head	1.418;
access;
symbols
	sid-snapshot-20180601:1.418
	sid-snapshot-20180501:1.418
	sid-snapshot-20180401:1.418
	sid-snapshot-20180301:1.418
	sid-snapshot-20180201:1.418
	sid-snapshot-20180101:1.418
	sid-snapshot-20171201:1.418
	sid-snapshot-20171101:1.418
	sid-snapshot-20171001:1.418
	sid-snapshot-20170901:1.418
	sid-snapshot-20170801:1.418
	sid-snapshot-20170701:1.418
	sid-snapshot-20170601:1.418
	sid-snapshot-20170501:1.418
	sid-snapshot-20170401:1.418
	sid-snapshot-20170301:1.418
	sid-snapshot-20170201:1.418
	sid-snapshot-20170101:1.418
	sid-snapshot-20161201:1.418
	sid-snapshot-20161101:1.418
	sid-snapshot-20160901:1.418
	sid-snapshot-20160801:1.418
	sid-snapshot-20160701:1.418
	sid-snapshot-20160601:1.418
	sid-snapshot-20160501:1.418
	sid-snapshot-20160401:1.418
	sid-snapshot-20160301:1.418
	sid-snapshot-20160201:1.418
	sid-snapshot-20160101:1.418
	sid-snapshot-20151201:1.418
	sid-snapshot-20151101:1.418
	sid-snapshot-20151001:1.418
	sid-snapshot-20150901:1.418
	sid-snapshot-20150801:1.418
	sid-snapshot-20150701:1.418
	sid-snapshot-20150601:1.418
	sid-snapshot-20150501:1.418
	sid-snapshot-20150401:1.418
	sid-snapshot-20150301:1.418
	sid-snapshot-20150201:1.418
	sid-snapshot-20150101:1.418
	sid-snapshot-20141201:1.418
	sid-snapshot-20141101:1.418
	sid-snapshot-20141001:1.418
	sid-snapshot-20140901:1.418
	sid-snapshot-20140801:1.418
	sid-snapshot-20140701:1.418
	sid-snapshot-20140601:1.418
	sid-snapshot-20140501:1.418
	sid-snapshot-20140401:1.418
	sid-snapshot-20140301:1.418
	sid-snapshot-20140201:1.418
	sid-snapshot-20140101:1.418
	sid-snapshot-20131201:1.418
	sid-snapshot-20131101:1.418
	sid-snapshot-20131001:1.418
	binutils-2_24-branch:1.418.0.2
	binutils-2_24-branchpoint:1.418
	binutils-2_21_1:1.339.2.11
	sid-snapshot-20130901:1.418
	gdb_7_6_1-2013-08-30-release:1.405
	sid-snapshot-20130801:1.417
	sid-snapshot-20130701:1.412
	sid-snapshot-20130601:1.411
	sid-snapshot-20130501:1.410
	gdb_7_6-2013-04-26-release:1.405
	sid-snapshot-20130401:1.408
	binutils-2_23_2:1.390.4.6
	gdb_7_6-branch:1.405.0.2
	gdb_7_6-2013-03-12-branchpoint:1.405
	sid-snapshot-20130301:1.405
	sid-snapshot-20130201:1.403
	sid-snapshot-20130101:1.397
	sid-snapshot-20121201:1.396
	gdb_7_5_1-2012-11-29-release:1.390
	binutils-2_23_1:1.390.4.3
	sid-snapshot-20121101:1.393
	binutils-2_23:1.390.4.3
	sid-snapshot-20121001:1.393
	sid-snapshot-20120901:1.392
	gdb_7_5-2012-08-17-release:1.390
	sid-snapshot-20120801:1.390
	binutils-2_23-branch:1.390.0.4
	binutils-2_23-branchpoint:1.390
	gdb_7_5-branch:1.390.0.2
	gdb_7_5-2012-07-18-branchpoint:1.390
	sid-snapshot-20120701:1.390
	sid-snapshot-20120601:1.386
	sid-snapshot-20120501:1.380
	binutils-2_22_branch:1.363.2.4.0.2
	gdb_7_4_1-2012-04-26-release:1.372
	sid-snapshot-20120401:1.378
	sid-snapshot-20120301:1.376
	sid-snapshot-20120201:1.375
	gdb_7_4-2012-01-24-release:1.372
	sid-snapshot-20120101:1.372
	gdb_7_4-branch:1.372.0.2
	gdb_7_4-2011-12-13-branchpoint:1.372
	sid-snapshot-20111201:1.371
	binutils-2_22:1.363.2.4
	sid-snapshot-20111101:1.369
	sid-snapshot-20111001:1.364
	binutils-2_22-branch:1.363.0.2
	binutils-2_22-branchpoint:1.363
	gdb_7_3_1-2011-09-04-release:1.346
	sid-snapshot-20110901:1.361
	sid-snapshot-20110801:1.357
	gdb_7_3-2011-07-26-release:1.346
	sid-snapshot-20110701:1.355
	sid-snapshot-20110601:1.352
	sid-snapshot-20110501:1.348
	gdb_7_3-branch:1.346.0.2
	gdb_7_3-2011-04-01-branchpoint:1.346
	sid-snapshot-20110401:1.346
	sid-snapshot-20110301:1.343
	sid-snapshot-20110201:1.340
	sid-snapshot-20110101:1.339
	binutils-2_21:1.339
	sid-snapshot-20101201:1.339
	binutils-2_21-branch:1.339.0.2
	binutils-2_21-branchpoint:1.339
	sid-snapshot-20101101:1.339
	sid-snapshot-20101001:1.337
	binutils-2_20_1:1.299.2.8
	gdb_7_2-2010-09-02-release:1.332
	sid-snapshot-20100901:1.336
	sid-snapshot-20100801:1.333
	gdb_7_2-branch:1.332.0.2
	gdb_7_2-2010-07-07-branchpoint:1.332
	sid-snapshot-20100701:1.332
	sid-snapshot-20100601:1.326
	sid-snapshot-20100501:1.326
	sid-snapshot-20100401:1.325
	gdb_7_1-2010-03-18-release:1.318
	sid-snapshot-20100301:1.319
	gdb_7_1-branch:1.318.0.2
	gdb_7_1-2010-02-18-branchpoint:1.318
	sid-snapshot-20100201:1.309
	sid-snapshot-20100101:1.306
	gdb_7_0_1-2009-12-22-release:1.299
	sid-snapshot-20091201:1.302
	sid-snapshot-20091101:1.301
	binutils-2_20:1.299.2.2
	gdb_7_0-2009-10-06-release:1.299
	sid-snapshot-20091001:1.301
	gdb_7_0-branch:1.299.0.4
	gdb_7_0-2009-09-16-branchpoint:1.299
	arc-sim-20090309:1.277
	binutils-arc-20081103-branch:1.288.0.6
	binutils-arc-20081103-branchpoint:1.288
	binutils-2_20-branch:1.299.0.2
	binutils-2_20-branchpoint:1.299
	sid-snapshot-20090901:1.299
	sid-snapshot-20090801:1.299
	msnyder-checkpoint-072509-branch:1.298.0.2
	msnyder-checkpoint-072509-branchpoint:1.298
	sid-snapshot-20090701:1.297
	dje-cgen-play1-branch:1.297.0.2
	dje-cgen-play1-branchpoint:1.297
	sid-snapshot-20090601:1.295
	sid-snapshot-20090501:1.293
	sid-snapshot-20090401:1.293
	arc-20081103-branch:1.288.0.4
	arc-20081103-branchpoint:1.288
	arc-insight_6_8-branch:1.277.0.6
	arc-insight_6_8-branchpoint:1.277
	insight_6_8-branch:1.277.0.4
	insight_6_8-branchpoint:1.277
	sid-snapshot-20090301:1.291
	binutils-2_19_1:1.286.2.1
	sid-snapshot-20090201:1.290
	sid-snapshot-20090101:1.290
	reverse-20081226-branch:1.290.0.2
	reverse-20081226-branchpoint:1.290
	sid-snapshot-20081201:1.289
	multiprocess-20081120-branch:1.288.0.2
	multiprocess-20081120-branchpoint:1.288
	sid-snapshot-20081101:1.288
	binutils-2_19:1.286.2.1
	sid-snapshot-20081001:1.286
	reverse-20080930-branch:1.286.0.4
	reverse-20080930-branchpoint:1.286
	binutils-2_19-branch:1.286.0.2
	binutils-2_19-branchpoint:1.286
	sid-snapshot-20080901:1.286
	sid-snapshot-20080801:1.284
	reverse-20080717-branch:1.284.0.2
	reverse-20080717-branchpoint:1.284
	sid-snapshot-20080701:1.284
	msnyder-reverse-20080609-branch:1.283.0.2
	msnyder-reverse-20080609-branchpoint:1.283
	drow-reverse-20070409-branch:1.260.0.2
	drow-reverse-20070409-branchpoint:1.260
	sid-snapshot-20080601:1.282
	sid-snapshot-20080501:1.279
	sid-snapshot-20080403:1.279
	sid-snapshot-20080401:1.279
	gdb_6_8-2008-03-27-release:1.277
	sid-snapshot-20080301:1.278
	gdb_6_8-branch:1.277.0.2
	gdb_6_8-2008-02-26-branchpoint:1.277
	sid-snapshot-20080201:1.274
	sid-snapshot-20080101:1.271
	sid-snapshot-20071201:1.271
	sid-snapshot-20071101:1.269
	gdb_6_7_1-2007-10-29-release:1.265
	gdb_6_7-2007-10-10-release:1.265
	sid-snapshot-20071001:1.268
	gdb_6_7-branch:1.265.0.2
	gdb_6_7-2007-09-07-branchpoint:1.265
	binutils-2_18:1.264.2.1
	binutils-2_18-branch:1.264.0.2
	binutils-2_18-branchpoint:1.264
	insight_6_6-20070208-release:1.252
	binutils-csl-coldfire-4_1-32:1.235.2.1
	binutils-csl-sourcerygxx-4_1-32:1.235.2.1
	gdb_6_6-2006-12-18-release:1.252
	binutils-csl-innovasic-fido-3_4_4-33:1.235.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.194.2.5
	binutils-csl-coldfire-4_1-30:1.235.2.1
	binutils-csl-sourcerygxx-4_1-30:1.235.2.1
	binutils-csl-coldfire-4_1-28:1.235.2.1
	binutils-csl-sourcerygxx-4_1-29:1.235.2.1
	binutils-csl-sourcerygxx-4_1-28:1.235.2.1
	gdb_6_6-branch:1.252.0.2
	gdb_6_6-2006-11-15-branchpoint:1.252
	binutils-csl-arm-2006q3-27:1.235.2.1
	binutils-csl-sourcerygxx-4_1-27:1.235.2.1
	binutils-csl-arm-2006q3-26:1.235.2.1
	binutils-csl-sourcerygxx-4_1-26:1.235.2.1
	binutils-csl-sourcerygxx-4_1-25:1.235.2.1
	binutils-csl-sourcerygxx-4_1-24:1.235.2.1
	binutils-csl-sourcerygxx-4_1-23:1.235.2.1
	insight_6_5-20061003-release:1.238.4.1
	gdb-csl-symbian-6_4_50_20060226-12:1.234
	binutils-csl-sourcerygxx-4_1-21:1.235.2.1
	binutils-csl-arm-2006q3-21:1.235.2.1
	binutils-csl-sourcerygxx-4_1-22:1.235.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.235.2.1
	binutils-csl-sourcerygxx-4_1-20:1.235.2.1
	binutils-csl-arm-2006q3-19:1.235.2.1
	binutils-csl-sourcerygxx-4_1-19:1.235.2.1
	binutils-csl-sourcerygxx-4_1-18:1.235.2.1
	binutils-csl-renesas-4_1-9:1.235.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.225
	binutils-csl-sourcerygxx-3_4_4-25:1.194.2.5
	nickrob-async-20060828-mergepoint:1.245
	gdb-csl-symbian-6_4_50_20060226-11:1.234
	binutils-csl-renesas-4_1-8:1.235
	binutils-csl-renesas-4_1-7:1.235
	binutils-csl-renesas-4_1-6:1.235
	gdb-csl-sourcerygxx-4_1-17:1.234
	binutils-csl-sourcerygxx-4_1-17:1.235
	gdb-csl-20060226-branch-local-2:1.234
	gdb-csl-sourcerygxx-4_1-14:1.234
	binutils-csl-sourcerygxx-4_1-14:1.235
	binutils-csl-sourcerygxx-4_1-15:1.235
	gdb-csl-sourcerygxx-4_1-13:1.234
	binutils-csl-sourcerygxx-4_1-13:1.235
	binutils-2_17:1.235.6.2
	gdb-csl-sourcerygxx-4_1-12:1.234
	binutils-csl-sourcerygxx-4_1-12:1.235
	gdb-csl-sourcerygxx-3_4_4-21:1.234
	binutils-csl-sourcerygxx-3_4_4-21:1.235
	gdb_6_5-20060621-release:1.238.4.1
	binutils-csl-wrs-linux-3_4_4-24:1.194
	binutils-csl-wrs-linux-3_4_4-23:1.194
	gdb-csl-sourcerygxx-4_1-9:1.234
	binutils-csl-sourcerygxx-4_1-9:1.235
	gdb-csl-sourcerygxx-4_1-8:1.234
	binutils-csl-sourcerygxx-4_1-8:1.235
	gdb-csl-sourcerygxx-4_1-7:1.234
	binutils-csl-sourcerygxx-4_1-7:1.235
	gdb-csl-arm-2006q1-6:1.234
	binutils-csl-arm-2006q1-6:1.235
	gdb-csl-sourcerygxx-4_1-6:1.234
	binutils-csl-sourcerygxx-4_1-6:1.235
	binutils-csl-wrs-linux-3_4_4-22:1.194
	gdb-csl-symbian-6_4_50_20060226-10:1.234
	gdb-csl-symbian-6_4_50_20060226-9:1.234
	gdb-csl-symbian-6_4_50_20060226-8:1.234
	gdb-csl-coldfire-4_1-11:1.234
	binutils-csl-coldfire-4_1-11:1.235
	gdb-csl-sourcerygxx-3_4_4-19:1.234
	binutils-csl-sourcerygxx-3_4_4-19:1.235
	gdb-csl-coldfire-4_1-10:1.234
	gdb_6_5-branch:1.238.0.4
	gdb_6_5-2006-05-14-branchpoint:1.238
	binutils-csl-coldfire-4_1-10:1.235
	gdb-csl-sourcerygxx-4_1-5:1.234
	binutils-csl-sourcerygxx-4_1-5:1.235
	nickrob-async-20060513-branch:1.238.0.2
	nickrob-async-20060513-branchpoint:1.238
	gdb-csl-sourcerygxx-4_1-4:1.234
	binutils-csl-sourcerygxx-4_1-4:1.235
	msnyder-reverse-20060502-branch:1.235.0.10
	msnyder-reverse-20060502-branchpoint:1.235
	binutils-csl-wrs-linux-3_4_4-21:1.194
	gdb-csl-morpho-4_1-4:1.234
	binutils-csl-morpho-4_1-4:1.235
	gdb-csl-sourcerygxx-3_4_4-17:1.234
	binutils-csl-sourcerygxx-3_4_4-17:1.235
	binutils-csl-wrs-linux-3_4_4-20:1.194
	readline_5_1-import-branch:1.235.0.8
	readline_5_1-import-branchpoint:1.235
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.234
	binutils-2_17-branch:1.235.0.6
	binutils-2_17-branchpoint:1.235
	gdb-csl-symbian-20060226-branch:1.234.0.6
	gdb-csl-symbian-20060226-branchpoint:1.234
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.234
	msnyder-reverse-20060331-branch:1.235.0.4
	msnyder-reverse-20060331-branchpoint:1.235
	binutils-csl-2_17-branch:1.235.0.2
	binutils-csl-2_17-branchpoint:1.235
	gdb-csl-available-20060303-branch:1.234.0.4
	gdb-csl-available-20060303-branchpoint:1.234
	gdb-csl-20060226-branch:1.234.0.2
	gdb-csl-20060226-branchpoint:1.234
	gdb_6_4-20051202-release:1.225
	msnyder-fork-checkpoint-branch:1.226.0.2
	msnyder-fork-checkpoint-branchpoint:1.226
	gdb-csl-gxxpro-6_3-branch:1.225.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.225
	gdb_6_4-branch:1.225.0.2
	gdb_6_4-2005-11-01-branchpoint:1.225
	gdb-csl-arm-20051020-branch:1.223.0.2
	gdb-csl-arm-20051020-branchpoint:1.223
	binutils-csl-gxxpro-3_4-branch:1.194.2.5.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.194.2.5
	binutils-2_16_1:1.194.2.5
	msnyder-tracepoint-checkpoint-branch:1.207.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.207
	gdb-csl-arm-20050325-2005-q1b:1.194
	binutils-csl-arm-2005q1b:1.194
	binutils-2_16:1.194.2.2
	gdb-csl-arm-20050325-2005-q1a:1.194
	binutils-csl-arm-2005q1a:1.194
	csl-arm-20050325-branch:1.194.0.6
	csl-arm-20050325-branchpoint:1.194
	binutils-csl-arm-2005q1-branch:1.194.0.4
	binutils-csl-arm-2005q1-branchpoint:1.194
	binutils-2_16-branch:1.194.0.2
	binutils-2_16-branchpoint:1.194
	csl-arm-2004-q3d:1.178
	gdb_6_3-20041109-release:1.175
	gdb_6_3-branch:1.175.0.2
	gdb_6_3-20041019-branchpoint:1.175
	csl-arm-2004-q3:1.175
	drow_intercu-merge-20040921:1.175
	drow_intercu-merge-20040915:1.173
	jimb-gdb_6_2-e500-branch:1.148.0.6
	jimb-gdb_6_2-e500-branchpoint:1.148
	gdb_6_2-20040730-release:1.148
	gdb_6_2-branch:1.148.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.148
	gdb_6_1_1-20040616-release:1.143
	binutils-2_15:1.143.6.1
	binutils-2_15-branchpoint:1.143
	csl-arm-2004-q1a:1.147
	csl-arm-2004-q1:1.147
	gdb_6_1-2004-04-05-release:1.143
	drow_intercu-merge-20040402:1.147
	drow_intercu-merge-20040327:1.146
	ezannoni_pie-20040323-branch:1.144.0.2
	ezannoni_pie-20040323-branchpoint:1.144
	cagney_tramp-20040321-mergepoint:1.143
	cagney_tramp-20040309-branch:1.143.0.12
	cagney_tramp-20040309-branchpoint:1.143
	gdb_6_1-branch:1.143.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.143
	drow_intercu-20040221-branch:1.143.0.8
	drow_intercu-20040221-branchpoint:1.143
	binutils-2_15-branch:1.143.0.6
	cagney_bfdfile-20040213-branch:1.143.0.4
	cagney_bfdfile-20040213-branchpoint:1.143
	drow-cplus-merge-20040208:1.143
	carlton_dictionary-20040126-merge:1.143
	cagney_bigcore-20040122-branch:1.143.0.2
	cagney_bigcore-20040122-branchpoint:1.143
	drow-cplus-merge-20040113:1.142
	csl-arm-2003-q4:1.142
	drow-cplus-merge-20031224:1.142
	drow-cplus-merge-20031220:1.142
	carlton_dictionary-20031215-merge:1.142
	drow-cplus-merge-20031214:1.142
	carlton-dictionary-20031111-merge:1.137
	gdb_6_0-2003-10-04-release:1.114
	kettenis_sparc-20030918-branch:1.130.0.6
	kettenis_sparc-20030918-branchpoint:1.130
	carlton_dictionary-20030917-merge:1.130
	ezannoni_pie-20030916-branchpoint:1.130
	ezannoni_pie-20030916-branch:1.130.0.4
	cagney_x86i386-20030821-branch:1.130.0.2
	cagney_x86i386-20030821-branchpoint:1.130
	carlton_dictionary-20030805-merge:1.123
	carlton_dictionary-20030627-merge:1.115
	gdb_6_0-branch:1.114.0.2
	gdb_6_0-2003-06-23-branchpoint:1.114
	jimb-ppc64-linux-20030613-branch:1.101.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.101
	binutils-2_14:1.92.14.1
	cagney_convert-20030606-branch:1.99.0.2
	cagney_convert-20030606-branchpoint:1.99
	cagney_writestrings-20030508-branch:1.95.0.4
	cagney_writestrings-20030508-branchpoint:1.95
	jimb-ppc64-linux-20030528-branch:1.98.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.98
	carlton_dictionary-20030523-merge:1.98
	cagney_fileio-20030521-branch:1.98.0.2
	cagney_fileio-20030521-branchpoint:1.98
	kettenis_i386newframe-20030517-mergepoint:1.98
	jimb-ppc64-linux-20030509-branch:1.95.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.95
	kettenis_i386newframe-20030504-mergepoint:1.93
	carlton_dictionary-20030430-merge:1.92
	binutils-2_14-branch:1.92.0.14
	binutils-2_14-branchpoint:1.92
	kettenis_i386newframe-20030419-branch:1.92.0.12
	kettenis_i386newframe-20030419-branchpoint:1.92
	carlton_dictionary-20030416-merge:1.92
	cagney_frameaddr-20030409-mergepoint:1.92
	kettenis_i386newframe-20030406-branch:1.92.0.10
	kettenis_i386newframe-20030406-branchpoint:1.92
	cagney_frameaddr-20030403-branchpoint:1.92
	cagney_frameaddr-20030403-branch:1.92.0.8
	cagney_framebase-20030330-mergepoint:1.92
	cagney_framebase-20030326-branch:1.92.0.6
	cagney_framebase-20030326-branchpoint:1.92
	cagney_lazyid-20030317-branch:1.92.0.4
	cagney_lazyid-20030317-branchpoint:1.92
	kettenis-i386newframe-20030316-mergepoint:1.92
	offbyone-20030313-branch:1.92.0.2
	offbyone-20030313-branchpoint:1.92
	kettenis-i386newframe-20030308-branch:1.91.0.2
	kettenis-i386newframe-20030308-branchpoint:1.91
	carlton_dictionary-20030305-merge:1.89
	cagney_offbyone-20030303-branch:1.89.0.2
	cagney_offbyone-20030303-branchpoint:1.89
	carlton_dictionary-20030207-merge:1.81
	interps-20030202-branch:1.79.0.2
	interps-20030202-branchpoint:1.79
	cagney-unwind-20030108-branch:1.76.0.2
	cagney-unwind-20030108-branchpoint:1.76
	binutils-2_13_2_1:1.59.2.10
	binutils-2_13_2:1.59.2.10
	carlton_dictionary-20021223-merge:1.76
	gdb_5_3-2002-12-12-release:1.63
	carlton_dictionary-20021115-merge:1.71
	binutils-2_13_1:1.59.2.8
	kseitz_interps-20021105-merge:1.69
	kseitz_interps-20021103-merge:1.69
	drow-cplus-merge-20021020:1.69
	drow-cplus-merge-20021025:1.69
	carlton_dictionary-20021025-merge:1.69
	carlton_dictionary-20021011-merge:1.69
	drow-cplus-branch:1.64.0.2
	drow-cplus-branchpoint:1.64
	kseitz_interps-20020930-merge:1.64
	carlton_dictionary-20020927-merge:1.64
	carlton_dictionary-branch:1.63.0.10
	carlton_dictionary-20020920-branchpoint:1.63
	sid-20020905-branchpoint:1.63
	sid-20020905-branch:1.63.0.8
	gdb_5_3-branch:1.63.0.6
	gdb_5_3-2002-09-04-branchpoint:1.63
	kseitz_interps-20020829-merge:1.63
	cagney_sysregs-20020825-branch:1.63.0.4
	cagney_sysregs-20020825-branchpoint:1.63
	readline_4_3-import-branch:1.63.0.2
	readline_4_3-import-branchpoint:1.63
	binutils-2_13:1.59
	gdb_5_2_1-2002-07-23-release:1.31
	binutils-2_13-branchpoint:1.59
	binutils-2_13-branch:1.59.0.2
	kseitz_interps-20020528-branch:1.45.0.2
	kseitz_interps-20020528-branchpoint:1.45
	cagney_regbuf-20020515-branch:1.39.0.2
	cagney_regbuf-20020515-branchpoint:1.39
	binutils-2_12_1:1.26.2.5
	jimb-macro-020506-branch:1.37.0.2
	jimb-macro-020506-branchpoint:1.37
	gdb_5_2-2002-04-29-release:1.31
	binutils-2_12:1.26.2.3
	gdb_5_2-branch:1.31.0.2
	gdb_5_2-2002-03-03-branchpoint:1.31
	binutils-2_12-branch:1.26.0.2
	binutils-2_12-branchpoint:1.26
	cygnus_cvs_20020108_pre:1.15
	binutils_latest_snapshot:1.418;
locks; strict;
comment	@ * @;


1.418
date	2013.08.27.01.06.43;	author amodra;	state Exp;
branches;
next	1.417;

1.417
date	2013.07.25.15.18.26;	author amodra;	state Exp;
branches;
next	1.416;

1.416
date	2013.07.03.09.42.56;	author amodra;	state Exp;
branches;
next	1.415;

1.415
date	2013.07.03.02.22.35;	author amodra;	state Exp;
branches;
next	1.414;

1.414
date	2013.07.03.00.45.50;	author amodra;	state Exp;
branches;
next	1.413;

1.413
date	2013.07.02.00.25.07;	author amodra;	state Exp;
branches;
next	1.412;

1.412
date	2013.07.01.03.45.05;	author amodra;	state Exp;
branches;
next	1.411;

1.411
date	2013.05.06.09.32.55;	author amodra;	state Exp;
branches;
next	1.410;

1.410
date	2013.04.22.03.11.39;	author amodra;	state Exp;
branches;
next	1.409;

1.409
date	2013.04.06.06.44.45;	author amodra;	state Exp;
branches;
next	1.408;

1.408
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.407;

1.407
date	2013.03.28.13.36.32;	author amodra;	state Exp;
branches;
next	1.406;

1.406
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches;
next	1.405;

1.405
date	2013.02.21.03.02.30;	author amodra;	state Exp;
branches;
next	1.404;

1.404
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.403;

1.403
date	2013.02.01.11.06.37;	author amodra;	state Exp;
branches;
next	1.402;

1.402
date	2013.01.31.06.28.46;	author amodra;	state Exp;
branches;
next	1.401;

1.401
date	2013.01.30.22.31.31;	author amodra;	state Exp;
branches;
next	1.400;

1.400
date	2013.01.28.12.30.17;	author amodra;	state Exp;
branches;
next	1.399;

1.399
date	2013.01.15.06.13.23;	author amodra;	state Exp;
branches;
next	1.398;

1.398
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.397;

1.397
date	2012.12.05.04.58.51;	author amodra;	state Exp;
branches;
next	1.396;

1.396
date	2012.11.06.05.18.03;	author amodra;	state Exp;
branches;
next	1.395;

1.395
date	2012.11.06.03.44.51;	author amodra;	state Exp;
branches;
next	1.394;

1.394
date	2012.11.05.05.17.34;	author amodra;	state Exp;
branches;
next	1.393;

1.393
date	2012.09.12.22.56.05;	author dougkwan;	state Exp;
branches;
next	1.392;

1.392
date	2012.08.31.02.42.57;	author amodra;	state Exp;
branches;
next	1.391;

1.391
date	2012.08.28.20.17.56;	author macro;	state Exp;
branches;
next	1.390;

1.390
date	2012.06.29.14.46.01;	author amodra;	state Exp;
branches
	1.390.4.1;
next	1.389;

1.389
date	2012.06.26.01.40.59;	author amodra;	state Exp;
branches;
next	1.388;

1.388
date	2012.06.22.05.53.04;	author amodra;	state Exp;
branches;
next	1.387;

1.387
date	2012.06.03.04.08.07;	author amodra;	state Exp;
branches;
next	1.386;

1.386
date	2012.06.01.12.26.55;	author amodra;	state Exp;
branches;
next	1.385;

1.385
date	2012.05.25.01.12.20;	author amodra;	state Exp;
branches;
next	1.384;

1.384
date	2012.05.24.06.20.52;	author amodra;	state Exp;
branches;
next	1.383;

1.383
date	2012.05.17.02.43.34;	author amodra;	state Exp;
branches;
next	1.382;

1.382
date	2012.05.16.16.38.29;	author nickc;	state Exp;
branches;
next	1.381;

1.381
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.380;

1.380
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.379;

1.379
date	2012.04.11.14.16.09;	author nickc;	state Exp;
branches;
next	1.378;

1.378
date	2012.03.23.06.41.21;	author amodra;	state Exp;
branches;
next	1.377;

1.377
date	2012.03.13.06.04.35;	author amodra;	state Exp;
branches;
next	1.376;

1.376
date	2012.02.07.07.04.04;	author amodra;	state Exp;
branches;
next	1.375;

1.375
date	2012.01.23.06.16.38;	author amodra;	state Exp;
branches;
next	1.374;

1.374
date	2012.01.16.22.30.19;	author amodra;	state Exp;
branches;
next	1.373;

1.373
date	2012.01.11.09.28.44;	author amodra;	state Exp;
branches;
next	1.372;

1.372
date	2011.12.03.00.55.50;	author amodra;	state Exp;
branches;
next	1.371;

1.371
date	2011.11.21.13.18.07;	author amodra;	state Exp;
branches;
next	1.370;

1.370
date	2011.11.08.13.06.01;	author amodra;	state Exp;
branches;
next	1.369;

1.369
date	2011.10.26.09.47.58;	author nickc;	state Exp;
branches;
next	1.368;

1.368
date	2011.10.20.16.27.03;	author nickc;	state Exp;
branches;
next	1.367;

1.367
date	2011.10.19.07.17.18;	author amodra;	state Exp;
branches;
next	1.366;

1.366
date	2011.10.17.08.27.45;	author amodra;	state Exp;
branches;
next	1.365;

1.365
date	2011.10.10.13.21.07;	author amodra;	state Exp;
branches;
next	1.364;

1.364
date	2011.09.30.05.11.01;	author amodra;	state Exp;
branches;
next	1.363;

1.363
date	2011.09.07.13.56.09;	author amodra;	state Exp;
branches
	1.363.2.1;
next	1.362;

1.362
date	2011.09.06.07.41.24;	author amodra;	state Exp;
branches;
next	1.361;

1.361
date	2011.08.19.08.12.08;	author amodra;	state Exp;
branches;
next	1.360;

1.360
date	2011.08.14.08.11.56;	author amodra;	state Exp;
branches;
next	1.359;

1.359
date	2011.08.05.06.22.21;	author amodra;	state Exp;
branches;
next	1.358;

1.358
date	2011.08.02.04.44.45;	author amodra;	state Exp;
branches;
next	1.357;

1.357
date	2011.07.26.01.57.16;	author amodra;	state Exp;
branches;
next	1.356;

1.356
date	2011.07.14.03.28.21;	author amodra;	state Exp;
branches;
next	1.355;

1.355
date	2011.07.01.07.49.08;	author amodra;	state Exp;
branches;
next	1.354;

1.354
date	2011.06.13.00.59.12;	author amodra;	state Exp;
branches;
next	1.353;

1.353
date	2011.06.03.10.11.06;	author nickc;	state Exp;
branches;
next	1.352;

1.352
date	2011.05.23.06.22.51;	author amodra;	state Exp;
branches;
next	1.351;

1.351
date	2011.05.23.06.14.21;	author amodra;	state Exp;
branches;
next	1.350;

1.350
date	2011.05.10.06.13.07;	author jkratoch;	state Exp;
branches;
next	1.349;

1.349
date	2011.05.04.00.31.41;	author amodra;	state Exp;
branches;
next	1.348;

1.348
date	2011.04.17.18.38.43;	author jkratoch;	state Exp;
branches;
next	1.347;

1.347
date	2011.04.11.08.13.17;	author nickc;	state Exp;
branches;
next	1.346;

1.346
date	2011.03.23.15.25.02;	author amodra;	state Exp;
branches;
next	1.345;

1.345
date	2011.03.10.09.26.18;	author amodra;	state Exp;
branches;
next	1.344;

1.344
date	2011.03.10.09.11.15;	author amodra;	state Exp;
branches;
next	1.343;

1.343
date	2011.02.15.04.07.43;	author amodra;	state Exp;
branches;
next	1.342;

1.342
date	2011.02.09.08.16.00;	author amodra;	state Exp;
branches;
next	1.341;

1.341
date	2011.02.08.02.54.42;	author amodra;	state Exp;
branches;
next	1.340;

1.340
date	2011.01.31.22.38.26;	author amodra;	state Exp;
branches;
next	1.339;

1.339
date	2010.10.25.15.54.15;	author drow;	state Exp;
branches
	1.339.2.1;
next	1.338;

1.338
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.337;

1.337
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.336;

1.336
date	2010.08.25.14.53.44;	author hjl;	state Exp;
branches;
next	1.335;

1.335
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.334;

1.334
date	2010.08.05.14.37.30;	author amodra;	state Exp;
branches;
next	1.333;

1.333
date	2010.07.29.07.35.58;	author amodra;	state Exp;
branches;
next	1.332;

1.332
date	2010.07.01.09.48.26;	author amodra;	state Exp;
branches;
next	1.331;

1.331
date	2010.07.01.04.12.29;	author amodra;	state Exp;
branches;
next	1.330;

1.330
date	2010.06.27.08.37.22;	author amodra;	state Exp;
branches;
next	1.329;

1.329
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.328;

1.328
date	2010.06.25.05.20.55;	author amodra;	state Exp;
branches;
next	1.327;

1.327
date	2010.06.25.03.46.04;	author amodra;	state Exp;
branches;
next	1.326;

1.326
date	2010.04.13.04.05.29;	author amodra;	state Exp;
branches;
next	1.325;

1.325
date	2010.03.31.07.53.40;	author amodra;	state Exp;
branches;
next	1.324;

1.324
date	2010.03.26.00.35.57;	author amodra;	state Exp;
branches;
next	1.323;

1.323
date	2010.03.16.00.40.36;	author amodra;	state Exp;
branches;
next	1.322;

1.322
date	2010.03.15.01.59.56;	author amodra;	state Exp;
branches;
next	1.321;

1.321
date	2010.03.14.07.05.36;	author amodra;	state Exp;
branches;
next	1.320;

1.320
date	2010.03.12.22.31.16;	author amodra;	state Exp;
branches;
next	1.319;

1.319
date	2010.02.19.05.07.49;	author hjl;	state Exp;
branches;
next	1.318;

1.318
date	2010.02.09.12.31.01;	author amodra;	state Exp;
branches;
next	1.317;

1.317
date	2010.02.09.12.08.19;	author amodra;	state Exp;
branches;
next	1.316;

1.316
date	2010.02.09.11.54.52;	author amodra;	state Exp;
branches;
next	1.315;

1.315
date	2010.02.09.11.35.37;	author amodra;	state Exp;
branches;
next	1.314;

1.314
date	2010.02.08.14.09.25;	author amodra;	state Exp;
branches;
next	1.313;

1.313
date	2010.02.08.13.50.16;	author amodra;	state Exp;
branches;
next	1.312;

1.312
date	2010.02.08.13.16.24;	author amodra;	state Exp;
branches;
next	1.311;

1.311
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.310;

1.310
date	2010.02.03.12.03.34;	author amodra;	state Exp;
branches;
next	1.309;

1.309
date	2010.01.27.12.44.07;	author amodra;	state Exp;
branches;
next	1.308;

1.308
date	2010.01.25.06.47.15;	author amodra;	state Exp;
branches;
next	1.307;

1.307
date	2010.01.08.05.55.10;	author amodra;	state Exp;
branches;
next	1.306;

1.306
date	2009.12.21.10.21.01;	author amodra;	state Exp;
branches;
next	1.305;

1.305
date	2009.12.17.00.07.38;	author amodra;	state Exp;
branches;
next	1.304;

1.304
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.303;

1.303
date	2009.12.03.08.31.29;	author amodra;	state Exp;
branches;
next	1.302;

1.302
date	2009.11.18.12.42.51;	author amodra;	state Exp;
branches;
next	1.301;

1.301
date	2009.09.21.11.51.01;	author amodra;	state Exp;
branches;
next	1.300;

1.300
date	2009.09.18.03.30.33;	author amodra;	state Exp;
branches;
next	1.299;

1.299
date	2009.07.29.14.56.38;	author amodra;	state Exp;
branches
	1.299.2.1;
next	1.298;

1.298
date	2009.07.10.12.19.57;	author amodra;	state Exp;
branches;
next	1.297;

1.297
date	2009.06.22.00.00.32;	author amodra;	state Exp;
branches;
next	1.296;

1.296
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.295;

1.295
date	2009.05.21.14.15.48;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2009.05.21.13.49.11;	author amodra;	state Exp;
branches;
next	1.293;

1.293
date	2009.03.23.13.35.46;	author amodra;	state Exp;
branches;
next	1.292;

1.292
date	2009.03.04.05.50.49;	author amodra;	state Exp;
branches;
next	1.291;

1.291
date	2009.02.15.12.14.14;	author amodra;	state Exp;
branches;
next	1.290;

1.290
date	2008.12.11.10.14.40;	author amodra;	state Exp;
branches;
next	1.289;

1.289
date	2008.11.25.13.03.56;	author nickc;	state Exp;
branches;
next	1.288;

1.288
date	2008.10.20.11.05.47;	author amodra;	state Exp;
branches;
next	1.287;

1.287
date	2008.10.09.00.55.52;	author amodra;	state Exp;
branches;
next	1.286;

1.286
date	2008.08.12.13.12.49;	author amodra;	state Exp;
branches
	1.286.2.1;
next	1.285;

1.285
date	2008.08.11.14.38.40;	author amodra;	state Exp;
branches;
next	1.284;

1.284
date	2008.06.30.20.51.58;	author rsandifo;	state Exp;
branches;
next	1.283;

1.283
date	2008.06.05.00.30.09;	author amodra;	state Exp;
branches;
next	1.282;

1.282
date	2008.05.14.16.00.38;	author uweigand;	state Exp;
branches;
next	1.281;

1.281
date	2008.05.14.02.21.19;	author amodra;	state Exp;
branches;
next	1.280;

1.280
date	2008.05.12.12.47.47;	author amodra;	state Exp;
branches;
next	1.279;

1.279
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.278;

1.278
date	2008.03.01.06.52.32;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2008.02.15.08.27.19;	author amodra;	state Exp;
branches;
next	1.276;

1.276
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.275;

1.275
date	2008.02.12.11.32.31;	author nickc;	state Exp;
branches;
next	1.274;

1.274
date	2008.01.19.10.07.25;	author amodra;	state Exp;
branches;
next	1.273;

1.273
date	2008.01.15.07.25.49;	author amodra;	state Exp;
branches;
next	1.272;

1.272
date	2008.01.11.09.07.04;	author gingold;	state Exp;
branches;
next	1.271;

1.271
date	2007.11.15.23.47.58;	author uweigand;	state Exp;
branches;
next	1.270;

1.270
date	2007.11.06.13.49.18;	author amodra;	state Exp;
branches;
next	1.269;

1.269
date	2007.10.23.12.54.17;	author amodra;	state Exp;
branches;
next	1.268;

1.268
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.267;

1.267
date	2007.09.26.03.07.45;	author amodra;	state Exp;
branches;
next	1.266;

1.266
date	2007.09.08.13.46.15;	author amodra;	state Exp;
branches;
next	1.265;

1.265
date	2007.08.13.00.20.58;	author amodra;	state Exp;
branches;
next	1.264;

1.264
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches
	1.264.2.1;
next	1.263;

1.263
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.262;

1.262
date	2007.05.10.11.45.07;	author jakub;	state Exp;
branches;
next	1.261;

1.261
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.259;

1.259
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.258;

1.258
date	2007.02.19.12.44.18;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2007.02.13.01.53.02;	author amodra;	state Exp;
branches;
next	1.256;

1.256
date	2007.02.12.12.02.58;	author amodra;	state Exp;
branches;
next	1.255;

1.255
date	2007.02.01.05.35.58;	author amodra;	state Exp;
branches;
next	1.254;

1.254
date	2006.12.23.09.57.38;	author jakub;	state Exp;
branches;
next	1.253;

1.253
date	2006.11.22.00.12.30;	author gkm;	state Exp;
branches;
next	1.252;

1.252
date	2006.11.07.03.34.52;	author amodra;	state Exp;
branches;
next	1.251;

1.251
date	2006.11.07.03.24.13;	author amodra;	state Exp;
branches;
next	1.250;

1.250
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.249;

1.249
date	2006.10.23.03.20.56;	author amodra;	state Exp;
branches;
next	1.248;

1.248
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.247;

1.247
date	2006.10.01.13.59.21;	author amodra;	state Exp;
branches;
next	1.246;

1.246
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.245;

1.245
date	2006.08.22.12.06.10;	author amodra;	state Exp;
branches;
next	1.244;

1.244
date	2006.08.17.08.21.06;	author amodra;	state Exp;
branches;
next	1.243;

1.243
date	2006.08.17.08.09.52;	author amodra;	state Exp;
branches;
next	1.242;

1.242
date	2006.08.08.14.21.46;	author amodra;	state Exp;
branches;
next	1.241;

1.241
date	2006.06.23.02.58.01;	author amodra;	state Exp;
branches;
next	1.240;

1.240
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.239;

1.239
date	2006.05.23.01.36.07;	author amodra;	state Exp;
branches;
next	1.238;

1.238
date	2006.05.09.03.38.30;	author bje;	state Exp;
branches
	1.238.4.1;
next	1.237;

1.237
date	2006.05.05.13.07.30;	author amodra;	state Exp;
branches;
next	1.236;

1.236
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.235;

1.235
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.235.2.1
	1.235.6.1;
next	1.234;

1.234
date	2006.02.17.12.52.58;	author amodra;	state Exp;
branches;
next	1.233;

1.233
date	2006.02.17.04.49.34;	author amodra;	state Exp;
branches;
next	1.232;

1.232
date	2006.01.17.15.32.41;	author amodra;	state Exp;
branches;
next	1.231;

1.231
date	2006.01.17.13.00.16;	author amodra;	state Exp;
branches;
next	1.230;

1.230
date	2006.01.01.00.06.24;	author jakub;	state Exp;
branches;
next	1.229;

1.229
date	2005.12.31.12.55.10;	author amodra;	state Exp;
branches;
next	1.228;

1.228
date	2005.12.13.05.39.34;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2005.12.12.03.59.52;	author amodra;	state Exp;
branches;
next	1.226;

1.226
date	2005.11.18.04.52.57;	author amodra;	state Exp;
branches;
next	1.225;

1.225
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.224;

1.224
date	2005.10.23.13.12.09;	author amodra;	state Exp;
branches;
next	1.223;

1.223
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.222;

1.222
date	2005.09.30.07.32.50;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2005.09.19.09.35.26;	author amodra;	state Exp;
branches;
next	1.220;

1.220
date	2005.08.18.01.28.24;	author amodra;	state Exp;
branches;
next	1.219;

1.219
date	2005.08.16.10.13.42;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2005.07.12.12.03.57;	author amodra;	state Exp;
branches;
next	1.217;

1.217
date	2005.07.08.06.20.02;	author amodra;	state Exp;
branches;
next	1.216;

1.216
date	2005.07.08.00.26.51;	author hjl;	state Exp;
branches;
next	1.215;

1.215
date	2005.07.05.15.07.43;	author nickc;	state Exp;
branches;
next	1.214;

1.214
date	2005.07.05.09.44.18;	author jakub;	state Exp;
branches;
next	1.213;

1.213
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.212;

1.212
date	2005.07.04.01.53.40;	author amodra;	state Exp;
branches;
next	1.211;

1.211
date	2005.06.20.18.12.08;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2005.06.06.13.16.15;	author amodra;	state Exp;
branches;
next	1.209;

1.209
date	2005.06.06.12.59.54;	author amodra;	state Exp;
branches;
next	1.208;

1.208
date	2005.06.02.13.13.54;	author amodra;	state Exp;
branches;
next	1.207;

1.207
date	2005.05.19.08.26.54;	author amodra;	state Exp;
branches;
next	1.206;

1.206
date	2005.05.09.10.30.40;	author amodra;	state Exp;
branches;
next	1.205;

1.205
date	2005.05.07.13.22.52;	author hjl;	state Exp;
branches;
next	1.204;

1.204
date	2005.05.07.02.55.54;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2005.05.05.14.33.55;	author hjl;	state Exp;
branches;
next	1.202;

1.202
date	2005.05.04.15.53.24;	author nickc;	state Exp;
branches;
next	1.201;

1.201
date	2005.05.04.11.00.17;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.199;

1.199
date	2005.04.27.20.16.07;	author hjl;	state Exp;
branches;
next	1.198;

1.198
date	2005.04.05.12.16.38;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2005.04.01.02.50.15;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2005.04.01.02.40.35;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2005.04.01.02.35.41;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2005.03.05.11.44.14;	author amodra;	state Exp;
branches
	1.194.2.1;
next	1.193;

1.193
date	2005.02.28.23.00.40;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2005.02.16.02.20.10;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2005.02.11.14.18.15;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2005.02.11.03.47.40;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2005.02.06.10.29.39;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2005.02.03.14.48.53;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2005.02.01.04.22.37;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2005.02.01.01.11.13;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2005.01.11.09.32.52;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2005.01.06.09.03.52;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2005.01.06.08.41.05;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2004.12.19.23.24.46;	author amodra;	state Exp;
branches;
next	1.181;

1.181
date	2004.12.11.03.56.43;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2004.12.10.14.04.57;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2004.12.10.13.18.39;	author amodra;	state Exp;
branches;
next	1.178;

1.178
date	2004.11.04.11.55.12;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2004.10.21.15.28.25;	author hjl;	state Exp;
branches;
next	1.176;

1.176
date	2004.10.19.12.00.58;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2004.09.16.14.52.06;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2004.09.07.13.40.37;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2004.09.06.12.37.12;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2004.09.02.04.43.36;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2004.08.28.08.54.34;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2004.08.28.03.05.17;	author amodra;	state Exp;
branches;
next	1.168;

1.168
date	2004.08.27.14.54.41;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2004.08.27.07.54.00;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2004.08.19.08.30.16;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2004.08.19.07.47.24;	author jakub;	state Exp;
branches;
next	1.164;

1.164
date	2004.08.18.10.11.02;	author amodra;	state Exp;
branches;
next	1.163;

1.163
date	2004.08.17.09.07.35;	author jakub;	state Exp;
branches;
next	1.162;

1.162
date	2004.08.17.07.05.52;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2004.08.17.05.38.28;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2004.08.17.01.25.21;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2004.08.10.11.23.01;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2004.08.09.06.02.02;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2004.08.09.05.38.48;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2004.08.09.05.12.14;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2004.08.09.03.14.11;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2004.08.09.02.59.15;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2004.08.09.00.54.28;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2004.08.09.00.40.48;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2004.08.09.00.22.53;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2004.07.27.05.16.51;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2004.03.25.12.48.38;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2004.01.13.00.31.07;	author amodra;	state Exp;
branches
	1.143.6.1
	1.143.8.1;
next	1.142;

1.142
date	2003.12.08.13.05.11;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.140;

1.140
date	2003.11.25.02.14.25;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2003.11.18.04.14.15;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.17.21.31.11;	author drow;	state Exp;
branches;
next	1.137;

1.137
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2003.11.04.08.51.36;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2003.11.04.06.16.36;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.29.13.06.06;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.23.09.02.33;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2003.08.16.13.42.43;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2003.08.12.05.58.10;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.126;

1.126
date	2003.08.11.11.31.01;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2003.08.06.12.23.37;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2003.07.31.14.34.13;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2003.07.29.06.47.10;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2003.07.27.09.05.08;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.119;

1.119
date	2003.07.21.00.24.10;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2003.07.10.00.37.26;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.116;

1.116
date	2003.07.02.07.41.51;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.25.06.40.21;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.20.12.35.30;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2003.06.20.05.30.45;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2003.06.19.15.11.26;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2003.06.19.13.50.35;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2003.06.19.11.49.01;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2003.06.18.03.26.22;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.17.14.22.46;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.17.13.43.02;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.06.17.12.39.41;	author jakub;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.17.12.37.26;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.17.09.10.41;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.17.00.25.45;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.16.10.50.22;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.10.07.44.09;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.08.14.06.38;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.17.06.16.03;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2003.05.15.06.35.43;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.13.14.09.50;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2003.05.09.02.27.06;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2003.05.05.14.12.05;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2003.05.01.10.22.46;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2003.03.10.23.25.13;	author amodra;	state Exp;
branches
	1.92.12.1
	1.92.14.1;
next	1.91;

1.91
date	2003.03.06.23.26.20;	author amodra;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2003.03.06.11.32.43;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2003.02.19.11.44.15;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.18.12.54.15;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.17.22.57.54;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.13.23.48.31;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2003.02.11.03.02.46;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2003.02.09.23.17.57;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.09.04.36.23;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.05.15.49.04;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.04.14.50.50;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.16.04.09.36;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.09.22.51.37;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.12.10.17.14;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.04.11.08.16;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.19.06.32.35;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.12.07.55.43;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2002.11.07.12.45.29;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2002.10.11.12.59.06;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.11.04.36.13;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2002.10.08.09.51.09;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2002.10.07.00.06.01;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.26.05.19.12;	author amodra;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2002.08.22.01.27.19;	author amodra;	state Exp;
branches
	1.63.10.1;
next	1.62;

1.62
date	2002.08.07.05.23.09;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2002.08.06.09.09.08;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.07.11.05.33.28;	author amodra;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2002.07.10.11.46.19;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.07.10.10.28.44;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.07.07.09.10.41;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.01.08.06.45;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.27.11.29.15;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.25.09.40.43;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.07.10.21.53;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.31.04.19.32;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.29.05.00.01;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.25.10.13.23;	author amodra;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2002.05.24.04.07.38;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.22.04.22.08;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.22.00.04.40;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.20.13.12.41;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.17.13.25.04;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.09.11.40.16;	author amodra;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.05.07.00.16.52;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.04.12.01.01;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.02.12.35.24;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.02.09.48.13;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.01.02.34.20;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.25.03.44.16;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.19.12.40.27;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.18.12.40.24;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.12.06.34.57;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.12.06.31.29;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.05.00.00.23;	author amodra;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2002.01.31.04.13.14;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.30.03.47.37;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.29.14.52.12;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.29.14.04.04;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.23.11.21.18;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.22.09.05.07;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.21.12.15.07;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.18.01.22.02;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.16.07.32.04;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.16.05.50.03;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.10.00.23.35;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.01.05.35.10;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.15.09.45.48;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.15.07.28.45;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.03.08.33.18;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.02.09.22.46;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.29.06.49.16;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.27.10.22.03;	author amodra;	state Exp;
branches;
next	;

1.390.4.1
date	2012.09.04.14.37.52;	author gingold;	state Exp;
branches;
next	1.390.4.2;

1.390.4.2
date	2012.09.07.03.09.09;	author amodra;	state Exp;
branches;
next	1.390.4.3;

1.390.4.3
date	2012.09.13.16.54.54;	author dougkwan;	state Exp;
branches;
next	1.390.4.4;

1.390.4.4
date	2013.01.21.13.48.36;	author amodra;	state Exp;
branches;
next	1.390.4.5;

1.390.4.5
date	2013.01.31.07.29.28;	author amodra;	state Exp;
branches;
next	1.390.4.6;

1.390.4.6
date	2013.02.01.11.48.07;	author amodra;	state Exp;
branches;
next	;

1.363.2.1
date	2011.10.25.02.46.09;	author amodra;	state Exp;
branches;
next	1.363.2.2;

1.363.2.2
date	2011.10.25.03.01.41;	author amodra;	state Exp;
branches;
next	1.363.2.3;

1.363.2.3
date	2011.10.25.03.09.34;	author amodra;	state Exp;
branches;
next	1.363.2.4;

1.363.2.4
date	2011.11.08.13.46.36;	author amodra;	state Exp;
branches;
next	1.363.2.5;

1.363.2.5
date	2011.12.03.00.58.02;	author amodra;	state Exp;
branches;
next	1.363.2.6;

1.363.2.6
date	2012.05.11.12.24.29;	author nickc;	state Exp;
branches;
next	;

1.339.2.1
date	2011.01.31.22.44.21;	author amodra;	state Exp;
branches;
next	1.339.2.2;

1.339.2.2
date	2011.02.08.03.00.28;	author amodra;	state Exp;
branches;
next	1.339.2.3;

1.339.2.3
date	2011.02.09.08.16.34;	author amodra;	state Exp;
branches;
next	1.339.2.4;

1.339.2.4
date	2011.02.15.04.08.10;	author amodra;	state Exp;
branches;
next	1.339.2.5;

1.339.2.5
date	2011.03.10.09.11.31;	author amodra;	state Exp;
branches;
next	1.339.2.6;

1.339.2.6
date	2011.03.10.09.27.57;	author amodra;	state Exp;
branches;
next	1.339.2.7;

1.339.2.7
date	2011.03.23.15.26.18;	author amodra;	state Exp;
branches;
next	1.339.2.8;

1.339.2.8
date	2011.04.27.07.17.37;	author amodra;	state Exp;
branches;
next	1.339.2.9;

1.339.2.9
date	2011.05.04.00.34.13;	author amodra;	state Exp;
branches;
next	1.339.2.10;

1.339.2.10
date	2011.05.13.05.58.02;	author amodra;	state Exp;
branches;
next	1.339.2.11;

1.339.2.11
date	2011.05.29.04.51.11;	author amodra;	state Exp;
branches;
next	;

1.299.2.1
date	2009.09.18.03.32.16;	author amodra;	state Exp;
branches;
next	1.299.2.2;

1.299.2.2
date	2009.09.21.11.55.16;	author amodra;	state Exp;
branches;
next	1.299.2.3;

1.299.2.3
date	2009.12.03.08.32.06;	author amodra;	state Exp;
branches;
next	1.299.2.4;

1.299.2.4
date	2009.12.17.00.08.01;	author amodra;	state Exp;
branches;
next	1.299.2.5;

1.299.2.5
date	2009.12.21.10.26.20;	author amodra;	state Exp;
branches;
next	1.299.2.6;

1.299.2.6
date	2010.01.25.12.12.47;	author amodra;	state Exp;
branches;
next	1.299.2.7;

1.299.2.7
date	2010.01.25.13.06.23;	author amodra;	state Exp;
branches;
next	1.299.2.8;

1.299.2.8
date	2010.01.27.12.51.24;	author amodra;	state Exp;
branches;
next	;

1.286.2.1
date	2008.10.09.01.04.30;	author amodra;	state Exp;
branches;
next	1.286.2.2;

1.286.2.2
date	2009.03.02.13.44.43;	author amodra;	state Exp;
branches;
next	1.286.2.3;

1.286.2.3
date	2009.03.02.13.55.19;	author amodra;	state Exp;
branches;
next	;

1.264.2.1
date	2007.08.15.04.34.00;	author amodra;	state Exp;
branches;
next	;

1.238.4.1
date	2006.05.24.03.11.51;	author amodra;	state Exp;
branches;
next	;

1.235.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.235.6.1
date	2006.05.10.01.58.25;	author amodra;	state Exp;
branches;
next	1.235.6.2;

1.235.6.2
date	2006.05.23.01.37.07;	author amodra;	state Exp;
branches;
next	;

1.194.2.1
date	2005.04.01.02.37.58;	author amodra;	state Exp;
branches;
next	1.194.2.2;

1.194.2.2
date	2005.04.01.02.55.05;	author amodra;	state Exp;
branches;
next	1.194.2.3;

1.194.2.3
date	2005.05.10.00.42.00;	author amodra;	state Exp;
branches;
next	1.194.2.4;

1.194.2.4
date	2005.06.03.01.52.29;	author amodra;	state Exp;
branches;
next	1.194.2.5;

1.194.2.5
date	2005.06.06.13.26.03;	author amodra;	state Exp;
branches;
next	;

1.143.6.1
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.143.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.143.8.2;

1.143.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.143.8.3;

1.143.8.3
date	2004.09.16.17.00.29;	author drow;	state Exp;
branches;
next	1.143.8.4;

1.143.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.92.12.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.92.12.2;

1.92.12.2
date	2003.05.18.09.43.45;	author kettenis;	state Exp;
branches;
next	;

1.92.14.1
date	2003.05.01.10.27.46;	author amodra;	state Exp;
branches;
next	;

1.91.2.1
date	2003.03.16.14.01.43;	author kettenis;	state Exp;
branches;
next	;

1.64.2.1
date	2002.10.26.17.11.59;	author drow;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2003.12.14.20.26.43;	author drow;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.63.10.1
date	2002.09.27.20.02.54;	author carlton;	state Exp;
branches;
next	1.63.10.2;

1.63.10.2
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.63.10.3;

1.63.10.3
date	2002.11.15.19.18.27;	author carlton;	state Exp;
branches;
next	1.63.10.4;

1.63.10.4
date	2002.12.23.19.37.48;	author carlton;	state Exp;
branches;
next	1.63.10.5;

1.63.10.5
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.63.10.6;

1.63.10.6
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.63.10.7;

1.63.10.7
date	2003.04.16.19.56.44;	author carlton;	state Exp;
branches;
next	1.63.10.8;

1.63.10.8
date	2003.05.23.18.40.26;	author carlton;	state Exp;
branches;
next	1.63.10.9;

1.63.10.9
date	2003.06.27.21.49.20;	author carlton;	state Exp;
branches;
next	1.63.10.10;

1.63.10.10
date	2003.08.05.17.12.50;	author carlton;	state Exp;
branches;
next	1.63.10.11;

1.63.10.11
date	2003.09.17.21.27.55;	author carlton;	state Exp;
branches;
next	1.63.10.12;

1.63.10.12
date	2003.11.11.23.50.23;	author carlton;	state Exp;
branches;
next	1.63.10.13;

1.63.10.13
date	2003.12.15.23.59.36;	author carlton;	state Exp;
branches;
next	1.63.10.14;

1.63.10.14
date	2004.01.26.19.11.05;	author carlton;	state Exp;
branches;
next	;

1.59.2.1
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	1.59.2.2;

1.59.2.2
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	1.59.2.3;

1.59.2.3
date	2002.09.26.05.20.55;	author amodra;	state Exp;
branches;
next	1.59.2.4;

1.59.2.4
date	2002.10.07.00.06.48;	author amodra;	state Exp;
branches;
next	1.59.2.5;

1.59.2.5
date	2002.10.08.09.57.22;	author amodra;	state Exp;
branches;
next	1.59.2.6;

1.59.2.6
date	2002.10.11.04.37.41;	author amodra;	state Exp;
branches;
next	1.59.2.7;

1.59.2.7
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	1.59.2.8;

1.59.2.8
date	2002.10.11.13.00.39;	author amodra;	state Exp;
branches;
next	1.59.2.9;

1.59.2.9
date	2002.11.13.02.57.06;	author amodra;	state Exp;
branches;
next	1.59.2.10;

1.59.2.10
date	2002.12.04.11.10.44;	author amodra;	state Exp;
branches;
next	;

1.45.2.1
date	2002.06.20.01.30.36;	author kseitz;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2002.08.09.18.34.15;	author kseitz;	state Exp;
branches;
next	1.45.2.4;

1.45.2.4
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	1.45.2.5;

1.45.2.5
date	2002.10.01.00.45.47;	author kseitz;	state Exp;
branches;
next	1.45.2.6;

1.45.2.6
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.39.2.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.26.2.1
date	2002.02.12.06.45.43;	author amodra;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.02.19.13.10.25;	author jakub;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2002.02.25.05.03.58;	author amodra;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2002.05.09.11.50.27;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.418
log
@	* elf-bfd.h (struct elf_backend_data): Remove as_needed_cleanup.
	Add notice_as_needed.
	* elf64-ppc.c (elf_backend_as_needed_cleanup): Don't define.
	(elf_backend_notice_as_needed): Define.
	(ppc64_elf_as_needed_cleanup): Rename and adjust..
	(ppc64_elf_notice_as_needed): ..to this.
	* elflink.c (_bfd_elf_notice_as_needed): New function, extracted..
	(elf_link_add_object_symbols): ..from here.
	* elfxx-target.h (elf_backend_as_needed_cleanup): Don't define.
	(elf_backend_notice_as_needed): Define..
	(elfNN_bed): ..and use here.
@
text
@/* PowerPC64-specific support for 64-bit ELF.
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012 Free Software Foundation, Inc.
   Written by Linus Nordberg, Swox AB <info@@swox.com>,
   based on elf32-ppc.c by Ian Lance Taylor.
   Largely rewritten by Alan Modra.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */


/* The 64-bit PowerPC ELF ABI may be found at
   http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi.txt, and
   http://www.linuxbase.org/spec/ELF/ppc64/spec/book1.html  */

#include "sysdep.h"
#include <stdarg.h>
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/ppc64.h"
#include "elf64-ppc.h"
#include "dwarf2.h"

static bfd_reloc_status_type ppc64_elf_ha_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_branch_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_brtaken_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_sectoff_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_sectoff_ha_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_toc_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_toc_ha_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_toc64_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc64_elf_unhandled_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_vma opd_entry_value
  (asection *, bfd_vma, asection **, bfd_vma *, bfd_boolean);

#define TARGET_LITTLE_SYM	bfd_elf64_powerpcle_vec
#define TARGET_LITTLE_NAME	"elf64-powerpcle"
#define TARGET_BIG_SYM		bfd_elf64_powerpc_vec
#define TARGET_BIG_NAME		"elf64-powerpc"
#define ELF_ARCH		bfd_arch_powerpc
#define ELF_TARGET_ID		PPC64_ELF_DATA
#define ELF_MACHINE_CODE	EM_PPC64
#define ELF_MAXPAGESIZE		0x10000
#define ELF_COMMONPAGESIZE	0x1000
#define elf_info_to_howto	ppc64_elf_info_to_howto

#define elf_backend_want_got_sym 0
#define elf_backend_want_plt_sym 0
#define elf_backend_plt_alignment 3
#define elf_backend_plt_not_loaded 1
#define elf_backend_got_header_size 8
#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_rela_normal 1
#define elf_backend_default_execstack 0

#define bfd_elf64_mkobject		      ppc64_elf_mkobject
#define bfd_elf64_bfd_reloc_type_lookup	      ppc64_elf_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup	      ppc64_elf_reloc_name_lookup
#define bfd_elf64_bfd_merge_private_bfd_data  _bfd_generic_verify_endian_match
#define bfd_elf64_new_section_hook	      ppc64_elf_new_section_hook
#define bfd_elf64_bfd_link_hash_table_create  ppc64_elf_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free    ppc64_elf_link_hash_table_free
#define bfd_elf64_get_synthetic_symtab	      ppc64_elf_get_synthetic_symtab
#define bfd_elf64_bfd_link_just_syms	      ppc64_elf_link_just_syms

#define elf_backend_object_p		      ppc64_elf_object_p
#define elf_backend_grok_prstatus	      ppc64_elf_grok_prstatus
#define elf_backend_grok_psinfo		      ppc64_elf_grok_psinfo
#define elf_backend_write_core_note	      ppc64_elf_write_core_note
#define elf_backend_create_dynamic_sections   ppc64_elf_create_dynamic_sections
#define elf_backend_copy_indirect_symbol      ppc64_elf_copy_indirect_symbol
#define elf_backend_add_symbol_hook	      ppc64_elf_add_symbol_hook
#define elf_backend_check_directives	      ppc64_elf_process_dot_syms
#define elf_backend_notice_as_needed	      ppc64_elf_notice_as_needed
#define elf_backend_archive_symbol_lookup     ppc64_elf_archive_symbol_lookup
#define elf_backend_check_relocs	      ppc64_elf_check_relocs
#define elf_backend_gc_keep		      ppc64_elf_gc_keep
#define elf_backend_gc_mark_dynamic_ref       ppc64_elf_gc_mark_dynamic_ref
#define elf_backend_gc_mark_hook	      ppc64_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	      ppc64_elf_gc_sweep_hook
#define elf_backend_adjust_dynamic_symbol     ppc64_elf_adjust_dynamic_symbol
#define elf_backend_hide_symbol		      ppc64_elf_hide_symbol
#define elf_backend_maybe_function_sym	      ppc64_elf_maybe_function_sym
#define elf_backend_always_size_sections      ppc64_elf_func_desc_adjust
#define elf_backend_size_dynamic_sections     ppc64_elf_size_dynamic_sections
#define elf_backend_init_index_section	      _bfd_elf_init_2_index_sections
#define elf_backend_action_discarded	      ppc64_elf_action_discarded
#define elf_backend_relocate_section	      ppc64_elf_relocate_section
#define elf_backend_finish_dynamic_symbol     ppc64_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class	      ppc64_elf_reloc_type_class
#define elf_backend_finish_dynamic_sections   ppc64_elf_finish_dynamic_sections
#define elf_backend_link_output_symbol_hook   ppc64_elf_output_symbol_hook
#define elf_backend_special_sections	      ppc64_elf_special_sections
#define elf_backend_post_process_headers      _bfd_elf_set_osabi

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"

/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 24

/* The initial size of the plt reserved for the dynamic linker.  */
#define PLT_INITIAL_ENTRY_SIZE PLT_ENTRY_SIZE

/* TOC base pointers offset from start of TOC.  */
#define TOC_BASE_OFF	0x8000

/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000

/* .plt call stub instructions.  The normal stub is like this, but
   sometimes the .plt entry crosses a 64k boundary and we need to
   insert an addi to adjust r12.  */
#define PLT_CALL_STUB_SIZE (7*4)
#define ADDIS_R12_R2	0x3d820000	/* addis %r12,%r2,xxx@@ha     */
#define STD_R2_40R1	0xf8410028	/* std	 %r2,40(%r1)	     */
#define LD_R11_0R12	0xe96c0000	/* ld	 %r11,xxx+0@@l(%r12)  */
#define MTCTR_R11	0x7d6903a6	/* mtctr %r11		     */
#define LD_R2_0R12	0xe84c0000	/* ld	 %r2,xxx+8@@l(%r12)   */
					/* ld	 %r11,xxx+16@@l(%r12) */
#define BCTR		0x4e800420	/* bctr			     */


#define ADDIS_R12_R12	0x3d8c0000	/* addis %r12,%r12,off@@ha  */
#define ADDI_R12_R12	0x398c0000	/* addi %r12,%r12,off@@l  */
#define ADDIS_R2_R2	0x3c420000	/* addis %r2,%r2,off@@ha  */
#define ADDI_R2_R2	0x38420000	/* addi  %r2,%r2,off@@l   */

#define XOR_R11_R11_R11	0x7d6b5a78	/* xor   %r11,%r11,%r11  */
#define ADD_R12_R12_R11	0x7d8c5a14	/* add   %r12,%r12,%r11  */
#define ADD_R2_R2_R11	0x7c425a14	/* add   %r2,%r2,%r11    */
#define CMPLDI_R2_0	0x28220000	/* cmpldi %r2,0          */
#define BNECTR		0x4ca20420	/* bnectr+               */
#define BNECTR_P4	0x4ce20420	/* bnectr+               */

#define LD_R11_0R2	0xe9620000	/* ld	 %r11,xxx+0(%r2) */
#define LD_R2_0R2	0xe8420000	/* ld	 %r2,xxx+0(%r2)  */

#define LD_R2_40R1	0xe8410028	/* ld    %r2,40(%r1)     */

/* glink call stub instructions.  We enter with the index in R0.  */
#define GLINK_CALL_STUB_SIZE (16*4)
					/* 0:				*/
					/*  .quad plt0-1f		*/
					/* __glink:			*/
#define MFLR_R12	0x7d8802a6	/*  mflr %12			*/
#define BCL_20_31	0x429f0005	/*  bcl 20,31,1f		*/
					/* 1:				*/
#define MFLR_R11	0x7d6802a6	/*  mflr %11			*/
#define LD_R2_M16R11	0xe84bfff0	/*  ld %2,(0b-1b)(%11)		*/
#define MTLR_R12	0x7d8803a6	/*  mtlr %12			*/
#define ADD_R12_R2_R11	0x7d825a14	/*  add %12,%2,%11		*/
					/*  ld %11,0(%12)		*/
					/*  ld %2,8(%12)		*/
					/*  mtctr %11			*/
					/*  ld %11,16(%12)		*/
					/*  bctr			*/

/* Pad with this.  */
#define NOP		0x60000000

/* Some other nops.  */
#define CROR_151515	0x4def7b82
#define CROR_313131	0x4ffffb82

/* .glink entries for the first 32k functions are two instructions.  */
#define LI_R0_0		0x38000000	/* li    %r0,0		*/
#define B_DOT		0x48000000	/* b     .		*/

/* After that, we need two instructions to load the index, followed by
   a branch.  */
#define LIS_R0_0	0x3c000000	/* lis   %r0,0		*/
#define ORI_R0_R0_0	0x60000000	/* ori	 %r0,%r0,0	*/

/* Instructions used by the save and restore reg functions.  */
#define STD_R0_0R1	0xf8010000	/* std   %r0,0(%r1)	*/
#define STD_R0_0R12	0xf80c0000	/* std   %r0,0(%r12)	*/
#define LD_R0_0R1	0xe8010000	/* ld    %r0,0(%r1)	*/
#define LD_R0_0R12	0xe80c0000	/* ld    %r0,0(%r12)	*/
#define STFD_FR0_0R1	0xd8010000	/* stfd  %fr0,0(%r1)	*/
#define LFD_FR0_0R1	0xc8010000	/* lfd   %fr0,0(%r1)	*/
#define LI_R12_0	0x39800000	/* li    %r12,0		*/
#define STVX_VR0_R12_R0	0x7c0c01ce	/* stvx  %v0,%r12,%r0	*/
#define LVX_VR0_R12_R0	0x7c0c00ce	/* lvx   %v0,%r12,%r0	*/
#define MTLR_R0		0x7c0803a6	/* mtlr  %r0		*/
#define BLR		0x4e800020	/* blr			*/

/* Since .opd is an array of descriptors and each entry will end up
   with identical R_PPC64_RELATIVE relocs, there is really no need to
   propagate .opd relocs;  The dynamic linker should be taught to
   relocate .opd without reloc entries.  */
#ifndef NO_OPD_RELOCS
#define NO_OPD_RELOCS 0
#endif

#define ONES(n) (((bfd_vma) 1 << ((n) - 1) << 1) - 1)

/* Relocation HOWTO's.  */
static reloc_howto_type *ppc64_elf_howto_table[(int) R_PPC64_max];

static reloc_howto_type ppc64_elf_howto_raw[] = {
  /* This reloc does nothing.  */
  HOWTO (R_PPC64_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_NONE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A standard 32 bit relocation.  */
  HOWTO (R_PPC64_ADDR32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 26 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC64_ADDR24,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR24",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A standard 16 bit relocation.  */
  HOWTO (R_PPC64_ADDR16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit relocation without overflow.  */
  HOWTO (R_PPC64_ADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 of an address.  */
  HOWTO (R_PPC64_ADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 of an address, plus 1 if the contents of the low 16
     bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC64_ADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_ha_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC64_ADDR14,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_branch_reloc, /* special_function */
	 "R_PPC64_ADDR14",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is expected to be taken.  The lower two
     bits must be zero.  */
  HOWTO (R_PPC64_ADDR14_BRTAKEN, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_brtaken_reloc, /* special_function */
	 "R_PPC64_ADDR14_BRTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is not expected to be taken.  The lower
     two bits must be zero.  */
  HOWTO (R_PPC64_ADDR14_BRNTAKEN, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_brtaken_reloc, /* special_function */
	 "R_PPC64_ADDR14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A relative 26 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC64_REL24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_branch_reloc, /* special_function */
	 "R_PPC64_REL24",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x03fffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC64_REL14,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_branch_reloc, /* special_function */
	 "R_PPC64_REL14",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is expected to be taken.  The lower two bits must be
     zero.  */
  HOWTO (R_PPC64_REL14_BRTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_brtaken_reloc, /* special_function */
	 "R_PPC64_REL14_BRTAKEN", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is not expected to be taken.  The lower two bits must
     be zero.  */
  HOWTO (R_PPC64_REL14_BRNTAKEN, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_brtaken_reloc, /* special_function */
	 "R_PPC64_REL14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000fffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC64_ADDR16, but referring to the GOT table entry for the
     symbol.  */
  HOWTO (R_PPC64_GOT16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_LO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC64_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_HI, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC64_GOT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_HA, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC64_GOT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_PPC64_COPY,		/* type */
	 0,			/* rightshift */
	 0,			/* this one is variable size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_COPY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR64, but used when setting global offset table
     entries.  */
  HOWTO (R_PPC64_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc,  /* special_function */
	 "R_PPC64_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Created by the link editor.  Marks a procedure linkage table
     entry for a symbol.  */
  HOWTO (R_PPC64_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used only by the dynamic linker.  When the object is run, this
     doubleword64 is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_PPC64_RELATIVE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_RELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR32, but may be unaligned.  */
  HOWTO (R_PPC64_UADDR32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_UADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16, but may be unaligned.  */
  HOWTO (R_PPC64_UADDR16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_UADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32-bit PC relative.  */
  HOWTO (R_PPC64_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 /* FIXME: Verify.  Was complain_overflow_bitfield.  */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_REL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 32-bit relocation to the symbol's procedure linkage table.  */
  HOWTO (R_PPC64_PLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32-bit PC relative relocation to the symbol's procedure linkage table.
     FIXME: R_PPC64_PLTREL32 not supported.  */
  HOWTO (R_PPC64_PLTREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_PLTREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC64_ADDR16_LO, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC64_PLT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_HI, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC64_PLT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_HA, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC64_PLT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit section relative relocation.  */
  HOWTO (R_PPC64_SECTOFF,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_SECTOFF, but no overflow warning.  */
  HOWTO (R_PPC64_SECTOFF_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit upper half section relative relocation.  */
  HOWTO (R_PPC64_SECTOFF_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit upper half adjusted section relative relocation.  */
  HOWTO (R_PPC64_SECTOFF_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_sectoff_ha_reloc, /* special_function */
	 "R_PPC64_SECTOFF_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_REL24 without touching the two least significant bits.  */
  HOWTO (R_PPC64_REL30,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 30,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_PPC64_REL30",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Relocs in the 64-bit PowerPC ELF ABI, not in the 32-bit ABI.  */

  /* A standard 64-bit relocation.  */
  HOWTO (R_PPC64_ADDR64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The bits 32-47 of an address.  */
  HOWTO (R_PPC64_ADDR16_HIGHER,	/* type */
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HIGHER", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The bits 32-47 of an address, plus 1 if the contents of the low
     16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC64_ADDR16_HIGHERA, /* type */
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_ha_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The bits 48-63 of an address.  */
  HOWTO (R_PPC64_ADDR16_HIGHEST,/* type */
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The bits 48-63 of an address, plus 1 if the contents of the low
     16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC64_ADDR16_HIGHESTA,/* type */
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_ha_reloc,	/* special_function */
	 "R_PPC64_ADDR16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like ADDR64, but may be unaligned.  */
  HOWTO (R_PPC64_UADDR64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_UADDR64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64-bit relative relocation.  */
  HOWTO (R_PPC64_REL64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_REL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 64-bit relocation to the symbol's procedure linkage table.  */
  HOWTO (R_PPC64_PLT64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64-bit PC relative relocation to the symbol's procedure linkage
     table.  */
  /* FIXME: R_PPC64_PLTREL64 not supported.  */
  HOWTO (R_PPC64_PLTREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit TOC-relative relocation.  */

  /* R_PPC64_TOC16	  47	   half16*	S + A - .TOC.  */
  HOWTO (R_PPC64_TOC16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit TOC-relative relocation without overflow.  */

  /* R_PPC64_TOC16_LO	  48	   half16	 #lo (S + A - .TOC.)  */
  HOWTO (R_PPC64_TOC16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit TOC-relative relocation, high 16 bits.  */

  /* R_PPC64_TOC16_HI	  49	   half16	 #hi (S + A - .TOC.)  */
  HOWTO (R_PPC64_TOC16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit TOC-relative relocation, high 16 bits, plus 1 if the
     contents of the low 16 bits, treated as a signed number, is
     negative.  */

  /* R_PPC64_TOC16_HA	  50	   half16	 #ha (S + A - .TOC.)  */
  HOWTO (R_PPC64_TOC16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_toc_ha_reloc, /* special_function */
	 "R_PPC64_TOC16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64-bit relocation; insert value of TOC base (.TOC.).  */

  /* R_PPC64_TOC		  51	   doubleword64	 .TOC.  */
  HOWTO (R_PPC64_TOC,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_toc64_reloc,	/* special_function */
	 "R_PPC64_TOC",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_GOT16, but also informs the link editor that the
     value to relocate may (!) refer to a PLT entry which the link
     editor (a) may replace with the symbol value.  If the link editor
     is unable to fully resolve the symbol, it may (b) create a PLT
     entry and store the address to the new PLT entry in the GOT.
     This permits lazy resolution of function symbols at run time.
     The link editor may also skip all of this and just (c) emit a
     R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
  /* FIXME: R_PPC64_PLTGOT16 not implemented.  */
    HOWTO (R_PPC64_PLTGOT16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16, but without overflow.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
  /* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus
     1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  /* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_GOT16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_PLT16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_LO_DS, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_TOC16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO_DS,/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marker relocs for TLS.  */
  HOWTO (R_PPC64_TLS,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TLS",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC64_TLSGD,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TLSGD",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC64_TLSLD,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TLSLD",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC64_TOCSAVE,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TOCSAVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC64_DTPMOD64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPMOD64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC64_DTPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC64_DTPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHER", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_DTPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC64_TPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC64_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_TPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSGD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSGD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSLD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSLD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_DTPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_DTPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_TPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC64_JMP_IREL,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_JMP_IREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC64_IRELATIVE,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0=byte, 1=short, 2=long, 4=64 bits) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_IRELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit relative relocation.  */
  HOWTO (R_PPC64_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_REL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit relative relocation without overflow.  */
  HOWTO (R_PPC64_REL16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_REL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The high order 16 bits of a relative address.  */
  HOWTO (R_PPC64_REL16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_REL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The high order 16 bits of a relative address, plus 1 if the contents of
     the low 16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC64_REL16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_ha_reloc,	/* special_function */
	 "R_PPC64_REL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC64_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC64_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC64_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC64_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
};


/* Initialize the ppc64_elf_howto_table, so that linear accesses can
   be done.  */

static void
ppc_howto_init (void)
{
  unsigned int i, type;

  for (i = 0;
       i < sizeof (ppc64_elf_howto_raw) / sizeof (ppc64_elf_howto_raw[0]);
       i++)
    {
      type = ppc64_elf_howto_raw[i].type;
      BFD_ASSERT (type < (sizeof (ppc64_elf_howto_table)
			  / sizeof (ppc64_elf_howto_table[0])));
      ppc64_elf_howto_table[type] = &ppc64_elf_howto_raw[i];
    }
}

static reloc_howto_type *
ppc64_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     bfd_reloc_code_real_type code)
{
  enum elf_ppc64_reloc_type r = R_PPC64_NONE;

  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
    /* Initialize howto table if needed.  */
    ppc_howto_init ();

  switch (code)
    {
    default:
      return NULL;

    case BFD_RELOC_NONE:			r = R_PPC64_NONE;
      break;
    case BFD_RELOC_32:				r = R_PPC64_ADDR32;
      break;
    case BFD_RELOC_PPC_BA26:			r = R_PPC64_ADDR24;
      break;
    case BFD_RELOC_16:				r = R_PPC64_ADDR16;
      break;
    case BFD_RELOC_LO16:			r = R_PPC64_ADDR16_LO;
      break;
    case BFD_RELOC_HI16:			r = R_PPC64_ADDR16_HI;
      break;
    case BFD_RELOC_HI16_S:			r = R_PPC64_ADDR16_HA;
      break;
    case BFD_RELOC_PPC_BA16:			r = R_PPC64_ADDR14;
      break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:		r = R_PPC64_ADDR14_BRTAKEN;
      break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:		r = R_PPC64_ADDR14_BRNTAKEN;
      break;
    case BFD_RELOC_PPC_B26:			r = R_PPC64_REL24;
      break;
    case BFD_RELOC_PPC_B16:			r = R_PPC64_REL14;
      break;
    case BFD_RELOC_PPC_B16_BRTAKEN:		r = R_PPC64_REL14_BRTAKEN;
      break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:		r = R_PPC64_REL14_BRNTAKEN;
      break;
    case BFD_RELOC_16_GOTOFF:			r = R_PPC64_GOT16;
      break;
    case BFD_RELOC_LO16_GOTOFF:			r = R_PPC64_GOT16_LO;
      break;
    case BFD_RELOC_HI16_GOTOFF:			r = R_PPC64_GOT16_HI;
      break;
    case BFD_RELOC_HI16_S_GOTOFF:		r = R_PPC64_GOT16_HA;
      break;
    case BFD_RELOC_PPC_COPY:			r = R_PPC64_COPY;
      break;
    case BFD_RELOC_PPC_GLOB_DAT:		r = R_PPC64_GLOB_DAT;
      break;
    case BFD_RELOC_32_PCREL:			r = R_PPC64_REL32;
      break;
    case BFD_RELOC_32_PLTOFF:			r = R_PPC64_PLT32;
      break;
    case BFD_RELOC_32_PLT_PCREL:		r = R_PPC64_PLTREL32;
      break;
    case BFD_RELOC_LO16_PLTOFF:			r = R_PPC64_PLT16_LO;
      break;
    case BFD_RELOC_HI16_PLTOFF:			r = R_PPC64_PLT16_HI;
      break;
    case BFD_RELOC_HI16_S_PLTOFF:		r = R_PPC64_PLT16_HA;
      break;
    case BFD_RELOC_16_BASEREL:			r = R_PPC64_SECTOFF;
      break;
    case BFD_RELOC_LO16_BASEREL:		r = R_PPC64_SECTOFF_LO;
      break;
    case BFD_RELOC_HI16_BASEREL:		r = R_PPC64_SECTOFF_HI;
      break;
    case BFD_RELOC_HI16_S_BASEREL:		r = R_PPC64_SECTOFF_HA;
      break;
    case BFD_RELOC_CTOR:			r = R_PPC64_ADDR64;
      break;
    case BFD_RELOC_64:				r = R_PPC64_ADDR64;
      break;
    case BFD_RELOC_PPC64_HIGHER:		r = R_PPC64_ADDR16_HIGHER;
      break;
    case BFD_RELOC_PPC64_HIGHER_S:		r = R_PPC64_ADDR16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_HIGHEST:		r = R_PPC64_ADDR16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_HIGHEST_S:		r = R_PPC64_ADDR16_HIGHESTA;
      break;
    case BFD_RELOC_64_PCREL:			r = R_PPC64_REL64;
      break;
    case BFD_RELOC_64_PLTOFF:			r = R_PPC64_PLT64;
      break;
    case BFD_RELOC_64_PLT_PCREL:		r = R_PPC64_PLTREL64;
      break;
    case BFD_RELOC_PPC_TOC16:			r = R_PPC64_TOC16;
      break;
    case BFD_RELOC_PPC64_TOC16_LO:		r = R_PPC64_TOC16_LO;
      break;
    case BFD_RELOC_PPC64_TOC16_HI:		r = R_PPC64_TOC16_HI;
      break;
    case BFD_RELOC_PPC64_TOC16_HA:		r = R_PPC64_TOC16_HA;
      break;
    case BFD_RELOC_PPC64_TOC:			r = R_PPC64_TOC;
      break;
    case BFD_RELOC_PPC64_PLTGOT16:		r = R_PPC64_PLTGOT16;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_LO:		r = R_PPC64_PLTGOT16_LO;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_HI:		r = R_PPC64_PLTGOT16_HI;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_HA:		r = R_PPC64_PLTGOT16_HA;
      break;
    case BFD_RELOC_PPC64_ADDR16_DS:		r = R_PPC64_ADDR16_DS;
      break;
    case BFD_RELOC_PPC64_ADDR16_LO_DS:		r = R_PPC64_ADDR16_LO_DS;
      break;
    case BFD_RELOC_PPC64_GOT16_DS:		r = R_PPC64_GOT16_DS;
      break;
    case BFD_RELOC_PPC64_GOT16_LO_DS:		r = R_PPC64_GOT16_LO_DS;
      break;
    case BFD_RELOC_PPC64_PLT16_LO_DS:		r = R_PPC64_PLT16_LO_DS;
      break;
    case BFD_RELOC_PPC64_SECTOFF_DS:		r = R_PPC64_SECTOFF_DS;
      break;
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:		r = R_PPC64_SECTOFF_LO_DS;
      break;
    case BFD_RELOC_PPC64_TOC16_DS:		r = R_PPC64_TOC16_DS;
      break;
    case BFD_RELOC_PPC64_TOC16_LO_DS:		r = R_PPC64_TOC16_LO_DS;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_DS:		r = R_PPC64_PLTGOT16_DS;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_LO_DS:	r = R_PPC64_PLTGOT16_LO_DS;
      break;
    case BFD_RELOC_PPC_TLS:			r = R_PPC64_TLS;
      break;
    case BFD_RELOC_PPC_TLSGD:			r = R_PPC64_TLSGD;
      break;
    case BFD_RELOC_PPC_TLSLD:			r = R_PPC64_TLSLD;
      break;
    case BFD_RELOC_PPC_DTPMOD:			r = R_PPC64_DTPMOD64;
      break;
    case BFD_RELOC_PPC_TPREL16:			r = R_PPC64_TPREL16;
      break;
    case BFD_RELOC_PPC_TPREL16_LO:		r = R_PPC64_TPREL16_LO;
      break;
    case BFD_RELOC_PPC_TPREL16_HI:		r = R_PPC64_TPREL16_HI;
      break;
    case BFD_RELOC_PPC_TPREL16_HA:		r = R_PPC64_TPREL16_HA;
      break;
    case BFD_RELOC_PPC_TPREL:			r = R_PPC64_TPREL64;
      break;
    case BFD_RELOC_PPC_DTPREL16:		r = R_PPC64_DTPREL16;
      break;
    case BFD_RELOC_PPC_DTPREL16_LO:		r = R_PPC64_DTPREL16_LO;
      break;
    case BFD_RELOC_PPC_DTPREL16_HI:		r = R_PPC64_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_DTPREL16_HA:		r = R_PPC64_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC_DTPREL:			r = R_PPC64_DTPREL64;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16:		r = R_PPC64_GOT_TLSGD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:		r = R_PPC64_GOT_TLSGD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:		r = R_PPC64_GOT_TLSGD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:		r = R_PPC64_GOT_TLSGD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16:		r = R_PPC64_GOT_TLSLD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:		r = R_PPC64_GOT_TLSLD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:		r = R_PPC64_GOT_TLSLD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:		r = R_PPC64_GOT_TLSLD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16:		r = R_PPC64_GOT_TPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:		r = R_PPC64_GOT_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:		r = R_PPC64_GOT_TPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:		r = R_PPC64_GOT_TPREL16_HA;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16:		r = R_PPC64_GOT_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:		r = R_PPC64_GOT_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:		r = R_PPC64_GOT_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:		r = R_PPC64_GOT_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC64_TPREL16_DS:		r = R_PPC64_TPREL16_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_LO_DS:		r = R_PPC64_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHER:	r = R_PPC64_TPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHERA:	r = R_PPC64_TPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHEST:	r = R_PPC64_TPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHESTA:	r = R_PPC64_TPREL16_HIGHESTA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_DS:		r = R_PPC64_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_LO_DS:	r = R_PPC64_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHER:	r = R_PPC64_DTPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHERA:	r = R_PPC64_DTPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHEST:	r = R_PPC64_DTPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:	r = R_PPC64_DTPREL16_HIGHESTA;
      break;
    case BFD_RELOC_16_PCREL:			r = R_PPC64_REL16;
      break;
    case BFD_RELOC_LO16_PCREL:			r = R_PPC64_REL16_LO;
      break;
    case BFD_RELOC_HI16_PCREL:			r = R_PPC64_REL16_HI;
      break;
    case BFD_RELOC_HI16_S_PCREL:		r = R_PPC64_REL16_HA;
      break;
    case BFD_RELOC_VTABLE_INHERIT:		r = R_PPC64_GNU_VTINHERIT;
      break;
    case BFD_RELOC_VTABLE_ENTRY:		r = R_PPC64_GNU_VTENTRY;
      break;
    }

  return ppc64_elf_howto_table[r];
};

static reloc_howto_type *
ppc64_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (ppc64_elf_howto_raw) / sizeof (ppc64_elf_howto_raw[0]);
       i++)
    if (ppc64_elf_howto_raw[i].name != NULL
	&& strcasecmp (ppc64_elf_howto_raw[i].name, r_name) == 0)
      return &ppc64_elf_howto_raw[i];

  return NULL;
}

/* Set the howto pointer for a PowerPC ELF reloc.  */

static void
ppc64_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			 Elf_Internal_Rela *dst)
{
  unsigned int type;

  /* Initialize howto table if needed.  */
  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
    ppc_howto_init ();

  type = ELF64_R_TYPE (dst->r_info);
  if (type >= (sizeof (ppc64_elf_howto_table)
	       / sizeof (ppc64_elf_howto_table[0])))
    {
      (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
			     abfd, (int) type);
      type = R_PPC64_NONE;
    }
  cache_ptr->howto = ppc64_elf_howto_table[type];
}

/* Handle the R_PPC64_ADDR16_HA and similar relocs.  */

static bfd_reloc_status_type
ppc64_elf_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  /* Adjust the addend for sign extension of the low 16 bits.
     We won't actually be using the low 16 bits, so trashing them
     doesn't matter.  */
  reloc_entry->addend += 0x8000;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_branch_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section,
			bfd *output_bfd, char **error_message)
{
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (strcmp (symbol->section->name, ".opd") == 0
      && (symbol->section->owner->flags & DYNAMIC) == 0)
    {
      bfd_vma dest = opd_entry_value (symbol->section,
				      symbol->value + reloc_entry->addend,
				      NULL, NULL, FALSE);
      if (dest != (bfd_vma) -1)
	reloc_entry->addend = dest - (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset);
    }
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_brtaken_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
{
  long insn;
  enum elf_ppc64_reloc_type r_type;
  bfd_size_type octets;
  /* Assume 'at' branch hints.  */
  bfd_boolean is_isa_v2 = TRUE;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  insn = bfd_get_32 (abfd, (bfd_byte *) data + octets);
  insn &= ~(0x01 << 21);
  r_type = reloc_entry->howto->type;
  if (r_type == R_PPC64_ADDR14_BRTAKEN
      || r_type == R_PPC64_REL14_BRTAKEN)
    insn |= 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */

  if (is_isa_v2)
    {
      /* Set 'a' bit.  This is 0b00010 in BO field for branch
	 on CR(BI) insns (BO == 001at or 011at), and 0b01000
	 for branch on CTR insns (BO == 1a00t or 1a01t).  */
      if ((insn & (0x14 << 21)) == (0x04 << 21))
	insn |= 0x02 << 21;
      else if ((insn & (0x14 << 21)) == (0x10 << 21))
	insn |= 0x08 << 21;
      else
	goto out;
    }
  else
    {
      bfd_vma target = 0;
      bfd_vma from;

      if (!bfd_is_com_section (symbol->section))
	target = symbol->value;
      target += symbol->section->output_section->vma;
      target += symbol->section->output_offset;
      target += reloc_entry->addend;

      from = (reloc_entry->address
	      + input_section->output_offset
	      + input_section->output_section->vma);

      /* Invert 'y' bit if not the default.  */
      if ((bfd_signed_vma) (target - from) < 0)
	insn ^= 0x01 << 21;
    }
  bfd_put_32 (abfd, insn, (bfd_byte *) data + octets);
 out:
  return ppc64_elf_branch_reloc (abfd, reloc_entry, symbol, data,
				 input_section, output_bfd, error_message);
}

static bfd_reloc_status_type
ppc64_elf_sectoff_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  /* Subtract the symbol section base address.  */
  reloc_entry->addend -= symbol->section->output_section->vma;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_sectoff_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			    void *data, asection *input_section,
			    bfd *output_bfd, char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  /* Subtract the symbol section base address.  */
  reloc_entry->addend -= symbol->section->output_section->vma;

  /* Adjust the addend for sign extension of the low 16 bits.  */
  reloc_entry->addend += 0x8000;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_toc_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
{
  bfd_vma TOCstart;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);

  /* Subtract the TOC base address.  */
  reloc_entry->addend -= TOCstart + TOC_BASE_OFF;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_toc_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section,
			bfd *output_bfd, char **error_message)
{
  bfd_vma TOCstart;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);

  /* Subtract the TOC base address.  */
  reloc_entry->addend -= TOCstart + TOC_BASE_OFF;

  /* Adjust the addend for sign extension of the low 16 bits.  */
  reloc_entry->addend += 0x8000;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_toc64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		       void *data, asection *input_section,
		       bfd *output_bfd, char **error_message)
{
  bfd_vma TOCstart;
  bfd_size_type octets;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_set_toc (NULL, input_section->output_section->owner);

  octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  bfd_put_64 (abfd, TOCstart + TOC_BASE_OFF, (bfd_byte *) data + octets);
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc64_elf_unhandled_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, "generic linker can't handle %s",
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}

/* Track GOT entries needed for a given symbol.  We might need more
   than one got entry per symbol.  */
struct got_entry
{
  struct got_entry *next;

  /* The symbol addend that we'll be placing in the GOT.  */
  bfd_vma addend;

  /* Unlike other ELF targets, we use separate GOT entries for the same
     symbol referenced from different input files.  This is to support
     automatic multiple TOC/GOT sections, where the TOC base can vary
     from one input file to another.  After partitioning into TOC groups
     we merge entries within the group.

     Point to the BFD owning this GOT entry.  */
  bfd *owner;

  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
  unsigned char tls_type;

  /* Non-zero if got.ent points to real entry.  */
  unsigned char is_indirect;

  /* Reference count until size_dynamic_sections, GOT offset thereafter.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
      struct got_entry *ent;
    } got;
};

/* The same for PLT.  */
struct plt_entry
{
  struct plt_entry *next;

  bfd_vma addend;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
};

struct ppc64_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* Shortcuts to dynamic linker sections.  */
  asection *got;
  asection *relgot;

  /* Used during garbage collection.  We attach global symbols defined
     on removed .opd entries to this section so that the sym is removed.  */
  asection *deleted_section;

  /* TLS local dynamic got entry handling.  Support for multiple GOT
     sections means we potentially need one of these for each input bfd.  */
  struct got_entry tlsld_got;

  union {
    /* A copy of relocs before they are modified for --emit-relocs.  */
    Elf_Internal_Rela *relocs;

    /* Section contents.  */
    bfd_byte *contents;
  } opd;

  /* Nonzero if this bfd has small toc/got relocs, ie. that expect
     the reloc to be in the range -32768 to 32767.  */
  unsigned int has_small_toc_reloc : 1;

  /* Set if toc/got ha relocs detected not using r2, or lo reloc
     instruction not one we handle.  */
  unsigned int unexpected_toc_insn : 1;
};

#define ppc64_elf_tdata(bfd) \
  ((struct ppc64_elf_obj_tdata *) (bfd)->tdata.any)

#define ppc64_tlsld_got(bfd) \
  (&ppc64_elf_tdata (bfd)->tlsld_got)

#define is_ppc64_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_object_id (bfd) == PPC64_ELF_DATA)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc64_elf_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct ppc64_elf_obj_tdata),
				  PPC64_ELF_DATA);
}

/* Fix bad default arch selected for a 64 bit input bfd when the
   default is 32 bit.  */

static bfd_boolean
ppc64_elf_object_p (bfd *abfd)
{
  if (abfd->arch_info->the_default && abfd->arch_info->bits_per_word == 32)
    {
      Elf_Internal_Ehdr *i_ehdr = elf_elfheader (abfd);

      if (i_ehdr->e_ident[EI_CLASS] == ELFCLASS64)
	{
	  /* Relies on arch after 32 bit default being 64 bit default.  */
	  abfd->arch_info = abfd->arch_info->next;
	  BFD_ASSERT (abfd->arch_info->bits_per_word == 64);
	}
    }
  return TRUE;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
ppc64_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t offset, size;

  if (note->descsz != 504)
    return FALSE;

  /* pr_cursig */
  elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

  /* pr_pid */
  elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 32);

  /* pr_reg */
  offset = 112;
  size = 384;

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
ppc64_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz != 136)
    return FALSE;

  elf_tdata (abfd)->core->pid
    = bfd_get_32 (abfd, note->descdata + 24);
  elf_tdata (abfd)->core->program
    = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
  elf_tdata (abfd)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);

  return TRUE;
}

static char *
ppc64_elf_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type,
			   ...)
{
  switch (note_type)
    {
    default:
      return NULL;

    case NT_PRPSINFO:
      {
	char data[136];
	va_list ap;

	va_start (ap, note_type);
	memset (data, 0, sizeof (data));
	strncpy (data + 40, va_arg (ap, const char *), 16);
	strncpy (data + 56, va_arg (ap, const char *), 80);
	va_end (ap);
	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }

    case NT_PRSTATUS:
      {
	char data[504];
	va_list ap;
	long pid;
	int cursig;
	const void *greg;

	va_start (ap, note_type);
	memset (data, 0, 112);
	pid = va_arg (ap, long);
	bfd_put_32 (abfd, pid, data + 32);
	cursig = va_arg (ap, int);
	bfd_put_16 (abfd, cursig, data + 12);
	greg = va_arg (ap, const void *);
	memcpy (data + 112, greg, 384);
	memset (data + 496, 0, 8);
	va_end (ap);
	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }
    }
}

/* Add extra PPC sections.  */

static const struct bfd_elf_special_section ppc64_elf_special_sections[]=
{
  { STRING_COMMA_LEN (".plt"),    0, SHT_NOBITS,   0 },
  { STRING_COMMA_LEN (".sbss"),  -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".sdata"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".toc"),    0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".toc1"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".tocbss"), 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,                     0,  0, 0,            0 }
};

enum _ppc64_sec_type {
  sec_normal = 0,
  sec_opd = 1,
  sec_toc = 2
};

struct _ppc64_elf_section_data
{
  struct bfd_elf_section_data elf;

  union
  {
    /* An array with one entry for each opd function descriptor.  */
    struct _opd_sec_data
    {
      /* Points to the function code section for local opd entries.  */
      asection **func_sec;

      /* After editing .opd, adjust references to opd local syms.  */
      long *adjust;
    } opd;

    /* An array for toc sections, indexed by offset/8.  */
    struct _toc_sec_data
    {
      /* Specifies the relocation symbol index used at a given toc offset.  */
      unsigned *symndx;

      /* And the relocation addend.  */
      bfd_vma *add;
    } toc;
  } u;

  enum _ppc64_sec_type sec_type:2;

  /* Flag set when small branches are detected.  Used to
     select suitable defaults for the stub group size.  */
  unsigned int has_14bit_branch:1;
};

#define ppc64_elf_section_data(sec) \
  ((struct _ppc64_elf_section_data *) elf_section_data (sec))

static bfd_boolean
ppc64_elf_new_section_hook (bfd *abfd, asection *sec)
{
  if (!sec->used_by_bfd)
    {
      struct _ppc64_elf_section_data *sdata;
      bfd_size_type amt = sizeof (*sdata);

      sdata = bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  return _bfd_elf_new_section_hook (abfd, sec);
}

static struct _opd_sec_data *
get_opd_info (asection * sec)
{
  if (sec != NULL
      && ppc64_elf_section_data (sec) != NULL
      && ppc64_elf_section_data (sec)->sec_type == sec_opd)
    return &ppc64_elf_section_data (sec)->u.opd;
  return NULL;
}

/* Parameters for the qsort hook.  */
static bfd_boolean synthetic_relocatable;

/* qsort comparison function for ppc64_elf_get_synthetic_symtab.  */

static int
compare_symbols (const void *ap, const void *bp)
{
  const asymbol *a = * (const asymbol **) ap;
  const asymbol *b = * (const asymbol **) bp;

  /* Section symbols first.  */
  if ((a->flags & BSF_SECTION_SYM) && !(b->flags & BSF_SECTION_SYM))
    return -1;
  if (!(a->flags & BSF_SECTION_SYM) && (b->flags & BSF_SECTION_SYM))
    return 1;

  /* then .opd symbols.  */
  if (strcmp (a->section->name, ".opd") == 0
      && strcmp (b->section->name, ".opd") != 0)
    return -1;
  if (strcmp (a->section->name, ".opd") != 0
      && strcmp (b->section->name, ".opd") == 0)
    return 1;

  /* then other code symbols.  */
  if ((a->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
      == (SEC_CODE | SEC_ALLOC)
      && (b->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 != (SEC_CODE | SEC_ALLOC))
    return -1;

  if ((a->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
      != (SEC_CODE | SEC_ALLOC)
      && (b->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 == (SEC_CODE | SEC_ALLOC))
    return 1;

  if (synthetic_relocatable)
    {
      if (a->section->id < b->section->id)
	return -1;

      if (a->section->id > b->section->id)
	return 1;
    }

  if (a->value + a->section->vma < b->value + b->section->vma)
    return -1;

  if (a->value + a->section->vma > b->value + b->section->vma)
    return 1;

  /* For syms with the same value, prefer strong dynamic global function
     syms over other syms.  */
  if ((a->flags & BSF_GLOBAL) != 0 && (b->flags & BSF_GLOBAL) == 0)
    return -1;

  if ((a->flags & BSF_GLOBAL) == 0 && (b->flags & BSF_GLOBAL) != 0)
    return 1;

  if ((a->flags & BSF_FUNCTION) != 0 && (b->flags & BSF_FUNCTION) == 0)
    return -1;

  if ((a->flags & BSF_FUNCTION) == 0 && (b->flags & BSF_FUNCTION) != 0)
    return 1;

  if ((a->flags & BSF_WEAK) == 0 && (b->flags & BSF_WEAK) != 0)
    return -1;

  if ((a->flags & BSF_WEAK) != 0 && (b->flags & BSF_WEAK) == 0)
    return 1;

  if ((a->flags & BSF_DYNAMIC) != 0 && (b->flags & BSF_DYNAMIC) == 0)
    return -1;

  if ((a->flags & BSF_DYNAMIC) == 0 && (b->flags & BSF_DYNAMIC) != 0)
    return 1;

  return 0;
}

/* Search SYMS for a symbol of the given VALUE.  */

static asymbol *
sym_exists_at (asymbol **syms, long lo, long hi, int id, bfd_vma value)
{
  long mid;

  if (id == -1)
    {
      while (lo < hi)
	{
	  mid = (lo + hi) >> 1;
	  if (syms[mid]->value + syms[mid]->section->vma < value)
	    lo = mid + 1;
	  else if (syms[mid]->value + syms[mid]->section->vma > value)
	    hi = mid;
	  else
	    return syms[mid];
	}
    }
  else
    {
      while (lo < hi)
	{
	  mid = (lo + hi) >> 1;
	  if (syms[mid]->section->id < id)
	    lo = mid + 1;
	  else if (syms[mid]->section->id > id)
	    hi = mid;
	  else if (syms[mid]->value < value)
	    lo = mid + 1;
	  else if (syms[mid]->value > value)
	    hi = mid;
	  else
	    return syms[mid];
	}
    }
  return NULL;
}

static bfd_boolean
section_covers_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *section, void *ptr)
{
  bfd_vma vma = *(bfd_vma *) ptr;
  return ((section->flags & SEC_ALLOC) != 0
	  && section->vma <= vma
	  && vma < section->vma + section->size);
}

/* Create synthetic symbols, effectively restoring "dot-symbol" function
   entry syms.  Also generate @@plt symbols for the glink branch table.  */

static long
ppc64_elf_get_synthetic_symtab (bfd *abfd,
				long static_count, asymbol **static_syms,
				long dyn_count, asymbol **dyn_syms,
				asymbol **ret)
{
  asymbol *s;
  long i;
  long count;
  char *names;
  long symcount, codesecsym, codesecsymend, secsymend, opdsymend;
  asection *opd;
  bfd_boolean relocatable = (abfd->flags & (EXEC_P | DYNAMIC)) == 0;
  asymbol **syms;

  *ret = NULL;

  opd = bfd_get_section_by_name (abfd, ".opd");
  if (opd == NULL)
    return 0;

  symcount = static_count;
  if (!relocatable)
    symcount += dyn_count;
  if (symcount == 0)
    return 0;

  syms = bfd_malloc ((symcount + 1) * sizeof (*syms));
  if (syms == NULL)
    return -1;

  if (!relocatable && static_count != 0 && dyn_count != 0)
    {
      /* Use both symbol tables.  */
      memcpy (syms, static_syms, static_count * sizeof (*syms));
      memcpy (syms + static_count, dyn_syms, (dyn_count + 1) * sizeof (*syms));
    }
  else if (!relocatable && static_count == 0)
    memcpy (syms, dyn_syms, (symcount + 1) * sizeof (*syms));
  else
    memcpy (syms, static_syms, (symcount + 1) * sizeof (*syms));

  synthetic_relocatable = relocatable;
  qsort (syms, symcount, sizeof (*syms), compare_symbols);

  if (!relocatable && symcount > 1)
    {
      long j;
      /* Trim duplicate syms, since we may have merged the normal and
	 dynamic symbols.  Actually, we only care about syms that have
	 different values, so trim any with the same value.  */
      for (i = 1, j = 1; i < symcount; ++i)
	if (syms[i - 1]->value + syms[i - 1]->section->vma
	    != syms[i]->value + syms[i]->section->vma)
	  syms[j++] = syms[i];
      symcount = j;
    }

  i = 0;
  if (strcmp (syms[i]->section->name, ".opd") == 0)
    ++i;
  codesecsym = i;

  for (; i < symcount; ++i)
    if (((syms[i]->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 != (SEC_CODE | SEC_ALLOC))
	|| (syms[i]->flags & BSF_SECTION_SYM) == 0)
      break;
  codesecsymend = i;

  for (; i < symcount; ++i)
    if ((syms[i]->flags & BSF_SECTION_SYM) == 0)
      break;
  secsymend = i;

  for (; i < symcount; ++i)
    if (strcmp (syms[i]->section->name, ".opd") != 0)
      break;
  opdsymend = i;

  for (; i < symcount; ++i)
    if ((syms[i]->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	!= (SEC_CODE | SEC_ALLOC))
      break;
  symcount = i;

  count = 0;

  if (relocatable)
    {
      bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
      arelent *r;
      size_t size;
      long relcount;

      if (opdsymend == secsymend)
	goto done;

      slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
      relcount = (opd->flags & SEC_RELOC) ? opd->reloc_count : 0;
      if (relcount == 0)
	goto done;

      if (!(*slurp_relocs) (abfd, opd, static_syms, FALSE))
	{
	  count = -1;
	  goto done;
	}

      size = 0;
      for (i = secsymend, r = opd->relocation; i < opdsymend; ++i)
	{
	  asymbol *sym;

	  while (r < opd->relocation + relcount
		 && r->address < syms[i]->value + opd->vma)
	    ++r;

	  if (r == opd->relocation + relcount)
	    break;

	  if (r->address != syms[i]->value + opd->vma)
	    continue;

	  if (r->howto->type != R_PPC64_ADDR64)
	    continue;

	  sym = *r->sym_ptr_ptr;
	  if (!sym_exists_at (syms, opdsymend, symcount,
			      sym->section->id, sym->value + r->addend))
	    {
	      ++count;
	      size += sizeof (asymbol);
	      size += strlen (syms[i]->name) + 2;
	    }
	}

      s = *ret = bfd_malloc (size);
      if (s == NULL)
	{
	  count = -1;
	  goto done;
	}

      names = (char *) (s + count);

      for (i = secsymend, r = opd->relocation; i < opdsymend; ++i)
	{
	  asymbol *sym;

	  while (r < opd->relocation + relcount
		 && r->address < syms[i]->value + opd->vma)
	    ++r;

	  if (r == opd->relocation + relcount)
	    break;

	  if (r->address != syms[i]->value + opd->vma)
	    continue;

	  if (r->howto->type != R_PPC64_ADDR64)
	    continue;

	  sym = *r->sym_ptr_ptr;
	  if (!sym_exists_at (syms, opdsymend, symcount,
			      sym->section->id, sym->value + r->addend))
	    {
	      size_t len;

	      *s = *syms[i];
	      s->flags |= BSF_SYNTHETIC;
	      s->section = sym->section;
	      s->value = sym->value + r->addend;
	      s->name = names;
	      *names++ = '.';
	      len = strlen (syms[i]->name);
	      memcpy (names, syms[i]->name, len + 1);
	      names += len + 1;
	      /* Have udata.p point back to the original symbol this
		 synthetic symbol was derived from.  */
	      s->udata.p = syms[i];
	      s++;
	    }
	}
    }
  else
    {
      bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
      bfd_byte *contents;
      size_t size;
      long plt_count = 0;
      bfd_vma glink_vma = 0, resolv_vma = 0;
      asection *dynamic, *glink = NULL, *relplt = NULL;
      arelent *p;

      if (!bfd_malloc_and_get_section (abfd, opd, &contents))
	{
	  if (contents)
	    {
	    free_contents_and_exit:
	      free (contents);
	    }
	  count = -1;
	  goto done;
	}

      size = 0;
      for (i = secsymend; i < opdsymend; ++i)
	{
	  bfd_vma ent;

	  /* Ignore bogus symbols.  */
	  if (syms[i]->value > opd->size - 8)
	    continue;

	  ent = bfd_get_64 (abfd, contents + syms[i]->value);
	  if (!sym_exists_at (syms, opdsymend, symcount, -1, ent))
	    {
	      ++count;
	      size += sizeof (asymbol);
	      size += strlen (syms[i]->name) + 2;
	    }
	}

      /* Get start of .glink stubs from DT_PPC64_GLINK.  */
      if (dyn_count != 0
	  && (dynamic = bfd_get_section_by_name (abfd, ".dynamic")) != NULL)
	{
	  bfd_byte *dynbuf, *extdyn, *extdynend;
	  size_t extdynsize;
	  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

	  if (!bfd_malloc_and_get_section (abfd, dynamic, &dynbuf))
	    goto free_contents_and_exit;

	  extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
	  swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

	  extdyn = dynbuf;
	  extdynend = extdyn + dynamic->size;
	  for (; extdyn < extdynend; extdyn += extdynsize)
	    {
	      Elf_Internal_Dyn dyn;
	      (*swap_dyn_in) (abfd, extdyn, &dyn);

	      if (dyn.d_tag == DT_NULL)
		break;

	      if (dyn.d_tag == DT_PPC64_GLINK)
		{
		  /* The first glink stub starts at offset 32; see comment in
		     ppc64_elf_finish_dynamic_sections. */
		  glink_vma = dyn.d_un.d_val + 32;
		  /* The .glink section usually does not survive the final
		     link; search for the section (usually .text) where the
		     glink stubs now reside.  */
		  glink = bfd_sections_find_if (abfd, section_covers_vma,
						&glink_vma);
		  break;
		}
	    }

	  free (dynbuf);
	}

      if (glink != NULL)
	{
	  /* Determine __glink trampoline by reading the relative branch
	     from the first glink stub.  */
	  bfd_byte buf[4];
	  if (bfd_get_section_contents (abfd, glink, buf,
					glink_vma + 4 - glink->vma, 4))
	    {
	      unsigned int insn = bfd_get_32 (abfd, buf);
	      insn ^= B_DOT;
	      if ((insn & ~0x3fffffc) == 0)
		resolv_vma = glink_vma + 4 + (insn ^ 0x2000000) - 0x2000000;
	    }

	  if (resolv_vma)
	    size += sizeof (asymbol) + sizeof ("__glink_PLTresolve");

	  relplt = bfd_get_section_by_name (abfd, ".rela.plt");
	  if (relplt != NULL)
	    {
	      slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
	      if (! (*slurp_relocs) (abfd, relplt, dyn_syms, TRUE))
		goto free_contents_and_exit;

	      plt_count = relplt->size / sizeof (Elf64_External_Rela);
	      size += plt_count * sizeof (asymbol);

	      p = relplt->relocation;
	      for (i = 0; i < plt_count; i++, p++)
		{
		  size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
		  if (p->addend != 0)
		    size += sizeof ("+0x") - 1 + 16;
		}
	    }
	}

      s = *ret = bfd_malloc (size);
      if (s == NULL)
	goto free_contents_and_exit;

      names = (char *) (s + count + plt_count + (resolv_vma != 0));

      for (i = secsymend; i < opdsymend; ++i)
	{
	  bfd_vma ent;

	  if (syms[i]->value > opd->size - 8)
	    continue;

	  ent = bfd_get_64 (abfd, contents + syms[i]->value);
	  if (!sym_exists_at (syms, opdsymend, symcount, -1, ent))
	    {
	      long lo, hi;
	      size_t len;
	      asection *sec = abfd->sections;

	      *s = *syms[i];
	      lo = codesecsym;
	      hi = codesecsymend;
	      while (lo < hi)
		{
		  long mid = (lo + hi) >> 1;
		  if (syms[mid]->section->vma < ent)
		    lo = mid + 1;
		  else if (syms[mid]->section->vma > ent)
		    hi = mid;
		  else
		    {
		      sec = syms[mid]->section;
		      break;
		    }
		}

	      if (lo >= hi && lo > codesecsym)
		sec = syms[lo - 1]->section;

	      for (; sec != NULL; sec = sec->next)
		{
		  if (sec->vma > ent)
		    break;
		  /* SEC_LOAD may not be set if SEC is from a separate debug
		     info file.  */
		  if ((sec->flags & SEC_ALLOC) == 0)
		    break;
		  if ((sec->flags & SEC_CODE) != 0)
		    s->section = sec;
		}
	      s->flags |= BSF_SYNTHETIC;
	      s->value = ent - s->section->vma;
	      s->name = names;
	      *names++ = '.';
	      len = strlen (syms[i]->name);
	      memcpy (names, syms[i]->name, len + 1);
	      names += len + 1;
	      /* Have udata.p point back to the original symbol this
		 synthetic symbol was derived from.  */
	      s->udata.p = syms[i];
	      s++;
	    }
	}
      free (contents);

      if (glink != NULL && relplt != NULL)
	{
	  if (resolv_vma)
	    {
	      /* Add a symbol for the main glink trampoline.  */
	      memset (s, 0, sizeof *s);
	      s->the_bfd = abfd;
	      s->flags = BSF_GLOBAL | BSF_SYNTHETIC;
	      s->section = glink;
	      s->value = resolv_vma - glink->vma;
	      s->name = names;
	      memcpy (names, "__glink_PLTresolve", sizeof ("__glink_PLTresolve"));
	      names += sizeof ("__glink_PLTresolve");
	      s++;
	      count++;
	    }

	  /* FIXME: It would be very much nicer to put sym@@plt on the
	     stub rather than on the glink branch table entry.  The
	     objdump disassembler would then use a sensible symbol
	     name on plt calls.  The difficulty in doing so is
	     a) finding the stubs, and,
	     b) matching stubs against plt entries, and,
	     c) there can be multiple stubs for a given plt entry.

	     Solving (a) could be done by code scanning, but older
	     ppc64 binaries used different stubs to current code.
	     (b) is the tricky one since you need to known the toc
	     pointer for at least one function that uses a pic stub to
	     be able to calculate the plt address referenced.
	     (c) means gdb would need to set multiple breakpoints (or
	     find the glink branch itself) when setting breakpoints
	     for pending shared library loads.  */
	  p = relplt->relocation;
	  for (i = 0; i < plt_count; i++, p++)
	    {
	      size_t len;

	      *s = **p->sym_ptr_ptr;
	      /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since
		 we are defining a symbol, ensure one of them is set.  */
	      if ((s->flags & BSF_LOCAL) == 0)
		s->flags |= BSF_GLOBAL;
	      s->flags |= BSF_SYNTHETIC;
	      s->section = glink;
	      s->value = glink_vma - glink->vma;
	      s->name = names;
	      s->udata.p = NULL;
	      len = strlen ((*p->sym_ptr_ptr)->name);
	      memcpy (names, (*p->sym_ptr_ptr)->name, len);
	      names += len;
	      if (p->addend != 0)
		{
		  memcpy (names, "+0x", sizeof ("+0x") - 1);
		  names += sizeof ("+0x") - 1;
		  bfd_sprintf_vma (abfd, names, p->addend);
		  names += strlen (names);
		}
	      memcpy (names, "@@plt", sizeof ("@@plt"));
	      names += sizeof ("@@plt");
	      s++;
	      glink_vma += 8;
	      if (i >= 0x8000)
		glink_vma += 4;
	    }
	  count += plt_count;
	}
    }

 done:
  free (syms);
  return count;
}

/* The following functions are specific to the ELF linker, while
   functions above are used generally.  Those named ppc64_elf_* are
   called by the main ELF linker code.  They appear in this file more
   or less in the order in which they are called.  eg.
   ppc64_elf_check_relocs is called early in the link process,
   ppc64_elf_finish_dynamic_sections is one of the last functions
   called.

   PowerPC64-ELF uses a similar scheme to PowerPC64-XCOFF in that
   functions have both a function code symbol and a function descriptor
   symbol.  A call to foo in a relocatable object file looks like:

   .		.text
   .	x:
   .		bl	.foo
   .		nop

   The function definition in another object file might be:

   .		.section .opd
   .	foo:	.quad	.foo
   .		.quad	.TOC.@@tocbase
   .		.quad	0
   .
   .		.text
   .	.foo:	blr

   When the linker resolves the call during a static link, the branch
   unsurprisingly just goes to .foo and the .opd information is unused.
   If the function definition is in a shared library, things are a little
   different:  The call goes via a plt call stub, the opd information gets
   copied to the plt, and the linker patches the nop.

   .	x:
   .		bl	.foo_stub
   .		ld	2,40(1)
   .
   .
   .	.foo_stub:
   .		addis	12,2,Lfoo@@toc@@ha	# in practice, the call stub
   .		addi	12,12,Lfoo@@toc@@l	# is slightly optimized, but
   .		std	2,40(1)			# this is the general idea
   .		ld	11,0(12)
   .		ld	2,8(12)
   .		mtctr	11
   .		ld	11,16(12)
   .		bctr
   .
   .		.section .plt
   .	Lfoo:	reloc (R_PPC64_JMP_SLOT, foo)

   The "reloc ()" notation is supposed to indicate that the linker emits
   an R_PPC64_JMP_SLOT reloc against foo.  The dynamic linker does the opd
   copying.

   What are the difficulties here?  Well, firstly, the relocations
   examined by the linker in check_relocs are against the function code
   sym .foo, while the dynamic relocation in the plt is emitted against
   the function descriptor symbol, foo.  Somewhere along the line, we need
   to carefully copy dynamic link information from one symbol to the other.
   Secondly, the generic part of the elf linker will make .foo a dynamic
   symbol as is normal for most other backends.  We need foo dynamic
   instead, at least for an application final link.  However, when
   creating a shared library containing foo, we need to have both symbols
   dynamic so that references to .foo are satisfied during the early
   stages of linking.  Otherwise the linker might decide to pull in a
   definition from some other object, eg. a static library.

   Update: As of August 2004, we support a new convention.  Function
   calls may use the function descriptor symbol, ie. "bl foo".  This
   behaves exactly as "bl .foo".  */

/* Of those relocs that might be copied as dynamic relocs, this function
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */

static int
must_be_dyn_reloc (struct bfd_link_info *info,
		   enum elf_ppc64_reloc_type r_type)
{
  switch (r_type)
    {
    default:
      return 1;

    case R_PPC64_REL32:
    case R_PPC64_REL64:
    case R_PPC64_REL30:
      return 0;

    case R_PPC64_TPREL16:
    case R_PPC64_TPREL16_LO:
    case R_PPC64_TPREL16_HI:
    case R_PPC64_TPREL16_HA:
    case R_PPC64_TPREL16_DS:
    case R_PPC64_TPREL16_LO_DS:
    case R_PPC64_TPREL16_HIGHER:
    case R_PPC64_TPREL16_HIGHERA:
    case R_PPC64_TPREL16_HIGHEST:
    case R_PPC64_TPREL16_HIGHESTA:
    case R_PPC64_TPREL64:
      return !info->executable;
    }
}

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  With code that gcc generates, it's vital that this be
   enabled;  In the PowerPC64 ABI, the address of a function is actually
   the address of a function descriptor, which resides in the .opd
   section.  gcc uses the descriptor directly rather than going via the
   GOT as some other ABI's do, which means that initialized function
   pointers must reference the descriptor.  Thus, a function pointer
   initialized to the address of a function in a shared library will
   either require a copy reloc, or a dynamic reloc.  Using a copy reloc
   redefines the function descriptor symbol to point to the copy.  This
   presents a problem as a plt entry for that function is also
   initialized from the function descriptor symbol and the copy reloc
   may not be initialized first.  */
#define ELIMINATE_COPY_RELOCS 1

/* Section name for stubs is the associated section name plus this
   string.  */
#define STUB_SUFFIX ".stub"

/* Linker stubs.
   ppc_stub_long_branch:
   Used when a 14 bit branch (or even a 24 bit branch) can't reach its
   destination, but a 24 bit branch in a stub section will reach.
   .	b	dest

   ppc_stub_plt_branch:
   Similar to the above, but a 24 bit branch in the stub section won't
   reach its destination.
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
   .	mtctr	%r11
   .	bctr

   ppc_stub_plt_call:
   Used to call a function in a shared library.  If it so happens that
   the plt entry referenced crosses a 64k boundary, then an extra
   "addi %r12,%r12,xxx@@toc@@l" will be inserted before the "mtctr".
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	std	%r2,40(%r1)
   .	ld	%r11,xxx+0@@toc@@l(%r12)
   .	mtctr	%r11
   .	ld	%r2,xxx+8@@toc@@l(%r12)
   .	ld	%r11,xxx+16@@toc@@l(%r12)
   .	bctr

   ppc_stub_long_branch and ppc_stub_plt_branch may also have additional
   code to adjust the value and save r2 to support multiple toc sections.
   A ppc_stub_long_branch with an r2 offset looks like:
   .	std	%r2,40(%r1)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
   .	b	dest

   A ppc_stub_plt_branch with an r2 offset looks like:
   .	std	%r2,40(%r1)
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
   .	mtctr	%r11
   .	bctr

   In cases where the "addis" instruction would add zero, the "addis" is
   omitted and following instructions modified slightly in some cases.
*/

enum ppc_stub_type {
  ppc_stub_none,
  ppc_stub_long_branch,
  ppc_stub_long_branch_r2off,
  ppc_stub_plt_branch,
  ppc_stub_plt_branch_r2off,
  ppc_stub_plt_call,
  ppc_stub_plt_call_r2save
};

struct ppc_stub_hash_entry {

  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  enum ppc_stub_type stub_type;

  /* The stub section.  */
  asection *stub_sec;

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;

  /* Given the symbol's value and its section we can determine its final
     value when building the stubs (so the stub knows where to jump.  */
  bfd_vma target_value;
  asection *target_section;

  /* The symbol table entry, if any, that this was derived from.  */
  struct ppc_link_hash_entry *h;
  struct plt_entry *plt_ent;

  /* Where this stub is being called from, or, in the case of combined
     stub sections, the first input section in the group.  */
  asection *id_sec;
};

struct ppc_branch_hash_entry {

  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  /* Offset within branch lookup table.  */
  unsigned int offset;

  /* Generation marker.  */
  unsigned int iter;
};

/* Used to track dynamic relocations for local symbols.  */
struct ppc_dyn_relocs
{
  struct ppc_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  unsigned int count : 31;

  /* Whether this entry is for STT_GNU_IFUNC symbols.  */
  unsigned int ifunc : 1;
};

struct ppc_link_hash_entry
{
  struct elf_link_hash_entry elf;

  union {
    /* A pointer to the most recently used stub hash entry against this
       symbol.  */
    struct ppc_stub_hash_entry *stub_cache;

    /* A pointer to the next symbol starting with a '.'  */
    struct ppc_link_hash_entry *next_dot_sym;
  } u;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

  /* Link between function code and descriptor symbols.  */
  struct ppc_link_hash_entry *oh;

  /* Flag function code and descriptor symbols.  */
  unsigned int is_func:1;
  unsigned int is_func_descriptor:1;
  unsigned int fake:1;

  /* Whether global opd/toc sym has been adjusted or not.
     After ppc64_elf_edit_opd/ppc64_elf_edit_toc has run, this flag
     should be set for all globals defined in any opd/toc section.  */
  unsigned int adjust_done:1;

  /* Set if we twiddled this symbol to weak at some stage.  */
  unsigned int was_undefined:1;

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.
     tls_optimize may also set TLS_TPRELGD when a GD reloc turns into
     a TPREL one.  We use a separate flag rather than setting TPREL
     just for convenience in distinguishing the two cases.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_EXPLICIT	32	/* Marks TOC section TLS relocs. */
#define TLS_TPRELGD	64	/* TPREL reloc resulting from GD->IE. */
#define PLT_IFUNC      128	/* STT_GNU_IFUNC.  */
  unsigned char tls_mask;
};

/* ppc64 ELF linker hash table.  */

struct ppc_link_hash_table
{
  struct elf_link_hash_table elf;

  /* The stub hash table.  */
  struct bfd_hash_table stub_hash_table;

  /* Another hash table for plt_branch stubs.  */
  struct bfd_hash_table branch_hash_table;

  /* Hash table for function prologue tocsave.  */
  htab_t tocsave_htab;

  /* Linker stub bfd.  */
  bfd *stub_bfd;

  /* Linker call-backs.  */
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);

  /* Array to keep track of which stub sections have been created, and
     information on stub grouping.  */
  struct map_stub {
    /* This is the section to which stubs in the group will be attached.  */
    asection *link_sec;
    /* The stub section.  */
    asection *stub_sec;
    /* Along with elf_gp, specifies the TOC pointer used in this group.  */
    bfd_vma toc_off;
  } *stub_group;

  /* Temp used when calculating TOC pointers.  */
  bfd_vma toc_curr;
  bfd *toc_bfd;
  asection *toc_first_sec;

  /* Highest input section id.  */
  int top_id;

  /* Highest output section index.  */
  int top_index;

  /* Used when adding symbols.  */
  struct ppc_link_hash_entry *dot_syms;

  /* List of input sections for each output section.  */
  asection **input_list;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *got;
  asection *plt;
  asection *relplt;
  asection *iplt;
  asection *reliplt;
  asection *dynbss;
  asection *relbss;
  asection *glink;
  asection *sfpr;
  asection *brlt;
  asection *relbrlt;
  asection *glink_eh_frame;

  /* Shortcut to .__tls_get_addr and __tls_get_addr.  */
  struct ppc_link_hash_entry *tls_get_addr;
  struct ppc_link_hash_entry *tls_get_addr_fd;

  /* The size of reliplt used by got entry relocs.  */
  bfd_size_type got_reli_size;

  /* Statistics.  */
  unsigned long stub_count[ppc_stub_plt_call_r2save];

  /* Number of stubs against global syms.  */
  unsigned long stub_globals;

  /* Alignment of PLT call stubs.  */
  unsigned int plt_stub_align:4;

  /* Set if PLT call stubs should load r11.  */
  unsigned int plt_static_chain:1;

  /* Set if PLT call stubs need a read-read barrier.  */
  unsigned int plt_thread_safe:1;

  /* Set if we should emit symbols for stubs.  */
  unsigned int emit_stub_syms:1;

  /* Set if __tls_get_addr optimization should not be done.  */
  unsigned int no_tls_get_addr_opt:1;

  /* Support for multiple toc sections.  */
  unsigned int do_multi_toc:1;
  unsigned int multi_toc_needed:1;
  unsigned int second_toc_pass:1;
  unsigned int do_toc_opt:1;

  /* Set on error.  */
  unsigned int stub_error:1;

  /* Temp used by ppc64_elf_process_dot_syms.  */
  unsigned int twiddled_syms:1;

  /* Incremented every time we size stubs.  */
  unsigned int stub_iteration;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

/* Rename some of the generic section flags to better document how they
   are used here.  */

/* Nonzero if this section has TLS related relocations.  */
#define has_tls_reloc sec_flg0

/* Nonzero if this section has a call to __tls_get_addr.  */
#define has_tls_get_addr_call sec_flg1

/* Nonzero if this section has any toc or got relocs.  */
#define has_toc_reloc sec_flg2

/* Nonzero if this section has a call to another section that uses
   the toc or got.  */
#define makes_toc_func_call sec_flg3

/* Recursion protection when determining above flag.  */
#define call_check_in_progress sec_flg4
#define call_check_done sec_flg5

/* Get the ppc64 ELF linker hash table from a link_info structure.  */

#define ppc_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == PPC64_ELF_DATA ? ((struct ppc_link_hash_table *) ((p)->hash)) : NULL)

#define ppc_stub_hash_lookup(table, string, create, copy) \
  ((struct ppc_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

#define ppc_branch_hash_lookup(table, string, create, copy) \
  ((struct ppc_branch_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

/* Create an entry in the stub hash table.  */

static struct bfd_hash_entry *
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct ppc_stub_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct ppc_stub_hash_entry *eh;

      /* Initialize the local fields.  */
      eh = (struct ppc_stub_hash_entry *) entry;
      eh->stub_type = ppc_stub_none;
      eh->stub_sec = NULL;
      eh->stub_offset = 0;
      eh->target_value = 0;
      eh->target_section = NULL;
      eh->h = NULL;
      eh->id_sec = NULL;
    }

  return entry;
}

/* Create an entry in the branch hash table.  */

static struct bfd_hash_entry *
branch_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table,
		     const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct ppc_branch_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct ppc_branch_hash_entry *eh;

      /* Initialize the local fields.  */
      eh = (struct ppc_branch_hash_entry *) entry;
      eh->offset = 0;
      eh->iter = 0;
    }

  return entry;
}

/* Create an entry in a ppc64 ELF linker hash table.  */

static struct bfd_hash_entry *
link_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct ppc_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) entry;

      memset (&eh->u.stub_cache, 0,
	      (sizeof (struct ppc_link_hash_entry)
	       - offsetof (struct ppc_link_hash_entry, u.stub_cache)));

      /* When making function calls, old ABI code references function entry
	 points (dot symbols), while new ABI code references the function
	 descriptor symbol.  We need to make any combination of reference and
	 definition work together, without breaking archive linking.

	 For a defined function "foo" and an undefined call to "bar":
	 An old object defines "foo" and ".foo", references ".bar" (possibly
	 "bar" too).
	 A new object defines "foo" and references "bar".

	 A new object thus has no problem with its undefined symbols being
	 satisfied by definitions in an old object.  On the other hand, the
	 old object won't have ".bar" satisfied by a new object.

	 Keep a list of newly added dot-symbols.  */

      if (string[0] == '.')
	{
	  struct ppc_link_hash_table *htab;

	  htab = (struct ppc_link_hash_table *) table;
	  eh->u.next_dot_sym = htab->dot_syms;
	  htab->dot_syms = eh;
	}
    }

  return entry;
}

struct tocsave_entry {
  asection *sec;
  bfd_vma offset;
};

static hashval_t
tocsave_htab_hash (const void *p)
{
  const struct tocsave_entry *e = (const struct tocsave_entry *) p;
  return ((bfd_vma)(intptr_t) e->sec ^ e->offset) >> 3;
}

static int
tocsave_htab_eq (const void *p1, const void *p2)
{
  const struct tocsave_entry *e1 = (const struct tocsave_entry *) p1;
  const struct tocsave_entry *e2 = (const struct tocsave_entry *) p2;
  return e1->sec == e2->sec && e1->offset == e2->offset;
}

/* Create a ppc64 ELF linker hash table.  */

static struct bfd_link_hash_table *
ppc64_elf_link_hash_table_create (bfd *abfd)
{
  struct ppc_link_hash_table *htab;
  bfd_size_type amt = sizeof (struct ppc_link_hash_table);

  htab = bfd_zmalloc (amt);
  if (htab == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&htab->elf, abfd, link_hash_newfunc,
				      sizeof (struct ppc_link_hash_entry),
				      PPC64_ELF_DATA))
    {
      free (htab);
      return NULL;
    }

  /* Init the stub hash table too.  */
  if (!bfd_hash_table_init (&htab->stub_hash_table, stub_hash_newfunc,
			    sizeof (struct ppc_stub_hash_entry)))
    return NULL;

  /* And the branch hash table.  */
  if (!bfd_hash_table_init (&htab->branch_hash_table, branch_hash_newfunc,
			    sizeof (struct ppc_branch_hash_entry)))
    return NULL;

  htab->tocsave_htab = htab_try_create (1024,
					tocsave_htab_hash,
					tocsave_htab_eq,
					NULL);
  if (htab->tocsave_htab == NULL)
    return NULL;

  /* Initializing two fields of the union is just cosmetic.  We really
     only care about glist, but when compiled on a 32-bit host the
     bfd_vma fields are larger.  Setting the bfd_vma to zero makes
     debugger inspection of these fields look nicer.  */
  htab->elf.init_got_refcount.refcount = 0;
  htab->elf.init_got_refcount.glist = NULL;
  htab->elf.init_plt_refcount.refcount = 0;
  htab->elf.init_plt_refcount.glist = NULL;
  htab->elf.init_got_offset.offset = 0;
  htab->elf.init_got_offset.glist = NULL;
  htab->elf.init_plt_offset.offset = 0;
  htab->elf.init_plt_offset.glist = NULL;

  return &htab->elf.root;
}

/* Free the derived linker hash table.  */

static void
ppc64_elf_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct ppc_link_hash_table *htab = (struct ppc_link_hash_table *) hash;

  bfd_hash_table_free (&htab->stub_hash_table);
  bfd_hash_table_free (&htab->branch_hash_table);
  if (htab->tocsave_htab)
    htab_delete (htab->tocsave_htab);
  _bfd_elf_link_hash_table_free (hash);
}

/* Create sections for linker generated code.  */

static bfd_boolean
create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  flagword flags;

  htab = ppc_hash_table (info);

  /* Create .sfpr for code to save and restore fp regs.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->sfpr = bfd_make_section_anyway_with_flags (dynobj, ".sfpr",
						   flags);
  if (htab->sfpr == NULL
      || ! bfd_set_section_alignment (dynobj, htab->sfpr, 2))
    return FALSE;

  /* Create .glink for lazy dynamic linking support.  */
  htab->glink = bfd_make_section_anyway_with_flags (dynobj, ".glink",
						    flags);
  if (htab->glink == NULL
      || ! bfd_set_section_alignment (dynobj, htab->glink, 3))
    return FALSE;

  if (!info->no_ld_generated_unwind_info)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->glink_eh_frame = bfd_make_section_anyway_with_flags (dynobj,
								 ".eh_frame",
								 flags);
      if (htab->glink_eh_frame == NULL
	  || !bfd_set_section_alignment (dynobj, htab->glink_eh_frame, 2))
	return FALSE;
    }

  flags = SEC_ALLOC | SEC_LINKER_CREATED;
  htab->iplt = bfd_make_section_anyway_with_flags (dynobj, ".iplt", flags);
  if (htab->iplt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->iplt, 3))
    return FALSE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->reliplt = bfd_make_section_anyway_with_flags (dynobj,
						      ".rela.iplt",
						      flags);
  if (htab->reliplt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->reliplt, 3))
    return FALSE;

  /* Create branch lookup table for plt_branch stubs.  */
  flags = (SEC_ALLOC | SEC_LOAD
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->brlt = bfd_make_section_anyway_with_flags (dynobj, ".branch_lt",
						   flags);
  if (htab->brlt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->brlt, 3))
    return FALSE;

  if (!info->shared)
    return TRUE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->relbrlt = bfd_make_section_anyway_with_flags (dynobj,
						      ".rela.branch_lt",
						      flags);
  if (htab->relbrlt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->relbrlt, 3))
    return FALSE;

  return TRUE;
}

/* Satisfy the ELF linker by filling in some fields in our fake bfd.  */

bfd_boolean
ppc64_elf_init_stub_bfd (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  elf_elfheader (abfd)->e_ident[EI_CLASS] = ELFCLASS64;

/* Always hook our dynamic sections into the first bfd, which is the
   linker created stub bfd.  This ensures that the GOT header is at
   the start of the output TOC section.  */
  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;
  htab->stub_bfd = abfd;
  htab->elf.dynobj = abfd;

  if (info->relocatable)
    return TRUE;

  return create_linkage_sections (htab->elf.dynobj, info);
}

/* Build a name for an entry in the stub hash table.  */

static char *
ppc_stub_name (const asection *input_section,
	       const asection *sym_sec,
	       const struct ppc_link_hash_entry *h,
	       const Elf_Internal_Rela *rel)
{
  char *stub_name;
  ssize_t len;

  /* rel->r_addend is actually 64 bit, but who uses more than +/- 2^31
     offsets from a sym as a branch target?  In fact, we could
     probably assume the addend is always zero.  */
  BFD_ASSERT (((int) rel->r_addend & 0xffffffff) == rel->r_addend);

  if (h)
    {
      len = 8 + 1 + strlen (h->elf.root.root.string) + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name == NULL)
	return stub_name;

      len = sprintf (stub_name, "%08x.%s+%x",
		     input_section->id & 0xffffffff,
		     h->elf.root.root.string,
		     (int) rel->r_addend & 0xffffffff);
    }
  else
    {
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
      stub_name = bfd_malloc (len);
      if (stub_name == NULL)
	return stub_name;

      len = sprintf (stub_name, "%08x.%x:%x+%x",
		     input_section->id & 0xffffffff,
		     sym_sec->id & 0xffffffff,
		     (int) ELF64_R_SYM (rel->r_info) & 0xffffffff,
		     (int) rel->r_addend & 0xffffffff);
    }
  if (len > 2 && stub_name[len - 2] == '+' && stub_name[len - 1] == '0')
    stub_name[len - 2] = 0;
  return stub_name;
}

/* Look up an entry in the stub hash.  Stub entries are cached because
   creating the stub name takes a bit of time.  */

static struct ppc_stub_hash_entry *
ppc_get_stub_entry (const asection *input_section,
		    const asection *sym_sec,
		    struct ppc_link_hash_entry *h,
		    const Elf_Internal_Rela *rel,
		    struct ppc_link_hash_table *htab)
{
  struct ppc_stub_hash_entry *stub_entry;
  const asection *id_sec;

  /* If this input section is part of a group of sections sharing one
     stub section, then use the id of the first section in the group.
     Stub names need to include a section id, as there may well be
     more than one stub used to reach say, printf, and we need to
     distinguish between them.  */
  id_sec = htab->stub_group[input_section->id].link_sec;

  if (h != NULL && h->u.stub_cache != NULL
      && h->u.stub_cache->h == h
      && h->u.stub_cache->id_sec == id_sec)
    {
      stub_entry = h->u.stub_cache;
    }
  else
    {
      char *stub_name;

      stub_name = ppc_stub_name (id_sec, sym_sec, h, rel);
      if (stub_name == NULL)
	return NULL;

      stub_entry = ppc_stub_hash_lookup (&htab->stub_hash_table,
					 stub_name, FALSE, FALSE);
      if (h != NULL)
	h->u.stub_cache = stub_entry;

      free (stub_name);
    }

  return stub_entry;
}

/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct ppc_stub_hash_entry *
ppc_add_stub (const char *stub_name,
	      asection *section,
	      struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  asection *link_sec;
  asection *stub_sec;
  struct ppc_stub_hash_entry *stub_entry;

  link_sec = htab->stub_group[section->id].link_sec;
  stub_sec = htab->stub_group[section->id].stub_sec;
  if (stub_sec == NULL)
    {
      stub_sec = htab->stub_group[link_sec->id].stub_sec;
      if (stub_sec == NULL)
	{
	  size_t namelen;
	  bfd_size_type len;
	  char *s_name;

	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
	  s_name = bfd_alloc (htab->stub_bfd, len);
	  if (s_name == NULL)
	    return NULL;

	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
	  if (stub_sec == NULL)
	    return NULL;
	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
	}
      htab->stub_group[section->id].stub_sec = stub_sec;
    }

  /* Enter this entry into the linker stub hash table.  */
  stub_entry = ppc_stub_hash_lookup (&htab->stub_hash_table, stub_name,
				     TRUE, FALSE);
  if (stub_entry == NULL)
    {
      info->callbacks->einfo (_("%P: %B: cannot create stub entry %s\n"),
			      section->owner, stub_name);
      return NULL;
    }

  stub_entry->stub_sec = stub_sec;
  stub_entry->stub_offset = 0;
  stub_entry->id_sec = link_sec;
  return stub_entry;
}

/* Create .got and .rela.got sections in ABFD, and .got in dynobj if
   not already done.  */

static bfd_boolean
create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  asection *got, *relgot;
  flagword flags;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (!is_ppc64_elf (abfd))
    return FALSE;
  if (htab == NULL)
    return FALSE;

  if (!htab->got)
    {
      if (! _bfd_elf_create_got_section (htab->elf.dynobj, info))
	return FALSE;

      htab->got = bfd_get_linker_section (htab->elf.dynobj, ".got");
      if (!htab->got)
	abort ();
    }

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  got = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (!got
      || !bfd_set_section_alignment (abfd, got, 3))
    return FALSE;

  relgot = bfd_make_section_anyway_with_flags (abfd, ".rela.got",
					       flags | SEC_READONLY);
  if (!relgot
      || ! bfd_set_section_alignment (abfd, relgot, 3))
    return FALSE;

  ppc64_elf_tdata (abfd)->got = got;
  ppc64_elf_tdata (abfd)->relgot = relgot;
  return TRUE;
}

/* Create the dynamic sections, and set up shortcuts.  */

static bfd_boolean
ppc64_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (!htab->got)
    htab->got = bfd_get_linker_section (dynobj, ".got");
  htab->plt = bfd_get_linker_section (dynobj, ".plt");
  htab->relplt = bfd_get_linker_section (dynobj, ".rela.plt");
  htab->dynbss = bfd_get_linker_section (dynobj, ".dynbss");
  if (!info->shared)
    htab->relbss = bfd_get_linker_section (dynobj, ".rela.bss");

  if (!htab->got || !htab->plt || !htab->relplt || !htab->dynbss
      || (!info->shared && !htab->relbss))
    abort ();

  return TRUE;
}

/* Follow indirect and warning symbol links.  */

static inline struct bfd_link_hash_entry *
follow_link (struct bfd_link_hash_entry *h)
{
  while (h->type == bfd_link_hash_indirect
	 || h->type == bfd_link_hash_warning)
    h = h->u.i.link;
  return h;
}

static inline struct elf_link_hash_entry *
elf_follow_link (struct elf_link_hash_entry *h)
{
  return (struct elf_link_hash_entry *) follow_link (&h->root);
}

static inline struct ppc_link_hash_entry *
ppc_follow_link (struct ppc_link_hash_entry *h)
{
  return (struct ppc_link_hash_entry *) follow_link (&h->elf.root);
}

/* Merge PLT info on FROM with that on TO.  */

static void
move_plt_plist (struct ppc_link_hash_entry *from,
		struct ppc_link_hash_entry *to)
{
  if (from->elf.plt.plist != NULL)
    {
      if (to->elf.plt.plist != NULL)
	{
	  struct plt_entry **entp;
	  struct plt_entry *ent;

	  for (entp = &from->elf.plt.plist; (ent = *entp) != NULL; )
	    {
	      struct plt_entry *dent;

	      for (dent = to->elf.plt.plist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend)
		  {
		    dent->plt.refcount += ent->plt.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = to->elf.plt.plist;
	}

      to->elf.plt.plist = from->elf.plt.plist;
      from->elf.plt.plist = NULL;
    }
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct ppc_link_hash_entry *edir, *eind;

  edir = (struct ppc_link_hash_entry *) dir;
  eind = (struct ppc_link_hash_entry *) ind;

  edir->is_func |= eind->is_func;
  edir->is_func_descriptor |= eind->is_func_descriptor;
  edir->tls_mask |= eind->tls_mask;
  if (eind->oh != NULL)
    edir->oh = ppc_follow_link (eind->oh);

  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (!(ELIMINATE_COPY_RELOCS
	&& eind->elf.root.type != bfd_link_hash_indirect
	&& edir->elf.dynamic_adjusted))
    edir->elf.non_got_ref |= eind->elf.non_got_ref;

  edir->elf.ref_dynamic |= eind->elf.ref_dynamic;
  edir->elf.ref_regular |= eind->elf.ref_regular;
  edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
  edir->elf.needs_plt |= eind->elf.needs_plt;

  /* Copy over any dynamic relocs we may have on the indirect sym.  */
  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  /* If we were called to copy over info for a weak sym, that's all.
     You might think dyn_relocs need not be copied over;  After all,
     both syms will be dynamic or both non-dynamic so we're just
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS
     code in ppc64_elf_adjust_dynamic_symbol needs to check for
     dyn_relocs in read-only sections, and it does so on what is the
     DIR sym here.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

  /* Copy over got entries that we may have already seen to the
     symbol which just became indirect.  */
  if (eind->elf.got.glist != NULL)
    {
      if (edir->elf.got.glist != NULL)
	{
	  struct got_entry **entp;
	  struct got_entry *ent;

	  for (entp = &eind->elf.got.glist; (ent = *entp) != NULL; )
	    {
	      struct got_entry *dent;

	      for (dent = edir->elf.got.glist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend
		    && dent->owner == ent->owner
		    && dent->tls_type == ent->tls_type)
		  {
		    dent->got.refcount += ent->got.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.got.glist;
	}

      edir->elf.got.glist = eind->elf.got.glist;
      eind->elf.got.glist = NULL;
    }

  /* And plt entries.  */
  move_plt_plist (eind, edir);

  if (eind->elf.dynindx != -1)
    {
      if (edir->elf.dynindx != -1)
	_bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				edir->elf.dynstr_index);
      edir->elf.dynindx = eind->elf.dynindx;
      edir->elf.dynstr_index = eind->elf.dynstr_index;
      eind->elf.dynindx = -1;
      eind->elf.dynstr_index = 0;
    }
}

/* Find the function descriptor hash entry from the given function code
   hash entry FH.  Link the entries via their OH fields.  */

static struct ppc_link_hash_entry *
lookup_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
{
  struct ppc_link_hash_entry *fdh = fh->oh;

  if (fdh == NULL)
    {
      const char *fd_name = fh->elf.root.root.string + 1;

      fdh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);
      if (fdh == NULL)
	return fdh;

      fdh->is_func_descriptor = 1;
      fdh->oh = fh;
      fh->is_func = 1;
      fh->oh = fdh;
    }

  return ppc_follow_link (fdh);
}

/* Make a fake function descriptor sym for the code sym FH.  */

static struct ppc_link_hash_entry *
make_fdh (struct bfd_link_info *info,
	  struct ppc_link_hash_entry *fh)
{
  bfd *abfd;
  asymbol *newsym;
  struct bfd_link_hash_entry *bh;
  struct ppc_link_hash_entry *fdh;

  abfd = fh->elf.root.u.undef.abfd;
  newsym = bfd_make_empty_symbol (abfd);
  newsym->name = fh->elf.root.root.string + 1;
  newsym->section = bfd_und_section_ptr;
  newsym->value = 0;
  newsym->flags = BSF_WEAK;

  bh = NULL;
  if (!_bfd_generic_link_add_one_symbol (info, abfd, newsym->name,
					 newsym->flags, newsym->section,
					 newsym->value, NULL, FALSE, FALSE,
					 &bh))
    return NULL;

  fdh = (struct ppc_link_hash_entry *) bh;
  fdh->elf.non_elf = 0;
  fdh->fake = 1;
  fdh->is_func_descriptor = 1;
  fdh->oh = fh;
  fh->is_func = 1;
  fh->oh = fdh;
  return fdh;
}

/* Fix function descriptor symbols defined in .opd sections to be
   function type.  */

static bfd_boolean
ppc64_elf_add_symbol_hook (bfd *ibfd,
			   struct bfd_link_info *info,
			   Elf_Internal_Sym *isym,
			   const char **name ATTRIBUTE_UNUSED,
			   flagword *flags ATTRIBUTE_UNUSED,
			   asection **sec,
			   bfd_vma *value ATTRIBUTE_UNUSED)
{
  if ((ibfd->flags & DYNAMIC) == 0
      && ELF_ST_BIND (isym->st_info) == STB_GNU_UNIQUE)
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
    {
      if ((ibfd->flags & DYNAMIC) == 0)
	elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;
    }
  else if (ELF_ST_TYPE (isym->st_info) == STT_FUNC)
    ;
  else if (*sec != NULL
	   && strcmp ((*sec)->name, ".opd") == 0)
    isym->st_info = ELF_ST_INFO (ELF_ST_BIND (isym->st_info), STT_FUNC);

  return TRUE;
}

/* This function makes an old ABI object reference to ".bar" cause the
   inclusion of a new ABI object archive that defines "bar".
   NAME is a symbol defined in an archive.  Return a symbol in the hash
   table that might be satisfied by the archive symbols.  */

static struct elf_link_hash_entry *
ppc64_elf_archive_symbol_lookup (bfd *abfd,
				 struct bfd_link_info *info,
				 const char *name)
{
  struct elf_link_hash_entry *h;
  char *dot_name;
  size_t len;

  h = _bfd_elf_archive_symbol_lookup (abfd, info, name);
  if (h != NULL
      /* Don't return this sym if it is a fake function descriptor
	 created by add_symbol_adjust.  */
      && !(h->root.type == bfd_link_hash_undefweak
	   && ((struct ppc_link_hash_entry *) h)->fake))
    return h;

  if (name[0] == '.')
    return h;

  len = strlen (name);
  dot_name = bfd_alloc (abfd, len + 2);
  if (dot_name == NULL)
    return (struct elf_link_hash_entry *) 0 - 1;
  dot_name[0] = '.';
  memcpy (dot_name + 1, name, len + 1);
  h = _bfd_elf_archive_symbol_lookup (abfd, info, dot_name);
  bfd_release (abfd, dot_name);
  return h;
}

/* This function satisfies all old ABI object references to ".bar" if a
   new ABI object defines "bar".  Well, at least, undefined dot symbols
   are made weak.  This stops later archive searches from including an
   object if we already have a function descriptor definition.  It also
   prevents the linker complaining about undefined symbols.
   We also check and correct mismatched symbol visibility here.  The
   most restrictive visibility of the function descriptor and the
   function entry symbol is used.  */

static bfd_boolean
add_symbol_adjust (struct ppc_link_hash_entry *eh, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  struct ppc_link_hash_entry *fdh;

  if (eh->elf.root.type == bfd_link_hash_indirect)
    return TRUE;

  if (eh->elf.root.type == bfd_link_hash_warning)
    eh = (struct ppc_link_hash_entry *) eh->elf.root.u.i.link;

  if (eh->elf.root.root.string[0] != '.')
    abort ();

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  fdh = lookup_fdh (eh, htab);
  if (fdh == NULL)
    {
      if (!info->relocatable
	  && (eh->elf.root.type == bfd_link_hash_undefined
	      || eh->elf.root.type == bfd_link_hash_undefweak)
	  && eh->elf.ref_regular)
	{
	  /* Make an undefweak function descriptor sym, which is enough to
	     pull in an --as-needed shared lib, but won't cause link
	     errors.  Archives are handled elsewhere.  */
	  fdh = make_fdh (info, eh);
	  if (fdh == NULL)
	    return FALSE;
	  fdh->elf.ref_regular = 1;
	}
    }
  else
    {
      unsigned entry_vis = ELF_ST_VISIBILITY (eh->elf.other) - 1;
      unsigned descr_vis = ELF_ST_VISIBILITY (fdh->elf.other) - 1;
      if (entry_vis < descr_vis)
	fdh->elf.other += entry_vis - descr_vis;
      else if (entry_vis > descr_vis)
	eh->elf.other += descr_vis - entry_vis;

      if ((fdh->elf.root.type == bfd_link_hash_defined
	   || fdh->elf.root.type == bfd_link_hash_defweak)
	  && eh->elf.root.type == bfd_link_hash_undefined)
	{
	  eh->elf.root.type = bfd_link_hash_undefweak;
	  eh->was_undefined = 1;
	  htab->twiddled_syms = 1;
	}
    }

  return TRUE;
}

/* Process list of dot-symbols we made in link_hash_newfunc.  */

static bfd_boolean
ppc64_elf_process_dot_syms (bfd *ibfd, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  struct ppc_link_hash_entry **p, *eh;

  if (!is_ppc64_elf (info->output_bfd))
    return TRUE;
  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (is_ppc64_elf (ibfd))
    {
      p = &htab->dot_syms;
      while ((eh = *p) != NULL)
	{
	  *p = NULL;
	  if (&eh->elf == htab->elf.hgot)
	    ;
	  else if (htab->elf.hgot == NULL
		   && strcmp (eh->elf.root.root.string, ".TOC.") == 0)
	    htab->elf.hgot = &eh->elf;
	  else if (!add_symbol_adjust (eh, info))
	    return FALSE;
	  p = &eh->u.next_dot_sym;
	}
    }

  /* Clear the list for non-ppc64 input files.  */
  p = &htab->dot_syms;
  while ((eh = *p) != NULL)
    {
      *p = NULL;
      p = &eh->u.next_dot_sym;
    }

  /* We need to fix the undefs list for any syms we have twiddled to
     undef_weak.  */
  if (htab->twiddled_syms)
    {
      bfd_link_repair_undef_list (&htab->elf.root);
      htab->twiddled_syms = 0;
    }
  return TRUE;
}

/* Undo hash table changes when an --as-needed input file is determined
   not to be needed.  */

static bfd_boolean
ppc64_elf_notice_as_needed (bfd *ibfd,
			    struct bfd_link_info *info,
			    enum notice_asneeded_action act)
{
  if (act == notice_not_needed)
    {
      struct ppc_link_hash_table *htab = ppc_hash_table (info);

      if (htab == NULL)
	return FALSE;

      htab->dot_syms = NULL;
    }
  return _bfd_elf_notice_as_needed (ibfd, info, act);
}

/* If --just-symbols against a final linked binary, then assume we need
   toc adjusting stubs when calling functions defined there.  */

static void
ppc64_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
{
  if ((sec->flags & SEC_CODE) != 0
      && (sec->owner->flags & (EXEC_P | DYNAMIC)) != 0
      && is_ppc64_elf (sec->owner))
    {
      asection *got = bfd_get_section_by_name (sec->owner, ".got");
      if (got != NULL
	  && got->size >= elf_backend_got_header_size
	  && bfd_get_section_by_name (sec->owner, ".opd") != NULL)
	sec->has_toc_reloc = 1;
    }
  _bfd_elf_link_just_syms (sec, info);
}

static struct plt_entry **
update_local_sym_info (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx, bfd_vma r_addend, int tls_type)
{
  struct got_entry **local_got_ents = elf_local_got_ents (abfd);
  struct plt_entry **local_plt;
  unsigned char *local_got_tls_masks;

  if (local_got_ents == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= (sizeof (*local_got_ents)
	       + sizeof (*local_plt)
	       + sizeof (*local_got_tls_masks));
      local_got_ents = bfd_zalloc (abfd, size);
      if (local_got_ents == NULL)
	return NULL;
      elf_local_got_ents (abfd) = local_got_ents;
    }

  if ((tls_type & (PLT_IFUNC | TLS_EXPLICIT)) == 0)
    {
      struct got_entry *ent;

      for (ent = local_got_ents[r_symndx]; ent != NULL; ent = ent->next)
	if (ent->addend == r_addend
	    && ent->owner == abfd
	    && ent->tls_type == tls_type)
	  break;
      if (ent == NULL)
	{
	  bfd_size_type amt = sizeof (*ent);
	  ent = bfd_alloc (abfd, amt);
	  if (ent == NULL)
	    return FALSE;
	  ent->next = local_got_ents[r_symndx];
	  ent->addend = r_addend;
	  ent->owner = abfd;
	  ent->tls_type = tls_type;
	  ent->is_indirect = FALSE;
	  ent->got.refcount = 0;
	  local_got_ents[r_symndx] = ent;
	}
      ent->got.refcount += 1;
    }

  local_plt = (struct plt_entry **) (local_got_ents + symtab_hdr->sh_info);
  local_got_tls_masks = (unsigned char *) (local_plt + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;

  return local_plt + r_symndx;
}

static bfd_boolean
update_plt_info (bfd *abfd, struct plt_entry **plist, bfd_vma addend)
{
  struct plt_entry *ent;

  for (ent = *plist; ent != NULL; ent = ent->next)
    if (ent->addend == addend)
      break;
  if (ent == NULL)
    {
      bfd_size_type amt = sizeof (*ent);
      ent = bfd_alloc (abfd, amt);
      if (ent == NULL)
	return FALSE;
      ent->next = *plist;
      ent->addend = addend;
      ent->plt.refcount = 0;
      *plist = ent;
    }
  ent->plt.refcount += 1;
  return TRUE;
}

static bfd_boolean
is_branch_reloc (enum elf_ppc64_reloc_type r_type)
{
  return (r_type == R_PPC64_REL24
	  || r_type == R_PPC64_REL14
	  || r_type == R_PPC64_REL14_BRTAKEN
	  || r_type == R_PPC64_REL14_BRNTAKEN
	  || r_type == R_PPC64_ADDR24
	  || r_type == R_PPC64_ADDR14
	  || r_type == R_PPC64_ADDR14_BRTAKEN
	  || r_type == R_PPC64_ADDR14_BRNTAKEN);
}

/* Look through the relocs for a section during the first phase, and
   calculate needed space in the global offset table, procedure
   linkage table, and dynamic reloc sections.  */

static bfd_boolean
ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
{
  struct ppc_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;
  asection **opd_sym_map;
  struct elf_link_hash_entry *tga, *dottga;

  if (info->relocatable)
    return TRUE;

  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  BFD_ASSERT (is_ppc64_elf (abfd));

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  tga = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
			      FALSE, FALSE, TRUE);
  dottga = elf_link_hash_lookup (&htab->elf, ".__tls_get_addr",
				 FALSE, FALSE, TRUE);
  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  sreloc = NULL;
  opd_sym_map = NULL;
  if (strcmp (sec->name, ".opd") == 0)
    {
      /* Garbage collection needs some extra help with .opd sections.
	 We don't want to necessarily keep everything referenced by
	 relocs in .opd, as that would keep all functions.  Instead,
	 if we reference an .opd symbol (a function descriptor), we
	 want to keep the function code symbol's section.  This is
	 easy for global symbols, but for local syms we need to keep
	 information about the associated function section.  */
      bfd_size_type amt;

      amt = sec->size * sizeof (*opd_sym_map) / 8;
      opd_sym_map = bfd_zalloc (abfd, amt);
      if (opd_sym_map == NULL)
	return FALSE;
      ppc64_elf_section_data (sec)->u.opd.func_sec = opd_sym_map;
      BFD_ASSERT (ppc64_elf_section_data (sec)->sec_type == sec_normal);
      ppc64_elf_section_data (sec)->sec_type = sec_opd;
    }

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      enum elf_ppc64_reloc_type r_type;
      int tls_type;
      struct _ppc64_elf_section_data *ppc64_sec;
      struct plt_entry **ifunc;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  h = elf_follow_link (h);

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;

	  if (h == htab->elf.hgot)
	    sec->has_toc_reloc = 1;
	}

      tls_type = 0;
      ifunc = NULL;
      if (h != NULL)
	{
	  if (h->type == STT_GNU_IFUNC)
	    {
	      h->needs_plt = 1;
	      ifunc = &h->plt.plist;
	    }
	}
      else
	{
	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
							  abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      ifunc = update_local_sym_info (abfd, symtab_hdr, r_symndx,
					     rel->r_addend, PLT_IFUNC);
	      if (ifunc == NULL)
		return FALSE;
	    }
	}
      r_type = ELF64_R_TYPE (rel->r_info);
      if (is_branch_reloc (r_type))
	{
	  if (h != NULL && (h == tga || h == dottga))
	    {
	      if (rel != relocs
		  && (ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_TLSGD
		      || ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_TLSLD))
		/* We have a new-style __tls_get_addr call with a marker
		   reloc.  */
		;
	      else
		/* Mark this section as having an old-style call.  */
		sec->has_tls_get_addr_call = 1;
	    }

	  /* STT_GNU_IFUNC symbols must have a PLT entry.  */
	  if (ifunc != NULL
	      && !update_plt_info (abfd, ifunc, rel->r_addend))
	    return FALSE;
	}

      switch (r_type)
	{
	case R_PPC64_TLSGD:
	case R_PPC64_TLSLD:
	  /* These special tls relocs tie a call to __tls_get_addr with
	     its parameter symbol.  */
	  break;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  if (!info->executable)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

	case R_PPC64_GOT16:
	case R_PPC64_GOT16_DS:
	case R_PPC64_GOT16_HA:
	case R_PPC64_GOT16_HI:
	case R_PPC64_GOT16_LO:
	case R_PPC64_GOT16_LO_DS:
	  /* This symbol requires a global offset table entry.  */
	  sec->has_toc_reloc = 1;
	  if (r_type == R_PPC64_GOT_TLSLD16
	      || r_type == R_PPC64_GOT_TLSGD16
	      || r_type == R_PPC64_GOT_TPREL16_DS
	      || r_type == R_PPC64_GOT_DTPREL16_DS
	      || r_type == R_PPC64_GOT16
	      || r_type == R_PPC64_GOT16_DS)
	    {
	      htab->do_multi_toc = 1;
	      ppc64_elf_tdata (abfd)->has_small_toc_reloc = 1;
	    }

	  if (ppc64_elf_tdata (abfd)->got == NULL
	      && !create_got_section (abfd, info))
	    return FALSE;

	  if (h != NULL)
	    {
	      struct ppc_link_hash_entry *eh;
	      struct got_entry *ent;

	      eh = (struct ppc_link_hash_entry *) h;
	      for (ent = eh->elf.got.glist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend
		    && ent->owner == abfd
		    && ent->tls_type == tls_type)
		  break;
	      if (ent == NULL)
		{
		  bfd_size_type amt = sizeof (*ent);
		  ent = bfd_alloc (abfd, amt);
		  if (ent == NULL)
		    return FALSE;
		  ent->next = eh->elf.got.glist;
		  ent->addend = rel->r_addend;
		  ent->owner = abfd;
		  ent->tls_type = tls_type;
		  ent->is_indirect = FALSE;
		  ent->got.refcount = 0;
		  eh->elf.got.glist = ent;
		}
	      ent->got.refcount += 1;
	      eh->tls_mask |= tls_type;
	    }
	  else
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;
	  break;

	case R_PPC64_PLT16_HA:
	case R_PPC64_PLT16_HI:
	case R_PPC64_PLT16_LO:
	case R_PPC64_PLT32:
	case R_PPC64_PLT64:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
	  if (h == NULL)
	    {
	      /* It does not make sense to have a procedure linkage
		 table entry for a local symbol.  */
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  else
	    {
	      if (!update_plt_info (abfd, &h->plt.plist, rel->r_addend))
		return FALSE;
	      h->needs_plt = 1;
	      if (h->root.root.string[0] == '.'
		  && h->root.root.string[1] != '\0')
		((struct ppc_link_hash_entry *) h)->is_func = 1;
	    }
	  break;

	  /* The following relocations don't need to propagate the
	     relocation if linking a shared object since they are
	     section relative.  */
	case R_PPC64_SECTOFF:
	case R_PPC64_SECTOFF_LO:
	case R_PPC64_SECTOFF_HI:
	case R_PPC64_SECTOFF_HA:
	case R_PPC64_SECTOFF_DS:
	case R_PPC64_SECTOFF_LO_DS:
	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  break;

	  /* Nor do these.  */
	case R_PPC64_REL16:
	case R_PPC64_REL16_LO:
	case R_PPC64_REL16_HI:
	case R_PPC64_REL16_HA:
	  break;

	case R_PPC64_TOC16:
	case R_PPC64_TOC16_DS:
	  htab->do_multi_toc = 1;
	  ppc64_elf_tdata (abfd)->has_small_toc_reloc = 1;
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_HI:
	case R_PPC64_TOC16_HA:
	case R_PPC64_TOC16_LO_DS:
	  sec->has_toc_reloc = 1;
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PPC64_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PPC64_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	case R_PPC64_REL14:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL14_BRNTAKEN:
	  {
	    asection *dest = NULL;

	    /* Heuristic: If jumping outside our section, chances are
	       we are going to need a stub.  */
	    if (h != NULL)
	      {
		/* If the sym is weak it may be overridden later, so
		   don't assume we know where a weak sym lives.  */
		if (h->root.type == bfd_link_hash_defined)
		  dest = h->root.u.def.section;
	      }
	    else
	      {
		Elf_Internal_Sym *isym;

		isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					      abfd, r_symndx);
		if (isym == NULL)
		  return FALSE;

		dest = bfd_section_from_elf_index (abfd, isym->st_shndx);
	      }

	    if (dest != sec)
	      ppc64_elf_section_data (sec)->has_14bit_branch = 1;
	  }
	  /* Fall through.  */

	case R_PPC64_REL24:
	  if (h != NULL && ifunc == NULL)
	    {
	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      if (!update_plt_info (abfd, &h->plt.plist, rel->r_addend))
		return FALSE;
	      h->needs_plt = 1;
	      if (h->root.root.string[0] == '.'
		  && h->root.root.string[1] != '\0')
		((struct ppc_link_hash_entry *) h)->is_func = 1;
	      if (h == tga || h == dottga)
		sec->has_tls_reloc = 1;
	    }
	  break;

	case R_PPC64_TPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_TPREL;
	  if (!info->executable)
	    info->flags |= DF_STATIC_TLS;
	  goto dotlstoc;

	case R_PPC64_DTPMOD64:
	  if (rel + 1 < rel_end
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD;
	  else
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_LD;
	  goto dotlstoc;

	case R_PPC64_DTPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_DTPREL;
	  if (rel != relocs
	      && rel[-1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPMOD64)
	      && rel[-1].r_offset == rel->r_offset - 8)
	    /* This is the second reloc of a dtpmod, dtprel pair.
	       Don't mark with TLS_DTPREL.  */
	    goto dodyn;

	dotlstoc:
	  sec->has_tls_reloc = 1;
	  if (h != NULL)
	    {
	      struct ppc_link_hash_entry *eh;
	      eh = (struct ppc_link_hash_entry *) h;
	      eh->tls_mask |= tls_type;
	    }
	  else
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;

	  ppc64_sec = ppc64_elf_section_data (sec);
	  if (ppc64_sec->sec_type != sec_toc)
	    {
	      bfd_size_type amt;

	      /* One extra to simplify get_tls_mask.  */
	      amt = sec->size * sizeof (unsigned) / 8 + sizeof (unsigned);
	      ppc64_sec->u.toc.symndx = bfd_zalloc (abfd, amt);
	      if (ppc64_sec->u.toc.symndx == NULL)
		return FALSE;
	      amt = sec->size * sizeof (bfd_vma) / 8;
	      ppc64_sec->u.toc.add = bfd_zalloc (abfd, amt);
	      if (ppc64_sec->u.toc.add == NULL)
		return FALSE;
	      BFD_ASSERT (ppc64_sec->sec_type == sec_normal);
	      ppc64_sec->sec_type = sec_toc;
	    }
	  BFD_ASSERT (rel->r_offset % 8 == 0);
	  ppc64_sec->u.toc.symndx[rel->r_offset / 8] = r_symndx;
	  ppc64_sec->u.toc.add[rel->r_offset / 8] = rel->r_addend;

	  /* Mark the second slot of a GD or LD entry.
	     -1 to indicate GD and -2 to indicate LD.  */
	  if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_GD))
	    ppc64_sec->u.toc.symndx[rel->r_offset / 8 + 1] = -1;
	  else if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_LD))
	    ppc64_sec->u.toc.symndx[rel->r_offset / 8 + 1] = -2;
	  goto dodyn;

	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  if (info->shared)
	    {
	      if (!info->executable)
		info->flags |= DF_STATIC_TLS;
	      goto dodyn;
	    }
	  break;

	case R_PPC64_ADDR64:
	  if (opd_sym_map != NULL
	      && rel + 1 < rel_end
	      && ELF64_R_TYPE ((rel + 1)->r_info) == R_PPC64_TOC)
	    {
	      if (h != NULL)
		{
		  if (h->root.root.string[0] == '.'
		      && h->root.root.string[1] != 0
		      && lookup_fdh ((struct ppc_link_hash_entry *) h, htab))
		    ;
		  else
		    ((struct ppc_link_hash_entry *) h)->is_func = 1;
		}
	      else
		{
		  asection *s;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s != NULL && s != sec)
		    opd_sym_map[rel->r_offset / 8] = s;
		}
	    }
	  /* Fall through.  */

	case R_PPC64_REL30:
	case R_PPC64_REL32:
	case R_PPC64_REL64:
	case R_PPC64_ADDR14:
	case R_PPC64_ADDR14_BRNTAKEN:
	case R_PPC64_ADDR14_BRTAKEN:
	case R_PPC64_ADDR16:
	case R_PPC64_ADDR16_DS:
	case R_PPC64_ADDR16_HA:
	case R_PPC64_ADDR16_HI:
	case R_PPC64_ADDR16_HIGHER:
	case R_PPC64_ADDR16_HIGHERA:
	case R_PPC64_ADDR16_HIGHEST:
	case R_PPC64_ADDR16_HIGHESTA:
	case R_PPC64_ADDR16_LO:
	case R_PPC64_ADDR16_LO_DS:
	case R_PPC64_ADDR24:
	case R_PPC64_ADDR32:
	case R_PPC64_UADDR16:
	case R_PPC64_UADDR32:
	case R_PPC64_UADDR64:
	case R_PPC64_TOC:
	  if (h != NULL && !info->shared)
	    /* We may need a copy reloc.  */
	    h->non_got_ref = 1;

	  /* Don't propagate .opd relocs.  */
	  if (NO_OPD_RELOCS && opd_sym_map != NULL)
	    break;

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the dyn_relocs field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	dodyn:
	  if ((info->shared
	       && (must_be_dyn_reloc (info, r_type)
		   || (h != NULL
		       && (!SYMBOLIC_BIND (info, h)
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular))
	      || (!info->shared
		  && ifunc != NULL))
	    {
	      /* We must copy these reloc types into the output file.
		 Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->elf.dynobj, 3, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  struct elf_dyn_relocs *p;
		  struct elf_dyn_relocs **head;

		  head = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
		  p = *head;
		  if (p == NULL || p->sec != sec)
		    {
		      p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		      if (p == NULL)
			return FALSE;
		      p->next = *head;
		      *head = p;
		      p->sec = sec;
		      p->count = 0;
		      p->pc_count = 0;
		    }
		  p->count += 1;
		  if (!must_be_dyn_reloc (info, r_type))
		    p->pc_count += 1;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  struct ppc_dyn_relocs *p;
		  struct ppc_dyn_relocs **head;
		  bfd_boolean is_ifunc;
		  asection *s;
		  void *vpp;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
		  head = (struct ppc_dyn_relocs **) vpp;
		  is_ifunc = ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC;
		  p = *head;
		  if (p != NULL && p->sec == sec && p->ifunc != is_ifunc)
		    p = p->next;
		  if (p == NULL || p->sec != sec || p->ifunc != is_ifunc)
		    {
		      p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		      if (p == NULL)
			return FALSE;
		      p->next = *head;
		      *head = p;
		      p->sec = sec;
		      p->ifunc = is_ifunc;
		      p->count = 0;
		    }
		  p->count += 1;
		}
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* OFFSET in OPD_SEC specifies a function descriptor.  Return the address
   of the code entry point, and its section.  */

static bfd_vma
opd_entry_value (asection *opd_sec,
		 bfd_vma offset,
		 asection **code_sec,
		 bfd_vma *code_off,
		 bfd_boolean in_code_sec)
{
  bfd *opd_bfd = opd_sec->owner;
  Elf_Internal_Rela *relocs;
  Elf_Internal_Rela *lo, *hi, *look;
  bfd_vma val;

  /* No relocs implies we are linking a --just-symbols object, or looking
     at a final linked executable with addr2line or somesuch.  */
  if (opd_sec->reloc_count == 0)
    {
      bfd_byte *contents = ppc64_elf_tdata (opd_bfd)->opd.contents;

      if (contents == NULL)
	{
	  if (!bfd_malloc_and_get_section (opd_bfd, opd_sec, &contents))
	    return (bfd_vma) -1;
	  ppc64_elf_tdata (opd_bfd)->opd.contents = contents;
	}

      val = bfd_get_64 (opd_bfd, contents + offset);
      if (code_sec != NULL)
	{
	  asection *sec, *likely = NULL;

	  if (in_code_sec)
	    {
	      sec = *code_sec;
	      if (sec->vma <= val
		  && val < sec->vma + sec->size)
		likely = sec;
	      else
		val = -1;
	    }
	  else
	    for (sec = opd_bfd->sections; sec != NULL; sec = sec->next)
	      if (sec->vma <= val
		  && (sec->flags & SEC_LOAD) != 0
		  && (sec->flags & SEC_ALLOC) != 0)
		likely = sec;
	  if (likely != NULL)
	    {
	      *code_sec = likely;
	      if (code_off != NULL)
		*code_off = val - likely->vma;
	    }
	}
      return val;
    }

  BFD_ASSERT (is_ppc64_elf (opd_bfd));

  relocs = ppc64_elf_tdata (opd_bfd)->opd.relocs;
  if (relocs == NULL)
    relocs = _bfd_elf_link_read_relocs (opd_bfd, opd_sec, NULL, NULL, TRUE);

  /* Go find the opd reloc at the sym address.  */
  lo = relocs;
  BFD_ASSERT (lo != NULL);
  hi = lo + opd_sec->reloc_count - 1; /* ignore last reloc */
  val = (bfd_vma) -1;
  while (lo < hi)
    {
      look = lo + (hi - lo) / 2;
      if (look->r_offset < offset)
	lo = look + 1;
      else if (look->r_offset > offset)
	hi = look;
      else
	{
	  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (opd_bfd);

	  if (ELF64_R_TYPE (look->r_info) == R_PPC64_ADDR64
	      && ELF64_R_TYPE ((look + 1)->r_info) == R_PPC64_TOC)
	    {
	      unsigned long symndx = ELF64_R_SYM (look->r_info);
	      asection *sec;

	      if (symndx < symtab_hdr->sh_info
		  || elf_sym_hashes (opd_bfd) == NULL)
		{
		  Elf_Internal_Sym *sym;

		  sym = (Elf_Internal_Sym *) symtab_hdr->contents;
		  if (sym == NULL)
		    {
		      size_t symcnt = symtab_hdr->sh_info;
		      if (elf_sym_hashes (opd_bfd) == NULL)
			symcnt = symtab_hdr->sh_size / symtab_hdr->sh_entsize;
		      sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr, symcnt,
						  0, NULL, NULL, NULL);
		      if (sym == NULL)
			break;
		      symtab_hdr->contents = (bfd_byte *) sym;
		    }

		  sym += symndx;
		  val = sym->st_value;
		  sec = bfd_section_from_elf_index (opd_bfd, sym->st_shndx);
		  BFD_ASSERT ((sec->flags & SEC_MERGE) == 0);
		}
	      else
		{
		  struct elf_link_hash_entry **sym_hashes;
		  struct elf_link_hash_entry *rh;

		  sym_hashes = elf_sym_hashes (opd_bfd);
		  rh = sym_hashes[symndx - symtab_hdr->sh_info];
		  if (rh != NULL)
		    {
		      rh = elf_follow_link (rh);
		      BFD_ASSERT (rh->root.type == bfd_link_hash_defined
				  || rh->root.type == bfd_link_hash_defweak);
		      val = rh->root.u.def.value;
		      sec = rh->root.u.def.section;
		    }
		  else
		    {
		      /* Handle the odd case where we can be called
			 during bfd_elf_link_add_symbols before the
			 symbol hashes have been fully populated.  */
		      Elf_Internal_Sym *sym;

		      sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr, 1,
						  symndx, NULL, NULL, NULL);
		      if (sym == NULL)
			break;

		      val = sym->st_value;
		      sec = bfd_section_from_elf_index (opd_bfd, sym->st_shndx);
		      free (sym);
		    }
		}
	      val += look->r_addend;
	      if (code_off != NULL)
		*code_off = val;
	      if (code_sec != NULL)
		{
		  if (in_code_sec && *code_sec != sec)
		    return -1;
		  else
		    *code_sec = sec;
		}
	      if (sec != NULL && sec->output_section != NULL)
		val += sec->output_section->vma + sec->output_offset;
	    }
	  break;
	}
    }

  return val;
}

/* If the ELF symbol SYM might be a function in SEC, return the
   function size and set *CODE_OFF to the function's entry point,
   otherwise return zero.  */

static bfd_size_type
ppc64_elf_maybe_function_sym (const asymbol *sym, asection *sec,
			      bfd_vma *code_off)
{
  bfd_size_type size;

  if ((sym->flags & (BSF_SECTION_SYM | BSF_FILE | BSF_OBJECT
		     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC)) != 0)
    return 0;

  size = 0;
  if (!(sym->flags & BSF_SYNTHETIC))
    size = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;

  if (strcmp (sym->section->name, ".opd") == 0)
    {
      if (opd_entry_value (sym->section, sym->value,
			   &sec, code_off, TRUE) == (bfd_vma) -1)
	return 0;
      /* An old ABI binary with dot-syms has a size of 24 on the .opd
	 symbol.  This size has nothing to do with the code size of the
	 function, which is what we're supposed to return, but the
	 code size isn't available without looking up the dot-sym.
	 However, doing that would be a waste of time particularly
	 since elf_find_function will look at the dot-sym anyway.
	 Now, elf_find_function will keep the largest size of any
	 function sym found at the code address of interest, so return
	 1 here to avoid it incorrectly caching a larger function size
	 for a small function.  This does mean we return the wrong
	 size for a new-ABI function of size 24, but all that does is
	 disable caching for such functions.  */
      if (size == 24)
	size = 1;
    }
  else
    {
      if (sym->section != sec)
	return 0;
      *code_off = sym->value;
    }
  if (size == 0)
    size = 1;
  return size;
}

/* Return true if symbol is defined in a regular object file.  */

static bfd_boolean
is_static_defined (struct elf_link_hash_entry *h)
{
  return ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section != NULL
	  && h->root.u.def.section->output_section != NULL);
}

/* If FDH is a function descriptor symbol, return the associated code
   entry symbol if it is defined.  Return NULL otherwise.  */

static struct ppc_link_hash_entry *
defined_code_entry (struct ppc_link_hash_entry *fdh)
{
  if (fdh->is_func_descriptor)
    {
      struct ppc_link_hash_entry *fh = ppc_follow_link (fdh->oh);
      if (fh->elf.root.type == bfd_link_hash_defined
	  || fh->elf.root.type == bfd_link_hash_defweak)
	return fh;
    }
  return NULL;
}

/* If FH is a function code entry symbol, return the associated
   function descriptor symbol if it is defined.  Return NULL otherwise.  */

static struct ppc_link_hash_entry *
defined_func_desc (struct ppc_link_hash_entry *fh)
{
  if (fh->oh != NULL
      && fh->oh->is_func_descriptor)
    {
      struct ppc_link_hash_entry *fdh = ppc_follow_link (fh->oh);
      if (fdh->elf.root.type == bfd_link_hash_defined
	  || fdh->elf.root.type == bfd_link_hash_defweak)
	return fdh;
    }
  return NULL;
}

/* Mark all our entry sym sections, both opd and code section.  */

static void
ppc64_elf_gc_keep (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  struct bfd_sym_chain *sym;

  if (htab == NULL)
    return;

  for (sym = info->gc_sym_list; sym != NULL; sym = sym->next)
    {
      struct ppc_link_hash_entry *eh, *fh;
      asection *sec;

      eh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, TRUE);
      if (eh == NULL)
	continue;
      if (eh->elf.root.type != bfd_link_hash_defined
	  && eh->elf.root.type != bfd_link_hash_defweak)
	continue;

      fh = defined_code_entry (eh);
      if (fh != NULL)
	{
	  sec = fh->elf.root.u.def.section;
	  sec->flags |= SEC_KEEP;
	}
      else if (get_opd_info (eh->elf.root.u.def.section) != NULL
	       && opd_entry_value (eh->elf.root.u.def.section,
				   eh->elf.root.u.def.value,
				   &sec, NULL, FALSE) != (bfd_vma) -1)
	sec->flags |= SEC_KEEP;

      sec = eh->elf.root.u.def.section;
      sec->flags |= SEC_KEEP;
    }
}

/* Mark sections containing dynamically referenced symbols.  When
   building shared libraries, we must assume that any visible symbol is
   referenced.  */

static bfd_boolean
ppc64_elf_gc_mark_dynamic_ref (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
  struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) h;
  struct ppc_link_hash_entry *fdh;

  /* Dynamic linking info is on the func descriptor sym.  */
  fdh = defined_func_desc (eh);
  if (fdh != NULL)
    eh = fdh;

  if ((eh->elf.root.type == bfd_link_hash_defined
       || eh->elf.root.type == bfd_link_hash_defweak)
      && (eh->elf.ref_dynamic
	  || (!info->executable
	      && eh->elf.def_regular
	      && ELF_ST_VISIBILITY (eh->elf.other) != STV_INTERNAL
	      && ELF_ST_VISIBILITY (eh->elf.other) != STV_HIDDEN
	      && (strchr (eh->elf.root.root.string, ELF_VER_CHR) != NULL
		  || !bfd_hide_sym_by_version (info->version_info,
					       eh->elf.root.root.string)))))
    {
      asection *code_sec;
      struct ppc_link_hash_entry *fh;

      eh->elf.root.u.def.section->flags |= SEC_KEEP;

      /* Function descriptor syms cause the associated
	 function code sym section to be marked.  */
      fh = defined_code_entry (eh);
      if (fh != NULL)
	{
	  code_sec = fh->elf.root.u.def.section;
	  code_sec->flags |= SEC_KEEP;
	}
      else if (get_opd_info (eh->elf.root.u.def.section) != NULL
	       && opd_entry_value (eh->elf.root.u.def.section,
				   eh->elf.root.u.def.value,
				   &code_sec, NULL, FALSE) != (bfd_vma) -1)
	code_sec->flags |= SEC_KEEP;
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
ppc64_elf_gc_mark_hook (asection *sec,
			struct bfd_link_info *info,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
{
  asection *rsec;

  /* Syms return NULL if we're marking .opd, so we avoid marking all
     function sections, as all functions are referenced in .opd.  */
  rsec = NULL;
  if (get_opd_info (sec) != NULL)
    return rsec;

  if (h != NULL)
    {
      enum elf_ppc64_reloc_type r_type;
      struct ppc_link_hash_entry *eh, *fh, *fdh;

      r_type = ELF64_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PPC64_GNU_VTINHERIT:
	case R_PPC64_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      eh = (struct ppc_link_hash_entry *) h;
	      fdh = defined_func_desc (eh);
	      if (fdh != NULL)
		eh = fdh;

	      /* Function descriptor syms cause the associated
		 function code sym section to be marked.  */
	      fh = defined_code_entry (eh);
	      if (fh != NULL)
		{
		  /* They also mark their opd section.  */
		  eh->elf.root.u.def.section->gc_mark = 1;

		  rsec = fh->elf.root.u.def.section;
		}
	      else if (get_opd_info (eh->elf.root.u.def.section) != NULL
		       && opd_entry_value (eh->elf.root.u.def.section,
					   eh->elf.root.u.def.value,
					   &rsec, NULL, FALSE) != (bfd_vma) -1)
		eh->elf.root.u.def.section->gc_mark = 1;
	      else
		rsec = h->root.u.def.section;
	      break;

	    case bfd_link_hash_common:
	      rsec = h->root.u.c.p->section;
	      break;

	    default:
	      return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
	    }
	}
    }
  else
    {
      struct _opd_sec_data *opd;

      rsec = bfd_section_from_elf_index (sec->owner, sym->st_shndx);
      opd = get_opd_info (rsec);
      if (opd != NULL && opd->func_sec != NULL)
	{
	  rsec->gc_mark = 1;

	  rsec = opd->func_sec[(sym->st_value + rel->r_addend) / 8];
	}
    }

  return rsec;
}

/* Update the .got, .plt. and dynamic reloc reference counts for the
   section being removed.  */

static bfd_boolean
ppc64_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			 asection *sec, const Elf_Internal_Rela *relocs)
{
  struct ppc_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct got_entry **local_got_ents;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  elf_section_data (sec)->local_dynrel = NULL;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_ents = elf_local_got_ents (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      enum elf_ppc64_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;
      unsigned char tls_type = 0;

      r_symndx = ELF64_R_SYM (rel->r_info);
      r_type = ELF64_R_TYPE (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  h = elf_follow_link (h);
	  eh = (struct ppc_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      if (is_branch_reloc (r_type))
	{
	  struct plt_entry **ifunc = NULL;
	  if (h != NULL)
	    {
	      if (h->type == STT_GNU_IFUNC)
		ifunc = &h->plt.plist;
	    }
	  else if (local_got_ents != NULL)
	    {
	      struct plt_entry **local_plt = (struct plt_entry **)
		(local_got_ents + symtab_hdr->sh_info);
	      unsigned char *local_got_tls_masks = (unsigned char *)
		(local_plt + symtab_hdr->sh_info);
	      if ((local_got_tls_masks[r_symndx] & PLT_IFUNC) != 0)
		ifunc = local_plt + r_symndx;
	    }
	  if (ifunc != NULL)
	    {
	      struct plt_entry *ent;

	      for (ent = *ifunc; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend)
		  break;
	      if (ent == NULL)
		abort ();
	      if (ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
	      continue;
	    }
	}

      switch (r_type)
	{
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

	case R_PPC64_GOT16:
	case R_PPC64_GOT16_DS:
	case R_PPC64_GOT16_HA:
	case R_PPC64_GOT16_HI:
	case R_PPC64_GOT16_LO:
	case R_PPC64_GOT16_LO_DS:
	dogot:
	  {
	    struct got_entry *ent;

	    if (h != NULL)
	      ent = h->got.glist;
	    else
	      ent = local_got_ents[r_symndx];

	    for (; ent != NULL; ent = ent->next)
	      if (ent->addend == rel->r_addend
		  && ent->owner == abfd
		  && ent->tls_type == tls_type)
		break;
	    if (ent == NULL)
	      abort ();
	    if (ent->got.refcount > 0)
	      ent->got.refcount -= 1;
	  }
	  break;

	case R_PPC64_PLT16_HA:
	case R_PPC64_PLT16_HI:
	case R_PPC64_PLT16_LO:
	case R_PPC64_PLT32:
	case R_PPC64_PLT64:
	case R_PPC64_REL14:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL24:
	  if (h != NULL)
	    {
	      struct plt_entry *ent;

	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend)
		  break;
	      if (ent != NULL && ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
	    }
	  break;

	default:
	  break;
	}
    }
  return TRUE;
}

/* The maximum size of .sfpr.  */
#define SFPR_MAX (218*4)

struct sfpr_def_parms
{
  const char name[12];
  unsigned char lo, hi;
  bfd_byte * (*write_ent) (bfd *, bfd_byte *, int);
  bfd_byte * (*write_tail) (bfd *, bfd_byte *, int);
};

/* Auto-generate _save*, _rest* functions in .sfpr.  */

static bfd_boolean
sfpr_define (struct bfd_link_info *info, const struct sfpr_def_parms *parm)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  unsigned int i;
  size_t len = strlen (parm->name);
  bfd_boolean writing = FALSE;
  char sym[16];

  if (htab == NULL)
    return FALSE;

  memcpy (sym, parm->name, len);
  sym[len + 2] = 0;

  for (i = parm->lo; i <= parm->hi; i++)
    {
      struct elf_link_hash_entry *h;

      sym[len + 0] = i / 10 + '0';
      sym[len + 1] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
      if (h != NULL
	  && !h->def_regular)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = htab->sfpr->size;
	  h->type = STT_FUNC;
	  h->def_regular = 1;
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
	  writing = TRUE;
	  if (htab->sfpr->contents == NULL)
	    {
	      htab->sfpr->contents = bfd_alloc (htab->elf.dynobj, SFPR_MAX);
	      if (htab->sfpr->contents == NULL)
		return FALSE;
	    }
	}
      if (writing)
	{
	  bfd_byte *p = htab->sfpr->contents + htab->sfpr->size;
	  if (i != parm->hi)
	    p = (*parm->write_ent) (htab->elf.dynobj, p, i);
	  else
	    p = (*parm->write_tail) (htab->elf.dynobj, p, i);
	  htab->sfpr->size = p - htab->sfpr->contents;
	}
    }

  return TRUE;
}

static bfd_byte *
savegpr0 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STD_R0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savegpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savegpr0 (abfd, p, r);
  bfd_put_32 (abfd, STD_R0_0R1 + 16, p);
  p = p + 4;
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restgpr0 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restgpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + 16, p);
  p = p + 4;
  p = restgpr0 (abfd, p, r);
  bfd_put_32 (abfd, MTLR_R0, p);
  p = p + 4;
  if (r == 29)
    {
      p = restgpr0 (abfd, p, 30);
      p = restgpr0 (abfd, p, 31);
    }
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savegpr1 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STD_R0_0R12 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savegpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savegpr1 (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restgpr1 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R12 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restgpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restgpr1 (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savefpr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STFD_FR0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savefpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savefpr (abfd, p, r);
  bfd_put_32 (abfd, STD_R0_0R1 + 16, p);
  p = p + 4;
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restfpr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LFD_FR0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restfpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + 16, p);
  p = p + 4;
  p = restfpr (abfd, p, r);
  bfd_put_32 (abfd, MTLR_R0, p);
  p = p + 4;
  if (r == 29)
    {
      p = restfpr (abfd, p, 30);
      p = restfpr (abfd, p, 31);
    }
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savefpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savefpr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restfpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restfpr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savevr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LI_R12_0 + (1 << 16) - (32 - r) * 16, p);
  p = p + 4;
  bfd_put_32 (abfd, STVX_VR0_R12_R0 + (r << 21), p);
  return p + 4;
}

static bfd_byte *
savevr_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savevr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restvr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LI_R12_0 + (1 << 16) - (32 - r) * 16, p);
  p = p + 4;
  bfd_put_32 (abfd, LVX_VR0_R12_R0 + (r << 21), p);
  return p + 4;
}

static bfd_byte *
restvr_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restvr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

/* Called via elf_link_hash_traverse to transfer dynamic linking
   information on function code symbol entries to their corresponding
   function descriptor symbol entries.  */

static bfd_boolean
func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct ppc_link_hash_table *htab;
  struct plt_entry *ent;
  struct ppc_link_hash_entry *fh;
  struct ppc_link_hash_entry *fdh;
  bfd_boolean force_local;

  fh = (struct ppc_link_hash_entry *) h;
  if (fh->elf.root.type == bfd_link_hash_indirect)
    return TRUE;

  info = inf;
  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Resolve undefined references to dot-symbols as the value
     in the function descriptor, if we have one in a regular object.
     This is to satisfy cases like ".quad .foo".  Calls to functions
     in dynamic objects are handled elsewhere.  */
  if (fh->elf.root.type == bfd_link_hash_undefweak
      && fh->was_undefined
      && (fdh = defined_func_desc (fh)) != NULL
      && get_opd_info (fdh->elf.root.u.def.section) != NULL
      && opd_entry_value (fdh->elf.root.u.def.section,
			  fdh->elf.root.u.def.value,
			  &fh->elf.root.u.def.section,
			  &fh->elf.root.u.def.value, FALSE) != (bfd_vma) -1)
    {
      fh->elf.root.type = fdh->elf.root.type;
      fh->elf.forced_local = 1;
      fh->elf.def_regular = fdh->elf.def_regular;
      fh->elf.def_dynamic = fdh->elf.def_dynamic;
    }

  /* If this is a function code symbol, transfer dynamic linking
     information to the function descriptor symbol.  */
  if (!fh->is_func)
    return TRUE;

  for (ent = fh->elf.plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.refcount > 0)
      break;
  if (ent == NULL
      || fh->elf.root.root.string[0] != '.'
      || fh->elf.root.root.string[1] == '\0')
    return TRUE;

  /* Find the corresponding function descriptor symbol.  Create it
     as undefined if necessary.  */

  fdh = lookup_fdh (fh, htab);
  if (fdh == NULL
      && !info->executable
      && (fh->elf.root.type == bfd_link_hash_undefined
	  || fh->elf.root.type == bfd_link_hash_undefweak))
    {
      fdh = make_fdh (info, fh);
      if (fdh == NULL)
	return FALSE;
    }

  /* Fake function descriptors are made undefweak.  If the function
     code symbol is strong undefined, make the fake sym the same.
     If the function code symbol is defined, then force the fake
     descriptor local;  We can't support overriding of symbols in a
     shared library on a fake descriptor.  */

  if (fdh != NULL
      && fdh->fake
      && fdh->elf.root.type == bfd_link_hash_undefweak)
    {
      if (fh->elf.root.type == bfd_link_hash_undefined)
	{
	  fdh->elf.root.type = bfd_link_hash_undefined;
	  bfd_link_add_undef (&htab->elf.root, &fdh->elf.root);
	}
      else if (fh->elf.root.type == bfd_link_hash_defined
	       || fh->elf.root.type == bfd_link_hash_defweak)
	{
	  _bfd_elf_link_hash_hide_symbol (info, &fdh->elf, TRUE);
	}
    }

  if (fdh != NULL
      && !fdh->elf.forced_local
      && (!info->executable
	  || fdh->elf.def_dynamic
	  || fdh->elf.ref_dynamic
	  || (fdh->elf.root.type == bfd_link_hash_undefweak
	      && ELF_ST_VISIBILITY (fdh->elf.other) == STV_DEFAULT)))
    {
      if (fdh->elf.dynindx == -1)
	if (! bfd_elf_link_record_dynamic_symbol (info, &fdh->elf))
	  return FALSE;
      fdh->elf.ref_regular |= fh->elf.ref_regular;
      fdh->elf.ref_dynamic |= fh->elf.ref_dynamic;
      fdh->elf.ref_regular_nonweak |= fh->elf.ref_regular_nonweak;
      fdh->elf.non_got_ref |= fh->elf.non_got_ref;
      if (ELF_ST_VISIBILITY (fh->elf.other) == STV_DEFAULT)
	{
	  move_plt_plist (fh, fdh);
	  fdh->elf.needs_plt = 1;
	}
      fdh->is_func_descriptor = 1;
      fdh->oh = fh;
      fh->oh = fdh;
    }

  /* Now that the info is on the function descriptor, clear the
     function code sym info.  Any function code syms for which we
     don't have a definition in a regular file, we force local.
     This prevents a shared library from exporting syms that have
     been imported from another library.  Function code syms that
     are really in the library we must leave global to prevent the
     linker dragging in a definition from a static library.  */
  force_local = (!fh->elf.def_regular
		 || fdh == NULL
		 || !fdh->elf.def_regular
		 || fdh->elf.forced_local);
  _bfd_elf_link_hash_hide_symbol (info, &fh->elf, force_local);

  return TRUE;
}

/* Called near the start of bfd_elf_size_dynamic_sections.  We use
   this hook to a) provide some gcc support functions, and b) transfer
   dynamic linking information gathered so far on function code symbol
   entries, to their corresponding function descriptor symbol entries.  */

static bfd_boolean
ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  unsigned int i;
  static const struct sfpr_def_parms funcs[] =
    {
      { "_savegpr0_", 14, 31, savegpr0, savegpr0_tail },
      { "_restgpr0_", 14, 29, restgpr0, restgpr0_tail },
      { "_restgpr0_", 30, 31, restgpr0, restgpr0_tail },
      { "_savegpr1_", 14, 31, savegpr1, savegpr1_tail },
      { "_restgpr1_", 14, 31, restgpr1, restgpr1_tail },
      { "_savefpr_", 14, 31, savefpr, savefpr0_tail },
      { "_restfpr_", 14, 29, restfpr, restfpr0_tail },
      { "_restfpr_", 30, 31, restfpr, restfpr0_tail },
      { "._savef", 14, 31, savefpr, savefpr1_tail },
      { "._restf", 14, 31, restfpr, restfpr1_tail },
      { "_savevr_", 20, 31, savevr, savevr_tail },
      { "_restvr_", 20, 31, restvr, restvr_tail }
    };

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (!info->relocatable
      && htab->elf.hgot != NULL)
    _bfd_elf_link_hash_hide_symbol (info, htab->elf.hgot, TRUE);

  if (htab->sfpr == NULL)
    /* We don't have any relocs.  */
    return TRUE;

  /* Provide any missing _save* and _rest* functions.  */
  htab->sfpr->size = 0;
  if (!info->relocatable)
    for (i = 0; i < sizeof (funcs) / sizeof (funcs[0]); i++)
      if (!sfpr_define (info, &funcs[i]))
	return FALSE;

  elf_link_hash_traverse (&htab->elf, func_desc_adjust, info);

  if (htab->sfpr->size == 0)
    htab->sfpr->flags |= SEC_EXCLUDE;

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
{
  struct ppc_link_hash_table *htab;
  asection *s;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Deal with function syms.  */
  if (h->type == STT_FUNC
      || h->type == STT_GNU_IFUNC
      || h->needs_plt)
    {
      /* Clear procedure linkage table information for any symbol that
	 won't need a .plt entry.  */
      struct plt_entry *ent;
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.refcount > 0)
	  break;
      if (ent == NULL
	  || (h->type != STT_GNU_IFUNC
	      && (SYMBOL_CALLS_LOCAL (info, h)
		  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		      && h->root.type == bfd_link_hash_undefweak))))
	{
	  h->plt.plist = NULL;
	  h->needs_plt = 0;
	}
    }
  else
    h->plt.plist = NULL;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* Don't generate a copy reloc for symbols defined in the executable.  */
  if (!h->def_dynamic || !h->ref_regular || h->def_regular)
    return TRUE;

  if (ELIMINATE_COPY_RELOCS)
    {
      struct ppc_link_hash_entry * eh;
      struct elf_dyn_relocs *p;

      eh = (struct ppc_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->non_got_ref = 0;
	  return TRUE;
	}
    }

  if (h->plt.plist != NULL)
    {
      /* We should never get here, but unfortunately there are versions
	 of gcc out there that improperly (for this ABI) put initialized
	 function pointers, vtable refs and suchlike in read-only
	 sections.  Allow them to proceed, but warn that this might
	 break at runtime.  */
      info->callbacks->einfo
	(_("%P: copy reloc against `%T' requires lazy plt linking; "
	   "avoid setting LD_BIND_NOW=1 or upgrade gcc\n"),
	 h->root.root.string);
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  /* We must generate a R_PPC64_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      htab->relbss->size += sizeof (Elf64_External_Rela);
      h->needs_copy = 1;
    }

  s = htab->dynbss;

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* If given a function descriptor symbol, hide both the function code
   sym and the descriptor.  */
static void
ppc64_elf_hide_symbol (struct bfd_link_info *info,
		       struct elf_link_hash_entry *h,
		       bfd_boolean force_local)
{
  struct ppc_link_hash_entry *eh;
  _bfd_elf_link_hash_hide_symbol (info, h, force_local);

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->is_func_descriptor)
    {
      struct ppc_link_hash_entry *fh = eh->oh;

      if (fh == NULL)
	{
	  const char *p, *q;
	  struct ppc_link_hash_table *htab;
	  char save;

	  /* We aren't supposed to use alloca in BFD because on
	     systems which do not have alloca the version in libiberty
	     calls xmalloc, which might cause the program to crash
	     when it runs out of memory.  This function doesn't have a
	     return status, so there's no way to gracefully return an
	     error.  So cheat.  We know that string[-1] can be safely
	     accessed;  It's either a string in an ELF string table,
	     or allocated in an objalloc structure.  */

	  p = eh->elf.root.root.string - 1;
	  save = *p;
	  *(char *) p = '.';
	  htab = ppc_hash_table (info);
	  if (htab == NULL)
	    return;

	  fh = (struct ppc_link_hash_entry *)
	    elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
	  *(char *) p = save;

	  /* Unfortunately, if it so happens that the string we were
	     looking for was allocated immediately before this string,
	     then we overwrote the string terminator.  That's the only
	     reason the lookup should fail.  */
	  if (fh == NULL)
	    {
	      q = eh->elf.root.root.string + strlen (eh->elf.root.root.string);
	      while (q >= eh->elf.root.root.string && *q == *p)
		--q, --p;
	      if (q < eh->elf.root.root.string && *p == '.')
		fh = (struct ppc_link_hash_entry *)
		  elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
	    }
	  if (fh != NULL)
	    {
	      eh->oh = fh;
	      fh->oh = eh;
	    }
	}
      if (fh != NULL)
	_bfd_elf_link_hash_hide_symbol (info, &fh->elf, force_local);
    }
}

static bfd_boolean
get_sym_h (struct elf_link_hash_entry **hp,
	   Elf_Internal_Sym **symp,
	   asection **symsecp,
	   unsigned char **tls_maskp,
	   Elf_Internal_Sym **locsymsp,
	   unsigned long r_symndx,
	   bfd *ibfd)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);

  if (r_symndx >= symtab_hdr->sh_info)
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      h = elf_follow_link (h);

      if (hp != NULL)
	*hp = h;

      if (symp != NULL)
	*symp = NULL;

      if (symsecp != NULL)
	{
	  asection *symsec = NULL;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    symsec = h->root.u.def.section;
	  *symsecp = symsec;
	}

      if (tls_maskp != NULL)
	{
	  struct ppc_link_hash_entry *eh;

	  eh = (struct ppc_link_hash_entry *) h;
	  *tls_maskp = &eh->tls_mask;
	}
    }
  else
    {
      Elf_Internal_Sym *sym;
      Elf_Internal_Sym *locsyms = *locsymsp;

      if (locsyms == NULL)
	{
	  locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (locsyms == NULL)
	    locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
					    symtab_hdr->sh_info,
					    0, NULL, NULL, NULL);
	  if (locsyms == NULL)
	    return FALSE;
	  *locsymsp = locsyms;
	}
      sym = locsyms + r_symndx;

      if (hp != NULL)
	*hp = NULL;

      if (symp != NULL)
	*symp = sym;

      if (symsecp != NULL)
	*symsecp = bfd_section_from_elf_index (ibfd, sym->st_shndx);

      if (tls_maskp != NULL)
	{
	  struct got_entry **lgot_ents;
	  unsigned char *tls_mask;

	  tls_mask = NULL;
	  lgot_ents = elf_local_got_ents (ibfd);
	  if (lgot_ents != NULL)
	    {
	      struct plt_entry **local_plt = (struct plt_entry **)
		(lgot_ents + symtab_hdr->sh_info);
	      unsigned char *lgot_masks = (unsigned char *)
		(local_plt + symtab_hdr->sh_info);
	      tls_mask = &lgot_masks[r_symndx];
	    }
	  *tls_maskp = tls_mask;
	}
    }
  return TRUE;
}

/* Returns TLS_MASKP for the given REL symbol.  Function return is 0 on
   error, 2 on a toc GD type suitable for optimization, 3 on a toc LD
   type suitable for optimization, and 1 otherwise.  */

static int
get_tls_mask (unsigned char **tls_maskp,
	      unsigned long *toc_symndx,
	      bfd_vma *toc_addend,
	      Elf_Internal_Sym **locsymsp,
	      const Elf_Internal_Rela *rel,
	      bfd *ibfd)
{
  unsigned long r_symndx;
  int next_r;
  struct elf_link_hash_entry *h;
  Elf_Internal_Sym *sym;
  asection *sec;
  bfd_vma off;

  r_symndx = ELF64_R_SYM (rel->r_info);
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;

  if ((*tls_maskp != NULL && **tls_maskp != 0)
      || sec == NULL
      || ppc64_elf_section_data (sec) == NULL
      || ppc64_elf_section_data (sec)->sec_type != sec_toc)
    return 1;

  /* Look inside a TOC section too.  */
  if (h != NULL)
    {
      BFD_ASSERT (h->root.type == bfd_link_hash_defined);
      off = h->root.u.def.value;
    }
  else
    off = sym->st_value;
  off += rel->r_addend;
  BFD_ASSERT (off % 8 == 0);
  r_symndx = ppc64_elf_section_data (sec)->u.toc.symndx[off / 8];
  next_r = ppc64_elf_section_data (sec)->u.toc.symndx[off / 8 + 1];
  if (toc_symndx != NULL)
    *toc_symndx = r_symndx;
  if (toc_addend != NULL)
    *toc_addend = ppc64_elf_section_data (sec)->u.toc.add[off / 8];
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;
  if ((h == NULL || is_static_defined (h))
      && (next_r == -1 || next_r == -2))
    return 1 - next_r;
  return 1;
}

/* Find (or create) an entry in the tocsave hash table.  */

static struct tocsave_entry *
tocsave_find (struct ppc_link_hash_table *htab,
	      enum insert_option insert,
	      Elf_Internal_Sym **local_syms,
	      const Elf_Internal_Rela *irela,
	      bfd *ibfd)
{
  unsigned long r_indx;
  struct elf_link_hash_entry *h;
  Elf_Internal_Sym *sym;
  struct tocsave_entry ent, *p;
  hashval_t hash;
  struct tocsave_entry **slot;

  r_indx = ELF64_R_SYM (irela->r_info);
  if (!get_sym_h (&h, &sym, &ent.sec, NULL, local_syms, r_indx, ibfd))
    return NULL;
  if (ent.sec == NULL || ent.sec->output_section == NULL)
    {
      (*_bfd_error_handler)
	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"));
      return NULL;
    }

  if (h != NULL)
    ent.offset = h->root.u.def.value;
  else
    ent.offset = sym->st_value;
  ent.offset += irela->r_addend;

  hash = tocsave_htab_hash (&ent);
  slot = ((struct tocsave_entry **)
	  htab_find_slot_with_hash (htab->tocsave_htab, &ent, hash, insert));
  if (slot == NULL)
    return NULL;

  if (*slot == NULL)
    {
      p = (struct tocsave_entry *) bfd_alloc (ibfd, sizeof (*p));
      if (p == NULL)
	return NULL;
      *p = ent;
      *slot = p;
    }
  return *slot;
}

/* Adjust all global syms defined in opd sections.  In gcc generated
   code for the old ABI, these will already have been done.  */

static bfd_boolean
adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  struct ppc_link_hash_entry *eh;
  asection *sym_sec;
  struct _opd_sec_data *opd;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type != bfd_link_hash_defined
      && h->root.type != bfd_link_hash_defweak)
    return TRUE;

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->adjust_done)
    return TRUE;

  sym_sec = eh->elf.root.u.def.section;
  opd = get_opd_info (sym_sec);
  if (opd != NULL && opd->adjust != NULL)
    {
      long adjust = opd->adjust[eh->elf.root.u.def.value / 8];
      if (adjust == -1)
	{
	  /* This entry has been deleted.  */
	  asection *dsec = ppc64_elf_tdata (sym_sec->owner)->deleted_section;
	  if (dsec == NULL)
	    {
	      for (dsec = sym_sec->owner->sections; dsec; dsec = dsec->next)
		if (discarded_section (dsec))
		  {
		    ppc64_elf_tdata (sym_sec->owner)->deleted_section = dsec;
		    break;
		  }
	    }
	  eh->elf.root.u.def.value = 0;
	  eh->elf.root.u.def.section = dsec;
	}
      else
	eh->elf.root.u.def.value += adjust;
      eh->adjust_done = 1;
    }
  return TRUE;
}

/* Handles decrementing dynamic reloc counts for the reloc specified by
   R_INFO in section SEC.  If LOCAL_SYMS is NULL, then H and SYM
   have already been determined.  */

static bfd_boolean
dec_dynrel_count (bfd_vma r_info,
		  asection *sec,
		  struct bfd_link_info *info,
		  Elf_Internal_Sym **local_syms,
		  struct elf_link_hash_entry *h,
		  Elf_Internal_Sym *sym)
{
  enum elf_ppc64_reloc_type r_type;
  asection *sym_sec = NULL;

  /* Can this reloc be dynamic?  This switch, and later tests here
     should be kept in sync with the code in check_relocs.  */
  r_type = ELF64_R_TYPE (r_info);
  switch (r_type)
    {
    default:
      return TRUE;

    case R_PPC64_TPREL16:
    case R_PPC64_TPREL16_LO:
    case R_PPC64_TPREL16_HI:
    case R_PPC64_TPREL16_HA:
    case R_PPC64_TPREL16_DS:
    case R_PPC64_TPREL16_LO_DS:
    case R_PPC64_TPREL16_HIGHER:
    case R_PPC64_TPREL16_HIGHERA:
    case R_PPC64_TPREL16_HIGHEST:
    case R_PPC64_TPREL16_HIGHESTA:
      if (!info->shared)
	return TRUE;

    case R_PPC64_TPREL64:
    case R_PPC64_DTPMOD64:
    case R_PPC64_DTPREL64:
    case R_PPC64_ADDR64:
    case R_PPC64_REL30:
    case R_PPC64_REL32:
    case R_PPC64_REL64:
    case R_PPC64_ADDR14:
    case R_PPC64_ADDR14_BRNTAKEN:
    case R_PPC64_ADDR14_BRTAKEN:
    case R_PPC64_ADDR16:
    case R_PPC64_ADDR16_DS:
    case R_PPC64_ADDR16_HA:
    case R_PPC64_ADDR16_HI:
    case R_PPC64_ADDR16_HIGHER:
    case R_PPC64_ADDR16_HIGHERA:
    case R_PPC64_ADDR16_HIGHEST:
    case R_PPC64_ADDR16_HIGHESTA:
    case R_PPC64_ADDR16_LO:
    case R_PPC64_ADDR16_LO_DS:
    case R_PPC64_ADDR24:
    case R_PPC64_ADDR32:
    case R_PPC64_UADDR16:
    case R_PPC64_UADDR32:
    case R_PPC64_UADDR64:
    case R_PPC64_TOC:
      break;
    }

  if (local_syms != NULL)
    {
      unsigned long r_symndx;
      bfd *ibfd = sec->owner;

      r_symndx = ELF64_R_SYM (r_info);
      if (!get_sym_h (&h, &sym, &sym_sec, NULL, local_syms, r_symndx, ibfd))
	return FALSE;
    }

  if ((info->shared
       && (must_be_dyn_reloc (info, r_type)
	   || (h != NULL
	       && (!SYMBOLIC_BIND (info, h)
		   || h->root.type == bfd_link_hash_defweak
		   || !h->def_regular))))
      || (ELIMINATE_COPY_RELOCS
	  && !info->shared
	  && h != NULL
	  && (h->root.type == bfd_link_hash_defweak
	      || !h->def_regular)))
    ;
  else
    return TRUE;

  if (h != NULL)
    {
      struct elf_dyn_relocs *p;
      struct elf_dyn_relocs **pp;
      pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;

      /* elf_gc_sweep may have already removed all dyn relocs associated
	 with local syms for a given section.  Also, symbol flags are
	 changed by elf_gc_sweep_symbol, confusing the test above.  Don't
	 report a dynreloc miscount.  */
      if (*pp == NULL && info->gc_sections)
	return TRUE;

      while ((p = *pp) != NULL)
	{
	  if (p->sec == sec)
	    {
	      if (!must_be_dyn_reloc (info, r_type))
		p->pc_count -= 1;
	      p->count -= 1;
	      if (p->count == 0)
		*pp = p->next;
	      return TRUE;
	    }
	  pp = &p->next;
	}
    }
  else
    {
      struct ppc_dyn_relocs *p;
      struct ppc_dyn_relocs **pp;
      void *vpp;
      bfd_boolean is_ifunc;

      if (local_syms == NULL)
	sym_sec = bfd_section_from_elf_index (sec->owner, sym->st_shndx);
      if (sym_sec == NULL)
	sym_sec = sec;

      vpp = &elf_section_data (sym_sec)->local_dynrel;
      pp = (struct ppc_dyn_relocs **) vpp;

      if (*pp == NULL && info->gc_sections)
	return TRUE;

      is_ifunc = ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC;
      while ((p = *pp) != NULL)
	{
	  if (p->sec == sec && p->ifunc == is_ifunc)
	    {
	      p->count -= 1;
	      if (p->count == 0)
		*pp = p->next;
	      return TRUE;
	    }
	  pp = &p->next;
	}
    }

  info->callbacks->einfo (_("%P: dynreloc miscount for %B, section %A\n"),
			  sec->owner, sec);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

/* Remove unused Official Procedure Descriptor entries.  Currently we
   only remove those associated with functions in discarded link-once
   sections, or weakly defined functions that have been overridden.  It
   would be possible to remove many more entries for statically linked
   applications.  */

bfd_boolean
ppc64_elf_edit_opd (struct bfd_link_info *info, bfd_boolean non_overlapping)
{
  bfd *ibfd;
  bfd_boolean some_edited = FALSE;
  asection *need_pad = NULL;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      asection *sec;
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Sym *local_syms;
      bfd_vma offset;
      struct _opd_sec_data *opd;
      bfd_boolean need_edit, add_aux_fields;
      bfd_size_type cnt_16b = 0;

      if (!is_ppc64_elf (ibfd))
	continue;

      sec = bfd_get_section_by_name (ibfd, ".opd");
      if (sec == NULL || sec->size == 0)
	continue;

      if (sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
	continue;

      if (sec->output_section == bfd_abs_section_ptr)
	continue;

      /* Look through the section relocs.  */
      if ((sec->flags & SEC_RELOC) == 0 || sec->reloc_count == 0)
	continue;

      local_syms = NULL;
      symtab_hdr = &elf_symtab_hdr (ibfd);

      /* Read the relocations.  */
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	return FALSE;

      /* First run through the relocs to check they are sane, and to
	 determine whether we need to edit this opd section.  */
      need_edit = FALSE;
      need_pad = sec;
      offset = 0;
      relend = relstart + sec->reloc_count;
      for (rel = relstart; rel < relend; )
	{
	  enum elf_ppc64_reloc_type r_type;
	  unsigned long r_symndx;
	  asection *sym_sec;
	  struct elf_link_hash_entry *h;
	  Elf_Internal_Sym *sym;

	  /* .opd contains a regular array of 16 or 24 byte entries.  We're
	     only interested in the reloc pointing to a function entry
	     point.  */
	  if (rel->r_offset != offset
	      || rel + 1 >= relend
	      || (rel + 1)->r_offset != offset + 8)
	    {
	      /* If someone messes with .opd alignment then after a
		 "ld -r" we might have padding in the middle of .opd.
		 Also, there's nothing to prevent someone putting
		 something silly in .opd with the assembler.  No .opd
		 optimization for them!  */
	    broken_opd:
	      (*_bfd_error_handler)
		(_("%B: .opd is not a regular array of opd entries"), ibfd);
	      need_edit = FALSE;
	      break;
	    }

	  if ((r_type = ELF64_R_TYPE (rel->r_info)) != R_PPC64_ADDR64
	      || (r_type = ELF64_R_TYPE ((rel + 1)->r_info)) != R_PPC64_TOC)
	    {
	      (*_bfd_error_handler)
		(_("%B: unexpected reloc type %u in .opd section"),
		 ibfd, r_type);
	      need_edit = FALSE;
	      break;
	    }

	  r_symndx = ELF64_R_SYM (rel->r_info);
	  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			  r_symndx, ibfd))
	    goto error_ret;

	  if (sym_sec == NULL || sym_sec->owner == NULL)
	    {
	      const char *sym_name;
	      if (h != NULL)
		sym_name = h->root.root.string;
	      else
		sym_name = bfd_elf_sym_name (ibfd, symtab_hdr, sym,
					     sym_sec);

	      (*_bfd_error_handler)
		(_("%B: undefined sym `%s' in .opd section"),
		 ibfd, sym_name);
	      need_edit = FALSE;
	      break;
	    }

	  /* opd entries are always for functions defined in the
	     current input bfd.  If the symbol isn't defined in the
	     input bfd, then we won't be using the function in this
	     bfd;  It must be defined in a linkonce section in another
	     bfd, or is weak.  It's also possible that we are
	     discarding the function due to a linker script /DISCARD/,
	     which we test for via the output_section.  */
	  if (sym_sec->owner != ibfd
	      || sym_sec->output_section == bfd_abs_section_ptr)
	    need_edit = TRUE;

	  rel += 2;
	  if (rel == relend
	      || (rel + 1 == relend && rel->r_offset == offset + 16))
	    {
	      if (sec->size == offset + 24)
		{
		  need_pad = NULL;
		  break;
		}
	      if (rel == relend && sec->size == offset + 16)
		{
		  cnt_16b++;
		  break;
		}
	      goto broken_opd;
	    }

	  if (rel->r_offset == offset + 24)
	    offset += 24;
	  else if (rel->r_offset != offset + 16)
	    goto broken_opd;
	  else if (rel + 1 < relend
		   && ELF64_R_TYPE (rel[0].r_info) == R_PPC64_ADDR64
		   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOC)
	    {
	      offset += 16;
	      cnt_16b++;
	    }
	  else if (rel + 2 < relend
		   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_ADDR64
		   && ELF64_R_TYPE (rel[2].r_info) == R_PPC64_TOC)
	    {
	      offset += 24;
	      rel += 1;
	    }
	  else
	    goto broken_opd;
	}

      add_aux_fields = non_overlapping && cnt_16b > 0;

      if (need_edit || add_aux_fields)
	{
	  Elf_Internal_Rela *write_rel;
	  Elf_Internal_Shdr *rel_hdr;
	  bfd_byte *rptr, *wptr;
	  bfd_byte *new_contents;
	  bfd_boolean skip;
	  long opd_ent_size;
	  bfd_size_type amt;

	  new_contents = NULL;
	  amt = sec->size * sizeof (long) / 8;
	  opd = &ppc64_elf_section_data (sec)->u.opd;
	  opd->adjust = bfd_zalloc (sec->owner, amt);
	  if (opd->adjust == NULL)
	    return FALSE;
	  ppc64_elf_section_data (sec)->sec_type = sec_opd;

	  /* This seems a waste of time as input .opd sections are all
	     zeros as generated by gcc, but I suppose there's no reason
	     this will always be so.  We might start putting something in
	     the third word of .opd entries.  */
	  if ((sec->flags & SEC_IN_MEMORY) == 0)
	    {
	      bfd_byte *loc;
	      if (!bfd_malloc_and_get_section (ibfd, sec, &loc))
		{
		  if (loc != NULL)
		    free (loc);
		error_ret:
		  if (local_syms != NULL
		      && symtab_hdr->contents != (unsigned char *) local_syms)
		    free (local_syms);
		  if (elf_section_data (sec)->relocs != relstart)
		    free (relstart);
		  return FALSE;
		}
	      sec->contents = loc;
	      sec->flags |= (SEC_IN_MEMORY | SEC_HAS_CONTENTS);
	    }

	  elf_section_data (sec)->relocs = relstart;

	  new_contents = sec->contents;
	  if (add_aux_fields)
	    {
	      new_contents = bfd_malloc (sec->size + cnt_16b * 8);
	      if (new_contents == NULL)
		return FALSE;
	      need_pad = FALSE;
	    }
	  wptr = new_contents;
	  rptr = sec->contents;

	  write_rel = relstart;
	  skip = FALSE;
	  offset = 0;
	  opd_ent_size = 0;
	  for (rel = relstart; rel < relend; rel++)
	    {
	      unsigned long r_symndx;
	      asection *sym_sec;
	      struct elf_link_hash_entry *h;
	      Elf_Internal_Sym *sym;

	      r_symndx = ELF64_R_SYM (rel->r_info);
	      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			      r_symndx, ibfd))
		goto error_ret;

	      if (rel->r_offset == offset)
		{
		  struct ppc_link_hash_entry *fdh = NULL;

		  /* See if the .opd entry is full 24 byte or
		     16 byte (with fd_aux entry overlapped with next
		     fd_func).  */
		  opd_ent_size = 24;
		  if ((rel + 2 == relend && sec->size == offset + 16)
		      || (rel + 3 < relend
			  && rel[2].r_offset == offset + 16
			  && rel[3].r_offset == offset + 24
			  && ELF64_R_TYPE (rel[2].r_info) == R_PPC64_ADDR64
			  && ELF64_R_TYPE (rel[3].r_info) == R_PPC64_TOC))
		    opd_ent_size = 16;

		  if (h != NULL
		      && h->root.root.string[0] == '.')
		    {
		      struct ppc_link_hash_table *htab;

		      htab = ppc_hash_table (info);
		      if (htab != NULL)
			fdh = lookup_fdh ((struct ppc_link_hash_entry *) h,
					  htab);
		      if (fdh != NULL
			  && fdh->elf.root.type != bfd_link_hash_defined
			  && fdh->elf.root.type != bfd_link_hash_defweak)
			fdh = NULL;
		    }

		  skip = (sym_sec->owner != ibfd
			  || sym_sec->output_section == bfd_abs_section_ptr);
		  if (skip)
		    {
		      if (fdh != NULL && sym_sec->owner == ibfd)
			{
			  /* Arrange for the function descriptor sym
			     to be dropped.  */
			  fdh->elf.root.u.def.value = 0;
			  fdh->elf.root.u.def.section = sym_sec;
			}
		      opd->adjust[rel->r_offset / 8] = -1;
		    }
		  else
		    {
		      /* We'll be keeping this opd entry.  */

		      if (fdh != NULL)
			{
			  /* Redefine the function descriptor symbol to
			     this location in the opd section.  It is
			     necessary to update the value here rather
			     than using an array of adjustments as we do
			     for local symbols, because various places
			     in the generic ELF code use the value
			     stored in u.def.value.  */
			  fdh->elf.root.u.def.value = wptr - new_contents;
			  fdh->adjust_done = 1;
			}

		      /* Local syms are a bit tricky.  We could
			 tweak them as they can be cached, but
			 we'd need to look through the local syms
			 for the function descriptor sym which we
			 don't have at the moment.  So keep an
			 array of adjustments.  */
		      opd->adjust[rel->r_offset / 8]
			= (wptr - new_contents) - (rptr - sec->contents);

		      if (wptr != rptr)
			memcpy (wptr, rptr, opd_ent_size);
		      wptr += opd_ent_size;
		      if (add_aux_fields && opd_ent_size == 16)
			{
			  memset (wptr, '\0', 8);
			  wptr += 8;
			}
		    }
		  rptr += opd_ent_size;
		  offset += opd_ent_size;
		}

	      if (skip)
		{
		  if (!NO_OPD_RELOCS
		      && !info->relocatable
		      && !dec_dynrel_count (rel->r_info, sec, info,
					    NULL, h, sym))
		    goto error_ret;
		}
	      else
		{
		  /* We need to adjust any reloc offsets to point to the
		     new opd entries.  While we're at it, we may as well
		     remove redundant relocs.  */
		  rel->r_offset += opd->adjust[(offset - opd_ent_size) / 8];
		  if (write_rel != rel)
		    memcpy (write_rel, rel, sizeof (*rel));
		  ++write_rel;
		}
	    }

	  sec->size = wptr - new_contents;
	  sec->reloc_count = write_rel - relstart;
	  if (add_aux_fields)
	    {
	      free (sec->contents);
	      sec->contents = new_contents;
	    }

	  /* Fudge the header size too, as this is used later in
	     elf_bfd_final_link if we are emitting relocs.  */
	  rel_hdr = _bfd_elf_single_rel_hdr (sec);
	  rel_hdr->sh_size = sec->reloc_count * rel_hdr->sh_entsize;
	  some_edited = TRUE;
	}
      else if (elf_section_data (sec)->relocs != relstart)
	free (relstart);

      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (!info->keep_memory)
	    free (local_syms);
	  else
	    symtab_hdr->contents = (unsigned char *) local_syms;
	}
    }

  if (some_edited)
    elf_link_hash_traverse (elf_hash_table (info), adjust_opd_syms, NULL);

  /* If we are doing a final link and the last .opd entry is just 16 byte
     long, add a 8 byte padding after it.  */
  if (need_pad != NULL && !info->relocatable)
    {
      bfd_byte *p;

      if ((need_pad->flags & SEC_IN_MEMORY) == 0)
	{
	  BFD_ASSERT (need_pad->size > 0);

	  p = bfd_malloc (need_pad->size + 8);
	  if (p == NULL)
	    return FALSE;

	  if (! bfd_get_section_contents (need_pad->owner, need_pad,
					  p, 0, need_pad->size))
	    return FALSE;

	  need_pad->contents = p;
	  need_pad->flags |= (SEC_IN_MEMORY | SEC_HAS_CONTENTS);
	}
      else
	{
	  p = bfd_realloc (need_pad->contents, need_pad->size + 8);
	  if (p == NULL)
	    return FALSE;

	  need_pad->contents = p;
	}

      memset (need_pad->contents + need_pad->size, 0, 8);
      need_pad->size += 8;
    }

  return TRUE;
}

/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */

asection *
ppc64_elf_tls_setup (struct bfd_link_info *info,
		     int no_tls_get_addr_opt,
		     int *no_multi_toc)
{
  struct ppc_link_hash_table *htab;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return NULL;

  if (*no_multi_toc)
    htab->do_multi_toc = 0;
  else if (!htab->do_multi_toc)
    *no_multi_toc = 1;

  htab->tls_get_addr = ((struct ppc_link_hash_entry *)
			elf_link_hash_lookup (&htab->elf, ".__tls_get_addr",
					      FALSE, FALSE, TRUE));
  /* Move dynamic linking info to the function descriptor sym.  */
  if (htab->tls_get_addr != NULL)
    func_desc_adjust (&htab->tls_get_addr->elf, info);
  htab->tls_get_addr_fd = ((struct ppc_link_hash_entry *)
			   elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
						 FALSE, FALSE, TRUE));
  if (!no_tls_get_addr_opt)
    {
      struct elf_link_hash_entry *opt, *opt_fd, *tga, *tga_fd;

      opt = elf_link_hash_lookup (&htab->elf, ".__tls_get_addr_opt",
				  FALSE, FALSE, TRUE);
      if (opt != NULL)
	func_desc_adjust (opt, info);
      opt_fd = elf_link_hash_lookup (&htab->elf, "__tls_get_addr_opt",
				     FALSE, FALSE, TRUE);
      if (opt_fd != NULL
	  && (opt_fd->root.type == bfd_link_hash_defined
	      || opt_fd->root.type == bfd_link_hash_defweak))
	{
	  /* If glibc supports an optimized __tls_get_addr call stub,
	     signalled by the presence of __tls_get_addr_opt, and we'll
	     be calling __tls_get_addr via a plt call stub, then
	     make __tls_get_addr point to __tls_get_addr_opt.  */
	  tga_fd = &htab->tls_get_addr_fd->elf;
	  if (htab->elf.dynamic_sections_created
	      && tga_fd != NULL
	      && (tga_fd->type == STT_FUNC
		  || tga_fd->needs_plt)
	      && !(SYMBOL_CALLS_LOCAL (info, tga_fd)
		   || (ELF_ST_VISIBILITY (tga_fd->other) != STV_DEFAULT
		       && tga_fd->root.type == bfd_link_hash_undefweak)))
	    {
	      struct plt_entry *ent;

	      for (ent = tga_fd->plt.plist; ent != NULL; ent = ent->next)
		if (ent->plt.refcount > 0)
		  break;
	      if (ent != NULL)
		{
		  tga_fd->root.type = bfd_link_hash_indirect;
		  tga_fd->root.u.i.link = &opt_fd->root;
		  ppc64_elf_copy_indirect_symbol (info, opt_fd, tga_fd);
		  if (opt_fd->dynindx != -1)
		    {
		      /* Use __tls_get_addr_opt in dynamic relocations.  */
		      opt_fd->dynindx = -1;
		      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
					      opt_fd->dynstr_index);
		      if (!bfd_elf_link_record_dynamic_symbol (info, opt_fd))
			return NULL;
		    }
		  htab->tls_get_addr_fd = (struct ppc_link_hash_entry *) opt_fd;
		  tga = &htab->tls_get_addr->elf;
		  if (opt != NULL && tga != NULL)
		    {
		      tga->root.type = bfd_link_hash_indirect;
		      tga->root.u.i.link = &opt->root;
		      ppc64_elf_copy_indirect_symbol (info, opt, tga);
		      _bfd_elf_link_hash_hide_symbol (info, opt,
						      tga->forced_local);
		      htab->tls_get_addr = (struct ppc_link_hash_entry *) opt;
		    }
		  htab->tls_get_addr_fd->oh = htab->tls_get_addr;
		  htab->tls_get_addr_fd->is_func_descriptor = 1;
		  if (htab->tls_get_addr != NULL)
		    {
		      htab->tls_get_addr->oh = htab->tls_get_addr_fd;
		      htab->tls_get_addr->is_func = 1;
		    }
		}
	    }
	}
      else
	no_tls_get_addr_opt = TRUE;
    }
  htab->no_tls_get_addr_opt = no_tls_get_addr_opt;
  return _bfd_elf_tls_setup (info->output_bfd, info);
}

/* Return TRUE iff REL is a branch reloc with a global symbol matching
   HASH1 or HASH2.  */

static bfd_boolean
branch_reloc_hash_match (const bfd *ibfd,
			 const Elf_Internal_Rela *rel,
			 const struct ppc_link_hash_entry *hash1,
			 const struct ppc_link_hash_entry *hash2)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
  enum elf_ppc64_reloc_type r_type = ELF64_R_TYPE (rel->r_info);
  unsigned int r_symndx = ELF64_R_SYM (rel->r_info);

  if (r_symndx >= symtab_hdr->sh_info && is_branch_reloc (r_type))
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      h = elf_follow_link (h);
      if (h == &hash1->elf || h == &hash2->elf)
	return TRUE;
    }
  return FALSE;
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  The linker has been hacked (see ppc64elf.em) to do
   a preliminary section layout so that we know the TLS segment
   offsets.  We can't optimize earlier because some optimizations need
   to know the tp offset, and we need to optimize before allocating
   dynamic relocations.  */

bfd_boolean
ppc64_elf_tls_optimize (struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;
  struct ppc_link_hash_table *htab;
  unsigned char *toc_ref;
  int pass;

  if (info->relocatable || !info->executable)
    return TRUE;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Make two passes over the relocs.  On the first pass, mark toc
     entries involved with tls relocs, and check that tls relocs
     involved in setting up a tls_get_addr call are indeed followed by
     such a call.  If they are not, we can't do any tls optimization.
     On the second pass twiddle tls_mask flags to notify
     relocate_section that optimization can be done, and adjust got
     and plt refcounts.  */
  toc_ref = NULL;
  for (pass = 0; pass < 2; ++pass)
    for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
      {
	Elf_Internal_Sym *locsyms = NULL;
	asection *toc = bfd_get_section_by_name (ibfd, ".toc");

	for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	  if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	    {
	      Elf_Internal_Rela *relstart, *rel, *relend;
	      bfd_boolean found_tls_get_addr_arg = 0;

	      /* Read the relocations.  */
	      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						    info->keep_memory);
	      if (relstart == NULL)
		return FALSE;

	      relend = relstart + sec->reloc_count;
	      for (rel = relstart; rel < relend; rel++)
		{
		  enum elf_ppc64_reloc_type r_type;
		  unsigned long r_symndx;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
		  asection *sym_sec;
		  unsigned char *tls_mask;
		  unsigned char tls_set, tls_clear, tls_type = 0;
		  bfd_vma value;
		  bfd_boolean ok_tprel, is_local;
		  long toc_ref_index = 0;
		  int expecting_tls_get_addr = 0;
		  bfd_boolean ret = FALSE;

		  r_symndx = ELF64_R_SYM (rel->r_info);
		  if (!get_sym_h (&h, &sym, &sym_sec, &tls_mask, &locsyms,
				  r_symndx, ibfd))
		    {
		    err_free_rel:
		      if (elf_section_data (sec)->relocs != relstart)
			free (relstart);
		      if (toc_ref != NULL)
			free (toc_ref);
		      if (locsyms != NULL
			  && (elf_symtab_hdr (ibfd).contents
			      != (unsigned char *) locsyms))
			free (locsyms);
		      return ret;
		    }

		  if (h != NULL)
		    {
		      if (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
			value = h->root.u.def.value;
		      else if (h->root.type == bfd_link_hash_undefweak)
			value = 0;
		      else
			{
			  found_tls_get_addr_arg = 0;
			  continue;
			}
		    }
		  else
		    /* Symbols referenced by TLS relocs must be of type
		       STT_TLS.  So no need for .opd local sym adjust.  */
		    value = sym->st_value;

		  ok_tprel = FALSE;
		  is_local = FALSE;
		  if (h == NULL
		      || !h->def_dynamic)
		    {
		      is_local = TRUE;
		      if (h != NULL
			  && h->root.type == bfd_link_hash_undefweak)
			ok_tprel = TRUE;
		      else
			{
			  value += sym_sec->output_offset;
			  value += sym_sec->output_section->vma;
			  value -= htab->elf.tls_sec->vma;
			  ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				      < (bfd_vma) 1 << 32);
			}
		    }

		  r_type = ELF64_R_TYPE (rel->r_info);
		  /* If this section has old-style __tls_get_addr calls
		     without marker relocs, then check that each
		     __tls_get_addr call reloc is preceded by a reloc
		     that conceivably belongs to the __tls_get_addr arg
		     setup insn.  If we don't find matching arg setup
		     relocs, don't do any tls optimization.  */
		  if (pass == 0
		      && sec->has_tls_get_addr_call
		      && h != NULL
		      && (h == &htab->tls_get_addr->elf
			  || h == &htab->tls_get_addr_fd->elf)
		      && !found_tls_get_addr_arg
		      && is_branch_reloc (r_type))
		    {
		      info->callbacks->minfo (_("%H __tls_get_addr lost arg, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      ret = TRUE;
		      goto err_free_rel;
		    }

		  found_tls_get_addr_arg = 0;
		  switch (r_type)
		    {
		    case R_PPC64_GOT_TLSLD16:
		    case R_PPC64_GOT_TLSLD16_LO:
		      expecting_tls_get_addr = 1;
		      found_tls_get_addr_arg = 1;
		      /* Fall thru */

		    case R_PPC64_GOT_TLSLD16_HI:
		    case R_PPC64_GOT_TLSLD16_HA:
		      /* These relocs should never be against a symbol
			 defined in a shared lib.  Leave them alone if
			 that turns out to be the case.  */
		      if (!is_local)
			continue;

		      /* LD -> LE */
		      tls_set = 0;
		      tls_clear = TLS_LD;
		      tls_type = TLS_TLS | TLS_LD;
		      break;

		    case R_PPC64_GOT_TLSGD16:
		    case R_PPC64_GOT_TLSGD16_LO:
		      expecting_tls_get_addr = 1;
		      found_tls_get_addr_arg = 1;
		      /* Fall thru */

		    case R_PPC64_GOT_TLSGD16_HI:
		    case R_PPC64_GOT_TLSGD16_HA:
		      if (ok_tprel)
			/* GD -> LE */
			tls_set = 0;
		      else
			/* GD -> IE */
			tls_set = TLS_TLS | TLS_TPRELGD;
		      tls_clear = TLS_GD;
		      tls_type = TLS_TLS | TLS_GD;
		      break;

		    case R_PPC64_GOT_TPREL16_DS:
		    case R_PPC64_GOT_TPREL16_LO_DS:
		    case R_PPC64_GOT_TPREL16_HI:
		    case R_PPC64_GOT_TPREL16_HA:
		      if (ok_tprel)
			{
			  /* IE -> LE */
			  tls_set = 0;
			  tls_clear = TLS_TPREL;
			  tls_type = TLS_TLS | TLS_TPREL;
			  break;
			}
		      continue;

		    case R_PPC64_TLSGD:
		    case R_PPC64_TLSLD:
		      found_tls_get_addr_arg = 1;
		      /* Fall thru */

		    case R_PPC64_TLS:
		    case R_PPC64_TOC16:
		    case R_PPC64_TOC16_LO:
		      if (sym_sec == NULL || sym_sec != toc)
			continue;

		      /* Mark this toc entry as referenced by a TLS
			 code sequence.  We can do that now in the
			 case of R_PPC64_TLS, and after checking for
			 tls_get_addr for the TOC16 relocs.  */
		      if (toc_ref == NULL)
			toc_ref = bfd_zmalloc (toc->output_section->rawsize / 8);
		      if (toc_ref == NULL)
			goto err_free_rel;

		      if (h != NULL)
			value = h->root.u.def.value;
		      else
			value = sym->st_value;
		      value += rel->r_addend;
		      BFD_ASSERT (value < toc->size && value % 8 == 0);
		      toc_ref_index = (value + toc->output_offset) / 8;
		      if (r_type == R_PPC64_TLS
			  || r_type == R_PPC64_TLSGD
			  || r_type == R_PPC64_TLSLD)
			{
			  toc_ref[toc_ref_index] = 1;
			  continue;
			}

		      if (pass != 0 && toc_ref[toc_ref_index] == 0)
			continue;

		      tls_set = 0;
		      tls_clear = 0;
		      expecting_tls_get_addr = 2;
		      break;

		    case R_PPC64_TPREL64:
		      if (pass == 0
			  || sec != toc
			  || toc_ref == NULL
			  || !toc_ref[(rel->r_offset + toc->output_offset) / 8])
			continue;
		      if (ok_tprel)
			{
			  /* IE -> LE */
			  tls_set = TLS_EXPLICIT;
			  tls_clear = TLS_TPREL;
			  break;
			}
		      continue;

		    case R_PPC64_DTPMOD64:
		      if (pass == 0
			  || sec != toc
			  || toc_ref == NULL
			  || !toc_ref[(rel->r_offset + toc->output_offset) / 8])
			continue;
		      if (rel + 1 < relend
			  && (rel[1].r_info
			      == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			  && rel[1].r_offset == rel->r_offset + 8)
			{
			  if (ok_tprel)
			    /* GD -> LE */
			    tls_set = TLS_EXPLICIT | TLS_GD;
			  else
			    /* GD -> IE */
			    tls_set = TLS_EXPLICIT | TLS_GD | TLS_TPRELGD;
			  tls_clear = TLS_GD;
			}
		      else
			{
			  if (!is_local)
			    continue;

			  /* LD -> LE */
			  tls_set = TLS_EXPLICIT;
			  tls_clear = TLS_LD;
			}
		      break;

		    default:
		      continue;
		    }

		  if (pass == 0)
		    {
		      if (!expecting_tls_get_addr
			  || !sec->has_tls_get_addr_call)
			continue;

		      if (rel + 1 < relend
			  && branch_reloc_hash_match (ibfd, rel + 1,
						      htab->tls_get_addr,
						      htab->tls_get_addr_fd))
			{
			  if (expecting_tls_get_addr == 2)
			    {
			      /* Check for toc tls entries.  */
			      unsigned char *toc_tls;
			      int retval;

			      retval = get_tls_mask (&toc_tls, NULL, NULL,
						     &locsyms,
						     rel, ibfd);
			      if (retval == 0)
				goto err_free_rel;
			      if (toc_tls != NULL)
				{
				  if ((*toc_tls & (TLS_GD | TLS_LD)) != 0)
				    found_tls_get_addr_arg = 1;
				  if (retval > 1)
				    toc_ref[toc_ref_index] = 1;
				}
			    }
			  continue;
			}

		      if (expecting_tls_get_addr != 1)
			continue;

		      /* Uh oh, we didn't find the expected call.  We
			 could just mark this symbol to exclude it
			 from tls optimization but it's safer to skip
			 the entire optimization.  */
		      info->callbacks->minfo (_("%H arg lost __tls_get_addr, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      ret = TRUE;
		      goto err_free_rel;
		    }

		  if (expecting_tls_get_addr && htab->tls_get_addr != NULL)
		    {
		      struct plt_entry *ent;
		      for (ent = htab->tls_get_addr->elf.plt.plist;
			   ent != NULL;
			   ent = ent->next)
			if (ent->addend == 0)
			  {
			    if (ent->plt.refcount > 0)
			      {
				ent->plt.refcount -= 1;
				expecting_tls_get_addr = 0;
			      }
			    break;
			  }
		    }

		  if (expecting_tls_get_addr && htab->tls_get_addr_fd != NULL)
		    {
		      struct plt_entry *ent;
		      for (ent = htab->tls_get_addr_fd->elf.plt.plist;
			   ent != NULL;
			   ent = ent->next)
			if (ent->addend == 0)
			  {
			    if (ent->plt.refcount > 0)
			      ent->plt.refcount -= 1;
			    break;
			  }
		    }

		  if (tls_clear == 0)
		    continue;

		  if ((tls_set & TLS_EXPLICIT) == 0)
		    {
		      struct got_entry *ent;

		      /* Adjust got entry for this reloc.  */
		      if (h != NULL)
			ent = h->got.glist;
		      else
			ent = elf_local_got_ents (ibfd)[r_symndx];

		      for (; ent != NULL; ent = ent->next)
			if (ent->addend == rel->r_addend
			    && ent->owner == ibfd
			    && ent->tls_type == tls_type)
			  break;
		      if (ent == NULL)
			abort ();

		      if (tls_set == 0)
			{
			  /* We managed to get rid of a got entry.  */
			  if (ent->got.refcount > 0)
			    ent->got.refcount -= 1;
			}
		    }
		  else
		    {
		      /* If we got rid of a DTPMOD/DTPREL reloc pair then
			 we'll lose one or two dyn relocs.  */
		      if (!dec_dynrel_count (rel->r_info, sec, info,
					     NULL, h, sym))
			return FALSE;

		      if (tls_set == (TLS_EXPLICIT | TLS_GD))
			{
			  if (!dec_dynrel_count ((rel + 1)->r_info, sec, info,
						 NULL, h, sym))
			    return FALSE;
			}
		    }

		  *tls_mask |= tls_set;
		  *tls_mask &= ~tls_clear;
		}

	      if (elf_section_data (sec)->relocs != relstart)
		free (relstart);
	    }

	if (locsyms != NULL
	    && (elf_symtab_hdr (ibfd).contents != (unsigned char *) locsyms))
	  {
	    if (!info->keep_memory)
	      free (locsyms);
	    else
	      elf_symtab_hdr (ibfd).contents = (unsigned char *) locsyms;
	  }
      }

  if (toc_ref != NULL)
    free (toc_ref);
  return TRUE;
}

/* Called via elf_link_hash_traverse from ppc64_elf_edit_toc to adjust
   the values of any global symbols in a toc section that has been
   edited.  Globals in toc sections should be a rarity, so this function
   sets a flag if any are found in toc sections other than the one just
   edited, so that futher hash table traversals can be avoided.  */

struct adjust_toc_info
{
  asection *toc;
  unsigned long *skip;
  bfd_boolean global_toc_syms;
};

enum toc_skip_enum { ref_from_discarded = 1, can_optimize = 2 };

static bfd_boolean
adjust_toc_syms (struct elf_link_hash_entry *h, void *inf)
{
  struct ppc_link_hash_entry *eh;
  struct adjust_toc_info *toc_inf = (struct adjust_toc_info *) inf;
  unsigned long i;

  if (h->root.type != bfd_link_hash_defined
      && h->root.type != bfd_link_hash_defweak)
    return TRUE;

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->adjust_done)
    return TRUE;

  if (eh->elf.root.u.def.section == toc_inf->toc)
    {
      if (eh->elf.root.u.def.value > toc_inf->toc->rawsize)
	i = toc_inf->toc->rawsize >> 3;
      else
	i = eh->elf.root.u.def.value >> 3;

      if ((toc_inf->skip[i] & (ref_from_discarded | can_optimize)) != 0)
	{
	  (*_bfd_error_handler)
	    (_("%s defined on removed toc entry"), eh->elf.root.root.string);
	  do
	    ++i;
	  while ((toc_inf->skip[i] & (ref_from_discarded | can_optimize)) != 0);
	  eh->elf.root.u.def.value = (bfd_vma) i << 3;
	}

      eh->elf.root.u.def.value -= toc_inf->skip[i];
      eh->adjust_done = 1;
    }
  else if (strcmp (eh->elf.root.u.def.section->name, ".toc") == 0)
    toc_inf->global_toc_syms = TRUE;

  return TRUE;
}

/* Return TRUE iff INSN is one we expect on a _LO variety toc/got reloc.  */

static bfd_boolean
ok_lo_toc_insn (unsigned int insn)
{
  return ((insn & (0x3f << 26)) == 14u << 26 /* addi */
	  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
	  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
	  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
	  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
	  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
	  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
	  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
	  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
	  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
	  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
	  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
	  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
	  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
	  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
	      && (insn & 3) != 1)
	  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
	      && ((insn & 3) == 0 || (insn & 3) == 3))
	  || (insn & (0x3f << 26)) == 12u << 26 /* addic */);
}

/* Examine all relocs referencing .toc sections in order to remove
   unused .toc entries.  */

bfd_boolean
ppc64_elf_edit_toc (struct bfd_link_info *info)
{
  bfd *ibfd;
  struct adjust_toc_info toc_inf;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  htab->do_toc_opt = 1;
  toc_inf.global_toc_syms = TRUE;
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      asection *toc, *sec;
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Sym *local_syms;
      Elf_Internal_Rela *relstart, *rel, *toc_relocs;
      unsigned long *skip, *drop;
      unsigned char *used;
      unsigned char *keep, last, some_unused;

      if (!is_ppc64_elf (ibfd))
	continue;

      toc = bfd_get_section_by_name (ibfd, ".toc");
      if (toc == NULL
	  || toc->size == 0
	  || toc->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
	  || discarded_section (toc))
	continue;

      toc_relocs = NULL;
      local_syms = NULL;
      symtab_hdr = &elf_symtab_hdr (ibfd);

      /* Look at sections dropped from the final link.  */
      skip = NULL;
      relstart = NULL;
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  if (sec->reloc_count == 0
	      || !discarded_section (sec)
	      || get_opd_info (sec)
	      || (sec->flags & SEC_ALLOC) == 0
	      || (sec->flags & SEC_DEBUGGING) != 0)
	    continue;

	  relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL, FALSE);
	  if (relstart == NULL)
	    goto error_ret;

	  /* Run through the relocs to see which toc entries might be
	     unused.  */
	  for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
	    {
	      enum elf_ppc64_reloc_type r_type;
	      unsigned long r_symndx;
	      asection *sym_sec;
	      struct elf_link_hash_entry *h;
	      Elf_Internal_Sym *sym;
	      bfd_vma val;

	      r_type = ELF64_R_TYPE (rel->r_info);
	      switch (r_type)
		{
		default:
		  continue;

		case R_PPC64_TOC16:
		case R_PPC64_TOC16_LO:
		case R_PPC64_TOC16_HI:
		case R_PPC64_TOC16_HA:
		case R_PPC64_TOC16_DS:
		case R_PPC64_TOC16_LO_DS:
		  break;
		}

	      r_symndx = ELF64_R_SYM (rel->r_info);
	      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			      r_symndx, ibfd))
		goto error_ret;

	      if (sym_sec != toc)
		continue;

	      if (h != NULL)
		val = h->root.u.def.value;
	      else
		val = sym->st_value;
	      val += rel->r_addend;

	      if (val >= toc->size)
		continue;

	      /* Anything in the toc ought to be aligned to 8 bytes.
		 If not, don't mark as unused.  */
	      if (val & 7)
		continue;

	      if (skip == NULL)
		{
		  skip = bfd_zmalloc (sizeof (*skip) * (toc->size + 15) / 8);
		  if (skip == NULL)
		    goto error_ret;
		}

	      skip[val >> 3] = ref_from_discarded;
	    }

	  if (elf_section_data (sec)->relocs != relstart)
	    free (relstart);
	}

      /* For largetoc loads of address constants, we can convert
	 .  addis rx,2,addr@@got@@ha
	 .  ld ry,addr@@got@@l(rx)
	 to
	 .  addis rx,2,addr@@toc@@ha
	 .  addi ry,rx,addr@@toc@@l
	 when addr is within 2G of the toc pointer.  This then means
	 that the word storing "addr" in the toc is no longer needed.  */

      if (!ppc64_elf_tdata (ibfd)->has_small_toc_reloc
	  && toc->output_section->rawsize < (bfd_vma) 1 << 31
	  && toc->reloc_count != 0)
	{
	  /* Read toc relocs.  */
	  toc_relocs = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
						  info->keep_memory);
	  if (toc_relocs == NULL)
	    goto error_ret;

	  for (rel = toc_relocs; rel < toc_relocs + toc->reloc_count; ++rel)
	    {
	      enum elf_ppc64_reloc_type r_type;
	      unsigned long r_symndx;
	      asection *sym_sec;
	      struct elf_link_hash_entry *h;
	      Elf_Internal_Sym *sym;
	      bfd_vma val, addr;

	      r_type = ELF64_R_TYPE (rel->r_info);
	      if (r_type != R_PPC64_ADDR64)
		continue;

	      r_symndx = ELF64_R_SYM (rel->r_info);
	      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			      r_symndx, ibfd))
		goto error_ret;

	      if (sym_sec == NULL
		  || discarded_section (sym_sec))
		continue;

	      if (!SYMBOL_CALLS_LOCAL (info, h))
		continue;

	      if (h != NULL)
		{
		  if (h->type == STT_GNU_IFUNC)
		    continue;
		  val = h->root.u.def.value;
		}
	      else
		{
		  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
		    continue;
		  val = sym->st_value;
		}
	      val += rel->r_addend;
	      val += sym_sec->output_section->vma + sym_sec->output_offset;

	      /* We don't yet know the exact toc pointer value, but we
		 know it will be somewhere in the toc section.  Don't
		 optimize if the difference from any possible toc
		 pointer is outside [ff..f80008000, 7fff7fff].  */
	      addr = toc->output_section->vma + TOC_BASE_OFF;
	      if (val - addr + (bfd_vma) 0x80008000 >= (bfd_vma) 1 << 32)
		continue;

	      addr = toc->output_section->vma + toc->output_section->rawsize;
	      if (val - addr + (bfd_vma) 0x80008000 >= (bfd_vma) 1 << 32)
		continue;

	      if (skip == NULL)
		{
		  skip = bfd_zmalloc (sizeof (*skip) * (toc->size + 15) / 8);
		  if (skip == NULL)
		    goto error_ret;
		}

	      skip[rel->r_offset >> 3]
		|= can_optimize | ((rel - toc_relocs) << 2);
	    }
	}

      if (skip == NULL)
	continue;

      used = bfd_zmalloc (sizeof (*used) * (toc->size + 7) / 8);
      if (used == NULL)
	{
	error_ret:
	  if (local_syms != NULL
	      && symtab_hdr->contents != (unsigned char *) local_syms)
	    free (local_syms);
	  if (sec != NULL
	      && relstart != NULL
	      && elf_section_data (sec)->relocs != relstart)
	    free (relstart);
	  if (toc_relocs != NULL
	      && elf_section_data (toc)->relocs != toc_relocs)
	    free (toc_relocs);
	  if (skip != NULL)
	    free (skip);
	  return FALSE;
	}

      /* Now check all kept sections that might reference the toc.
	 Check the toc itself last.  */
      for (sec = (ibfd->sections == toc && toc->next ? toc->next
		  : ibfd->sections);
	   sec != NULL;
	   sec = (sec == toc ? NULL
		  : sec->next == NULL ? toc
		  : sec->next == toc && toc->next ? toc->next
		  : sec->next))
	{
	  int repeat;

	  if (sec->reloc_count == 0
	      || discarded_section (sec)
	      || get_opd_info (sec)
	      || (sec->flags & SEC_ALLOC) == 0
	      || (sec->flags & SEC_DEBUGGING) != 0)
	    continue;

	  relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						info->keep_memory);
	  if (relstart == NULL)
	    goto error_ret;

	  /* Mark toc entries referenced as used.  */
	  do
	    {
	      repeat = 0;
	      for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
		{
		  enum elf_ppc64_reloc_type r_type;
		  unsigned long r_symndx;
		  asection *sym_sec;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
		  bfd_vma val;
		  enum {no_check, check_lo, check_ha} insn_check;

		  r_type = ELF64_R_TYPE (rel->r_info);
		  switch (r_type)
		    {
		    default:
		      insn_check = no_check;
		      break;

		    case R_PPC64_GOT_TLSLD16_HA:
		    case R_PPC64_GOT_TLSGD16_HA:
		    case R_PPC64_GOT_TPREL16_HA:
		    case R_PPC64_GOT_DTPREL16_HA:
		    case R_PPC64_GOT16_HA:
		    case R_PPC64_TOC16_HA:
		      insn_check = check_ha;
		      break;

		    case R_PPC64_GOT_TLSLD16_LO:
		    case R_PPC64_GOT_TLSGD16_LO:
		    case R_PPC64_GOT_TPREL16_LO_DS:
		    case R_PPC64_GOT_DTPREL16_LO_DS:
		    case R_PPC64_GOT16_LO:
		    case R_PPC64_GOT16_LO_DS:
		    case R_PPC64_TOC16_LO:
		    case R_PPC64_TOC16_LO_DS:
		      insn_check = check_lo;
		      break;
		    }

		  if (insn_check != no_check)
		    {
		      bfd_vma off = rel->r_offset & ~3;
		      unsigned char buf[4];
		      unsigned int insn;

		      if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
			{
			  free (used);
			  goto error_ret;
			}
		      insn = bfd_get_32 (ibfd, buf);
		      if (insn_check == check_lo
			  ? !ok_lo_toc_insn (insn)
			  : ((insn & ((0x3f << 26) | 0x1f << 16))
			     != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */))
			{
			  char str[12];

			  ppc64_elf_tdata (ibfd)->unexpected_toc_insn = 1;
			  sprintf (str, "%#08x", insn);
			  info->callbacks->einfo
			    (_("%P: %H: toc optimization is not supported for"
			       " %s instruction.\n"),
			     ibfd, sec, rel->r_offset & ~3, str);
			}
		    }

		  switch (r_type)
		    {
		    case R_PPC64_TOC16:
		    case R_PPC64_TOC16_LO:
		    case R_PPC64_TOC16_HI:
		    case R_PPC64_TOC16_HA:
		    case R_PPC64_TOC16_DS:
		    case R_PPC64_TOC16_LO_DS:
		      /* In case we're taking addresses of toc entries.  */
		    case R_PPC64_ADDR64:
		      break;

		    default:
		      continue;
		    }

		  r_symndx = ELF64_R_SYM (rel->r_info);
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_symndx, ibfd))
		    {
		      free (used);
		      goto error_ret;
		    }

		  if (sym_sec != toc)
		    continue;

		  if (h != NULL)
		    val = h->root.u.def.value;
		  else
		    val = sym->st_value;
		  val += rel->r_addend;

		  if (val >= toc->size)
		    continue;

		  if ((skip[val >> 3] & can_optimize) != 0)
		    {
		      bfd_vma off;
		      unsigned char opc;

		      switch (r_type)
			{
			case R_PPC64_TOC16_HA:
			  break;

			case R_PPC64_TOC16_LO_DS:
			  off = rel->r_offset;
			  off += (bfd_big_endian (ibfd) ? -2 : 3);
			  if (!bfd_get_section_contents (ibfd, sec, &opc,
							 off, 1))
			    {
			      free (used);
			      goto error_ret;
			    }
			  if ((opc & (0x3f << 2)) == (58u << 2))
			    break;
			  /* Fall thru */

			default:
			  /* Wrong sort of reloc, or not a ld.  We may
			     as well clear ref_from_discarded too.  */
			  skip[val >> 3] = 0;
			}
		    }

		  if (sec != toc)
		    used[val >> 3] = 1;
		  /* For the toc section, we only mark as used if this
		     entry itself isn't unused.  */
		  else if ((used[rel->r_offset >> 3]
			    || !(skip[rel->r_offset >> 3] & ref_from_discarded))
			   && !used[val >> 3])
		    {
		      /* Do all the relocs again, to catch reference
			 chains.  */
		      repeat = 1;
		      used[val >> 3] = 1;
		    }
		}
	    }
	  while (repeat);

	  if (elf_section_data (sec)->relocs != relstart)
	    free (relstart);
	}

      /* Merge the used and skip arrays.  Assume that TOC
	 doublewords not appearing as either used or unused belong
	 to to an entry more than one doubleword in size.  */
      for (drop = skip, keep = used, last = 0, some_unused = 0;
	   drop < skip + (toc->size + 7) / 8;
	   ++drop, ++keep)
	{
	  if (*keep)
	    {
	      *drop &= ~ref_from_discarded;
	      if ((*drop & can_optimize) != 0)
		some_unused = 1;
	      last = 0;
	    }
	  else if ((*drop & ref_from_discarded) != 0)
	    {
	      some_unused = 1;
	      last = ref_from_discarded;
	    }
	  else
	    *drop = last;
	}

      free (used);

      if (some_unused)
	{
	  bfd_byte *contents, *src;
	  unsigned long off;
	  Elf_Internal_Sym *sym;
	  bfd_boolean local_toc_syms = FALSE;

	  /* Shuffle the toc contents, and at the same time convert the
	     skip array from booleans into offsets.  */
	  if (!bfd_malloc_and_get_section (ibfd, toc, &contents))
	    goto error_ret;

	  elf_section_data (toc)->this_hdr.contents = contents;

	  for (src = contents, off = 0, drop = skip;
	       src < contents + toc->size;
	       src += 8, ++drop)
	    {
	      if ((*drop & (can_optimize | ref_from_discarded)) != 0)
		off += 8;
	      else if (off != 0)
		{
		  *drop = off;
		  memcpy (src - off, src, 8);
		}
	    }
	  *drop = off;
	  toc->rawsize = toc->size;
	  toc->size = src - contents - off;

	  /* Adjust addends for relocs against the toc section sym,
	     and optimize any accesses we can.  */
	  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	    {
	      if (sec->reloc_count == 0
		  || discarded_section (sec))
		continue;

	      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						    info->keep_memory);
	      if (relstart == NULL)
		goto error_ret;

	      for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
		{
		  enum elf_ppc64_reloc_type r_type;
		  unsigned long r_symndx;
		  asection *sym_sec;
		  struct elf_link_hash_entry *h;
		  bfd_vma val;

		  r_type = ELF64_R_TYPE (rel->r_info);
		  switch (r_type)
		    {
		    default:
		      continue;

		    case R_PPC64_TOC16:
		    case R_PPC64_TOC16_LO:
		    case R_PPC64_TOC16_HI:
		    case R_PPC64_TOC16_HA:
		    case R_PPC64_TOC16_DS:
		    case R_PPC64_TOC16_LO_DS:
		    case R_PPC64_ADDR64:
		      break;
		    }

		  r_symndx = ELF64_R_SYM (rel->r_info);
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_symndx, ibfd))
		    goto error_ret;

		  if (sym_sec != toc)
		    continue;

		  if (h != NULL)
		    val = h->root.u.def.value;
		  else
		    {
		      val = sym->st_value;
		      if (val != 0)
			local_toc_syms = TRUE;
		    }

		  val += rel->r_addend;

		  if (val > toc->rawsize)
		    val = toc->rawsize;
		  else if ((skip[val >> 3] & ref_from_discarded) != 0)
		    continue;
		  else if ((skip[val >> 3] & can_optimize) != 0)
		    {
		      Elf_Internal_Rela *tocrel
			= toc_relocs + (skip[val >> 3] >> 2);
		      unsigned long tsym = ELF64_R_SYM (tocrel->r_info);

		      switch (r_type)
			{
			case R_PPC64_TOC16_HA:
			  rel->r_info = ELF64_R_INFO (tsym, R_PPC64_TOC16_HA);
			  break;

			case R_PPC64_TOC16_LO_DS:
			  rel->r_info = ELF64_R_INFO (tsym, R_PPC64_LO_DS_OPT);
			  break;

			default:
			  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
			    ppc_howto_init ();
			  info->callbacks->einfo
			    (_("%P: %H: %s references "
			       "optimized away TOC entry\n"),
			     ibfd, sec, rel->r_offset,
			     ppc64_elf_howto_table[r_type]->name);
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret;
			}
		      rel->r_addend = tocrel->r_addend;
		      elf_section_data (sec)->relocs = relstart;
		      continue;
		    }

		  if (h != NULL || sym->st_value != 0)
		    continue;

		  rel->r_addend -= skip[val >> 3];
		  elf_section_data (sec)->relocs = relstart;
		}

	      if (elf_section_data (sec)->relocs != relstart)
		free (relstart);
	    }

	  /* We shouldn't have local or global symbols defined in the TOC,
	     but handle them anyway.  */
	  if (local_syms != NULL)
	    for (sym = local_syms;
		 sym < local_syms + symtab_hdr->sh_info;
		 ++sym)
	      if (sym->st_value != 0
		  && bfd_section_from_elf_index (ibfd, sym->st_shndx) == toc)
		{
		  unsigned long i;

		  if (sym->st_value > toc->rawsize)
		    i = toc->rawsize >> 3;
		  else
		    i = sym->st_value >> 3;

		  if ((skip[i] & (ref_from_discarded | can_optimize)) != 0)
		    {
		      if (local_toc_syms)
			(*_bfd_error_handler)
			  (_("%s defined on removed toc entry"),
			   bfd_elf_sym_name (ibfd, symtab_hdr, sym, NULL));
		      do
			++i;
		      while ((skip[i] & (ref_from_discarded | can_optimize)));
		      sym->st_value = (bfd_vma) i << 3;
		    }

		  sym->st_value -= skip[i];
		  symtab_hdr->contents = (unsigned char *) local_syms;
		}

	  /* Adjust any global syms defined in this toc input section.  */
	  if (toc_inf.global_toc_syms)
	    {
	      toc_inf.toc = toc;
	      toc_inf.skip = skip;
	      toc_inf.global_toc_syms = FALSE;
	      elf_link_hash_traverse (elf_hash_table (info), adjust_toc_syms,
				      &toc_inf);
	    }

	  if (toc->reloc_count != 0)
	    {
	      Elf_Internal_Shdr *rel_hdr;
	      Elf_Internal_Rela *wrel;
	      bfd_size_type sz;

	      /* Remove unused toc relocs, and adjust those we keep.  */
	      if (toc_relocs == NULL)
		toc_relocs = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
							info->keep_memory);
	      if (toc_relocs == NULL)
		goto error_ret;

	      wrel = toc_relocs;
	      for (rel = toc_relocs; rel < toc_relocs + toc->reloc_count; ++rel)
		if ((skip[rel->r_offset >> 3]
		     & (ref_from_discarded | can_optimize)) == 0)
		  {
		    wrel->r_offset = rel->r_offset - skip[rel->r_offset >> 3];
		    wrel->r_info = rel->r_info;
		    wrel->r_addend = rel->r_addend;
		    ++wrel;
		  }
		else if (!dec_dynrel_count (rel->r_info, toc, info,
					    &local_syms, NULL, NULL))
		  goto error_ret;

	      elf_section_data (toc)->relocs = toc_relocs;
	      toc->reloc_count = wrel - toc_relocs;
	      rel_hdr = _bfd_elf_single_rel_hdr (toc);
	      sz = rel_hdr->sh_entsize;
	      rel_hdr->sh_size = toc->reloc_count * sz;
	    }
	}
      else if (toc_relocs != NULL
	       && elf_section_data (toc)->relocs != toc_relocs)
	free (toc_relocs);

      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (!info->keep_memory)
	    free (local_syms);
	  else
	    symtab_hdr->contents = (unsigned char *) local_syms;
	}
      free (skip);
    }

  return TRUE;
}

/* Return true iff input section I references the TOC using
   instructions limited to +/-32k offsets.  */

bfd_boolean
ppc64_elf_has_small_toc_reloc (asection *i)
{
  return (is_ppc64_elf (i->owner)
	  && ppc64_elf_tdata (i->owner)->has_small_toc_reloc);
}

/* Allocate space for one GOT entry.  */

static void
allocate_got (struct elf_link_hash_entry *h,
	      struct bfd_link_info *info,
	      struct got_entry *gent)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  bfd_boolean dyn;
  struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) h;
  int entsize = (gent->tls_type & eh->tls_mask & (TLS_GD | TLS_LD)
		 ? 16 : 8);
  int rentsize = (gent->tls_type & eh->tls_mask & TLS_GD
		  ? 2 : 1) * sizeof (Elf64_External_Rela);
  asection *got = ppc64_elf_tdata (gent->owner)->got;

  gent->got.offset = got->size;
  got->size += entsize;

  dyn = htab->elf.dynamic_sections_created;
  if (h->type == STT_GNU_IFUNC)
    {
      htab->reliplt->size += rentsize;
      htab->got_reli_size += rentsize;
    }
  else if ((info->shared
	    || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	   && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak))
    {
      asection *relgot = ppc64_elf_tdata (gent->owner)->relgot;
      relgot->size += rentsize;
    }
}

/* This function merges got entries in the same toc group.  */

static void
merge_got_entries (struct got_entry **pent)
{
  struct got_entry *ent, *ent2;

  for (ent = *pent; ent != NULL; ent = ent->next)
    if (!ent->is_indirect)
      for (ent2 = ent->next; ent2 != NULL; ent2 = ent2->next)
	if (!ent2->is_indirect
	    && ent2->addend == ent->addend
	    && ent2->tls_type == ent->tls_type
	    && elf_gp (ent2->owner) == elf_gp (ent->owner))
	  {
	    ent2->is_indirect = TRUE;
	    ent2->got.ent = ent;
	  }
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct ppc_link_hash_table *htab;
  asection *s;
  struct ppc_link_hash_entry *eh;
  struct elf_dyn_relocs *p;
  struct got_entry **pgent, *gent;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if ((htab->elf.dynamic_sections_created
       && h->dynindx != -1
       && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
      || h->type == STT_GNU_IFUNC)
    {
      struct plt_entry *pent;
      bfd_boolean doneone = FALSE;
      for (pent = h->plt.plist; pent != NULL; pent = pent->next)
	if (pent->plt.refcount > 0)
	  {
	    if (!htab->elf.dynamic_sections_created
		|| h->dynindx == -1)
	      {
		s = htab->iplt;
		pent->plt.offset = s->size;
		s->size += PLT_ENTRY_SIZE;
		s = htab->reliplt;
	      }
	    else
	      {
		/* If this is the first .plt entry, make room for the special
		   first entry.  */
		s = htab->plt;
		if (s->size == 0)
		  s->size += PLT_INITIAL_ENTRY_SIZE;

		pent->plt.offset = s->size;

		/* Make room for this entry.  */
		s->size += PLT_ENTRY_SIZE;

		/* Make room for the .glink code.  */
		s = htab->glink;
		if (s->size == 0)
		  s->size += GLINK_CALL_STUB_SIZE;
		/* We need bigger stubs past index 32767.  */
		if (s->size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
		  s->size += 4;
		s->size += 2*4;

		/* We also need to make an entry in the .rela.plt section.  */
		s = htab->relplt;
	      }
	    s->size += sizeof (Elf64_External_Rela);
	    doneone = TRUE;
	  }
	else
	  pent->plt.offset = (bfd_vma) -1;
      if (!doneone)
	{
	  h->plt.plist = NULL;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.plist = NULL;
      h->needs_plt = 0;
    }

  eh = (struct ppc_link_hash_entry *) h;
  /* Run through the TLS GD got entries first if we're changing them
     to TPREL.  */
  if ((eh->tls_mask & TLS_TPRELGD) != 0)
    for (gent = h->got.glist; gent != NULL; gent = gent->next)
      if (gent->got.refcount > 0
	  && (gent->tls_type & TLS_GD) != 0)
	{
	  /* This was a GD entry that has been converted to TPREL.  If
	     there happens to be a TPREL entry we can use that one.  */
	  struct got_entry *ent;
	  for (ent = h->got.glist; ent != NULL; ent = ent->next)
	    if (ent->got.refcount > 0
		&& (ent->tls_type & TLS_TPREL) != 0
		&& ent->addend == gent->addend
		&& ent->owner == gent->owner)
	      {
		gent->got.refcount = 0;
		break;
	      }

	  /* If not, then we'll be using our own TPREL entry.  */
	  if (gent->got.refcount != 0)
	    gent->tls_type = TLS_TLS | TLS_TPREL;
	}

  /* Remove any list entry that won't generate a word in the GOT before
     we call merge_got_entries.  Otherwise we risk merging to empty
     entries.  */
  pgent = &h->got.glist;
  while ((gent = *pgent) != NULL)
    if (gent->got.refcount > 0)
      {
	if ((gent->tls_type & TLS_LD) != 0
	    && !h->def_dynamic)
	  {
	    ppc64_tlsld_got (gent->owner)->got.refcount += 1;
	    *pgent = gent->next;
	  }
	else
	  pgent = &gent->next;
      }
    else
      *pgent = gent->next;

  if (!htab->do_multi_toc)
    merge_got_entries (&h->got.glist);

  for (gent = h->got.glist; gent != NULL; gent = gent->next)
    if (!gent->is_indirect)
      {
	/* Make sure this symbol is output as a dynamic symbol.
	   Undefined weak syms won't yet be marked as dynamic,
	   nor will all TLS symbols.  */
	if (h->dynindx == -1
	    && !h->forced_local
	    && h->type != STT_GNU_IFUNC
	    && htab->elf.dynamic_sections_created)
	  {
	    if (! bfd_elf_link_record_dynamic_symbol (info, h))
	      return FALSE;
	  }

	if (!is_ppc64_elf (gent->owner))
	  abort ();

	allocate_got (h, info, gent);
      }

  if (eh->dyn_relocs == NULL
      || (!htab->elf.dynamic_sections_created
	  && h->type != STT_GNU_IFUNC))
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */

  if (info->shared)
    {
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see must_be_dyn_reloc) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else if (h->type == STT_GNU_IFUNC)
    {
      if (!h->non_got_ref)
	eh->dyn_relocs = NULL;
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && !h->def_regular)
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      if (eh->elf.type == STT_GNU_IFUNC)
	sreloc = htab->reliplt;
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct ppc_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  eh = (struct ppc_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
ppc64_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;
  struct got_entry *first_tlsld;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->elf.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry **lgot_ents;
      struct got_entry **end_lgot_ents;
      struct plt_entry **local_plt;
      struct plt_entry **end_local_plt;
      unsigned char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (!is_ppc64_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct ppc_dyn_relocs *p;

	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  asection *srel = elf_section_data (p->sec)->sreloc;
		  if (p->ifunc)
		    srel = htab->reliplt;
		  srel->size += p->count * sizeof (Elf64_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      lgot_ents = elf_local_got_ents (ibfd);
      if (!lgot_ents)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_lgot_ents = lgot_ents + locsymcount;
      local_plt = (struct plt_entry **) end_lgot_ents;
      end_local_plt = local_plt + locsymcount;
      lgot_masks = (unsigned char *) end_local_plt;
      s = ppc64_elf_tdata (ibfd)->got;
      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_masks)
	{
	  struct got_entry **pent, *ent;

	  pent = lgot_ents;
	  while ((ent = *pent) != NULL)
	    if (ent->got.refcount > 0)
	      {
		if ((ent->tls_type & *lgot_masks & TLS_LD) != 0)
		  {
		    ppc64_tlsld_got (ibfd)->got.refcount += 1;
		    *pent = ent->next;
		  }
		else
		  {
		    unsigned int ent_size = 8;
		    unsigned int rel_size = sizeof (Elf64_External_Rela);

		    ent->got.offset = s->size;
		    if ((ent->tls_type & *lgot_masks & TLS_GD) != 0)
		      {
			ent_size *= 2;
			rel_size *= 2;
		      }
		    s->size += ent_size;
		    if ((*lgot_masks & PLT_IFUNC) != 0)
		      {
			htab->reliplt->size += rel_size;
			htab->got_reli_size += rel_size;
		      }
		    else if (info->shared)
		      {
			asection *srel = ppc64_elf_tdata (ibfd)->relgot;
			srel->size += rel_size;
		      }
		    pent = &ent->next;
		  }
	      }
	    else
	      *pent = ent->next;
	}

      /* Allocate space for calls to local STT_GNU_IFUNC syms in .iplt.  */
      for (; local_plt < end_local_plt; ++local_plt)
	{
	  struct plt_entry *ent;

	  for (ent = *local_plt; ent != NULL; ent = ent->next)
	    if (ent->plt.refcount > 0)
	      {
		s = htab->iplt;
		ent->plt.offset = s->size;
		s->size += PLT_ENTRY_SIZE;

		htab->reliplt->size += sizeof (Elf64_External_Rela);
	      }
	    else
	      ent->plt.offset = (bfd_vma) -1;
	}
    }

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);

  first_tlsld = NULL;
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry *ent;

      if (!is_ppc64_elf (ibfd))
	continue;

      ent = ppc64_tlsld_got (ibfd);
      if (ent->got.refcount > 0)
	{
	  if (!htab->do_multi_toc && first_tlsld != NULL)
	    {
	      ent->is_indirect = TRUE;
	      ent->got.ent = first_tlsld;
	    }
	  else
	    {
	      if (first_tlsld == NULL)
		first_tlsld = ent;
	      s = ppc64_elf_tdata (ibfd)->got;
	      ent->got.offset = s->size;
	      ent->owner = ibfd;
	      s->size += 16;
	      if (info->shared)
		{
		  asection *srel = ppc64_elf_tdata (ibfd)->relgot;
		  srel->size += sizeof (Elf64_External_Rela);
		}
	    }
	}
      else
	ent->got.offset = (bfd_vma) -1;
    }

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->brlt || s == htab->relbrlt)
	/* These haven't been allocated yet;  don't strip.  */
	continue;
      else if (s == htab->got
	       || s == htab->plt
	       || s == htab->iplt
	       || s == htab->glink
	       || s == htab->dynbss)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (s == htab->glink_eh_frame)
	{
	  if (!bfd_is_abs_section (s->output_section))
	    /* Not sized yet.  */
	    continue;
	}
      else if (CONST_STRNEQ (s->name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      if (s != htab->relplt)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does we get a R_PPC64_NONE reloc in .rela
	 sections instead of garbage.
	 We also rely on the section contents being zero when writing
	 the GOT.  */
      s->contents = bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      if (!is_ppc64_elf (ibfd))
	continue;

      s = ppc64_elf_tdata (ibfd)->got;
      if (s != NULL && s != htab->got)
	{
	  if (s->size == 0)
	    s->flags |= SEC_EXCLUDE;
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->size);
	      if (s->contents == NULL)
		return FALSE;
	    }
	}
      s = ppc64_elf_tdata (ibfd)->relgot;
      if (s != NULL)
	{
	  if (s->size == 0)
	    s->flags |= SEC_EXCLUDE;
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->size);
	      if (s->contents == NULL)
		return FALSE;
	      relocs = TRUE;
	      s->reloc_count = 0;
	    }
	}
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in ppc64_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->plt != NULL && htab->plt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0)
	      || !add_dynamic_entry (DT_PPC64_GLINK, 0))
	    return FALSE;
	}

      if (NO_OPD_RELOCS)
	{
	  if (!add_dynamic_entry (DT_PPC64_OPD, 0)
	      || !add_dynamic_entry (DT_PPC64_OPDSZ, 0))
	    return FALSE;
	}

      if (!htab->no_tls_get_addr_opt
	  && htab->tls_get_addr_fd != NULL
	  && htab->tls_get_addr_fd->elf.plt.plist != NULL
	  && !add_dynamic_entry (DT_PPC64_TLSOPT, 0))
	return FALSE;

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Determine the type of stub needed, if any, for a call.  */

static inline enum ppc_stub_type
ppc_type_of_stub (asection *input_sec,
		  const Elf_Internal_Rela *rel,
		  struct ppc_link_hash_entry **hash,
		  struct plt_entry **plt_ent,
		  bfd_vma destination)
{
  struct ppc_link_hash_entry *h = *hash;
  bfd_vma location;
  bfd_vma branch_offset;
  bfd_vma max_branch_offset;
  enum elf_ppc64_reloc_type r_type;

  if (h != NULL)
    {
      struct plt_entry *ent;
      struct ppc_link_hash_entry *fdh = h;
      if (h->oh != NULL
	  && h->oh->is_func_descriptor)
	{
	  fdh = ppc_follow_link (h->oh);
	  *hash = fdh;
	}

      for (ent = fdh->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == rel->r_addend
	    && ent->plt.offset != (bfd_vma) -1)
	  {
	    *plt_ent = ent;
	    return ppc_stub_plt_call;
	  }

      /* Here, we know we don't have a plt entry.  If we don't have a
	 either a defined function descriptor or a defined entry symbol
	 in a regular object file, then it is pointless trying to make
	 any other type of stub.  */
      if (!is_static_defined (&fdh->elf)
	  && !is_static_defined (&h->elf))
	return ppc_stub_none;
    }
  else if (elf_local_got_ents (input_sec->owner) != NULL)
    {
      Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (input_sec->owner);
      struct plt_entry **local_plt = (struct plt_entry **)
	elf_local_got_ents (input_sec->owner) + symtab_hdr->sh_info;
      unsigned long r_symndx = ELF64_R_SYM (rel->r_info);

      if (local_plt[r_symndx] != NULL)
	{
	  struct plt_entry *ent;

	  for (ent = local_plt[r_symndx]; ent != NULL; ent = ent->next)
	    if (ent->addend == rel->r_addend
		&& ent->plt.offset != (bfd_vma) -1)
	      {
		*plt_ent = ent;
		return ppc_stub_plt_call;
	      }
	}
    }

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + rel->r_offset);

  branch_offset = destination - location;
  r_type = ELF64_R_TYPE (rel->r_info);

  /* Determine if a long branch stub is needed.  */
  max_branch_offset = 1 << 25;
  if (r_type != R_PPC64_REL24)
    max_branch_offset = 1 << 15;

  if (branch_offset + max_branch_offset >= 2 * max_branch_offset)
    /* We need a stub.  Figure out whether a long_branch or plt_branch
       is needed later.  */
    return ppc_stub_long_branch;

  return ppc_stub_none;
}

/* With power7 weakly ordered memory model, it is possible for ld.so
   to update a plt entry in one thread and have another thread see a
   stale zero toc entry.  To avoid this we need some sort of acquire
   barrier in the call stub.  One solution is to make the load of the
   toc word seem to appear to depend on the load of the function entry
   word.  Another solution is to test for r2 being zero, and branch to
   the appropriate glink entry if so.

   .	fake dep barrier	compare
   .	ld 11,xxx(2)		ld 11,xxx(2)
   .	mtctr 11		mtctr 11
   .	xor 11,11,11		ld 2,xxx+8(2)
   .	add 2,2,11		cmpldi 2,0
   .	ld 2,xxx+8(2)		bnectr+
   .	bctr			b <glink_entry>

   The solution involving the compare turns out to be faster, so
   that's what we use unless the branch won't reach.  */

#define ALWAYS_USE_FAKE_DEP 0
#define ALWAYS_EMIT_R2SAVE 0

#define PPC_LO(v) ((v) & 0xffff)
#define PPC_HI(v) (((v) >> 16) & 0xffff)
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

static inline unsigned int
plt_stub_size (struct ppc_link_hash_table *htab,
	       struct ppc_stub_hash_entry *stub_entry,
	       bfd_vma off)
{
  unsigned size = PLT_CALL_STUB_SIZE;

  if (!(ALWAYS_EMIT_R2SAVE
	|| stub_entry->stub_type == ppc_stub_plt_call_r2save))
    size -= 4;
  if (!htab->plt_static_chain)
    size -= 4;
  if (htab->plt_thread_safe)
    size += 8;
  if (PPC_HA (off) == 0)
    size -= 4;
  if (PPC_HA (off + 8 + 8 * htab->plt_static_chain) != PPC_HA (off))
    size += 4;
  if (stub_entry->h != NULL
      && (stub_entry->h == htab->tls_get_addr_fd
	  || stub_entry->h == htab->tls_get_addr)
      && !htab->no_tls_get_addr_opt)
    size += 13 * 4;
  return size;
}

/* If this stub would cross fewer 2**plt_stub_align boundaries if we align,
   then return the padding needed to do so.  */
static inline unsigned int
plt_stub_pad (struct ppc_link_hash_table *htab,
	      struct ppc_stub_hash_entry *stub_entry,
	      bfd_vma plt_off)
{
  int stub_align = 1 << htab->plt_stub_align;
  unsigned stub_size = plt_stub_size (htab, stub_entry, plt_off);
  bfd_vma stub_off = stub_entry->stub_sec->size;

  if (((stub_off + stub_size - 1) & -stub_align) - (stub_off & -stub_align)
      > (stub_size & -stub_align))
    return stub_align - (stub_off & (stub_align - 1));
  return 0;
}

/* Build a .plt call stub.  */

static inline bfd_byte *
build_plt_stub (struct ppc_link_hash_table *htab,
		struct ppc_stub_hash_entry *stub_entry,
		bfd_byte *p, bfd_vma offset, Elf_Internal_Rela *r)
{
  bfd *obfd = htab->stub_bfd;
  bfd_boolean plt_static_chain = htab->plt_static_chain;
  bfd_boolean plt_thread_safe = htab->plt_thread_safe;
  bfd_boolean use_fake_dep = plt_thread_safe;
  bfd_vma cmp_branch_off = 0;

  if (!ALWAYS_USE_FAKE_DEP
      && plt_thread_safe
      && !(stub_entry->h != NULL
	   && (stub_entry->h == htab->tls_get_addr_fd
	       || stub_entry->h == htab->tls_get_addr)
	   && !htab->no_tls_get_addr_opt))
    {
      bfd_vma pltoff = stub_entry->plt_ent->plt.offset & ~1;
      bfd_vma pltindex = (pltoff - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE;
      bfd_vma glinkoff = GLINK_CALL_STUB_SIZE + pltindex * 8;
      bfd_vma to, from;

      if (pltindex > 32768)
	glinkoff += (pltindex - 32768) * 4;
      to = (glinkoff
	    + htab->glink->output_offset
	    + htab->glink->output_section->vma);
      from = (p - stub_entry->stub_sec->contents
	      + 4 * (ALWAYS_EMIT_R2SAVE
		     || stub_entry->stub_type == ppc_stub_plt_call_r2save)
	      + 4 * (PPC_HA (offset) != 0)
	      + 4 * (PPC_HA (offset + 8 + 8 * plt_static_chain)
		     != PPC_HA (offset))
	      + 4 * (plt_static_chain != 0)
	      + 20
	      + stub_entry->stub_sec->output_offset
	      + stub_entry->stub_sec->output_section->vma);
      cmp_branch_off = to - from;
      use_fake_dep = cmp_branch_off + (1 << 25) >= (1 << 26);
    }

  if (PPC_HA (offset) != 0)
    {
      if (r != NULL)
	{
	  if (ALWAYS_EMIT_R2SAVE
	      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
	    r[0].r_offset += 4;
	  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_HA);
	  r[1].r_offset = r[0].r_offset + 4;
	  r[1].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO_DS);
	  r[1].r_addend = r[0].r_addend;
	  if (PPC_HA (offset + 8 + 8 * plt_static_chain) != PPC_HA (offset))
	    {
	      r[2].r_offset = r[1].r_offset + 4;
	      r[2].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO);
	      r[2].r_addend = r[0].r_addend;
	    }
	  else
	    {
	      r[2].r_offset = r[1].r_offset + 8 + 8 * use_fake_dep;
	      r[2].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO_DS);
	      r[2].r_addend = r[0].r_addend + 8;
	      if (plt_static_chain)
		{
		  r[3].r_offset = r[2].r_offset + 4;
		  r[3].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO_DS);
		  r[3].r_addend = r[0].r_addend + 16;
		}
	    }
	}
      if (ALWAYS_EMIT_R2SAVE
	  || stub_entry->stub_type == ppc_stub_plt_call_r2save)
	bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (offset), p),	p += 4;
      bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset), p),	p += 4;
      if (PPC_HA (offset + 8 + 8 * plt_static_chain) != PPC_HA (offset))
	{
	  bfd_put_32 (obfd, ADDI_R12_R12 | PPC_LO (offset), p),	p += 4;
	  offset = 0;
	}
      bfd_put_32 (obfd, MTCTR_R11, p),				p += 4;
      if (use_fake_dep)
	{
	  bfd_put_32 (obfd, XOR_R11_R11_R11, p),		p += 4;
	  bfd_put_32 (obfd, ADD_R12_R12_R11, p),		p += 4;
	}
      bfd_put_32 (obfd, LD_R2_0R12 | PPC_LO (offset + 8), p),	p += 4;
      if (plt_static_chain)
	bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset + 16), p), p += 4;
    }
  else
    {
      if (r != NULL)
	{
	  if (ALWAYS_EMIT_R2SAVE
	      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
	    r[0].r_offset += 4;
	  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);
	  if (PPC_HA (offset + 8 + 8 * plt_static_chain) != PPC_HA (offset))
	    {
	      r[1].r_offset = r[0].r_offset + 4;
	      r[1].r_info = ELF64_R_INFO (0, R_PPC64_TOC16);
	      r[1].r_addend = r[0].r_addend;
	    }
	  else
	    {
	      r[1].r_offset = r[0].r_offset + 8 + 8 * use_fake_dep;
	      r[1].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);
	      r[1].r_addend = r[0].r_addend + 8 + 8 * plt_static_chain;
	      if (plt_static_chain)
		{
		  r[2].r_offset = r[1].r_offset + 4;
		  r[2].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);
		  r[2].r_addend = r[0].r_addend + 8;
		}
	    }
	}
      if (ALWAYS_EMIT_R2SAVE
	  || stub_entry->stub_type == ppc_stub_plt_call_r2save)
	bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
      bfd_put_32 (obfd, LD_R11_0R2 | PPC_LO (offset), p),	p += 4;
      if (PPC_HA (offset + 8 + 8 * plt_static_chain) != PPC_HA (offset))
	{
	  bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (offset), p),	p += 4;
	  offset = 0;
	}
      bfd_put_32 (obfd, MTCTR_R11, p),				p += 4;
      if (use_fake_dep)
	{
	  bfd_put_32 (obfd, XOR_R11_R11_R11, p),		p += 4;
	  bfd_put_32 (obfd, ADD_R2_R2_R11, p),			p += 4;
	}
      if (plt_static_chain)
	bfd_put_32 (obfd, LD_R11_0R2 | PPC_LO (offset + 16), p), p += 4;
      bfd_put_32 (obfd, LD_R2_0R2 | PPC_LO (offset + 8), p),	p += 4;
    }
  if (plt_thread_safe && !use_fake_dep)
    {
      bfd_put_32 (obfd, CMPLDI_R2_0, p),			p += 4;
      bfd_put_32 (obfd, BNECTR_P4, p),				p += 4;
      bfd_put_32 (obfd, B_DOT | (cmp_branch_off & 0x3fffffc), p), p += 4;
    }
  else
    bfd_put_32 (obfd, BCTR, p),					p += 4;
  return p;
}

/* Build a special .plt call stub for __tls_get_addr.  */

#define LD_R11_0R3	0xe9630000
#define LD_R12_0R3	0xe9830000
#define MR_R0_R3	0x7c601b78
#define CMPDI_R11_0	0x2c2b0000
#define ADD_R3_R12_R13	0x7c6c6a14
#define BEQLR		0x4d820020
#define MR_R3_R0	0x7c030378
#define MFLR_R11	0x7d6802a6
#define STD_R11_0R1	0xf9610000
#define BCTRL		0x4e800421
#define LD_R11_0R1	0xe9610000
#define LD_R2_0R1	0xe8410000
#define MTLR_R11	0x7d6803a6

static inline bfd_byte *
build_tls_get_addr_stub (struct ppc_link_hash_table *htab,
			 struct ppc_stub_hash_entry *stub_entry,
			 bfd_byte *p, bfd_vma offset, Elf_Internal_Rela *r)
{
  bfd *obfd = htab->stub_bfd;

  bfd_put_32 (obfd, LD_R11_0R3 + 0, p),		p += 4;
  bfd_put_32 (obfd, LD_R12_0R3 + 8, p),		p += 4;
  bfd_put_32 (obfd, MR_R0_R3, p),		p += 4;
  bfd_put_32 (obfd, CMPDI_R11_0, p),		p += 4;
  bfd_put_32 (obfd, ADD_R3_R12_R13, p),		p += 4;
  bfd_put_32 (obfd, BEQLR, p),			p += 4;
  bfd_put_32 (obfd, MR_R3_R0, p),		p += 4;
  bfd_put_32 (obfd, MFLR_R11, p),		p += 4;
  bfd_put_32 (obfd, STD_R11_0R1 + 32, p),	p += 4;

  if (r != NULL)
    r[0].r_offset += 9 * 4;
  p = build_plt_stub (htab, stub_entry, p, offset, r);
  bfd_put_32 (obfd, BCTRL, p - 4);

  bfd_put_32 (obfd, LD_R11_0R1 + 32, p),	p += 4;
  bfd_put_32 (obfd, LD_R2_0R1 + 40, p),		p += 4;
  bfd_put_32 (obfd, MTLR_R11, p),		p += 4;
  bfd_put_32 (obfd, BLR, p),			p += 4;

  return p;
}

static Elf_Internal_Rela *
get_relocs (asection *sec, int count)
{
  Elf_Internal_Rela *relocs;
  struct bfd_elf_section_data *elfsec_data;

  elfsec_data = elf_section_data (sec);
  relocs = elfsec_data->relocs;
  if (relocs == NULL)
    {
      bfd_size_type relsize;
      relsize = sec->reloc_count * sizeof (*relocs);
      relocs = bfd_alloc (sec->owner, relsize);
      if (relocs == NULL)
	return NULL;
      elfsec_data->relocs = relocs;
      elfsec_data->rela.hdr = bfd_zalloc (sec->owner,
					  sizeof (Elf_Internal_Shdr));
      if (elfsec_data->rela.hdr == NULL)
	return NULL;
      elfsec_data->rela.hdr->sh_size = (sec->reloc_count
					* sizeof (Elf64_External_Rela));
      elfsec_data->rela.hdr->sh_entsize = sizeof (Elf64_External_Rela);
      sec->reloc_count = 0;
    }
  relocs += sec->reloc_count;
  sec->reloc_count += count;
  return relocs;
}

static bfd_vma
get_r2off (struct bfd_link_info *info,
	   struct ppc_stub_hash_entry *stub_entry)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  bfd_vma r2off = htab->stub_group[stub_entry->target_section->id].toc_off;

  if (r2off == 0)
    {
      /* Support linking -R objects.  Get the toc pointer from the
	 opd entry.  */
      char buf[8];
      asection *opd = stub_entry->h->elf.root.u.def.section;
      bfd_vma opd_off = stub_entry->h->elf.root.u.def.value;

      if (strcmp (opd->name, ".opd") != 0
	  || opd->reloc_count != 0)
	{
	  info->callbacks->einfo (_("%P: cannot find opd entry toc for `%T'\n"),
				  stub_entry->h->elf.root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return 0;
	}
      if (!bfd_get_section_contents (opd->owner, opd, buf, opd_off + 8, 8))
	return 0;
      r2off = bfd_get_64 (opd->owner, buf);
      r2off -= elf_gp (info->output_bfd);
    }
  r2off -= htab->stub_group[stub_entry->id_sec->id].toc_off;
  return r2off;
}

static bfd_boolean
ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct ppc_stub_hash_entry *stub_entry;
  struct ppc_branch_hash_entry *br_entry;
  struct bfd_link_info *info;
  struct ppc_link_hash_table *htab;
  bfd_byte *loc;
  bfd_byte *p;
  bfd_vma dest, off;
  int size;
  Elf_Internal_Rela *r;
  asection *plt;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct ppc_stub_hash_entry *) gen_entry;
  info = in_arg;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_entry->stub_sec->size;
  loc = stub_entry->stub_sec->contents + stub_entry->stub_offset;

  htab->stub_count[stub_entry->stub_type - 1] += 1;
  switch (stub_entry->stub_type)
    {
    case ppc_stub_long_branch:
    case ppc_stub_long_branch_r2off:
      /* Branches are relative.  This is where we are going to.  */
      off = dest = (stub_entry->target_value
		    + stub_entry->target_section->output_offset
		    + stub_entry->target_section->output_section->vma);

      /* And this is where we are coming from.  */
      off -= (stub_entry->stub_offset
	      + stub_entry->stub_sec->output_offset
	      + stub_entry->stub_sec->output_section->vma);

      size = 4;
      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
	{
	  bfd_vma r2off = get_r2off (info, stub_entry);

	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }
	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  size = 12;
	  if (PPC_HA (r2off) != 0)
	    {
	      size = 16;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	      loc += 4;
	    }
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	  loc += 4;
	  off -= size - 4;
	}
      bfd_put_32 (htab->stub_bfd, B_DOT | (off & 0x3fffffc), loc);

      if (off + (1 << 25) >= (bfd_vma) (1 << 26))
	{
	  info->callbacks->einfo
	    (_("%P: long branch stub `%s' offset overflow\n"),
	     stub_entry->root.string);
	  htab->stub_error = TRUE;
	  return FALSE;
	}

      if (info->emitrelocations)
	{
	  r = get_relocs (stub_entry->stub_sec, 1);
	  if (r == NULL)
	    return FALSE;
	  r->r_offset = loc - stub_entry->stub_sec->contents;
	  r->r_info = ELF64_R_INFO (0, R_PPC64_REL24);
	  r->r_addend = dest;
	  if (stub_entry->h != NULL)
	    {
	      struct elf_link_hash_entry **hashes;
	      unsigned long symndx;
	      struct ppc_link_hash_entry *h;

	      hashes = elf_sym_hashes (htab->stub_bfd);
	      if (hashes == NULL)
		{
		  bfd_size_type hsize;

		  hsize = (htab->stub_globals + 1) * sizeof (*hashes);
		  hashes = bfd_zalloc (htab->stub_bfd, hsize);
		  if (hashes == NULL)
		    return FALSE;
		  elf_sym_hashes (htab->stub_bfd) = hashes;
		  htab->stub_globals = 1;
		}
	      symndx = htab->stub_globals++;
	      h = stub_entry->h;
	      hashes[symndx] = &h->elf;
	      r->r_info = ELF64_R_INFO (symndx, R_PPC64_REL24);
	      if (h->oh != NULL && h->oh->is_func)
		h = ppc_follow_link (h->oh);
	      if (h->elf.root.u.def.section != stub_entry->target_section)
		/* H is an opd symbol.  The addend must be zero.  */
		r->r_addend = 0;
	      else
		{
		  off = (h->elf.root.u.def.value
			 + h->elf.root.u.def.section->output_offset
			 + h->elf.root.u.def.section->output_section->vma);
		  r->r_addend -= off;
		}
	    }
	}
      break;

    case ppc_stub_plt_branch:
    case ppc_stub_plt_branch_r2off:
      br_entry = ppc_branch_hash_lookup (&htab->branch_hash_table,
					 stub_entry->root.string + 9,
					 FALSE, FALSE);
      if (br_entry == NULL)
	{
	  info->callbacks->einfo (_("%P: can't find branch stub `%s'\n"),
				  stub_entry->root.string);
	  htab->stub_error = TRUE;
	  return FALSE;
	}

      dest = (stub_entry->target_value
	      + stub_entry->target_section->output_offset
	      + stub_entry->target_section->output_section->vma);

      bfd_put_64 (htab->brlt->owner, dest,
		  htab->brlt->contents + br_entry->offset);

      if (br_entry->iter == htab->stub_iteration)
	{
	  br_entry->iter = 0;

	  if (htab->relbrlt != NULL)
	    {
	      /* Create a reloc for the branch lookup table entry.  */
	      Elf_Internal_Rela rela;
	      bfd_byte *rl;

	      rela.r_offset = (br_entry->offset
			       + htab->brlt->output_offset
			       + htab->brlt->output_section->vma);
	      rela.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
	      rela.r_addend = dest;

	      rl = htab->relbrlt->contents;
	      rl += (htab->relbrlt->reloc_count++
		     * sizeof (Elf64_External_Rela));
	      bfd_elf64_swap_reloca_out (htab->relbrlt->owner, &rela, rl);
	    }
	  else if (info->emitrelocations)
	    {
	      r = get_relocs (htab->brlt, 1);
	      if (r == NULL)
		return FALSE;
	      /* brlt, being SEC_LINKER_CREATED does not go through the
		 normal reloc processing.  Symbols and offsets are not
		 translated from input file to output file form, so
		 set up the offset per the output file.  */
	      r->r_offset = (br_entry->offset
			     + htab->brlt->output_offset
			     + htab->brlt->output_section->vma);
	      r->r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
	      r->r_addend = dest;
	    }
	}

      dest = (br_entry->offset
	      + htab->brlt->output_offset
	      + htab->brlt->output_section->vma);

      off = (dest
	     - elf_gp (htab->brlt->output_section->owner)
	     - htab->stub_group[stub_entry->id_sec->id].toc_off);

      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
	{
	  info->callbacks->einfo
	    (_("%P: linkage table error against `%T'\n"),
	     stub_entry->root.string);
	  bfd_set_error (bfd_error_bad_value);
	  htab->stub_error = TRUE;
	  return FALSE;
	}

      if (info->emitrelocations)
	{
	  r = get_relocs (stub_entry->stub_sec, 1 + (PPC_HA (off) != 0));
	  if (r == NULL)
	    return FALSE;
	  r[0].r_offset = loc - stub_entry->stub_sec->contents;
	  if (bfd_big_endian (info->output_bfd))
	    r[0].r_offset += 2;
	  if (stub_entry->stub_type == ppc_stub_plt_branch_r2off)
	    r[0].r_offset += 4;
	  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);
	  r[0].r_addend = dest;
	  if (PPC_HA (off) != 0)
	    {
	      r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_HA);
	      r[1].r_offset = r[0].r_offset + 4;
	      r[1].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO_DS);
	      r[1].r_addend = r[0].r_addend;
	    }
	}

      if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
	{
	  if (PPC_HA (off) != 0)
	    {
	      size = 16;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (off), loc);
	      loc += 4;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (off), loc);
	    }
	  else
	    {
	      size = 12;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (off), loc);
	    }
	}
      else
	{
	  bfd_vma r2off = get_r2off (info, stub_entry);

	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }

	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  size = 20;
	  if (PPC_HA (off) != 0)
	    {
	      size += 4;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (off), loc);
	      loc += 4;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (off), loc);
	      loc += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (off), loc);
	      loc += 4;
	    }

	  if (PPC_HA (r2off) != 0)
	    {
	      size += 4;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	      loc += 4;
	    }
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	}
      loc += 4;
      bfd_put_32 (htab->stub_bfd, MTCTR_R11, loc);
      loc += 4;
      bfd_put_32 (htab->stub_bfd, BCTR, loc);
      break;

    case ppc_stub_plt_call:
    case ppc_stub_plt_call_r2save:
      if (stub_entry->h != NULL
	  && stub_entry->h->is_func_descriptor
	  && stub_entry->h->oh != NULL)
	{
	  struct ppc_link_hash_entry *fh = ppc_follow_link (stub_entry->h->oh);

	  /* If the old-ABI "dot-symbol" is undefined make it weak so
	     we don't get a link error from RELOC_FOR_GLOBAL_SYMBOL.
	     FIXME: We used to define the symbol on one of the call
	     stubs instead, which is why we test symbol section id
	     against htab->top_id in various places.  Likely all
	     these checks could now disappear.  */
	  if (fh->elf.root.type == bfd_link_hash_undefined)
	    fh->elf.root.type = bfd_link_hash_undefweak;
	  /* Stop undo_symbol_twiddle changing it back to undefined.  */
	  fh->was_undefined = 0;
	}

      /* Now build the stub.  */
      dest = stub_entry->plt_ent->plt.offset & ~1;
      if (dest >= (bfd_vma) -2)
	abort ();

      plt = htab->plt;
      if (!htab->elf.dynamic_sections_created
	  || stub_entry->h == NULL
	  || stub_entry->h->elf.dynindx == -1)
	plt = htab->iplt;

      dest += plt->output_offset + plt->output_section->vma;

      if (stub_entry->h == NULL
	  && (stub_entry->plt_ent->plt.offset & 1) == 0)
	{
	  Elf_Internal_Rela rela;
	  bfd_byte *rl;

	  rela.r_offset = dest;
	  rela.r_info = ELF64_R_INFO (0, R_PPC64_JMP_IREL);
	  rela.r_addend = (stub_entry->target_value
			   + stub_entry->target_section->output_offset
			   + stub_entry->target_section->output_section->vma);

	  rl = (htab->reliplt->contents
		+ (htab->reliplt->reloc_count++
		   * sizeof (Elf64_External_Rela)));
	  bfd_elf64_swap_reloca_out (info->output_bfd, &rela, rl);
	  stub_entry->plt_ent->plt.offset |= 1;
	}

      off = (dest
	     - elf_gp (plt->output_section->owner)
	     - htab->stub_group[stub_entry->id_sec->id].toc_off);

      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
	{
	  info->callbacks->einfo
	    (_("%P: linkage table error against `%T'\n"),
	     stub_entry->h != NULL
	     ? stub_entry->h->elf.root.root.string
	     : "<local sym>");
	  bfd_set_error (bfd_error_bad_value);
	  htab->stub_error = TRUE;
	  return FALSE;
	}

      if (htab->plt_stub_align != 0)
	{
	  unsigned pad = plt_stub_pad (htab, stub_entry, off);

	  stub_entry->stub_sec->size += pad;
	  stub_entry->stub_offset = stub_entry->stub_sec->size;
	  loc += pad;
	}

      r = NULL;
      if (info->emitrelocations)
	{
	  r = get_relocs (stub_entry->stub_sec,
			  (2
			   + (PPC_HA (off) != 0)
			   + (htab->plt_static_chain
			      && PPC_HA (off + 16) == PPC_HA (off))));
	  if (r == NULL)
	    return FALSE;
	  r[0].r_offset = loc - stub_entry->stub_sec->contents;
	  if (bfd_big_endian (info->output_bfd))
	    r[0].r_offset += 2;
	  r[0].r_addend = dest;
	}
      if (stub_entry->h != NULL
	  && (stub_entry->h == htab->tls_get_addr_fd
	      || stub_entry->h == htab->tls_get_addr)
	  && !htab->no_tls_get_addr_opt)
	p = build_tls_get_addr_stub (htab, stub_entry, loc, off, r);
      else
	p = build_plt_stub (htab, stub_entry, loc, off, r);
      size = p - loc;
      break;

    default:
      BFD_FAIL ();
      return FALSE;
    }

  stub_entry->stub_sec->size += size;

  if (htab->emit_stub_syms)
    {
      struct elf_link_hash_entry *h;
      size_t len1, len2;
      char *name;
      const char *const stub_str[] = { "long_branch",
				       "long_branch_r2off",
				       "plt_branch",
				       "plt_branch_r2off",
				       "plt_call",
				       "plt_call" };

      len1 = strlen (stub_str[stub_entry->stub_type - 1]);
      len2 = strlen (stub_entry->root.string);
      name = bfd_malloc (len1 + len2 + 2);
      if (name == NULL)
	return FALSE;
      memcpy (name, stub_entry->root.string, 9);
      memcpy (name + 9, stub_str[stub_entry->stub_type - 1], len1);
      memcpy (name + len1 + 9, stub_entry->root.string + 8, len2 - 8 + 1);
      h = elf_link_hash_lookup (&htab->elf, name, TRUE, FALSE, FALSE);
      if (h == NULL)
	return FALSE;
      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = stub_entry->stub_sec;
	  h->root.u.def.value = stub_entry->stub_offset;
	  h->ref_regular = 1;
	  h->def_regular = 1;
	  h->ref_regular_nonweak = 1;
	  h->forced_local = 1;
	  h->non_elf = 0;
	}
    }

  return TRUE;
}

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes, and select plt_branch stubs where
   long_branch stubs won't do.  */

static bfd_boolean
ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct ppc_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct ppc_link_hash_table *htab;
  bfd_vma off;
  int size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct ppc_stub_hash_entry *) gen_entry;
  info = in_arg;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (stub_entry->stub_type == ppc_stub_plt_call
      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
    {
      asection *plt;
      off = stub_entry->plt_ent->plt.offset & ~(bfd_vma) 1;
      if (off >= (bfd_vma) -2)
	abort ();
      plt = htab->plt;
      if (!htab->elf.dynamic_sections_created
	  || stub_entry->h == NULL
	  || stub_entry->h->elf.dynindx == -1)
	plt = htab->iplt;
      off += (plt->output_offset
	      + plt->output_section->vma
	      - elf_gp (plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);

      size = plt_stub_size (htab, stub_entry, off);
      if (htab->plt_stub_align)
	size += plt_stub_pad (htab, stub_entry, off);
      if (info->emitrelocations)
	{
	  stub_entry->stub_sec->reloc_count
	    += (2
		+ (PPC_HA (off) != 0)
		+ (htab->plt_static_chain
		   && PPC_HA (off + 16) == PPC_HA (off)));
	  stub_entry->stub_sec->flags |= SEC_RELOC;
	}
    }
  else
    {
      /* ppc_stub_long_branch or ppc_stub_plt_branch, or their r2off
	 variants.  */
      bfd_vma r2off = 0;

      off = (stub_entry->target_value
	     + stub_entry->target_section->output_offset
	     + stub_entry->target_section->output_section->vma);
      off -= (stub_entry->stub_sec->size
	      + stub_entry->stub_sec->output_offset
	      + stub_entry->stub_sec->output_section->vma);

      /* Reset the stub type from the plt variant in case we now
	 can reach with a shorter stub.  */
      if (stub_entry->stub_type >= ppc_stub_plt_branch)
	stub_entry->stub_type += ppc_stub_long_branch - ppc_stub_plt_branch;

      size = 4;
      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
	{
	  r2off = get_r2off (info, stub_entry);
	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }
	  size = 12;
	  if (PPC_HA (r2off) != 0)
	    size = 16;
	  off -= size - 4;
	}

      /* If the branch offset if too big, use a ppc_stub_plt_branch.  */
      if (off + (1 << 25) >= (bfd_vma) (1 << 26))
	{
	  struct ppc_branch_hash_entry *br_entry;

	  br_entry = ppc_branch_hash_lookup (&htab->branch_hash_table,
					     stub_entry->root.string + 9,
					     TRUE, FALSE);
	  if (br_entry == NULL)
	    {
	      info->callbacks->einfo (_("%P: can't build branch stub `%s'\n"),
				      stub_entry->root.string);
	      htab->stub_error = TRUE;
	      return FALSE;
	    }

	  if (br_entry->iter != htab->stub_iteration)
	    {
	      br_entry->iter = htab->stub_iteration;
	      br_entry->offset = htab->brlt->size;
	      htab->brlt->size += 8;

	      if (htab->relbrlt != NULL)
		htab->relbrlt->size += sizeof (Elf64_External_Rela);
	      else if (info->emitrelocations)
		{
		  htab->brlt->reloc_count += 1;
		  htab->brlt->flags |= SEC_RELOC;
		}
	    }

	  stub_entry->stub_type += ppc_stub_plt_branch - ppc_stub_long_branch;
	  off = (br_entry->offset
		 + htab->brlt->output_offset
		 + htab->brlt->output_section->vma
		 - elf_gp (htab->brlt->output_section->owner)
		 - htab->stub_group[stub_entry->id_sec->id].toc_off);

	  if (info->emitrelocations)
	    {
	      stub_entry->stub_sec->reloc_count += 1 + (PPC_HA (off) != 0);
	      stub_entry->stub_sec->flags |= SEC_RELOC;
	    }

	  if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
	    {
	      size = 12;
	      if (PPC_HA (off) != 0)
		size = 16;
	    }
	  else
	    {
	      size = 20;
	      if (PPC_HA (off) != 0)
		size += 4;

	      if (PPC_HA (r2off) != 0)
		size += 4;
	    }
	}
      else if (info->emitrelocations)
	{
	  stub_entry->stub_sec->reloc_count += 1;
	  stub_entry->stub_sec->flags |= SEC_RELOC;
	}
    }

  stub_entry->stub_sec->size += size;
  return TRUE;
}

/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  */

int
ppc64_elf_setup_section_lists
  (struct bfd_link_info *info,
   asection *(*add_stub_section) (const char *, asection *),
   void (*layout_sections_again) (void))
{
  bfd *input_bfd;
  int top_id, top_index, id;
  asection *section;
  asection **input_list;
  bfd_size_type amt;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (htab == NULL)
    return -1;
  /* Stash our params away.  */
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;

  /* Find the top input section id.  */
  for (input_bfd = info->input_bfds, top_id = 3;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (top_id < section->id)
	    top_id = section->id;
	}
    }

  htab->top_id = top_id;
  amt = sizeof (struct map_stub) * (top_id + 1);
  htab->stub_group = bfd_zmalloc (amt);
  if (htab->stub_group == NULL)
    return -1;

  /* Set toc_off for com, und, abs and ind sections.  */
  for (id = 0; id < 3; id++)
    htab->stub_group[id].toc_off = TOC_BASE_OFF;

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     strip_excluded_output_sections doesn't renumber the indices.  */
  for (section = info->output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = bfd_zmalloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  return 1;
}

/* Set up for first pass at multitoc partitioning.  */

void
ppc64_elf_start_multitoc_partition (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  htab->toc_curr = ppc64_elf_set_toc (info, info->output_bfd);
  htab->toc_bfd = NULL;
  htab->toc_first_sec = NULL;
}

/* The linker repeatedly calls this function for each TOC input section
   and linker generated GOT section.  Group input bfds such that the toc
   within a group is less than 64k in size.  */

bfd_boolean
ppc64_elf_next_toc_section (struct bfd_link_info *info, asection *isec)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  bfd_vma addr, off, limit;

  if (htab == NULL)
    return FALSE;

  if (!htab->second_toc_pass)
    {
      /* Keep track of the first .toc or .got section for this input bfd.  */
      bfd_boolean new_bfd = htab->toc_bfd != isec->owner;

      if (new_bfd)
	{
	  htab->toc_bfd = isec->owner;
	  htab->toc_first_sec = isec;
	}

      addr = isec->output_offset + isec->output_section->vma;
      off = addr - htab->toc_curr;
      limit = 0x80008000;
      if (ppc64_elf_tdata (isec->owner)->has_small_toc_reloc)
	limit = 0x10000;
      if (off + isec->size > limit)
	{
	  addr = (htab->toc_first_sec->output_offset
		  + htab->toc_first_sec->output_section->vma);
	  htab->toc_curr = addr;
	}

      /* toc_curr is the base address of this toc group.  Set elf_gp
	 for the input section to be the offset relative to the
	 output toc base plus 0x8000.  Making the input elf_gp an
	 offset allows us to move the toc as a whole without
	 recalculating input elf_gp.  */
      off = htab->toc_curr - elf_gp (isec->output_section->owner);
      off += TOC_BASE_OFF;

      /* Die if someone uses a linker script that doesn't keep input
	 file .toc and .got together.  */
      if (new_bfd
	  && elf_gp (isec->owner) != 0
	  && elf_gp (isec->owner) != off)
	return FALSE;

      elf_gp (isec->owner) = off;
      return TRUE;
    }

  /* During the second pass toc_first_sec points to the start of
     a toc group, and toc_curr is used to track the old elf_gp.
     We use toc_bfd to ensure we only look at each bfd once.  */
  if (htab->toc_bfd == isec->owner)
    return TRUE;
  htab->toc_bfd = isec->owner;

  if (htab->toc_first_sec == NULL
      || htab->toc_curr != elf_gp (isec->owner))
    {
      htab->toc_curr = elf_gp (isec->owner);
      htab->toc_first_sec = isec;
    }
  addr = (htab->toc_first_sec->output_offset
	  + htab->toc_first_sec->output_section->vma);
  off = addr - elf_gp (isec->output_section->owner) + TOC_BASE_OFF;
  elf_gp (isec->owner) = off;

  return TRUE;
}

/* Called via elf_link_hash_traverse to merge GOT entries for global
   symbol H.  */

static bfd_boolean
merge_global_got (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  merge_got_entries (&h->got.glist);

  return TRUE;
}

/* Called via elf_link_hash_traverse to allocate GOT entries for global
   symbol H.  */

static bfd_boolean
reallocate_got (struct elf_link_hash_entry *h, void *inf)
{
  struct got_entry *gent;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  for (gent = h->got.glist; gent != NULL; gent = gent->next)
    if (!gent->is_indirect)
      allocate_got (h, (struct bfd_link_info *) inf, gent);
  return TRUE;
}

/* Called on the first multitoc pass after the last call to
   ppc64_elf_next_toc_section.  This function removes duplicate GOT
   entries.  */

bfd_boolean
ppc64_elf_layout_multitoc (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  struct bfd *ibfd, *ibfd2;
  bfd_boolean done_something;

  htab->multi_toc_needed = htab->toc_curr != elf_gp (info->output_bfd);

  if (!htab->do_multi_toc)
    return FALSE;

  /* Merge global sym got entries within a toc group.  */
  elf_link_hash_traverse (&htab->elf, merge_global_got, info);

  /* And tlsld_got.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry *ent, *ent2;

      if (!is_ppc64_elf (ibfd))
	continue;

      ent = ppc64_tlsld_got (ibfd);
      if (!ent->is_indirect
	  && ent->got.offset != (bfd_vma) -1)
	{
	  for (ibfd2 = ibfd->link_next; ibfd2 != NULL; ibfd2 = ibfd2->link_next)
	    {
	      if (!is_ppc64_elf (ibfd2))
		continue;

	      ent2 = ppc64_tlsld_got (ibfd2);
	      if (!ent2->is_indirect
		  && ent2->got.offset != (bfd_vma) -1
		  && elf_gp (ibfd2) == elf_gp (ibfd))
		{
		  ent2->is_indirect = TRUE;
		  ent2->got.ent = ent;
		}
	    }
	}
    }

  /* Zap sizes of got sections.  */
  htab->reliplt->rawsize = htab->reliplt->size;
  htab->reliplt->size -= htab->got_reli_size;
  htab->got_reli_size = 0;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      asection *got, *relgot;

      if (!is_ppc64_elf (ibfd))
	continue;

      got = ppc64_elf_tdata (ibfd)->got;
      if (got != NULL)
	{
	  got->rawsize = got->size;
	  got->size = 0;
	  relgot = ppc64_elf_tdata (ibfd)->relgot;
	  relgot->rawsize = relgot->size;
	  relgot->size = 0;
	}
    }

  /* Now reallocate the got, local syms first.  We don't need to
     allocate section contents again since we never increase size.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry **lgot_ents;
      struct got_entry **end_lgot_ents;
      struct plt_entry **local_plt;
      struct plt_entry **end_local_plt;
      unsigned char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *s;

      if (!is_ppc64_elf (ibfd))
	continue;

      lgot_ents = elf_local_got_ents (ibfd);
      if (!lgot_ents)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_lgot_ents = lgot_ents + locsymcount;
      local_plt = (struct plt_entry **) end_lgot_ents;
      end_local_plt = local_plt + locsymcount;
      lgot_masks = (unsigned char *) end_local_plt;
      s = ppc64_elf_tdata (ibfd)->got;
      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_masks)
	{
	  struct got_entry *ent;

	  for (ent = *lgot_ents; ent != NULL; ent = ent->next)
	    {
	      unsigned int ent_size = 8;
	      unsigned int rel_size = sizeof (Elf64_External_Rela);

	      ent->got.offset = s->size;
	      if ((ent->tls_type & *lgot_masks & TLS_GD) != 0)
		{
		  ent_size *= 2;
		  rel_size *= 2;
		}
	      s->size += ent_size;
	      if ((*lgot_masks & PLT_IFUNC) != 0)
		{
		  htab->reliplt->size += rel_size;
		  htab->got_reli_size += rel_size;
		}
	      else if (info->shared)
		{
		  asection *srel = ppc64_elf_tdata (ibfd)->relgot;
		  srel->size += rel_size;
		}
	    }
	}
    }

  elf_link_hash_traverse (&htab->elf, reallocate_got, info);

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry *ent;

      if (!is_ppc64_elf (ibfd))
	continue;

      ent = ppc64_tlsld_got (ibfd);
      if (!ent->is_indirect
	  && ent->got.offset != (bfd_vma) -1)
	{
	  asection *s = ppc64_elf_tdata (ibfd)->got;
	  ent->got.offset = s->size;
	  s->size += 16;
	  if (info->shared)
	    {
	      asection *srel = ppc64_elf_tdata (ibfd)->relgot;
	      srel->size += sizeof (Elf64_External_Rela);
	    }
	}
    }

  done_something = htab->reliplt->rawsize != htab->reliplt->size;
  if (!done_something)
    for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
      {
	asection *got;

	if (!is_ppc64_elf (ibfd))
	  continue;

	got = ppc64_elf_tdata (ibfd)->got;
	if (got != NULL)
	  {
	    done_something = got->rawsize != got->size;
	    if (done_something)
	      break;
	  }
      }

  if (done_something)
    (*htab->layout_sections_again) ();

  /* Set up for second pass over toc sections to recalculate elf_gp
     on input sections.  */
  htab->toc_bfd = NULL;
  htab->toc_first_sec = NULL;
  htab->second_toc_pass = TRUE;
  return done_something;
}

/* Called after second pass of multitoc partitioning.  */

void
ppc64_elf_finish_multitoc_partition (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  /* After the second pass, toc_curr tracks the TOC offset used
     for code sections below in ppc64_elf_next_input_section.  */
  htab->toc_curr = TOC_BASE_OFF;
}

/* No toc references were found in ISEC.  If the code in ISEC makes no
   calls, then there's no need to use toc adjusting stubs when branching
   into ISEC.  Actually, indirect calls from ISEC are OK as they will
   load r2.  Returns -1 on error, 0 for no stub needed, 1 for stub
   needed, and 2 if a cyclical call-graph was found but no other reason
   for a stub was detected.  If called from the top level, a return of
   2 means the same as a return of 0.  */

static int
toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)
{
  int ret;

  /* Mark this section as checked.  */
  isec->call_check_done = 1;

  /* We know none of our code bearing sections will need toc stubs.  */
  if ((isec->flags & SEC_LINKER_CREATED) != 0)
    return 0;

  if (isec->size == 0)
    return 0;

  if (isec->output_section == NULL)
    return 0;

  ret = 0;
  if (isec->reloc_count != 0)
    {
      Elf_Internal_Rela *relstart, *rel;
      Elf_Internal_Sym *local_syms;
      struct ppc_link_hash_table *htab;

      relstart = _bfd_elf_link_read_relocs (isec->owner, isec, NULL, NULL,
					    info->keep_memory);
      if (relstart == NULL)
	return -1;

      /* Look for branches to outside of this section.  */
      local_syms = NULL;
      htab = ppc_hash_table (info);
      if (htab == NULL)
	return -1;

      for (rel = relstart; rel < relstart + isec->reloc_count; ++rel)
	{
	  enum elf_ppc64_reloc_type r_type;
	  unsigned long r_symndx;
	  struct elf_link_hash_entry *h;
	  struct ppc_link_hash_entry *eh;
	  Elf_Internal_Sym *sym;
	  asection *sym_sec;
	  struct _opd_sec_data *opd;
	  bfd_vma sym_value;
	  bfd_vma dest;

	  r_type = ELF64_R_TYPE (rel->r_info);
	  if (r_type != R_PPC64_REL24
	      && r_type != R_PPC64_REL14
	      && r_type != R_PPC64_REL14_BRTAKEN
	      && r_type != R_PPC64_REL14_BRNTAKEN)
	    continue;

	  r_symndx = ELF64_R_SYM (rel->r_info);
	  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms, r_symndx,
			  isec->owner))
	    {
	      ret = -1;
	      break;
	    }

	  /* Calls to dynamic lib functions go through a plt call stub
	     that uses r2.  */
	  eh = (struct ppc_link_hash_entry *) h;
	  if (eh != NULL
	      && (eh->elf.plt.plist != NULL
		  || (eh->oh != NULL
		      && ppc_follow_link (eh->oh)->elf.plt.plist != NULL)))
	    {
	      ret = 1;
	      break;
	    }

	  if (sym_sec == NULL)
	    /* Ignore other undefined symbols.  */
	    continue;

	  /* Assume branches to other sections not included in the
	     link need stubs too, to cover -R and absolute syms.  */
	  if (sym_sec->output_section == NULL)
	    {
	      ret = 1;
	      break;
	    }

	  if (h == NULL)
	    sym_value = sym->st_value;
	  else
	    {
	      if (h->root.type != bfd_link_hash_defined
		  && h->root.type != bfd_link_hash_defweak)
		abort ();
	      sym_value = h->root.u.def.value;
	    }
	  sym_value += rel->r_addend;

	  /* If this branch reloc uses an opd sym, find the code section.  */
	  opd = get_opd_info (sym_sec);
	  if (opd != NULL)
	    {
	      if (h == NULL && opd->adjust != NULL)
		{
		  long adjust;

		  adjust = opd->adjust[sym->st_value / 8];
		  if (adjust == -1)
		    /* Assume deleted functions won't ever be called.  */
		    continue;
		  sym_value += adjust;
		}

	      dest = opd_entry_value (sym_sec, sym_value,
				      &sym_sec, NULL, FALSE);
	      if (dest == (bfd_vma) -1)
		continue;
	    }
	  else
	    dest = (sym_value
		    + sym_sec->output_offset
		    + sym_sec->output_section->vma);

	  /* Ignore branch to self.  */
	  if (sym_sec == isec)
	    continue;

	  /* If the called function uses the toc, we need a stub.  */
	  if (sym_sec->has_toc_reloc
	      || sym_sec->makes_toc_func_call)
	    {
	      ret = 1;
	      break;
	    }

	  /* Assume any branch that needs a long branch stub might in fact
	     need a plt_branch stub.  A plt_branch stub uses r2.  */
	  else if (dest - (isec->output_offset
			   + isec->output_section->vma
			   + rel->r_offset) + (1 << 25) >= (2 << 25))
	    {
	      ret = 1;
	      break;
	    }

	  /* If calling back to a section in the process of being
	     tested, we can't say for sure that no toc adjusting stubs
	     are needed, so don't return zero.  */
	  else if (sym_sec->call_check_in_progress)
	    ret = 2;

	  /* Branches to another section that itself doesn't have any TOC
	     references are OK.  Recursively call ourselves to check.  */
	  else if (!sym_sec->call_check_done)
	    {
	      int recur;

	      /* Mark current section as indeterminate, so that other
		 sections that call back to current won't be marked as
		 known.  */
	      isec->call_check_in_progress = 1;
	      recur = toc_adjusting_stub_needed (info, sym_sec);
	      isec->call_check_in_progress = 0;

	      if (recur != 0)
		{
		  ret = recur;
		  if (recur != 2)
		    break;
		}
	    }
	}

      if (local_syms != NULL
	  && (elf_symtab_hdr (isec->owner).contents
	      != (unsigned char *) local_syms))
	free (local_syms);
      if (elf_section_data (isec)->relocs != relstart)
	free (relstart);
    }

  if ((ret & 1) == 0
      && isec->map_head.s != NULL
      && (strcmp (isec->output_section->name, ".init") == 0
	  || strcmp (isec->output_section->name, ".fini") == 0))
    {
      if (isec->map_head.s->has_toc_reloc
	  || isec->map_head.s->makes_toc_func_call)
	ret = 1;
      else if (!isec->map_head.s->call_check_done)
	{
	  int recur;
	  isec->call_check_in_progress = 1;
	  recur = toc_adjusting_stub_needed (info, isec->map_head.s);
	  isec->call_check_in_progress = 0;
	  if (recur != 0)
	    ret = recur;
	}
    }

  if (ret == 1)
    isec->makes_toc_func_call = 1;

  return ret;
}

/* The linker repeatedly calls this function for each input section,
   in the order that input sections are linked into output sections.
   Build lists of input sections to determine groupings between which
   we may insert linker stubs.  */

bfd_boolean
ppc64_elf_next_input_section (struct bfd_link_info *info, asection *isec)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (htab == NULL)
    return FALSE;

  if ((isec->output_section->flags & SEC_CODE) != 0
      && isec->output_section->index <= htab->top_index)
    {
      asection **list = htab->input_list + isec->output_section->index;
      /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
      /* This happens to make the list in reverse order,
	 which is what we want.  */
      PREV_SEC (isec) = *list;
      *list = isec;
    }

  if (htab->multi_toc_needed)
    {
      /* If a code section has a function that uses the TOC then we need
	 to use the right TOC (obviously).  Also, make sure that .opd gets
	 the correct TOC value for R_PPC64_TOC relocs that don't have or
	 can't find their function symbol (shouldn't ever happen now).
	 Also specially treat .fixup for the linux kernel.  .fixup
	 contains branches, but only back to the function that hit an
	 exception.  */
      if (isec->has_toc_reloc
	  || (isec->flags & SEC_CODE) == 0
	  || strcmp (isec->name, ".fixup") == 0)
	{
	  if (elf_gp (isec->owner) != 0)
	    htab->toc_curr = elf_gp (isec->owner);
	}
      else
	{
	  if (!isec->call_check_done
	      && toc_adjusting_stub_needed (info, isec) < 0)
	    return FALSE;
	  /* If we make a local call from this section, ie. a branch
	     without a following nop, then we have no place to put a
	     toc restoring insn.  We must use the same toc group as
	     the callee.
	     Testing makes_toc_func_call actually tests for *any*
	     calls to functions that need a good toc pointer.  A more
	     precise test would be better, as this one will set
	     incorrect values for pasted .init/.fini fragments.
	     (Fixed later in check_pasted_section.)  */
	  if (isec->makes_toc_func_call
	      && elf_gp (isec->owner) != 0)
	    htab->toc_curr = elf_gp (isec->owner);
	}
    }

  /* Functions that don't use the TOC can belong in any TOC group.
     Use the last TOC base.  */
  htab->stub_group[isec->id].toc_off = htab->toc_curr;
  return TRUE;
}

/* Check that all .init and .fini sections use the same toc, if they
   have toc relocs.  */

static bfd_boolean
check_pasted_section (struct bfd_link_info *info, const char *name)
{
  asection *o = bfd_get_section_by_name (info->output_bfd, name);

  if (o != NULL)
    {
      struct ppc_link_hash_table *htab = ppc_hash_table (info);
      bfd_vma toc_off = 0;
      asection *i;

      for (i = o->map_head.s; i != NULL; i = i->map_head.s)
	if (i->has_toc_reloc)
	  {
	    if (toc_off == 0)
	      toc_off = htab->stub_group[i->id].toc_off;
	    else if (toc_off != htab->stub_group[i->id].toc_off)
	      return FALSE;
	  }

      if (toc_off == 0)
	for (i = o->map_head.s; i != NULL; i = i->map_head.s)
	  if (i->makes_toc_func_call)
	    {
	      toc_off = htab->stub_group[i->id].toc_off;
	      break;
	    }

      /* Make sure the whole pasted function uses the same toc offset.  */
      if (toc_off != 0)
	for (i = o->map_head.s; i != NULL; i = i->map_head.s)
	  htab->stub_group[i->id].toc_off = toc_off;
    }
  return TRUE;
}

bfd_boolean
ppc64_elf_check_init_fini (struct bfd_link_info *info)
{
  return (check_pasted_section (info, ".init")
	  & check_pasted_section (info, ".fini"));
}

/* See whether we can group stub sections together.  Grouping stub
   sections may result in fewer stubs.  More importantly, we need to
   put all .init* and .fini* stubs at the beginning of the .init or
   .fini output sections respectively, because glibc splits the
   _init and _fini functions into multiple parts.  Putting a stub in
   the middle of a function is not a good idea.  */

static void
group_sections (struct ppc_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
{
  asection **list;
  bfd_size_type stub14_group_size;
  bfd_boolean suppress_size_errors;

  suppress_size_errors = FALSE;
  stub14_group_size = stub_group_size;
  if (stub_group_size == 1)
    {
      /* Default values.  */
      if (stubs_always_before_branch)
	{
	  stub_group_size = 0x1e00000;
	  stub14_group_size = 0x7800;
	}
      else
	{
	  stub_group_size = 0x1c00000;
	  stub14_group_size = 0x7000;
	}
      suppress_size_errors = TRUE;
    }

  list = htab->input_list + htab->top_index;
  do
    {
      asection *tail = *list;
      while (tail != NULL)
	{
	  asection *curr;
	  asection *prev;
	  bfd_size_type total;
	  bfd_boolean big_sec;
	  bfd_vma curr_toc;

	  curr = tail;
	  total = tail->size;
	  big_sec = total > (ppc64_elf_section_data (tail) != NULL
			     && ppc64_elf_section_data (tail)->has_14bit_branch
			     ? stub14_group_size : stub_group_size);
	  if (big_sec && !suppress_size_errors)
	    (*_bfd_error_handler) (_("%B section %A exceeds stub group size"),
				     tail->owner, tail);
	  curr_toc = htab->stub_group[tail->id].toc_off;

	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
		     < (ppc64_elf_section_data (prev) != NULL
			&& ppc64_elf_section_data (prev)->has_14bit_branch
			? stub14_group_size : stub_group_size))
		 && htab->stub_group[prev->id].toc_off == curr_toc)
	    curr = prev;

	  /* OK, the size from the start of CURR to the end is less
	     than stub_group_size and thus can be handled by one stub
	     section.  (or the tail section is itself larger than
	     stub_group_size, in which case we may be toast.)  We
	     should really be keeping track of the total size of stubs
	     added here, as stubs contribute to the final output
	     section size.  That's a little tricky, and this way will
	     only break if stubs added make the total size more than
	     2^25, ie. for the default stub_group_size, if stubs total
	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
	  do
	    {
	      prev = PREV_SEC (tail);
	      /* Set up this stub group.  */
	      htab->stub_group[tail->id].link_sec = curr;
	    }
	  while (tail != curr && (tail = prev) != NULL);

	  /* But wait, there's more!  Input sections up to stub_group_size
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
	    {
	      total = 0;
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
			 < (ppc64_elf_section_data (prev) != NULL
			    && ppc64_elf_section_data (prev)->has_14bit_branch
			    ? stub14_group_size : stub_group_size))
		     && htab->stub_group[prev->id].toc_off == curr_toc)
		{
		  tail = prev;
		  prev = PREV_SEC (tail);
		  htab->stub_group[tail->id].link_sec = curr;
		}
	    }
	  tail = prev;
	}
    }
  while (list-- != htab->input_list);
  free (htab->input_list);
#undef PREV_SEC
}

static const unsigned char glink_eh_frame_cie[] =
{
  0, 0, 0, 16,				/* length.  */
  0, 0, 0, 0,				/* id.  */
  1,					/* CIE version.  */
  'z', 'R', 0,				/* Augmentation string.  */
  4,					/* Code alignment.  */
  0x78,					/* Data alignment.  */
  65,					/* RA reg.  */
  1,					/* Augmentation size.  */
  DW_EH_PE_pcrel | DW_EH_PE_sdata4,	/* FDE encoding.  */
  DW_CFA_def_cfa, 1, 0			/* def_cfa: r1 offset 0.  */
};

/* Stripping output sections is normally done before dynamic section
   symbols have been allocated.  This function is called later, and
   handles cases like htab->brlt which is mapped to its own output
   section.  */

static void
maybe_strip_output (struct bfd_link_info *info, asection *isec)
{
  if (isec->size == 0
      && isec->output_section->size == 0
      && !(isec->output_section->flags & SEC_KEEP)
      && !bfd_section_removed_from_list (info->output_bfd,
					 isec->output_section)
      && elf_section_data (isec->output_section)->dynindx == 0)
    {
      isec->output_section->flags |= SEC_EXCLUDE;
      bfd_section_list_remove (info->output_bfd, isec->output_section);
      info->output_bfd->section_count--;
    }
}

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

bfd_boolean
ppc64_elf_size_stubs (struct bfd_link_info *info, bfd_signed_vma group_size,
		      bfd_boolean plt_static_chain, int plt_thread_safe,
		      int plt_stub_align)
{
  bfd_size_type stub_group_size;
  bfd_boolean stubs_always_before_branch;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (htab == NULL)
    return FALSE;

  htab->plt_static_chain = plt_static_chain;
  htab->plt_stub_align = plt_stub_align;
  if (plt_thread_safe == -1 && !info->executable)
    plt_thread_safe = 1;
  if (plt_thread_safe == -1)
    {
      static const char *const thread_starter[] =
	{
	  "pthread_create",
	  /* libstdc++ */
	  "_ZNSt6thread15_M_start_threadESt10shared_ptrINS_10_Impl_baseEE",
	  /* librt */
	  "aio_init", "aio_read", "aio_write", "aio_fsync", "lio_listio",
	  "mq_notify", "create_timer",
	  /* libanl */
	  "getaddrinfo_a",
	  /* libgomp */
	  "GOMP_parallel_start",
	  "GOMP_parallel_loop_static_start",
	  "GOMP_parallel_loop_dynamic_start",
	  "GOMP_parallel_loop_guided_start",
	  "GOMP_parallel_loop_runtime_start",
	  "GOMP_parallel_sections_start",
	};
      unsigned i;

      for (i = 0; i < sizeof (thread_starter)/ sizeof (thread_starter[0]); i++)
	{
	  struct elf_link_hash_entry *h;
	  h = elf_link_hash_lookup (&htab->elf, thread_starter[i],
				    FALSE, FALSE, TRUE);
	  plt_thread_safe = h != NULL && h->ref_regular;
	  if (plt_thread_safe)
	    break;
	}
    }
  htab->plt_thread_safe = plt_thread_safe;
  stubs_always_before_branch = group_size < 0;
  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;

  group_sections (htab, stub_group_size, stubs_always_before_branch);

  while (1)
    {
      bfd *input_bfd;
      unsigned int bfd_indx;
      asection *stub_sec;

      htab->stub_iteration += 1;

      for (input_bfd = info->input_bfds, bfd_indx = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, bfd_indx++)
	{
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *section;
	  Elf_Internal_Sym *local_syms = NULL;

	  if (!is_ppc64_elf (input_bfd))
	    continue;

	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_symtab_hdr (input_bfd);
	  if (symtab_hdr->sh_info == 0)
	    continue;

	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next)
	    {
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	      /* If there aren't any relocs, then there's nothing more
		 to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || (section->flags & SEC_ALLOC) == 0
		  || (section->flags & SEC_LOAD) == 0
		  || (section->flags & SEC_CODE) == 0
		  || section->reloc_count == 0)
		continue;

	      /* If this section is a link-once section that will be
		 discarded, then don't create any stubs.  */
	      if (section->output_section == NULL
		  || section->output_section->owner != info->output_bfd)
		continue;

	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
	      if (internal_relocs == NULL)
		goto error_ret_free_local;

	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  enum elf_ppc64_reloc_type r_type;
		  unsigned int r_indx;
		  enum ppc_stub_type stub_type;
		  struct ppc_stub_hash_entry *stub_entry;
		  asection *sym_sec, *code_sec;
		  bfd_vma sym_value, code_value;
		  bfd_vma destination;
		  bfd_boolean ok_dest;
		  struct ppc_link_hash_entry *hash;
		  struct ppc_link_hash_entry *fdh;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
		  char *stub_name;
		  const asection *id_sec;
		  struct _opd_sec_data *opd;
		  struct plt_entry *plt_ent;

		  r_type = ELF64_R_TYPE (irela->r_info);
		  r_indx = ELF64_R_SYM (irela->r_info);

		  if (r_type >= R_PPC64_max)
		    {
		      bfd_set_error (bfd_error_bad_value);
		      goto error_ret_free_internal;
		    }

		  /* Only look for stubs on branch instructions.  */
		  if (r_type != R_PPC64_REL24
		      && r_type != R_PPC64_REL14
		      && r_type != R_PPC64_REL14_BRTAKEN
		      && r_type != R_PPC64_REL14_BRNTAKEN)
		    continue;

		  /* Now determine the call target, its name, value,
		     section.  */
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_indx, input_bfd))
		    goto error_ret_free_internal;
		  hash = (struct ppc_link_hash_entry *) h;

		  ok_dest = FALSE;
		  fdh = NULL;
		  sym_value = 0;
		  if (hash == NULL)
		    {
		      sym_value = sym->st_value;
		      ok_dest = TRUE;
		    }
		  else if (hash->elf.root.type == bfd_link_hash_defined
			   || hash->elf.root.type == bfd_link_hash_defweak)
		    {
		      sym_value = hash->elf.root.u.def.value;
		      if (sym_sec->output_section != NULL)
			ok_dest = TRUE;
		    }
		  else if (hash->elf.root.type == bfd_link_hash_undefweak
			   || hash->elf.root.type == bfd_link_hash_undefined)
		    {
		      /* Recognise an old ABI func code entry sym, and
			 use the func descriptor sym instead if it is
			 defined.  */
		      if (hash->elf.root.root.string[0] == '.'
			  && (fdh = lookup_fdh (hash, htab)) != NULL)
			{
			  if (fdh->elf.root.type == bfd_link_hash_defined
			      || fdh->elf.root.type == bfd_link_hash_defweak)
			    {
			      sym_sec = fdh->elf.root.u.def.section;
			      sym_value = fdh->elf.root.u.def.value;
			      if (sym_sec->output_section != NULL)
				ok_dest = TRUE;
			    }
			  else
			    fdh = NULL;
			}
		    }
		  else
		    {
		      bfd_set_error (bfd_error_bad_value);
		      goto error_ret_free_internal;
		    }

		  destination = 0;
		  if (ok_dest)
		    {
		      sym_value += irela->r_addend;
		      destination = (sym_value
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		    }

		  code_sec = sym_sec;
		  code_value = sym_value;
		  opd = get_opd_info (sym_sec);
		  if (opd != NULL)
		    {
		      bfd_vma dest;

		      if (hash == NULL && opd->adjust != NULL)
			{
			  long adjust = opd->adjust[sym_value / 8];
			  if (adjust == -1)
			    continue;
			  code_value += adjust;
			  sym_value += adjust;
			}
		      dest = opd_entry_value (sym_sec, sym_value,
					      &code_sec, &code_value, FALSE);
		      if (dest != (bfd_vma) -1)
			{
			  destination = dest;
			  if (fdh != NULL)
			    {
			      /* Fixup old ABI sym to point at code
				 entry.  */
			      hash->elf.root.type = bfd_link_hash_defweak;
			      hash->elf.root.u.def.section = code_sec;
			      hash->elf.root.u.def.value = code_value;
			    }
			}
		    }

		  /* Determine what (if any) linker stub is needed.  */
		  plt_ent = NULL;
		  stub_type = ppc_type_of_stub (section, irela, &hash,
						&plt_ent, destination);

		  if (stub_type != ppc_stub_plt_call)
		    {
		      /* Check whether we need a TOC adjusting stub.
			 Since the linker pastes together pieces from
			 different object files when creating the
			 _init and _fini functions, it may be that a
			 call to what looks like a local sym is in
			 fact a call needing a TOC adjustment.  */
		      if (code_sec != NULL
			  && code_sec->output_section != NULL
			  && (htab->stub_group[code_sec->id].toc_off
			      != htab->stub_group[section->id].toc_off)
			  && (code_sec->has_toc_reloc
			      || code_sec->makes_toc_func_call))
			stub_type = ppc_stub_long_branch_r2off;
		    }

		  if (stub_type == ppc_stub_none)
		    continue;

		  /* __tls_get_addr calls might be eliminated.  */
		  if (stub_type != ppc_stub_plt_call
		      && hash != NULL
		      && (hash == htab->tls_get_addr
			  || hash == htab->tls_get_addr_fd)
		      && section->has_tls_reloc
		      && irela != internal_relocs)
		    {
		      /* Get tls info.  */
		      unsigned char *tls_mask;

		      if (!get_tls_mask (&tls_mask, NULL, NULL, &local_syms,
					 irela - 1, input_bfd))
			goto error_ret_free_internal;
		      if (*tls_mask != 0)
			continue;
		    }

		  if (stub_type == ppc_stub_plt_call
		      && irela + 1 < irelaend
		      && irela[1].r_offset == irela->r_offset + 4
		      && ELF64_R_TYPE (irela[1].r_info) == R_PPC64_TOCSAVE)
		    {
		      if (!tocsave_find (htab, INSERT,
					 &local_syms, irela + 1, input_bfd))
			goto error_ret_free_internal;
		    }
		  else if (stub_type == ppc_stub_plt_call)
		    stub_type = ppc_stub_plt_call_r2save;

		  /* Support for grouping stub sections.  */
		  id_sec = htab->stub_group[section->id].link_sec;

		  /* Get the name of this stub.  */
		  stub_name = ppc_stub_name (id_sec, sym_sec, hash, irela);
		  if (!stub_name)
		    goto error_ret_free_internal;

		  stub_entry = ppc_stub_hash_lookup (&htab->stub_hash_table,
						     stub_name, FALSE, FALSE);
		  if (stub_entry != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      if (stub_type == ppc_stub_plt_call_r2save)
			stub_entry->stub_type = stub_type;
		      continue;
		    }

		  stub_entry = ppc_add_stub (stub_name, section, info);
		  if (stub_entry == NULL)
		    {
		      free (stub_name);
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		    error_ret_free_local:
		      if (local_syms != NULL
			  && (symtab_hdr->contents
			      != (unsigned char *) local_syms))
			free (local_syms);
		      return FALSE;
		    }

		  stub_entry->stub_type = stub_type;
		  if (stub_type != ppc_stub_plt_call
		      && stub_type != ppc_stub_plt_call_r2save)
		    {
		      stub_entry->target_value = code_value;
		      stub_entry->target_section = code_sec;
		    }
		  else
		    {
		      stub_entry->target_value = sym_value;
		      stub_entry->target_section = sym_sec;
		    }
		  stub_entry->h = hash;
		  stub_entry->plt_ent = plt_ent;

		  if (stub_entry->h != NULL)
		    htab->stub_globals += 1;
		}

	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs != internal_relocs)
		free (internal_relocs);
	    }

	  if (local_syms != NULL
	      && symtab_hdr->contents != (unsigned char *) local_syms)
	    {
	      if (!info->keep_memory)
		free (local_syms);
	      else
		symtab_hdr->contents = (unsigned char *) local_syms;
	    }
	}

      /* We may have added some stubs.  Find out the new size of the
	 stub sections.  */
      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	  {
	    stub_sec->rawsize = stub_sec->size;
	    stub_sec->size = 0;
	    stub_sec->reloc_count = 0;
	    stub_sec->flags &= ~SEC_RELOC;
	  }

      htab->brlt->size = 0;
      htab->brlt->reloc_count = 0;
      htab->brlt->flags &= ~SEC_RELOC;
      if (htab->relbrlt != NULL)
	htab->relbrlt->size = 0;

      bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, info);

      if (info->emitrelocations
	  && htab->glink != NULL && htab->glink->size != 0)
	{
	  htab->glink->reloc_count = 1;
	  htab->glink->flags |= SEC_RELOC;
	}

      if (htab->glink_eh_frame != NULL
	  && !bfd_is_abs_section (htab->glink_eh_frame->output_section)
	  && htab->glink_eh_frame->output_section->size != 0)
	{
	  size_t size = 0, align;

	  for (stub_sec = htab->stub_bfd->sections;
	       stub_sec != NULL;
	       stub_sec = stub_sec->next)
	    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	      size += 20;
	  if (htab->glink != NULL && htab->glink->size != 0)
	    size += 24;
	  if (size != 0)
	    size += sizeof (glink_eh_frame_cie);
	  align = 1;
	  align <<= htab->glink_eh_frame->output_section->alignment_power;
	  align -= 1;
	  size = (size + align) & ~align;
	  htab->glink_eh_frame->rawsize = htab->glink_eh_frame->size;
	  htab->glink_eh_frame->size = size;
	}

      if (htab->plt_stub_align != 0)
	for (stub_sec = htab->stub_bfd->sections;
	     stub_sec != NULL;
	     stub_sec = stub_sec->next)
	  if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	    stub_sec->size = ((stub_sec->size + (1 << htab->plt_stub_align) - 1)
			      & (-1 << htab->plt_stub_align));

      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	if ((stub_sec->flags & SEC_LINKER_CREATED) == 0
	    && stub_sec->rawsize != stub_sec->size)
	  break;

      /* Exit from this loop when no stubs have been added, and no stubs
	 have changed size.  */
      if (stub_sec == NULL
	  && (htab->glink_eh_frame == NULL
	      || htab->glink_eh_frame->rawsize == htab->glink_eh_frame->size))
	break;

      /* Ask the linker to do its stuff.  */
      (*htab->layout_sections_again) ();
    }

  maybe_strip_output (info, htab->brlt);
  if (htab->glink_eh_frame != NULL)
    maybe_strip_output (info, htab->glink_eh_frame);

  return TRUE;
}

/* Called after we have determined section placement.  If sections
   move, we'll be called again.  Provide a value for TOCstart.  */

bfd_vma
ppc64_elf_set_toc (struct bfd_link_info *info, bfd *obfd)
{
  asection *s;
  bfd_vma TOCstart;

  /* The TOC consists of sections .got, .toc, .tocbss, .plt in that
     order.  The TOC starts where the first of these sections starts.  */
  s = bfd_get_section_by_name (obfd, ".got");
  if (s == NULL || (s->flags & SEC_EXCLUDE) != 0)
    s = bfd_get_section_by_name (obfd, ".toc");
  if (s == NULL || (s->flags & SEC_EXCLUDE) != 0)
    s = bfd_get_section_by_name (obfd, ".tocbss");
  if (s == NULL || (s->flags & SEC_EXCLUDE) != 0)
    s = bfd_get_section_by_name (obfd, ".plt");
  if (s == NULL || (s->flags & SEC_EXCLUDE) != 0)
    {
      /* This may happen for
	 o  references to TOC base (SYM@@toc / TOC[tc0]) without a
	 .toc directive
	 o  bad linker script
	 o --gc-sections and empty TOC sections

	 FIXME: Warn user?  */

      /* Look for a likely section.  We probably won't even be
	 using TOCstart.  */
      for (s = obfd->sections; s != NULL; s = s->next)
	if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_READONLY
			 | SEC_EXCLUDE))
	    == (SEC_ALLOC | SEC_SMALL_DATA))
	  break;
      if (s == NULL)
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_EXCLUDE))
	      == (SEC_ALLOC | SEC_SMALL_DATA))
	    break;
      if (s == NULL)
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & (SEC_ALLOC | SEC_READONLY | SEC_EXCLUDE))
	      == SEC_ALLOC)
	    break;
      if (s == NULL)
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & (SEC_ALLOC | SEC_EXCLUDE)) == SEC_ALLOC)
	    break;
    }

  TOCstart = 0;
  if (s != NULL)
    TOCstart = s->output_section->vma + s->output_offset;

  _bfd_set_gp_value (obfd, TOCstart);

  if (info != NULL && s != NULL && is_ppc64_elf (obfd))
    {
      struct ppc_link_hash_table *htab = ppc_hash_table (info);

      if (htab != NULL
	  && htab->elf.hgot != NULL)
	{
	  htab->elf.hgot->type = STT_OBJECT;
	  htab->elf.hgot->root.type = bfd_link_hash_defined;
	  htab->elf.hgot->root.u.def.value = TOC_BASE_OFF;
	  htab->elf.hgot->root.u.def.section = s;
	}
    }
  return TOCstart;
}

/* Build all the stubs associated with the current output file.
   The stubs are kept in a hash table attached to the main linker
   hash table.  This function is called via gldelf64ppc_finish.  */

bfd_boolean
ppc64_elf_build_stubs (bfd_boolean emit_stub_syms,
		       struct bfd_link_info *info,
		       char **stats)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  asection *stub_sec;
  bfd_byte *p;
  int stub_sec_count = 0;

  if (htab == NULL)
    return FALSE;

  htab->emit_stub_syms = emit_stub_syms;

  /* Allocate memory to hold the linker stubs.  */
  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0
	&& stub_sec->size != 0)
      {
	stub_sec->contents = bfd_zalloc (htab->stub_bfd, stub_sec->size);
	if (stub_sec->contents == NULL)
	  return FALSE;
	/* We want to check that built size is the same as calculated
	   size.  rawsize is a convenient location to use.  */
	stub_sec->rawsize = stub_sec->size;
	stub_sec->size = 0;
      }

  if (htab->glink != NULL && htab->glink->size != 0)
    {
      unsigned int indx;
      bfd_vma plt0;

      /* Build the .glink plt call stub.  */
      if (htab->emit_stub_syms)
	{
	  struct elf_link_hash_entry *h;
	  h = elf_link_hash_lookup (&htab->elf, "__glink_PLTresolve",
				    TRUE, FALSE, FALSE);
	  if (h == NULL)
	    return FALSE;
	  if (h->root.type == bfd_link_hash_new)
	    {
	      h->root.type = bfd_link_hash_defined;
	      h->root.u.def.section = htab->glink;
	      h->root.u.def.value = 8;
	      h->ref_regular = 1;
	      h->def_regular = 1;
	      h->ref_regular_nonweak = 1;
	      h->forced_local = 1;
	      h->non_elf = 0;
	    }
	}
      plt0 = htab->plt->output_section->vma + htab->plt->output_offset - 16;
      if (info->emitrelocations)
	{
	  Elf_Internal_Rela *r = get_relocs (htab->glink, 1);
	  if (r == NULL)
	    return FALSE;
	  r->r_offset = (htab->glink->output_offset
			 + htab->glink->output_section->vma);
	  r->r_info = ELF64_R_INFO (0, R_PPC64_REL64);
	  r->r_addend = plt0;
	}
      p = htab->glink->contents;
      plt0 -= htab->glink->output_section->vma + htab->glink->output_offset;
      bfd_put_64 (htab->glink->owner, plt0, p);
      p += 8;
      bfd_put_32 (htab->glink->owner, MFLR_R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, BCL_20_31, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, MFLR_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R2_M16R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, MTLR_R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADD_R12_R2_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R2_0R12 | 8, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, MTCTR_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | 16, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, BCTR, p);
      p += 4;
      while (p - htab->glink->contents < GLINK_CALL_STUB_SIZE)
	{
	  bfd_put_32 (htab->glink->owner, NOP, p);
	  p += 4;
	}

      /* Build the .glink lazy link call stubs.  */
      indx = 0;
      while (p < htab->glink->contents + htab->glink->size)
	{
	  if (indx < 0x8000)
	    {
	      bfd_put_32 (htab->glink->owner, LI_R0_0 | indx, p);
	      p += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->glink->owner, LIS_R0_0 | PPC_HI (indx), p);
	      p += 4;
	      bfd_put_32 (htab->glink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
	      p += 4;
	    }
	  bfd_put_32 (htab->glink->owner,
		      B_DOT | ((htab->glink->contents - p + 8) & 0x3fffffc), p);
	  indx++;
	  p += 4;
	}
      htab->glink->rawsize = p - htab->glink->contents;
    }

  if (htab->brlt->size != 0)
    {
      htab->brlt->contents = bfd_zalloc (htab->brlt->owner,
					 htab->brlt->size);
      if (htab->brlt->contents == NULL)
	return FALSE;
    }
  if (htab->relbrlt != NULL && htab->relbrlt->size != 0)
    {
      htab->relbrlt->contents = bfd_zalloc (htab->relbrlt->owner,
					    htab->relbrlt->size);
      if (htab->relbrlt->contents == NULL)
	return FALSE;
    }

  if (htab->glink_eh_frame != NULL
      && htab->glink_eh_frame->size != 0)
    {
      bfd_vma val;
      bfd_byte *last_fde;
      size_t last_fde_len, size, align, pad;

      p = bfd_zalloc (htab->glink_eh_frame->owner, htab->glink_eh_frame->size);
      if (p == NULL)
	return FALSE;
      htab->glink_eh_frame->contents = p;
      last_fde = p;

      htab->glink_eh_frame->rawsize = htab->glink_eh_frame->size;

      memcpy (p, glink_eh_frame_cie, sizeof (glink_eh_frame_cie));
      /* CIE length (rewrite in case little-endian).  */
      last_fde_len = sizeof (glink_eh_frame_cie) - 4;
      bfd_put_32 (htab->elf.dynobj, last_fde_len, p);
      p += sizeof (glink_eh_frame_cie);

      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	  {
	    last_fde = p;
	    last_fde_len = 16;
	    /* FDE length.  */
	    bfd_put_32 (htab->elf.dynobj, 16, p);
	    p += 4;
	    /* CIE pointer.  */
	    val = p - htab->glink_eh_frame->contents;
	    bfd_put_32 (htab->elf.dynobj, val, p);
	    p += 4;
	    /* Offset to stub section.  */
	    val = (stub_sec->output_section->vma
		   + stub_sec->output_offset);
	    val -= (htab->glink_eh_frame->output_section->vma
		    + htab->glink_eh_frame->output_offset);
	    val -= p - htab->glink_eh_frame->contents;
	    if (val + 0x80000000 > 0xffffffff)
	      {
		info->callbacks->einfo
		  (_("%P: %s offset too large for .eh_frame sdata4 encoding"),
		   stub_sec->name);
		return FALSE;
	      }
	    bfd_put_32 (htab->elf.dynobj, val, p);
	    p += 4;
	    /* stub section size.  */
	    bfd_put_32 (htab->elf.dynobj, stub_sec->rawsize, p);
	    p += 4;
	    /* Augmentation.  */
	    p += 1;
	    /* Pad.  */
	    p += 3;
	  }
      if (htab->glink != NULL && htab->glink->size != 0)
	{
	  last_fde = p;
	  last_fde_len = 20;
	  /* FDE length.  */
	  bfd_put_32 (htab->elf.dynobj, 20, p);
	  p += 4;
	  /* CIE pointer.  */
	  val = p - htab->glink_eh_frame->contents;
	  bfd_put_32 (htab->elf.dynobj, val, p);
	  p += 4;
	  /* Offset to .glink.  */
	  val = (htab->glink->output_section->vma
		 + htab->glink->output_offset
		 + 8);
	  val -= (htab->glink_eh_frame->output_section->vma
		  + htab->glink_eh_frame->output_offset);
	  val -= p - htab->glink_eh_frame->contents;
	  if (val + 0x80000000 > 0xffffffff)
	    {
	      info->callbacks->einfo
		(_("%P: %s offset too large for .eh_frame sdata4 encoding"),
		 htab->glink->name);
	      return FALSE;
	    }
	  bfd_put_32 (htab->elf.dynobj, val, p);
	  p += 4;
	  /* .glink size.  */
	  bfd_put_32 (htab->elf.dynobj, htab->glink->rawsize - 8, p);
	  p += 4;
	  /* Augmentation.  */
	  p += 1;

	  *p++ = DW_CFA_advance_loc + 1;
	  *p++ = DW_CFA_register;
	  *p++ = 65;
	  *p++ = 12;
	  *p++ = DW_CFA_advance_loc + 4;
	  *p++ = DW_CFA_restore_extended;
	  *p++ = 65;
	}
      /* Subsume any padding into the last FDE if user .eh_frame
	 sections are aligned more than glink_eh_frame.  Otherwise any
	 zero padding will be seen as a terminator.  */
      size = p - htab->glink_eh_frame->contents;
      align = 1;
      align <<= htab->glink_eh_frame->output_section->alignment_power;
      align -= 1;
      pad = ((size + align) & ~align) - size;
      htab->glink_eh_frame->size = size + pad;
      bfd_put_32 (htab->elf.dynobj, last_fde_len + pad, last_fde);
    }

  /* Build the stubs as directed by the stub hash table.  */
  bfd_hash_traverse (&htab->stub_hash_table, ppc_build_one_stub, info);

  if (htab->relbrlt != NULL)
    htab->relbrlt->reloc_count = 0;

  if (htab->plt_stub_align != 0)
    for (stub_sec = htab->stub_bfd->sections;
	 stub_sec != NULL;
	 stub_sec = stub_sec->next)
      if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	stub_sec->size = ((stub_sec->size + (1 << htab->plt_stub_align) - 1)
			  & (-1 << htab->plt_stub_align));

  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
      {
	stub_sec_count += 1;
	if (stub_sec->rawsize != stub_sec->size)
	  break;
      }

  if (stub_sec != NULL
      || htab->glink->rawsize != htab->glink->size
      || (htab->glink_eh_frame != NULL
	  && htab->glink_eh_frame->rawsize != htab->glink_eh_frame->size))
    {
      htab->stub_error = TRUE;
      info->callbacks->einfo (_("%P: stubs don't match calculated size\n"));
    }

  if (htab->stub_error)
    return FALSE;

  if (stats != NULL)
    {
      *stats = bfd_malloc (500);
      if (*stats == NULL)
	return FALSE;

      sprintf (*stats, _("linker stubs in %u group%s\n"
			 "  branch       %lu\n"
			 "  toc adjust   %lu\n"
			 "  long branch  %lu\n"
			 "  long toc adj %lu\n"
			 "  plt call     %lu\n"
			 "  plt call toc %lu"),
	       stub_sec_count,
	       stub_sec_count == 1 ? "" : "s",
	       htab->stub_count[ppc_stub_long_branch - 1],
	       htab->stub_count[ppc_stub_long_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_branch - 1],
	       htab->stub_count[ppc_stub_plt_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_call - 1],
	       htab->stub_count[ppc_stub_plt_call_r2save - 1]);
    }
  return TRUE;
}

/* This function undoes the changes made by add_symbol_adjust.  */

static bfd_boolean
undo_symbol_twiddle (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  struct ppc_link_hash_entry *eh;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->elf.root.type != bfd_link_hash_undefweak || !eh->was_undefined)
    return TRUE;

  eh->elf.root.type = bfd_link_hash_undefined;
  return TRUE;
}

void
ppc64_elf_restore_symbols (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (htab != NULL)
    elf_link_hash_traverse (&htab->elf, undo_symbol_twiddle, info);
}

/* What to do when ld finds relocations against symbols defined in
   discarded sections.  */

static unsigned int
ppc64_elf_action_discarded (asection *sec)
{
  if (strcmp (".opd", sec->name) == 0)
    return 0;

  if (strcmp (".toc", sec->name) == 0)
    return 0;

  if (strcmp (".toc1", sec->name) == 0)
    return 0;

  return _bfd_elf_default_action_discarded (sec);
}

/* The RELOCATE_SECTION function is called by the ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjust the section contents as
   necessary, and (if using Rela relocs and generating a
   relocatable output file) adjusting the reloc addend as
   necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
ppc64_elf_relocate_section (bfd *output_bfd,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
{
  struct ppc_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  Elf_Internal_Rela outrel;
  bfd_byte *loc;
  struct got_entry **local_got_ents;
  bfd_vma TOCstart;
  bfd_boolean ret = TRUE;
  bfd_boolean is_opd;
  /* Assume 'at' branch hints.  */
  bfd_boolean is_isa_v2 = TRUE;
  bfd_vma d_offset = (bfd_big_endian (output_bfd) ? 2 : 0);

  /* Initialize howto table if needed.  */
  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
    ppc_howto_init ();

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Don't relocate stub sections.  */
  if (input_section->owner == htab->stub_bfd)
    return TRUE;

  BFD_ASSERT (is_ppc64_elf (input_bfd));

  local_got_ents = elf_local_got_ents (input_bfd);
  TOCstart = elf_gp (output_bfd);
  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  is_opd = ppc64_elf_section_data (input_section)->sec_type == sec_opd;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      enum elf_ppc64_reloc_type r_type;
      bfd_vma addend;
      bfd_reloc_status_type r;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h_elf;
      struct ppc_link_hash_entry *h;
      struct ppc_link_hash_entry *fdh;
      const char *sym_name;
      unsigned long r_symndx, toc_symndx;
      bfd_vma toc_addend;
      unsigned char tls_mask, tls_gd, tls_type;
      unsigned char sym_type;
      bfd_vma relocation;
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      enum { DEST_NORMAL, DEST_OPD, DEST_STUB } reloc_dest;
      unsigned int insn;
      unsigned int mask;
      struct ppc_stub_hash_entry *stub_entry;
      bfd_vma max_br_offset;
      bfd_vma from;
      const Elf_Internal_Rela orig_rel = *rel;

      r_type = ELF64_R_TYPE (rel->r_info);
      r_symndx = ELF64_R_SYM (rel->r_info);

      /* For old style R_PPC64_TOC relocs with a zero symbol, use the
	 symbol of the previous ADDR64 reloc.  The symbol gives us the
	 proper TOC base to use.  */
      if (rel->r_info == ELF64_R_INFO (0, R_PPC64_TOC)
	  && rel != relocs
	  && ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_ADDR64
	  && is_opd)
	r_symndx = ELF64_R_SYM (rel[-1].r_info);

      sym = NULL;
      sec = NULL;
      h_elf = NULL;
      sym_name = NULL;
      unresolved_reloc = FALSE;
      warned = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* It's a local symbol.  */
	  struct _opd_sec_data *opd;

	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, sec);
	  sym_type = ELF64_ST_TYPE (sym->st_info);
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	  opd = get_opd_info (sec);
	  if (opd != NULL && opd->adjust != NULL)
	    {
	      long adjust = opd->adjust[(sym->st_value + rel->r_addend) / 8];
	      if (adjust == -1)
		relocation = 0;
	      else
		{
		  /* If this is a relocation against the opd section sym
		     and we have edited .opd, adjust the reloc addend so
		     that ld -r and ld --emit-relocs output is correct.
		     If it is a reloc against some other .opd symbol,
		     then the symbol value will be adjusted later.  */
		  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		    rel->r_addend += adjust;
		  else
		    relocation += adjust;
		}
	    }
	}
      else
	{
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h_elf, sec, relocation,
				   unresolved_reloc, warned);
	  sym_name = h_elf->root.root.string;
	  sym_type = h_elf->type;
	  if (sec != NULL
	      && sec->owner == output_bfd
	      && strcmp (sec->name, ".opd") == 0)
	    {
	      /* This is a symbol defined in a linker script.  All
		 such are defined in output sections, even those
		 defined by simple assignment from a symbol defined in
		 an input section.  Transfer the symbol to an
		 appropriate input .opd section, so that a branch to
		 this symbol will be mapped to the location specified
		 by the opd entry.  */
	      struct bfd_link_order *lo;
	      for (lo = sec->map_head.link_order; lo != NULL; lo = lo->next)
		if (lo->type == bfd_indirect_link_order)
		  {
		    asection *isec = lo->u.indirect.section;
		    if (h_elf->root.u.def.value >= isec->output_offset
			&& h_elf->root.u.def.value < (isec->output_offset
						      + isec->size))
		      {
			h_elf->root.u.def.value -= isec->output_offset;
			h_elf->root.u.def.section = isec;
			sec = isec;
			break;
		      }
		  }
	    }
	}
      h = (struct ppc_link_hash_entry *) h_elf;

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend,
					 ppc64_elf_howto_table[r_type], 0,
					 contents);

      if (info->relocatable)
	continue;

      if (h != NULL && &h->elf == htab->elf.hgot)
	{
	  relocation = (TOCstart
			+ htab->stub_group[input_section->id].toc_off);
	  sec = bfd_abs_section_ptr;
	  unresolved_reloc = FALSE;
	}

      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      toc_symndx = 0;
      if (h != NULL)
	tls_mask = h->tls_mask;
      else if (local_got_ents != NULL)
	{
	  struct plt_entry **local_plt = (struct plt_entry **)
	    (local_got_ents + symtab_hdr->sh_info);
	  unsigned char *lgot_masks = (unsigned char *)
	    (local_plt + symtab_hdr->sh_info);
	  tls_mask = lgot_masks[r_symndx];
	}
      if (tls_mask == 0
	  && (r_type == R_PPC64_TLS
	      || r_type == R_PPC64_TLSGD
	      || r_type == R_PPC64_TLSLD))
	{
	  /* Check for toc tls entries.  */
	  unsigned char *toc_tls;

	  if (!get_tls_mask (&toc_tls, &toc_symndx, &toc_addend,
			     &local_syms, rel, input_bfd))
	    return FALSE;

	  if (toc_tls)
	    tls_mask = *toc_tls;
	}

      /* Check that tls relocs are used with tls syms, and non-tls
	 relocs are used with non-tls syms.  */
      if (r_symndx != STN_UNDEF
	  && r_type != R_PPC64_NONE
	  && (h == NULL
	      || h->elf.root.type == bfd_link_hash_defined
	      || h->elf.root.type == bfd_link_hash_defweak)
	  && (IS_PPC64_TLS_RELOC (r_type)
	      != (sym_type == STT_TLS
		  || (sym_type == STT_SECTION
		      && (sec->flags & SEC_THREAD_LOCAL) != 0))))
	{
	  if (tls_mask != 0
	      && (r_type == R_PPC64_TLS
		  || r_type == R_PPC64_TLSGD
		  || r_type == R_PPC64_TLSLD))
	    /* R_PPC64_TLS is OK against a symbol in the TOC.  */
	    ;
	  else
	    info->callbacks->einfo
	      (!IS_PPC64_TLS_RELOC (r_type)
	       ? _("%P: %H: %s used with TLS symbol `%T'\n")
	       : _("%P: %H: %s used with non-TLS symbol `%T'\n"),
	       input_bfd, input_section, rel->r_offset,
	       ppc64_elf_howto_table[r_type]->name,
	       sym_name);
	}

      /* Ensure reloc mapping code below stays sane.  */
      if (R_PPC64_TOC16_LO_DS != R_PPC64_TOC16_DS + 1
	  || R_PPC64_TOC16_LO != R_PPC64_TOC16 + 1
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TLSGD16 & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TLSGD16_LO & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TLSGD16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TLSGD16_HA & 3)
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TPREL16_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TPREL16_LO_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TPREL16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TPREL16_HA & 3))
	abort ();

      switch (r_type)
	{
	default:
	  break;

	case R_PPC64_LO_DS_OPT:
	  insn = bfd_get_32 (output_bfd, contents + rel->r_offset - d_offset);
	  if ((insn & (0x3f << 26)) != 58u << 26)
	    abort ();
	  insn += (14u << 26) - (58u << 26);
	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset - d_offset);
	  r_type = R_PPC64_TOC16_LO;
	  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	  break;

	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	  {
	    /* Check for toc tls entries.  */
	    unsigned char *toc_tls;
	    int retval;

	    retval = get_tls_mask (&toc_tls, &toc_symndx, &toc_addend,
				   &local_syms, rel, input_bfd);
	    if (retval == 0)
	      return FALSE;

	    if (toc_tls)
	      {
		tls_mask = *toc_tls;
		if (r_type == R_PPC64_TOC16_DS
		    || r_type == R_PPC64_TOC16_LO_DS)
		  {
		    if (tls_mask != 0
			&& (tls_mask & (TLS_DTPREL | TLS_TPREL)) == 0)
		      goto toctprel;
		  }
		else
		  {
		    /* If we found a GD reloc pair, then we might be
		       doing a GD->IE transition.  */
		    if (retval == 2)
		      {
			tls_gd = TLS_TPRELGD;
			if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
			  goto tls_ldgd_opt;
		      }
		    else if (retval == 3)
		      {
			if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
			  goto tls_ldgd_opt;
		      }
		  }
	      }
	  }
	  break;

	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      rel->r_offset -= d_offset;
	      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
	      r_type = R_PPC64_NONE;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	    toctprel:
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - d_offset);
	      insn &= 31 << 21;
	      insn |= 0x3c0d0000;	/* addis 0,13,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - d_offset);
	      r_type = R_PPC64_TPREL16_HA;
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  rel->r_addend = toc_addend;
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_TLS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      insn = _bfd_elf_ppc_at_tls_transform (insn, 13);
	      if (insn == 0)
		abort ();
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      /* Was PPC64_TLS which sits on insn boundary, now
		 PPC64_TPREL16_LO which is at low-order half-word.  */
	      rel->r_offset += d_offset;
	      r_type = R_PPC64_TPREL16_LO;
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  rel->r_addend = toc_addend;
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;

	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC64_GOT_TPREL16_DS);
	      else
		{
		  rel->r_offset -= d_offset;
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  r_type = R_PPC64_NONE;
		}
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_ldgd_opt;
	  break;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	      unsigned int insn1, insn2, insn3;
	      bfd_vma offset;

	    tls_ldgd_opt:
	      offset = (bfd_vma) -1;
	      /* If not using the newer R_PPC64_TLSGD/LD to mark
		 __tls_get_addr calls, we must trust that the call
		 stays with its arg setup insns, ie. that the next
		 reloc is the __tls_get_addr call associated with
		 the current reloc.  Edit both insns.  */
	      if (input_section->has_tls_get_addr_call
		  && rel + 1 < relend
		  && branch_reloc_hash_match (input_bfd, rel + 1,
					      htab->tls_get_addr,
					      htab->tls_get_addr_fd))
		offset = rel[1].r_offset;
	      if ((tls_mask & tls_gd) != 0)
		{
		  /* IE */
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
		  insn1 &= (1 << 26) - (1 << 2);
		  insn1 |= 58 << 26;	/* ld */
		  insn2 = 0x7c636a14;	/* add 3,3,13 */
		  if (offset != (bfd_vma) -1)
		    rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
		  if ((tls_mask & TLS_EXPLICIT) == 0)
		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			      + R_PPC64_GOT_TPREL16_DS);
		  else
		    r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
	      else
		{
		  /* LE */
		  insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		  insn2 = 0x38630000;	/* addi 3,3,0 */
		  if (tls_gd == 0)
		    {
		      /* Was an LD reloc.  */
		      if (toc_symndx)
			sec = local_sections[toc_symndx];
		      for (r_symndx = 0;
			   r_symndx < symtab_hdr->sh_info;
			   r_symndx++)
			if (local_sections[r_symndx] == sec)
			  break;
		      if (r_symndx >= symtab_hdr->sh_info)
			r_symndx = STN_UNDEF;
		      rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
		      if (r_symndx != STN_UNDEF)
			rel->r_addend -= (local_syms[r_symndx].st_value
					  + sec->output_offset
					  + sec->output_section->vma);
		    }
		  else if (toc_symndx != 0)
		    {
		      r_symndx = toc_symndx;
		      rel->r_addend = toc_addend;
		    }
		  r_type = R_PPC64_TPREL16_HA;
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		  if (offset != (bfd_vma) -1)
		    {
		      rel[1].r_info = ELF64_R_INFO (r_symndx,
						    R_PPC64_TPREL16_LO);
		      rel[1].r_offset = offset + d_offset;
		      rel[1].r_addend = rel->r_addend;
		    }
		}
	      bfd_put_32 (output_bfd, insn1,
			  contents + rel->r_offset - d_offset);
	      if (offset != (bfd_vma) -1)
		{
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      rel[1].r_offset += 4;
		      bfd_put_32 (output_bfd, insn2, contents + offset + 4);
		      insn2 = NOP;
		    }
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		}
	      if ((tls_mask & tls_gd) == 0
		  && (tls_gd == 0 || toc_symndx != 0))
		{
		  /* We changed the symbol.  Start over in order
		     to get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	    }
	  break;

	case R_PPC64_TLSGD:
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    {
	      unsigned int insn2, insn3;
	      bfd_vma offset = rel->r_offset;

	      if ((tls_mask & TLS_TPRELGD) != 0)
		{
		  /* IE */
		  r_type = R_PPC64_NONE;
		  insn2 = 0x7c636a14;	/* add 3,3,13 */
		}
	      else
		{
		  /* LE */
		  if (toc_symndx != 0)
		    {
		      r_symndx = toc_symndx;
		      rel->r_addend = toc_addend;
		    }
		  r_type = R_PPC64_TPREL16_LO;
		  rel->r_offset = offset + d_offset;
		  insn2 = 0x38630000;	/* addi 3,3,0 */
		}
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	      /* Zap the reloc on the _tls_get_addr call too.  */
	      BFD_ASSERT (offset == rel[1].r_offset);
	      rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
	      insn3 = bfd_get_32 (output_bfd,
				  contents + offset + 4);
	      if (insn3 == NOP
		  || insn3 == CROR_151515 || insn3 == CROR_313131)
		{
		  rel->r_offset += 4;
		  bfd_put_32 (output_bfd, insn2, contents + offset + 4);
		  insn2 = NOP;
		}
	      bfd_put_32 (output_bfd, insn2, contents + offset);
	      if ((tls_mask & TLS_TPRELGD) == 0 && toc_symndx != 0)
		{
		  rel--;
		  continue;
		}
	    }
	  break;

	case R_PPC64_TLSLD:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	      unsigned int insn2, insn3;
	      bfd_vma offset = rel->r_offset;

	      if (toc_symndx)
		sec = local_sections[toc_symndx];
	      for (r_symndx = 0;
		   r_symndx < symtab_hdr->sh_info;
		   r_symndx++)
		if (local_sections[r_symndx] == sec)
		  break;
	      if (r_symndx >= symtab_hdr->sh_info)
		r_symndx = STN_UNDEF;
	      rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
	      if (r_symndx != STN_UNDEF)
		rel->r_addend -= (local_syms[r_symndx].st_value
				  + sec->output_offset
				  + sec->output_section->vma);

	      r_type = R_PPC64_TPREL16_LO;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	      rel->r_offset = offset + d_offset;
	      /* Zap the reloc on the _tls_get_addr call too.  */
	      BFD_ASSERT (offset == rel[1].r_offset);
	      rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
	      insn2 = 0x38630000;	/* addi 3,3,0 */
	      insn3 = bfd_get_32 (output_bfd,
				  contents + offset + 4);
	      if (insn3 == NOP
		  || insn3 == CROR_151515 || insn3 == CROR_313131)
		{
		  rel->r_offset += 4;
		  bfd_put_32 (output_bfd, insn2, contents + offset + 4);
		  insn2 = NOP;
		}
	      bfd_put_32 (output_bfd, insn2, contents + offset);
	      rel--;
	      continue;
	    }
	  break;

	case R_PPC64_DTPMOD64:
	  if (rel + 1 < relend
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
	    {
	      if ((tls_mask & TLS_GD) == 0)
		{
		  rel[1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_NONE);
		  if ((tls_mask & TLS_TPRELGD) != 0)
		    r_type = R_PPC64_TPREL64;
		  else
		    {
		      bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
		      r_type = R_PPC64_NONE;
		    }
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
	    }
	  else
	    {
	      if ((tls_mask & TLS_LD) == 0)
		{
		  bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
		  r_type = R_PPC64_NONE;
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
	    }
	  break;

	case R_PPC64_TPREL64:
	  if ((tls_mask & TLS_TPREL) == 0)
	    {
	      r_type = R_PPC64_NONE;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;
	}

      /* Handle other relocations that tweak non-addend part of insn.  */
      insn = 0;
      max_br_offset = 1 << 25;
      addend = rel->r_addend;
      reloc_dest = DEST_NORMAL;
      switch (r_type)
	{
	default:
	  break;

	case R_PPC64_TOCSAVE:
	  if (relocation + addend == (rel->r_offset
				      + input_section->output_offset
				      + input_section->output_section->vma)
	      && tocsave_find (htab, NO_INSERT,
			       &local_syms, rel, input_bfd))
	    {
	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if (insn == NOP
		  || insn == CROR_151515 || insn == CROR_313131)
		bfd_put_32 (input_bfd, STD_R2_40R1,
			    contents + rel->r_offset);
	    }
	  break;

	  /* Branch taken prediction relocations.  */
	case R_PPC64_ADDR14_BRTAKEN:
	case R_PPC64_REL14_BRTAKEN:
	  insn = 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */
	  /* Fall thru.  */

	  /* Branch not taken prediction relocations.  */
	case R_PPC64_ADDR14_BRNTAKEN:
	case R_PPC64_REL14_BRNTAKEN:
	  insn |= bfd_get_32 (output_bfd,
			      contents + rel->r_offset) & ~(0x01 << 21);
	  /* Fall thru.  */

	case R_PPC64_REL14:
	  max_br_offset = 1 << 15;
	  /* Fall thru.  */

	case R_PPC64_REL24:
	  /* Calls to functions with a different TOC, such as calls to
	     shared objects, need to alter the TOC pointer.  This is
	     done using a linkage stub.  A REL24 branching to these
	     linkage stubs needs to be followed by a nop, as the nop
	     will be replaced with an instruction to restore the TOC
	     base pointer.  */
	  fdh = h;
	  if (h != NULL
	      && h->oh != NULL
	      && h->oh->is_func_descriptor)
	    fdh = ppc_follow_link (h->oh);
	  stub_entry = ppc_get_stub_entry (input_section, sec, fdh, &orig_rel,
					   htab);
	  if (stub_entry != NULL
	      && (stub_entry->stub_type == ppc_stub_plt_call
		  || stub_entry->stub_type == ppc_stub_plt_call_r2save
		  || stub_entry->stub_type == ppc_stub_plt_branch_r2off
		  || stub_entry->stub_type == ppc_stub_long_branch_r2off))
	    {
	      bfd_boolean can_plt_call = FALSE;

	      /* All of these stubs will modify r2, so there must be a
		 branch and link followed by a nop.  The nop is
		 replaced by an insn to restore r2.  */
	      if (rel->r_offset + 8 <= input_section->size)
		{
		  unsigned long br;

		  br = bfd_get_32 (input_bfd,
				   contents + rel->r_offset);
		  if ((br & 1) != 0)
		    {
		      unsigned long nop;

		      nop = bfd_get_32 (input_bfd,
					contents + rel->r_offset + 4);
		      if (nop == NOP
			  || nop == CROR_151515 || nop == CROR_313131)
			{
			  if (h != NULL
			      && (h == htab->tls_get_addr_fd
				  || h == htab->tls_get_addr)
			      && !htab->no_tls_get_addr_opt)
			    {
			      /* Special stub used, leave nop alone.  */
			    }
			  else
			    bfd_put_32 (input_bfd, LD_R2_40R1,
					contents + rel->r_offset + 4);
			  can_plt_call = TRUE;
			}
		    }
		}

	      if (!can_plt_call && h != NULL)
		{
		  const char *name = h->elf.root.root.string;

		  if (*name == '.')
		    ++name;

		  if (strncmp (name, "__libc_start_main", 17) == 0
		      && (name[17] == 0 || name[17] == '@@'))
		    {
		      /* Allow crt1 branch to go via a toc adjusting
			 stub.  Other calls that never return could do
			 the same, if we could detect such.  */
		      can_plt_call = TRUE;
		    }
		}

	      if (!can_plt_call)
		{
		  /* g++ as of 20130507 emits self-calls without a
		     following nop.  This is arguably wrong since we
		     have conflicting information.  On the one hand a
		     global symbol and on the other a local call
		     sequence, but don't error for this special case.
		     It isn't possible to cheaply verify we have
		     exactly such a call.  Allow all calls to the same
		     section.  */
		  asection *code_sec = sec;

		  if (get_opd_info (sec) != NULL)
		    {
		      bfd_vma off = (relocation + addend
				     - sec->output_section->vma
				     - sec->output_offset);

		      opd_entry_value (sec, off, &code_sec, NULL, FALSE);
		    }
		  if (code_sec == input_section)
		    can_plt_call = TRUE;
		}

	      if (!can_plt_call)
		{
		  info->callbacks->einfo
		    (_("%P: %H: call to `%T' lacks nop, can't restore toc; "
		       "recompile with -fPIC"),
		     input_bfd, input_section, rel->r_offset, sym_name);

		  bfd_set_error (bfd_error_bad_value);
		  ret = FALSE;
		}

	      if (can_plt_call
		  && (stub_entry->stub_type == ppc_stub_plt_call
		      || stub_entry->stub_type == ppc_stub_plt_call_r2save))
		unresolved_reloc = FALSE;
	    }

	  if ((stub_entry == NULL
	       || stub_entry->stub_type == ppc_stub_long_branch
	       || stub_entry->stub_type == ppc_stub_plt_branch)
	      && get_opd_info (sec) != NULL)
	    {
	      /* The branch destination is the value of the opd entry. */
	      bfd_vma off = (relocation + addend
			     - sec->output_section->vma
			     - sec->output_offset);
	      bfd_vma dest = opd_entry_value (sec, off, NULL, NULL, FALSE);
	      if (dest != (bfd_vma) -1)
		{
		  relocation = dest;
		  addend = 0;
		  reloc_dest = DEST_OPD;
		}
	    }

	  /* If the branch is out of reach we ought to have a long
	     branch stub.  */
	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);

	  if (stub_entry != NULL
	      && (stub_entry->stub_type == ppc_stub_long_branch
		  || stub_entry->stub_type == ppc_stub_plt_branch)
	      && (r_type == R_PPC64_ADDR14_BRTAKEN
		  || r_type == R_PPC64_ADDR14_BRNTAKEN
		  || (relocation + addend - from + max_br_offset
		      < 2 * max_br_offset)))
	    /* Don't use the stub if this branch is in range.  */
	    stub_entry = NULL;

	  if (stub_entry != NULL)
	    {
	      /* Munge up the value and addend so that we call the stub
		 rather than the procedure directly.  */
	      relocation = (stub_entry->stub_offset
			    + stub_entry->stub_sec->output_offset
			    + stub_entry->stub_sec->output_section->vma);
	      addend = 0;
	      reloc_dest = DEST_STUB;

 	      if ((stub_entry->stub_type == ppc_stub_plt_call
		   || stub_entry->stub_type == ppc_stub_plt_call_r2save)
		  && (ALWAYS_EMIT_R2SAVE
		      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
		  && rel + 1 < relend
		  && rel[1].r_offset == rel->r_offset + 4
		  && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)
		relocation += 4;
	    }

	  if (insn != 0)
	    {
	      if (is_isa_v2)
		{
		  /* Set 'a' bit.  This is 0b00010 in BO field for branch
		     on CR(BI) insns (BO == 001at or 011at), and 0b01000
		     for branch on CTR insns (BO == 1a00t or 1a01t).  */
		  if ((insn & (0x14 << 21)) == (0x04 << 21))
		    insn |= 0x02 << 21;
		  else if ((insn & (0x14 << 21)) == (0x10 << 21))
		    insn |= 0x08 << 21;
		  else
		    break;
		}
	      else
		{
		  /* Invert 'y' bit if not the default.  */
		  if ((bfd_signed_vma) (relocation + addend - from) < 0)
		    insn ^= 0x01 << 21;
		}

	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    }

	  /* NOP out calls to undefined weak functions.
	     We can thus call a weak function without first
	     checking whether the function is defined.  */
	  else if (h != NULL
		   && h->elf.root.type == bfd_link_hash_undefweak
		   && h->elf.dynindx == -1
		   && r_type == R_PPC64_REL24
		   && relocation == 0
		   && addend == 0)
	    {
	      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
	      continue;
	    }
	  break;
	}

      /* Set `addend'.  */
      tls_type = 0;
      switch (r_type)
	{
	default:
	  info->callbacks->einfo
	    (_("%P: %B: unknown relocation type %d for `%T'\n"),
	     input_bfd, (int) r_type, sym_name);

	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	  continue;

	case R_PPC64_NONE:
	case R_PPC64_TLS:
	case R_PPC64_TLSGD:
	case R_PPC64_TLSLD:
	case R_PPC64_TOCSAVE:
	case R_PPC64_GNU_VTINHERIT:
	case R_PPC64_GNU_VTENTRY:
	  continue;

	  /* GOT16 relocations.  Like an ADDR16 using the symbol's
	     address in the GOT as relocation value instead of the
	     symbol's value itself.  Also, create a GOT entry for the
	     symbol and put the symbol value there.  */
	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

	case R_PPC64_GOT16:
	case R_PPC64_GOT16_LO:
	case R_PPC64_GOT16_HI:
	case R_PPC64_GOT16_HA:
	case R_PPC64_GOT16_DS:
	case R_PPC64_GOT16_LO_DS:
	dogot:
	  {
	    /* Relocation is to the entry for this symbol in the global
	       offset table.  */
	    asection *got;
	    bfd_vma *offp;
	    bfd_vma off;
	    unsigned long indx = 0;
	    struct got_entry *ent;

	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !h->elf.def_dynamic))
	      ent = ppc64_tlsld_got (input_bfd);
	    else
	      {

		if (h != NULL)
		  {
		    bfd_boolean dyn = htab->elf.dynamic_sections_created;
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
							  &h->elf)
			|| (info->shared
			    && SYMBOL_CALLS_LOCAL (info, &h->elf)))
		      /* This is actually a static link, or it is a
			 -Bsymbolic link and the symbol is defined
			 locally, or the symbol was forced to be local
			 because of a version file.  */
		      ;
		    else
		      {
			BFD_ASSERT (h->elf.dynindx != -1);
			indx = h->elf.dynindx;
			unresolved_reloc = FALSE;
		      }
		    ent = h->elf.got.glist;
		  }
		else
		  {
		    if (local_got_ents == NULL)
		      abort ();
		    ent = local_got_ents[r_symndx];
		  }

		for (; ent != NULL; ent = ent->next)
		  if (ent->addend == orig_rel.r_addend
		      && ent->owner == input_bfd
		      && ent->tls_type == tls_type)
		    break;
	      }

	    if (ent == NULL)
	      abort ();
	    if (ent->is_indirect)
	      ent = ent->got.ent;
	    offp = &ent->got.offset;
	    got = ppc64_elf_tdata (ent->owner)->got;
	    if (got == NULL)
	      abort ();

	    /* The offset must always be a multiple of 8.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    off = *offp;
	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		/* Generate relocs for the dynamic linker, except in
		   the case of TLSLD where we'll use one entry per
		   module.  */
		asection *relgot;
		bfd_boolean ifunc;

		*offp = off | 1;
		relgot = NULL;
		ifunc = (h != NULL
			 ? h->elf.type == STT_GNU_IFUNC
			 : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC);
		if (ifunc)
		  relgot = htab->reliplt;
		else if ((info->shared || indx != 0)
			 && (h == NULL
			     || (tls_type == (TLS_TLS | TLS_LD)
				 && !h->elf.def_dynamic)
			     || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
			     || h->elf.root.type != bfd_link_hash_undefweak))
		  relgot = ppc64_elf_tdata (ent->owner)->relgot;
		if (relgot != NULL)
		  {
		    outrel.r_offset = (got->output_section->vma
				       + got->output_offset
				       + off);
		    outrel.r_addend = addend;
		    if (tls_type & (TLS_LD | TLS_GD))
		      {
			outrel.r_addend = 0;
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    loc = relgot->contents;
			    loc += (relgot->reloc_count++
				    * sizeof (Elf64_External_Rela));
			    bfd_elf64_swap_reloca_out (output_bfd,
						       &outrel, loc);
			    outrel.r_offset += 8;
			    outrel.r_addend = addend;
			    outrel.r_info
			      = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
			  }
		      }
		    else if (tls_type == (TLS_TLS | TLS_DTPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
		    else if (tls_type == (TLS_TLS | TLS_TPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_TPREL64);
		    else if (indx != 0)
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_GLOB_DAT);
		    else
		      {
			if (ifunc)
			  outrel.r_info = ELF64_R_INFO (0, R_PPC64_IRELATIVE);
			else
			  outrel.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);

			/* Write the .got section contents for the sake
			   of prelink.  */
			loc = got->contents + off;
			bfd_put_64 (output_bfd, outrel.r_addend + relocation,
				    loc);
		      }

		    if (indx == 0 && tls_type != (TLS_TLS | TLS_LD))
		      {
			outrel.r_addend += relocation;
			if (tls_type & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			  outrel.r_addend -= htab->elf.tls_sec->vma;
		      }
		    loc = relgot->contents;
		    loc += (relgot->reloc_count++
			    * sizeof (Elf64_External_Rela));
		    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  }

		/* Init the .got section contents here if we're not
		   emitting a reloc.  */
		else
		  {
		    relocation += addend;
		    if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
		    else if (tls_type != 0)
		      {
			relocation -= htab->elf.tls_sec->vma + DTP_OFFSET;
			if (tls_type == (TLS_TLS | TLS_TPREL))
			  relocation += DTP_OFFSET - TP_OFFSET;

			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    bfd_put_64 (output_bfd, relocation,
					got->contents + off + 8);
			    relocation = 1;
			  }
		      }

		    bfd_put_64 (output_bfd, relocation,
				got->contents + off);
		  }
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    relocation = got->output_section->vma + got->output_offset + off;
	    addend = -(TOCstart + htab->stub_group[input_section->id].toc_off);
	  }
	  break;

	case R_PPC64_PLT16_HA:
	case R_PPC64_PLT16_HI:
	case R_PPC64_PLT16_LO:
	case R_PPC64_PLT32:
	case R_PPC64_PLT64:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  /* It's possible that we didn't make a PLT entry for this
	     symbol.  This happens when statically linking PIC code,
	     or when using -Bsymbolic.  Go find a match if there is a
	     PLT entry.  */
	  if (htab->plt != NULL)
	    {
	      struct plt_entry *ent;
	      for (ent = h->elf.plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == orig_rel.r_addend
		    && ent->plt.offset != (bfd_vma) -1)
		  {
		    relocation = (htab->plt->output_section->vma
				  + htab->plt->output_offset
				  + ent->plt.offset);
		    unresolved_reloc = FALSE;
		  }
	    }
	  break;

	case R_PPC64_TOC:
	  /* Relocation value is TOC base.  */
	  relocation = TOCstart;
	  if (r_symndx == STN_UNDEF)
	    relocation += htab->stub_group[input_section->id].toc_off;
	  else if (unresolved_reloc)
	    ;
	  else if (sec != NULL && sec->id <= htab->top_id)
	    relocation += htab->stub_group[sec->id].toc_off;
	  else
	    unresolved_reloc = TRUE;
	  goto dodyn;

	  /* TOC16 relocs.  We want the offset relative to the TOC base,
	     which is the address of the start of the TOC plus 0x8000.
	     The TOC consists of sections .got, .toc, .tocbss, and .plt,
	     in this order.  */
	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_HI:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	case R_PPC64_TOC16_HA:
	  addend -= TOCstart + htab->stub_group[input_section->id].toc_off;
	  break;

	  /* Relocate against the beginning of the section.  */
	case R_PPC64_SECTOFF:
	case R_PPC64_SECTOFF_LO:
	case R_PPC64_SECTOFF_HI:
	case R_PPC64_SECTOFF_DS:
	case R_PPC64_SECTOFF_LO_DS:
	case R_PPC64_SECTOFF_HA:
	  if (sec != NULL)
	    addend -= sec->output_section->vma;
	  break;

	case R_PPC64_REL16:
	case R_PPC64_REL16_LO:
	case R_PPC64_REL16_HI:
	case R_PPC64_REL16_HA:
	  break;

	case R_PPC64_REL14:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL24:
	  break;

	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  if (h != NULL
	      && h->elf.root.type == bfd_link_hash_undefweak
	      && h->elf.dynindx == -1)
	    {
	      /* Make this relocation against an undefined weak symbol
		 resolve to zero.  This is really just a tweak, since
		 code using weak externs ought to check that they are
		 defined before using them.  */
	      bfd_byte *p = contents + rel->r_offset - d_offset;

	      insn = bfd_get_32 (output_bfd, p);
	      insn = _bfd_elf_ppc_at_tprel_transform (insn, 13);
	      if (insn != 0)
		bfd_put_32 (output_bfd, insn, p);
	      break;
	    }
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  if (info->shared)
	    /* The TPREL16 relocs shouldn't really be used in shared
	       libs as they will result in DT_TEXTREL being set, but
	       support them anyway.  */
	    goto dodyn;
	  break;

	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  break;

	case R_PPC64_DTPMOD64:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

	case R_PPC64_TPREL64:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC64_DTPREL64:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  /* Fall thru */

	  /* Relocations that may need to be propagated if this is a
	     dynamic object.  */
	case R_PPC64_REL30:
	case R_PPC64_REL32:
	case R_PPC64_REL64:
	case R_PPC64_ADDR14:
	case R_PPC64_ADDR14_BRNTAKEN:
	case R_PPC64_ADDR14_BRTAKEN:
	case R_PPC64_ADDR16:
	case R_PPC64_ADDR16_DS:
	case R_PPC64_ADDR16_HA:
	case R_PPC64_ADDR16_HI:
	case R_PPC64_ADDR16_HIGHER:
	case R_PPC64_ADDR16_HIGHERA:
	case R_PPC64_ADDR16_HIGHEST:
	case R_PPC64_ADDR16_HIGHESTA:
	case R_PPC64_ADDR16_LO:
	case R_PPC64_ADDR16_LO_DS:
	case R_PPC64_ADDR24:
	case R_PPC64_ADDR32:
	case R_PPC64_ADDR64:
	case R_PPC64_UADDR16:
	case R_PPC64_UADDR32:
	case R_PPC64_UADDR64:
	dodyn:
	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if (NO_OPD_RELOCS && is_opd)
	    break;

	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
	       && (must_be_dyn_reloc (info, r_type)
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && h->elf.dynindx != -1
		  && !h->elf.non_got_ref
		  && !h->elf.def_regular)
	      || (!info->shared
		  && (h != NULL
		      ? h->elf.type == STT_GNU_IFUNC
		      : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)))
	    {
	      bfd_boolean skip, relocate;
	      asection *sreloc;
	      bfd_vma out_off;

	      /* When generating a dynamic object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      skip = FALSE;
	      relocate = FALSE;

	      out_off = _bfd_elf_section_offset (output_bfd, info,
						 input_section, rel->r_offset);
	      if (out_off == (bfd_vma) -1)
		skip = TRUE;
	      else if (out_off == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      out_off += (input_section->output_section->vma
			  + input_section->output_offset);
	      outrel.r_offset = out_off;
	      outrel.r_addend = rel->r_addend;

	      /* Optimize unaligned reloc use.  */
	      if ((r_type == R_PPC64_ADDR64 && (out_off & 7) != 0)
		  || (r_type == R_PPC64_UADDR64 && (out_off & 7) == 0))
		r_type ^= R_PPC64_ADDR64 ^ R_PPC64_UADDR64;
	      else if ((r_type == R_PPC64_ADDR32 && (out_off & 3) != 0)
		       || (r_type == R_PPC64_UADDR32 && (out_off & 3) == 0))
		r_type ^= R_PPC64_ADDR32 ^ R_PPC64_UADDR32;
	      else if ((r_type == R_PPC64_ADDR16 && (out_off & 1) != 0)
		       || (r_type == R_PPC64_UADDR16 && (out_off & 1) == 0))
		r_type ^= R_PPC64_ADDR16 ^ R_PPC64_UADDR16;

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (!SYMBOL_CALLS_LOCAL (info, &h->elf)
		       && !is_opd
		       && r_type != R_PPC64_TOC)
		{
		  BFD_ASSERT (h->elf.dynindx != -1);
		  outrel.r_info = ELF64_R_INFO (h->elf.dynindx, r_type);
		}
	      else
		{
		  /* This symbol is local, or marked to become local,
		     or this is an opd section reloc which must point
		     at a local function.  */
		  outrel.r_addend += relocation;
		  if (r_type == R_PPC64_ADDR64 || r_type == R_PPC64_TOC)
		    {
		      if (is_opd && h != NULL)
			{
			  /* Lie about opd entries.  This case occurs
			     when building shared libraries and we
			     reference a function in another shared
			     lib.  The same thing happens for a weak
			     definition in an application that's
			     overridden by a strong definition in a
			     shared lib.  (I believe this is a generic
			     bug in binutils handling of weak syms.)
			     In these cases we won't use the opd
			     entry in this lib.  */
			  unresolved_reloc = FALSE;
			}
		      if (!is_opd
			  && r_type == R_PPC64_ADDR64
			  && (h != NULL
			      ? h->elf.type == STT_GNU_IFUNC
			      : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC))
			outrel.r_info = ELF64_R_INFO (0, R_PPC64_IRELATIVE);
		      else
			{
			  outrel.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);

			  /* We need to relocate .opd contents for ld.so.
			     Prelink also wants simple and consistent rules
			     for relocs.  This make all RELATIVE relocs have
			     *r_offset equal to r_addend.  */
			  relocate = TRUE;
			}
		    }
		  else
		    {
		      long indx = 0;

		      if (h != NULL
			  ? h->elf.type == STT_GNU_IFUNC
			  : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
			{
			  info->callbacks->einfo
			    (_("%P: %H: %s for indirect "
			       "function `%T' unsupported\n"),
			     input_bfd, input_section, rel->r_offset,
			     ppc64_elf_howto_table[r_type]->name,
			     sym_name);
			  ret = FALSE;
			}
		      else if (r_symndx == STN_UNDEF || bfd_is_abs_section (sec))
			;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;

			  if (indx == 0)
			    {
			      if ((osec->flags & SEC_READONLY) == 0
				  && htab->elf.data_index_section != NULL)
				osec = htab->elf.data_index_section;
			      else
				osec = htab->elf.text_index_section;
			      indx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (indx != 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */
			  outrel.r_addend -= osec->vma;
			}

		      outrel.r_info = ELF64_R_INFO (indx, r_type);
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;
	      if (h != NULL
		  ? h->elf.type == STT_GNU_IFUNC
		  : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
		sreloc = htab->reliplt;
	      if (sreloc == NULL)
		abort ();

	      if (sreloc->reloc_count * sizeof (Elf64_External_Rela)
		  >= sreloc->size)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, it will
		 be computed at runtime, so there's no need to do
		 anything now.  However, for the sake of prelink ensure
		 that the section contents are a known value.  */
	      if (! relocate)
		{
		  unresolved_reloc = FALSE;
		  /* The value chosen here is quite arbitrary as ld.so
		     ignores section contents except for the special
		     case of .opd where the contents might be accessed
		     before relocation.  Choose zero, as that won't
		     cause reloc overflow.  */
		  relocation = 0;
		  addend = 0;
		  /* Use *r_offset == r_addend for R_PPC64_ADDR64 relocs
		     to improve backward compatibility with older
		     versions of ld.  */
		  if (r_type == R_PPC64_ADDR64)
		    addend = outrel.r_addend;
		  /* Adjust pc_relative relocs to have zero in *r_offset.  */
		  else if (ppc64_elf_howto_table[r_type]->pc_relative)
		    addend = (input_section->output_section->vma
			      + input_section->output_offset
			      + rel->r_offset);
		}
	    }
	  break;

	case R_PPC64_COPY:
	case R_PPC64_GLOB_DAT:
	case R_PPC64_JMP_SLOT:
	case R_PPC64_JMP_IREL:
	case R_PPC64_RELATIVE:
	  /* We shouldn't ever see these dynamic relocs in relocatable
	     files.  */
	  /* Fall through.  */

	case R_PPC64_PLTGOT16:
	case R_PPC64_PLTGOT16_DS:
	case R_PPC64_PLTGOT16_HA:
	case R_PPC64_PLTGOT16_HI:
	case R_PPC64_PLTGOT16_LO:
	case R_PPC64_PLTGOT16_LO_DS:
	case R_PPC64_PLTREL32:
	case R_PPC64_PLTREL64:
	  /* These ones haven't been implemented yet.  */

	  info->callbacks->einfo
	    (_("%P: %B: %s is not supported for `%T'\n"),
	     input_bfd,
	     ppc64_elf_howto_table[r_type]->name, sym_name);

	  bfd_set_error (bfd_error_invalid_operation);
	  ret = FALSE;
	  continue;
	}

      /* Multi-instruction sequences that access the TOC can be
	 optimized, eg. addis ra,r2,0; addi rb,ra,x;
	 to             nop;           addi rb,r2,x;  */
      switch (r_type)
	{
	default:
	  break;

	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT16_HI:
	case R_PPC64_TOC16_HI:
	  /* These relocs would only be useful if building up an
	     offset to later add to r2, perhaps in an indexed
	     addressing mode instruction.  Don't try to optimize.
	     Unfortunately, the possibility of someone building up an
	     offset like this or even with the HA relocs, means that
	     we need to check the high insn when optimizing the low
	     insn.  */
	  break;

	case R_PPC64_GOT_TLSLD16_HA:
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TPREL16_HA:
	case R_PPC64_GOT_DTPREL16_HA:
	case R_PPC64_GOT16_HA:
	case R_PPC64_TOC16_HA:
	  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000
	      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn)
	    {
	      bfd_byte *p = contents + (rel->r_offset & ~3);
	      bfd_put_32 (input_bfd, NOP, p);
	    }
	  break;

	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT16_LO:
	case R_PPC64_GOT16_LO_DS:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_LO_DS:
	  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000
	      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn)
	    {
	      bfd_byte *p = contents + (rel->r_offset & ~3);
	      insn = bfd_get_32 (input_bfd, p);
	      if ((insn & (0x3f << 26)) == 12u << 26 /* addic */)
		{
		  /* Transform addic to addi when we change reg.  */
		  insn &= ~((0x3f << 26) | (0x1f << 16));
		  insn |= (14u << 26) | (2 << 16);
		}
	      else
		{
		  insn &= ~(0x1f << 16);
		  insn |= 2 << 16;
		}
	      bfd_put_32 (input_bfd, insn, p);
	    }
	  break;
	}

      /* Do any further special processing.  */
      switch (r_type)
	{
	default:
	  break;

	case R_PPC64_ADDR16_HA:
	case R_PPC64_REL16_HA:
	case R_PPC64_ADDR16_HIGHERA:
	case R_PPC64_ADDR16_HIGHESTA:
	case R_PPC64_TOC16_HA:
	case R_PPC64_SECTOFF_HA:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  /* It's just possible that this symbol is a weak symbol
	     that's not actually defined anywhere. In that case,
	     'sec' would be NULL, and we should leave the symbol
	     alone (it will be set to zero elsewhere in the link).  */
	  if (sec == NULL)
	    break;
	  /* Fall thru */

	case R_PPC64_GOT16_HA:
	case R_PPC64_PLTGOT16_HA:
	case R_PPC64_PLT16_HA:
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TLSLD16_HA:
	case R_PPC64_GOT_TPREL16_HA:
	case R_PPC64_GOT_DTPREL16_HA:
	  /* Add 0x10000 if sign bit in 0:15 is set.
	     Bits 0:15 are not used.  */
	  addend += 0x8000;
	  break;

	case R_PPC64_ADDR16_DS:
	case R_PPC64_ADDR16_LO_DS:
	case R_PPC64_GOT16_DS:
	case R_PPC64_GOT16_LO_DS:
	case R_PPC64_PLT16_LO_DS:
	case R_PPC64_SECTOFF_DS:
	case R_PPC64_SECTOFF_LO_DS:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	case R_PPC64_PLTGOT16_DS:
	case R_PPC64_PLTGOT16_LO_DS:
	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	  insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));
	  mask = 3;
	  /* If this reloc is against an lq insn, then the value must be
	     a multiple of 16.  This is somewhat of a hack, but the
	     "correct" way to do this by defining _DQ forms of all the
	     _DS relocs bloats all reloc switches in this file.  It
	     doesn't seem to make much sense to use any of these relocs
	     in data, so testing the insn should be safe.  */
	  if ((insn & (0x3f << 26)) == (56u << 26))
	    mask = 15;
	  if (((relocation + addend) & mask) != 0)
	    {
	      info->callbacks->einfo
		(_("%P: %H: error: %s not a multiple of %u\n"),
		 input_bfd, input_section, rel->r_offset,
		 ppc64_elf_howto_table[r_type]->name,
		 mask + 1);
	      bfd_set_error (bfd_error_bad_value);
	      ret = FALSE;
	      continue;
	    }
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->elf.def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  info->callbacks->einfo
	    (_("%P: %H: unresolvable %s against `%T'\n"),
	     input_bfd, input_section, rel->r_offset,
	     ppc64_elf_howto_table[(int) r_type]->name,
	     h->elf.root.root.string);
	  ret = FALSE;
	}

      r = _bfd_final_link_relocate (ppc64_elf_howto_table[(int) r_type],
				    input_bfd,
				    input_section,
				    contents,
				    rel->r_offset,
				    relocation,
				    addend);

      if (r != bfd_reloc_ok)
	{
	  char *more_info = NULL;
	  const char *reloc_name = ppc64_elf_howto_table[r_type]->name;

	  if (reloc_dest != DEST_NORMAL)
	    {
	      more_info = bfd_malloc (strlen (reloc_name) + 8);
	      if (more_info != NULL)
		{
		  strcpy (more_info, reloc_name);
		  strcat (more_info, (reloc_dest == DEST_OPD
				      ? " (OPD)" : " (stub)"));
		  reloc_name = more_info;
		}
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (warned)
		continue;
	      if (h != NULL
		  && h->elf.root.type == bfd_link_hash_undefweak
		  && ppc64_elf_howto_table[r_type]->pc_relative)
		{
		  /* Assume this is a call protected by other code that
		     detects the symbol is undefined.  If this is the case,
		     we can safely ignore the overflow.  If not, the
		     program is hosed anyway, and a little warning isn't
		     going to help.  */

		  continue;
		}

	      if (!((*info->callbacks->reloc_overflow)
		    (info, &h->elf.root, sym_name,
		     reloc_name, orig_rel.r_addend,
		     input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      info->callbacks->einfo
		(_("%P: %H: %s against `%T': error %d\n"),
		 input_bfd, input_section, rel->r_offset,
		 reloc_name, sym_name, (int) r);
	      ret = FALSE;
	    }
	  if (more_info != NULL)
	    free (more_info);
	}
    }

  /* If we're emitting relocations, then shortly after this function
     returns, reloc offsets and addends for this section will be
     adjusted.  Worse, reloc symbol indices will be for the output
     file rather than the input.  Save a copy of the relocs for
     opd_entry_value.  */
  if (is_opd && (info->emitrelocations || info->relocatable))
    {
      bfd_size_type amt;
      amt = input_section->reloc_count * sizeof (Elf_Internal_Rela);
      rel = bfd_alloc (input_bfd, amt);
      BFD_ASSERT (ppc64_elf_tdata (input_bfd)->opd.relocs == NULL);
      ppc64_elf_tdata (input_bfd)->opd.relocs = rel;
      if (rel == NULL)
	return FALSE;
      memcpy (rel, relocs, amt);
    }
  return ret;
}

/* Adjust the value of any local symbols in opd sections.  */

static int
ppc64_elf_output_symbol_hook (struct bfd_link_info *info,
			      const char *name ATTRIBUTE_UNUSED,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h)
{
  struct _opd_sec_data *opd;
  long adjust;
  bfd_vma value;

  if (h != NULL)
    return 1;

  opd = get_opd_info (input_sec);
  if (opd == NULL || opd->adjust == NULL)
    return 1;

  value = elfsym->st_value - input_sec->output_offset;
  if (!info->relocatable)
    value -= input_sec->output_section->vma;

  adjust = opd->adjust[value / 8];
  if (adjust == -1)
    return 2;

  elfsym->st_value += adjust;
  return 1;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
ppc64_elf_finish_dynamic_symbol (bfd *output_bfd,
				 struct bfd_link_info *info,
				 struct elf_link_hash_entry *h,
				 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
  struct ppc_link_hash_table *htab;
  struct plt_entry *ent;
  Elf_Internal_Rela rela;
  bfd_byte *loc;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.offset != (bfd_vma) -1)
      {
	/* This symbol has an entry in the procedure linkage
	   table.  Set it up.  */
	if (!htab->elf.dynamic_sections_created
	    || h->dynindx == -1)
	  {
	    BFD_ASSERT (h->type == STT_GNU_IFUNC
			&& h->def_regular
			&& (h->root.type == bfd_link_hash_defined
			    || h->root.type == bfd_link_hash_defweak));
	    rela.r_offset = (htab->iplt->output_section->vma
			     + htab->iplt->output_offset
			     + ent->plt.offset);
	    rela.r_info = ELF64_R_INFO (0, R_PPC64_JMP_IREL);
	    rela.r_addend = (h->root.u.def.value
			     + h->root.u.def.section->output_offset
			     + h->root.u.def.section->output_section->vma
			     + ent->addend);
	    loc = (htab->reliplt->contents
		   + (htab->reliplt->reloc_count++
		      * sizeof (Elf64_External_Rela)));
	  }
	else
	  {
	    rela.r_offset = (htab->plt->output_section->vma
			     + htab->plt->output_offset
			     + ent->plt.offset);
	    rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	    rela.r_addend = ent->addend;
	    loc = (htab->relplt->contents
		   + ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE)
		      / (PLT_ENTRY_SIZE / sizeof (Elf64_External_Rela))));
	  }
	bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
      }

  if (h->needs_copy)
    {
      /* This symbol needs a copy reloc.  Set it up.  */

      if (h->dynindx == -1
	  || (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	  || htab->relbss == NULL)
	abort ();

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_COPY);
      rela.r_addend = 0;
      loc = htab->relbss->contents;
      loc += htab->relbss->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
ppc64_elf_reloc_type_class (const struct bfd_link_info *info,
			    const asection *rel_sec,
			    const Elf_Internal_Rela *rela)
{
  enum elf_ppc64_reloc_type r_type;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (rel_sec == htab->reliplt)
    return reloc_class_ifunc;

  r_type = ELF64_R_TYPE (rela->r_info);
  switch (r_type)
    {
    case R_PPC64_RELATIVE:
      return reloc_class_relative;
    case R_PPC64_JMP_SLOT:
      return reloc_class_plt;
    case R_PPC64_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
ppc64_elf_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->elf.dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->elf.dynamic_sections_created)
    {
      Elf64_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL || htab->got == NULL)
	abort ();

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PPC64_GLINK:
	      s = htab->glink;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      /* We stupidly defined DT_PPC64_GLINK to be the start
		 of glink rather than the first entry point, which is
		 what ld.so needs, and now have a bigger stub to
		 support automatic multiple TOCs.  */
	      dyn.d_un.d_ptr += GLINK_CALL_STUB_SIZE - 32;
	      break;

	    case DT_PPC64_OPD:
	      s = bfd_get_section_by_name (output_bfd, ".opd");
	      if (s == NULL)
		continue;
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_PPC64_OPDSZ:
	      s = bfd_get_section_by_name (output_bfd, ".opd");
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val = s->size;
	      break;

	    case DT_PLTGOT:
	      s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_JMPREL:
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = htab->relplt->size;
	      break;

	    case DT_RELASZ:
	      /* Don't count procedure linkage table relocs in the
		 overall reloc count.  */
	      s = htab->relplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->relplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->size;
	      break;
	    }

	  bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	}
    }

  if (htab->got != NULL && htab->got->size != 0)
    {
      /* Fill in the first entry in the global offset table.
	 We use it to hold the link-time TOCbase.  */
      bfd_put_64 (output_bfd,
		  elf_gp (output_bfd) + TOC_BASE_OFF,
		  htab->got->contents);

      /* Set .got entry size.  */
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 8;
    }

  if (htab->plt != NULL && htab->plt->size != 0)
    {
      /* Set .plt entry size.  */
      elf_section_data (htab->plt->output_section)->this_hdr.sh_entsize
	= PLT_ENTRY_SIZE;
    }

  /* brlt is SEC_LINKER_CREATED, so we need to write out relocs for
     brlt ourselves if emitrelocations.  */
  if (htab->brlt != NULL
      && htab->brlt->reloc_count != 0
      && !_bfd_elf_link_output_relocs (output_bfd,
				       htab->brlt,
				       elf_section_data (htab->brlt)->rela.hdr,
				       elf_section_data (htab->brlt)->relocs,
				       NULL))
    return FALSE;

  if (htab->glink != NULL
      && htab->glink->reloc_count != 0
      && !_bfd_elf_link_output_relocs (output_bfd,
				       htab->glink,
				       elf_section_data (htab->glink)->rela.hdr,
				       elf_section_data (htab->glink)->relocs,
				       NULL))
    return FALSE;


  if (htab->glink_eh_frame != NULL
      && htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
      && !_bfd_elf_write_section_eh_frame (output_bfd, info,
					   htab->glink_eh_frame,
					   htab->glink_eh_frame->contents))
    return FALSE;

  /* We need to handle writing out multiple GOT sections ourselves,
     since we didn't add them to DYNOBJ.  We know dynobj is the first
     bfd.  */
  while ((dynobj = dynobj->link_next) != NULL)
    {
      asection *s;

      if (!is_ppc64_elf (dynobj))
	continue;

      s = ppc64_elf_tdata (dynobj)->got;
      if (s != NULL
	  && s->size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->size))
	return FALSE;
      s = ppc64_elf_tdata (dynobj)->relgot;
      if (s != NULL
	  && s->size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->size))
	return FALSE;
    }

  return TRUE;
}

#include "elf64-target.h"

/* FreeBSD support */

#undef  TARGET_LITTLE_SYM
#undef  TARGET_LITTLE_NAME

#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM	bfd_elf64_powerpc_freebsd_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME "elf64-powerpc-freebsd"

#undef  ELF_OSABI
#define	ELF_OSABI       ELFOSABI_FREEBSD

#undef  elf64_bed
#define elf64_bed	elf64_powerpc_fbsd_bed

#include "elf64-target.h"

@


1.417
log
@	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Replace opd_relocs
	with a union.
	(opd_entry_value): Cache .opd section contents.
	(ppc64_elf_relocate_section): Adjust.
@
text
@d99 1
a99 1
#define elf_backend_as_needed_cleanup	      ppc64_elf_as_needed_cleanup
d4809 3
a4811 2
ppc64_elf_as_needed_cleanup (bfd *ibfd ATTRIBUTE_UNUSED,
			     struct bfd_link_info *info)
d4813 3
a4815 1
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
d4817 2
a4818 2
  if (htab == NULL)
    return FALSE;
d4820 3
a4822 2
  htab->dot_syms = NULL;
  return TRUE;
@


1.416
log
@	* elf64-ppc.c (ppc64_elf_func_desc_adjust): Don't hide .TOC.
	when relocatable.  Don't change root.type or type here.
	(ppc64_elf_set_toc): Set type of .TOC. to STT_OBJECT.
@
text
@d2618 7
a2624 2
  /* A copy of relocs before they are modified for --emit-relocs.  */
  Elf_Internal_Rela *opd_relocs;
d5582 1
a5582 1
      char buf[8];
d5584 6
a5589 2
      if (!bfd_get_section_contents (opd_bfd, opd_sec, buf, offset, 8))
	return (bfd_vma) -1;
d5591 1
a5591 1
      val = bfd_get_64 (opd_bfd, buf);
d5623 1
a5623 1
  relocs = ppc64_elf_tdata (opd_bfd)->opd_relocs;
d14077 2
a14078 2
      BFD_ASSERT (ppc64_elf_tdata (input_bfd)->opd_relocs == NULL);
      ppc64_elf_tdata (input_bfd)->opd_relocs = rel;
@


1.415
log
@bfd/
	* elf64-ppc.c (struct ppc_stub_hash_entry): Delete "addend".
	(ppc64_elf_size_stubs): Don't set "addend".
	(ppc64_elf_relocate_section): Don't allow calls via
	toc-adjusting stubs without a following nop even in an
	executable, except for self-calls and both libc_start_main
	and .libc_start_main.
gold/
	* powerpc.cc (Target_powerpc::Relocate::relocate): Update self-call
	comment.
@
text
@d6550 3
a6552 6
  if (htab->elf.hgot != NULL)
    {
      htab->elf.hgot->root.type = bfd_link_hash_new;
      htab->elf.hgot->type = STT_OBJECT;
      _bfd_elf_link_hash_hide_symbol (info, htab->elf.hgot, TRUE);
    }
d11917 1
@


1.414
log
@	* elf64-ppc.c (ppc64_elf_func_desc_adjust): Hide ".TOC.".
@
text
@a3620 3
  /* And the reloc addend that this was derived from.  */
  bfd_vma addend;

a11751 1
		  stub_entry->addend = irela->r_addend;
d13014 3
d13019 12
a13030 9
		  unsigned long nop;
		  nop = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
		  if (nop == NOP
		      || nop == CROR_151515 || nop == CROR_313131)
		    {
		      if (h != NULL
			  && (h == htab->tls_get_addr_fd
			      || h == htab->tls_get_addr)
			  && !htab->no_tls_get_addr_opt)
d13032 11
a13042 1
			  /* Special stub used, leave nop alone.  */
a13043 4
		      else
			bfd_put_32 (input_bfd, LD_R2_40R1,
				    contents + rel->r_offset + 4);
		      can_plt_call = TRUE;
d13047 1
a13047 1
	      if (!can_plt_call)
d13049 7
a13055 2
		  if (stub_entry->stub_type == ppc_stub_plt_call
		      || stub_entry->stub_type == ppc_stub_plt_call_r2save)
d13057 3
a13059 16
		      /* If this is a plain branch rather than a branch
			 and link, don't require a nop.  However, don't
			 allow tail calls in a shared library as they
			 will result in r2 being corrupted.  */
		      unsigned long br;
		      br = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      if (info->executable && (br & 1) == 0)
			can_plt_call = TRUE;
		      else
			stub_entry = NULL;
		    }
		  else if (h != NULL
			   && strcmp (h->elf.root.root.string,
				      ".__libc_start_main") == 0)
		    {
		      /* Allow crt1 branch to go via a toc adjusting stub.  */
d13062 15
a13076 1
		  else
d13078 3
a13080 4
		      info->callbacks->einfo
			(_("%P: %H: call to `%T' lacks nop, can't restore toc; "
			   "recompile with -fPIC"),
			   input_bfd, input_section, rel->r_offset, sym_name);
d13082 1
a13082 2
		      bfd_set_error (bfd_error_bad_value);
		      ret = FALSE;
d13084 13
@


1.413
log
@bfd/
	* elf64-ppc.c (ppc64_elf_relocate_section): Set "relocation" for
	.TOC. after relocatable check.
gas/
	* config/tc-ppc.c (ppc_elf_adjust_symtab): Don't make .TOC. weak.
@
text
@d6553 7
@


1.412
log
@bfd/
	* elf64-ppc.h (ppc64_elf_toc): Delete.
	(ppc64_elf_set_toc): Declare.
	* elf64-ppc.c (ppc64_elf_toc_reloc): Replace call to ppc64_elf_toc
	with call the ppc64_elf_set_toc.
	(ppc64_elf_toc_ha_reloc, ppc64_elf_toc64_reloc): Likewise.
	(ppc64_elf_start_multitoc_partition): Likewise.
	(struct ppc_link_hash_table): Delete dot_toc_dot.  Replace all uses
	with elf.hgot.
	(ppc64_elf_process_dot_syms): Don't make a fake function descriptor
	for ".TOC.".
	(ppc64_elf_check_relocs): Mark sections with a reference to .TOC.
	as needing a toc pointer.
	(ppc64_elf_size_stubs): Don't set dot_toc_dot here.
	(ppc64_elf_set_toc): Rename from ppc64_elf_toc.  Add info param.
	Set elf.hgot value.
ld/
	* emultempl/ppc64elf.em: (ppc_layout_sections_again): Call
	ppc64_elf_set_toc rather than ppc64_elf_toc/_bfd_set_gp_value.
	(gld${EMULATION_NAME}_after_allocation): Likewise.
@
text
@a12469 7
	  if (h_elf == htab->elf.hgot)
	    {
	      relocation = (TOCstart
			    + htab->stub_group[input_section->id].toc_off);
	      sec = bfd_abs_section_ptr;
	      unresolved_reloc = FALSE;
	    }
d12482 8
@


1.411
log
@	* elf64-ppc.c (opd_entry_value): Handle case where symbol
	hashes are not available.
@
text
@d2475 1
a2475 1
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);
d2498 1
a2498 1
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);
d2525 1
a2525 1
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);
a3774 3
  /* The special .TOC. symbol.  */
  struct ppc_link_hash_entry *dot_toc_dot;

d4774 6
a4779 1
	  if (!add_symbol_adjust (eh, info))
d5012 3
d10625 1
a10625 2
  elf_gp (info->output_bfd) = ppc64_elf_toc (info->output_bfd);
  htab->toc_curr = elf_gp (info->output_bfd);
a11456 3
  htab->dot_toc_dot = ((struct ppc_link_hash_entry *)
		       elf_link_hash_lookup (&htab->elf, ".TOC.",
					     FALSE, FALSE, TRUE));
d11857 1
a11857 1
ppc64_elf_toc (bfd *obfd)
d11908 14
d12470 1
a12470 1
	  if (h_elf == &htab->dot_toc_dot->elf)
@


1.410
log
@bfd/
	* elf64-ppc.c (ppc64_elf_check_relocs): Don't call
	create_linkage_sections here..
	(ppc64_elf_init_stub_bfd): ..do so here.  Return status.
	(create_linkage_sections): Move earlier in file.
	(ppc64_elf_setup_section_lists): Remove now useless htab->brlt test.
	* elf64-ppc.h (ppc64_elf_init_stub_bfd): Update proto.
ld/
	* emultempl/ppc64elf.em (ppc_create_output_section_statements):
	Check return from ppc64_elf_init_stub_bfd.
ld/testsuite/
	* ld-powerpc/tlsexe.d: Adjust.
	* ld-powerpc/tlsexe.r: Adjust.
	* ld-powerpc/tlsexetoc.d: Adjust.
	* ld-powerpc/tlsexetoc.r: Adjust.
	* ld-powerpc/tlsso.d: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlstocso.d: Adjust.
	* ld-powerpc/tlstocso.r: Adjust.
@
text
@d5668 24
a5691 5
		  rh = elf_follow_link (rh);
		  BFD_ASSERT (rh->root.type == bfd_link_hash_defined
			      || rh->root.type == bfd_link_hash_defweak);
		  val = rh->root.u.def.value;
		  sec = rh->root.u.def.section;
@


1.409
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Use SYMBOLIC_BIND.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count): Likewise.
@
text
@d4064 77
d4143 1
a4143 1
void
d4155 1
a4155 1
    return;
d4158 5
a4311 79
/* Create sections for linker generated code.  */

static bfd_boolean
create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  flagword flags;

  htab = ppc_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Create .sfpr for code to save and restore fp regs.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->sfpr = bfd_make_section_anyway_with_flags (dynobj, ".sfpr",
						   flags);
  if (htab->sfpr == NULL
      || ! bfd_set_section_alignment (dynobj, htab->sfpr, 2))
    return FALSE;

  /* Create .glink for lazy dynamic linking support.  */
  htab->glink = bfd_make_section_anyway_with_flags (dynobj, ".glink",
						    flags);
  if (htab->glink == NULL
      || ! bfd_set_section_alignment (dynobj, htab->glink, 3))
    return FALSE;

  if (!info->no_ld_generated_unwind_info)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->glink_eh_frame = bfd_make_section_anyway_with_flags (dynobj,
								 ".eh_frame",
								 flags);
      if (htab->glink_eh_frame == NULL
	  || !bfd_set_section_alignment (dynobj, htab->glink_eh_frame, 2))
	return FALSE;
    }

  flags = SEC_ALLOC | SEC_LINKER_CREATED;
  htab->iplt = bfd_make_section_anyway_with_flags (dynobj, ".iplt", flags);
  if (htab->iplt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->iplt, 3))
    return FALSE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->reliplt = bfd_make_section_anyway_with_flags (dynobj,
						      ".rela.iplt",
						      flags);
  if (htab->reliplt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->reliplt, 3))
    return FALSE;

  /* Create branch lookup table for plt_branch stubs.  */
  flags = (SEC_ALLOC | SEC_LOAD
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->brlt = bfd_make_section_anyway_with_flags (dynobj, ".branch_lt",
						   flags);
  if (htab->brlt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->brlt, 3))
    return FALSE;

  if (!info->shared)
    return TRUE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->relbrlt = bfd_make_section_anyway_with_flags (dynobj,
						      ".rela.branch_lt",
						      flags);
  if (htab->relbrlt == NULL
      || ! bfd_set_section_alignment (dynobj, htab->relbrlt, 3))
    return FALSE;

  return TRUE;
}

a4988 4
  if (htab->sfpr == NULL
      && !create_linkage_sections (htab->elf.dynobj, info))
    return FALSE;

a10548 3
  if (htab->brlt == NULL)
    return 0;

@


1.408
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d5459 1
a5459 1
		       && (! info->symbolic
d7067 1
a7067 1
	       && (!info->symbolic
@


1.407
log
@	* elf64-ppc.c (struct ppc_dyn_relocs): New.
	(ppc64_elf_check_relocs): Separate dynrel counts for local syms
	into ifunc and non-ifunc.
	(dec_dynrel_count): Pass in sym rather than sym_sec.  Handle
	separate ifunc/non-ifunc dynrel counts.
	(allocate_got): Always use reliplt for ifunc.
	(allocate_dynrelocs): Likewise.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc64_elf_layout_multitoc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d5007 4
@


1.406
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d3641 15
a5465 3
	      struct elf_dyn_relocs *p;
	      struct elf_dyn_relocs **head;

d5482 3
d5486 15
d5507 3
d5524 17
a5540 14
		  head = (struct elf_dyn_relocs **) vpp;
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
a5541 4

	      p->count += 1;
	      if (!must_be_dyn_reloc (info, r_type))
		p->pc_count += 1;
d6986 1
a6986 1
   R_INFO in section SEC.  If LOCAL_SYMS is NULL, then H and SYM_SEC
d6995 1
a6995 1
		  asection *sym_sec)
d6998 1
a6998 2
  struct elf_dyn_relocs *p;
  struct elf_dyn_relocs **pp;
a7052 1
      Elf_Internal_Sym *sym;
a7075 2
    pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
  else
d7077 12
a7088 1
      if (sym_sec != NULL)
d7090 10
a7099 7
	  void *vpp = &elf_section_data (sym_sec)->local_dynrel;
	  pp = (struct elf_dyn_relocs **) vpp;
	}
      else
	{
	  void *vpp = &elf_section_data (sec)->local_dynrel;
	  pp = (struct elf_dyn_relocs **) vpp;
d7102 14
d7117 2
a7118 6
  /* elf_gc_sweep may have already removed all dyn relocs associated
     with local syms for a given section.  Also, symbol flags are
     changed by elf_gc_sweep_symbol, confusing the test above.  Don't
     report a dynreloc miscount.  */
  if (*pp == NULL && info->gc_sections)
    return TRUE;
d7120 2
a7121 3
  while ((p = *pp) != NULL)
    {
      if (p->sec == sec)
d7123 8
a7130 6
	  if (!must_be_dyn_reloc (info, r_type))
	    p->pc_count -= 1;
	  p->count -= 1;
	  if (p->count == 0)
	    *pp = p->next;
	  return TRUE;
a7131 1
      pp = &p->next;
d7464 1
a7464 1
					    NULL, h, sym_sec))
d8071 1
a8071 1
					     NULL, h, sym_sec))
d8077 1
a8077 1
						 NULL, h, sym_sec))
d8869 1
a8869 4
  if ((info->shared
       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d8871 2
a8872 2
      asection *relgot = ppc64_elf_tdata (gent->owner)->relgot;
      relgot->size += rentsize;
d8874 4
a8877 1
  else if (h->type == STT_GNU_IFUNC)
d8879 1
a8879 1
      asection *relgot = htab->reliplt;
a8880 1
      htab->got_reli_size += rentsize;
d9144 1
a9144 1
      if (!htab->elf.dynamic_sections_created)
a9222 1
      asection *srel;
d9229 1
a9229 1
	  struct elf_dyn_relocs *p;
d9243 2
a9244 2
		  srel = elf_section_data (p->sec)->sreloc;
		  if (!htab->elf.dynamic_sections_created)
a9263 1
      srel = ppc64_elf_tdata (ibfd)->relgot;
d9279 3
a9281 1
		    unsigned int num = 1;
a9283 5
		      num = 2;
		    s->size += num * 8;
		    if (info->shared)
		      srel->size += num * sizeof (Elf64_External_Rela);
		    else if ((*lgot_masks & PLT_IFUNC) != 0)
d9285 13
a9297 4
			htab->reliplt->size
			  += num * sizeof (Elf64_External_Rela);
			htab->got_reli_size
			  += num * sizeof (Elf64_External_Rela);
d10796 1
a10796 1
      asection *s, *srel;
a10811 1
      srel = ppc64_elf_tdata (ibfd)->relgot;
d10818 3
a10820 1
	      unsigned int num = 1;
a10822 5
		num = 2;
	      s->size += num * 8;
	      if (info->shared)
		srel->size += num * sizeof (Elf64_External_Rela);
	      else if ((*lgot_masks & PLT_IFUNC) != 0)
d10824 13
a10836 4
		  htab->reliplt->size
		    += num * sizeof (Elf64_External_Rela);
		  htab->got_reli_size
		    += num * sizeof (Elf64_External_Rela);
d13271 8
a13278 6
		if ((info->shared || indx != 0)
		    && (h == NULL
			|| (tls_type == (TLS_TLS | TLS_LD)
			    && !h->elf.def_dynamic)
			|| ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
			|| h->elf.root.type != bfd_link_hash_undefweak))
a13279 2
		else if (ifunc)
		  relgot = htab->reliplt;
d13693 3
a13695 1
	      if (!htab->elf.dynamic_sections_created)
@


1.405
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d8819 2
a8820 2
	    && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak))
d14065 3
a14067 1
ppc64_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d14070 4
@


1.404
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d2680 1
a2680 1
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d2683 1
a2683 1
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 32);
d2700 1
a2700 1
  elf_tdata (abfd)->core_pid
d2702 1
a2702 1
  elf_tdata (abfd)->core_program
d2704 1
a2704 1
  elf_tdata (abfd)->core_command
@


1.403
log
@	* elf64-ppc.c (dec_dynrel_count): Don't error when elf_gc_sweep_symbol
	clears def_regular.
@
text
@d4046 1
a4046 1
  _bfd_generic_link_hash_table_free (hash);
@


1.402
log
@bfd/
	* elf64-ppc.c (ppc_stub_name): Trim off trailing "+0".
ld/testsuite/
	* ld-powerpc/tlsexe.d: Update for changed stub names.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexetoc.d: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso.d: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlstocso.d: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
@
text
@d7059 1
d7061 6
a7066 6
      /* elf_gc_sweep may have already removed all dyn relocs associated
	 with local syms for a given section.  Don't report a dynreloc
	 miscount.  */
      if (*pp == NULL)
	return TRUE;
    }
@


1.401
log
@	* elf64-ppc.c (build_plt_stub): Correct plt stub branch to glink.
@
text
@d4077 1
a4077 1
  bfd_size_type len;
d4091 4
a4094 4
      sprintf (stub_name, "%08x.%s+%x",
	       input_section->id & 0xffffffff,
	       h->elf.root.root.string,
	       (int) rel->r_addend & 0xffffffff);
d4103 5
a4107 5
      sprintf (stub_name, "%08x.%x:%x+%x",
	       input_section->id & 0xffffffff,
	       sym_sec->id & 0xffffffff,
	       (int) ELF64_R_SYM (rel->r_info) & 0xffffffff,
	       (int) rel->r_addend & 0xffffffff);
d4109 1
a4109 1
  if (stub_name[len - 2] == '+' && stub_name[len - 1] == '0')
@


1.400
log
@	* elf64-ppc.c: Use %T to print symbols names and remove redundant
	"relocation" in error messages throughout file.
	(ppc64_elf_relocate_section): Remove sibling call error message,
	replace with "call lacks nop".  Specially report errors for
	branches to function entry points via OPD lookup and branches
	to stubs.  Remove NULL symbol handling now done by %T.
@
text
@d9775 1
a9775 1
      bfd_put_32 (obfd, B_DOT + cmp_branch_off, p),		p += 4;
@


1.399
log
@bfd/
	* elf64-ppc.c (ppc64_elf_size_stubs): Default shared libs to
	plt-thread-safe.
gold/
	* powerpc.cc (Target_powerpc::do_relax): Default shared libs to
	plt-thread-safe.
ld/testsuite/
	* ld-powerpc/tlsso.d: Adjust for plt-thread-safe stubs.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlstocso.d: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
@
text
@d6614 1
a6614 1
	(_("%P: copy reloc against `%s' requires lazy plt linking; "
d8669 1
a8669 1
			    (_("%P: %H: %s relocation references "
d9876 1
a9876 1
	  info->callbacks->einfo (_("%P: cannot find opd entry toc for %s\n"),
d9958 3
a9960 2
	  info->callbacks->einfo (_("%P: long branch stub `%s' offset overflow\n"),
				  stub_entry->root.string);
d10080 1
a10080 1
	    (_("%P: linkage table error against `%s'\n"),
d10223 1
a10223 1
	    (_("%P: linkage table error against `%s'\n"),
d12283 1
d12448 2
a12449 2
	       ? _("%P: %H: %s used with TLS symbol %s\n")
	       : _("%P: %H: %s used with non-TLS symbol %s\n"),
d12855 1
d12961 5
a12965 19
		      if (strcmp (input_section->output_section->name,
				  ".init") == 0
			  || strcmp (input_section->output_section->name,
				     ".fini") == 0)
			info->callbacks->einfo
			  (_("%P: %H: automatic multiple TOCs "
			     "not supported using your crt files; "
			     "recompile with -mminimal-toc or upgrade gcc\n"),
			   input_bfd, input_section, rel->r_offset);
		      else
			info->callbacks->einfo
			  (_("%P: %H: sibling call optimization to `%s' "
			     "does not allow automatic multiple TOCs; "
			     "recompile with -mminimal-toc or "
			     "-fno-optimize-sibling-calls, "
			     "or make `%s' extern\n"),
			   input_bfd, input_section, rel->r_offset,
			   sym_name,
			   sym_name);
d12991 1
d13019 1
d13077 1
a13077 1
	    (_("%P: %B: unknown relocation type %d for symbol %s\n"),
d13587 2
a13588 2
			    (_("%P: %H: relocation %s for indirect "
			       "function %s unsupported\n"),
d13692 1
a13692 1
	    (_("%P: %B: relocation %s is not supported for symbol %s\n"),
d13862 1
a13862 1
	    (_("%P: %H: unresolvable %s relocation against symbol `%s'\n"),
d13879 15
a13893 2
	  if (sym_name == NULL)
	    sym_name = "(null)";
d13912 3
a13914 4
		    (info, (h ? &h->elf.root : NULL), sym_name,
		     ppc64_elf_howto_table[r_type]->name,
		     orig_rel.r_addend, input_bfd, input_section,
		     rel->r_offset)))
d13920 1
a13920 1
		(_("%P: %H: %s reloc against `%s': error %d\n"),
d13922 1
a13922 3
		 ppc64_elf_howto_table[r_type]->name,
		 sym_name,
		 (int) r);
d13925 2
@


1.398
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d11337 2
d11341 1
a11341 1
      const char *const thread_starter[] =
@


1.397
log
@	* elf64-ppc.c (build_plt_stub): Fix off by one error in branch
	to glink.
@
text
@d3262 1
a3262 1
	
d4491 1
a4491 1
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
d8256 1
a8256 1
	 
d11355 1
a11355 1
	  "GOMP_parallel_sections_start", 
@


1.396
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_table): Add dot_toc_dot.
	(ppc64_elf_size_stubs): Lookup ".TOC.".
	(ppc64_elf_relocate_section): Resolve special symbol ".TOC.".
gas/
	* config/tc-ppc.c (ppc_elf_adjust_symtab): New function, split out..
	(ppc_frob_file_before_adjust): ..from here.
	(md_apply_fix): Set BSF_KEEP on .TOC. if not @@tocbase.
	* config/tc-ppc.h (ppc_elf_adjust_symtab): Declare.
	(tc_adjust_symtab): Define.
@
text
@d9656 2
a9657 2
      if (pltindex > 32767)
	glinkoff += (pltindex - 32767) * 4;
@


1.395
log
@	* elf64-ppc.c (maybe_strip_output): Heed SEC_KEEP.
@
text
@d3760 3
d11370 3
d12371 7
@


1.394
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Clear "repeat" inside
	loop.  Really mark toc entry referring to another toc entry
	only if the first is used.
@
text
@d11303 1
@


1.393
log
@2012-09-12  Doug Kwan  <dougkwan@@google.com>

	* elf64-ppc.c (ppc64_elf_relocate_section): Use pre-adjusted
	relocation for stub lookup.
@
text
@a8374 1
	  repeat = 0;
d8376 11
a8386 9
	    for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
	      {
		enum elf_ppc64_reloc_type r_type;
		unsigned long r_symndx;
		asection *sym_sec;
		struct elf_link_hash_entry *h;
		Elf_Internal_Sym *sym;
		bfd_vma val;
		enum {no_check, check_lo, check_ha} insn_check;
d8388 6
a8393 6
		r_type = ELF64_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  default:
		    insn_check = no_check;
		    break;
d8395 8
a8402 8
		  case R_PPC64_GOT_TLSLD16_HA:
		  case R_PPC64_GOT_TLSGD16_HA:
		  case R_PPC64_GOT_TPREL16_HA:
		  case R_PPC64_GOT_DTPREL16_HA:
		  case R_PPC64_GOT16_HA:
		  case R_PPC64_TOC16_HA:
		    insn_check = check_ha;
		    break;
d8404 11
a8414 11
		  case R_PPC64_GOT_TLSLD16_LO:
		  case R_PPC64_GOT_TLSGD16_LO:
		  case R_PPC64_GOT_TPREL16_LO_DS:
		  case R_PPC64_GOT_DTPREL16_LO_DS:
		  case R_PPC64_GOT16_LO:
		  case R_PPC64_GOT16_LO_DS:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TOC16_LO_DS:
		    insn_check = check_lo;
		    break;
		  }
d8416 5
a8420 5
		if (insn_check != no_check)
		  {
		    bfd_vma off = rel->r_offset & ~3;
		    unsigned char buf[4];
		    unsigned int insn;
d8422 12
a8433 12
		    if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
		      {
			free (used);
			goto error_ret;
		      }
		    insn = bfd_get_32 (ibfd, buf);
		    if (insn_check == check_lo
			? !ok_lo_toc_insn (insn)
			: ((insn & ((0x3f << 26) | 0x1f << 16))
			   != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */))
		      {
			char str[12];
d8435 8
a8442 8
			ppc64_elf_tdata (ibfd)->unexpected_toc_insn = 1;
			sprintf (str, "%#08x", insn);
			info->callbacks->einfo
			  (_("%P: %H: toc optimization is not supported for"
			     " %s instruction.\n"),
			   ibfd, sec, rel->r_offset & ~3, str);
		      }
		  }
d8444 11
a8454 11
		switch (r_type)
		  {
		  case R_PPC64_TOC16:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TOC16_HI:
		  case R_PPC64_TOC16_HA:
		  case R_PPC64_TOC16_DS:
		  case R_PPC64_TOC16_LO_DS:
		    /* In case we're taking addresses of toc entries.  */
		  case R_PPC64_ADDR64:
		    break;
d8456 3
a8458 3
		  default:
		    continue;
		  }
d8460 7
a8466 7
		r_symndx = ELF64_R_SYM (rel->r_info);
		if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				r_symndx, ibfd))
		  {
		    free (used);
		    goto error_ret;
		  }
d8468 2
a8469 2
		if (sym_sec != toc)
		  continue;
d8471 5
a8475 5
		if (h != NULL)
		  val = h->root.u.def.value;
		else
		  val = sym->st_value;
		val += rel->r_addend;
d8477 2
a8478 2
		if (val >= toc->size)
		  continue;
d8480 4
a8483 4
		if ((skip[val >> 3] & can_optimize) != 0)
		  {
		    bfd_vma off;
		    unsigned char opc;
d8485 3
a8487 13
		    switch (r_type)
		      {
		      case R_PPC64_TOC16_HA:
			break;

		      case R_PPC64_TOC16_LO_DS:
			off = rel->r_offset + (bfd_big_endian (ibfd) ? -2 : 3);
			if (!bfd_get_section_contents (ibfd, sec, &opc, off, 1))
			  {
			    free (used);
			    goto error_ret;
			  }
			if ((opc & (0x3f << 2)) == (58u << 2))
a8488 1
			/* Fall thru */
d8490 12
a8501 6
		      default:
			/* Wrong sort of reloc, or not a ld.  We may
			   as well clear ref_from_discarded too.  */
			skip[val >> 3] = 0;
		      }
		  }
d8503 6
a8508 9
		/* For the toc section, we only mark as used if
		   this entry itself isn't unused.  */
		if (sec == toc
		    && !used[val >> 3]
		    && (used[rel->r_offset >> 3]
			|| !(skip[rel->r_offset >> 3] & ref_from_discarded)))
		  /* Do all the relocs again, to catch reference
		     chains.  */
		  repeat = 1;
d8510 15
a8524 2
		used[val >> 3] = 1;
	      }
@


1.392
log
@	PR ld/14464
	* elf64-ppc.c (ppc64_elf_relocate_section): Map symbols defined
	by a linker script in .opd to corresponding input .opd section.
@
text
@d12252 1
a12252 1
      bfd_vma addend, orig_addend;
d12272 1
a12291 1
      orig_addend = rel->r_addend;
d12880 2
a12881 1
	  stub_entry = ppc_get_stub_entry (input_section, sec, fdh, rel, htab);
d13163 1
a13163 1
		  if (ent->addend == orig_addend
d13316 1
a13316 1
		if (ent->addend == orig_addend
d13888 2
a13889 1
		     orig_addend, input_bfd, input_section, rel->r_offset)))
@


1.391
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Assert that dynindx is
	not minus one.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d12331 27
@


1.390
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d13121 1
d13494 4
a13497 1
		outrel.r_info = ELF64_R_INFO (h->elf.dynindx, r_type);
@


1.390.4.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@a13120 1
			BFD_ASSERT (h->elf.dynindx != -1);
d13493 1
a13493 4
		{
		  BFD_ASSERT (h->elf.dynindx != -1);
		  outrel.r_info = ELF64_R_INFO (h->elf.dynindx, r_type);
		}
@


1.390.4.2
log
@	PR ld/14464
	* elf64-ppc.c (ppc64_elf_relocate_section): Map symbols defined
	by a linker script in .opd to corresponding input .opd section.
@
text
@a12330 27
	  if (sec != NULL
	      && sec->owner == output_bfd
	      && strcmp (sec->name, ".opd") == 0)
	    {
	      /* This is a symbol defined in a linker script.  All
		 such are defined in output sections, even those
		 defined by simple assignment from a symbol defined in
		 an input section.  Transfer the symbol to an
		 appropriate input .opd section, so that a branch to
		 this symbol will be mapped to the location specified
		 by the opd entry.  */
	      struct bfd_link_order *lo;
	      for (lo = sec->map_head.link_order; lo != NULL; lo = lo->next)
		if (lo->type == bfd_indirect_link_order)
		  {
		    asection *isec = lo->u.indirect.section;
		    if (h_elf->root.u.def.value >= isec->output_offset
			&& h_elf->root.u.def.value < (isec->output_offset
						      + isec->size))
		      {
			h_elf->root.u.def.value -= isec->output_offset;
			h_elf->root.u.def.section = isec;
			sec = isec;
			break;
		      }
		  }
	    }
@


1.390.4.3
log
@2012-09-13  Doug Kwan  <dougkwan@@google.com>

	* elf64-ppc.c (ppc64_elf_relocate_section): Use pre-adjusted
	relocation for stub lookup.
@
text
@d12252 1
a12252 1
      bfd_vma addend;
a12271 1
      const Elf_Internal_Rela orig_rel = *rel;
d12291 1
d12880 1
a12880 2
	  stub_entry = ppc_get_stub_entry (input_section, sec, fdh, &orig_rel,
					   htab);
d13162 1
a13162 1
		  if (ent->addend == orig_rel.r_addend
d13315 1
a13315 1
		if (ent->addend == orig_rel.r_addend
d13887 1
a13887 2
		     orig_rel.r_addend, input_bfd, input_section,
		     rel->r_offset)))
@


1.390.4.4
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d8375 1
d8377 16
a8392 11
	    {
	      repeat = 0;
	      for (rel = relstart; rel < relstart + sec->reloc_count; ++rel)
		{
		  enum elf_ppc64_reloc_type r_type;
		  unsigned long r_symndx;
		  asection *sym_sec;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
		  bfd_vma val;
		  enum {no_check, check_lo, check_ha} insn_check;
d8394 8
a8401 6
		  r_type = ELF64_R_TYPE (rel->r_info);
		  switch (r_type)
		    {
		    default:
		      insn_check = no_check;
		      break;
d8403 11
a8413 8
		    case R_PPC64_GOT_TLSLD16_HA:
		    case R_PPC64_GOT_TLSGD16_HA:
		    case R_PPC64_GOT_TPREL16_HA:
		    case R_PPC64_GOT_DTPREL16_HA:
		    case R_PPC64_GOT16_HA:
		    case R_PPC64_TOC16_HA:
		      insn_check = check_ha;
		      break;
d8415 5
a8419 11
		    case R_PPC64_GOT_TLSLD16_LO:
		    case R_PPC64_GOT_TLSGD16_LO:
		    case R_PPC64_GOT_TPREL16_LO_DS:
		    case R_PPC64_GOT_DTPREL16_LO_DS:
		    case R_PPC64_GOT16_LO:
		    case R_PPC64_GOT16_LO_DS:
		    case R_PPC64_TOC16_LO:
		    case R_PPC64_TOC16_LO_DS:
		      insn_check = check_lo;
		      break;
		    }
d8421 12
a8432 5
		  if (insn_check != no_check)
		    {
		      bfd_vma off = rel->r_offset & ~3;
		      unsigned char buf[4];
		      unsigned int insn;
d8434 8
a8441 12
		      if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
			{
			  free (used);
			  goto error_ret;
			}
		      insn = bfd_get_32 (ibfd, buf);
		      if (insn_check == check_lo
			  ? !ok_lo_toc_insn (insn)
			  : ((insn & ((0x3f << 26) | 0x1f << 16))
			     != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */))
			{
			  char str[12];
d8443 11
a8453 8
			  ppc64_elf_tdata (ibfd)->unexpected_toc_insn = 1;
			  sprintf (str, "%#08x", insn);
			  info->callbacks->einfo
			    (_("%P: %H: toc optimization is not supported for"
			       " %s instruction.\n"),
			     ibfd, sec, rel->r_offset & ~3, str);
			}
		    }
d8455 3
a8457 11
		  switch (r_type)
		    {
		    case R_PPC64_TOC16:
		    case R_PPC64_TOC16_LO:
		    case R_PPC64_TOC16_HI:
		    case R_PPC64_TOC16_HA:
		    case R_PPC64_TOC16_DS:
		    case R_PPC64_TOC16_LO_DS:
		      /* In case we're taking addresses of toc entries.  */
		    case R_PPC64_ADDR64:
		      break;
d8459 7
a8465 3
		    default:
		      continue;
		    }
d8467 2
a8468 7
		  r_symndx = ELF64_R_SYM (rel->r_info);
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_symndx, ibfd))
		    {
		      free (used);
		      goto error_ret;
		    }
d8470 5
a8474 2
		  if (sym_sec != toc)
		    continue;
d8476 2
a8477 5
		  if (h != NULL)
		    val = h->root.u.def.value;
		  else
		    val = sym->st_value;
		  val += rel->r_addend;
d8479 4
a8482 2
		  if (val >= toc->size)
		    continue;
d8484 4
a8487 4
		  if ((skip[val >> 3] & can_optimize) != 0)
		    {
		      bfd_vma off;
		      unsigned char opc;
d8489 8
a8496 3
		      switch (r_type)
			{
			case R_PPC64_TOC16_HA:
d8498 1
d8500 6
a8505 12
			case R_PPC64_TOC16_LO_DS:
			  off = rel->r_offset;
			  off += (bfd_big_endian (ibfd) ? -2 : 3);
			  if (!bfd_get_section_contents (ibfd, sec, &opc,
							 off, 1))
			    {
			      free (used);
			      goto error_ret;
			    }
			  if ((opc & (0x3f << 2)) == (58u << 2))
			    break;
			  /* Fall thru */
d8507 9
a8515 6
			default:
			  /* Wrong sort of reloc, or not a ld.  We may
			     as well clear ref_from_discarded too.  */
			  skip[val >> 3] = 0;
			}
		    }
d8517 2
a8518 15
		  if (sec != toc)
		    used[val >> 3] = 1;
		  /* For the toc section, we only mark as used if this
		     entry itself isn't unused.  */
		  else if ((used[rel->r_offset >> 3]
			    || !(skip[rel->r_offset >> 3] & ref_from_discarded))
			   && !used[val >> 3])
		    {
		      /* Do all the relocs again, to catch reference
			 chains.  */
		      repeat = 1;
		      used[val >> 3] = 1;
		    }
		}
	    }
d9647 2
a9648 2
      if (pltindex > 32768)
	glinkoff += (pltindex - 32768) * 4;
a11296 1
      && !(isec->output_section->flags & SEC_KEEP)
a11326 2
  if (plt_thread_safe == -1 && !info->executable)
    plt_thread_safe = 1;
d11329 1
a11329 1
      static const char *const thread_starter[] =
@


1.390.4.5
log
@	* elf64-ppc.c (build_plt_stub): Correct plt stub branch to glink.

	2013-01-28  Alan Modra  <amodra@@gmail.com>
	* elf64-ppc.c: Use %T to print symbols names and remove redundant
	"relocation" in error messages throughout file.
	(ppc64_elf_relocate_section): Remove sibling call error message,
	replace with "call lacks nop".  Specially report errors for
	branches to function entry points via OPD lookup and branches
	to stubs.  Remove NULL symbol handling now done by %T.
@
text
@d6611 1
a6611 1
	(_("%P: copy reloc against `%T' requires lazy plt linking; "
d8666 1
a8666 1
			    (_("%P: %H: %s references "
d9772 1
a9772 1
      bfd_put_32 (obfd, B_DOT | (cmp_branch_off & 0x3fffffc), p), p += 4;
d9873 1
a9873 1
	  info->callbacks->einfo (_("%P: cannot find opd entry toc for `%T'\n"),
d9955 2
a9956 3
	  info->callbacks->einfo
	    (_("%P: long branch stub `%s' offset overflow\n"),
	     stub_entry->root.string);
d10076 1
a10076 1
	    (_("%P: linkage table error against `%T'\n"),
d10219 1
a10219 1
	    (_("%P: linkage table error against `%T'\n"),
a12275 1
      enum { DEST_NORMAL, DEST_OPD, DEST_STUB } reloc_dest;
d12433 2
a12434 2
	       ? _("%P: %H: %s used with TLS symbol `%T'\n")
	       : _("%P: %H: %s used with non-TLS symbol `%T'\n"),
a12839 1
      reloc_dest = DEST_NORMAL;
d12945 19
a12963 5
		      info->callbacks->einfo
			(_("%P: %H: call to `%T' lacks nop, can't restore toc; "
			   "recompile with -fPIC"),
			   input_bfd, input_section, rel->r_offset, sym_name);

a12988 1
		  reloc_dest = DEST_OPD;
a13015 1
	      reloc_dest = DEST_STUB;
d13073 1
a13073 1
	    (_("%P: %B: unknown relocation type %d for `%T'\n"),
d13583 2
a13584 2
			    (_("%P: %H: %s for indirect "
			       "function `%T' unsupported\n"),
d13688 1
a13688 1
	    (_("%P: %B: %s is not supported for `%T'\n"),
d13858 1
a13858 1
	    (_("%P: %H: unresolvable %s against `%T'\n"),
d13875 2
a13876 15
	  char *more_info = NULL;
	  const char *reloc_name = ppc64_elf_howto_table[r_type]->name;

	  if (reloc_dest != DEST_NORMAL)
	    {
	      more_info = bfd_malloc (strlen (reloc_name) + 8);
	      if (more_info != NULL)
		{
		  strcpy (more_info, reloc_name);
		  strcat (more_info, (reloc_dest == DEST_OPD
				      ? " (OPD)" : " (stub)"));
		  reloc_name = more_info;
		}
	    }

d13895 4
a13898 3
		    (info, &h->elf.root, sym_name,
		     reloc_name, orig_rel.r_addend,
		     input_bfd, input_section, rel->r_offset)))
d13904 1
a13904 1
		(_("%P: %H: %s against `%T': error %d\n"),
d13906 3
a13908 1
		 reloc_name, sym_name, (int) r);
a13910 2
	  if (more_info != NULL)
	    free (more_info);
@


1.390.4.6
log
@	* elf64-ppc.c (dec_dynrel_count): Don't error when elf_gc_sweep_symbol
	clears def_regular.
@
text
@d7056 6
a7063 7
  /* elf_gc_sweep may have already removed all dyn relocs associated
     with local syms for a given section.  Also, symbol flags are
     changed by elf_gc_sweep_symbol, confusing the test above.  Don't
     report a dynreloc miscount.  */
  if (*pp == NULL && info->gc_sections)
    return TRUE;

@


1.389
log
@	* elf64-ppc.c (ppc64_elf_next_toc_section): Don't error if input
	file has multiple .got/.toc sections and all don't fit in
	current toc group.
@
text
@d4311 1
a4311 1
      htab->got = bfd_get_section_by_name (htab->elf.dynobj, ".got");
d4350 4
a4353 4
    htab->got = bfd_get_section_by_name (dynobj, ".got");
  htab->plt = bfd_get_section_by_name (dynobj, ".plt");
  htab->relplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->dynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d4355 1
a4355 1
    htab->relbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d9143 1
a9143 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d14039 1
a14039 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.388
log
@	* elf64-ppc.c (ppc64_elf_func_desc_adjust): Don't emit out-of-line
	save/restore functions when relocatable.  Make "funcs" static.
@
text
@d10557 3
a10559 1
      if (htab->toc_bfd != isec->owner)
d10587 2
a10588 1
      if (elf_gp (isec->owner) != 0
@


1.387
log
@	PR binutils/13897
	* elf.c (elf_find_function): Cache last function sym info.
	(_bfd_elf_maybe_function_sym): Return function size, pass in
	section of interest.
	* elf-bfd.h (struct elf_backend_data <maybe_function_sym>): Likewise.
	(_bfd_elf_maybe_function_sym): Likewise.
	* elf64-ppc.c (ppc64_elf_maybe_function_sym): Likewise.
	(opd_entry_value): Add in_code_sec param.  Revert caching code.
	Return -1 if in_code_sec and function found in wrong section.
	Update all calls.
@
text
@d6471 1
a6471 1
  const struct sfpr_def_parms funcs[] =
d6497 4
a6500 3
  for (i = 0; i < sizeof (funcs) / sizeof (funcs[0]); i++)
    if (!sfpr_define (info, &funcs[i]))
      return FALSE;
@


1.386
log
@	PR binutils/13897
	* elf64-ppc.c (opd_entry_value): Rewrite cache code.
@
text
@d58 1
a58 1
  (asection *, bfd_vma, asection **, bfd_vma *);
d2350 1
a2350 1
				      NULL, NULL);
d5525 2
a5526 1
		 bfd_vma *code_off)
d5537 11
a5547 18
      static asection *last_opd_sec, *last_code_sec;
      static bfd_vma last_opd_off, last_entry_vma;
      static bfd_boolean sec_search_done;

      if (last_opd_sec != opd_sec
	  || last_opd_off != offset
	  || (code_sec != NULL && !sec_search_done))
	{
	  char buf[8];

	  if (!bfd_get_section_contents (opd_bfd, opd_sec, buf, offset, 8))
	    return (bfd_vma) -1;

	  last_opd_sec = opd_sec;
	  last_opd_off = offset;
	  last_entry_vma = bfd_get_64 (opd_bfd, buf);
	  sec_search_done = FALSE;
	  if (code_sec != NULL)
d5549 19
a5567 16
	      asection *sec;

	      sec_search_done = TRUE;
	      last_code_sec = NULL;
	      for (sec = opd_bfd->sections; sec != NULL; sec = sec->next)
		if (sec->vma <= last_entry_vma
		    && (sec->flags & SEC_LOAD) != 0
		    && (sec->flags & SEC_ALLOC) != 0)
		  last_code_sec = sec;
	    }
	}
      if (code_sec != NULL && last_code_sec != NULL)
	{
	  *code_sec = last_code_sec;
	  if (code_off != NULL)
	    *code_off = last_entry_vma - last_code_sec->vma;
d5569 1
a5569 1
      return last_entry_vma;
d5640 6
a5645 1
		*code_sec = sec;
d5656 17
a5672 2
/* Return TRUE iff the ELF symbol SYM might be a function.  Set *CODE_SEC
   and *CODE_OFF to the function's entry point.  */
d5674 21
a5694 5
static bfd_boolean
ppc64_elf_maybe_function_sym (const asymbol *sym,
			      asection **code_sec, bfd_vma *code_off)
{
  if (_bfd_elf_maybe_function_sym (sym, code_sec, code_off))
d5696 3
a5698 3
      if (strcmp (sym->section->name, ".opd") == 0)
	opd_entry_value (sym->section, sym->value, code_sec, code_off);
      return TRUE;
d5700 3
a5702 1
  return FALSE;
d5782 1
a5782 1
				   &sec, NULL) != (bfd_vma) -1)
d5833 1
a5833 1
				   &code_sec, NULL) != (bfd_vma) -1)
d5893 1
a5893 1
					   &rsec, NULL) != (bfd_vma) -1)
d6362 1
a6362 1
			  &fh->elf.root.u.def.value) != (bfd_vma) -1)
d10953 2
a10954 1
	      dest = opd_entry_value (sym_sec, sym_value, &sym_sec, NULL);
d11529 1
a11529 1
					      &code_sec, &code_value);
d12943 1
a12943 1
	      bfd_vma dest = opd_entry_value (sec, off, NULL, NULL);
@


1.385
log
@	PR ld/13909
	* elf-eh-frame.c (_bfd_elf_eh_frame_present): New function.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Use it here.
	* elf-bfd.h (_bfd_elf_eh_frame_present): Declare.
	* elflink.c (bfd_elf_size_dynamic_sections): Let the backend
	size dynamic sections before stripping eh_frame_hdr.
	(bfd_elf_gc_sections): Handle multiple .eh_frame sections.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Drop glink_eh_frame
	if no other .eh_frame sections exist.
	* elf64-ppc.c (ppc64_elf_size_stubs): Likewise.
	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_i386_size_dynamic_sections): ..do it here instead.  Don't
	specially keep sgotplt, iplt, tgotplt, sdynbss for symbols.
	(elf_i386_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_x86_64_size_dynamic_sections): ..do it here instead.
	(elf_x86_64_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
@
text
@d5536 17
a5552 8
      /* PR 13897: Cache the loaded section to speed up the search.  */
      static asection * buf_sec = NULL;
      static char       buf[8];
      static bfd_vma    buf_val = 0;
      static asection * buf_likely = NULL;
      
      if (buf_sec == opd_sec)
	{
a5553 22
	    * code_sec = buf_likely;
	  if (code_off != NULL && buf_likely != NULL)
	    * code_off = buf_val - buf_likely->vma;
	  return buf_val;
	}
   
      if (!bfd_get_section_contents (opd_bfd, opd_sec, buf, offset, 8))
	return (bfd_vma) -1;
      buf_sec = opd_sec;

      buf_val = bfd_get_64 (opd_bfd, buf);
      if (code_sec != NULL)
	{
	  asection *sec;

	  buf_likely = NULL;
	  for (sec = opd_bfd->sections; sec != NULL; sec = sec->next)
	    if (sec->vma <= buf_val
		&& (sec->flags & SEC_LOAD) != 0
		&& (sec->flags & SEC_ALLOC) != 0)
	      buf_likely = sec;
	  if (buf_likely != NULL)
d5555 16
a5570 4
	      *code_sec = buf_likely;
	      if (code_off != NULL)
		*code_off = buf_val - buf_likely->vma;
	    }
d5572 1
a5572 3
      else
	buf_likely = NULL;
      return buf_val;
@


1.384
log
@	PR ld/14158
	* elf64-ppc.c (ppc64_elf_size_stubs): Round up glink_eh_frame
	size to output section alignment.
	(ppc64_elf_build_stubs): Likewise, and extend last FDE to cover.
@
text
@d11665 1
a11665 1
	  && (htab->glink_eh_frame->flags & SEC_EXCLUDE) == 0)
@


1.383
log
@bfd/
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Don't make _DYNAMIC,
	_GLOBAL_OFFSET_TABLE_ or _PROCEDURE_LINKAGE_TABLE_ absolute.
	* elf64-ppc.c (ppc64_elf_finish_dynamic_symbol): Don't make _DYNAMIC
	absolute.
ld/testsuite/
	* ld-powerpc/tlsso.r: Update for dynamic sym changes.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
@
text
@d11667 1
a11667 1
	  bfd_size_type size = 0;
d11678 4
d11923 2
d11930 1
d11936 2
a11937 1
      bfd_put_32 (htab->elf.dynobj, sizeof (glink_eh_frame_cie) - 4, p);
d11945 2
d11979 2
d12018 10
a12027 1
      htab->glink_eh_frame->size = p - htab->glink_eh_frame->contents;
@


1.382
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@d13872 1
a13872 1
				 Elf_Internal_Sym *sym)
a13940 4
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0)
    sym->st_shndx = SHN_ABS;

@


1.381
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d4248 1
a4248 1
	  || !bfd_set_section_alignment (abfd, htab->glink_eh_frame, 2))
@


1.380
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d12278 2
a12279 2
					 rel, relend,
					 ppc64_elf_howto_table[r_type],
@


1.379
log
@	PR binutils/13897
	* elf64-ppc.c (opd_entry_value): When dealing with sections
	without relocs, keep the last section loaded in order to avoid
	unnecessary reloads.
@
text
@d6901 1
a6901 1
		if (elf_discarded_section (dsec))
d7082 1
a7082 1
      if (sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d8126 2
a8127 2
	  || toc->sec_info_type == ELF_INFO_TYPE_JUST_SYMS
	  || elf_discarded_section (toc))
d8140 1
a8140 1
	      || !elf_discarded_section (sec)
d8250 1
a8250 1
		  || elf_discarded_section (sym_sec))
d8330 1
a8330 1
	      || elf_discarded_section (sec)
d8552 1
a8552 1
		  || elf_discarded_section (sec))
d12276 1
a12276 1
      if (sec != NULL && elf_discarded_section (sec))
d14113 1
a14113 1
      && htab->glink_eh_frame->sec_info_type == ELF_INFO_TYPE_EH_FRAME
@


1.378
log
@	PR binutils/13894
	* elf64-ppc.c (opd_entry_value): Read full symbol table when
	sym hashes unavailable.
@
text
@d5536 15
a5550 2
      char buf[8];

d5553 1
d5555 1
a5555 1
      val = bfd_get_64 (opd_bfd, buf);
d5558 3
a5560 1
	  asection *sec, *likely = NULL;
d5562 1
a5562 1
	    if (sec->vma <= val
d5565 2
a5566 2
	      likely = sec;
	  if (likely != NULL)
d5568 1
a5568 1
	      *code_sec = likely;
d5570 1
a5570 1
		*code_off = val - likely->vma;
d5573 3
a5575 1
      return val;
@


1.377
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d5588 2
a5589 1
	      if (symndx < symtab_hdr->sh_info)
d5596 4
a5599 2
		      sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr,
						  symtab_hdr->sh_info,
@


1.376
log
@	* elf.c (elf_find_function): Don't use internal_elf_sym.
	(_bfd_elf_maybe_function_sym): Likewise.  Replace elf_symbol_type
	parameter with asymbol.
	* elf64-ppc.c (ppc64_elf_maybe_function_sym): Likewise.
	* elf-bfd.h (_bfd_elf_maybe_function_sym): Update prototype.
	(struct elf_backend_data <maybe_function_sym>): Likewise.
@
text
@a6564 7
  if (h->size == 0)
    {
      info->callbacks->einfo (_("%P: dynamic variable `%s' is zero size\n"),
			      h->root.root.string);
      return TRUE;
    }

d6579 1
a6579 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.375
log
@	* elf-bfd.h: Formatting.
	(struct elf_backend_data): Add "maybe_function_sym".
	(_bfd_elf_maybe_function_sym): Declare.
	* elfxx-target.h (elf_backend_maybe_function_sym): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_find_function): Use maybe_function_sym.
	(_bfd_elf_maybe_function_sym): New function.
	* elf64-ppc.c (elf_backend_maybe_function_sym): Define.
	(ppc64_elf_maybe_function_sym): New function.
@
text
@d5640 1
a5640 1
ppc64_elf_maybe_function_sym (const elf_symbol_type *sym,
d5645 2
a5646 3
      if (strcmp (sym->symbol.section->name, ".opd") == 0)
	opd_entry_value (sym->symbol.section, sym->symbol.value,
			 code_sec, code_off);
@


1.374
log
@	* elf32-ppc.c (ppc_elf_write_core_note <NT_PRPSINFO>): Don't leave
	trailing garbage in the note.
	* elf64-ppc.c (ppc64_elf_write_core_note <NT_PRPSINFO>): Likewise.
@
text
@d108 1
d5532 2
a5533 1
  /* No relocs implies we are linking a --just-symbols object.  */
d5636 17
@


1.373
log
@bfd/
	* elf64-ppc.c: Define more insns used in plt call stubs.
	(ppc64_elf_brtaken_reloc): Assume isa version 2 or above.
	(ppc64_elf_relocate_section): Likewise.
	(enum ppc_stub_type): Add ppc_stub_plt_call_r2save.
	(struct ppc_link_hash_table): Increase size of stub_count array.
	Add plt_stub_align and plt_thread_safe.
	(ALWAYS_USE_FAKE_DEP, ALWAYS_EMIT_R2SAVE): Define.
	(plt_stub_size, plt_stub_pad): New functions.
	(build_plt_stub): Emit barriers for power7 thread safety.  Don't
	emit needless save of r2.
	(build_tls_get_addr_stub): Adjust params.
	(ppc_build_one_stub): Handle ppc_stub_plt_call_r2save and aligning
	plt stubs.  Adjust build_*plt_stub calls.
	(ppc_size_one_stub): Similarly.
	(ppc64_elf_size_stubs): Accept plt_thread_safe and plt_stub_align
	params.  Choose default for plt_thread_safe based on existence of
	calls to thread creation functions.  Modify plt_call to
	plt_call_r2save when no tocsave reloc found.  Align tail of stub
	sections.
	(ppc64_elf_build_stubs): Align tail of stub sections.  Adjust
	output of stub statistics.
	(ppc64_elf_relocate_section): Handle ppc_stub_plt_call_r2save.
	* elf64-ppc.h (ppc64_elf_size_stubs): Update prototype.
ld/
	* emultempl/ppc64elf.em (PARSE_AND_LIST_PROLOGUE,
	PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS,
	PARSE_AND_LIST_ARGS_CASES): Handle --{no-,}plt-thread-safe and
	--{no-,}plt-align.
	(plt_thread_safe, plt_stub_align): New vars.
	(gld${EMULATION_NAME}_after_allocation): Pass them to
	ppc64_elf_size_stubs.  Align stub sections according to plt_stub_align.
	* ld.texinfo: Document new command line options, and an old
	undocumented option.
@
text
@d2724 1
a2724 1
	memset (data, 0, 40);
@


1.372
log
@	PR ld/13470
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
	change in 2011-07-01 commit.  Comment.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
@
text
@d3 1
a3 1
   2009, 2010, 2011 Free Software Foundation, Inc.
d155 7
d2366 2
a2367 2
  /* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
  bfd_boolean is_power4 = FALSE;
d2384 1
a2384 1
  if (is_power4)
d3594 2
a3595 1
  ppc_stub_plt_call
d3763 1
a3763 1
  unsigned long stub_count[ppc_stub_plt_call];
d3768 3
d3774 3
d9488 21
a9508 1
/* Build a .plt call stub.  */
a9509 4
static inline bfd_byte *
build_plt_stub (bfd *obfd, bfd_byte *p, int offset, Elf_Internal_Rela *r,
		bfd_boolean plt_static_chain)
{
d9514 87
d9605 3
a9607 1
	  r[0].r_offset += 4;
d9620 1
a9620 1
	      r[2].r_offset = r[1].r_offset + 8;
d9631 3
a9633 1
      bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d9642 5
a9649 1
      bfd_put_32 (obfd, BCTR, p),				p += 4;
d9655 3
a9657 1
	  r[0].r_offset += 4;
d9667 1
a9667 1
	      r[1].r_offset = r[0].r_offset + 8;
d9678 3
a9680 1
      bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d9688 5
a9695 1
      bfd_put_32 (obfd, BCTR, p),				p += 4;
d9697 8
d9725 3
a9727 2
build_tls_get_addr_stub (bfd *obfd, bfd_byte *p, int offset,
			 Elf_Internal_Rela *r, bfd_boolean plt_static_chain)
d9729 2
d9743 1
a9743 1
  p = build_plt_stub (obfd, p, offset, r, plt_static_chain);
d10090 1
d10157 9
d10185 1
a10185 2
	p = build_tls_get_addr_stub (htab->stub_bfd, loc, off, r,
				     htab->plt_static_chain);
d10187 1
a10187 2
	p = build_plt_stub (htab->stub_bfd, loc, off, r,
			    htab->plt_static_chain);
d10207 1
d10258 2
a10259 1
  if (stub_entry->stub_type == ppc_stub_plt_call)
d10275 3
a10277 12
      size = PLT_CALL_STUB_SIZE;
      if (!htab->plt_static_chain)
	size -= 4;
      if (PPC_HA (off) == 0)
	size -= 4;
      if (PPC_HA (off + 8 + 8 * htab->plt_static_chain) != PPC_HA (off))
	size += 4;
      if (stub_entry->h != NULL
	  && (stub_entry->h == htab->tls_get_addr_fd
	      || stub_entry->h == htab->tls_get_addr)
	  && !htab->no_tls_get_addr_opt)
	size += 13 * 4;
d11246 2
a11247 1
		      bfd_boolean plt_static_chain)
d11257 34
d11525 8
a11532 4
		      && ELF64_R_TYPE (irela[1].r_info) == R_PPC64_TOCSAVE
		      && !tocsave_find (htab, INSERT,
					&local_syms, irela + 1, input_bfd))
		    goto error_ret_free_internal;
d11548 2
d11569 2
a11570 1
		  if (stub_type != ppc_stub_plt_call)
d11650 8
d11983 8
d12024 2
a12025 1
			 "  plt call     %lu"),
d12032 2
a12033 1
	       htab->stub_count[ppc_stub_plt_call - 1]);
d12133 2
a12134 2
  /* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
  bfd_boolean is_power4 = FALSE;
d12766 1
d12795 2
a12796 1
		  if (stub_entry->stub_type == ppc_stub_plt_call)
d12843 2
a12844 1
		  && stub_entry->stub_type == ppc_stub_plt_call)
d12890 4
a12893 1
 	      if (stub_entry->stub_type == ppc_stub_plt_call
d12902 1
a12902 1
	      if (is_power4)
@


1.371
log
@	* config.bfd: Add vectors for powerpc and powerpc64-freebsd.
	* configure.in (TDEFINES): Add rules for powerpc*-freebsd.
	* configure: Regenerate.
	* elf32-ppc.c: Add powerpc-freebsd definitions.
	* elf64-ppc.c: Add powerpc64-freebsd definitions.
	* targets.c: Add bits for powerpc and powerpc64-freebsd.
@
text
@a4437 4
  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

d4470 10
@


1.370
log
@bfd/
	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Rename
	ha_relocs_not_using_r2 to unexpected_toc_insn.
	(ok_lo_toc_insn): New function.
	(ppc64_elf_edit_toc): Check insn on lo toc reloc.  Emit warning.
	(ppc64_elf_relocate_section): Don't check insn on lo toc reloc here.
	Handle addic on lo toc reloc.
ld/testsuite/
	* ld-powerpc/powerpc.exp: Expect ld warnings for tocopt test.
	* ld-powerpc/tocopt.out: New file.
@
text
@d13902 19
@


1.369
log
@	PR ld/13049
	* elf64-ppc.c (STUB_SUFFIX): Revert previous delta.
	* elf32-hppa.c (STUB_SUFFIX): Likewise.
@
text
@d2617 3
a2619 2
  /* Set if toc/got ha relocs detected not using r2.  */
  unsigned int ha_relocs_not_using_r2 : 1;
d8020 26
d8300 1
d8306 1
d8315 2
a8316 4
		    {
		      bfd_vma off = rel->r_offset & ~3;
		      unsigned char buf[4];
		      unsigned int insn;
d8318 9
a8326 10
		      if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
			{
			  free (used);
			  goto error_ret;
			}
		      insn = bfd_get_32 (ibfd, buf);
		      if ((insn & ((0x3f << 26) | 0x1f << 16))
			  != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */)
			ppc64_elf_tdata (ibfd)->ha_relocs_not_using_r2 = 1;
		    }
d8330 28
d13379 1
a13379 1
	      && !ppc64_elf_tdata (input_bfd)->ha_relocs_not_using_r2)
d13395 1
a13395 1
	      && !ppc64_elf_tdata (input_bfd)->ha_relocs_not_using_r2)
d13399 7
a13405 18
	      if ((insn & (0x3f << 26)) == 14u << 26 /* addi */
		  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
		  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
		  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
		  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
		  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
		  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
		  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
		  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
		  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
		  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
		  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
		  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
		  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
		  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
		      && (insn & 3) != 1)
		  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
		      && ((insn & 3) == 0 || (insn & 3) == 3)))
a13408 1
		  bfd_put_32 (input_bfd, insn, p);
d13410 1
@


1.368
log
@	PR ld/13049
	* elf32-arm.c (STUB_SUFFIX): Avoid collision with user namespace
	symbol names.
	* elf64-ppc.c (STUB_SUFFIX): Likewise.
	* elf32-hppa.c (STUB_SUFFIX): Likewise.
@
text
@d3530 2
a3531 2
   string.  PR 13049: Use a name that is not a valid C identifier.  */
#define STUB_SUFFIX ".__stub"
@


1.367
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d3530 2
a3531 2
   string.  */
#define STUB_SUFFIX ".stub"
@


1.366
log
@	PR ld/12975
	PR ld/13195
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref): Apply 2011-09-15
	and 2011-09-29 bfd_elf_gc_mark_dynamic_ref_symbol changes here too.
@
text
@d13462 3
a13464 1
	       && h->elf.def_dynamic))
@


1.365
log
@include/elf/
	* ppc64.h (R_PPC64_TOCSAVE): Add.
bfd/
	* elf64-ppc.c (ppc64_elf_howto_table): Add R_PPC64_TOCSAVE entry.
	(struct ppc_link_hash_table): Add tocsave_htab.
	(struct tocsave_entry): New.
	(tocsave_htab_hash, tocsave_htab_eq, tocsave_find): New functions.
	(ppc64_elf_link_hash_table_create): Create tocsave_htab..
	(ppc64_elf_link_hash_table_free): ..and delete it.
	(build_plt_stub): Always put STD_R2_40R1 first.
	(ppc64_elf_size_stubs): Check for R_PPC64_TOCSAVE following reloc
	on plt call.  If present add prologue nop location to tocsave_htab.
	(ppc64_elf_relocate_section): Convert prologue nop to std.  Skip
	first insn of plt call stub when R_PPC64_TOCSAVE present.
@
text
@d5720 4
a5723 1
	      && ELF_ST_VISIBILITY (eh->elf.other) != STV_HIDDEN)))
@


1.364
log
@	PR ld/13235
bfd/
	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add ha_relocs_not_using_r2.
	(ppc64_elf_edit_toc): Check HA relocs.
	(ha_reloc_match): Delete function.
	(ppc64_elf_relocate_section): Remove delayed HA nop optimization.
	Instead do it and low part optimization based on
	ha_relocs_not_using_r2.
ld/testsuite/
	* ld-powerpc/tocopt.d: Update.
	* ld-powerpc/tocopt5.d, * ld-powerpc/tocopt5.s: New test.
	* ld-powerpc/powerpc.exp: Run new test.
@
text
@d1285 14
d3694 3
d3943 20
d3993 7
d4021 1
a4021 1
  struct ppc_link_hash_table *ret = (struct ppc_link_hash_table *) hash;
d4023 4
a4026 2
  bfd_hash_table_free (&ret->stub_hash_table);
  bfd_hash_table_free (&ret->branch_hash_table);
d6763 49
d9425 1
d9427 1
a9427 1
	  r[1].r_offset = r[0].r_offset + 8;
d9449 1
a9450 1
      bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d11279 8
d12451 15
d12618 6
d12683 1
@


1.363
log
@	PR ld/13131
	* bfd/elf64-ppc.c (adjust_toc_syms): Ensure ppc64_elf_howto_table
	is initialized.
@
text
@d2601 4
a2604 1
  unsigned int has_small_toc_reloc;
d8179 29
d8255 4
a8258 1
			  return FALSE;
a11710 57
/* REL points to a low-part reloc on a largetoc instruction sequence.
   Find the matching high-part reloc instruction and verify that it
   is addis REG,x,imm.  If so, set *REG to x and return a pointer to
   the high-part reloc.  */

static const Elf_Internal_Rela *
ha_reloc_match (const Elf_Internal_Rela *relocs,
		const Elf_Internal_Rela *rel,
		unsigned int *reg,
		bfd_boolean match_addend,
		const bfd *input_bfd,
		const bfd_byte *contents)
{
  enum elf_ppc64_reloc_type r_type, r_type_ha;
  bfd_vma r_info_ha, r_addend;

  r_type = ELF64_R_TYPE (rel->r_info);
  switch (r_type)
    {
    case R_PPC64_GOT_TLSLD16_LO:
    case R_PPC64_GOT_TLSGD16_LO:
    case R_PPC64_GOT_TPREL16_LO_DS:
    case R_PPC64_GOT_DTPREL16_LO_DS:
    case R_PPC64_GOT16_LO:
    case R_PPC64_TOC16_LO:
      r_type_ha = r_type + 2;
      break;
    case R_PPC64_GOT16_LO_DS:
      r_type_ha = R_PPC64_GOT16_HA;
      break;
    case R_PPC64_TOC16_LO_DS:
      r_type_ha = R_PPC64_TOC16_HA;
      break;
    default:
      abort ();
    }
  r_info_ha = ELF64_R_INFO (ELF64_R_SYM (rel->r_info), r_type_ha);
  r_addend = rel->r_addend;

  while (--rel >= relocs)
    if (rel->r_info == r_info_ha
	&& (!match_addend
	    || rel->r_addend == r_addend))
      {
	const bfd_byte *p = contents + (rel->r_offset & ~3);
	unsigned int insn = bfd_get_32 (input_bfd, p);
	if ((insn & (0x3f << 26)) == (15u << 26) /* addis rt,x,imm */
	    && (insn & (0x1f << 21)) == (*reg << 21))
	  {
	    *reg = (insn >> 16) & 0x1f;
	    return rel;
	  }
	break;
      }
  return NULL;
}

a11757 1
  unsigned char *ha_opt;
a11758 1
  bfd_boolean no_ha_opt;
a11783 2
  ha_opt = NULL;
  no_ha_opt = FALSE;
d13195 6
a13200 1
	  /* nop is done later.  */
d13211 2
a13212 1
	  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000)
d13235 3
a13237 26
		  unsigned int reg = (insn >> 16) & 0x1f;
		  const Elf_Internal_Rela *ha;
		  bfd_boolean match_addend;

		  match_addend = (sym != NULL
				  && ELF_ST_TYPE (sym->st_info) == STT_SECTION);
		  ha = ha_reloc_match (relocs, rel, &reg, match_addend,
				       input_bfd, contents);
		  if (ha != NULL)
		    {
		      insn &= ~(0x1f << 16);
		      insn |= reg << 16;
		      bfd_put_32 (input_bfd, insn, p);
		      if (ha_opt == NULL)
			{
			  ha_opt = bfd_zmalloc (input_section->reloc_count);
			  if (ha_opt == NULL)
			    return FALSE;
			}
		      ha_opt[ha - relocs] = 1;
		    }
		  else
		    /* If we don't find a matching high part insn,
		       something is fishy.  Refuse to nop any high
		       part insn in this section.  */
		    no_ha_opt = TRUE;
a13390 17
  if (ha_opt != NULL)
    {
      if (!no_ha_opt)
	{
	  unsigned char *opt = ha_opt;
	  rel = relocs;
	  relend = relocs + input_section->reloc_count;
	  for (; rel < relend; opt++, rel++)
	    if (*opt != 0)
	      {
		bfd_byte *p = contents + (rel->r_offset & ~3);
		bfd_put_32 (input_bfd, NOP, p);
	      }
	}
      free (ha_opt);
    }

@


1.363.2.1
log
@	PR ld/13235
	Apply mainline patches
bfd/
	2011-09-30  Alan Modra  <amodra@@gmail.com>
	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add ha_relocs_not_using_r2.
	(ppc64_elf_edit_toc): Check HA relocs.
	(ha_reloc_match): Delete function.
	(ppc64_elf_relocate_section): Remove delayed HA nop optimization.
	Instead do it and low part optimization based on
	ha_relocs_not_using_r2.
ld/testsuite/
	2011-09-30  Alan Modra  <amodra@@gmail.com>
	* ld-powerpc/tocopt.d: Update.
	* ld-powerpc/tocopt5.d, * ld-powerpc/tocopt5.s: New test.
	* ld-powerpc/powerpc.exp: Run new test.
@
text
@d2601 1
a2601 4
  unsigned int has_small_toc_reloc : 1;

  /* Set if toc/got ha relocs detected not using r2.  */
  unsigned int ha_relocs_not_using_r2 : 1;
a8175 29
		  default:
		    break;

		  case R_PPC64_GOT_TLSLD16_HA:
		  case R_PPC64_GOT_TLSGD16_HA:
		  case R_PPC64_GOT_TPREL16_HA:
		  case R_PPC64_GOT_DTPREL16_HA:
		  case R_PPC64_GOT16_HA:
		  case R_PPC64_TOC16_HA:
		    {
		      bfd_vma off = rel->r_offset & ~3;
		      unsigned char buf[4];
		      unsigned int insn;

		      if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
			{
			  free (used);
			  goto error_ret;
			}
		      insn = bfd_get_32 (ibfd, buf);
		      if ((insn & ((0x3f << 26) | 0x1f << 16))
			  != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */)
			ppc64_elf_tdata (ibfd)->ha_relocs_not_using_r2 = 1;
		    }
		    break;
		  }

		switch (r_type)
		  {
d8223 1
a8223 4
			  {
			    free (used);
			    goto error_ret;
			  }
d11676 57
d11780 1
d11782 1
d11808 2
d13221 1
a13221 6
	  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000
	      && !ppc64_elf_tdata (input_bfd)->ha_relocs_not_using_r2)
	    {
	      bfd_byte *p = contents + (rel->r_offset & ~3);
	      bfd_put_32 (input_bfd, NOP, p);
	    }
d13232 1
a13232 2
	  if (htab->do_toc_opt && relocation + addend + 0x8000 < 0x10000
	      && !ppc64_elf_tdata (input_bfd)->ha_relocs_not_using_r2)
d13255 26
a13280 3
		  insn &= ~(0x1f << 16);
		  insn |= 2 << 16;
		  bfd_put_32 (input_bfd, insn, p);
d13434 17
@


1.363.2.2
log
@bfd/
	2011-10-10  Alan Modra  <amodra@@gmail.com>
	* elf64-ppc.c (ppc64_elf_howto_table): Add R_PPC64_TOCSAVE entry.
	(struct ppc_link_hash_table): Add tocsave_htab.
	(struct tocsave_entry): New.
	(tocsave_htab_hash, tocsave_htab_eq, tocsave_find): New functions.
	(ppc64_elf_link_hash_table_create): Create tocsave_htab..
	(ppc64_elf_link_hash_table_free): ..and delete it.
	(build_plt_stub): Always put STD_R2_40R1 first.
	(ppc64_elf_size_stubs): Check for R_PPC64_TOCSAVE following reloc
	on plt call.  If present add prologue nop location to tocsave_htab.
	(ppc64_elf_relocate_section): Convert prologue nop to std.  Skip
	first insn of plt call stub when R_PPC64_TOCSAVE present.
include/elf/
	2011-10-10  Alan Modra  <amodra@@gmail.com>
	* ppc64.h (R_PPC64_TOCSAVE): Add.
@
text
@a1284 14
  HOWTO (R_PPC64_TOCSAVE,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TOCSAVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

a3679 3
  /* Hash table for function prologue tocsave.  */
  htab_t tocsave_htab;

a3925 20
struct tocsave_entry {
  asection *sec;
  bfd_vma offset;
};

static hashval_t
tocsave_htab_hash (const void *p)
{
  const struct tocsave_entry *e = (const struct tocsave_entry *) p;
  return ((bfd_vma)(intptr_t) e->sec ^ e->offset) >> 3;
}

static int
tocsave_htab_eq (const void *p1, const void *p2)
{
  const struct tocsave_entry *e1 = (const struct tocsave_entry *) p1;
  const struct tocsave_entry *e2 = (const struct tocsave_entry *) p2;
  return e1->sec == e2->sec && e1->offset == e2->offset;
}

a3955 7
  htab->tocsave_htab = htab_try_create (1024,
					tocsave_htab_hash,
					tocsave_htab_eq,
					NULL);
  if (htab->tocsave_htab == NULL)
    return NULL;

d3977 1
a3977 1
  struct ppc_link_hash_table *htab = (struct ppc_link_hash_table *) hash;
d3979 2
a3980 4
  bfd_hash_table_free (&htab->stub_hash_table);
  bfd_hash_table_free (&htab->branch_hash_table);
  if (htab->tocsave_htab)
    htab_delete (htab->tocsave_htab);
a6716 49
/* Find (or create) an entry in the tocsave hash table.  */

static struct tocsave_entry *
tocsave_find (struct ppc_link_hash_table *htab,
	      enum insert_option insert,
	      Elf_Internal_Sym **local_syms,
	      const Elf_Internal_Rela *irela,
	      bfd *ibfd)
{
  unsigned long r_indx;
  struct elf_link_hash_entry *h;
  Elf_Internal_Sym *sym;
  struct tocsave_entry ent, *p;
  hashval_t hash;
  struct tocsave_entry **slot;

  r_indx = ELF64_R_SYM (irela->r_info);
  if (!get_sym_h (&h, &sym, &ent.sec, NULL, local_syms, r_indx, ibfd))
    return NULL;
  if (ent.sec == NULL || ent.sec->output_section == NULL)
    {
      (*_bfd_error_handler)
	(_("%B: undefined symbol on R_PPC64_TOCSAVE relocation"));
      return NULL;
    }

  if (h != NULL)
    ent.offset = h->root.u.def.value;
  else
    ent.offset = sym->st_value;
  ent.offset += irela->r_addend;

  hash = tocsave_htab_hash (&ent);
  slot = ((struct tocsave_entry **)
	  htab_find_slot_with_hash (htab->tocsave_htab, &ent, hash, insert));
  if (slot == NULL)
    return NULL;

  if (*slot == NULL)
    {
      p = (struct tocsave_entry *) bfd_alloc (ibfd, sizeof (*p));
      if (p == NULL)
	return NULL;
      *p = ent;
      *slot = p;
    }
  return *slot;
}

a9329 1
	  r[0].r_offset += 4;
d9331 1
a9331 1
	  r[1].r_offset = r[0].r_offset + 4;
d9353 1
a9354 1
      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (offset), p),	p += 4;
a11182 8
		  if (stub_type == ppc_stub_plt_call
		      && irela + 1 < irelaend
		      && irela[1].r_offset == irela->r_offset + 4
		      && ELF64_R_TYPE (irela[1].r_info) == R_PPC64_TOCSAVE
		      && !tocsave_find (htab, INSERT,
					&local_syms, irela + 1, input_bfd))
		    goto error_ret_free_internal;

a12346 15
	case R_PPC64_TOCSAVE:
	  if (relocation + addend == (rel->r_offset
				      + input_section->output_offset
				      + input_section->output_section->vma)
	      && tocsave_find (htab, NO_INSERT,
			       &local_syms, rel, input_bfd))
	    {
	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if (insn == NOP
		  || insn == CROR_151515 || insn == CROR_313131)
		bfd_put_32 (input_bfd, STD_R2_40R1,
			    contents + rel->r_offset);
	    }
	  break;

a12498 6

 	      if (stub_entry->stub_type == ppc_stub_plt_call
		  && rel + 1 < relend
		  && rel[1].r_offset == rel->r_offset + 4
		  && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)
		relocation += 4;
a12557 1
	case R_PPC64_TOCSAVE:
@


1.363.2.3
log
@	PR ld/12975
	PR ld/13195
	2011-10-17  Alan Modra  <amodra@@gmail.com>
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref): Apply 2011-09-15
	and 2011-09-29 bfd_elf_gc_mark_dynamic_ref_symbol changes here too.
@
text
@d5720 1
a5720 4
	      && ELF_ST_VISIBILITY (eh->elf.other) != STV_HIDDEN
	      && (strchr (eh->elf.root.root.string, ELF_VER_CHR) != NULL
		  || !bfd_hide_sym_by_version (info->version_info,
					       eh->elf.root.root.string)))))
@


1.363.2.4
log
@bfd/
	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Rename
	ha_relocs_not_using_r2 to unexpected_toc_insn.
	(ok_lo_toc_insn): New function.
	(ppc64_elf_edit_toc): Check insn on lo toc reloc.  Emit warning.
	(ppc64_elf_relocate_section): Don't check insn on lo toc reloc here.
	Handle addic on lo toc reloc.
ld/testsuite/
	* ld-powerpc/powerpc.exp: Expect ld warnings for tocopt test.
	* ld-powerpc/tocopt.out: New file.
@
text
@d2617 2
a2618 3
  /* Set if toc/got ha relocs detected not using r2, or lo reloc
     instruction not one we handle.  */
  unsigned int unexpected_toc_insn : 1;
a8018 26
/* Return TRUE iff INSN is one we expect on a _LO variety toc/got reloc.  */

static bfd_boolean
ok_lo_toc_insn (unsigned int insn)
{
  return ((insn & (0x3f << 26)) == 14u << 26 /* addi */
	  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
	  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
	  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
	  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
	  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
	  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
	  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
	  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
	  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
	  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
	  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
	  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
	  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
	  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
	      && (insn & 3) != 1)
	  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
	      && ((insn & 3) == 0 || (insn & 3) == 3))
	  || (insn & (0x3f << 26)) == 12u << 26 /* addic */);
}

a8272 1
		enum {no_check, check_lo, check_ha} insn_check;
a8277 1
		    insn_check = no_check;
d8286 4
a8289 2
		    insn_check = check_ha;
		    break;
d8291 10
a8300 9
		  case R_PPC64_GOT_TLSLD16_LO:
		  case R_PPC64_GOT_TLSGD16_LO:
		  case R_PPC64_GOT_TPREL16_LO_DS:
		  case R_PPC64_GOT_DTPREL16_LO_DS:
		  case R_PPC64_GOT16_LO:
		  case R_PPC64_GOT16_LO_DS:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TOC16_LO_DS:
		    insn_check = check_lo;
a8303 28
		if (insn_check != no_check)
		  {
		    bfd_vma off = rel->r_offset & ~3;
		    unsigned char buf[4];
		    unsigned int insn;

		    if (!bfd_get_section_contents (ibfd, sec, buf, off, 4))
		      {
			free (used);
			goto error_ret;
		      }
		    insn = bfd_get_32 (ibfd, buf);
		    if (insn_check == check_lo
			? !ok_lo_toc_insn (insn)
			: ((insn & ((0x3f << 26) | 0x1f << 16))
			   != ((15u << 26) | (2 << 16)) /* addis rt,2,imm */))
		      {
			char str[12];

			ppc64_elf_tdata (ibfd)->unexpected_toc_insn = 1;
			sprintf (str, "%#08x", insn);
			info->callbacks->einfo
			  (_("%P: %H: toc optimization is not supported for"
			     " %s instruction.\n"),
			   ibfd, sec, rel->r_offset & ~3, str);
		      }
		  }

d13325 1
a13325 1
	      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn)
d13341 1
a13341 1
	      && !ppc64_elf_tdata (input_bfd)->unexpected_toc_insn)
d13345 18
a13362 7
	      if ((insn & (0x3f << 26)) == 12u << 26 /* addic */)
		{
		  /* Transform addic to addi when we change reg.  */
		  insn &= ~((0x3f << 26) | (0x1f << 16));
		  insn |= (14u << 26) | (2 << 16);
		}
	      else
d13366 1
a13367 1
	      bfd_put_32 (input_bfd, insn, p);
@


1.363.2.5
log
@	PR ld/13470
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
	change in 2011-07-01 commit.  Comment.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
@
text
@d4438 4
a4473 10
  /* If we were called to copy over info for a weak sym, that's all.
     You might think dyn_relocs need not be copied over;  After all,
     both syms will be dynamic or both non-dynamic so we're just
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
     code in ppc64_elf_adjust_dynamic_symbol needs to check for
     dyn_relocs in read-only sections, and it does so on what is the
     DIR sym here.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

@


1.363.2.6
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d6855 1
a6855 1
		if (discarded_section (dsec))
d7036 1
a7036 1
      if (sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
d8080 2
a8081 2
	  || toc->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
	  || discarded_section (toc))
d8094 1
a8094 1
	      || !discarded_section (sec)
d8204 1
a8204 1
		  || discarded_section (sym_sec))
d8284 1
a8284 1
	      || discarded_section (sec)
d8506 1
a8506 1
		  || discarded_section (sec))
d12039 1
a12039 1
      if (sec != NULL && discarded_section (sec))
d13868 1
a13868 1
      && htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
@


1.362
log
@	PR ld/13131
	* elf64-ppc.c (adjust_toc_syms): Delete redundant code.
	(ppc64_elf_edit_toc): Fix style nit.  Report some details
	on linker failure due to reference in debug or non-alloc
	sections to optimized away toc entry, and don't abort.
@
text
@d8385 2
@


1.361
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Ignore can_optimize bit if
	we haven't seen expected -mcmodel=medium/large code relocs.
@
text
@a7883 3
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

d8267 1
a8267 1
	  else if (*drop & ref_from_discarded)
d8385 7
a8391 1
			  abort ();
@


1.360
log
@	* elf64-ppc.c: Prefix all einfo error strings with "%P: ".
	* elf32-ppc.c: Likewise.
	(ppc_elf_select_plt_layout): Use einfo rather than info to report
	forced bss-plt.
@
text
@d8270 1
a8270 1
	  else if (*drop)
@


1.359
log
@bfd/
	* elf64-ppc.c (maybe_strip_output): New function.
	(ppc64_elf_size_stubs): Use it to strip .branch_lt and .eh_frame.
ld/testsuite/
	* ld-powerpc/tlsexe.r: Update for stripped .branch_lt.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
@
text
@d4136 1
a4136 1
      info->callbacks->einfo (_("%B: cannot create stub entry %s\n"),
d6466 1
a6466 1
	(_("copy reloc against `%s' requires lazy plt linking; "
d6476 1
a6476 1
      info->callbacks->einfo (_("dynamic variable `%s' is zero size\n"),
d6891 1
a6891 1
  info->callbacks->einfo (_("dynreloc miscount for %B, section %A\n"),
d9459 1
a9459 1
	  info->callbacks->einfo (_("cannot find opd entry toc for %s\n"),
d9541 1
a9541 1
	  info->callbacks->einfo (_("long branch stub `%s' offset overflow\n"),
d9600 1
a9600 1
	  info->callbacks->einfo (_("can't find branch stub `%s'\n"),
d9662 1
a9662 1
	    (_("linkage table error against `%s'\n"),
d9804 1
a9804 1
	    (_("linkage table error against `%s'\n"),
d9987 1
a9987 1
	      info->callbacks->einfo (_("can't build branch stub `%s'\n"),
d11519 1
a11519 1
		  (_("%s offset too large for .eh_frame sdata4 encoding"),
d11552 1
a11552 1
		(_("%s offset too large for .eh_frame sdata4 encoding"),
d11597 1
a11597 1
      info->callbacks->einfo (_("stubs don't match calculated size\n"));
d11956 2
a11957 2
	       ? _("%H: %s used with TLS symbol %s\n")
	       : _("%H: %s used with non-TLS symbol %s\n"),
d12455 1
a12455 1
			  (_("%H: automatic multiple TOCs "
d12461 1
a12461 1
			  (_("%H: sibling call optimization to `%s' "
d12568 1
a12568 1
	    (_("%B: unknown relocation type %d for symbol %s\n"),
d13073 1
a13073 1
			    (_("%H: relocation %s for indirect "
d13178 1
a13178 1
	    (_("%B: relocation %s is not supported for symbol %s\n"),
d13355 1
a13355 1
		(_("%H: error: %s not a multiple of %u\n"),
d13374 1
a13374 1
	    (_("%H: unresolvable %s relocation against symbol `%s'\n"),
d13419 1
a13419 1
		(_("%H: %s reloc against `%s': error %d\n"),
@


1.358
log
@	* elf64-ppc.c (build_plt_stub): Correct emitted relocs when no
	plt_static_chain.
	(ppc_build_one_stub): Adjust get_relocs call to suit..
	(ppc_size_one_stub): ..and reloc sizing.  Correct plt size corner case.
@
text
@d10874 20
d11274 3
a11276 4
  /* It would be nice to strip htab->brlt from the output if the
     section is empty, but it's too late.  If we strip sections here,
     the dynamic symbol table is corrupted since the section symbol
     for the stripped section isn't written.  */
@


1.357
log
@bfd/
	* elf32-ppc.c: Include dwarf2.h.
	(struct ppc_elf_link_hash_table): Add glink_eh_frame.
	(ppc_elf_create_glink): Create .eh_frame section.
	(glink_eh_frame_cie): New array.
	(ppc_elf_size_dynamic_sections): Size glink_eh_frame.
	(ppc_elf_finish_dynamic_sections): Write glink_eh_frame.
	* elf64-ppc.c: Include dwarg2.h.
	(struct ppc_link_hash_table): Add glink_eh_frame.
	(create_linkage_sections): Create .eh_frame section.
	(ppc64_elf_size_dynamic_sections): Arrange to drop unneeded
	glink_eh_frame.
	(glink_eh_frame_cie): New array.
	(ppc64_elf_size_stubs): Size glink_eh_frame.
	(ppc64_elf_build_stubs): Init glink_eh_frame contents.
	(ppc64_elf_finish_dynamic_sections): Write glink_eh_frame.
ld/
	* emulparams/elf32ppc.sh: Source plt_unwind.sh.
	* emulparams/elf64ppc.sh: Likewise.
	* emultempl/ppc32elf.em (OPTION_NO_TLS_OPT): Adjust.
	(PARSE_AND_LIST_PROLOGUE, PARSE_AND_LIST_LONGOPTS,
	PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Append to
	existing values.
	* emultempl/ppc64elf.em (OPTION_STUBGROUP_SIZE): Adjust.
	(PARSE_AND_LIST_PROLOGUE, PARSE_AND_LIST_LONGOPTS,
	PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Append to
	existing values.
ld/testsuite/
	* ld-powerpc/powerpc.exp: Use --no-ld-generated-unwind-info
	with some tests.
	* ld-powerpc/relbrlt.d: Likewise.
@
text
@d9294 1
a9294 1
	  if (PPC_HA (offset + 16) != PPC_HA (offset))
d9305 6
a9310 3
	      r[3].r_offset = r[2].r_offset + 4;
	      r[3].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_LO_DS);
	      r[3].r_addend = r[0].r_addend + 16;
d9333 1
a9333 1
	  if (PPC_HA (offset + 16) != PPC_HA (offset))
d9343 7
a9349 4
	      r[1].r_addend = r[0].r_addend + 16;
	      r[2].r_offset = r[1].r_offset + 4;
	      r[2].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);
	      r[2].r_addend = r[0].r_addend + 8;
d9817 4
a9820 2
			  (2 + (PPC_HA (off) != 0)
			   + (PPC_HA (off + 16) == PPC_HA (off))));
d9927 1
a9927 1
      if (PPC_HA (off + 16) != PPC_HA (off))
d9937 4
a9940 1
	    += 2 + (PPC_HA (off) != 0) + (PPC_HA (off + 16) == PPC_HA (off));
@


1.356
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_table): Add plt_static_chain.
	(build_plt_stub): Add plt_static_chain param, don't load r11 if false.
	(build_tls_get_addr_stub): Likewise.
	(ppc_build_one_stub): Update calls to above.
	(ppc_size_one_stub): Adjust stub size.
	(ppc64_elf_size_stubs): Add plt_static_chain param, save to htab.
	* elf64-ppc.h (ppc64_elf_size_stubs): Update prototype.
ld/
	* emultempl/ppc64elf.em (plt_static_chain): New var.
	(gld${EMULATION_NAME}_after_allocation): Pass to ppc64_elf_size_stubs.
	(PARSE_AND_LIST_PROLOGUE, PARSE_AND_LIST_LONGOPTS,
	PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Handle
	--plt-static-chain and --no-plt-static-chain.
ld/testsuite/
	* ld-powerpc/tlsexe.d, * ld-powerpc/tlsexe.g. *ld-powerpc/tlsexe.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r, * ld-powerpc/tlsso.d,
	* ld-powerpc/tlstocso.d: Update for plt stub change.
@
text
@d37 1
d3724 1
d4175 12
d9042 6
d10849 14
d11206 19
d11234 3
a11236 1
      if (stub_sec == NULL)
d11451 94
d11562 3
a11564 1
      || htab->glink->rawsize != htab->glink->size)
d13713 8
@


1.355
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Don't look at
	dyn relocs when called to copy flags for a weak sym.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_merge_private_bfd_data): Delete.
	(bfd_elf64_bfd_merge_private_bfd_data): Define as
	_bfd_generic_verify_endian_match.
@
text
@d3737 3
d9259 2
a9260 1
build_plt_stub (bfd *obfd, bfd_byte *p, int offset, Elf_Internal_Rela *r)
d9293 1
a9293 1
      if (PPC_HA (offset + 16) != PPC_HA (offset))
d9300 2
a9301 1
      bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset + 16), p),	p += 4;
d9328 1
a9328 1
      if (PPC_HA (offset + 16) != PPC_HA (offset))
d9334 2
a9335 1
      bfd_put_32 (obfd, LD_R11_0R2 | PPC_LO (offset + 16), p),	p += 4;
d9360 1
a9360 1
			 Elf_Internal_Rela *r)
d9374 1
a9374 1
  p = build_plt_stub (obfd, p, offset, r);
d9804 2
a9805 1
	p = build_tls_get_addr_stub (htab->stub_bfd, loc, off, r);
d9807 2
a9808 1
	p = build_plt_stub (htab->stub_bfd, loc, off, r);
d9895 2
d10836 2
a10837 1
ppc64_elf_size_stubs (struct bfd_link_info *info, bfd_signed_vma group_size)
d10846 1
@


1.354
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d83 1
a83 1
#define bfd_elf64_bfd_merge_private_bfd_data  ppc64_elf_merge_private_bfd_data
a2729 29
/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
ppc64_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  /* Check if we have the same endianness.  */
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%B: compiled for a big endian system "
		"and target is little endian");
      else
	msg = _("%B: compiled for a little endian system "
		"and target is big endian");

      (*_bfd_error_handler) (msg, ibfd);

      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  return TRUE;
}

d4352 23
a4406 23
  edir->is_func |= eind->is_func;
  edir->is_func_descriptor |= eind->is_func_descriptor;
  edir->tls_mask |= eind->tls_mask;
  if (eind->oh != NULL)
    edir->oh = ppc_follow_link (eind->oh);

  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (!(ELIMINATE_COPY_RELOCS
	&& eind->elf.root.type != bfd_link_hash_indirect
	&& edir->elf.dynamic_adjusted))
    edir->elf.non_got_ref |= eind->elf.non_got_ref;

  edir->elf.ref_dynamic |= eind->elf.ref_dynamic;
  edir->elf.ref_regular |= eind->elf.ref_regular;
  edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
  edir->elf.needs_plt |= eind->elf.needs_plt;

  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

@


1.353
log
@oops - spelling fixes accidentally omitted from previous delta.
@
text
@a5671 3
  if (eh->elf.root.type == bfd_link_hash_warning)
    eh = (struct ppc_link_hash_entry *) eh->elf.root.u.i.link;

a6213 3
  if (fh->elf.root.type == bfd_link_hash_warning)
    fh = (struct ppc_link_hash_entry *) fh->elf.root.u.i.link;

a6738 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a7898 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a8593 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a8833 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a10201 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a10217 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a11471 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.352
log
@	* elf-bfd.h: Comment typo fix.
	* elf32-ppc.c (struct ppc_elf_dyn_relocs): Delete.  Replace with
	struct elf_dyn_relocs throughout.
	* elf64-ppc.c (struct ppc_dyn_relocs): Likewise.
@
text
@d2736 1
a2736 1
  /* Check if we have the same endianess.  */
@


1.351
log
@	* elf32-frv.c: Use info->callbacks->einfo throughout file in linker
	functions rather than warning callback or _bfd_error_handler.
	* elf32-ppc.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf32-ppc.c (ppc_elf_tls_optimize): Use %H in __tls_get_addr lost
	arg error.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
@
text
@a3489 20
/* The linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct ppc_dyn_relocs
{
  struct ppc_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

d3656 1
a3656 1
  struct ppc_dyn_relocs *dyn_relocs;
d4386 2
a4387 2
	  struct ppc_dyn_relocs **pp;
	  struct ppc_dyn_relocs *p;
d4393 1
a4393 1
	      struct ppc_dyn_relocs *q;
d5389 2
a5390 2
	      struct ppc_dyn_relocs *p;
	      struct ppc_dyn_relocs **head;
d5429 1
a5429 1
		  head = (struct ppc_dyn_relocs **) vpp;
d5838 2
a5839 2
	  struct ppc_dyn_relocs **pp;
	  struct ppc_dyn_relocs *p;
d6457 1
a6457 1
      struct ppc_dyn_relocs *p;
d6797 2
a6798 2
  struct ppc_dyn_relocs *p;
  struct ppc_dyn_relocs **pp;
d6883 1
a6883 1
	  pp = (struct ppc_dyn_relocs **) vpp;
d6888 1
a6888 1
	  pp = (struct ppc_dyn_relocs **) vpp;
d8600 1
a8600 1
  struct ppc_dyn_relocs *p;
d8764 1
a8764 1
	  struct ppc_dyn_relocs **pp;
d8847 1
a8847 1
  struct ppc_dyn_relocs *p;
d8922 1
a8922 1
	  struct ppc_dyn_relocs *p;
@


1.350
log
@bfd/
	* elf.c (elfcore_grok_psinfo): Initialize CORE_PID for both native and
	32bit psinfo.
	* elf32-ppc.c (ppc_elf_grok_psinfo): Initialize core_pid.
	* elf64-ppc.c (ppc64_elf_grok_psinfo): Likewise.
@
text
@d4141 1
a4141 1
	      struct ppc_link_hash_table *htab)
d4143 1
d4180 2
a4181 2
      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
			     section->owner, stub_name);
d6503 1
a6503 1
      (*_bfd_error_handler)
d6505 1
a6505 1
	   "avoid setting LD_BIND_NOW=1 or upgrade gcc"),
d6514 2
a6515 2
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
d6932 2
a6933 2
  (*_bfd_error_handler) (_("dynreloc miscount for %B, section %A"),
			   sec->owner, sec);
d7604 1
a7604 1
		      info->callbacks->minfo (_("%C __tls_get_addr lost arg, "
d7798 1
a7798 1
		      info->callbacks->minfo (_("%C arg lost __tls_get_addr, "
d9477 1
a9477 1
get_r2off (struct ppc_link_hash_table *htab,
d9480 1
d9494 2
a9495 2
	  (*_bfd_error_handler) (_("cannot find opd entry toc for %s"),
				 stub_entry->h->elf.root.root.string);
d9502 1
a9502 1
      r2off -= elf_gp (stub_entry->id_sec->output_section->owner);
d9552 1
a9552 1
	  bfd_vma r2off = get_r2off (htab, stub_entry);
d9576 2
a9577 2
	  (*_bfd_error_handler) (_("long branch stub `%s' offset overflow"),
				 stub_entry->root.string);
d9635 2
a9636 2
	  (*_bfd_error_handler) (_("can't find branch stub `%s'"),
				 stub_entry->root.string);
d9696 2
a9697 2
	  (*_bfd_error_handler)
	    (_("linkage table error against `%s'"),
d9742 1
a9742 1
	  bfd_vma r2off = get_r2off (htab, stub_entry);
d9838 2
a9839 2
	  (*_bfd_error_handler)
	    (_("linkage table error against `%s'"),
d9991 1
a9991 1
	  r2off = get_r2off (htab, stub_entry);
d10013 2
a10014 2
	      (*_bfd_error_handler) (_("can't build branch stub `%s'"),
				     stub_entry->root.string);
d11156 1
a11156 1
		  stub_entry = ppc_add_stub (stub_name, section, htab);
d11477 1
a11477 1
      (*_bfd_error_handler) (_("stubs don't match calculated size"));
d11837 1
a11837 1
	    (*_bfd_error_handler)
d11839 3
a11841 5
	       ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
	       : _("%B(%A+0x%lx): %s used with non-TLS symbol %s"),
	       input_bfd,
	       input_section,
	       (long) rel->r_offset,
d12337 2
a12338 2
			(*_bfd_error_handler)
			  (_("%B(%A+0x%lx): automatic multiple TOCs "
d12340 2
a12341 4
			     "recompile with -mminimal-toc or upgrade gcc"),
			   input_bfd,
			   input_section,
			   (long) rel->r_offset);
d12343 2
a12344 2
			(*_bfd_error_handler)
			  (_("%B(%A+0x%lx): sibling call optimization to `%s' "
d12348 2
a12349 4
			     "or make `%s' extern"),
			   input_bfd,
			   input_section,
			   (long) rel->r_offset,
d12450 2
a12451 2
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d for symbol %s"),
d12955 4
a12958 6
			  (*_bfd_error_handler)
			    (_("%B(%A+0x%lx): relocation %s for indirect "
			       "function %s unsupported"),
			     input_bfd,
			     input_section,
			     (long) rel->r_offset,
d13060 2
a13061 2
	  (*_bfd_error_handler)
	    (_("%B: relocation %s is not supported for symbol %s."),
d13237 3
a13239 3
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): error: %s not a multiple of %u"),
		 input_bfd, input_section, (long) rel->r_offset,
d13256 3
a13258 5
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
d13301 3
a13303 5
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): %s reloc against `%s': error %d"),
		 input_bfd,
		 input_section,
		 (long) rel->r_offset,
@


1.349
log
@	PR ld/12727
	* elf64-ppc.c (ppc_build_one_stub <ppc_sub_plt_call>): Clear
	was_undefined on dot-symbols.
@
text
@d2673 2
@


1.348
log
@bfd/
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.

gdb/
	Fix convert_code_addr_to_desc_addr for ppc64 files after eu-strip.
	* elfread.c (elf_symfile_read): New variable synth_abfd, pass it to
	bfd_get_synthetic_symtab.
	* jit.c (jit_register_code): Pass NULL to the new parameter parent.
	* machoread.c (macho_add_oso_symfile): Pass main_objfile to the new
	parameter parent, remove the call to add_separate_debug_objfile.
	* solib.c (solib_read_symbols): Pass NULL to the new parameter parent.
	* symfile-mem.c (symbol_file_add_from_memory): Likewise.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): New parameter
	parent, new comment for it, call add_separate_debug_objfile for it.
	(symbol_file_add_separate): Pass objfile as the parameter parent,
	remove the call to add_separate_debug_objfile.
	(symbol_file_add_from_bfd): New parameter parent, pass it.
	(symbol_file_add): Pass NULL to the new parameter parent.
	* symfile.h (symbol_file_add_from_bfd): New parameter parent.

gdb/testsuite/
	* gdb.base/eu-strip-infcall.c: New file.
	* gdb.base/eu-strip-infcall.exp: New file.
@
text
@d9792 2
@


1.347
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d3320 3
a3322 2
		  if ((sec->flags & SEC_ALLOC) == 0
		      || (sec->flags & SEC_LOAD) == 0)
@


1.346
log
@bfd/
	* elf32-ppc.c (ppc_elf_tls_optimize): Catch more cases where
	old-style __tls_get_addr calls without marker relocs don't match
	their arg setup insn one for one.  If such mismatches are found
	report the reloc and don't do any tls optimization.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
ld/testsuite/
	* ld-powerpc/tlsmark.s: Delete non-optimizable section.
	* ld-powerpc/tlsmark32.s: Likewise.
	* ld-powerpc/tlsmark.d: Adjust to suit.
	* ld-powerpc/tlsmark32.d: Likewise.
	* ld-powerpc/tlsopt1.d, * ld-powerpc/tlsopt1.s: New.
	* ld-powerpc/tlsopt2.d, * ld-powerpc/tlsopt2.s: New.
	* ld-powerpc/tlsopt3.d, * ld-powerpc/tlsopt3.s: New.
	* ld-powerpc/tlsopt4.d, * ld-powerpc/tlsopt4.s: New.
	* ld-powerpc/tlsopt1_32.d, * ld-powerpc/tlsopt1_32.s: New.
	* ld-powerpc/tlsopt2_32.d, * ld-powerpc/tlsopt2_32.s: New.
	* ld-powerpc/tlsopt3_32.d, * ld-powerpc/tlsopt3_32.s: New.
	* ld-powerpc/tlsopt4_32.d, * ld-powerpc/tlsopt4_32.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@d4572 4
d4579 1
a4579 1
	elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.345
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Provide section/offset
	for LO_DS error message and correct multiple.
@
text
@d7476 1
d7486 14
a7499 13
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;
      asection *toc = bfd_get_section_by_name (ibfd, ".toc");
      unsigned char *toc_ref = NULL;

      /* Look at all the sections for this file.  Make two passes over
	 the relocs.  On the first pass, mark toc entries involved
	 with tls relocs, and check that tls relocs involved in
	 setting up a tls_get_addr call are indeed followed by such a
	 call.  If they are not, exclude them from the optimizations
	 done on the second pass.  */
      for (pass = 0; pass < 2; ++pass)
d7504 1
d7526 1
d7541 1
a7541 1
		      return FALSE;
d7552 4
a7555 1
			continue;
d7582 22
d7609 1
d7629 1
d7658 6
a7665 3
		    case R_PPC64_TLS:
		    case R_PPC64_TLSGD:
		    case R_PPC64_TLSLD:
d7674 4
a7677 5
			{
			  toc_ref = bfd_zmalloc (toc->size / 8);
			  if (toc_ref == NULL)
			    goto err_free_rel;
			}
d7684 1
a7684 1
		      toc_ref_index = value / 8;
d7705 1
a7705 1
			  || !toc_ref[rel->r_offset / 8])
d7720 1
a7720 1
			  || !toc_ref[rel->r_offset / 8])
d7772 7
a7778 2
			      if (retval > 1 && toc_tls != NULL)
				toc_ref[toc_ref_index] = 1;
d7789 6
a7794 3
			 the entire section.  */
		      sec->has_tls_reloc = 0;
		      break;
d7880 9
a7888 2
      if (toc_ref != NULL)
	free (toc_ref);
d7890 2
a7891 9
      if (locsyms != NULL
	  && (elf_symtab_hdr (ibfd).contents != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    elf_symtab_hdr (ibfd).contents = (unsigned char *) locsyms;
	}
    }
@


1.344
log
@	* elf64-ppc.c (bfd_elf64_bfd_link_just_syms): Define.
	(ppc64_elf_link_just_syms): New function.
	(opd_entry_value): Don't assume big-endian host.
	(get_r2off): New function.
	(ppc_build_one_stub, ppc_size_one_stub): Use it here.
@
text
@d11658 1
a11658 1
      bfd_vma mask;
d13194 2
a13195 2
		(_("%B: error: relocation %s not a multiple of %d"),
		 input_bfd,
@


1.343
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Reinstate second read of
	toc relocs.  Fuss over free(NULL).
@
text
@d82 1
a82 1
#define bfd_elf64_bfd_reloc_name_lookup ppc64_elf_reloc_name_lookup
d88 1
d4749 19
d5488 3
a5490 1
      if (!bfd_get_section_contents (opd_bfd, opd_sec, &val, offset, 8))
d5493 1
d9427 31
d9502 1
a9502 1
	  bfd_vma r2off;
d9504 5
a9508 2
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
d9692 7
a9698 1
	  bfd_vma r2off;
a9699 2
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
d9939 6
a9944 2
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
@


1.342
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Don't free toc relocs until
	we are done.  When optimising large toc, check that a global
	symbol on a toc reloc is defined in a kept section.
@
text
@d8427 6
d8454 2
a8455 1
      else if (elf_section_data (toc)->relocs != toc_relocs)
@


1.341
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Don't segfault on NULL
	local_syms when looking for local symbols in .toc.
@
text
@d7910 1
a7910 1
      Elf_Internal_Rela *relstart, *rel;
d7925 1
d8021 3
a8023 3
	  relstart = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
						info->keep_memory);
	  if (relstart == NULL)
d8026 1
a8026 1
	  for (rel = relstart; rel < relstart + toc->reloc_count; ++rel)
d8044 4
d8086 1
a8086 1
		|= can_optimize | ((rel - relstart) << 2);
a8087 3

	  if (elf_section_data (toc)->relocs != relstart)
	    free (relstart);
d8104 3
d8346 1
a8346 1
			= elf_section_data (toc)->relocs + (skip[val >> 3] >> 2);
a8425 6
	      /* Read toc relocs.  */
	      relstart = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
						    TRUE);
	      if (relstart == NULL)
		goto error_ret;

d8427 2
a8428 2
	      wrel = relstart;
	      for (rel = relstart; rel < relstart + toc->reloc_count; ++rel)
d8441 2
a8442 1
	      toc->reloc_count = wrel - relstart;
d8448 2
@


1.340
log
@	* elf64-ppc.c (ppc64_elf_next_input_section): Use elf_gp value
	for toc pointer on any section having makes_toc_func_call set.
	(check_pasted_section): Ensure pasted .init/.fini fragments use
	the same toc if any has makes_toc_func_call set.
@
text
@d3 1
a3 1
   2009, 2010 Free Software Foundation, Inc.
d8375 8
a8382 7
	  for (sym = local_syms;
	       sym < local_syms + symtab_hdr->sh_info;
	       ++sym)
	    if (sym->st_value != 0
		&& bfd_section_from_elf_index (ibfd, sym->st_shndx) == toc)
	      {
		unsigned long i;
d8384 4
a8387 4
		if (sym->st_value > toc->rawsize)
		  i = toc->rawsize >> 3;
		else
		  i = sym->st_value >> 3;
d8389 11
a8399 11
		if ((skip[i] & (ref_from_discarded | can_optimize)) != 0)
		  {
		    if (local_toc_syms)
		      (*_bfd_error_handler)
			(_("%s defined on removed toc entry"),
			 bfd_elf_sym_name (ibfd, symtab_hdr, sym, NULL));
		    do
		      ++i;
		    while ((skip[i] & (ref_from_discarded | can_optimize)));
		    sym->st_value = (bfd_vma) i << 3;
		  }
d8401 3
a8403 3
		sym->st_value -= skip[i];
		symtab_hdr->contents = (unsigned char *) local_syms;
	      }
@


1.339
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d10583 18
a10600 3
      else if (!isec->call_check_done
	       && toc_adjusting_stub_needed (info, isec) < 0)
	return FALSE;
d10604 1
a10604 2
     Use the last TOC base.  This happens to make _init and _fini
     pasting work, because the fragments generally don't use the TOC.  */
d10631 9
@


1.339.2.1
log
@	* elf64-ppc.c (ppc64_elf_next_input_section): Use elf_gp value
	for toc pointer on any section having makes_toc_func_call set.
	(check_pasted_section): Ensure pasted .init/.fini fragments use
	the same toc if any has makes_toc_func_call set.
@
text
@d3 1
a3 1
   2009, 2010, 2011 Free Software Foundation, Inc.
d10583 3
a10585 18
      else
	{
	  if (!isec->call_check_done
	      && toc_adjusting_stub_needed (info, isec) < 0)
	    return FALSE;
	  /* If we make a local call from this section, ie. a branch
	     without a following nop, then we have no place to put a
	     toc restoring insn.  We must use the same toc group as
	     the callee.
	     Testing makes_toc_func_call actually tests for *any*
	     calls to functions that need a good toc pointer.  A more
	     precise test would be better, as this one will set
	     incorrect values for pasted .init/.fini fragments.
	     (Fixed later in check_pasted_section.)  */
	  if (isec->makes_toc_func_call
	      && elf_gp (isec->owner) != 0)
	    htab->toc_curr = elf_gp (isec->owner);
	}
d10589 2
a10590 1
     Use the last TOC base.  */
a10616 9

      if (toc_off == 0)
	for (i = o->map_head.s; i != NULL; i = i->map_head.s)
	  if (i->makes_toc_func_call)
	    {
	      toc_off = htab->stub_group[i->id].toc_off;
	      break;
	    }

@


1.339.2.2
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Don't segfault on NULL
	local_syms when looking for local symbols in .toc.
@
text
@d8375 7
a8381 8
	  if (local_syms != NULL)
	    for (sym = local_syms;
		 sym < local_syms + symtab_hdr->sh_info;
		 ++sym)
	      if (sym->st_value != 0
		  && bfd_section_from_elf_index (ibfd, sym->st_shndx) == toc)
		{
		  unsigned long i;
d8383 4
a8386 4
		  if (sym->st_value > toc->rawsize)
		    i = toc->rawsize >> 3;
		  else
		    i = sym->st_value >> 3;
d8388 11
a8398 11
		  if ((skip[i] & (ref_from_discarded | can_optimize)) != 0)
		    {
		      if (local_toc_syms)
			(*_bfd_error_handler)
			  (_("%s defined on removed toc entry"),
			   bfd_elf_sym_name (ibfd, symtab_hdr, sym, NULL));
		      do
			++i;
		      while ((skip[i] & (ref_from_discarded | can_optimize)));
		      sym->st_value = (bfd_vma) i << 3;
		    }
d8400 3
a8402 3
		  sym->st_value -= skip[i];
		  symtab_hdr->contents = (unsigned char *) local_syms;
		}
@


1.339.2.3
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Don't free toc relocs until
	we are done.  When optimising large toc, check that a global
	symbol on a toc reloc is defined in a kept section.
@
text
@d7910 1
a7910 1
      Elf_Internal_Rela *relstart, *rel, *toc_relocs;
a7924 1
      toc_relocs = NULL;
d8020 3
a8022 3
	  toc_relocs = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
						  info->keep_memory);
	  if (toc_relocs == NULL)
d8025 1
a8025 1
	  for (rel = toc_relocs; rel < toc_relocs + toc->reloc_count; ++rel)
a8042 4
	      if (sym_sec == NULL
		  || elf_discarded_section (sym_sec))
		continue;

d8081 1
a8081 1
		|= can_optimize | ((rel - toc_relocs) << 2);
d8083 3
a8101 3
	  if (toc_relocs != NULL
	      && elf_section_data (toc)->relocs != toc_relocs)
	    free (toc_relocs);
d8341 1
a8341 1
			= toc_relocs + (skip[val >> 3] >> 2);
d8421 6
d8428 2
a8429 2
	      wrel = toc_relocs;
	      for (rel = toc_relocs; rel < toc_relocs + toc->reloc_count; ++rel)
d8442 1
a8442 2
	      elf_section_data (toc)->relocs = toc_relocs;
	      toc->reloc_count = wrel - toc_relocs;
a8447 2
      else if (elf_section_data (toc)->relocs != toc_relocs)
	free (toc_relocs);
@


1.339.2.4
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Reinstate second read of
	toc relocs.  Fuss over free(NULL).
@
text
@a8426 6
	      if (toc_relocs == NULL)
		toc_relocs = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
							info->keep_memory);
	      if (toc_relocs == NULL)
		goto error_ret;

d8448 1
a8448 2
      else if (toc_relocs != NULL
	       && elf_section_data (toc)->relocs != toc_relocs)
@


1.339.2.5
log
@	* elf64-ppc.c (bfd_elf64_bfd_link_just_syms): Define.
	(ppc64_elf_link_just_syms): New function.
	(opd_entry_value): Don't assume big-endian host.
	(get_r2off): New function.
	(ppc_build_one_stub, ppc_size_one_stub): Use it here.
@
text
@d82 1
a82 1
#define bfd_elf64_bfd_reloc_name_lookup	      ppc64_elf_reloc_name_lookup
a87 1
#define bfd_elf64_bfd_link_just_syms	      ppc64_elf_link_just_syms
a4747 19
/* If --just-symbols against a final linked binary, then assume we need
   toc adjusting stubs when calling functions defined there.  */

static void
ppc64_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
{
  if ((sec->flags & SEC_CODE) != 0
      && (sec->owner->flags & (EXEC_P | DYNAMIC)) != 0
      && is_ppc64_elf (sec->owner))
    {
      asection *got = bfd_get_section_by_name (sec->owner, ".got");
      if (got != NULL
	  && got->size >= elf_backend_got_header_size
	  && bfd_get_section_by_name (sec->owner, ".opd") != NULL)
	sec->has_toc_reloc = 1;
    }
  _bfd_elf_link_just_syms (sec, info);
}

d5468 1
a5468 3
      char buf[8];

      if (!bfd_get_section_contents (opd_bfd, opd_sec, buf, offset, 8))
a5470 1
      val = bfd_get_64 (opd_bfd, buf);
a9403 31
static bfd_vma
get_r2off (struct ppc_link_hash_table *htab,
	   struct ppc_stub_hash_entry *stub_entry)
{
  bfd_vma r2off = htab->stub_group[stub_entry->target_section->id].toc_off;

  if (r2off == 0)
    {
      /* Support linking -R objects.  Get the toc pointer from the
	 opd entry.  */
      char buf[8];
      asection *opd = stub_entry->h->elf.root.u.def.section;
      bfd_vma opd_off = stub_entry->h->elf.root.u.def.value;

      if (strcmp (opd->name, ".opd") != 0
	  || opd->reloc_count != 0)
	{
	  (*_bfd_error_handler) (_("cannot find opd entry toc for %s"),
				 stub_entry->h->elf.root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return 0;
	}
      if (!bfd_get_section_contents (opd->owner, opd, buf, opd_off + 8, 8))
	return 0;
      r2off = bfd_get_64 (opd->owner, buf);
      r2off -= elf_gp (stub_entry->id_sec->output_section->owner);
    }
  r2off -= htab->stub_group[stub_entry->id_sec->id].toc_off;
  return r2off;
}

d9448 1
a9448 1
	  bfd_vma r2off = get_r2off (htab, stub_entry);
d9450 2
a9451 5
	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }
d9635 1
a9635 7
	  bfd_vma r2off = get_r2off (htab, stub_entry);

	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }
d9637 2
d9878 2
a9879 6
	  r2off = get_r2off (htab, stub_entry);
	  if (r2off == 0)
	    {
	      htab->stub_error = TRUE;
	      return FALSE;
	    }
@


1.339.2.6
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Provide section/offset
	for LO_DS error message and correct multiple.
@
text
@d11658 1
a11658 1
      unsigned int mask;
d13194 2
a13195 2
		(_("%B(%A+0x%lx): error: %s not a multiple of %u"),
		 input_bfd, input_section, (long) rel->r_offset,
@


1.339.2.7
log
@bfd/
	* elf32-ppc.c (ppc_elf_tls_optimize): Catch more cases where
	old-style __tls_get_addr calls without marker relocs don't match
	their arg setup insn one for one.  If such mismatches are found
	report the reloc and don't do any tls optimization.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
ld/testsuite/
	* ld-powerpc/tlsmark.s: Delete non-optimizable section.
	* ld-powerpc/tlsmark32.s: Likewise.
	* ld-powerpc/tlsmark.d: Adjust to suit.
	* ld-powerpc/tlsmark32.d: Likewise.
	* ld-powerpc/tlsopt1.d, * ld-powerpc/tlsopt1.s: New.
	* ld-powerpc/tlsopt2.d, * ld-powerpc/tlsopt2.s: New.
	* ld-powerpc/tlsopt3.d, * ld-powerpc/tlsopt3.s: New.
	* ld-powerpc/tlsopt4.d, * ld-powerpc/tlsopt4.s: New.
	* ld-powerpc/tlsopt1_32.d, * ld-powerpc/tlsopt1_32.s: New.
	* ld-powerpc/tlsopt2_32.d, * ld-powerpc/tlsopt2_32.s: New.
	* ld-powerpc/tlsopt3_32.d, * ld-powerpc/tlsopt3_32.s: New.
	* ld-powerpc/tlsopt4_32.d, * ld-powerpc/tlsopt4_32.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@a7475 1
  unsigned char *toc_ref;
d7485 13
a7497 14
  /* Make two passes over the relocs.  On the first pass, mark toc
     entries involved with tls relocs, and check that tls relocs
     involved in setting up a tls_get_addr call are indeed followed by
     such a call.  If they are not, we can't do any tls optimization.
     On the second pass twiddle tls_mask flags to notify
     relocate_section that optimization can be done, and adjust got
     and plt refcounts.  */
  toc_ref = NULL;
  for (pass = 0; pass < 2; ++pass)
    for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
      {
	Elf_Internal_Sym *locsyms = NULL;
	asection *toc = bfd_get_section_by_name (ibfd, ".toc");

a7501 1
	      bfd_boolean found_tls_get_addr_arg = 0;
a7522 1
		  bfd_boolean ret = FALSE;
d7537 1
a7537 1
		      return ret;
d7548 1
a7548 4
			{
			  found_tls_get_addr_arg = 0;
			  continue;
			}
a7574 22
		  /* If this section has old-style __tls_get_addr calls
		     without marker relocs, then check that each
		     __tls_get_addr call reloc is preceded by a reloc
		     that conceivably belongs to the __tls_get_addr arg
		     setup insn.  If we don't find matching arg setup
		     relocs, don't do any tls optimization.  */
		  if (pass == 0
		      && sec->has_tls_get_addr_call
		      && h != NULL
		      && (h == &htab->tls_get_addr->elf
			  || h == &htab->tls_get_addr_fd->elf)
		      && !found_tls_get_addr_arg
		      && is_branch_reloc (r_type))
		    {
		      info->callbacks->minfo (_("%C __tls_get_addr lost arg, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      ret = TRUE;
		      goto err_free_rel;
		    }

		  found_tls_get_addr_arg = 0;
a7579 1
		      found_tls_get_addr_arg = 1;
a7598 1
		      found_tls_get_addr_arg = 1;
d7627 3
a7631 6
		      found_tls_get_addr_arg = 1;
		      /* Fall thru */

		    case R_PPC64_TLS:
		    case R_PPC64_TOC16:
		    case R_PPC64_TOC16_LO:
d7640 5
a7644 4
			toc_ref = bfd_zmalloc (toc->output_section->rawsize / 8);
		      if (toc_ref == NULL)
			goto err_free_rel;

d7651 1
a7651 1
		      toc_ref_index = (value + toc->output_offset) / 8;
d7672 1
a7672 1
			  || !toc_ref[(rel->r_offset + toc->output_offset) / 8])
d7687 1
a7687 1
			  || !toc_ref[(rel->r_offset + toc->output_offset) / 8])
d7739 2
a7740 7
			      if (toc_tls != NULL)
				{
				  if ((*toc_tls & (TLS_GD | TLS_LD)) != 0)
				    found_tls_get_addr_arg = 1;
				  if (retval > 1)
				    toc_ref[toc_ref_index] = 1;
				}
d7751 3
a7753 6
			 the entire optimization.  */
		      info->callbacks->minfo (_("%C arg lost __tls_get_addr, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      ret = TRUE;
		      goto err_free_rel;
d7839 2
a7840 9
	if (locsyms != NULL
	    && (elf_symtab_hdr (ibfd).contents != (unsigned char *) locsyms))
	  {
	    if (!info->keep_memory)
	      free (locsyms);
	    else
	      elf_symtab_hdr (ibfd).contents = (unsigned char *) locsyms;
	  }
      }
d7842 9
a7850 2
  if (toc_ref != NULL)
    free (toc_ref);
@


1.339.2.8
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@a4571 4
  if ((ibfd->flags & DYNAMIC) == 0
      && ELF_ST_BIND (isym->st_info) == STB_GNU_UNIQUE)
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

d4575 1
a4575 1
	elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;
@


1.339.2.9
log
@	PR ld/12727
	* elf64-ppc.c (ppc_build_one_stub <ppc_sub_plt_call>): Clear
	was_undefined on dot-symbols.
@
text
@a9790 2
	  /* Stop undo_symbol_twiddle changing it back to undefined.  */
	  fh->was_undefined = 0;
@


1.339.2.10
log
@	Apply 2011-04-17  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Do not check for
	SEC_LOAD.
@
text
@d3320 2
a3321 3
		  /* SEC_LOAD may not be set if SEC is from a separate debug
		     info file.  */
		  if ((sec->flags & SEC_ALLOC) == 0)
@


1.339.2.11
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a2672 2
  elf_tdata (abfd)->core_pid
    = bfd_get_32 (abfd, note->descdata + 24);
@


1.338
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d11627 4
a11630 10
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (ppc64_elf_howto_table[r_type], input_bfd,
			       contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.337
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d7076 1
d7256 2
a7257 3
	  elf_section_data (sec)->rel_hdr.sh_size
	    = sec->reloc_count * elf_section_data (sec)->rel_hdr.sh_entsize;
	  BFD_ASSERT (elf_section_data (sec)->rel_hdr2 == NULL);
d8416 1
d8442 3
a8444 3
	      sz = elf_section_data (toc)->rel_hdr.sh_entsize;
	      elf_section_data (toc)->rel_hdr.sh_size = toc->reloc_count * sz;
	      BFD_ASSERT (elf_section_data (toc)->rel_hdr2 == NULL);
d9380 7
a9386 3
      elfsec_data->rel_hdr.sh_size = (sec->reloc_count
				      * sizeof (Elf64_External_Rela));
      elfsec_data->rel_hdr.sh_entsize = sizeof (Elf64_External_Rela);
d13480 1
a13480 1
				       &elf_section_data (htab->brlt)->rel_hdr,
d13489 1
a13489 1
				       &elf_section_data (htab->glink)->rel_hdr,
@


1.336
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d11671 1
a11671 1
      if (r_symndx != 0
d11920 1
a11920 1
			r_symndx = 0;
d11922 1
a11922 1
		      if (r_symndx != 0)
d12028 1
a12028 1
		r_symndx = 0;
d12030 1
a12030 1
	      if (r_symndx != 0)
d12572 1
a12572 1
	  if (r_symndx == 0)
d12822 1
a12822 1
		      else if (r_symndx == 0 || bfd_is_abs_section (sec))
@


1.335
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d64 1
@


1.334
log
@	* elf64-ppc.c (ha_reloc_match): Allow matches to other than r2.
	(ppc64_elf_relocate_section): Nop out high part insn of large toc
	code sequence when the high part of offset is zero.
@
text
@d2654 1
a2654 1
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);
@


1.333
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Always adjust local syms in
	.toc section, even when none are used in relocs.
@
text
@d11400 2
a11401 1
   is addis REG,r2,x.  If so, return a pointer to the high-part reloc.  */
d11406 2
a11407 1
		unsigned int reg,
d11439 2
a11440 1
	&& rel->r_addend == r_addend)
d11444 6
a11449 4
	if ((insn & ((0x3f << 26) | (0x1f << 16)))
	    == ((15u << 26) | (2 << 16)) /* addis rt,r2,x */
	    && (insn & (0x1f << 21)) == (reg << 21))
	  return rel;
d11502 1
d11504 1
d11530 2
d12957 1
a12957 1
	  /* For now we don't nop out the first instruction.  */
d12992 8
a12999 1
		  if (ha_reloc_match (relocs, rel, reg, input_bfd, contents))
d13002 1
a13002 1
		      insn |= 2 << 16;
d13004 7
d13012 5
d13174 17
@


1.332
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Use SYMBOL_CALLS_LOCAL rather
	than SYMBOL_REFERENCES_LOCAL.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d8251 1
a8295 1
		  Elf_Internal_Sym *sym;
d8374 12
a8385 3
	  if (local_toc_syms)
	    {
	      Elf_Internal_Sym *sym;
d8387 1
a8387 5
	      for (sym = local_syms;
		   sym < local_syms + symtab_hdr->sh_info;
		   ++sym)
		if (sym->st_value != 0
		    && bfd_section_from_elf_index (ibfd, sym->st_shndx) == toc)
d8389 9
a8397 1
		    unsigned long i;
d8399 3
a8401 20
		    if (sym->st_value > toc->rawsize)
		      i = toc->rawsize >> 3;
		    else
		      i = sym->st_value >> 3;

		    if ((skip[i] & (ref_from_discarded | can_optimize)) != 0)
		      {
			(*_bfd_error_handler)
			  (_("%s defined on removed toc entry"),
			   bfd_elf_sym_name (ibfd, symtab_hdr, sym, NULL));
			do
			  ++i;
			while ((skip[i] & (ref_from_discarded | can_optimize)));
			sym->st_value = (bfd_vma) i << 3;
		      }

		    sym->st_value -= skip[i];
		    symtab_hdr->contents = (unsigned char *) local_syms;
		  }
	    }
@


1.331
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Keep toc entries for ifuncs.
@
text
@d8042 1
a8042 1
	      if (!SYMBOL_REFERENCES_LOCAL (info, h))
d12378 1
a12378 1
			    && SYMBOL_REFERENCES_LOCAL (info, &h->elf)))
d12755 1
a12755 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, &h->elf)
@


1.330
log
@	* elf64-ppc.c (get_tls_mask): Don't segfault on NULL elf_section_data.
	(group_sections): Likewise.
@
text
@d8046 5
a8050 1
		val = h->root.u.def.value;
d8052 5
a8056 1
		val = sym->st_value;
@


1.329
log
@fix set but unused variable warnings
@
text
@d6692 1
d10670 2
a10671 1
	  big_sec = total > (ppc64_elf_section_data (tail)->has_14bit_branch
d10680 2
a10681 1
		     < (ppc64_elf_section_data (prev)->has_14bit_branch
d10714 2
a10715 1
			 < (ppc64_elf_section_data (prev)->has_14bit_branch
@


1.328
log
@include/elf/
	* ppc64.h (R_PPC64_LO_DS_OPT): Define.
bfd/
	* elf64-ppc.c (toc_skip_enum): Define.
	(ppc64_elf_edit_toc): Use two low bits of skip array as markers.
	Optimize largetoc sequences.
	(adjust_toc_syms): Update for skip array change.
	(ppc64_elf_relocate_section): Handle R_PPC64_LO_DS_OPT.
ld/
	* emultempl/ppc64elf.em (prelim_size_sections): New function.
	(ppc_before_allocation): Use it.  Size sections before toc edit too.
@
text
@d4847 1
a4847 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a4876 1

a4877 4
  sym_hashes_end = (sym_hashes
		    + symtab_hdr->sh_size / sizeof (Elf64_External_Sym)
		    - symtab_hdr->sh_info);

a6923 1
      struct elf_link_hash_entry **sym_hashes;
a6947 1
      sym_hashes = elf_sym_hashes (ibfd);
a7907 1
      struct elf_link_hash_entry **sym_hashes;
a7924 1
      sym_hashes = elf_sym_hashes (ibfd);
@


1.327
log
@	* elf64-ppc.c (is_static_defined): New function.
	(get_tls_mask, ppc_type_of_stub): Use it here.
	(ppc64_elf_edit_opd): Ensure we only attempt to edit ppc64 input.
	(ppc64_elf_tls_setup): Typo fix.
	(adjust_toc_syms): Correctly handle symbols defined past the end
	of the toc.  Move syms on removed entries to next entry rather
	than to start of toc.
	(ppc64_elf_edit_toc): Likewise.  Ensure we only attempt to
	edit ppc64 input.  Allocate one extra word in skip array.
	Honour info->keep_memory when reading relocs if we can.
	Adjust toc relocs after adjusting symbols.
@
text
@d7849 2
d7879 1
a7879 1
      if (toc_inf->skip[i] == (unsigned long) -1)
d7885 1
a7885 1
	  while (toc_inf->skip[i] == (unsigned long) -1);
d8006 1
a8006 1
	      skip[val >> 3] = 1;
d8013 74
d8179 25
d8209 1
a8209 1
			|| !skip[rel->r_offset >> 3]))
d8231 3
a8233 1
	      *drop = 0;
d8239 1
a8239 1
	      last = 1;
d8251 1
d8264 2
a8265 5
	      if (*drop)
		{
		  *drop = (unsigned long) -1;
		  off += 8;
		}
d8276 2
a8277 1
	  /* Adjust addends for relocs against the toc section sym.  */
d8319 1
a8319 1
		  if (sym_sec != toc || h != NULL || sym->st_value != 0)
d8322 10
a8331 1
		  val = rel->r_addend;
d8335 28
d8374 1
a8374 1
	  if (local_syms != NULL)
d8391 1
a8391 1
		    if (skip[sym->st_value >> 3] == (unsigned long) -1)
d8398 1
a8398 1
			while (skip[i] == (unsigned long) -1);
d8431 2
a8432 1
		if (skip[rel->r_offset >> 3] != (unsigned long) -1)
d11399 1
a11399 1
/* REL points to a low-part reloc on a bigtoc instruction sequence.
d11708 10
@


1.326
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Correct NOP location
	when optimizing high got_tlsgd/ld insns.
@
text
@d5569 11
d6718 1
a6718 4
  if ((h == NULL
       || ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && !h->def_dynamic))
d6935 3
d7389 1
a7389 1
			return FALSE;
d7854 1
d7872 2
a7873 3
      unsigned long skip = toc_inf->skip[eh->elf.root.u.def.value >> 3];
      if (skip != (unsigned long) -1)
	eh->elf.root.u.def.value -= skip;
d7875 3
d7880 5
a7884 3
	    (_("%s defined in removed toc entry"), eh->elf.root.root.string);
	  eh->elf.root.u.def.section = &bfd_abs_section;
	  eh->elf.root.u.def.value = 0;
d7886 2
d7919 3
d7999 1
a7999 1
		  skip = bfd_zmalloc (sizeof (*skip) * (toc->size + 7) / 8);
d8049 2
a8050 1
	  relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL, TRUE);
d8116 3
d8171 1
a8174 31
	  if (toc->reloc_count != 0)
	    {
	      Elf_Internal_Rela *wrel;
	      bfd_size_type sz;

	      /* Read toc relocs.  */
	      relstart = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL,
						    TRUE);
	      if (relstart == NULL)
		goto error_ret;

	      /* Remove unused toc relocs, and adjust those we keep.  */
	      wrel = relstart;
	      for (rel = relstart; rel < relstart + toc->reloc_count; ++rel)
		if (skip[rel->r_offset >> 3] != (unsigned long) -1)
		  {
		    wrel->r_offset = rel->r_offset - skip[rel->r_offset >> 3];
		    wrel->r_info = rel->r_info;
		    wrel->r_addend = rel->r_addend;
		    ++wrel;
		  }
		else if (!dec_dynrel_count (rel->r_info, toc, info,
					    &local_syms, NULL, NULL))
		  goto error_ret;

	      toc->reloc_count = wrel - relstart;
	      sz = elf_section_data (toc)->rel_hdr.sh_entsize;
	      elf_section_data (toc)->rel_hdr.sh_size = toc->reloc_count * sz;
	      BFD_ASSERT (elf_section_data (toc)->rel_hdr2 == NULL);
	    }

d8183 1
a8183 1
						    TRUE);
d8194 1
d8220 7
a8226 1
		  rel->r_addend -= skip[rel->r_addend >> 3];
d8228 3
d8245 4
a8248 2
		    if (skip[sym->st_value >> 3] != (unsigned long) -1)
		      sym->st_value -= skip[sym->st_value >> 3];
d8250 3
d8255 6
a8260 5
			  (_("%s defined in removed toc entry"),
			   bfd_elf_sym_name (ibfd, symtab_hdr, sym,
					     NULL));
			sym->st_value = 0;
			sym->st_shndx = SHN_ABS;
d8262 2
d8268 1
a8268 1
	  /* Finally, adjust any global syms defined in the toc.  */
d8277 31
d9054 2
a9055 6
      if (!((fdh->elf.root.type == bfd_link_hash_defined
	    || fdh->elf.root.type == bfd_link_hash_defweak)
	    && fdh->elf.root.u.def.section->output_section != NULL)
	  && !((h->elf.root.type == bfd_link_hash_defined
		|| h->elf.root.type == bfd_link_hash_defweak)
	       && h->elf.root.u.def.section->output_section != NULL))
@


1.325
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Nop out optimized
	TPREL16_HI and TPREL16_HA insns.
@
text
@d11653 1
a11654 1
		  rel->r_offset -= d_offset;
@


1.324
log
@	PR ld/11375
	* elf64-ppc.c (ppc64_elf_relocate_section): Always look up a
	possible stub on branches.
@
text
@d11572 12
@


1.323
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Add do_toc_opt.
	(ppc64_elf_edit_toc): Set it here.
	(ha_reloc_match): New function.
	(ppc64_elf_relocate_section): Optimize bigtoc insn sequences.
@
text
@a11916 1
	  stub_entry = NULL;
d11922 2
a11923 11
	  if (((fdh != NULL
		&& fdh->elf.plt.plist != NULL)
	       || (sec != NULL
		   && sec->output_section != NULL
		   && sec->id <= htab->top_id
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off))
	       || (h == NULL
		   && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC))
	      && (stub_entry = ppc_get_stub_entry (input_section, sec, fdh,
						   rel, htab)) != NULL
d12008 3
a12010 1
	  if (stub_entry == NULL
d12031 9
a12039 7
	  if (stub_entry == NULL
	      && (relocation + addend - from + max_br_offset
		  >= 2 * max_br_offset)
	      && r_type != R_PPC64_ADDR14_BRTAKEN
	      && r_type != R_PPC64_ADDR14_BRNTAKEN)
	    stub_entry = ppc_get_stub_entry (input_section, sec, fdh, rel,
					     htab);
@


1.322
log
@	* elf64-ppc.c (ppc64_elf_has_small_toc_reloc): New function.
	* elf64-ppc.h (ppc64_elf_has_small_toc_reloc): Declare.
@
text
@d3791 1
d7886 1
d7888 1
d11219 52
d11365 2
a11366 1
      unsigned long insn, mask;
d12724 75
@


1.321
log
@bfd/
	PR ld/11378
	* elf64-ppc.h (ppc64_elf_check_init_fini): Declare.
	* elf64-ppc.c (call_check_done): Define.
	(ppc64_elf_add_symbol_hook): Substitute bfd_get_section_name macro.
	(ppc64_elf_check_relocs, ppc64_elf_size_dynamic_sections): Likewise.
	(ppc64_elf_finish_multitoc_partition): Remove unnecessary check.
	(toc_adjusting_stub_needed): Use call_check_done rather than toc_off.
	Simplify return logic.  Iterate over all .init and .fini fragments
	by recursion.  Set makes_toc_func_call here..
	(ppc64_elf_next_input_section): ..rather than here.
	(check_pasted_section, ppc64_elf_check_init_fini): New functions.
ld/
	PR ld/11378
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_after_allocation): Call
	ppc64_elf_check_init_fini and warn if .init/.fini use different TOCs.
@
text
@d8277 10
@


1.320
log
@	PR ld/11375
	* elf64-ppc.c (ppc_type_of_stub): Always set *hash to the
	function descriptor symbol if there is one, not just for plt stubs.
	(ppc64_elf_relocate_section): Use fdh on all ppc_get_stub_entry calls.
@
text
@d3823 1
d4577 1
a4577 1
	   && strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
d4884 1
a4884 1
  if (strcmp (bfd_get_section_name (abfd, sec), ".opd") == 0)
d8815 1
a8815 1
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
a10128 3
  if (htab == NULL)
    return;

a10144 2
  Elf_Internal_Rela *relstart, *rel;
  Elf_Internal_Sym *local_syms;
d10146 3
a10148 1
  struct ppc_link_hash_table *htab;
a10159 10
  if (isec->reloc_count == 0)
    return 0;

  relstart = _bfd_elf_link_read_relocs (isec->owner, isec, NULL, NULL,
					info->keep_memory);
  if (relstart == NULL)
    return -1;

  /* Look for branches to outside of this section.  */
  local_syms = NULL;
d10161 1
a10161 5
  htab = ppc_hash_table (info);
  if (htab == NULL)
    return -1;

  for (rel = relstart; rel < relstart + isec->reloc_count; ++rel)
d10163 3
a10165 9
      enum elf_ppc64_reloc_type r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      struct ppc_link_hash_entry *eh;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      struct _opd_sec_data *opd;
      bfd_vma sym_value;
      bfd_vma dest;
d10167 4
a10170 6
      r_type = ELF64_R_TYPE (rel->r_info);
      if (r_type != R_PPC64_REL24
	  && r_type != R_PPC64_REL14
	  && r_type != R_PPC64_REL14_BRTAKEN
	  && r_type != R_PPC64_REL14_BRNTAKEN)
	continue;
d10172 5
a10176 7
      r_symndx = ELF64_R_SYM (rel->r_info);
      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms, r_symndx,
		      isec->owner))
	{
	  ret = -1;
	  break;
	}
d10178 1
a10178 7
      /* Calls to dynamic lib functions go through a plt call stub
	 that uses r2.  */
      eh = (struct ppc_link_hash_entry *) h;
      if (eh != NULL
	  && (eh->elf.plt.plist != NULL
	      || (eh->oh != NULL
		  && ppc_follow_link (eh->oh)->elf.plt.plist != NULL)))
d10180 9
a10188 3
	  ret = 1;
	  break;
	}
d10190 6
a10195 3
      if (sym_sec == NULL)
	/* Ignore other undefined symbols.  */
	continue;
d10197 7
a10203 7
      /* Assume branches to other sections not included in the link need
	 stubs too, to cover -R and absolute syms.  */
      if (sym_sec->output_section == NULL)
	{
	  ret = 1;
	  break;
	}
d10205 7
a10211 16
      if (h == NULL)
	sym_value = sym->st_value;
      else
	{
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    abort ();
	  sym_value = h->root.u.def.value;
	}
      sym_value += rel->r_addend;

      /* If this branch reloc uses an opd sym, find the code section.  */
      opd = get_opd_info (sym_sec);
      if (opd != NULL)
	{
	  if (h == NULL && opd->adjust != NULL)
d10213 2
a10214 7
	      long adjust;

	      adjust = opd->adjust[sym->st_value / 8];
	      if (adjust == -1)
		/* Assume deleted functions won't ever be called.  */
		continue;
	      sym_value += adjust;
d10217 2
a10218 2
	  dest = opd_entry_value (sym_sec, sym_value, &sym_sec, NULL);
	  if (dest == (bfd_vma) -1)
a10219 5
	}
      else
	dest = (sym_value
		+ sym_sec->output_offset
		+ sym_sec->output_section->vma);
d10221 7
a10227 3
      /* Ignore branch to self.  */
      if (sym_sec == isec)
	continue;
d10229 10
a10238 7
      /* If the called function uses the toc, we need a stub.  */
      if (sym_sec->has_toc_reloc
	  || sym_sec->makes_toc_func_call)
	{
	  ret = 1;
	  break;
	}
d10240 7
a10246 9
      /* Assume any branch that needs a long branch stub might in fact
	 need a plt_branch stub.  A plt_branch stub uses r2.  */
      else if (dest - (isec->output_offset
		       + isec->output_section->vma
		       + rel->r_offset) + (1 << 25) >= (2 << 25))
	{
	  ret = 1;
	  break;
	}
d10248 6
a10253 5
      /* If calling back to a section in the process of being tested, we
	 can't say for sure that no toc adjusting stubs are needed, so
	 don't return zero.  */
      else if (sym_sec->call_check_in_progress)
	ret = 2;
d10255 8
a10262 6
      /* Branches to another section that itself doesn't have any TOC
	 references are OK.  Recursively call ourselves to check.  */
      else if (sym_sec->id <= htab->top_id
	       && htab->stub_group[sym_sec->id].toc_off == 0)
	{
	  int recur;
d10264 3
a10266 6
	  /* Mark current section as indeterminate, so that other
	     sections that call back to current won't be marked as
	     known.  */
	  isec->call_check_in_progress = 1;
	  recur = toc_adjusting_stub_needed (info, sym_sec);
	  isec->call_check_in_progress = 0;
d10268 3
a10270 1
	  if (recur < 0)
d10272 1
a10272 2
	      /* An error.  Exit.  */
	      ret = -1;
d10275 6
a10280 1
	  else if (recur <= 1)
d10282 23
a10304 2
	      /* Known result.  Mark as checked and set section flag.  */
	      htab->stub_group[sym_sec->id].toc_off = 1;
d10307 3
a10309 3
		  sym_sec->makes_toc_func_call = 1;
		  ret = 1;
		  break;
d10312 26
a10337 5
	  else
	    {
	      /* Unknown result.  Continue checking.  */
	      ret = 2;
	    }
d10341 2
a10342 5
  if (local_syms != NULL
      && (elf_symtab_hdr (isec->owner).contents != (unsigned char *) local_syms))
    free (local_syms);
  if (elf_section_data (isec)->relocs != relstart)
    free (relstart);
d10388 3
a10390 8
      else if (htab->stub_group[isec->id].toc_off == 0)
	{
	  int ret = toc_adjusting_stub_needed (info, isec);
	  if (ret < 0)
	    return FALSE;
	  else
	    isec->makes_toc_func_call = ret & 1;
	}
d10395 1
a10395 1
     pasting work.  */
d10400 37
@


1.319
log
@Don't set ELFOSABI_LINUX in dynamic ifunc-using executable.

bfd/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_add_symbol_hook): Don't set
	has_ifunc_symbols if the symbol comes from a shared library.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): Likewise.

ld/testsuite/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc.exp: Expect System V OSABI in dynamic
	ifunc-using executable.
@
text
@d8979 4
a8982 1
	fdh = ppc_follow_link (h->oh);
a8987 1
	    *hash = fdh;
d11938 1
a11938 1
	    stub_entry = ppc_get_stub_entry (input_section, sec, h, rel,
@


1.318
log
@	* elf64-ppc.c (merge_got_entries): Move earlier in file.
	(allocate_dynrelocs): Merge got entries here if not doing multi-toc.
	(ppc64_elf_size_dynamic_sections): Similarly merge tlsld_got.
	(ppc64_elf_layout_multitoc): Don't resize if we have already
	merged got entries.
@
text
@d4560 1
a4560 1
ppc64_elf_add_symbol_hook (bfd *ibfd ATTRIBUTE_UNUSED,
d4569 4
a4572 1
    elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.317
log
@	* elf64-ppc.c (has_small_toc_reloc): Don't define.
	(makes_toc_func_call, call_check_in_progress): Shuffle flags.
	(struct ppc64_elf_obj_tdata): Add has_small_toc_reloc.  Update
	code setting the flag.
	(ppc64_elf_next_toc_section): Group big-toc sections in
	0x80008000 chunks.
@
text
@d8309 20
d8439 3
d8446 18
a8475 8
	if ((gent->tls_type & TLS_LD) != 0
	    && !h->def_dynamic)
	  {
	    ppc64_tlsld_got (gent->owner)->got.refcount += 1;
	    *pgent = gent->next;
	    continue;
	  }

a8479 1
	pgent = &gent->next;
a8480 2
    else
      *pgent = gent->next;
d8620 1
d8756 1
d8759 2
d8764 2
a8765 1
      if (ppc64_tlsld_got (ibfd)->got.refcount > 0)
d8767 6
a8772 5
	  s = ppc64_elf_tdata (ibfd)->got;
	  ppc64_tlsld_got (ibfd)->got.offset = s->size;
	  ppc64_tlsld_got (ibfd)->owner = ibfd;
	  s->size += 16;
	  if (info->shared)
d8774 11
a8784 2
	      asection *srel = ppc64_elf_tdata (ibfd)->relgot;
	      srel->size += sizeof (Elf64_External_Rela);
d8788 1
a8788 1
	ppc64_tlsld_got (ibfd)->got.offset = (bfd_vma) -1;
a9902 20
/* This function merges got entries in the same toc group.  */

static void
merge_got_entries (struct got_entry **pent)
{
  struct got_entry *ent, *ent2;

  for (ent = *pent; ent != NULL; ent = ent->next)
    if (!ent->is_indirect)
      for (ent2 = ent->next; ent2 != NULL; ent2 = ent2->next)
	if (!ent2->is_indirect
	    && ent2->addend == ent->addend
	    && ent2->tls_type == ent->tls_type
	    && elf_gp (ent2->owner) == elf_gp (ent->owner))
	  {
	    ent2->is_indirect = TRUE;
	    ent2->got.ent = ent;
	  }
}

d9953 3
@


1.316
log
@	* elf64-ppc.c (ppc64_elf_layout_multitoc): Don't merge local got ents.
@
text
@d2595 4
a3816 4
/* Nonzero if this section has small toc/got relocs, ie. that expect
   the reloc to be in the range -32768 to 32767.  */
#define has_small_toc_reloc sec_flg3

d3819 1
a3819 1
#define makes_toc_func_call sec_flg4
d3822 1
a3822 1
#define call_check_in_progress sec_flg5
d5026 1
a5026 1
	      sec->has_small_toc_reloc = 1;
d5127 1
a5127 1
	  sec->has_small_toc_reloc = 1;
d9793 1
a9793 1
  bfd_vma addr, off;
d9809 4
a9812 1
      if (off + isec->size > 0x10000)
@


1.315
log
@	* elf64-ppc.c (struct got_entry): Make tls_type and is_indirect
	unsigned char.  Update variables and code using them throughout file.
	(struct ppc_link_hash_entry): Likewise for tls_mask.
@
text
@d9925 1
a9925 24
  /* Merge local got entries within a toc group.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct got_entry **lgot_ents;
      struct got_entry **end_lgot_ents;
      Elf_Internal_Shdr *symtab_hdr;
      bfd_size_type locsymcount;

      if (!is_ppc64_elf (ibfd))
	continue;

      lgot_ents = elf_local_got_ents (ibfd);
      if (!lgot_ents)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_lgot_ents = lgot_ents + locsymcount;

      for (; lgot_ents < end_lgot_ents; ++lgot_ents)
	merge_got_entries (lgot_ents);
    }

  /* And the same for global sym got entries.  */
d10013 16
a10028 17
	    if (!ent->is_indirect)
	      {
		unsigned int num = 1;
		ent->got.offset = s->size;
		if ((ent->tls_type & *lgot_masks & TLS_GD) != 0)
		  num = 2;
		s->size += num * 8;
		if (info->shared)
		  srel->size += num * sizeof (Elf64_External_Rela);
		else if ((*lgot_masks & PLT_IFUNC) != 0)
		  {
		    htab->reliplt->size
		      += num * sizeof (Elf64_External_Rela);
		    htab->got_reli_size
		      += num * sizeof (Elf64_External_Rela);
		  }
	      }
@


1.314
log
@	* elf64-ppc.c (allocate_dynrelocs): Remove unused got structs here..
	(ppc64_elf_size_dynamic_sections): ..and here..
	(merge_got_entries): ..rather than here.
@
text
@d2549 1
a2549 1
  char tls_type;
d2552 1
a2552 1
  char is_indirect;
d3701 1
a3701 1
  char tls_mask;
d4748 1
a4748 1
  char *local_got_tls_masks;
d4790 1
a4790 1
  local_got_tls_masks = (char *) (local_plt + symtab_hdr->sh_info);
d5808 1
a5808 1
      char tls_type = 0;
d5843 1
a5843 1
	      char *local_got_tls_masks = (char *)
d6570 1
a6570 1
	   char **tls_maskp,
d6638 1
a6638 1
	  char *tls_mask;
d6646 1
a6646 1
	      char *lgot_masks = (char *)
d6661 1
a6661 1
get_tls_mask (char **tls_maskp,
d7483 2
a7484 2
		  char *tls_mask;
		  char tls_set, tls_clear, tls_type = 0;
d7697 1
a7697 1
			      char *toc_tls;
d8620 1
a8620 1
      char *lgot_masks;
d8663 1
a8663 1
      lgot_masks = (char *) end_local_plt;
d10011 1
a10011 1
      char *lgot_masks;
d10028 1
a10028 1
      lgot_masks = (char *) end_local_plt;
d10730 1
a10730 1
		      char *tls_mask;
d11243 2
a11244 2
      char tls_mask, tls_gd, tls_type;
      char sym_type;
d11342 1
a11342 1
	  char *lgot_masks = (char *)
d11352 1
a11352 1
	  char *toc_tls;
d11416 1
a11416 1
	    char *toc_tls;
@


1.313
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_table): Add do_multi_toc.
	(has_small_toc_reloc): Define.
	(ppc64_elf_check_relocs): Set the above flags.
	(ppc64_elf_edit_opd): Delete obfd param.
	(ppc64_elf_tls_optimize): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_tls_setup): Likewise.  Add no_multi_toc param.
	* elf64-ppc.h: Update prototypes.
ld/
	* emultempl/ppc64elf.em (ppc_before_allocation): Update for changed
	function parameters.
@
text
@d8320 1
a8320 1
  struct got_entry *gent;
d8419 2
a8420 1
  for (gent = h->got.glist; gent != NULL; gent = gent->next)
d8439 1
a8439 1
	    gent->got.offset = (bfd_vma) -1;
d8447 1
d8450 1
a8450 1
      gent->got.offset = (bfd_vma) -1;
d8668 1
a8668 1
	  struct got_entry *ent;
d8670 2
a8671 1
	  for (ent = *lgot_ents; ent != NULL; ent = ent->next)
d8677 1
a8677 1
		    ent->got.offset = (bfd_vma) -1;
d8695 1
d8699 1
a8699 1
	      ent->got.offset = (bfd_vma) -1;
d9855 1
a9855 2
/* This function removes unneeded got entries (those with got.offset == -1)
   and merges entries in the same toc group.  */
d9862 11
a9872 22
  while ((ent = *pent) != NULL)
    {
      if (!ent->is_indirect)
	{
	  if (ent->got.offset == (bfd_vma) -1)
	    {
	      *pent = ent->next;
	      continue;
	    }
	  for (ent2 = ent->next; ent2 != NULL; ent2 = ent2->next)
	    if (!ent2->is_indirect
		&& ent2->got.offset != (bfd_vma) -1
		&& ent2->addend == ent->addend
		&& ent2->tls_type == ent->tls_type
		&& elf_gp (ent2->owner) == elf_gp (ent->owner))
	      {
		ent2->is_indirect = TRUE;
		ent2->got.ent = ent;
	      }
	}
      pent = &ent->next;
    }
@


1.312
log
@	* section.c (struct bfd_section): Delete has_tls_reloc,
	has_tls_get_addr_call, has_gp_reloc, need_finalize_relax, reloc_done.
	Add sec_flg0 thru sec_flg5.
	(BFD_FAKE_SECTION): Update for changed flags.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	* elf64-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Update.
	* elf32-xtensa.c (reloc_done): Define.
	* elfxx-ia64.c (skip_relax_pass_0, skip_relax_pass_1): Update.
	* bfd-in2.h: Regenerate.
@
text
@d3784 1
d3813 4
d5018 11
d5125 3
a5130 1
	case R_PPC64_TOC16_DS:
d6904 1
a6904 2
ppc64_elf_edit_opd (bfd *obfd, struct bfd_link_info *info,
		    bfd_boolean non_overlapping)
d7074 1
a7074 1
	  opd->adjust = bfd_zalloc (obfd, amt);
d7305 3
a7307 3
ppc64_elf_tls_setup (bfd *obfd,
		     struct bfd_link_info *info,
		     int no_tls_get_addr_opt)
d7315 5
d7400 1
a7400 1
  return _bfd_elf_tls_setup (obfd, info);
d7437 1
a7437 1
ppc64_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
d7877 1
a7877 1
ppc64_elf_edit_toc (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
@


1.311
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d3802 16
a3817 3
#define has_toc_reloc has_gp_reloc
#define makes_toc_func_call need_finalize_relax
#define call_check_in_progress reloc_done
@


1.310
log
@bfd/
	* elf64-ppc.c (struct plt_entry): Move earlier in file.
	(struct got_entry): Likewise.  Add is_indirect and got.ent fields.
	(struct ppc64_elf_obj_tdata): Change tlsld_got to be a struct got_entry.
	Update all uses.
	(struct ppc_link_hash_table): Add got_reli_size and second_toc_pass.
	Remove no_multi_toc.
	(update_local_sym_info, ppc64_elf_check_relocs): Clear is_indirect
	when allocating a new struct got_entry.
	(allocate_got): New function, extracted from..
	(allocate_dynrelocs): ..here.  Abort on got entry in non-ppc64 bfd.
	(ppc64_elf_size_dynamic_sections): Track got relocs allocated in
	.reliplt by got_reli_size.  Set owner on ppc64_tlsld_got entries.
	(ppc64_elf_setup_section_lists): Remove output_bfd param and
	no_multi_toc, add add_stub_section and layout_sections_again.  Stash
	new params in htab.  Extract some code to..
	(ppc64_elf_start_multitoc_partition): ..here.  New function.
	(ppc64_elf_next_toc_section): Check for linker script errors.  Handle
	second pass toc scan.
	(merge_got_entries, merge_global_got, reallocate_got): New functions.
	(ppc64_elf_reinit_toc): Rename to..
	(ppc64_elf_finish_multitoc_partition): ..this.
	(ppc64_elf_layout_multitoc): New function.
	(ppc64_elf_size_stubs): Delete output_bfd, add_stub_section and
	layout_sections_again params.
	(ppc64_elf_relocate_section): Handle indirect got entries.
	* elf64-ppc.h: Update prototypes.  Declare new functions.
ld/
	* emultempl/ppc64elf.em (build_toc_list): Report errors from
	ppc64_elf_next_toc_section.
	(after_allocation): Update for changed function names and params.
	Run second pass of multitoc partitioning.
@
text
@d2605 1
a2605 1
   && elf_object_id (bfd) == PPC64_ELF_TDATA)
d2613 1
a2613 1
				  PPC64_ELF_TDATA);
d3809 2
a3810 1
  ((struct ppc_link_hash_table *) ((p)->hash))
d3955 2
a3956 1
				      sizeof (struct ppc_link_hash_entry)))
d4013 2
d4174 2
d4244 2
d4287 3
d4622 3
a4671 1
  htab = ppc_hash_table (info);
d4674 3
d4715 6
a4720 1
  ppc_hash_table (info)->dot_syms = NULL;
d4846 3
d5574 3
d5764 3
d5930 1
a5930 1
static unsigned int
d5939 3
d6168 2
d6308 3
d6343 2
d6504 3
d7120 6
a7125 2
		      fdh = lookup_fdh ((struct ppc_link_hash_entry *) h,
					ppc_hash_table (info));
d7282 3
d7413 3
d8295 2
d8555 3
d9128 2
d9526 2
d9679 2
d9756 3
d10089 3
d10135 3
d10310 3
d10478 3
d10902 3
d11104 3
a11106 1
  elf_link_hash_traverse (&htab->elf, undo_symbol_twiddle, info);
d11186 2
d12797 2
d12898 3
@


1.309
log
@	PR ld/11217
	* elf64-ppc.c (struct ppc_link_hash_table): Add toc_bfd, toc_first_sec.
	(ppc64_elf_setup_section_lists): Init them.
	(ppc64_elf_next_toc_section): Don't partition multi-toc between .got
	and .toc on the same input file.
	(ppc64_elf_relocate_section): Correct GOT entry offset.
@
text
@d2529 48
d2589 1
a2589 1
  /* TLS local dynamic got entry handling.  Suppose for multiple GOT
d2591 1
a2591 4
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;
a3500 44
/* Track GOT entries needed for a given symbol.  We might need more
   than one got entry per symbol.  */
struct got_entry
{
  struct got_entry *next;

  /* The symbol addend that we'll be placing in the GOT.  */
  bfd_vma addend;

  /* Unlike other ELF targets, we use separate GOT entries for the same
     symbol referenced from different input files.  This is to support
     automatic multiple TOC/GOT sections, where the TOC base can vary
     from one input file to another.  FIXME: After group_sections we
     ought to merge entries within the group.

     Point to the BFD owning this GOT entry.  */
  bfd *owner;

  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
  char tls_type;

  /* Reference count until size_dynamic_sections, GOT offset thereafter.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } got;
};

/* The same for PLT.  */
struct plt_entry
{
  struct plt_entry *next;

  bfd_vma addend;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
};

d3768 3
a3783 1
  unsigned int no_multi_toc:1;
d3785 1
d4743 1
d5001 1
d8185 36
a8331 3
	bfd_boolean dyn;
	asection *rsec;

d8347 1
a8347 1
	    ppc64_tlsld_got (gent->owner)->refcount += 1;
d8353 1
a8353 1
	  continue;
d8355 1
a8355 17
	s = ppc64_elf_tdata (gent->owner)->got;
	gent->got.offset = s->size;
	s->size
	  += (gent->tls_type & eh->tls_mask & (TLS_GD | TLS_LD)) ? 16 : 8;
	dyn = htab->elf.dynamic_sections_created;
	rsec = NULL;
	if ((info->shared
	     || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	    && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak))
	  rsec = ppc64_elf_tdata (gent->owner)->relgot;
	else if (h->type == STT_GNU_IFUNC)
	  rsec = htab->reliplt;
	if (rsec != NULL)
	  rsec->size += (gent->tls_type & eh->tls_mask & TLS_GD
			 ? 2 * sizeof (Elf64_External_Rela)
			 : sizeof (Elf64_External_Rela));
d8580 1
a8580 1
		    ppc64_tlsld_got (ibfd)->refcount += 1;
d8593 6
a8598 1
		      htab->reliplt->size += num * sizeof (Elf64_External_Rela);
d8633 1
a8633 1
      if (ppc64_tlsld_got (ibfd)->refcount > 0)
d8636 2
a8637 1
	  ppc64_tlsld_got (ibfd)->offset = s->size;
d8646 1
a8646 1
	ppc64_tlsld_got (ibfd)->offset = (bfd_vma) -1;
d9605 4
a9608 3
ppc64_elf_setup_section_lists (bfd *output_bfd,
			       struct bfd_link_info *info,
			       int no_multi_toc)
d9617 3
a9619 1
  htab->no_multi_toc = no_multi_toc;
a9647 4
  elf_gp (output_bfd) = htab->toc_curr = ppc64_elf_toc (output_bfd);
  htab->toc_bfd = NULL;
  htab->toc_first_sec = NULL;

d9651 1
a9651 1
  for (section = output_bfd->sections, top_index = 0;
d9669 13
d9684 1
a9684 2
   within a group is less than 64k in size.  Will break with cute linker
   scripts that play games with dot in the output toc section.  */
d9686 1
a9686 1
void
d9690 1
d9692 1
a9692 1
  if (!htab->no_multi_toc)
d9694 1
a9694 2
      bfd_vma addr, off;

d9700 1
d9710 30
a9739 3
      elf_gp (isec->owner) = (htab->toc_curr
			      - elf_gp (isec->output_section->owner)
			      + TOC_BASE_OFF);
d9741 6
d9749 267
a10015 1
/* Called after the last call to the above function.  */
d10018 1
a10018 1
ppc64_elf_reinit_toc (bfd *output_bfd, struct bfd_link_info *info)
d10022 2
a10023 4
  htab->multi_toc_needed = htab->toc_curr != elf_gp (output_bfd);

  /* toc_curr tracks the TOC offset used for code sections below in
     ppc64_elf_next_input_section.  Start off at 0x8000.  */
d10396 1
a10396 5
ppc64_elf_size_stubs (bfd *output_bfd,
		      struct bfd_link_info *info,
		      bfd_signed_vma group_size,
		      asection *(*add_stub_section) (const char *, asection *),
		      void (*layout_sections_again) (void))
a10401 3
  /* Stash our params away.  */
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
d10453 1
a10453 1
		  || section->output_section->owner != output_bfd)
d11933 1
d11938 1
a11938 1
	      offp = &ppc64_tlsld_got (input_bfd)->offset;
a11940 1
		struct got_entry *ent;
a11972 3
		if (ent == NULL)
		  abort ();
		offp = &ent->got.offset;
d11975 6
a11980 1
	    got = ppc64_elf_tdata (input_bfd)->got;
d12004 3
a12006 2
		    && (offp == &ppc64_tlsld_got (input_bfd)->offset
			|| h == NULL
d12009 1
a12009 1
		  relgot = ppc64_elf_tdata (input_bfd)->relgot;
@


1.308
log
@	PR ld/11217
	* elf64-ppc.c (ppc64_elf_tls_optimize): Optimize tls sequences
	with relocations against undefined weak symbols.
	(ppc64_elf_relocate_section): Don't optimize calls to undefined
	weak functions if the symbol is dynamic.
	(ppc64_elf_relocate_section): Edit tprel tls sequences.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(_bfd_elf_ppc_at_tprel_transform): New function.
	* bfd-in.h (_bfd_elf_ppc_at_tprel_transform): Declare.
	* bfd-in2.h: Regenerate.
@
text
@d3735 2
d9617 2
d9653 1
a9653 2
      bfd_vma addr = isec->output_offset + isec->output_section->vma;
      bfd_vma off = addr - htab->toc_curr;
d9655 7
d9663 5
a9667 1
	htab->toc_curr = addr;
d11762 2
a11763 4
	    relocation = got->output_offset + off;

	    /* TOC base (r2) is TOC start plus 0x8000.  */
	    addend = -TOC_BASE_OFF;
@


1.307
log
@	PR ld/11133
	* elf32-cr16.c (elf32_cr16_gc_mark_hook): Call _bfd_elf_gc_mark_hook.
	* elf32-microblaze.c (microblaze_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
@
text
@d7412 6
a7417 2
		      if (h->root.type != bfd_link_hash_defined
			  && h->root.type != bfd_link_hash_defweak)
a7418 1
		      value = h->root.u.def.value;
d7431 11
a7441 5
		      value += sym_sec->output_offset;
		      value += sym_sec->output_section->vma;
		      value -= htab->elf.tls_sec->vma;
		      ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				  < (bfd_vma) 1 << 32);
d11510 1
d11846 16
@


1.306
log
@	* elf64-ppc.c: Delete my email address.
@
text
@d3 1
a3 1
   2009 Free Software Foundation, Inc.
d5627 1
a5627 1
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
d5686 1
a5686 1
	      break;
@


1.305
log
@	PR ld/11088
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Don't abort if symbol
	hiding has nulled out plt.plist.
@
text
@d6 1
a6 1
   Largely rewritten by Alan Modra <amodra@@bigpond.net.au>
@


1.304
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d5867 1
a5867 3
	      if (ent == NULL)
		abort ();
	      if (ent->plt.refcount > 0)
@


1.303
log
@	PR ld/11047
	* elf32-ppc.c (ppc_elf_relocate_section): Delete __tls_get_addr
	symbol reference from relocs belonging to calls that are
	optimized away.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@a5403 2
      bfd_vma val;

d8576 1
a8576 2
		asection *s = htab->iplt;

a11919 1
	      Elf_Internal_Rela outrel;
a11921 1
	      bfd_byte *loc;
a12381 3
      Elf_Internal_Rela rela;
      bfd_byte *loc;

@


1.302
log
@bfd/
	* bfd-in.h (_bfd_elf_ppc_at_tls_transform): Declare.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (ppc64_elf_relocate_section): Move code for R_PPC64_TLS
	insn optimisation to..
	* elf32-ppc.c (_bfd_elf_ppc_at_tls_transform): ..here.  New function.
	(ppc_elf_relocate_section): Use it.
gas/
	* config/tc-ppc.c (md_assemble): Report error on invalid @@tls operands
	and opcode.
@
text
@d11105 1
a11105 2
		    rel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (rel[1].r_info),
						  R_PPC64_NONE);
d11204 1
a11204 2
	      rel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (rel[1].r_info),
					    R_PPC64_NONE);
d11249 1
a11249 2
	      rel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (rel[1].r_info),
					    R_PPC64_NONE);
@


1.301
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@a11020 1
	      bfd_vma rtra;
d11022 2
a11023 27
	      if ((insn & ((0x3f << 26) | (31 << 11)))
		  == ((31 << 26) | (13 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((0x3f << 26) | (31 << 16)))
		       == ((31 << 26) | (13 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
a11024 1
	      insn |= rtra;
@


1.300
log
@bfd/
	* elf64-ppc.c (follow_link, elf_follow_link, ppc_follow_link): New
	functions.  Use throughout.
	(ppc64_elf_copy_indirect_symbol): Set direct symbol "oh" field
	from indirect symbol.
	(lookup_fdh): Rename from get_fdh.  Follow indirect sym links.
	(add_symbol_adjust): Simplify.
	(defined_code_entry, defined_func_desc): New functions.
	(ppc64_elf_gc_keep): Follow indirect sym links.  Use defined_code_entry.
	(ppc64_elf_gc_mark_dynamic_ref): Use defined_func_desc and
	defined_code_entry to follow indirect sym links.
	(ppc64_elf_gc_mark_hook, func_desc_adjust): Likewise.
	(ppc_type_of_stub): Follow indirect sym links.
	(toc_adjusting_stub_needed): Likewise.
	(ppc_build_one_stub): Likewise.  Make undefined dot-symbols weak
	rather than defining them at stub.
	(ppc64_elf_relocate_section): Rewrite call test to avoid multiple
	assignments in test.
ld/testsuite/
	* ld-powerpc/tlsso.d: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.d: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@d3774 3
d7224 3
a7226 1
ppc64_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
d7234 3
d7240 71
d8748 6
d8947 43
d9358 7
a9364 1
      p = build_plt_stub (htab->stub_bfd, loc, off, r);
d9453 5
d11397 10
a11406 2
		      bfd_put_32 (input_bfd, LD_R2_40R1,
				  contents + rel->r_offset + 4);
@


1.299
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Always set up sections
	used by indirect function support.  Count dynamic relocs for
	ifunc syms.
	(ppc_elf_adjust_dynamic_symbol): Tweak for ifunc.
	(allocate_dynrelocs): Allocate all non-dynamic ifunc plt entries
	in iplt and their relocs in reliplt.  Don't make ifunc syms
	dynamic.  Allocate got entry relocs for non-dynamic ifunc in
	reliplt.  Handle other dynamic relocs for ifunc.
	(ppc_elf_size_dynamic_sections): Alloc dyn relocs for static
	ifunc in reliplt, likewise relocs for got against local ifunc.
	Typo fix on reliplt size adjust.
	(ppc_elf_relocate_section): Don't use plt scheme of allocating
	relocs 1-1 with entries for iplt, instead just add using
	reloc_count.  Write got relocs and dyn relocs for ifunc to reliplt.
	Error on invalid ifunc dyn relocs.
	(ppc_elf_finish_dynamic_symbol): Adjust for non-dynamic ifunc plt
	in iplt/reliplt.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_JMP_IREL,
	R_PPC64_REL16, R_PPC64_REL16_LO, R_PPC64_REL16_HI, R_PPC64_REL16_HA.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Likewise.  Count dyn relocs for ifunc.
	(allocate_dynrelocs): As for elf32-ppc.c above.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc_build_one_stub): Put non-dynamic ifunc plt call stubs in iplt,
	and their relocs in reliplt.  Use R_PPC64_JMP_IREL.
	(ppc_size_one_stub): Similarly.
	(ppc64_elf_relocate_section): As for elf32-ppc.c above.  Handle new
	relocs too.
	(ppc64_elf_finish_dynamic_symbol): As for elf32-ppc.c above.
@
text
@d4285 23
d4390 2
d4461 1
a4461 1
get_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
d4471 7
a4477 7
      if (fdh != NULL)
	{
	  fdh->is_func_descriptor = 1;
	  fdh->oh = fh;
	  fh->is_func = 1;
	  fh->oh = fdh;
	}
d4480 1
a4480 1
  return fdh;
d4602 16
a4617 15
  fdh = get_fdh (eh, htab);
  if (fdh == NULL
      && !info->relocatable
      && (eh->elf.root.type == bfd_link_hash_undefined
	  || eh->elf.root.type == bfd_link_hash_undefweak)
      && eh->elf.ref_regular)
    {
      /* Make an undefweak function descriptor sym, which is enough to
	 pull in an --as-needed shared lib, but won't cause link
	 errors.  Archives are handled elsewhere.  */
      fdh = make_fdh (info, eh);
      if (fdh == NULL)
	return FALSE;
      else
	fdh->elf.ref_regular = 1;
d4619 1
a4619 1
  else if (fdh != NULL)
d4868 1
a4868 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d5226 1
a5226 1
		      && get_fdh ((struct ppc_link_hash_entry *) h, htab))
d5479 1
a5479 3
		  while (rh->root.type == bfd_link_hash_indirect
			 || rh->root.type == bfd_link_hash_warning)
		    rh = ((struct elf_link_hash_entry *) rh->root.u.i.link);
d5500 33
d5543 1
a5543 1
      struct ppc_link_hash_entry *eh;
d5547 1
a5547 1
	elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
d5554 2
a5555 3
      if (eh->is_func_descriptor
	  && (eh->oh->elf.root.type == bfd_link_hash_defined
	      || eh->oh->elf.root.type == bfd_link_hash_defweak))
d5557 1
a5557 1
	  sec = eh->oh->elf.root.u.def.section;
d5580 1
d5586 3
a5588 5
  if (eh->oh != NULL
      && eh->oh->is_func_descriptor
      && (eh->oh->elf.root.type == bfd_link_hash_defined
	  || eh->oh->elf.root.type == bfd_link_hash_defweak))
    eh = eh->oh;
d5599 1
d5605 6
a5610 4
      if (eh->is_func_descriptor
	  && (eh->oh->elf.root.type == bfd_link_hash_defined
	      || eh->oh->elf.root.type == bfd_link_hash_defweak))
	eh->oh->elf.root.u.def.section->flags |= SEC_KEEP;
d5642 1
a5642 1
      struct ppc_link_hash_entry *eh;
d5657 3
a5659 5
	      if (eh->oh != NULL
		  && eh->oh->is_func_descriptor
		  && (eh->oh->elf.root.type == bfd_link_hash_defined
		      || eh->oh->elf.root.type == bfd_link_hash_defweak))
		eh = eh->oh;
d5663 2
a5664 3
	      if (eh->is_func_descriptor
		  && (eh->oh->elf.root.type == bfd_link_hash_defined
		      || eh->oh->elf.root.type == bfd_link_hash_defweak))
d5669 1
a5669 1
		  rsec = eh->oh->elf.root.u.def.section;
d5749 1
a5749 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d6135 4
a6138 5
      && (fh->oh->elf.root.type == bfd_link_hash_defined
	  || fh->oh->elf.root.type == bfd_link_hash_defweak)
      && get_opd_info (fh->oh->elf.root.u.def.section) != NULL
      && opd_entry_value (fh->oh->elf.root.u.def.section,
			  fh->oh->elf.root.u.def.value,
d6142 1
a6142 1
      fh->elf.root.type = fh->oh->elf.root.type;
d6144 2
a6145 2
      fh->elf.def_regular = fh->oh->elf.def_regular;
      fh->elf.def_dynamic = fh->oh->elf.def_dynamic;
d6164 1
a6164 6
  fdh = get_fdh (fh, htab);
  if (fdh != NULL)
    while (fdh->elf.root.type == bfd_link_hash_indirect
	   || fdh->elf.root.type == bfd_link_hash_warning)
      fdh = (struct ppc_link_hash_entry *) fdh->elf.root.u.i.link;

d6502 1
a6502 3
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
d7070 2
a7071 2
		      fdh = get_fdh ((struct ppc_link_hash_entry *) h,
				     ppc_hash_table (info));
d7254 1
a7254 3
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
d8712 3
a8714 3
      if (fdh->oh != NULL
	  && fdh->oh->is_func_descriptor)
	fdh = fdh->oh;
d8988 1
a8988 1
		h = h->oh;
a9152 3
      /* Do the best we can for shared libraries built without
	 exporting ".foo" for each "foo".  This can happen when symbol
	 versioning scripts strip all bar a subset of symbols.  */
d9154 13
a9166 12
	  && stub_entry->h->oh != NULL
	  && stub_entry->h->oh->elf.root.type != bfd_link_hash_defined
	  && stub_entry->h->oh->elf.root.type != bfd_link_hash_defweak)
	{
	  /* Point the symbol at the stub.  There may be multiple stubs,
	     we don't really care;  The main thing is to make this sym
	     defined somewhere.  Maybe defining the symbol in the stub
	     section is a silly idea.  If we didn't do this, htab->top_id
	     could disappear.  */
	  stub_entry->h->oh->elf.root.type = bfd_link_hash_defined;
	  stub_entry->h->oh->elf.root.u.def.section = stub_entry->stub_sec;
	  stub_entry->h->oh->elf.root.u.def.value = stub_entry->stub_offset;
d9603 1
a9603 1
		  && eh->oh->elf.plt.plist != NULL)))
d10042 1
a10042 1
			  && (fdh = get_fdh (hash, htab)) != NULL)
d11230 6
a11235 4
	  if (((h != NULL
		&& (((fdh = h->oh) != NULL
		     && fdh->elf.plt.plist != NULL)
		    || (fdh = h)->elf.plt.plist != NULL))
@


1.299.2.1
log
@bfd/
	* elf64-ppc.c (follow_link, elf_follow_link, ppc_follow_link): New
	functions.  Use throughout.
	(ppc64_elf_copy_indirect_symbol): Set direct symbol "oh" field
	from indirect symbol.
	(lookup_fdh): Rename from get_fdh.  Follow indirect sym links.
	(add_symbol_adjust): Simplify.
	(defined_code_entry, defined_func_desc): New functions.
	(ppc64_elf_gc_keep): Follow indirect sym links.  Use defined_code_entry.
	(ppc64_elf_gc_mark_dynamic_ref): Use defined_func_desc and
	defined_code_entry to follow indirect sym links.
	(ppc64_elf_gc_mark_hook, func_desc_adjust): Likewise.
	(ppc_type_of_stub): Follow indirect sym links.
	(toc_adjusting_stub_needed): Likewise.
	(ppc_build_one_stub): Likewise.  Make undefined dot-symbols weak
	rather than defining them at stub.
	(ppc64_elf_relocate_section): Rewrite call test to avoid multiple
	assignments in test.
ld/testsuite/
	* ld-powerpc/tlsso.d: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.d: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@a4284 23
/* Follow indirect and warning symbol links.  */

static inline struct bfd_link_hash_entry *
follow_link (struct bfd_link_hash_entry *h)
{
  while (h->type == bfd_link_hash_indirect
	 || h->type == bfd_link_hash_warning)
    h = h->u.i.link;
  return h;
}

static inline struct elf_link_hash_entry *
elf_follow_link (struct elf_link_hash_entry *h)
{
  return (struct elf_link_hash_entry *) follow_link (&h->root);
}

static inline struct ppc_link_hash_entry *
ppc_follow_link (struct ppc_link_hash_entry *h)
{
  return (struct ppc_link_hash_entry *) follow_link (&h->elf.root);
}

a4366 2
  if (eind->oh != NULL)
    edir->oh = ppc_follow_link (eind->oh);
d4436 1
a4436 1
lookup_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
d4446 7
a4452 7
      if (fdh == NULL)
	return fdh;

      fdh->is_func_descriptor = 1;
      fdh->oh = fh;
      fh->is_func = 1;
      fh->oh = fdh;
d4455 1
a4455 1
  return ppc_follow_link (fdh);
d4577 15
a4591 16
  fdh = lookup_fdh (eh, htab);
  if (fdh == NULL)
    {
      if (!info->relocatable
	  && (eh->elf.root.type == bfd_link_hash_undefined
	      || eh->elf.root.type == bfd_link_hash_undefweak)
	  && eh->elf.ref_regular)
	{
	  /* Make an undefweak function descriptor sym, which is enough to
	     pull in an --as-needed shared lib, but won't cause link
	     errors.  Archives are handled elsewhere.  */
	  fdh = make_fdh (info, eh);
	  if (fdh == NULL)
	    return FALSE;
	  fdh->elf.ref_regular = 1;
	}
d4593 1
a4593 1
  else
d4842 3
a4844 1
	  h = elf_follow_link (h);
d5202 1
a5202 1
		      && lookup_fdh ((struct ppc_link_hash_entry *) h, htab))
d5455 3
a5457 1
		  rh = elf_follow_link (rh);
a5477 33
/* If FDH is a function descriptor symbol, return the associated code
   entry symbol if it is defined.  Return NULL otherwise.  */

static struct ppc_link_hash_entry *
defined_code_entry (struct ppc_link_hash_entry *fdh)
{
  if (fdh->is_func_descriptor)
    {
      struct ppc_link_hash_entry *fh = ppc_follow_link (fdh->oh);
      if (fh->elf.root.type == bfd_link_hash_defined
	  || fh->elf.root.type == bfd_link_hash_defweak)
	return fh;
    }
  return NULL;
}

/* If FH is a function code entry symbol, return the associated
   function descriptor symbol if it is defined.  Return NULL otherwise.  */

static struct ppc_link_hash_entry *
defined_func_desc (struct ppc_link_hash_entry *fh)
{
  if (fh->oh != NULL
      && fh->oh->is_func_descriptor)
    {
      struct ppc_link_hash_entry *fdh = ppc_follow_link (fh->oh);
      if (fdh->elf.root.type == bfd_link_hash_defined
	  || fdh->elf.root.type == bfd_link_hash_defweak)
	return fdh;
    }
  return NULL;
}

d5488 1
a5488 1
      struct ppc_link_hash_entry *eh, *fh;
d5492 1
a5492 1
	elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, TRUE);
d5499 3
a5501 2
      fh = defined_code_entry (eh);
      if (fh != NULL)
d5503 1
a5503 1
	  sec = fh->elf.root.u.def.section;
a5525 1
  struct ppc_link_hash_entry *fdh;
d5531 5
a5535 3
  fdh = defined_func_desc (eh);
  if (fdh != NULL)
    eh = fdh;
a5545 1
      struct ppc_link_hash_entry *fh;
d5551 4
a5554 6
      fh = defined_code_entry (eh);
      if (fh != NULL)
	{
	  code_sec = fh->elf.root.u.def.section;
	  code_sec->flags |= SEC_KEEP;
	}
d5586 1
a5586 1
      struct ppc_link_hash_entry *eh, *fh, *fdh;
d5601 5
a5605 3
	      fdh = defined_func_desc (eh);
	      if (fdh != NULL)
		eh = fdh;
d5609 3
a5611 2
	      fh = defined_code_entry (eh);
	      if (fh != NULL)
d5616 1
a5616 1
		  rsec = fh->elf.root.u.def.section;
d5696 3
a5698 1
	  h = elf_follow_link (h);
d6084 5
a6088 4
      && (fdh = defined_func_desc (fh)) != NULL
      && get_opd_info (fdh->elf.root.u.def.section) != NULL
      && opd_entry_value (fdh->elf.root.u.def.section,
			  fdh->elf.root.u.def.value,
d6092 1
a6092 1
      fh->elf.root.type = fdh->elf.root.type;
d6094 2
a6095 2
      fh->elf.def_regular = fdh->elf.def_regular;
      fh->elf.def_dynamic = fdh->elf.def_dynamic;
d6114 6
a6119 1
  fdh = lookup_fdh (fh, htab);
d6457 3
a6459 1
      h = elf_follow_link (h);
d7027 2
a7028 2
		      fdh = lookup_fdh ((struct ppc_link_hash_entry *) h,
					ppc_hash_table (info));
d7211 3
a7213 1
      h = elf_follow_link (h);
d8671 3
a8673 3
      if (h->oh != NULL
	  && h->oh->is_func_descriptor)
	fdh = ppc_follow_link (h->oh);
d8947 1
a8947 1
		h = ppc_follow_link (h->oh);
d9112 3
d9116 12
a9127 13
	  && stub_entry->h->is_func_descriptor
	  && stub_entry->h->oh != NULL)
	{
	  struct ppc_link_hash_entry *fh = ppc_follow_link (stub_entry->h->oh);

	  /* If the old-ABI "dot-symbol" is undefined make it weak so
	     we don't get a link error from RELOC_FOR_GLOBAL_SYMBOL.
	     FIXME: We used to define the symbol on one of the call
	     stubs instead, which is why we test symbol section id
	     against htab->top_id in various places.  Likely all
	     these checks could now disappear.  */
	  if (fh->elf.root.type == bfd_link_hash_undefined)
	    fh->elf.root.type = bfd_link_hash_undefweak;
d9564 1
a9564 1
		  && ppc_follow_link (eh->oh)->elf.plt.plist != NULL)))
d10003 1
a10003 1
			  && (fdh = lookup_fdh (hash, htab)) != NULL)
d11191 4
a11194 6
	  if (h != NULL
	      && h->oh != NULL
	      && h->oh->is_func_descriptor)
	    fdh = ppc_follow_link (h->oh);
	  if (((fdh != NULL
		&& fdh->elf.plt.plist != NULL)
@


1.299.2.2
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@a3773 3
  /* Set if __tls_get_addr optimization should not be done.  */
  unsigned int no_tls_get_addr_opt:1;

d7221 1
a7221 3
ppc64_elf_tls_setup (bfd *obfd,
		     struct bfd_link_info *info,
		     int no_tls_get_addr_opt)
a7228 3
  /* Move dynamic linking info to the function descriptor sym.  */
  if (htab->tls_get_addr != NULL)
    func_desc_adjust (&htab->tls_get_addr->elf, info);
a7231 71
  if (!no_tls_get_addr_opt)
    {
      struct elf_link_hash_entry *opt, *opt_fd, *tga, *tga_fd;

      opt = elf_link_hash_lookup (&htab->elf, ".__tls_get_addr_opt",
				  FALSE, FALSE, TRUE);
      if (opt != NULL)
	func_desc_adjust (opt, info);
      opt_fd = elf_link_hash_lookup (&htab->elf, "__tls_get_addr_opt",
				     FALSE, FALSE, TRUE);
      if (opt_fd != NULL
	  && (opt_fd->root.type == bfd_link_hash_defined
	      || opt_fd->root.type == bfd_link_hash_defweak))
	{
	  /* If glibc supports an optimized __tls_get_addr call stub,
	     signalled by the presence of __tls_get_addr_opt, and we'll
	     be calling __tls_get_addr via a plt call stub, then
	     make __tls_get_addr point to __tls_get_addr_opt.  */
	  tga_fd = &htab->tls_get_addr_fd->elf;
	  if (htab->elf.dynamic_sections_created
	      && tga_fd != NULL
	      && (tga_fd->type == STT_FUNC
		  || tga_fd->needs_plt)
	      && !(SYMBOL_CALLS_LOCAL (info, tga_fd)
		   || (ELF_ST_VISIBILITY (tga_fd->other) != STV_DEFAULT
		       && tga_fd->root.type == bfd_link_hash_undefweak)))
	    {
	      struct plt_entry *ent;

	      for (ent = tga_fd->plt.plist; ent != NULL; ent = ent->next)
		if (ent->plt.refcount > 0)
		  break;
	      if (ent != NULL)
		{
		  tga_fd->root.type = bfd_link_hash_indirect;
		  tga_fd->root.u.i.link = &opt_fd->root;
		  ppc64_elf_copy_indirect_symbol (info, opt_fd, tga_fd);
		  if (opt_fd->dynindx != -1)
		    {
		      /* Use __tls_get_addr_opt in dynamic relocations.  */
		      opt_fd->dynindx = -1;
		      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
					      opt_fd->dynstr_index);
		      if (!bfd_elf_link_record_dynamic_symbol (info, opt_fd))
			return FALSE;
		    }
		  htab->tls_get_addr_fd = (struct ppc_link_hash_entry *) opt_fd;
		  tga = &htab->tls_get_addr->elf;
		  if (opt != NULL && tga != NULL)
		    {
		      tga->root.type = bfd_link_hash_indirect;
		      tga->root.u.i.link = &opt->root;
		      ppc64_elf_copy_indirect_symbol (info, opt, tga);
		      _bfd_elf_link_hash_hide_symbol (info, opt,
						      tga->forced_local);
		      htab->tls_get_addr = (struct ppc_link_hash_entry *) opt;
		    }
		  htab->tls_get_addr_fd->oh = htab->tls_get_addr;
		  htab->tls_get_addr_fd->is_func_descriptor = 1;
		  if (htab->tls_get_addr != NULL)
		    {
		      htab->tls_get_addr->oh = htab->tls_get_addr_fd;
		      htab->tls_get_addr->is_func = 1;
		    }
		}
	    }
	}
      else
	no_tls_get_addr_opt = TRUE;
    }
  htab->no_tls_get_addr_opt = no_tls_get_addr_opt;
a8668 6
      if (!htab->no_tls_get_addr_opt
	  && htab->tls_get_addr_fd != NULL
	  && htab->tls_get_addr_fd->elf.plt.plist != NULL
	  && !add_dynamic_entry (DT_PPC64_TLSOPT, 0))
	return FALSE;

a8861 43
/* Build a special .plt call stub for __tls_get_addr.  */

#define LD_R11_0R3	0xe9630000
#define LD_R12_0R3	0xe9830000
#define MR_R0_R3	0x7c601b78
#define CMPDI_R11_0	0x2c2b0000
#define ADD_R3_R12_R13	0x7c6c6a14
#define BEQLR		0x4d820020
#define MR_R3_R0	0x7c030378
#define MFLR_R11	0x7d6802a6
#define STD_R11_0R1	0xf9610000
#define BCTRL		0x4e800421
#define LD_R11_0R1	0xe9610000
#define LD_R2_0R1	0xe8410000
#define MTLR_R11	0x7d6803a6

static inline bfd_byte *
build_tls_get_addr_stub (bfd *obfd, bfd_byte *p, int offset,
			 Elf_Internal_Rela *r)
{
  bfd_put_32 (obfd, LD_R11_0R3 + 0, p),		p += 4;
  bfd_put_32 (obfd, LD_R12_0R3 + 8, p),		p += 4;
  bfd_put_32 (obfd, MR_R0_R3, p),		p += 4;
  bfd_put_32 (obfd, CMPDI_R11_0, p),		p += 4;
  bfd_put_32 (obfd, ADD_R3_R12_R13, p),		p += 4;
  bfd_put_32 (obfd, BEQLR, p),			p += 4;
  bfd_put_32 (obfd, MR_R3_R0, p),		p += 4;
  bfd_put_32 (obfd, MFLR_R11, p),		p += 4;
  bfd_put_32 (obfd, STD_R11_0R1 + 32, p),	p += 4;

  if (r != NULL)
    r[0].r_offset += 9 * 4;
  p = build_plt_stub (obfd, p, offset, r);
  bfd_put_32 (obfd, BCTRL, p - 4);

  bfd_put_32 (obfd, LD_R11_0R1 + 32, p),	p += 4;
  bfd_put_32 (obfd, LD_R2_0R1 + 40, p),		p += 4;
  bfd_put_32 (obfd, MTLR_R11, p),		p += 4;
  bfd_put_32 (obfd, BLR, p),			p += 4;

  return p;
}

d9230 1
a9230 7
      if (stub_entry->h != NULL
	  && (stub_entry->h == htab->tls_get_addr_fd
	      || stub_entry->h == htab->tls_get_addr)
	  && !htab->no_tls_get_addr_opt)
	p = build_tls_get_addr_stub (htab->stub_bfd, loc, off, r);
      else
	p = build_plt_stub (htab->stub_bfd, loc, off, r);
a9318 5
      if (stub_entry->h != NULL
	  && (stub_entry->h == htab->tls_get_addr_fd
	      || stub_entry->h == htab->tls_get_addr)
	  && !htab->no_tls_get_addr_opt)
	size += 13 * 4;
d11258 2
a11259 10
		      if (h != NULL
			  && (h == htab->tls_get_addr_fd
			      || h == htab->tls_get_addr)
			  && !htab->no_tls_get_addr_opt)
			{
			  /* Special stub used, leave nop alone.  */
			}
		      else
			bfd_put_32 (input_bfd, LD_R2_40R1,
				    contents + rel->r_offset + 4);
@


1.299.2.3
log
@	PR ld/11047
	* elf32-ppc.c (ppc_elf_relocate_section): Delete __tls_get_addr
	symbol reference from relocs belonging to calls that are
	optimized away.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d11132 2
a11133 1
		    rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
d11232 2
a11233 1
	      rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
d11278 2
a11279 1
	      rel[1].r_info = ELF64_R_INFO (STN_UNDEF, R_PPC64_NONE);
@


1.299.2.4
log
@	PR ld/11088
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Don't abort if symbol
	hiding has nulled out plt.plist.
@
text
@d5869 3
a5871 1
	      if (ent != NULL && ent->plt.refcount > 0)
@


1.299.2.5
log
@	* elf64-ppc.c: Delete my email address.
@
text
@d6 1
a6 1
   Largely rewritten by Alan Modra.
@


1.299.2.6
log
@	Backport
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* elf32-ppc.c: Fix shadowed variable warnings.
	* elf64-ppc.c: Likewise.

	2009-11-18  Alan Modra  <amodra@@bigpond.net.au>
	* bfd-in.h (_bfd_elf_ppc_at_tls_transform): Declare.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (ppc64_elf_relocate_section): Move code for R_PPC64_TLS
	insn optimisation to..
	* elf32-ppc.c (_bfd_elf_ppc_at_tls_transform): ..here.  New function.
	(ppc_elf_relocate_section): Use it.
@
text
@d3 1
a3 1
   2009, 2010 Free Software Foundation, Inc.
d5404 2
d8576 2
a8577 1
		s = htab->iplt;
d11019 1
d11021 7
a11027 2
	      insn = _bfd_elf_ppc_at_tls_transform (insn, 13);
	      if (insn == 0)
d11029 21
d11948 1
d11951 1
d12412 3
@


1.299.2.7
log
@	PR ld/11217
	* elf64-ppc.c (ppc64_elf_tls_optimize): Optimize tls sequences
	with relocations against undefined weak symbols.
	(ppc64_elf_relocate_section): Don't optimize calls to undefined
	weak functions if the symbol is dynamic.
	(ppc64_elf_relocate_section): Edit tprel tls sequences.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(_bfd_elf_ppc_at_tprel_transform): New function.
	* bfd-in.h (_bfd_elf_ppc_at_tprel_transform): Declare.
	* bfd-in2.h: Regenerate.
@
text
@d7412 2
a7413 6
		      if (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
			value = h->root.u.def.value;
		      else if (h->root.type == bfd_link_hash_undefweak)
			value = 0;
		      else
d7415 1
d7428 5
a7432 11
		      if (h != NULL
			  && h->root.type == bfd_link_hash_undefweak)
			ok_tprel = TRUE;
		      else
			{
			  value += sym_sec->output_offset;
			  value += sym_sec->output_section->vma;
			  value -= htab->elf.tls_sec->vma;
			  ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				      < (bfd_vma) 1 << 32);
			}
a11500 1
		   && h->elf.dynindx == -1
a11835 16
	  if (h != NULL
	      && h->elf.root.type == bfd_link_hash_undefweak
	      && h->elf.dynindx == -1)
	    {
	      /* Make this relocation against an undefined weak symbol
		 resolve to zero.  This is really just a tweak, since
		 code using weak externs ought to check that they are
		 defined before using them.  */
	      bfd_byte *p = contents + rel->r_offset - d_offset;

	      insn = bfd_get_32 (output_bfd, p);
	      insn = _bfd_elf_ppc_at_tprel_transform (insn, 13);
	      if (insn != 0)
		bfd_put_32 (output_bfd, insn, p);
	      break;
	    }
@


1.299.2.8
log
@	PR ld/11217
	* elf64-ppc.c (struct ppc_link_hash_table): Add toc_bfd, toc_first_sec.
	(ppc64_elf_setup_section_lists): Init them.
	(ppc64_elf_next_toc_section): Don't partition multi-toc between .got
	and .toc on the same input file.
	(ppc64_elf_relocate_section): Correct GOT entry offset.
@
text
@a3734 2
  bfd *toc_bfd;
  asection *toc_first_sec;
a9614 2
  htab->toc_bfd = NULL;
  htab->toc_first_sec = NULL;
d9649 2
a9650 1
      bfd_vma addr, off;
a9651 7
      if (htab->toc_bfd != isec->owner)
	{
	  htab->toc_bfd = isec->owner;
	  htab->toc_first_sec = isec;
	}
      addr = isec->output_offset + isec->output_section->vma;
      off = addr - htab->toc_curr;
d9653 1
a9653 5
	{
	  addr = (htab->toc_first_sec->output_offset
		  + htab->toc_first_sec->output_section->vma);
	  htab->toc_curr = addr;
	}
d11748 4
a11751 2
	    relocation = got->output_section->vma + got->output_offset + off;
	    addend = -(TOCstart + htab->stub_group[input_section->id].toc_off);
@


1.298
log
@STT_GNU_IFUNC support for PowerPC.
@
text
@d1877 14
d1905 61
d2234 8
d4849 23
a4888 23
	  if (h != NULL)
	    {
	      if (h->type == STT_GNU_IFUNC)
		{
		  h->needs_plt = 1;
		  ifunc = &h->plt.plist;
		}
	    }
	  else
	    {
	      Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
							      abfd, r_symndx);
	      if (isym == NULL)
		return FALSE;

	      if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
		{
		  ifunc = update_local_sym_info (abfd, symtab_hdr, r_symndx,
						 rel->r_addend, PLT_IFUNC);
		  if (ifunc == NULL)
		    return FALSE;
		}
	    }
d5030 6
d5286 3
a5288 1
		      || !h->def_regular)))
d8084 2
a8085 1
	    if (!htab->elf.dynamic_sections_created)
d8164 1
d8171 1
d8194 1
d8199 7
a8205 4
	  ppc64_elf_tdata (gent->owner)->relgot->size
	    += (gent->tls_type & eh->tls_mask & TLS_GD
		? 2 * sizeof (Elf64_External_Rela)
		: sizeof (Elf64_External_Rela));
d8211 2
a8212 1
      || !htab->elf.dynamic_sections_created)
d8262 5
d8300 2
d8400 2
d8435 1
d8438 6
a8443 11
		      {
			s->size += 16;
			if (info->shared)
			  srel->size += 2 * sizeof (Elf64_External_Rela);
		      }
		    else
		      {
			s->size += 8;
			if (info->shared)
			  srel->size += sizeof (Elf64_External_Rela);
		      }
d8463 1
a8463 1
		htab->reliplt += sizeof (Elf64_External_Rela);
d9136 3
a9138 1
      if (!htab->elf.dynamic_sections_created)
d9150 1
a9150 1
	  rela.r_info = ELF64_R_INFO (0, R_PPC64_IRELATIVE);
d9155 4
a9158 9
	  if (!htab->elf.dynamic_sections_created)
	    rl = (htab->reliplt->contents
		  + (stub_entry->plt_ent->plt.offset
		     / (PLT_ENTRY_SIZE / sizeof (Elf64_External_Rela))));
	  else
	    rl = (htab->relplt->contents
		  + ((stub_entry->plt_ent->plt.offset - PLT_INITIAL_ENTRY_SIZE)
		     / (PLT_ENTRY_SIZE / sizeof (Elf64_External_Rela))));
	  bfd_elf32_swap_reloca_out (info->output_bfd, &rela, rl);
d9266 3
a9268 1
      if (!htab->elf.dynamic_sections_created)
d11199 3
a11201 1
		       != htab->stub_group[input_section->id].toc_off)))
d11485 2
a11486 1
		asection *relgot = ppc64_elf_tdata (input_bfd)->relgot;
d11489 4
d11498 4
d11528 3
a11530 1
		    else if (indx == 0)
d11532 4
a11535 1
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);
a11542 2
		    else
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_GLOB_DAT);
d11661 6
d11759 5
a11763 1
		  && !h->elf.def_regular))
d11828 9
a11836 1
		      outrel.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
d11838 6
a11843 5
		      /* We need to relocate .opd contents for ld.so.
			 Prelink also wants simple and consistent rules
			 for relocs.  This make all RELATIVE relocs have
			 *r_offset equal to r_addend.  */
		      relocate = TRUE;
d11849 15
a11863 1
		      if (r_symndx == 0 || bfd_is_abs_section (sec))
d11901 2
d11944 1
d11977 1
a12193 8
	asection *plt = htab->plt;
	if (!htab->elf.dynamic_sections_created)
	  plt = htab->iplt;

	rela.r_offset = (plt->output_section->vma
			 + plt->output_offset
			 + ent->plt.offset);

d12201 4
a12204 1
	    rela.r_info = ELF64_R_INFO (0, R_PPC64_IRELATIVE);
d12209 3
d12215 3
d12220 3
a12223 9

	if (!htab->elf.dynamic_sections_created)
	  loc = (htab->reliplt->contents
		 + (ent->plt.offset
		    / (PLT_ENTRY_SIZE / sizeof (Elf64_External_Rela))));
	else
	  loc = (htab->relplt->contents
		 + ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE)
		    / (PLT_ENTRY_SIZE / sizeof (Elf64_External_Rela))));
@


1.297
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): Avoid gcc warning.
@
text
@d115 1
d1877 14
d3134 5
a3138 1
		size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
d3258 7
d3547 1
d3616 1
d3669 2
d4095 15
d4127 1
a4127 1
  if (!htab->relbrlt
d4415 1
a4415 1
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
d4422 6
a4427 2
  if (*sec != NULL
      && strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
d4585 1
a4585 1
static bfd_boolean
d4590 1
d4597 3
a4599 1
      size *= sizeof (*local_got_ents) + sizeof (*local_got_tls_masks);
d4602 1
a4602 1
	return FALSE;
d4606 1
a4606 1
  if ((tls_type & TLS_EXPLICIT) == 0)
d4631 2
a4632 1
  local_got_tls_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
d4634 2
a4635 1
  return TRUE;
d4639 1
a4639 1
update_plt_info (bfd *abfd, struct ppc_link_hash_entry *eh, bfd_vma addend)
d4643 1
a4643 1
  for (ent = eh->elf.plt.plist; ent != NULL; ent = ent->next)
d4652 1
a4652 1
      ent->next = eh->elf.plt.plist;
d4655 1
a4655 1
      eh->elf.plt.plist = ent;
a4657 4
  eh->elf.needs_plt = 1;
  if (eh->elf.root.root.string[0] == '.'
      && eh->elf.root.root.string[1] != '\0')
    eh->is_func = 1;
d4661 13
d4751 1
d4765 1
d4767 30
a4796 5
      if (h != NULL && (h == tga || h == dottga))
	switch (r_type)
	  {
	  default:
	    break;
d4798 12
a4809 19
	  case R_PPC64_REL24:
	  case R_PPC64_REL14:
	  case R_PPC64_REL14_BRTAKEN:
	  case R_PPC64_REL14_BRNTAKEN:
	  case R_PPC64_ADDR24:
	  case R_PPC64_ADDR14:
	  case R_PPC64_ADDR14_BRTAKEN:
	  case R_PPC64_ADDR14_BRNTAKEN:
	    if (rel != relocs
		&& (ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_TLSGD
		    || ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_TLSLD))
	      /* We have a new-style __tls_get_addr call with a marker
		 reloc.  */
	      ;
	    else
	      /* Mark this section as having an old-style call.  */
	      sec->has_tls_get_addr_call = 1;
	    break;
	  }
d4915 8
a4922 3
	    if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				  rel->r_addend))
	      return FALSE;
d5005 1
a5005 1
	  if (h != NULL)
d5009 1
a5009 2
	      if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				    rel->r_addend))
d5011 4
d5619 32
d6165 1
d6175 4
a6178 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d6429 4
a6432 1
	      char *lgot_masks = (char *) (lgot_ents + symtab_hdr->sh_info);
d7114 1
a7114 9
  if (r_symndx >= symtab_hdr->sh_info
      && (r_type == R_PPC64_REL24
	  || r_type == R_PPC64_REL14
	  || r_type == R_PPC64_REL14_BRTAKEN
	  || r_type == R_PPC64_REL14_BRNTAKEN
	  || r_type == R_PPC64_ADDR24
	  || r_type == R_PPC64_ADDR14
	  || r_type == R_PPC64_ADDR14_BRTAKEN
	  || r_type == R_PPC64_ADDR14_BRNTAKEN))
d7983 4
a7986 3
  if (htab->elf.dynamic_sections_created
      && h->dynindx != -1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d7993 28
a8020 19
	    /* If this is the first .plt entry, make room for the special
	       first entry.  */
	    s = htab->plt;
	    if (s->size == 0)
	      s->size += PLT_INITIAL_ENTRY_SIZE;

	    pent->plt.offset = s->size;

	    /* Make room for this entry.  */
	    s->size += PLT_ENTRY_SIZE;

	    /* Make room for the .glink code.  */
	    s = htab->glink;
	    if (s->size == 0)
	      s->size += GLINK_CALL_STUB_SIZE;
	    /* We need bigger stubs past index 32767.  */
	    if (s->size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	      s->size += 4;
	    s->size += 2*4;
d8022 3
a8024 2
	    /* We also need to make an entry in the .rela.plt section.  */
	    s = htab->relplt;
d8267 2
d8308 3
a8310 1
      lgot_masks = (char *) end_lgot_ents;
d8345 19
d8403 1
d8554 1
d8565 1
d8571 8
a8578 12
      if (fdh->elf.dynindx != -1)
	{
	  struct plt_entry *ent;

	  for (ent = fdh->elf.plt.plist; ent != NULL; ent = ent->next)
	    if (ent->addend == rel->r_addend
		&& ent->plt.offset != (bfd_vma) -1)
	      {
		*hash = fdh;
		return ppc_stub_plt_call;
	      }
	}
d8592 20
a8751 1
  struct plt_entry *ent;
d8755 1
d9011 2
a9012 1
      if (stub_entry->h->oh != NULL
d9027 1
a9027 7
      dest = (bfd_vma) -1;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    dest = ent->plt.offset;
	    break;
	  }
d9031 29
a9059 3
      dest &= ~ (bfd_vma) 1;
      dest += (htab->plt->output_offset
	       + htab->plt->output_section->vma);
d9062 1
a9062 1
	     - elf_gp (htab->plt->output_section->owner)
d9069 3
a9071 1
	     stub_entry->h->elf.root.root.string);
d9160 2
a9161 8
      struct plt_entry *ent;
      off = (bfd_vma) -1;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    off = ent->plt.offset & ~(bfd_vma) 1;
	    break;
	  }
d9164 6
a9169 3
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
d9843 1
a9843 1
		  bfd_vma sym_value;
d9853 1
d9930 1
d9941 1
d9945 1
a9945 1
					      &code_sec, &sym_value);
d9955 1
a9955 1
			      hash->elf.root.u.def.value = sym_value;
d9961 1
d9963 1
a9963 1
						destination);
d10036 10
a10045 2
		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = code_sec;
d10047 1
d10133 1
a10133 1
  if (s == NULL)
d10135 1
a10135 1
  if (s == NULL)
d10137 1
a10137 1
  if (s == NULL)
d10139 1
a10139 1
  if (s == NULL)
d10152 2
a10153 1
	if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_READONLY))
d10158 1
a10158 1
	  if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA))
d10163 2
a10164 1
	  if ((s->flags & (SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
d10168 1
a10168 1
	  if ((s->flags & SEC_ALLOC) == SEC_ALLOC)
d10597 4
a10600 2
	  char *lgot_masks;
	  lgot_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
d12040 3
d12044 2
a12045 9
	if (htab->plt == NULL
	    || htab->relplt == NULL
	    || htab->glink == NULL)
	  abort ();

	/* Create a JMP_SLOT reloc to inform the dynamic linker to
	   fill in the PLT entry.  */
	rela.r_offset = (htab->plt->output_section->vma
			 + htab->plt->output_offset
a12046 2
	rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	rela.r_addend = ent->addend;
d12048 27
a12074 3
	loc = htab->relplt->contents;
	loc += ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		* sizeof (Elf64_External_Rela));
@


1.296
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d6724 1
a6724 1
	  bfd_byte *new_contents = NULL;
d6729 1
@


1.295
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d3674 2
a3675 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d4900 11
a4910 2
	      dest = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						sec, r_symndx);
d5030 1
d5032 3
a5034 3
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,
						 r_symndx);
		  if (s == NULL)
d5036 3
a5038 1
		  else if (s != sec)
a5133 1

d5136 1
d5138 6
a5143 2
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d5145 1
a5145 1
		    return FALSE;
@


1.294
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't segfault on
	out of range .opd symbols.
@
text
@d11762 1
a11762 1
static bfd_boolean
d11774 1
a11774 1
    return TRUE;
d11778 1
a11778 1
    return TRUE;
d11786 4
a11789 4
    elfsym->st_value = 0;
  else
    elfsym->st_value += adjust;
  return TRUE;
@


1.293
log
@	* elf64-ppc.c (synthetic_opd): Delete.
	(compare_symbols): Look for .opd name rather than section match.
	(ppc64_elf_get_synthetic_symtab): Likewise.
@
text
@d3036 4
d3133 3
@


1.292
log
@include/elf/
	* ppc.h (R_PPC_TLSGD, R_PPC_TLSLD): Add new relocs.
	* ppc64.h (R_PPC64_TLSGD, R_PPC64_TLSLD): Add new relocs.
bfd/
	* reloc.c (BFD_RELOC_PPC_TLSGD, BFD_RELOC_PPC_TLSLD): New.
	* section.c (struct bfd_section): Add has_tls_get_addr_call.
	(BFD_FAKE_SECTION): Init new flag.
	* ecoff.c (bfd_debug_section): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-ppc.c (ppc_elf_howto_raw): Add R_PPC_TLSGD and R_PPC_TLSLD.
	(ppc_elf_reloc_type_lookup): Handle new relocs.
	(ppc_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.
	(ppc_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_TLSGD, R_PPC64_TLSLD.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc64_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.  Set toc_ref for new relocs as
	appropriate.
	(ppc64_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
gas/
	* config/tc-ppc.c (ppc_elf_suffix): Error if ppc32 tls got relocs
	have non-zero addend.
	(md_assemble): Parse args of __tls_get_addr calls.
	(md_apply_fix): Handle BFD_RELOC_PPC_TLSGD and BFD_RELOC_PPC_TLSLD.
ld/testsuite/
	* ld-powerpc/tlsmark.s, * ld-powerpc/tlsmark.d: New test.
	* ld-powerpc/tlsmark32.s, * ld-powerpc/tlsmark32.d: New test.
	* ld-powerpc/powerpc.exp: Run them.
@
text
@a2691 1
static asection *synthetic_opd;
d2709 2
a2710 1
  if (a->section == synthetic_opd && b->section != synthetic_opd)
d2712 2
a2713 1
  if (a->section != synthetic_opd && b->section == synthetic_opd)
a2866 1
  synthetic_opd = opd;
d2884 1
a2884 1
  if (syms[i]->section == opd)
d2901 1
a2901 1
    if (syms[i]->section != opd)
@


1.291
log
@	* elf64-ppc.c (struct _ppc64_elf_section_data): Delete t_symndx,
	add toc.symndx and toc.add.
	(ppc64_elf_check_relocs): Don't set htab->tls_get_addr here.
	Set up toc.add.
	(get_tls_mask): Add toc_addend param, set from toc.add.  Adjust all
	callers.
	(ppc64_elf_tls_setup): Set htab->tls_get_addr and tls_get_addr_fd.
	(branch_reloc_hash_match): New function, extracted from..
	(ppc64_elf_tls_optimize): ..here.
	(ppc64_elf_relocate_section): Properly set addends when optimizing
	tls sequences.  Avoid unnecessary reading and writing of insns.
	Only redo reloc when symbol changed.  Bypass symbol checks when
	using tlsld_got.
	* elf32-ppc.c (ppc_elf_tls_setup): Correct comment.
	(branch_reloc_hash_match): New function, extracted from..
	(ppc_elf_tls_optimize): ..here.
	(ppc_elf_relocate_section): Avoid unnecessary reading of insns.
	Don't clear addend on zapped __tls_get_addr reloc.
@
text
@d1238 1
a1238 1
  /* Marker reloc for TLS.  */
d1253 28
d2062 4
d4679 1
a4679 1
      int tls_type = 0;
d4693 1
d4695 26
d4723 6
d7140 2
d7162 3
a7164 1
		      if (r_type == R_PPC64_TLS)
d7229 2
a7230 1
		      if (!expecting_tls_get_addr)
d7349 2
a7350 2
	if (toc_ref != NULL)
	  free (toc_ref);
d7352 9
a7360 9
	if (locsyms != NULL
	    && (elf_symtab_hdr (ibfd).contents != (unsigned char *) locsyms))
	  {
	    if (!info->keep_memory)
	      free (locsyms);
	    else
	      elf_symtab_hdr (ibfd).contents = (unsigned char *) locsyms;
	  }
      }
d10361 3
a10363 1
      if (IS_PPC64_TLS_RELOC (r_type))
d10365 11
a10375 12
	  if (h != NULL)
	    tls_mask = h->tls_mask;
	  else if (local_got_ents != NULL)
	    {
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
	    }
	  if (tls_mask == 0 && r_type == R_PPC64_TLS)
	    {
	      /* Check for toc tls entries.  */
	      char *toc_tls;
d10377 3
a10379 3
	      if (!get_tls_mask (&toc_tls, &toc_symndx, &toc_addend,
				 &local_syms, rel, input_bfd))
		return FALSE;
d10381 2
a10382 3
	      if (toc_tls)
		tls_mask = *toc_tls;
	    }
d10397 4
a10400 1
	  if (r_type == R_PPC64_TLS && tls_mask != 0)
d10596 12
a10607 3
	      /* We know that the next reloc is on a tls_get_addr
		 call, since ppc64_elf_tls_optimize checks this.  */
	      offset = rel[1].r_offset;
d10616 3
a10618 2
		  rel[1].r_info = ELF64_R_INFO (ELF64_R_SYM (rel[1].r_info),
						R_PPC64_NONE);
d10656 7
a10662 4
		  rel[1].r_info = ELF64_R_INFO (r_symndx,
						R_PPC64_TPREL16_LO);
		  rel[1].r_offset += d_offset;
		  rel[1].r_addend = rel->r_addend;
d10666 53
d10724 1
a10724 1
		  rel[1].r_offset += 4;
d10729 1
a10729 2
	      if ((tls_mask & tls_gd) == 0
		  && (tls_gd == 0 || toc_symndx != 0))
a10730 2
		  /* We changed the symbol.  Start over in order
		     to get h, sym, sec etc. right.  */
d10737 44
d11034 2
@


1.290
log
@	PR 7041
	* elf64-ppc.c (func_desc_adjust): Correct logic making fake function
	descriptors.  Similarly correct making function descriptors dynamic.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
d2611 9
a2619 3
    /* An array for toc sections, indexed by offset/8.
       Specifies the relocation symbol index used at a given toc offset.  */
    unsigned *t_symndx;
d4587 1
d4604 4
d4843 1
a4843 2
	      if (h == &htab->tls_get_addr->elf
		  || h == &htab->tls_get_addr_fd->elf)
a4844 16
	      else if (htab->tls_get_addr == NULL
		       && CONST_STRNEQ (h->root.root.string, ".__tls_get_addr")
		       && (h->root.root.string[15] == 0
			   || h->root.root.string[15] == '@@'))
		{
		  htab->tls_get_addr = (struct ppc_link_hash_entry *) h;
		  sec->has_tls_reloc = 1;
		}
	      else if (htab->tls_get_addr_fd == NULL
		       && CONST_STRNEQ (h->root.root.string, "__tls_get_addr")
		       && (h->root.root.string[14] == 0
			   || h->root.root.string[14] == '@@'))
		{
		  htab->tls_get_addr_fd = (struct ppc_link_hash_entry *) h;
		  sec->has_tls_reloc = 1;
		}
d4888 2
d4891 7
a4897 3
	      bfd_size_type amt = sec->size * sizeof (unsigned) / 8 + 1;
	      ppc64_sec->u.t_symndx = bfd_zalloc (abfd, amt);
	      if (ppc64_sec->u.t_symndx == NULL)
d4903 2
a4904 1
	  ppc64_sec->u.t_symndx[rel->r_offset / 8] = r_symndx;
d4909 1
a4909 1
	    ppc64_sec->u.t_symndx[rel->r_offset / 8 + 1] = -1;
d4911 1
a4911 1
	    ppc64_sec->u.t_symndx[rel->r_offset / 8 + 1] = -2;
d6230 3
a6232 1
get_tls_mask (char **tls_maskp, unsigned long *toc_symndx,
d6234 2
a6235 1
	      const Elf_Internal_Rela *rel, bfd *ibfd)
d6263 6
a6268 2
  r_symndx = ppc64_elf_section_data (sec)->u.t_symndx[off / 8];
  next_r = ppc64_elf_section_data (sec)->u.t_symndx[off / 8 + 1];
a6270 2
  if (toc_symndx != NULL)
    *toc_symndx = r_symndx;
d6875 8
a6882 3
  if (htab->tls_get_addr != NULL)
    {
      struct ppc_link_hash_entry *h = htab->tls_get_addr;
d6884 2
a6885 3
      while (h->elf.root.type == bfd_link_hash_indirect
	     || h->elf.root.type == bfd_link_hash_warning)
	h = (struct ppc_link_hash_entry *) h->elf.root.u.i.link;
d6887 9
a6895 9
      htab->tls_get_addr = h;

      if (htab->tls_get_addr_fd == NULL
	  && h->oh != NULL
	  && h->oh->is_func_descriptor
	  && (h->oh->elf.root.type == bfd_link_hash_defined
	      || h->oh->elf.root.type == bfd_link_hash_defweak))
	htab->tls_get_addr_fd = h->oh;
    }
d6897 9
a6905 1
  if (htab->tls_get_addr_fd != NULL)
d6907 2
a6908 1
      struct ppc_link_hash_entry *h = htab->tls_get_addr_fd;
d6910 6
a6915 5
      while (h->elf.root.type == bfd_link_hash_indirect
	     || h->elf.root.type == bfd_link_hash_warning)
	h = (struct ppc_link_hash_entry *) h->elf.root.u.i.link;

      htab->tls_get_addr_fd = h;
d6917 1
a6917 2

  return _bfd_elf_tls_setup (obfd, info);
d7163 4
a7166 1
		      if (rel + 1 < relend)
d7168 1
a7168 16
			  Elf_Internal_Shdr *symtab_hdr;
			  enum elf_ppc64_reloc_type r_type2;
			  unsigned long r_symndx2;
			  struct elf_link_hash_entry *h2;

			  symtab_hdr = &elf_symtab_hdr (ibfd);

			  /* The next instruction should be a call to
			     __tls_get_addr.  Peek at the reloc to be sure.  */
			  r_type2 = ELF64_R_TYPE (rel[1].r_info);
			  r_symndx2 = ELF64_R_SYM (rel[1].r_info);
			  if (r_symndx2 >= symtab_hdr->sh_info
			      && (r_type2 == R_PPC64_REL14
				  || r_type2 == R_PPC64_REL14_BRTAKEN
				  || r_type2 == R_PPC64_REL14_BRNTAKEN
				  || r_type2 == R_PPC64_REL24))
d7170 11
a7180 29
			      struct elf_link_hash_entry **sym_hashes;

			      sym_hashes = elf_sym_hashes (ibfd);

			      h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
			      while (h2->root.type == bfd_link_hash_indirect
				     || h2->root.type == bfd_link_hash_warning)
				h2 = ((struct elf_link_hash_entry *)
				      h2->root.u.i.link);
			      if (h2 != NULL
				  && (h2 == &htab->tls_get_addr->elf
				      || h2 == &htab->tls_get_addr_fd->elf))
				{
				  if (expecting_tls_get_addr == 2)
				    {
				      /* Check for toc tls entries.  */
				      char *toc_tls;
				      int retval;

				      retval = get_tls_mask (&toc_tls, NULL,
							     &locsyms,
							     rel, ibfd);
				      if (retval == 0)
					goto err_free_rel;
				      if (retval > 1 && toc_tls != NULL)
					toc_ref[toc_ref_index] = 1;
				    }
				  continue;
				}
d7182 1
d9705 1
a9705 1
		      if (!get_tls_mask (&tls_mask, NULL, &local_syms,
d10197 1
d10306 2
a10307 2
	      if (!get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				 rel, input_bfd))
d10369 2
a10370 2
	    retval = get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				   rel, input_bfd);
d10418 1
d10472 1
d10519 1
a10519 1
	      bfd_vma insn1, insn2, insn3;
a10525 4
	      insn1 = bfd_get_32 (output_bfd,
				  contents + rel->r_offset - d_offset);
	      insn3 = bfd_get_32 (output_bfd,
				  contents + offset + 4);
d10529 2
a10564 1
		      rel[1].r_addend = rel->r_addend;
d10567 4
a10570 1
		    r_symndx = toc_symndx;
d10576 1
d10578 4
d10585 2
a10586 1
		  insn3 = insn2;
a10587 1
		  rel[1].r_offset += 4;
a10588 2
	      bfd_put_32 (output_bfd, insn1,
			  contents + rel->r_offset - d_offset);
d10590 2
a10591 2
	      bfd_put_32 (output_bfd, insn3, contents + offset + 4);
	      if (tls_gd == 0 || toc_symndx != 0)
d10968 2
a10969 1
		    && (h == NULL
@


1.289
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d5818 1
a5818 1
      && info->shared
d5851 1
a5851 1
      && (info->shared
@


1.288
log
@	* elf64-ppc.c (ppc64_elf_process_dot_syms): Renamed from
	ppc64_elf_check_directives.
	* elf32-sh-symbian.c (sh_symbian_process_directives): Combine..
	(sh_symbian_check_directives): ..this
	(bfd_elf32_sh_symbian_process_directives) ..and this function.
@
text
@d5031 2
a5032 2
		  const char *name;
		  bfd *dynobj;
d5034 1
a5034 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a5035 28

		  if (! CONST_STRNEQ (name, ".rela")
		      || strcmp (bfd_get_section_name (abfd, sec),
				 name + 5) != 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
		      bfd_set_error (bfd_error_bad_value);
		    }

		  dynobj = htab->elf.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED
			       | SEC_ALLOC | SEC_LOAD);
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.287
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't attempt to
	read plt relocs if no dynamic syms.
@
text
@d95 1
a95 1
#define elf_backend_check_directives	      ppc64_elf_check_directives
d3623 1
a3623 1
  /* Temp used by ppc64_elf_check_directives.  */
d4441 1
a4441 1
ppc64_elf_check_directives (bfd *ibfd, struct bfd_link_info *info)
@


1.286
log
@	* elf32-ppc.c (allocate_dynrelocs): Ignore dyn_relocs when
	!dynamic_sections_created.  Don't make symbols with got
	references dynamic if !dynamic_sections_created.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.  Alloc dynamic
	relocs on undefined symbols.
	(ppc64_elf_relocate_section): Allow dynamic relocs on
	undefined symbols.
@
text
@d3008 2
a3009 2
      dynamic = bfd_get_section_by_name (abfd, ".dynamic");
      if (dynamic != NULL)
a3063 1
	}
d3065 6
a3070 6
      relplt = bfd_get_section_by_name (abfd, ".rela.plt");
      if (glink != NULL && relplt != NULL)
	{
	  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
	  if (! (*slurp_relocs) (abfd, relplt, dyn_syms, TRUE))
	    goto free_contents_and_exit;
d3072 2
a3073 2
	  plt_count = relplt->size / sizeof (Elf64_External_Rela);
	  size += plt_count * sizeof (asymbol);
d3075 4
a3078 3
	  p = relplt->relocation;
	  for (i = 0; i < plt_count; i++, p++)
	    size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
@


1.286.2.1
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't attempt to
	read plt relocs if no dynamic syms.
@
text
@d3008 2
a3009 2
      if (dyn_count != 0
	  && (dynamic = bfd_get_section_by_name (abfd, ".dynamic")) != NULL)
d3064 1
d3066 6
a3071 6
	  relplt = bfd_get_section_by_name (abfd, ".rela.plt");
	  if (relplt != NULL)
	    {
	      slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
	      if (! (*slurp_relocs) (abfd, relplt, dyn_syms, TRUE))
		goto free_contents_and_exit;
d3073 2
a3074 2
	      plt_count = relplt->size / sizeof (Elf64_External_Rela);
	      size += plt_count * sizeof (asymbol);
d3076 3
a3078 4
	      p = relplt->relocation;
	      for (i = 0; i < plt_count; i++, p++)
		size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
	    }
@


1.286.2.2
log
@backport 2008-12-11  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d5850 1
a5850 1
      && !info->executable
d5883 1
a5883 1
      && (!info->executable
@


1.286.2.3
log
@backport 2009-02-15  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009 Free Software Foundation, Inc.
d2611 3
a2613 9
    /* An array for toc sections, indexed by offset/8.  */
    struct _toc_sec_data
    {
      /* Specifies the relocation symbol index used at a given toc offset.  */
      unsigned *symndx;

      /* And the relocation addend.  */
      bfd_vma *add;
    } toc;
a4580 1
  struct elf_link_hash_entry *tga, *dottga;
a4596 4
  tga = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
			      FALSE, FALSE, TRUE);
  dottga = elf_link_hash_lookup (&htab->elf, ".__tls_get_addr",
				 FALSE, FALSE, TRUE);
d4832 2
a4833 1
	      if (h == tga || h == dottga)
d4835 16
a4893 2
	      bfd_size_type amt;

d4895 3
a4897 7
	      amt = sec->size * sizeof (unsigned) / 8 + sizeof (unsigned);
	      ppc64_sec->u.toc.symndx = bfd_zalloc (abfd, amt);
	      if (ppc64_sec->u.toc.symndx == NULL)
		return FALSE;
	      amt = sec->size * sizeof (bfd_vma) / 8;
	      ppc64_sec->u.toc.add = bfd_zalloc (abfd, amt);
	      if (ppc64_sec->u.toc.add == NULL)
d4903 1
a4903 2
	  ppc64_sec->u.toc.symndx[rel->r_offset / 8] = r_symndx;
	  ppc64_sec->u.toc.add[rel->r_offset / 8] = rel->r_addend;
d4908 1
a4908 1
	    ppc64_sec->u.toc.symndx[rel->r_offset / 8 + 1] = -1;
d4910 1
a4910 1
	    ppc64_sec->u.toc.symndx[rel->r_offset / 8 + 1] = -2;
d6261 1
a6261 3
get_tls_mask (char **tls_maskp,
	      unsigned long *toc_symndx,
	      bfd_vma *toc_addend,
d6263 1
a6263 2
	      const Elf_Internal_Rela *rel,
	      bfd *ibfd)
d6291 4
a6294 2
  r_symndx = ppc64_elf_section_data (sec)->u.toc.symndx[off / 8];
  next_r = ppc64_elf_section_data (sec)->u.toc.symndx[off / 8 + 1];
a6296 4
  if (toc_addend != NULL)
    *toc_addend = ppc64_elf_section_data (sec)->u.toc.add[off / 8];
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;
d6901 7
a6907 8
  htab->tls_get_addr = ((struct ppc_link_hash_entry *)
			elf_link_hash_lookup (&htab->elf, ".__tls_get_addr",
					      FALSE, FALSE, TRUE));
  htab->tls_get_addr_fd = ((struct ppc_link_hash_entry *)
			   elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
						 FALSE, FALSE, TRUE));
  return _bfd_elf_tls_setup (obfd, info);
}
d6909 1
a6909 2
/* Return TRUE iff REL is a branch reloc with a global symbol matching
   HASH1 or HASH2.  */
d6911 7
a6917 9
static bfd_boolean
branch_reloc_hash_match (const bfd *ibfd,
			 const Elf_Internal_Rela *rel,
			 const struct ppc_link_hash_entry *hash1,
			 const struct ppc_link_hash_entry *hash2)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
  enum elf_ppc64_reloc_type r_type = ELF64_R_TYPE (rel->r_info);
  unsigned int r_symndx = ELF64_R_SYM (rel->r_info);
d6919 1
a6919 9
  if (r_symndx >= symtab_hdr->sh_info
      && (r_type == R_PPC64_REL24
	  || r_type == R_PPC64_REL14
	  || r_type == R_PPC64_REL14_BRTAKEN
	  || r_type == R_PPC64_REL14_BRNTAKEN
	  || r_type == R_PPC64_ADDR24
	  || r_type == R_PPC64_ADDR14
	  || r_type == R_PPC64_ADDR14_BRTAKEN
	  || r_type == R_PPC64_ADDR14_BRNTAKEN))
d6921 5
a6925 2
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;
d6927 1
a6927 6
      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h == &hash1->elf || h == &hash2->elf)
	return TRUE;
d6929 2
a6930 1
  return FALSE;
d7176 1
a7176 4
		      if (rel + 1 < relend
			  && branch_reloc_hash_match (ibfd, rel + 1,
						      htab->tls_get_addr,
						      htab->tls_get_addr_fd))
d7178 16
a7193 1
			  if (expecting_tls_get_addr == 2)
d7195 29
a7223 11
			      /* Check for toc tls entries.  */
			      char *toc_tls;
			      int retval;

			      retval = get_tls_mask (&toc_tls, NULL, NULL,
						     &locsyms,
						     rel, ibfd);
			      if (retval == 0)
				goto err_free_rel;
			      if (retval > 1 && toc_tls != NULL)
				toc_ref[toc_ref_index] = 1;
a7224 1
			  continue;
d9747 1
a9747 1
		      if (!get_tls_mask (&tls_mask, NULL, NULL, &local_syms,
a10238 1
      bfd_vma toc_addend;
d10347 2
a10348 2
	      if (!get_tls_mask (&toc_tls, &toc_symndx, &toc_addend,
				 &local_syms, rel, input_bfd))
d10410 2
a10411 2
	    retval = get_tls_mask (&toc_tls, &toc_symndx, &toc_addend,
				   &local_syms, rel, input_bfd);
a10458 1
		  rel->r_addend = toc_addend;
a10511 1
		  rel->r_addend = toc_addend;
d10558 1
a10558 1
	      unsigned int insn1, insn2, insn3;
d10565 4
a10571 2
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
d10606 1
d10609 1
a10609 4
		    {
		      r_symndx = toc_symndx;
		      rel->r_addend = toc_addend;
		    }
a10614 1
		  rel[1].r_addend = rel->r_addend;
a10615 4
	      bfd_put_32 (output_bfd, insn1,
			  contents + rel->r_offset - d_offset);
	      insn3 = bfd_get_32 (output_bfd,
				  contents + offset + 4);
d10619 2
a10621 2
		  bfd_put_32 (output_bfd, insn2, contents + offset + 4);
		  insn2 = NOP;
d10623 2
d10626 2
a10627 2
	      if ((tls_mask & tls_gd) == 0
		  && (tls_gd == 0 || toc_symndx != 0))
d11004 1
a11004 2
		    && (offp == &ppc64_tlsld_got (input_bfd)->offset
			|| h == NULL
@


1.285
log
@	* elf64-ppc.c (toc_adjusting_stub_needed): Any call via the plt
	needs r2 valid, not just those to external syms.
@
text
@d7894 2
a7895 1
	    && !h->forced_local)
d7929 2
a7930 1
  if (eh->dyn_relocs == NULL)
a7986 1
	  && h->def_dynamic
a11254 1
		  && h->elf.def_dynamic
@


1.284
log
@bfd/
	* syms.c (BSF_SYNTHETIC): New flag.
	* elf.c (_bfd_elf_get_synthetic_symtab): Set it.
	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Likewise.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
	* bfd-in.h (bfd_asymbol_flavour): Return bfd_target_unknown_flavour
	for synthetic symbols.
	* bfd-in2.h: Regenerate.

opcodes/
	* mips-dis.c (_print_insn_mips): Use bfd_asymbol_flavour to check
	for ELF symbols.
@
text
@d9187 1
d9210 6
a9215 4
	 that uses r2.  Branches to undefined symbols might be a call
	 using old-style dot symbols that can be satisfied by a plt
	 call into a new-style dynamic library.  */
      if (sym_sec == NULL)
d9217 3
a9219 8
	  struct ppc_link_hash_entry *eh = (struct ppc_link_hash_entry *) h;
	  if (eh != NULL
	      && eh->oh != NULL
	      && eh->oh->elf.plt.plist != NULL)
	    {
	      ret = 1;
	      break;
	    }
d9221 3
a9223 3
	  /* Ignore other undefined symbols.  */
	  continue;
	}
@


1.283
log
@	PR ld/6590
	* elf64-ppc.c (ppc_build_one_stub): Correct reloc offsets.
@
text
@d2957 1
d3128 1
d3150 1
a3150 1
	      s->flags = BSF_GLOBAL;
d3186 1
@


1.282
log
@	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Fix memset calls.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
@
text
@d8711 2
d8834 2
@


1.281
log
@	* elf32-ppc.c (section_covers_vma): New function.
	(ppc_elf_get_synthetic_symtab): New function.
	(bfd_elf32_get_synthetic_symtab): Define.
	* elf64-ppc.c (section_covers_vma): New function.
	(ppc64_elf_get_synthetic_symtab): Generate sym@@plt on glink branch
	table entries, and __glink_PLTresolve on resolver stub.
	(ppc64_elf_build_stubs): Rename __glink sym to __glink_PLTresolve.
@
text
@d3146 1
a3146 1
	      memset (s, sizeof *s, 0);
@


1.280
log
@	PR 6443
	* elf32-ppc.c (MUST_BE_DYN_RELOC): Delete.
	(must_be_dyn_reloc): New function.
	(ppc_elf_check_relocs): Don't set DF_STATIC_TLS for tprel relocs
	in pies.
	(ppc_elf_tls_optimize): Optimise pies.
	(ppc_elf_relocate_section): Use a section symbol rather than no
	symbol if possible for LD->IE TLS sequence, but don't error if
	we must use no symbol.
	* elf64-ppc.c (MUST_BE_DYN_RELOC): As for elf32-ppc.c.
	(must_be_dyn_reloc): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	(ppc64_elf_tls_optimize): Likewise.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d2774 9
d2784 1
a2784 1
   entry syms.  */
a2873 2
  if (opdsymend == secsymend)
    goto done;
d2882 3
d2973 1
d2976 4
d3006 74
d3084 1
a3084 1
      names = (char *) (s + count);
d3140 60
d9954 2
a9955 1
	  h = elf_link_hash_lookup (&htab->elf, "__glink", TRUE, FALSE, FALSE);
@


1.279
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d3194 1
a3194 1
/* Of those relocs that might be copied as dynamic relocs, this macro
d3198 28
a3225 4
#define MUST_BE_DYN_RELOC(RTYPE)		\
  ((RTYPE) != R_PPC64_REL32			\
   && (RTYPE) != R_PPC64_REL64			\
   && (RTYPE) != R_PPC64_REL30)
d4519 1
a4519 1
	  if (info->shared)
d4704 1
a4704 1
	  if (info->shared)
d4773 2
a4774 1
	      info->flags |= DF_STATIC_TLS;
d4860 1
a4860 1
	       && (MUST_BE_DYN_RELOC (r_type)
d4956 1
a4956 1
	      if (!MUST_BE_DYN_RELOC (r_type))
d6284 1
a6284 1
       && (MUST_BE_DYN_RELOC (r_type)
d6324 1
a6324 1
	  if (!MUST_BE_DYN_RELOC (r_type))
d6796 1
a6796 1
  if (info->relocatable || info->shared)
d7788 1
a7788 1
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
d10207 4
a10210 1
	  && IS_PPC64_TLS_RELOC (r_type) != (sym_type == STT_TLS))
d10217 1
a10217 1
	      (sym_type == STT_TLS
d10436 9
a10444 1
		      r_symndx = 0;
d10446 5
a10450 1
		      rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
d11092 1
a11092 1
	       && (MUST_BE_DYN_RELOC (r_type)
d11177 1
a11177 1
		      if (bfd_is_abs_section (sec))
@


1.278
log
@bfd/
	* elf64-ppc.c (build_plt_stub): Add relocs on plt call stubs
	if emitrelocations.
	(get_relocs): New function, split out from..
	(ppc_build_one_stub): ..here.  Add relocs on plt_branch stubs if
	emitrelocations.  Remove indx temp.
	(ppc_size_one_stub): Count new stub relocs.
	(ppc64_elf_size_stubs): Count new glink reloc.
	(ppc64_elf_build_stubs): Emit glink reloc if emitrelocations.
	(ppc64_elf_finish_dynamic_sections): Output glink relocs.
	* elf32-ppc.c (ppc_elf_finish_dynamic_sections): Describe non-pic
	glink code.
ld/testsuite/
	* ld-powerpc/relbrlt.d: Update.  Also check .branch_lt section.
@
text
@d5029 1
a5029 5
		  sec = NULL;
		  if ((sym->st_shndx != SHN_UNDEF
		       && sym->st_shndx < SHN_LORESERVE)
		      || sym->st_shndx > SHN_HIRESERVE)
		    sec = bfd_section_from_elf_index (opd_bfd, sym->st_shndx);
d6059 1
a6059 8
	{
	  asection *symsec = NULL;
	  if ((sym->st_shndx != SHN_UNDEF
	       && sym->st_shndx < SHN_LORESERVE)
	      || sym->st_shndx > SHN_HIRESERVE)
	    symsec = bfd_section_from_elf_index (ibfd, sym->st_shndx);
	  *symsecp = symsec;
	}
d7569 1
a7569 4
		if (sym->st_shndx != SHN_UNDEF
		    && (sym->st_shndx < SHN_LORESERVE
			|| sym->st_shndx > SHN_HIRESERVE)
		    && sym->st_value != 0
@


1.277
log
@	* elf-bfd.h (enum elf_object_id): Add HPPA_ELF_TDATA.
	* elf.c (bfd_elf_allocate_object): Don't check for already allocated
	tdata.
	* elf32-hppa.c (elf32_hppa_mkobject): New function.
	(bfd_elf32_mkobject): Define.
	* elf32-ppc.c (is_ppc_elf_target): Delete.  Replace all uses with..
	(is_ppc_elf): ..this new macro.
	* elf64-ppc.c (is_ppc64_elf_target): Delete.  Replace all uses with..
	(is_ppc64_elf): ..this new macro.
@
text
@d8248 1
a8248 1
build_plt_stub (bfd *obfd, bfd_byte *p, int offset)
d8256 22
d8293 20
d8328 26
a8362 1
  unsigned int indx;
d8366 1
d8425 3
a8427 20
	  Elf_Internal_Rela *relocs, *r;
	  struct bfd_elf_section_data *elfsec_data;

	  elfsec_data = elf_section_data (stub_entry->stub_sec);
	  relocs = elfsec_data->relocs;
	  if (relocs == NULL)
	    {
	      bfd_size_type relsize;
	      relsize = stub_entry->stub_sec->reloc_count * sizeof (*relocs);
	      relocs = bfd_alloc (htab->stub_bfd, relsize);
	      if (relocs == NULL)
		return FALSE;
	      elfsec_data->relocs = relocs;
	      elfsec_data->rel_hdr.sh_size = (stub_entry->stub_sec->reloc_count
					      * sizeof (Elf64_External_Rela));
	      elfsec_data->rel_hdr.sh_entsize = sizeof (Elf64_External_Rela);
	      stub_entry->stub_sec->reloc_count = 0;
	    }
	  r = relocs + stub_entry->stub_sec->reloc_count;
	  stub_entry->stub_sec->reloc_count += 1;
d8482 3
a8484 3
      off = (stub_entry->target_value
	     + stub_entry->target_section->output_offset
	     + stub_entry->target_section->output_section->vma);
d8486 1
a8486 1
      bfd_put_64 (htab->brlt->owner, off,
d8503 1
a8503 1
	      rela.r_addend = off;
d8512 7
a8518 22
	      Elf_Internal_Rela *relocs, *r;
	      struct bfd_elf_section_data *elfsec_data;

	      elfsec_data = elf_section_data (htab->brlt);
	      relocs = elfsec_data->relocs;
	      if (relocs == NULL)
		{
		  bfd_size_type relsize;
		  relsize = htab->brlt->reloc_count * sizeof (*relocs);
		  relocs = bfd_alloc (htab->brlt->owner, relsize);
		  if (relocs == NULL)
		    return FALSE;
		  elfsec_data->relocs = relocs;
		  elfsec_data->rel_hdr.sh_size
		    = (stub_entry->stub_sec->reloc_count
		       * sizeof (Elf64_External_Rela));
		  elfsec_data->rel_hdr.sh_entsize
		    = sizeof (Elf64_External_Rela);
		  htab->brlt->reloc_count = 0;
		}
	      r = relocs + htab->brlt->reloc_count;
	      htab->brlt->reloc_count += 1;
d8523 1
a8523 1
	      r->r_addend = off;
d8527 5
a8531 3
      off = (br_entry->offset
	     + htab->brlt->output_offset
	     + htab->brlt->output_section->vma
d8545 19
a8563 1
      indx = off;
d8566 1
a8566 1
	  if (PPC_HA (indx) != 0)
d8569 1
a8569 1
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d8571 1
a8571 1
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d8576 1
a8576 1
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (indx), loc);
d8588 1
a8588 1
	  if (PPC_HA (indx) != 0)
d8591 1
a8591 1
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d8593 1
a8593 1
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d8598 1
a8598 1
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (indx), loc);
d8635 1
a8635 1
      off = (bfd_vma) -1;
d8639 1
a8639 1
	    off = ent->plt.offset;
d8642 1
a8642 1
      if (off >= (bfd_vma) -2)
d8645 7
a8651 5
      off &= ~ (bfd_vma) 1;
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);
d8663 12
a8674 1
      p = build_plt_stub (htab->stub_bfd, loc, off);
d8764 6
a8803 1
	  unsigned int indx;
d8838 6
a8843 1
	  indx = off;
d8847 1
a8847 1
	      if (PPC_HA (indx) != 0)
d8853 1
a8853 1
	      if (PPC_HA (indx) != 0)
d9666 7
d9809 11
d9821 1
a9821 5
      plt0 = (htab->plt->output_section->vma
	      + htab->plt->output_offset
	      - (htab->glink->output_section->vma
		 + htab->glink->output_offset
		 + 16));
d11679 9
@


1.276
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d2428 4
a2440 11
/* Return 1 if target is one of ours.  */

static bfd_boolean
is_ppc64_elf_target (const struct bfd_target *targ)
{
  extern const bfd_target bfd_elf64_powerpc_vec;
  extern const bfd_target bfd_elf64_powerpcle_vec;

  return targ == &bfd_elf64_powerpc_vec || targ == &bfd_elf64_powerpcle_vec;
}

d3878 1
a3878 1
  if (! is_ppc64_elf_target (abfd->xvec))
d4271 1
a4271 1
  if (!is_ppc64_elf_target (info->output_bfd->xvec))
d4274 1
a4274 1
  if (is_ppc64_elf_target (ibfd->xvec))
d4418 1
a4418 1
  BFD_ASSERT (is_ppc64_elf_target (abfd->xvec));
d4984 1
a4984 1
  BFD_ASSERT (is_ppc64_elf_target (opd_bfd->xvec));
d7745 1
a7745 1
	if (! is_ppc64_elf_target (gent->owner->xvec))
d7925 1
a7925 1
      if (!is_ppc64_elf_target (ibfd->xvec))
d8002 1
a8002 1
      if (!is_ppc64_elf_target (ibfd->xvec))
d8089 1
a8089 1
      if (!is_ppc64_elf_target (ibfd->xvec))
d9306 1
a9306 1
	  if (!is_ppc64_elf_target (input_bfd->xvec))
d9957 1
a9957 1
  BFD_ASSERT (is_ppc64_elf_target (input_bfd->xvec));
d11593 1
a11593 1
      if (!is_ppc64_elf_target (dynobj->xvec))
@


1.275
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d4278 1
a4278 1
  if (!is_ppc64_elf_target (htab->elf.root.creator))
@


1.274
log
@	PR 5646
	* elf64-ppc.c (ppc64_elf_tls_optimize): Ensure htab->tls_get_addr
	non-NULL before dereferencing.
@
text
@d2433 2
a2434 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct ppc64_elf_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d3885 3
d4425 2
d4428 1
a4428 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d4991 2
d5011 2
a5012 1
	  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (opd_bfd)->symtab_hdr;
d5270 1
a5270 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d6010 1
a6010 1
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d6374 1
a6374 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d6842 1
a6842 1
			  && (elf_tdata (ibfd)->symtab_hdr.contents
d7024 1
a7024 1
			  symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d7166 1
a7166 2
	    && (elf_tdata (ibfd)->symtab_hdr.contents
		!= (unsigned char *) locsyms))
d7171 1
a7171 1
	      elf_tdata (ibfd)->symtab_hdr.contents = (unsigned char *) locsyms;
d7259 1
a7259 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d7752 3
d7963 1
a7963 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d9099 1
a9099 2
      && (elf_tdata (isec->owner)->symtab_hdr.contents
	  != (unsigned char *) local_syms))
d9317 1
a9317 1
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d9964 2
d9968 1
a9968 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
@


1.273
log
@bfd/
	PR 5604
	* elf-bfd.h (struct elf_backend_data): Add gc_keep.  Remove param
	names from others.
	(_bfd_elf_gc_keep): Declare.
	* elfxx-target.h (elf_backend_gc_keep): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_gc_keep): New function.
	(bfd_elf_gc_sections): Call gc_keep.
	* elf64-ppc.c (elf_backend_gc_keep): Define.
	(struct _ppc64_elf_section_data): Move .opd related fields to
	a struct so they don't occupy the same storage.  Adjust accesses
	throughout file.
	(ppc64_elf_gc_keep): New function, split out from..
	(ppc64_elf_gc_mark_hook): ..here.  Don't call _bfd_elf_gc_mark
	to mark .opd section, just set gc_mark.
	(ppc64_elf_edit_opd): Remove no_opd_opt parm.  Don't set opd->adjust
	unless we are changing .opd.  Test non-NULL opd->adjust at all
	accesses throughout file.
	* elf64-ppc.h (ppc64_elf_edit_opd): Update prototype.
ld/
	PR 5604
	* ldlang.c (lang_gc_sections): Move code to set SEC_KEEP on entry
	syms to _bfd_elf_gc_keep.
	* emultempl/ppc64elf.em (ppc_before_allocation): Don't call
	ppc64_elf_edit_opd if no_opd_opt.
@
text
@d7077 1
a7077 1
		  if (expecting_tls_get_addr)
d7094 1
a7094 1
		  if (expecting_tls_get_addr)
@


1.272
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d99 1
a2611 1
  /* An array with one entry for each opd function descriptor.  */
d2614 9
a2622 4
    /* Points to the function code section for local opd entries.  */
    asection **opd_func_sec;
    /* After editing .opd, adjust references to opd local syms.  */
    long *opd_adjust;
d2656 1
a2656 1
static void *
d2662 1
a2662 1
    return ppc64_elf_section_data (sec)->u.opd_adjust;
d4446 1
a4446 7
	 information about the associated function section.  Later, if
	 edit_opd deletes entries, we'll use this array to adjust
	 local syms in .opd.  */
      union opd_info {
	asection *func_section;
	long entry_adjust;
      };
d4449 1
a4449 1
      amt = sec->size * sizeof (union opd_info) / 8;
d4453 1
a4453 1
      ppc64_elf_section_data (sec)->u.opd_func_sec = opd_sym_map;
d5071 39
d5163 1
a5163 1
			struct bfd_link_info *info,
a5169 40
  /* First mark all our entry sym sections.  */
  if (info->gc_sym_list != NULL)
    {
      struct ppc_link_hash_table *htab = ppc_hash_table (info);
      struct bfd_sym_chain *sym = info->gc_sym_list;

      info->gc_sym_list = NULL;
      for (; sym != NULL; sym = sym->next)
	{
	  struct ppc_link_hash_entry *eh;

	  eh = (struct ppc_link_hash_entry *)
	    elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
	  if (eh == NULL)
	    continue;
	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    continue;

	  if (eh->is_func_descriptor
	      && (eh->oh->elf.root.type == bfd_link_hash_defined
		  || eh->oh->elf.root.type == bfd_link_hash_defweak))
	    rsec = eh->oh->elf.root.u.def.section;
	  else if (get_opd_info (eh->elf.root.u.def.section) != NULL
		   && opd_entry_value (eh->elf.root.u.def.section,
				       eh->elf.root.u.def.value,
				       &rsec, NULL) != (bfd_vma) -1)
	    ;
	  else
	    continue;

	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);

	  rsec = eh->elf.root.u.def.section;
	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);
	}
    }

d5207 1
a5207 3
		  if (!eh->elf.root.u.def.section->gc_mark)
		    _bfd_elf_gc_mark (info, eh->elf.root.u.def.section,
				      ppc64_elf_gc_mark_hook);
d5215 1
a5215 5
		{
		  if (!eh->elf.root.u.def.section->gc_mark)
		    _bfd_elf_gc_mark (info, eh->elf.root.u.def.section,
				      ppc64_elf_gc_mark_hook);
		}
d5231 1
a5231 1
      asection **opd_sym_section;
d5234 2
a5235 2
      opd_sym_section = get_opd_info (rsec);
      if (opd_sym_section != NULL)
d5237 1
a5237 2
	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);
d5239 1
a5239 1
	  rsec = opd_sym_section[(sym->st_value + rel->r_addend) / 8];
d6153 1
a6153 1
  long *opd_adjust;
d6170 2
a6171 2
  opd_adjust = get_opd_info (sym_sec);
  if (opd_adjust != NULL)
d6173 1
a6173 1
      long adjust = opd_adjust[eh->elf.root.u.def.value / 8];
a6338 1
		    bfd_boolean no_opd_opt,
d6353 1
a6353 2
      bfd_size_type amt;
      long *opd_adjust;
a6360 18
      amt = sec->size * sizeof (long) / 8;
      opd_adjust = get_opd_info (sec);
      if (opd_adjust == NULL)
	{
	  /* check_relocs hasn't been called.  Must be a ld -r link
	     or --just-symbols object.   */
	  opd_adjust = bfd_alloc (obfd, amt);
	  if (opd_adjust == NULL)
	    return FALSE;
	  ppc64_elf_section_data (sec)->u.opd_adjust = opd_adjust;
	  BFD_ASSERT (ppc64_elf_section_data (sec)->sec_type == sec_normal);
	  ppc64_elf_section_data (sec)->sec_type = sec_opd;
	}
      memset (opd_adjust, 0, amt);

      if (no_opd_opt)
	continue;

d6504 8
d6603 1
a6603 1
		      opd_adjust[rel->r_offset / 8] = -1;
d6628 1
a6628 1
		      opd_adjust[rel->r_offset / 8]
d6657 1
a6657 1
		  rel->r_offset += opd_adjust[(offset - opd_ent_size) / 8];
d8946 1
a8946 1
      long *opd_adjust;
d9004 2
a9005 2
      opd_adjust = get_opd_info (sym_sec);
      if (opd_adjust != NULL)
d9007 1
a9007 1
	  if (h == NULL)
d9011 1
a9011 1
	      adjust = opd_adjust[sym->st_value / 8];
d9366 1
a9366 1
		  long *opd_adjust;
d9443 2
a9444 2
		  opd_adjust = get_opd_info (sym_sec);
		  if (opd_adjust != NULL)
d9448 1
a9448 1
		      if (hash == NULL)
d9450 1
a9450 1
			  long adjust = opd_adjust[sym_value / 8];
d10014 1
a10014 1
	  long *opd_adjust;
d10021 2
a10022 2
	  opd_adjust = get_opd_info (sec);
	  if (opd_adjust != NULL)
d10024 1
a10024 1
	      long adjust = opd_adjust[(sym->st_value + rel->r_addend) / 8];
d11343 2
a11344 1
  long *opd_adjust, adjust;
d11350 2
a11351 2
  opd_adjust = get_opd_info (input_sec);
  if (opd_adjust == NULL)
d11358 1
a11358 1
  adjust = opd_adjust[value / 8];
@


1.271
log
@bfd/ChangeLog:

	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Set udata.p of
	synthetic symbol to point to the ELF symbol it was derived from.

gdb/ChangeLog:

	* elfread.c (ST_REGULAR, ST_DYNAMIC, ST_SYNTHETIC): New defines.
	(elf_symtab_read): Rename DYNAMIC argument to TYPE.  Do not access
	ELF-private symbol data when processing synthetic symbols.  Use
	udata.p to get at size of ppc64 synthetic 'dot' symbols.
	(elf_symfile_read): Pass TYPE argument to elf_symtab_read.
@
text
@d5268 3
@


1.270
log
@bfd/
	* elf64-ppc.c (ppc64_elf_check_relocs): Don't refcount tlsld_got here..
	(ppc64_elf_gc_sweep_hook): ..or here..
	(ppc64_elf_tls_optimize): ..or here.  Make two passes through the
	relocs, ensuring that tls_get_addr calls follow gd and ld relocs.
	(allocate_dynrelocs): Refcount tlsld_got here.
	(ppc64_elf_size_dynamic_sections): Allocate local got and call
	allocate_dynrelocs before allocating tlsld_got.
	(ppc64_elf_relocate_section): Remove check that a tls_get_addr
	call follows gd and ld relocs.
ld/testsuite/
	* ld-powerpc/tlsso.d: Update for changed got alloc order.
	* ld-powerpc/tlsso.r: Likewise.
@
text
@d2962 3
d3052 3
@


1.269
log
@	* elf64-ppc.c (ppc_build_one_stub): Don't duplicate relocs
	emitted for ".brlt" entries.
	(toc_adjusting_stub_needed): Don't treat ".fixup" specially here..
	(ppc64_elf_next_input_section): ..instead do so here.
@
text
@d3164 2
a3165 1
     from one input file to another.
a4483 1
	  ppc64_tlsld_got (abfd)->refcount += 1;
a5308 1
	  ppc64_tlsld_got (abfd)->refcount -= 1;
d6797 1
d6809 89
a6897 19
      /* Look at all the sections for this file, with TOC last.  */
      for (sec = (ibfd->sections == toc && toc && toc->next ? toc->next
		  : ibfd->sections);
	   sec != NULL;
	   sec = (sec == toc ? NULL
		  : sec->next == NULL ? toc
		  : sec->next == toc && toc->next ? toc->next
		  : sec->next))
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	  {
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;
	    long toc_ref_index = 0;

	    /* Read the relocations.  */
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						  info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;
d6899 5
a6903 13
	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc64_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h;
		Elf_Internal_Sym *sym;
		asection *sym_sec;
		char *tls_mask;
		char tls_set, tls_clear, tls_type = 0;
		bfd_vma value;
		bfd_boolean ok_tprel, is_local;
d6905 16
a6920 15
		r_symndx = ELF64_R_SYM (rel->r_info);
		if (!get_sym_h (&h, &sym, &sym_sec, &tls_mask, &locsyms,
				r_symndx, ibfd))
		  {
		  err_free_rel:
		    if (elf_section_data (sec)->relocs != relstart)
		      free (relstart);
		    if (toc_ref != NULL)
		      free (toc_ref);
		    if (locsyms != NULL
			&& (elf_tdata (ibfd)->symtab_hdr.contents
			    != (unsigned char *) locsyms))
		      free (locsyms);
		    return FALSE;
		  }
d6922 12
a6933 4
		if (h != NULL)
		  {
		    if (h->root.type != bfd_link_hash_defined
			&& h->root.type != bfd_link_hash_defweak)
a6934 19
		    value = h->root.u.def.value;
		  }
		else
		  /* Symbols referenced by TLS relocs must be of type
		     STT_TLS.  So no need for .opd local sym adjust.  */
		  value = sym->st_value;

		ok_tprel = FALSE;
		is_local = FALSE;
		if (h == NULL
		    || !h->def_dynamic)
		  {
		    is_local = TRUE;
		    value += sym_sec->output_offset;
		    value += sym_sec->output_section->vma;
		    value -= htab->elf.tls_sec->vma;
		    ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				< (bfd_vma) 1 << 32);
		  }
d6936 50
a6985 12
		r_type = ELF64_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC64_GOT_TLSLD16:
		  case R_PPC64_GOT_TLSLD16_LO:
		  case R_PPC64_GOT_TLSLD16_HI:
		  case R_PPC64_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    ppc64_tlsld_got (ibfd)->refcount -= 1;
		    if (!is_local)
d6988 23
a7010 6
		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    tls_type = TLS_TLS | TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;
d7012 5
a7016 14
		  case R_PPC64_GOT_TLSGD16:
		  case R_PPC64_GOT_TLSGD16_LO:
		  case R_PPC64_GOT_TLSGD16_HI:
		  case R_PPC64_GOT_TLSGD16_HA:
		    if (ok_tprel)
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    tls_type = TLS_TLS | TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;
d7018 1
a7018 14
		  case R_PPC64_GOT_TPREL16_DS:
		  case R_PPC64_GOT_TPREL16_LO_DS:
		  case R_PPC64_GOT_TPREL16_HI:
		  case R_PPC64_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			tls_type = TLS_TLS | TLS_TPREL;
			break;
		      }
		    else
d7020 29
d7050 46
a7095 14
		  case R_PPC64_REL14:
		  case R_PPC64_REL14_BRTAKEN:
		  case R_PPC64_REL14_BRNTAKEN:
		  case R_PPC64_REL24:
		    if (h != NULL
			&& (h == &htab->tls_get_addr->elf
			    || h == &htab->tls_get_addr_fd->elf))
		      {
			if (!expecting_tls_get_addr
			    && rel != relstart
			    && ((ELF64_R_TYPE (rel[-1].r_info)
				 == R_PPC64_TOC16)
				|| (ELF64_R_TYPE (rel[-1].r_info)
				    == R_PPC64_TOC16_LO)))
d7097 1
a7097 9
			    /* Check for toc tls entries.  */
			    char *toc_tls;
			    int retval;

			    retval = get_tls_mask (&toc_tls, NULL, &locsyms,
						   rel - 1, ibfd);
			    if (retval == 0)
			      goto err_free_rel;
			    if (retval > 1 && toc_tls != NULL)
d7099 2
a7100 3
				expecting_tls_get_addr = 1;
				if (toc_ref != NULL)
				  toc_ref[toc_ref_index] = 1;
d7102 1
d7104 1
d7106 7
a7112 1
			if (expecting_tls_get_addr)
d7114 3
a7116 8
			    struct plt_entry *ent;
			    for (ent = h->plt.plist; ent; ent = ent->next)
			      if (ent->addend == 0)
				{
				  if (ent->plt.refcount > 0)
				    ent->plt.refcount -= 1;
				  break;
				}
d7118 1
a7118 3
		      }
		    expecting_tls_get_addr = 0;
		    continue;
d7120 1
a7120 26
		  case R_PPC64_TOC16:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TLS:
		    expecting_tls_get_addr = 0;
		    if (sym_sec == toc && toc != NULL)
		      {
			/* Mark this toc entry as referenced by a TLS
			   code sequence.  We can do that now in the
			   case of R_PPC64_TLS, and after checking for
			   tls_get_addr for the TOC16 relocs.  */
			if (toc_ref == NULL)
			  {
			    toc_ref = bfd_zmalloc (toc->size / 8);
			    if (toc_ref == NULL)
			      goto err_free_rel;
			  }
			if (h != NULL)
			  value = h->root.u.def.value;
			else
			  value = sym->st_value;
			value += rel->r_addend;
			BFD_ASSERT (value < toc->size && value % 8 == 0);
			toc_ref_index = value / 8;
			if (r_type == R_PPC64_TLS)
			  toc_ref[toc_ref_index] = 1;
		      }
d7123 3
a7125 15
		  case R_PPC64_TPREL64:
		    expecting_tls_get_addr = 0;
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;
d7127 5
a7131 23
		  case R_PPC64_DTPMOD64:
		    expecting_tls_get_addr = 0;
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
		    if (rel + 1 < relend
			&& (rel[1].r_info
			    == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			&& rel[1].r_offset == rel->r_offset + 8)
		      {
			if (ok_tprel)
			  /* GD -> LE */
			  tls_set = TLS_EXPLICIT | TLS_GD;
			else
			  /* GD -> IE */
			  tls_set = TLS_EXPLICIT | TLS_GD | TLS_TPRELGD;
			tls_clear = TLS_GD;
		      }
		    else
		      {
			if (!is_local)
			  continue;
d7133 7
a7139 5
			/* LD -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_LD;
		      }
		    break;
d7141 14
a7154 4
		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }
d7156 7
a7162 3
		if ((tls_set & TLS_EXPLICIT) == 0)
		  {
		    struct got_entry *ent;
d7164 3
a7166 5
		    /* Adjust got entry for this reloc.  */
		    if (h != NULL)
		      ent = h->got.glist;
		    else
		      ent = elf_local_got_ents (ibfd)[r_symndx];
d7168 3
a7170 22
		    for (; ent != NULL; ent = ent->next)
		      if (ent->addend == rel->r_addend
			  && ent->owner == ibfd
			  && ent->tls_type == tls_type)
			break;
		    if (ent == NULL)
		      abort ();

		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (ent->got.refcount > 0)
			  ent->got.refcount -= 1;
		      }
		  }
		else
		  {
		    /* If we got rid of a DTPMOD/DTPREL reloc pair then
		       we'll lose one or two dyn relocs.  */
		    if (!dec_dynrel_count (rel->r_info, sec, info,
					   NULL, h, sym_sec))
		      return FALSE;
d7172 2
a7173 7
		    if (tls_set == (TLS_EXPLICIT | TLS_GD))
		      {
			if (!dec_dynrel_count ((rel + 1)->r_info, sec, info,
					       NULL, h, sym_sec))
			  return FALSE;
		      }
		  }
d7175 8
a7182 6
		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }

	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
d7184 1
a7184 14

      if (toc_ref != NULL)
	free (toc_ref);

      if (locsyms != NULL
	  && (elf_tdata (ibfd)->symtab_hdr.contents
	      != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    elf_tdata (ibfd)->symtab_hdr.contents = (unsigned char *) locsyms;
	}
    }
d7758 2
a7759 1
	    gent->got.offset = ppc64_tlsld_got (gent->owner)->offset;
a7942 14
      if (ppc64_tlsld_got (ibfd)->refcount > 0)
	{
	  s = ppc64_elf_tdata (ibfd)->got;
	  ppc64_tlsld_got (ibfd)->offset = s->size;
	  s->size += 16;
	  if (info->shared)
	    {
	      srel = ppc64_elf_tdata (ibfd)->relgot;
	      srel->size += sizeof (Elf64_External_Rela);
	    }
	}
      else
	ppc64_tlsld_got (ibfd)->offset = (bfd_vma) -1;

d7986 2
a7987 8
		    if (ppc64_tlsld_got (ibfd)->offset == (bfd_vma) -1)
		      {
			ppc64_tlsld_got (ibfd)->offset = s->size;
			s->size += 16;
			if (info->shared)
			  srel->size += sizeof (Elf64_External_Rela);
		      }
		    ent->got.offset = ppc64_tlsld_got (ibfd)->offset;
d8015 20
d10184 1
a10184 1
			  goto tls_get_addr_check;
d10189 1
a10189 1
			  goto tls_get_addr_check;
d10302 1
a10302 1
	    goto tls_get_addr_check;
d10309 12
a10320 2
	    tls_get_addr_check:
	      if (rel + 1 < relend)
d10322 9
a10330 45
		  enum elf_ppc64_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2, insn3;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2 = ELF64_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF64_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC64_REL14
			  && r_type2 != R_PPC64_REL14_BRTAKEN
			  && r_type2 != R_PPC64_REL14_BRNTAKEN
			  && r_type2 != R_PPC64_REL24))
		    break;

		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || (h2 != &htab->tls_get_addr->elf
				     && h2 != &htab->tls_get_addr_fd->elf))
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
		  if ((tls_mask & tls_gd) != 0)
		    {
		      /* IE */
		      insn1 &= (1 << 26) - (1 << 2);
		      insn1 |= 58 << 26;	/* ld */
		      insn2 = 0x7c636a14;	/* add 3,3,13 */
		      rel[1].r_info = ELF64_R_INFO (r_symndx2, R_PPC64_NONE);
		      if ((tls_mask & TLS_EXPLICIT) == 0)
			r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
				  + R_PPC64_GOT_TPREL16_DS);
		      else
			r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		    }
d10332 9
d10342 4
a10345 34
		      /* LE */
		      insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			}
		      else if (toc_symndx != 0)
			r_symndx = toc_symndx;
		      r_type = R_PPC64_TPREL16_HA;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF64_R_INFO (r_symndx,
						    R_PPC64_TPREL16_LO);
		      rel[1].r_offset += d_offset;
		    }
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      insn3 = insn2;
		      insn2 = NOP;
		      rel[1].r_offset += 4;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - d_offset);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
		  if (tls_gd == 0 || toc_symndx != 0)
		    {
		      /* We changed the symbol.  Start over in order
			 to get h, sym, sec etc. right.  */
		      rel--;
		      continue;
d10347 25
@


1.268
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d8390 1
a8390 1
      if (htab->relbrlt != NULL)
d8392 23
a8414 18
	  /* Create a reloc for the branch lookup table entry.  */
	  Elf_Internal_Rela rela;
	  bfd_byte *rl;

	  rela.r_offset = (br_entry->offset
			   + htab->brlt->output_offset
			   + htab->brlt->output_section->vma);
	  rela.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
	  rela.r_addend = off;

	  rl = htab->relbrlt->contents;
	  rl += htab->relbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->relbrlt->owner, &rela, rl);
	}
      else if (info->emitrelocations)
	{
	  Elf_Internal_Rela *relocs, *r;
	  struct bfd_elf_section_data *elfsec_data;
d8416 2
a8417 7
	  elfsec_data = elf_section_data (htab->brlt);
	  relocs = elfsec_data->relocs;
	  if (relocs == NULL)
	    {
	      bfd_size_type relsize;
	      relsize = htab->brlt->reloc_count * sizeof (*relocs);
	      relocs = bfd_alloc (htab->brlt->owner, relsize);
d8419 22
a8440 14
		return FALSE;
	      elfsec_data->relocs = relocs;
	      elfsec_data->rel_hdr.sh_size = (stub_entry->stub_sec->reloc_count
					      * sizeof (Elf64_External_Rela));
	      elfsec_data->rel_hdr.sh_entsize = sizeof (Elf64_External_Rela);
	      htab->brlt->reloc_count = 0;
	    }
	  r = relocs + htab->brlt->reloc_count;
	  htab->brlt->reloc_count += 1;
	  r->r_offset = (br_entry->offset
			 + htab->brlt->output_offset
			 + htab->brlt->output_section->vma);
	  r->r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
	  r->r_addend = off;
a8875 5
  /* Hack for linux kernel.  .fixup contains branches, but only back to
     the function that hit an exception.  */
  if (strcmp (isec->name, ".fixup") == 0)
    return 0;

d9080 7
a9086 2
	 can't find their function symbol (shouldn't ever happen now).  */
      if (isec->has_toc_reloc || (isec->flags & SEC_CODE) == 0)
@


1.267
log
@	* elf64-ppc.c (ppc_build_one_stub): Correct rel_hdr.sh_size.
@
text
@d4622 3
a4624 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.266
log
@	* elf64-ppc.c (func_desc_adjust): When resolving undefined
	references to dot-symbols, transfer def_regular and
	def_dynamic from the descriptor symbol.
@
text
@d8320 3
a8322 2
	      elfsec_data->rel_hdr.sh_size = relsize;
	      elfsec_data->rel_hdr.sh_entsize = 24;
d8419 3
a8421 2
	      elfsec_data->rel_hdr.sh_size = relsize;
	      elfsec_data->rel_hdr.sh_entsize = 24;
@


1.265
log
@bfd/
	* elf64-ppc.c (ADDI_R12_R12, LD_R11_0R2, LD_R2_0R2): Define.
	Update stub comments.
	(build_plt_stub): Build two variants, one without "addis".
	(ppc_build_one_stub): Build stubs without "addis" if possible.
	(ppc_size_one_stub): Size new stubs.
ld/testsuite/
	* ld-powerpc/relbrlt.s (.text.pad2): Adjust space.
	* ld-powerpc/relbrlt.d: Update.
	* ld-powerpc/tlsexe.d: Update.
	* ld-powerpc/tlsexe.g: Update.
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexetoc.d: Update.
	* ld-powerpc/tlsexetoc.g: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-powerpc/tlsso.d: Update.
	* ld-powerpc/tlsso.g: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.d: Update.
	* ld-powerpc/tlstocso.g: Update.
@
text
@d5654 2
@


1.264
log
@Switch sources over to use the GPL version 3
@
text
@d134 1
a134 1
   insert an addis to adjust r12.  */
d139 1
a140 1
#define MTCTR_R11	0x7d6903a6	/* mtctr %r11		     */
d146 1
d150 3
d3242 1
a3242 2
   "addis %r12,%r12,1" will be inserted before the load at xxx+8 or
   xxx+16 as appropriate.
d3246 1
a3247 1
   .	mtctr	%r11
d3267 3
d8202 29
a8230 13
  bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (offset), p),	p += 4;
  bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
  bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset), p),	p += 4;
  if (PPC_HA (offset + 8) != PPC_HA (offset))
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
  offset += 8;
  bfd_put_32 (obfd, LD_R2_0R12 | PPC_LO (offset), p),	p += 4;
  if (PPC_HA (offset + 8) != PPC_HA (offset))
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
  offset += 8;
  bfd_put_32 (obfd, MTCTR_R11, p),			p += 4;
  bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset), p),	p += 4;
  bfd_put_32 (obfd, BCTR, p),				p += 4;
d8273 2
a8274 3
      if (stub_entry->stub_type != ppc_stub_long_branch_r2off)
	size = 4;
      else
d8282 7
a8288 2
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
d8291 1
a8291 2
	  off -= 12;
	  size = 16;
d8448 12
a8459 4
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  size = 16;
d8469 21
a8489 6
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
a8490 1
	  size = 28;
d8629 2
d8638 2
d8655 6
a8660 2
	  off -= 12;
	  size = 16;
d8667 1
d8696 22
a8717 3
	  size = 16;
	  if (stub_entry->stub_type != ppc_stub_plt_branch)
	    size = 28;
@


1.264.2.1
log
@bfd/
	* elf64-ppc.c (ADDI_R12_R12, LD_R11_0R2, LD_R2_0R2): Define.
	Update stub comments.
	(build_plt_stub): Build two variants, one without "addis".
	(ppc_build_one_stub): Build stubs without "addis" if possible.
	(ppc_size_one_stub): Size new stubs.
ld/testsuite/
	* ld-powerpc/relbrlt.s (.text.pad2): Adjust space.
	* ld-powerpc/relbrlt.d: Update.
	* ld-powerpc/tlsexe.d: Update.
	* ld-powerpc/tlsexe.g: Update.
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexetoc.d: Update.
	* ld-powerpc/tlsexetoc.g: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-powerpc/tlsso.d: Update.
	* ld-powerpc/tlsso.g: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.d: Update.
	* ld-powerpc/tlstocso.g: Update.
@
text
@d134 1
a134 1
   insert an addi to adjust r12.  */
d139 1
a140 1
#define LD_R2_0R12	0xe84c0000	/* ld	 %r2,xxx+8@@l(%r12)   */
a145 1
#define ADDI_R12_R12	0x398c0000	/* addi %r12,%r12,off@@l  */
a148 3
#define LD_R11_0R2	0xe9620000	/* ld	 %r11,xxx+0(%r2) */
#define LD_R2_0R2	0xe8420000	/* ld	 %r2,xxx+0(%r2)  */

d3238 2
a3239 1
   "addi %r12,%r12,xxx@@toc@@l" will be inserted before the "mtctr".
d3243 1
a3244 1
   .	ld	%r2,xxx+8@@toc@@l(%r12)
a3263 3

   In cases where the "addis" instruction would add zero, the "addis" is
   omitted and following instructions modified slightly in some cases.
d8196 13
a8208 29
  if (PPC_HA (offset) != 0)
    {
      bfd_put_32 (obfd, ADDIS_R12_R2 | PPC_HA (offset), p),	p += 4;
      bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
      bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset), p),	p += 4;
      if (PPC_HA (offset + 16) != PPC_HA (offset))
	{
	  bfd_put_32 (obfd, ADDI_R12_R12 | PPC_LO (offset), p),	p += 4;
	  offset = 0;
	}
      bfd_put_32 (obfd, MTCTR_R11, p),				p += 4;
      bfd_put_32 (obfd, LD_R2_0R12 | PPC_LO (offset + 8), p),	p += 4;
      bfd_put_32 (obfd, LD_R11_0R12 | PPC_LO (offset + 16), p),	p += 4;
      bfd_put_32 (obfd, BCTR, p),				p += 4;
    }
  else
    {
      bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
      bfd_put_32 (obfd, LD_R11_0R2 | PPC_LO (offset), p),	p += 4;
      if (PPC_HA (offset + 16) != PPC_HA (offset))
	{
	  bfd_put_32 (obfd, ADDI_R2_R2 | PPC_LO (offset), p),	p += 4;
	  offset = 0;
	}
      bfd_put_32 (obfd, MTCTR_R11, p),				p += 4;
      bfd_put_32 (obfd, LD_R11_0R2 | PPC_LO (offset + 16), p),	p += 4;
      bfd_put_32 (obfd, LD_R2_0R2 | PPC_LO (offset + 8), p),	p += 4;
      bfd_put_32 (obfd, BCTR, p),				p += 4;
    }
d8251 3
a8253 2
      size = 4;
      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
d8261 2
a8262 7
	  size = 12;
	  if (PPC_HA (r2off) != 0)
	    {
	      size = 16;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	      loc += 4;
	    }
d8265 2
a8266 1
	  off -= size - 4;
d8423 4
a8426 12
	  if (PPC_HA (indx) != 0)
	    {
	      size = 16;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	      loc += 4;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	    }
	  else
	    {
	      size = 12;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (indx), loc);
	    }
d8436 6
a8441 21
	  size = 20;
	  if (PPC_HA (indx) != 0)
	    {
	      size += 4;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	      loc += 4;
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	      loc += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->stub_bfd, LD_R11_0R2 | PPC_LO (indx), loc);
	      loc += 4;
	    }

	  if (PPC_HA (r2off) != 0)
	    {
	      size += 4;
	      bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	      loc += 4;
	    }
d8443 1
a8581 2
      if (PPC_HA (off) == 0)
	size -= 4;
a8588 2
      bfd_vma r2off = 0;

d8604 2
a8605 6
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
	  size = 12;
	  if (PPC_HA (r2off) != 0)
	    size = 16;
	  off -= size - 4;
a8611 1
	  unsigned int indx;
d8640 3
a8642 22
	  off = (br_entry->offset
		 + htab->brlt->output_offset
		 + htab->brlt->output_section->vma
		 - elf_gp (htab->brlt->output_section->owner)
		 - htab->stub_group[stub_entry->id_sec->id].toc_off);

	  indx = off;
	  if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
	    {
	      size = 12;
	      if (PPC_HA (indx) != 0)
		size = 16;
	    }
	  else
	    {
	      size = 20;
	      if (PPC_HA (indx) != 0)
		size += 4;

	      if (PPC_HA (r2off) != 0)
		size += 4;
	    }
@


1.263
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
@


1.262
log
@	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Don't do copyreloc
	processing if symbol is defined in the executable.
@
text
@a5801 1
  unsigned int power_of_two;
a5921 7
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
a5922 6
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }
d5924 1
a5924 8
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.261
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5854 4
@


1.260
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d28 1
a30 1
#include "sysdep.h"
@


1.259
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d80 1
d2115 16
@


1.258
log
@	* elf-bfd.h (struct elf_backend_data): Add default_execstack.
	* elflink.c (bfd_elf_size_dynamic_sections): Heed default_execstack.
	* elfxx-target.h (elf_backend_default_execstack): Define to 1.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_default_execstack): Define to 0.
@
text
@a9898 2
	  if (info->relocatable)
	    continue;
a9901 2
	  if (info->relocatable)
	    continue;
d9911 15
d10745 1
a10745 1
	  goto dodyn2;
a10844 3
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
a10845 9
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (ppc64_elf_howto_table[r_type], input_bfd,
				   contents + rel->r_offset);
	      break;
	    }
	  /* Fall thru.  */

	dodyn2:
@


1.257
log
@bfd/
	* elf64-ppc.c (create_linkage_sections): Use section ".branch_lt"
	for branch lookup table.
ld/
	* emulparams/elf64ppc.sh (OTHER_READWRITE_SECTIONS): Add ".branch_lt".
	* emultempl/ppc64elf.em (ppc_add_stub_section): Create without
	SEC_RELOC flag set.
ld/testsuite/
	* ld-powerpc/relbrlt.d: Update.
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@d76 1
d1201 1
a1201 1
    HOWTO (R_PPC64_PLTGOT16_DS,	/* type */
@


1.256
log
@bfd/
	* elf64-ppc.c (create_linkage_sections): Don't create
	.rela.rodata.brlt for --emit-relocs.
	(ppc_build_one_stub): Create relocs for brlt --emit-relocs here.
	(ppc_size_one_stub): Count them.  Simplify test of stub type
	when counting stub relocs.  Set SEC_RELOC too.
	(ppc64_elf_size_stubs): Clear reloc_count and SEC_RELOC.
	(ppc64_elf_finish_dynamic_sections): Output brlt relocs.
ld/testsuite/
	* ld-powerpc/relbrlt.d: Update.
@
text
@d3821 4
a3824 16
  if (info->shared)
    {
      flags = (SEC_ALLOC | SEC_LOAD
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->brlt
	= bfd_make_section_anyway_with_flags (dynobj, ".data.rel.ro.brlt",
					      flags);
    }
  else
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->brlt
	= bfd_make_section_anyway_with_flags (dynobj, ".rodata.brlt", flags);
    }

d3829 1
a3829 9
  if (info->shared)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->relbrlt
	= bfd_make_section_anyway_with_flags (dynobj, ".rela.data.rel.ro.brlt",
					      flags);
    }
  else
d3832 5
@


1.255
log
@	* elf-bfd.h (struct elf_backend_data): Add elf_backend_write_core_note.
	* elfxx-target.h (elf_backend_write_core_note): Define and use.
	* elf.c (elfcore_write_prpsinfo): Call the above.  Add support for
	32-bit core note on 64-bit target.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_lwpstatus): Make note_name const.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_pstatus): Add support for 32-bit core note on 64-bit
	target.
	* elf32-ppc.c (ppc_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
	* elf64-ppc.c (ppc64_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a3848 8
  else if (info->emitrelocations)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
	       | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      htab->relbrlt
	= bfd_make_section_anyway_with_flags (dynobj, ".rela.rodata.brlt",
					      flags);
    }
d8389 27
d8645 5
d8657 5
a8661 5

      if (info->emitrelocations
	  && (stub_entry->stub_type == ppc_stub_long_branch
	      || stub_entry->stub_type == ppc_stub_long_branch_r2off))
	stub_entry->stub_sec->reloc_count += 1;
d9453 1
d9457 2
d11472 11
@


1.254
log
@	* elf-bfd.h (struct elf_backend_data): Add as_needed_cleanup hook.
	* elfxx-target.h (elf_backend_as_needed_cleanup): Define.
	(elfNN_bed): Add as_needed_cleanup hook.
	* elflink.c (elf_link_add_object_symbols): Call it when reverting
	hash table changes for unneeded --as-needed input.
	* elf64-ppc64.c (elf_backend_as_needed_cleanup): Define.
	(ppc64_elf_as_needed_cleanup): New function.
@
text
@d28 1
d88 1
d2489 47
@


1.253
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Fixup D field
	at proper offset in little-endian mode.
	* elf64-ppc.c (ppc_elf_relocate_section): Likewise.
@
text
@d91 1
d4251 11
@


1.252
log
@	* elf64-ppc.c (enum _ppc64_sec_type): New.
	(struct _ppc64_elf_section_data): Move "t_symndx" into opd union,
	and rename fields.  Add sec_type and has_14bit_branch.
	(struct ppc_link_hash_table): Remove has_14bit_branch.
	(get_opd_info, get_tls_mask, ppc64_elf_edit_opd): Adjust.
	(ppc64_elf_relocate_section): Likewise.
	(ppc64_elf_check_relocs): Likewise.  Set per-section has_14bit_branch.
	(ppc64_elf_size_stubs): Don't set default group size here.
	(group_sections): Instead do so here, and group sections using
	their individual requirements.
@
text
@d9734 1
d9964 1
a9964 1
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
d9967 1
a9967 1
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
d10019 2
a10020 2
		 PPC64_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
d10053 1
a10053 1
		  rel->r_offset -= 2;
d10102 1
a10102 1
				      contents + rel->r_offset - 2);
d10137 1
a10137 1
		      rel[1].r_offset += 2;
d10146 1
a10146 1
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
@


1.251
log
@	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Remove "has_dotsym"
	and union.
	(struct ppc_link_hash_entry): Add "next_dot_sym".
	(struct ppc_link_hash_table): Add "dot_syms".
	(link_hash_newfunc): Make list of syms starting with a dot.
	(ppc_get_stub_entry, adjust_opd_syms): Adjust.
	(ppc64_elf_add_symbol_hook): Don't set has_dotsym.
	(struct add_symbol_adjust_data): Delete.
	(add_symbol_adjust): Simplify params and return.
	(ppc64_elf_check_directives): Just process the "dot_syms" lists,
	not all syms.
@
text
@d2528 6
d2542 1
a2542 1
    asection **func_sec;
d2544 8
a2551 2
    long *adjust;
  } opd;
d2553 3
a2555 3
  /* An array for toc sections, indexed by offset/8.
     Specifies the relocation symbol index used at a given toc offset.  */
  unsigned *t_symndx;
d2583 2
a2584 2
      && ppc64_elf_section_data (sec)->opd.adjust != NULL)
    return ppc64_elf_section_data (sec)->opd.adjust;
a3372 4
  /* Flag set when small branches are detected.  Used to
     select suitable defaults for the stub group size.  */
  unsigned int has_14bit_branch:1;

d4384 3
a4386 1
      ppc64_elf_section_data (sec)->opd.func_sec = opd_sym_map;
d4400 1
d4582 1
a4582 1
	      htab->has_14bit_branch = 1;
d4653 2
a4654 1
	  if (ppc64_elf_section_data (sec)->t_symndx == NULL)
d4658 2
a4659 2
	      ppc64_elf_section_data (sec)->t_symndx = bfd_zalloc (abfd, amt);
	      if (ppc64_elf_section_data (sec)->t_symndx == NULL)
d4661 2
d4665 1
a4665 1
	  ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8] = r_symndx;
d4670 1
a4670 1
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -1;
d4672 1
a4672 1
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -2;
d6068 1
a6068 1
      || ppc64_elf_section_data (sec)->t_symndx == NULL)
d6081 2
a6082 2
  r_symndx = ppc64_elf_section_data (sec)->t_symndx[off / 8];
  next_r = ppc64_elf_section_data (sec)->t_symndx[off / 8 + 1];
d6323 3
a6325 1
	  ppc64_elf_section_data (sec)->opd.adjust = opd_adjust;
d8959 23
a8981 1
  asection **list = htab->input_list + htab->top_index;
d8995 3
a8997 2
	  big_sec = total > stub_group_size;
	  if (big_sec)
d9004 2
a9005 1
		     < stub_group_size)
d9037 2
a9038 1
			 < stub_group_size)
a9078 16
  if (stub_group_size == 1)
    {
      /* Default values.  */
      if (stubs_always_before_branch)
	{
	  stub_group_size = 0x1e00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7800;
	}
      else
	{
	  stub_group_size = 0x1c00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7000;
	}
    }
d9749 1
a9749 1
  is_opd = ppc64_elf_section_data (input_section)->opd.adjust != NULL;
@


1.250
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2380 3
a2382 8
  union {
    /* Used during garbage collection.  We attach global symbols defined
       on removed .opd entries to this section so that the sym is removed.  */
    asection *deleted_section;

    /* Used when adding symbols.  */
    bfd_boolean has_dotsym;
  } u;
d3239 8
a3246 3
  /* A pointer to the most recently used stub hash entry against this
     symbol.  */
  struct ppc_stub_hash_entry *stub_cache;
d3324 3
d3483 1
a3483 1
      memset (&eh->stub_cache, 0,
d3485 26
a3510 1
	       - offsetof (struct ppc_link_hash_entry, stub_cache)));
d3656 3
a3658 3
  if (h != NULL && h->stub_cache != NULL
      && h->stub_cache->h == h
      && h->stub_cache->id_sec == id_sec)
d3660 1
a3660 1
      stub_entry = h->stub_cache;
d3673 1
a3673 1
	h->stub_cache = stub_entry;
a4081 15
/* Hacks to support old ABI code.
   When making function calls, old ABI code references function entry
   points (dot symbols), while new ABI code references the function
   descriptor symbol.  We need to make any combination of reference and
   definition work together, without breaking archive linking.

   For a defined function "foo" and an undefined call to "bar":
   An old object defines "foo" and ".foo", references ".bar" (possibly
   "bar" too).
   A new object defines "foo" and references "bar".

   A new object thus has no problem with its undefined symbols being
   satisfied by definitions in an old object.  On the other hand, the
   old object won't have ".bar" satisfied by a new object.  */

d4086 1
a4086 1
ppc64_elf_add_symbol_hook (bfd *ibfd,
d4089 1
a4089 1
			   const char **name,
a4097 6
  if ((*name)[0] == '.'
      && ELF_ST_BIND (isym->st_info) == STB_GLOBAL
      && ELF_ST_TYPE (isym->st_info) < STT_SECTION
      && is_ppc64_elf_target (ibfd->xvec))
    ppc64_elf_tdata (ibfd)->u.has_dotsym = 1;

a4145 6
struct add_symbol_adjust_data
{
  struct bfd_link_info *info;
  bfd_boolean ok;
};

d4147 1
a4147 1
add_symbol_adjust (struct elf_link_hash_entry *h, void *inf)
a4148 1
  struct add_symbol_adjust_data *data;
a4149 1
  struct ppc_link_hash_entry *eh;
d4152 1
a4152 1
  if (h->root.type == bfd_link_hash_indirect)
d4155 2
a4156 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d4158 2
a4159 2
  if (h->root.root.string[0] != '.')
    return TRUE;
d4161 1
a4161 3
  data = inf;
  htab = ppc_hash_table (data->info);
  eh = (struct ppc_link_hash_entry *) h;
d4164 1
a4164 1
      && !data->info->relocatable
d4172 1
a4172 1
      fdh = make_fdh (data->info, eh);
d4174 1
a4174 1
	data->ok = FALSE;
d4200 2
d4203 1
a4203 1
ppc64_elf_check_directives (bfd *abfd, struct bfd_link_info *info)
d4206 1
a4206 8
  struct add_symbol_adjust_data data;

  if (!is_ppc64_elf_target (abfd->xvec))
    return TRUE;

  if (!ppc64_elf_tdata (abfd)->u.has_dotsym)
    return TRUE;
  ppc64_elf_tdata (abfd)->u.deleted_section = NULL;
d4212 19
a4230 3
  data.info = info;
  data.ok = TRUE;
  elf_link_hash_traverse (&htab->elf, add_symbol_adjust, &data);
d4239 1
a4239 1
  return data.ok;
d6114 1
a6114 1
	  asection *dsec = ppc64_elf_tdata (sym_sec->owner)->u.deleted_section;
d6120 1
a6120 1
		    ppc64_elf_tdata (sym_sec->owner)->u.deleted_section = dsec;
@


1.249
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): Clarify comment.
@
text
@d10731 5
a10735 1
	    break;
@


1.248
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d6611 1
a6611 1
	  /* Fudge the size too, as this is used later in
@


1.247
log
@	* elf64-ppc.c (ppc64_elf_build_stubs): Test glink size for
	existence of PLT.
@
text
@d100 1
d10844 11
@


1.246
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d9454 1
a9454 1
  if (htab->plt != NULL)
@


1.245
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Correct GOT and PLT HA
	reloc handling.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d2523 7
a2529 7
  { ".plt",     4,  0, SHT_NOBITS,   0 },
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".toc",     4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".toc1",    5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".tocbss",  7,  0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
d4578 1
a4578 1
		       && !strncmp (h->root.root.string, ".__tls_get_addr", 15)
d4586 1
a4586 1
		       && !strncmp (h->root.root.string, "__tls_get_addr", 14)
d4779 1
a4779 1
		  if (strncmp (name, ".rela", 5) != 0
d7916 1
a7916 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
@


1.244
log
@bfd/
	* elf64-ppc.c (create_linkage_sections): Align .glink to 8 bytes.
	(ppc64_elf_build_stubs): Use new lazy linking stub.
ld/testsuite/
	* ld-powerpc/tlsexe.d: Update for lazy link stub change.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexetoc.d: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso.d: Likewise.
	* ld-powerpc/tlstocso.d: Likewise.
@
text
@a10930 3
	case R_PPC64_GOT16_HA:
	case R_PPC64_PLTGOT16_HA:
	case R_PPC64_PLT16_HA:
a10934 4
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TLSLD16_HA:
	case R_PPC64_GOT_TPREL16_HA:
	case R_PPC64_GOT_DTPREL16_HA:
d10947 14
a10960 4
	  if (sec != NULL)
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
@


1.243
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): Ignore non-code sections.
@
text
@d138 1
d144 1
a144 2
/* glink call stub instructions.  We enter with the index in R0, and the
   address of glink entry in CTR.  From that, we can calculate PLT0.  */
d146 15
a160 16
#define MFCTR_R12	0x7d8902a6	/* mfctr  %r12			*/
#define SLDI_R11_R0_3	0x780b1f24	/* sldi	  %r11,%r0,3		*/
#define ADDIC_R2_R0_32K 0x34408000	/* addic. %r2,%r0,-32768	*/
#define SUB_R12_R12_R11 0x7d8b6050	/* sub	  %r12,%r12,%r11	*/
#define SRADI_R2_R2_63	0x7c42fe76	/* sradi  %r2,%r2,63		*/
#define SLDI_R11_R0_2	0x780b1764	/* sldi	  %r11,%r0,2		*/
#define AND_R2_R2_R11	0x7c425838	/* and	  %r2,%r2,%r11		*/
					/* sub	  %r12,%r12,%r11	*/
#define ADD_R12_R12_R2	0x7d8c1214	/* add	  %r12,%r12,%r2		*/
#define ADDIS_R12_R12	0x3d8c0000	/* addis  %r12,%r12,xxx@@ha	*/
					/* ld	  %r11,xxx@@l(%r12)	*/
#define ADDI_R12_R12	0x398c0000	/* addi	  %r12,%r12,xxx@@l	*/
					/* ld	  %r2,8(%r12)		*/
					/* mtctr  %r11			*/
					/* ld	  %r11,16(%r12)		*/
					/* bctr				*/
d3730 1
a3730 1
      || ! bfd_set_section_alignment (dynobj, htab->glink, 2))
a9459 12
      plt0 = (htab->plt->output_section->vma
	      + htab->plt->output_offset
	      - (htab->glink->output_section->vma
		 + htab->glink->output_offset
		 + GLINK_CALL_STUB_SIZE));
      if (plt0 + 0x80008000 > 0xffffffff)
	{
	  (*_bfd_error_handler) (_(".glink and .plt too far apart"));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

d9470 1
a9470 1
	      h->root.u.def.value = 0;
d9479 8
a9486 7
      bfd_put_32 (htab->glink->owner, MFCTR_R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_3, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDIC_R2_R0_32K, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
d9488 1
a9488 1
      bfd_put_32 (htab->glink->owner, SRADI_R2_R2_63, p);
d9490 1
a9490 1
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_2, p);
d9492 1
a9492 1
      bfd_put_32 (htab->glink->owner, AND_R2_R2_R11, p);
d9494 1
a9494 1
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
d9496 1
a9496 1
      bfd_put_32 (htab->glink->owner, ADD_R12_R12_R2, p);
d9498 1
a9498 5
      bfd_put_32 (htab->glink->owner, ADDIS_R12_R12 | PPC_HA (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | PPC_LO (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDI_R12_R12 | PPC_LO (plt0), p);
d9508 5
d9531 1
a9531 1
		      B_DOT | ((htab->glink->contents - p) & 0x3fffffc), p);
@


1.242
log
@	* elf64-ppc.c (ppc64_elf_build_stubs): Clear relbrlt reloc_count
	after stubs have been built.
@
text
@d9083 3
@


1.241
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d9564 3
@


1.240
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@a2410 2
  bfd_size_type amt = sizeof (struct ppc64_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d2412 7
a2418 2
    return FALSE;
  return TRUE;
@


1.239
log
@	* elf64-ppc.c (compare_symbols): Prefer strong dynamic global
	function syms over other syms.
@
text
@d64 1
@


1.238
log
@        * elf64-ppc.c (ppc64_elf_finish_dynamic_symbol): Remove unused
        local variable `dynobj'.
@
text
@d2629 26
@


1.238.4.1
log
@	* elf64-ppc.c (compare_symbols): Prefer strong dynamic global
	function syms over other syms.
@
text
@a2628 26
  /* For syms with the same value, prefer strong dynamic global function
     syms over other syms.  */
  if ((a->flags & BSF_GLOBAL) != 0 && (b->flags & BSF_GLOBAL) == 0)
    return -1;

  if ((a->flags & BSF_GLOBAL) == 0 && (b->flags & BSF_GLOBAL) != 0)
    return 1;

  if ((a->flags & BSF_FUNCTION) != 0 && (b->flags & BSF_FUNCTION) == 0)
    return -1;

  if ((a->flags & BSF_FUNCTION) == 0 && (b->flags & BSF_FUNCTION) != 0)
    return 1;

  if ((a->flags & BSF_WEAK) == 0 && (b->flags & BSF_WEAK) != 0)
    return -1;

  if ((a->flags & BSF_WEAK) != 0 && (b->flags & BSF_WEAK) == 0)
    return 1;

  if ((a->flags & BSF_DYNAMIC) != 0 && (b->flags & BSF_DYNAMIC) == 0)
    return -1;

  if ((a->flags & BSF_DYNAMIC) == 0 && (b->flags & BSF_DYNAMIC) != 0)
    return 1;

@


1.237
log
@	* elf64-ppc.c (ppc64_elf_tls_optimize): Only optimize
	R_PPC64_TPREL64 and R_PPC64_DTPMOD64 relocs when they are in
	the .toc and referenced by a TLS code sequence.
	(ppc64_elf_edit_toc): Cater for the unlikely situation that
	.toc is the first section in a file.
@
text
@a11104 1
  bfd *dynobj;
a11109 1
  dynobj = htab->elf.dynobj;
@


1.236
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d6702 2
d6705 8
a6712 1
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
d6717 1
d6746 2
d6855 6
a6860 2
			    if (toc_tls != NULL)
			      expecting_tls_get_addr = retval > 1;
d6878 28
d6908 4
d6924 4
d7006 3
d7204 4
a7207 2
      /* Now check all kept sections that might reference the toc.  */
      for (sec = ibfd->sections;
a7208 1
	   /* Check the toc itself last.  */
a7209 1
		  : sec->next == toc && sec->next->next ? sec->next->next
d7211 1
@


1.235
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2553 4
a2556 2
  struct _ppc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d2558 5
a2562 4
  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;
@


1.235.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a2625 26
  /* For syms with the same value, prefer strong dynamic global function
     syms over other syms.  */
  if ((a->flags & BSF_GLOBAL) != 0 && (b->flags & BSF_GLOBAL) == 0)
    return -1;

  if ((a->flags & BSF_GLOBAL) == 0 && (b->flags & BSF_GLOBAL) != 0)
    return 1;

  if ((a->flags & BSF_FUNCTION) != 0 && (b->flags & BSF_FUNCTION) == 0)
    return -1;

  if ((a->flags & BSF_FUNCTION) == 0 && (b->flags & BSF_FUNCTION) != 0)
    return 1;

  if ((a->flags & BSF_WEAK) == 0 && (b->flags & BSF_WEAK) != 0)
    return -1;

  if ((a->flags & BSF_WEAK) != 0 && (b->flags & BSF_WEAK) == 0)
    return 1;

  if ((a->flags & BSF_DYNAMIC) != 0 && (b->flags & BSF_DYNAMIC) == 0)
    return -1;

  if ((a->flags & BSF_DYNAMIC) == 0 && (b->flags & BSF_DYNAMIC) != 0)
    return 1;

a6698 2
      asection *toc = bfd_get_section_by_name (ibfd, ".toc");
      unsigned char *toc_ref = NULL;
d6700 1
a6700 8
      /* Look at all the sections for this file, with TOC last.  */
      for (sec = (ibfd->sections == toc && toc && toc->next ? toc->next
		  : ibfd->sections);
	   sec != NULL;
	   sec = (sec == toc ? NULL
		  : sec->next == NULL ? toc
		  : sec->next == toc && toc->next ? toc->next
		  : sec->next))
a6704 1
	    long toc_ref_index = 0;
a6732 2
		    if (toc_ref != NULL)
		      free (toc_ref);
d6840 2
a6841 6
			    if (retval > 1 && toc_tls != NULL)
			      {
				expecting_tls_get_addr = 1;
				if (toc_ref != NULL)
				  toc_ref[toc_ref_index] = 1;
			      }
a6858 28
		  case R_PPC64_TOC16:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TLS:
		    expecting_tls_get_addr = 0;
		    if (sym_sec == toc && toc != NULL)
		      {
			/* Mark this toc entry as referenced by a TLS
			   code sequence.  We can do that now in the
			   case of R_PPC64_TLS, and after checking for
			   tls_get_addr for the TOC16 relocs.  */
			if (toc_ref == NULL)
			  {
			    toc_ref = bfd_zmalloc (toc->size / 8);
			    if (toc_ref == NULL)
			      goto err_free_rel;
			  }
			if (h != NULL)
			  value = h->root.u.def.value;
			else
			  value = sym->st_value;
			value += rel->r_addend;
			BFD_ASSERT (value < toc->size && value % 8 == 0);
			toc_ref_index = value / 8;
			if (r_type == R_PPC64_TLS)
			  toc_ref[toc_ref_index] = 1;
		      }
		    continue;

a6860 4
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
a6872 4
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
a6950 3
      if (toc_ref != NULL)
	free (toc_ref);

d7146 2
a7147 4
      /* Now check all kept sections that might reference the toc.
	 Check the toc itself last.  */
      for (sec = (ibfd->sections == toc && toc->next ? toc->next
		  : ibfd->sections);
d7149 1
d7151 1
a7152 1
		  : sec->next == toc && toc->next ? toc->next
@


1.235.6.1
log
@	* elf64-ppc.c (ppc64_elf_tls_optimize): Only optimize
	R_PPC64_TPREL64 and R_PPC64_DTPMOD64 relocs when they are in
	the .toc and referenced by a TLS code sequence.
	(ppc64_elf_edit_toc): Cater for the unlikely situation that
	.toc is the first section in a file.
@
text
@a6698 2
      asection *toc = bfd_get_section_by_name (ibfd, ".toc");
      unsigned char *toc_ref = NULL;
d6700 1
a6700 8
      /* Look at all the sections for this file, with TOC last.  */
      for (sec = (ibfd->sections == toc && toc && toc->next ? toc->next
		  : ibfd->sections);
	   sec != NULL;
	   sec = (sec == toc ? NULL
		  : sec->next == NULL ? toc
		  : sec->next == toc && toc->next ? toc->next
		  : sec->next))
a6704 1
	    long toc_ref_index = 0;
a6732 2
		    if (toc_ref != NULL)
		      free (toc_ref);
d6840 2
a6841 6
			    if (retval > 1 && toc_tls != NULL)
			      {
				expecting_tls_get_addr = 1;
				if (toc_ref != NULL)
				  toc_ref[toc_ref_index] = 1;
			      }
a6858 28
		  case R_PPC64_TOC16:
		  case R_PPC64_TOC16_LO:
		  case R_PPC64_TLS:
		    expecting_tls_get_addr = 0;
		    if (sym_sec == toc && toc != NULL)
		      {
			/* Mark this toc entry as referenced by a TLS
			   code sequence.  We can do that now in the
			   case of R_PPC64_TLS, and after checking for
			   tls_get_addr for the TOC16 relocs.  */
			if (toc_ref == NULL)
			  {
			    toc_ref = bfd_zmalloc (toc->size / 8);
			    if (toc_ref == NULL)
			      goto err_free_rel;
			  }
			if (h != NULL)
			  value = h->root.u.def.value;
			else
			  value = sym->st_value;
			value += rel->r_addend;
			BFD_ASSERT (value < toc->size && value % 8 == 0);
			toc_ref_index = value / 8;
			if (r_type == R_PPC64_TLS)
			  toc_ref[toc_ref_index] = 1;
		      }
		    continue;

a6860 4
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
a6872 4
		    if (sec != toc
			|| toc_ref == NULL
			|| !toc_ref[rel->r_offset / 8])
		      continue;
a6950 3
      if (toc_ref != NULL)
	free (toc_ref);

d7146 2
a7147 4
      /* Now check all kept sections that might reference the toc.
	 Check the toc itself last.  */
      for (sec = (ibfd->sections == toc && toc->next ? toc->next
		  : ibfd->sections);
d7149 1
d7151 1
a7152 1
		  : sec->next == toc && toc->next ? toc->next
@


1.235.6.2
log
@	* elf64-ppc.c (compare_symbols): Prefer strong dynamic global
	function syms over other syms.
@
text
@a2625 26
  /* For syms with the same value, prefer strong dynamic global function
     syms over other syms.  */
  if ((a->flags & BSF_GLOBAL) != 0 && (b->flags & BSF_GLOBAL) == 0)
    return -1;

  if ((a->flags & BSF_GLOBAL) == 0 && (b->flags & BSF_GLOBAL) != 0)
    return 1;

  if ((a->flags & BSF_FUNCTION) != 0 && (b->flags & BSF_FUNCTION) == 0)
    return -1;

  if ((a->flags & BSF_FUNCTION) == 0 && (b->flags & BSF_FUNCTION) != 0)
    return 1;

  if ((a->flags & BSF_WEAK) == 0 && (b->flags & BSF_WEAK) != 0)
    return -1;

  if ((a->flags & BSF_WEAK) != 0 && (b->flags & BSF_WEAK) == 0)
    return 1;

  if ((a->flags & BSF_DYNAMIC) != 0 && (b->flags & BSF_DYNAMIC) == 0)
    return -1;

  if ((a->flags & BSF_DYNAMIC) == 0 && (b->flags & BSF_DYNAMIC) != 0)
    return 1;

@


1.234
log
@	* elf32-ppc.c (allocate_dynrelocs): Tweak undef weak handling.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
@
text
@d3467 2
a3468 1
  if (! _bfd_elf_link_hash_table_init (&htab->elf, abfd, link_hash_newfunc))
d3475 2
a3476 1
  if (!bfd_hash_table_init (&htab->stub_hash_table, stub_hash_newfunc))
d3480 2
a3481 1
  if (!bfd_hash_table_init (&htab->branch_hash_table, branch_hash_newfunc))
@


1.233
log
@	PR ld/2218
	* elf64-ppc.c (allocate_dynrelocs): Ensure undef weak sym is
	dynamic.
	(ppc64_elf_relocate_section): Check output reloc section size.
	* elf32-ppc.c (allocate_dynrelocs): Simplify undef weak test.
@
text
@d7585 2
a7586 1
      if (h->root.type == bfd_link_hash_undefweak)
@


1.232
log
@	* elf-bfd.h (struct elf_backend_data): Add gc_mark_dynamic_ref.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Declare.
	* elflink.c (bfd_elf_gc_mark_dynamic_ref_symbol): Rename from
	elf_gc_mark_dynamic_ref_symbol.  Make global.
	(bfd_elf_gc_sections): Call bed->gc_mark_dynamic_ref.
	* elfxx-target.h (elf_backend_gc_mark_dynamic_ref): Define.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_gc_mark_dynamic_ref): Define.
	(ppc64_elf_gc_mark_dynamic_ref): New function.
@
text
@d7585 14
a7598 3
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d10771 3
@


1.231
log
@	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Don't hang forever in loop.
@
text
@d92 1
d4943 48
@


1.230
log
@	* elf64-ppc.c (ppc64_elf_action_discarded): Return 0
	for .toc1 section.
@
text
@d4961 1
a4961 1
      do
a4990 2

	  sym = sym->next;
a4991 1
      while (sym != NULL);
@


1.229
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Adjust relocs against
	opd section sym when opd has been edited.  Use correct addend
	when determining branch 'y' bit and branch overflow.  Adjust and
	save opd relocs for ld -r too.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d9497 3
@


1.228
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Force tail calls in
	shared libs to resolve locally.
@
text
@a9552 3
  if (info->relocatable)
    return TRUE;

d9574 1
a9574 1
      bfd_vma addend;
d9611 1
d9630 11
a9640 1
		relocation += adjust;
d9642 2
d9647 2
d10141 3
a10143 2
	      bfd_vma off = (relocation - sec->output_section->vma
			     - sec->output_offset + rel->r_addend);
d10159 1
a10159 1
	      && (relocation + rel->r_addend - from + max_br_offset
d10193 1
a10193 1
		  if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
d10207 1
a10207 1
		   && rel->r_addend == 0)
d10316 1
a10316 1
		  if (ent->addend == rel->r_addend
d10351 1
a10351 1
		    outrel.r_addend = rel->r_addend;
d10364 1
a10364 1
			    outrel.r_addend = rel->r_addend;
d10402 1
a10402 1
		    relocation += rel->r_addend;
d10455 1
a10455 1
		if (ent->addend == rel->r_addend
d10901 1
a10901 1
		     rel->r_addend, input_bfd, input_section, rel->r_offset)))
d10924 1
a10924 1
  if (is_opd && info->emitrelocations)
@


1.227
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): Don't consider non-ppc64 input.
@
text
@d10073 3
a10075 1
			 and link, don't require a nop.  */
d10078 1
a10078 1
		      if ((br & 1) == 0)
@


1.226
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Don't set has_14bit_branch
	on branches to same section.
@
text
@d8915 3
@


1.225
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d4510 18
a4527 1
	  htab->has_14bit_branch = 1;
@


1.224
log
@	* elf64-ppc.c (dec_dynrel_count): Don't report errors for local
	syms in gc'd sections.
	(ppc64_elf_edit_opd): Don't adjust reloc counts when NO_OPD_RELOCS.
	(elf_backend_action_discarded): Define.
	(ppc64_elf_action_discarded): New function.
@
text
@d3847 3
a3849 4
ppc64_elf_copy_indirect_symbol
  (const struct elf_backend_data *bed ATTRIBUTE_UNUSED,
   struct elf_link_hash_entry *dir,
   struct elf_link_hash_entry *ind)
d3864 1
a3864 4
	  if (eind->elf.root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d3944 1
a3944 1
  if (edir->elf.dynindx == -1)
d3946 3
a3953 2
  else
    BFD_ASSERT (eind->elf.dynindx == -1);
@


1.223
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d98 1
a6123 5
  else if (sym_sec != NULL)
    {
      void *vpp = &elf_section_data (sym_sec)->local_dynrel;
      pp = (struct ppc_dyn_relocs **) vpp;
    }
d6126 16
a6141 2
      void *vpp = &elf_section_data (sec)->local_dynrel;
      pp = (struct ppc_dyn_relocs **) vpp;
d6489 2
a6490 1
		  if (!info->relocatable
d9468 15
@


1.222
log
@	* elf64-ppc.c (ppc_type_of_stub): Check both func desc and func
	entry sym before deciding no stub is needed.
	(ppc64_elf_size_stubs): When calculating branch destination,
	don't use func desc sym for old ABI objects unless func entry
	is undefined.
@
text
@d4770 2
d4777 2
a4778 2
		  head = ((struct ppc_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
d6124 4
a6127 1
    pp = (struct ppc_dyn_relocs **) &elf_section_data (sym_sec)->local_dynrel;
d6129 4
a6132 1
    pp = (struct ppc_dyn_relocs **) &elf_section_data (sec)->local_dynrel;
d7649 1
a7649 4
	  for (p = *((struct ppc_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
@


1.221
log
@	* elf64-ppc.c (ppc_build_one_stub): Replace assertion that long
	branch offset is in range with an error.  Print full stub name on
	errors.
	(ppc_size_one_stub): Print full stub name on errors.
	(group_sections): Warn if section size exceeds group size.
	(ppc64_elf_size_stubs): Continue relaxing when stub types change.
@
text
@d7891 4
a7894 3
      if (h->oh != NULL
	  && h->oh->is_func_descriptor)
	h = h->oh;
d7896 1
a7896 1
      if (h->elf.dynindx != -1)
d7900 1
a7900 1
	  for (ent = h->elf.plt.plist; ent != NULL; ent = ent->next)
d7904 1
a7904 1
		*hash = h;
d7909 10
a7918 3
      if (!(h->elf.root.type == bfd_link_hash_defined
	    || h->elf.root.type == bfd_link_hash_defweak)
	  || h->elf.root.u.def.section->output_section == NULL)
d8962 1
d8968 9
a8976 1
		  else
a8977 1
		      sym_value = 0;
d8979 2
a8980 1
			 use the func descriptor sym instead.  */
d8995 5
a8999 16
		      else if (hash->elf.root.type == bfd_link_hash_defined
			       || hash->elf.root.type == bfd_link_hash_defweak)
			{
			  sym_value = hash->elf.root.u.def.value;
			  if (sym_sec->output_section != NULL)
			    ok_dest = TRUE;
			}
		      else if (hash->elf.root.type == bfd_link_hash_undefweak)
			;
		      else if (hash->elf.root.type == bfd_link_hash_undefined)
			;
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
@


1.220
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d8018 7
a8024 1
      BFD_ASSERT (off + (1 << 25) < (bfd_vma) (1 << 26));
d8096 1
a8096 1
				 stub_entry->root.string + 9);
d8340 1
a8340 1
				     stub_entry->root.string + 9);
d8761 4
a8764 1
	  big_sec = total >= stub_group_size;
a8865 1
      bfd_boolean stub_changed;
a8867 1
      stub_changed = FALSE;
a9115 2

		  stub_changed = TRUE;
d9133 1
a9133 4
      if (!stub_changed)
	break;

      /* OK, we've added some stubs.  Find out the new size of the
d9140 1
d9151 12
@


1.219
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): Don't call dec_dynrel_count
	when relocatable.
@
text
@d5715 7
@


1.218
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Don't use a plt stub
	when !can_plt_call.
@
text
@d6464 3
a6466 2
		  if (!dec_dynrel_count (rel->r_info, sec, info,
					 NULL, h, sym_sec))
@


1.217
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d10001 2
@


1.216
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d3198 1
a3198 1
  /* Offset within .branch_lt.  */
d3696 17
a3712 5
  /* Create .branch_lt for plt_branch stubs.  */
  flags = (SEC_ALLOC | SEC_LOAD
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->brlt = bfd_make_section_anyway_with_flags (dynobj, ".branch_lt",
						   flags);
d3717 1
a3717 1
  if (info->shared || info->emitrelocations)
d3721 11
a3731 6
      htab->relbrlt = bfd_make_section_anyway_with_flags (dynobj,
							  ".rela.branch_lt",
							  flags);
      if (!htab->relbrlt
	  || ! bfd_set_section_alignment (dynobj, htab->relbrlt, 3))
	return FALSE;
d3733 7
d3766 1
a3766 1
  got = bfd_make_section_with_flags (abfd, ".got", flags);
d3771 2
a3772 2
  relgot = bfd_make_section_with_flags (abfd, ".rela.got",
					flags | SEC_READONLY);
d7723 2
a7724 1
	       || s == htab->glink)
d7731 1
a7731 13
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	    }
	  else
d7749 9
d7762 1
a7762 2
      /* .plt is in the bss section.  We don't initialise it.  */
      if (s == htab->plt)
d9144 1
a9144 1
  /* It would be nice to strip .branch_lt from the output if the
@


1.215
log
@Fix compile time warnings from a GCC 4.0 compiler
@
text
@d103 1
a103 1
#define elf_backend_get_sec_type_attr	      ppc64_elf_get_sec_type_attr
a2526 18
static const struct bfd_elf_special_section *
ppc64_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					ppc64_elf_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

@


1.214
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d2124 2
a2125 2
			     abfd, (int) r_type);
      r_type = R_PPC64_NONE;
@


1.213
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@d2120 7
a2126 2
  BFD_ASSERT (type < (sizeof (ppc64_elf_howto_table)
		      / sizeof (ppc64_elf_howto_table[0])));
@


1.212
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d2511 1
a2511 1
static struct bfd_elf_special_section const ppc64_elf_special_sections[]=
d2525 1
a2525 1
  const struct bfd_elf_special_section const *ssect;
@


1.211
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d103 1
a103 1
#define elf_backend_special_sections	      ppc64_elf_special_sections
d2511 1
a2511 2
static struct bfd_elf_special_section const
  ppc64_special_sections_p[]=
d2514 1
a2514 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  ppc64_special_sections_s[]=
{
a2515 7
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  ppc64_special_sections_t[]=
{
d2522 2
a2523 2
static struct bfd_elf_special_section const *
  ppc64_elf_special_sections[27]=
d2525 14
a2538 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  ppc64_special_sections_p,	/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  ppc64_special_sections_s,	/* 's' */
  ppc64_special_sections_t,	/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
@


1.210
log
@	* elf64-ppc.c (ppc_stub_name): Return immediately on bfd_malloc fail.
	(ppc64_elf_edit_opd): Ignore zero size .opd.  Check bfd_alloc
	return value.
@
text
@d4368 6
a4373 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.209
log
@bfd/
	* elf64-pcc.c (ppc64_elf_gc_mark_hook): For the local sym in .opd
	case, include addend when indexing .opd section map.
	(ppc64_elf_edit_opd): Add no_opd_opt param.  Do nothing besides
	clear opd_adjust array if no_opd_opt set.  Tidy code.
	* elf64-ppc.h (ppc64_elf_edit_opd): Update prototype.
ld/
	* emultempl/ppc64elf.em (ppc_before_allocation): Always run
	ppc64_elf_edit_opd.
@
text
@d3584 7
a3590 7
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x.%s+%x",
		   input_section->id & 0xffffffff,
		   h->elf.root.root.string,
		   (int) rel->r_addend & 0xffffffff);
	}
d3596 8
a3603 8
      if (stub_name != NULL)
	{
	  sprintf (stub_name, "%08x.%x:%x+%x",
		   input_section->id & 0xffffffff,
		   sym_sec->id & 0xffffffff,
		   (int) ELF64_R_SYM (rel->r_info) & 0xffffffff,
		   (int) rel->r_addend & 0xffffffff);
	}
d6179 1
a6179 1
      if (sec == NULL)
d6189 2
@


1.208
log
@	* elf64-ppc.c (add_symbol_adjust): Set sym visibility to most
	restrictive of func code and func descr for undefined syms as well
	as defined.
@
text
@d5067 1
a5067 1
	  rsec = opd_sym_section[sym->st_value / 8];
d6158 1
d6188 1
a6188 1
	  opd_adjust = bfd_zalloc (obfd, amt);
d6193 3
a6364 2
	  wptr = sec->contents;
	  rptr = sec->contents;
a6365 1

a6371 1
	      wptr = new_contents;
d6373 2
@


1.207
log
@	* elf-bfd.h (struct elf_link_hash_table): Delete init_refcount and
	init_offset.  Add init_got_refcount, init_plt_refcount,
	init_got_offset and init_plt_offset.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust for above change.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	(_bfd_elf_link_hash_table_init): Likewise.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (GLINK_PLTRESOLVE): Now 16 insns.
	(LWZU_0_X_12, LWZ_0_4_30, LWZ_0_X_12, LWZ_11_X_11, LWZ_11_X_30,
	LWZ_12_4_12, LWZ_12_8_30, LWZ_12_X_12, SUB_11_11_30): Delete.
	(ADDIS_12_12, BCL_20_31, LWZU_0_12, LWZ_0_12, LWZ_11_11, LWZ_11_30,
	LWZ_12_12, MFLR_0, MFLR_12, MTLR_0, SUB_11_11_12): Define.
	(struct plt_entry): New.
	(ppc_elf_link_hash_table_create): Set new init_plt fields.
	(ppc_elf_copy_indirect_symbol): Handle merge of plt plist.  Don't
	use _bfd_elf_link_hash_copy_indirect.
	(update_plt_info, find_plt_ent): New functions.
	(ppc_elf_check_relocs): Handle R_PPC_PLTREL24 with non-zero addend
	and adjust for use of plt list rather than refcount.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_tls_optimize): Likewise.
	(ppc_elf_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.  Adjust R_PPC_PLTREL24 addends
	when performing a relocatable link.
	(ppc_elf_finish_dynamic_symbol): Likewise.  Write .glink stubs here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Use new
	pic resolver stub.
@
text
@d4162 1
a4162 3
  else if (fdh != NULL
	   && (fdh->elf.root.type == bfd_link_hash_defined
	       || fdh->elf.root.type == bfd_link_hash_defweak))
d4171 3
a4173 1
      if (eh->elf.root.type == bfd_link_hash_undefined)
@


1.206
log
@	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add has_dotsym.
	(ppc64_elf_add_symbol_hook): Set has_dotsym.
	(ppc64_elf_check_directives): Only process syms when has_dotsym.
	(func_desc_adjust): Hide fake function descriptors when function
	code entry is defined.
	(adjust_opd_syms): Adjust for deleted_section becoming union field.
@
text
@d3523 8
a3530 4
  htab->elf.init_refcount.refcount = 0;
  htab->elf.init_refcount.glist = NULL;
  htab->elf.init_offset.offset = 0;
  htab->elf.init_offset.glist = NULL;
@


1.205
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d2372 8
a2379 3
  /* Used during garbage collection.  We attach global symbols defined
     on removed .opd entries to this section so that the sym is removed.  */
  asection *deleted_section;
d4050 1
a4050 1
ppc64_elf_add_symbol_hook (bfd *ibfd ATTRIBUTE_UNUSED,
d4053 1
a4053 1
			   const char **name ATTRIBUTE_UNUSED,
d4061 7
d4181 1
a4181 2
ppc64_elf_check_directives (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
d4186 7
d5512 4
a5515 1
     code symbol is strong undefined, make the fake sym the same.  */
d5519 1
a5519 2
      && fdh->elf.root.type == bfd_link_hash_undefweak
      && fh->elf.root.type == bfd_link_hash_undefined)
d5521 10
a5530 2
      fdh->elf.root.type = bfd_link_hash_undefined;
      bfd_link_add_undef (&htab->elf.root, &fdh->elf.root);
d6007 1
a6007 1
	  asection *dsec = ppc64_elf_tdata (sym_sec->owner)->deleted_section;
d6013 1
a6013 1
		    ppc64_elf_tdata (sym_sec->owner)->deleted_section = dsec;
@


1.204
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Remove got_symbol_offset.
	* elfxx-target.h (elf_backend_got_symbol_offset): Delete.
	* elflink.c (_bfd_elf_create_got_section): Use zero in place of
	got_symbol_offset.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Delete ppc code.
	(elf_backend_got_symbol_offset): Don't define.
	* elf64-ppc.c (elf_backend_got_symbol_offset): Don't define.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Add got_header_size
	and got_gap.
	(ppc_elf_create_got): Tidy.
	(ppc_elf_create_dynamic_sections): Don't set SEC_IN_MEMORY for .plt.
	(ppc_elf_check_relocs): Reduce string comparisons by using elf.hgot.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relocate_section): Likewise.
	(ppc_elf_finish_dynamic_symbol): Likewise.
	(allocate_got): New function.
	(allocate_dynrelocs): Use allocate_got.
	(ppc_elf_size_dynamic_sections): Likewise.  Delay tlsld_got allocation
	so that local got can refcount it.  Set got_header_size.
	(ppc_elf_relocate_section): Use value of elf.hgot rather than hard-
	coded 4.
	(ppc_elf_finish_dynamic_sections): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	(elf_backend_got_header_size): Ditto.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update for changed got layout.
	* ld-powerpc/tlsexe32.g: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d2506 9
a2514 1
static struct bfd_elf_special_section const ppc64_elf_special_sections[]=
d2518 6
a2523 1
  { ".plt",     4,  0, SHT_NOBITS,   0 },
d2530 32
@


1.203
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@a69 1
#define elf_backend_got_symbol_offset 0
d2711 1
a2711 1
	 different values, so trim any with the same value.  */ 
d4771 1
a4771 1
      
@


1.202
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3670 2
a3671 1
  htab->sfpr = bfd_make_section_anyway (dynobj, ".sfpr");
a3672 1
      || ! bfd_set_section_flags (dynobj, htab->sfpr, flags)
d3677 2
a3678 1
  htab->glink = bfd_make_section_anyway (dynobj, ".glink");
a3679 1
      || ! bfd_set_section_flags (dynobj, htab->glink, flags)
d3686 2
a3687 1
  htab->brlt = bfd_make_section_anyway (dynobj, ".branch_lt");
a3688 1
      || ! bfd_set_section_flags (dynobj, htab->brlt, flags)
d3696 3
a3698 1
      htab->relbrlt = bfd_make_section_anyway (dynobj, ".rela.branch_lt");
a3699 1
	  || ! bfd_set_section_flags (dynobj, htab->relbrlt, flags)
d3729 1
a3729 1
  got = bfd_make_section (abfd, ".got");
a3730 1
      || !bfd_set_section_flags (abfd, got, flags)
d3734 2
a3735 1
  relgot = bfd_make_section (abfd, ".rela.got");
a3736 1
      || ! bfd_set_section_flags (abfd, relgot, flags | SEC_READONLY)
a4688 1
		      sreloc = bfd_make_section (dynobj, name);
d4692 3
a4695 1
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.201
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d22 1
a22 1
   59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.200
log
@Update the FSF address in the copyright/GPL notice
@
text
@d5542 1
a5542 1
    _bfd_strip_section_from_output (info, htab->sfpr);
d7690 1
a7690 1
	  _bfd_strip_section_from_output (info, s);
d7719 1
a7719 1
	    _bfd_strip_section_from_output (info, s);
d7731 1
a7731 1
	    _bfd_strip_section_from_output (info, s);
d8339 1
a8339 1
     _bfd_strip_section_from_output doesn't renumber the indices.  */
@


1.199
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@d22 1
a22 1
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.198
log
@	* elf64-ppc.c (dec_dynrel_count): New function split out from
	ppc64_elf_edit_toc, with additional code from ppc64_elf_edit_opd.
	(ppc64_elf_edit_toc, ppc64_elf_edit_opd): Use it.
	(ppc64_elf_tls_optimize): Likewise.
@
text
@d6189 2
a6190 1
		sym_name = bfd_elf_sym_name (ibfd, symtab_hdr, sym);
d7225 2
a7226 1
			   bfd_elf_sym_name (ibfd, symtab_hdr, sym));
d9478 1
a9478 1
	  sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym);
@


1.197
log
@	* elf64-ppc.c (ppc64_elf_edit_toc): Account for dynamic relocs
	that we no longer need.
@
text
@d5954 119
d6393 3
a6395 27
		  BFD_ASSERT (MUST_BE_DYN_RELOC (ELF64_R_TYPE (rel->r_info)));
		  if (info->shared)
		    {
		      /* We won't be needing dynamic relocs here.  */
		      struct ppc_dyn_relocs **pp;
		      struct ppc_dyn_relocs *p;

		      if (h != NULL)
			pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
		      else if (sym_sec != NULL)
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sym_sec)->local_dynrel);
		      else
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sec)->local_dynrel);
		      while ((p = *pp) != NULL)
			{
			  if (p->sec == sec)
			    {
			      p->count -= 1;
			      if (p->count == 0)
				*pp = p->next;
			      break;
			    }
			  pp = &p->next;
			}
		    }
d6766 1
a6766 1
		else if (h != NULL)
d6768 12
a6779 21
		    struct ppc_link_hash_entry * eh;
		    struct ppc_dyn_relocs **pp;
		    struct ppc_dyn_relocs *p;

		    /* Adjust dynamic relocs.  */
		    eh = (struct ppc_link_hash_entry *) h;
		    for (pp = &eh->dyn_relocs;
			 (p = *pp) != NULL;
			 pp = &p->next)
		      if (p->sec == sec)
			{
			  /* If we got rid of a DTPMOD/DTPREL reloc
			     pair then we'll lose one or two dyn
			     relocs.  */
			  if (tls_set == (TLS_EXPLICIT | TLS_GD))
			    p->count -= 1;
			  p->count -= 1;
			  if (p->count == 0)
			    *pp = p->next;
			  break;
			}
d7145 3
a7147 100
		else
		  {
		    unsigned long r_symndx;
		    enum elf_ppc64_reloc_type r_type;
		    asection *sym_sec;
		    struct elf_link_hash_entry *h;
		    Elf_Internal_Sym *sym;
		    struct ppc_dyn_relocs *p;
		    struct ppc_dyn_relocs **head;

		    /* Can this reloc be dynamic?
		       This switch, and later tests here should be kept
		       in sync with the code in check_relocs.  */
		    r_type = ELF64_R_TYPE (rel->r_info);
		    switch (r_type)
		      {
		      default:
			continue;

		      case R_PPC64_TPREL16:
		      case R_PPC64_TPREL16_LO:
		      case R_PPC64_TPREL16_HI:
		      case R_PPC64_TPREL16_HA:
		      case R_PPC64_TPREL16_DS:
		      case R_PPC64_TPREL16_LO_DS:
		      case R_PPC64_TPREL16_HIGHER:
		      case R_PPC64_TPREL16_HIGHERA:
		      case R_PPC64_TPREL16_HIGHEST:
		      case R_PPC64_TPREL16_HIGHESTA:
			if (!info->shared)
			  continue;

		      case R_PPC64_TPREL64:
		      case R_PPC64_DTPMOD64:
		      case R_PPC64_DTPREL64:
		      case R_PPC64_ADDR64:
		      case R_PPC64_REL30:
		      case R_PPC64_REL32:
		      case R_PPC64_REL64:
		      case R_PPC64_ADDR14:
		      case R_PPC64_ADDR14_BRNTAKEN:
		      case R_PPC64_ADDR14_BRTAKEN:
		      case R_PPC64_ADDR16:
		      case R_PPC64_ADDR16_DS:
		      case R_PPC64_ADDR16_HA:
		      case R_PPC64_ADDR16_HI:
		      case R_PPC64_ADDR16_HIGHER:
		      case R_PPC64_ADDR16_HIGHERA:
		      case R_PPC64_ADDR16_HIGHEST:
		      case R_PPC64_ADDR16_HIGHESTA:
		      case R_PPC64_ADDR16_LO:
		      case R_PPC64_ADDR16_LO_DS:
		      case R_PPC64_ADDR24:
		      case R_PPC64_ADDR32:
		      case R_PPC64_UADDR16:
		      case R_PPC64_UADDR32:
		      case R_PPC64_UADDR64:
		      case R_PPC64_TOC:
			break;
		      }

		    r_symndx = ELF64_R_SYM (rel->r_info);
		    if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				    r_symndx, ibfd))
		      goto error_ret;

		    if ((info->shared
			 && (MUST_BE_DYN_RELOC (r_type)
			     || (h != NULL
				 && (!info->symbolic
				     || h->root.type == bfd_link_hash_defweak
				     || !h->def_regular))))
			|| (ELIMINATE_COPY_RELOCS
			    && !info->shared
			    && h != NULL
			    && (h->root.type == bfd_link_hash_defweak
				|| !h->def_regular)))
		      ;
		    else
		      continue;

		    if (h != NULL)
		      head = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
		    else
		      {
			if (sym_sec == NULL)
			  goto error_ret;

			head = ((struct ppc_dyn_relocs **)
				&elf_section_data (sym_sec)->local_dynrel);
		      }
		    for (p = *head; p != NULL; p = p->next)
		      if (p->sec == toc)
			{
			  p->count -= 1;
			  if (!MUST_BE_DYN_RELOC (r_type))
			    p->pc_count -= 1;
			  break;
			}
		  }
@


1.196
log
@	(ppc64_elf_check_relocs): Remove unnecessary SEC_ALLOC check.
@
text
@d7059 101
@


1.195
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Return -1 on errors
	rather than 0.
@
text
@d4691 2
a4692 3
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
@


1.194
log
@	* elf64-ppc.c (update_plt_info): Don't mark new ABI call syms
	with is_func.
	(func_desc_adjust): Force dot-syms local in executables as well
	as shared libs.
@
text
@d2690 1
a2690 1
    return 0;
d2761 2
d2764 5
a2768 3
      if (! relcount
	  || ! (*slurp_relocs) (abfd, opd, static_syms, FALSE))
	goto done;
d2801 1
a2801 1
	  count = 0;
d2854 1
d2874 1
a2874 4
	{
	  count = 0;
	  goto free_contents_and_exit;
	}
@


1.194.2.1
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Return -1 on errors
	rather than 0.
@
text
@d2690 1
a2690 1
    return -1;
d2761 3
a2763 1
      if (relcount == 0)
a2765 6
      if (!(*slurp_relocs) (abfd, opd, static_syms, FALSE))
	{
	  count = -1;
	  goto done;
	}

d2797 1
a2797 1
	  count = -1;
a2849 1
	  count = -1;
d2869 4
a2872 1
	goto free_contents_and_exit;
@


1.194.2.2
log
@	(ppc64_elf_check_relocs): Remove unnecessary SEC_ALLOC check.
@
text
@d4691 3
a4693 2
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED
			       | SEC_ALLOC | SEC_LOAD);
@


1.194.2.3
log
@	Apply from mainline.
	2005-05-09  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add has_dotsym.
	(ppc64_elf_add_symbol_hook): Set has_dotsym.
	(ppc64_elf_check_directives): Only process syms when has_dotsym.
	(func_desc_adjust): Hide fake function descriptors when function
	code entry is defined.
	(adjust_opd_syms): Adjust for deleted_section becoming union field.

	2005-04-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (dec_dynrel_count): New function split out from
	ppc64_elf_edit_toc, with additional code from ppc64_elf_edit_opd.
	(ppc64_elf_edit_toc, ppc64_elf_edit_opd): Use it.
	(ppc64_elf_tls_optimize): Likewise.

	2005-04-01  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_edit_toc): Account for dynamic relocs
	that we no longer need.
@
text
@d2373 3
a2375 8
  union {
    /* Used during garbage collection.  We attach global symbols defined
       on removed .opd entries to this section so that the sym is removed.  */
    asection *deleted_section;

    /* Used when adding symbols.  */
    bfd_boolean has_dotsym;
  } u;
d2712 1
a2712 1
	 different values, so trim any with the same value.  */
d4001 1
a4001 1
ppc64_elf_add_symbol_hook (bfd *ibfd,
d4004 1
a4004 1
			   const char **name,
a4011 7

  if ((*name)[0] == '.'
      && ELF_ST_BIND (isym->st_info) == STB_GLOBAL
      && ELF_ST_TYPE (isym->st_info) < STT_SECTION
      && is_ppc64_elf_target (ibfd->xvec))
    ppc64_elf_tdata (ibfd)->u.has_dotsym = 1;

d4125 2
a4126 1
ppc64_elf_check_directives (bfd *abfd, struct bfd_link_info *info)
a4130 7
  if (!is_ppc64_elf_target (abfd->xvec))
    return TRUE;

  if (!ppc64_elf_tdata (abfd)->u.has_dotsym)
    return TRUE;
  ppc64_elf_tdata (abfd)->u.deleted_section = NULL;

d4771 1
a4771 1

d5449 1
a5449 4
     code symbol is strong undefined, make the fake sym the same.
     If the function code symbol is defined, then force the fake
     descriptor local;  We can't support overriding of symbols in a
     shared library on a fake descriptor.  */
d5453 2
a5454 1
      && fdh->elf.root.type == bfd_link_hash_undefweak)
d5456 2
a5457 10
      if (fh->elf.root.type == bfd_link_hash_undefined)
	{
	  fdh->elf.root.type = bfd_link_hash_undefined;
	  bfd_link_add_undef (&htab->elf.root, &fdh->elf.root);
	}
      else if (fh->elf.root.type == bfd_link_hash_defined
	       || fh->elf.root.type == bfd_link_hash_defweak)
	{
	  _bfd_elf_link_hash_hide_symbol (info, &fdh->elf, TRUE);
	}
d5934 1
a5934 1
	  asection *dsec = ppc64_elf_tdata (sym_sec->owner)->u.deleted_section;
d5940 1
a5940 1
		    ppc64_elf_tdata (sym_sec->owner)->u.deleted_section = dsec;
a5953 119
/* Handles decrementing dynamic reloc counts for the reloc specified by
   R_INFO in section SEC.  If LOCAL_SYMS is NULL, then H and SYM_SEC
   have already been determined.  */

static bfd_boolean
dec_dynrel_count (bfd_vma r_info,
		  asection *sec,
		  struct bfd_link_info *info,
		  Elf_Internal_Sym **local_syms,
		  struct elf_link_hash_entry *h,
		  asection *sym_sec)
{
  enum elf_ppc64_reloc_type r_type;
  struct ppc_dyn_relocs *p;
  struct ppc_dyn_relocs **pp;

  /* Can this reloc be dynamic?  This switch, and later tests here
     should be kept in sync with the code in check_relocs.  */
  r_type = ELF64_R_TYPE (r_info);
  switch (r_type)
    {
    default:
      return TRUE;

    case R_PPC64_TPREL16:
    case R_PPC64_TPREL16_LO:
    case R_PPC64_TPREL16_HI:
    case R_PPC64_TPREL16_HA:
    case R_PPC64_TPREL16_DS:
    case R_PPC64_TPREL16_LO_DS:
    case R_PPC64_TPREL16_HIGHER:
    case R_PPC64_TPREL16_HIGHERA:
    case R_PPC64_TPREL16_HIGHEST:
    case R_PPC64_TPREL16_HIGHESTA:
      if (!info->shared)
	return TRUE;

    case R_PPC64_TPREL64:
    case R_PPC64_DTPMOD64:
    case R_PPC64_DTPREL64:
    case R_PPC64_ADDR64:
    case R_PPC64_REL30:
    case R_PPC64_REL32:
    case R_PPC64_REL64:
    case R_PPC64_ADDR14:
    case R_PPC64_ADDR14_BRNTAKEN:
    case R_PPC64_ADDR14_BRTAKEN:
    case R_PPC64_ADDR16:
    case R_PPC64_ADDR16_DS:
    case R_PPC64_ADDR16_HA:
    case R_PPC64_ADDR16_HI:
    case R_PPC64_ADDR16_HIGHER:
    case R_PPC64_ADDR16_HIGHERA:
    case R_PPC64_ADDR16_HIGHEST:
    case R_PPC64_ADDR16_HIGHESTA:
    case R_PPC64_ADDR16_LO:
    case R_PPC64_ADDR16_LO_DS:
    case R_PPC64_ADDR24:
    case R_PPC64_ADDR32:
    case R_PPC64_UADDR16:
    case R_PPC64_UADDR32:
    case R_PPC64_UADDR64:
    case R_PPC64_TOC:
      break;
    }

  if (local_syms != NULL)
    {
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      bfd *ibfd = sec->owner;

      r_symndx = ELF64_R_SYM (r_info);
      if (!get_sym_h (&h, &sym, &sym_sec, NULL, local_syms, r_symndx, ibfd))
	return FALSE;
    }

  if ((info->shared
       && (MUST_BE_DYN_RELOC (r_type)
	   || (h != NULL
	       && (!info->symbolic
		   || h->root.type == bfd_link_hash_defweak
		   || !h->def_regular))))
      || (ELIMINATE_COPY_RELOCS
	  && !info->shared
	  && h != NULL
	  && (h->root.type == bfd_link_hash_defweak
	      || !h->def_regular)))
    ;
  else
    return TRUE;

  if (h != NULL)
    pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
  else if (sym_sec != NULL)
    pp = (struct ppc_dyn_relocs **) &elf_section_data (sym_sec)->local_dynrel;
  else
    pp = (struct ppc_dyn_relocs **) &elf_section_data (sec)->local_dynrel;

  while ((p = *pp) != NULL)
    {
      if (p->sec == sec)
	{
	  if (!MUST_BE_DYN_RELOC (r_type))
	    p->pc_count -= 1;
	  p->count -= 1;
	  if (p->count == 0)
	    *pp = p->next;
	  return TRUE;
	}
      pp = &p->next;
    }

  (*_bfd_error_handler) (_("dynreloc miscount for %B, section %A"),
			   sec->owner, sec);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

d6274 27
a6300 3
		  if (!dec_dynrel_count (rel->r_info, sec, info,
					 NULL, h, sym_sec))
		    goto error_ret;
d6671 1
a6671 1
		else
d6673 21
a6693 12
		    /* If we got rid of a DTPMOD/DTPREL reloc pair then
		       we'll lose one or two dyn relocs.  */
		    if (!dec_dynrel_count (rel->r_info, sec, info,
					   NULL, h, sym_sec))
		      return FALSE;

		    if (tls_set == (TLS_EXPLICIT | TLS_GD))
		      {
			if (!dec_dynrel_count ((rel + 1)->r_info, sec, info,
					       NULL, h, sym_sec))
			  return FALSE;
		      }
a7058 4
		else if (!dec_dynrel_count (rel->r_info, toc, info,
					    &local_syms, NULL, NULL))
		  goto error_ret;

@


1.194.2.4
log
@	* elf64-ppc.c (add_symbol_adjust): Set sym visibility to most
	restrictive of func code and func descr for undefined syms as well
	as defined.
@
text
@d4114 3
a4116 1
  else if (fdh != NULL)
d4125 1
a4125 3
      if ((fdh->elf.root.type == bfd_link_hash_defined
	   || fdh->elf.root.type == bfd_link_hash_defweak)
	  && eh->elf.root.type == bfd_link_hash_undefined)
@


1.194.2.5
log
@bfd/
	* elf64-pcc.c (ppc64_elf_gc_mark_hook): For the local sym in .opd
	case, include addend when indexing .opd section map.
	(ppc64_elf_edit_opd): Add no_opd_opt param.  Do nothing besides
	clear opd_adjust array if no_opd_opt set.  Tidy code.
	Ignore zero size .opd.  Check bfd_alloc return value.
	(ppc_stub_name): Return immediately on bfd_malloc fail.
	* elf64-ppc.h (ppc64_elf_edit_opd): Update prototype.
ld/
	* emultempl/ppc64elf.em (ppc_before_allocation): Always run
	ppc64_elf_edit_opd.
@
text
@d3536 7
a3542 7
      if (stub_name == NULL)
	return stub_name;

      sprintf (stub_name, "%08x.%s+%x",
	       input_section->id & 0xffffffff,
	       h->elf.root.root.string,
	       (int) rel->r_addend & 0xffffffff);
d3548 8
a3555 8
      if (stub_name == NULL)
	return stub_name;

      sprintf (stub_name, "%08x.%x:%x+%x",
	       input_section->id & 0xffffffff,
	       sym_sec->id & 0xffffffff,
	       (int) ELF64_R_SYM (rel->r_info) & 0xffffffff,
	       (int) rel->r_addend & 0xffffffff);
d5018 1
a5018 1
	  rsec = opd_sym_section[(sym->st_value + rel->r_addend) / 8];
a6108 1
		    bfd_boolean no_opd_opt,
d6129 1
a6129 1
      if (sec == NULL || sec->size == 0)
d6138 1
a6138 3
	  opd_adjust = bfd_alloc (obfd, amt);
	  if (opd_adjust == NULL)
	    return FALSE;
a6142 3
      if (no_opd_opt)
	continue;

d6311 2
d6314 1
d6321 1
a6322 2
	  wptr = new_contents;
	  rptr = sec->contents;
@


1.193
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): Override defined dot-sym
	entry points with the func descriptor as well as undefweak.
@
text
@d4216 3
a4218 1
  eh->is_func = 1;
d5491 4
a5494 6
  force_local
    = (info->shared
       && (!fh->elf.def_regular
	   || fdh == NULL
	   || !fdh->elf.def_regular
	   || fdh->elf.forced_local));
@


1.192
log
@bfd/
	* elf64-ppc.c (ppc64_elf_edit_toc): Skip toc if size is zero.
	Skip toc reloc adjust if reloc_count is zero.
ld/
	* emultempl/ppc64elf.em (ppc_create_output_section_statements): Make
	an error creating fake bfd fatal.
	(ppc_before_allocation): Continue on after errors.
	(gld${EMULATION_NAME}_finish): Likewise.
@
text
@d8789 1
a8789 2
		      if (hash->elf.root.type == bfd_link_hash_undefweak
			  && hash->elf.root.root.string[0] == '.'
@


1.191
log
@	* elf64-ppc.c (toc_adjusting_stub_needed): Return true for
	old-style branches to undefined dot-symbols which will be
	satisfied by a plt call.
@
text
@d6785 1
a6785 1
      Elf_Internal_Rela *relstart, *rel, *wrel;
d6792 1
d7037 10
a7046 4
	  /* Read toc relocs.  */
	  relstart = _bfd_elf_link_read_relocs (ibfd, toc, NULL, NULL, TRUE);
	  if (relstart == NULL)
	    goto error_ret;
d7048 15
a7062 14
	  /* Remove unused toc relocs, and adjust those we keep.  */
	  wrel = relstart;
	  for (rel = relstart; rel < relstart + toc->reloc_count; ++rel)
	    if (skip[rel->r_offset >> 3] != (unsigned long) -1)
	      {
		wrel->r_offset = rel->r_offset - skip[rel->r_offset >> 3];
		wrel->r_info = rel->r_info;
		wrel->r_addend = rel->r_addend;
		++wrel;
	      }
	  toc->reloc_count = wrel - relstart;
	  elf_section_data (toc)->rel_hdr.sh_size
	    = toc->reloc_count * elf_section_data (toc)->rel_hdr.sh_entsize;
	  BFD_ASSERT (elf_section_data (toc)->rel_hdr2 == NULL);
@


1.190
log
@	* elf64-ppc.c (move_plt_plist): New function, extracted from..
	(ppc64_elf_copy_indirect_symbol): ..here.
	(func_desc_adjust): Use move_plt_plist.
@
text
@d8364 4
a8367 1
      /* Ignore branches to undefined syms.  */
d8369 13
a8381 1
	continue;
d8383 2
a8384 3
      /* Calls to dynamic lib functions go through a plt call stub
	 that uses r2.  Assume branches to other sections not included
	 in the link need stubs too, to cover -R and absolute syms.  */
a8405 1

@


1.189
log
@	* elf64-ppc.c (add_symbol_adjust): Don't create fake descriptor
	syms when doing a relocatable link.
	(ppc64_elf_gc_mark_hook): Check that syms are defined before looking
	at u.def.section.
	(ppc64_elf_tls_setup): Likewise.
	(ppc64_elf_edit_opd): Don't use an undefined func desc sym.
@
text
@d3769 35
d3906 1
a3906 27
  if (eind->elf.plt.plist != NULL)
    {
      if (edir->elf.plt.plist != NULL)
	{
	  struct plt_entry **entp;
	  struct plt_entry *ent;

	  for (entp = &eind->elf.plt.plist; (ent = *entp) != NULL; )
	    {
	      struct plt_entry *dent;

	      for (dent = edir->elf.plt.plist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend)
		  {
		    dent->plt.refcount += ent->plt.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.plt.plist;
	}

      edir->elf.plt.plist = eind->elf.plt.plist;
      eind->elf.plt.plist = NULL;
    }
d5474 1
a5474 5
	  struct plt_entry **ep = &fdh->elf.plt.plist;
	  while (*ep != NULL)
	    ep = &(*ep)->next;
	  *ep = fh->elf.plt.plist;
	  fh->elf.plt.plist = NULL;
@


1.188
log
@	* elf64-ppc.c (struct ppc_link_hash_entry): Add "fake".
	(link_hash_newfunc): Clear all locals using memset.
	(make_fdh): Remove flags param.  Always create fake func desc
	weak.  Link the descriptor with the code entry sym.
	(ppc64_elf_archive_symbol_lookup): Don't return fake syms.
	(add_symbol_adjust): Adjust make_fdh call.
	(func_desc_adjust): Likewise.  Twiddle any pre-existing fake
	descriptor to strong undefined if code entry is strong.
@
text
@d4077 1
d4091 3
a4093 1
  else if (fdh != NULL)
d4102 1
a4102 3
      if (eh->elf.root.type == bfd_link_hash_undefined
	  && (fdh->elf.root.type == bfd_link_hash_defined
	      || fdh->elf.root.type == bfd_link_hash_defweak))
d4888 3
a4890 1
	  if (eh->is_func_descriptor)
d4936 4
a4939 1
	      if (eh->oh != NULL && eh->oh->is_func_descriptor)
d4944 3
a4946 1
	      if (eh->is_func_descriptor)
d6205 8
a6212 2
		    fdh = get_fdh ((struct ppc_link_hash_entry *) h,
				   ppc_hash_table (info));
d6396 3
a6398 1
	  && h->oh->is_func_descriptor)
@


1.187
log
@bfd/
	* elf64-ppc.c (func_desc_adjust): Move code creating func desc sym to..
	(make_fdh): ..here.  New function.  Don't set BSF_OBJECT for
	undefined syms.
	(struct add_symbol_adjust_data): New.
	(add_symbol_adjust): Make an undefweak func desc for old ABI
	objects to link with --as-needed shared libs.  Return fail status.
	Don't adjust old ABI func entry sym to weak if func desc syms
	isn't defined.
	(ppc64_elf_check_directives): Adjust call to add_symbol_adjust,
	and return status.
ld/testsuite/
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@d3211 1
d3434 3
a3436 8
      eh->stub_cache = NULL;
      eh->dyn_relocs = NULL;
      eh->oh = NULL;
      eh->is_func = 0;
      eh->is_func_descriptor = 0;
      eh->adjust_done = 0;
      eh->was_undefined = 0;
      eh->tls_mask = 0;
d3940 1
a3940 2
	  struct ppc_link_hash_entry *fh,
	  flagword flags)
d3952 1
a3952 1
  newsym->flags = flags;
d3963 5
d4005 3
a4007 1
   inclusion of a new ABI object archive that defines "bar".  */
d4019 5
a4023 1
  if (h != NULL)
d4084 1
a4084 1
      fdh = make_fdh (data->info, eh, BSF_WEAK);
d5423 1
a5423 4
      flagword flags = 0;
      if (fh->elf.root.type == bfd_link_hash_undefweak)
	flags = BSF_WEAK;
      fdh = make_fdh (info, fh, flags);
d5428 12
@


1.186
log
@include/
	* bfdlink.h (bfd_link_repair_undef_list): Declare.
bfd/
	* elf64-ppc.c (ppc64_elf_check_directives): Move undefs list fixup..
	* linker.c (bfd_link_repair_undef_list): ..to new function, but don't
	remove anything but new and undefweak.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Override any
	existing _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): Formatting.
	(bfd_elf_record_link_assignment): Call bfd_link_repair_undef_list.
	(_bfd_elf_merge_symbol): Don't handle as-needed syms here.
	(struct elf_smash_data): New.
	(elf_smash_syms): New function.
	(elf_link_add_object_symbols): Call elf_smash_syms.  Don't add
	unneeded dynamic objects to loaded list.
	(elf_link_output_extsym): Don't handle as-needed here.  Strip
	bfd_link_hash_new symbols.
	* elf32-cris.c (elf_cris_discard_excess_program_dynamics): Don't
	delref when dynindx is already -1.
	* elf64-alpha.c (elf64_alpha_output_extsym): Strip bfd_link_hash_new
	symbols.
	* elfxx-mips.c (mips_elf_output_extsym): Likewise.
ld/
	* ld.texinfo: Clarify --as-needed operation.
@
text
@d3940 31
d4043 6
d4052 1
a4052 1
  struct bfd_link_info *info;
d4066 2
a4067 2
  info = inf;
  htab = ppc_hash_table (info);
d4070 15
a4084 1
  if (fdh != NULL)
d4093 3
a4095 1
      if (eh->elf.root.type == bfd_link_hash_undefined)
d4111 1
d4117 3
a4119 1
  elf_link_hash_traverse (&htab->elf, add_symbol_adjust, info);
d4128 1
a4128 1
  return TRUE;
d5417 1
a5417 10
      bfd *abfd;
      asymbol *newsym;
      struct bfd_link_hash_entry *bh;

      abfd = fh->elf.root.u.undef.abfd;
      newsym = bfd_make_empty_symbol (abfd);
      newsym->name = fh->elf.root.root.string + 1;
      newsym->section = bfd_und_section_ptr;
      newsym->value = 0;
      newsym->flags = BSF_OBJECT;
d5419 4
a5422 13
	newsym->flags |= BSF_WEAK;

      bh = &fdh->elf.root;
      if ( !(_bfd_generic_link_add_one_symbol
	     (info, abfd, newsym->name, newsym->flags,
	      newsym->section, newsym->value, NULL, FALSE, FALSE, &bh)))
	{
	  return FALSE;
	}
      fdh = (struct ppc_link_hash_entry *) bh;
      fdh->elf.non_elf = 0;
      fdh->elf.size = 24;
      fdh->elf.type = STT_OBJECT;
@


1.185
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d4069 1
a4069 28
      struct bfd_link_hash_entry **pun;

      pun = &htab->elf.root.undefs;
      while (*pun != NULL)
	{
	  struct bfd_link_hash_entry *h = *pun;

	  if (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common)
	    {
	      *pun = h->u.undef.next;
	      h->u.undef.next = NULL;
	      if (h == htab->elf.root.undefs_tail)
		{
		  if (pun == &htab->elf.root.undefs)
		    htab->elf.root.undefs_tail = NULL;
		  else
		    /* pun points at an u.undef.next field.  Go back to
		       the start of the link_hash_entry.  */
		    htab->elf.root.undefs_tail = (struct bfd_link_hash_entry *)
		      ((char *) pun - ((char *) &h->u.undef.next - (char *) h));
		  break;
		}
	    }
	  else
	    pun = &h->u.undef.next;
	}

@


1.184
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_multi_toc and
	multi_toc_needed.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Define.
	(ppc64_elf_check_relocs): Update references to has_gp_reloc.
	(ppc64_elf_setup_section_lists): Add no_multi_toc parm, set htab bit.
	(ppc64_elf_next_toc_section): Heed no_multi_toc.
	(ppc64_elf_reinit_toc): Set multi_toc_needed.
	(toc_adjusting_stub_needed): Rewrite.
	(ppc64_elf_next_input_section): Use multi_toc_needed to shortcut
	toc tests.  Adjust for toc_adjusting_stub_needed changes.
	(ppc64_elf_size_stubs): Update references to has_gp_reloc.
	* elf64-ppc.h (ppc64_elf_setup_section_lists): Update prototype.
	* section.c: Expand comment on backend bits.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
ld/
	* emultempl/ppc64elf.em (no_multi_toc): New var.
	(gld${EMULATION_NAME}_finish): Pass to ppc64_elf_setup_section_lists.
	(OPTION_NO_MULTI_TOC): Define.
	(PARSE_AND_LIST_LONGOPTS): Add --no-multi-toc support.
	(PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
d4992 3
@


1.183
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): When determining need for
	toc adjusting stub, do not test source section flags.
@
text
@d3304 4
d3325 6
d4298 1
a4298 1
	  sec->has_gp_reloc = 1;
d4388 1
a4388 1
	  sec->has_gp_reloc = 1;
d8144 3
a8146 1
ppc64_elf_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d8155 2
a8215 2
  bfd_vma addr = isec->output_offset + isec->output_section->vma;
  bfd_vma off = addr - htab->toc_curr;
d8217 7
a8223 2
  if (off + isec->size > 0x10000)
    htab->toc_curr = addr;
d8225 4
a8228 3
  elf_gp (isec->owner) = (htab->toc_curr
			  - elf_gp (isec->output_section->owner)
			  + TOC_BASE_OFF);
d8234 1
a8234 2
ppc64_elf_reinit_toc (bfd *output_bfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
d8238 2
d8248 4
a8251 1
   load r2.  */
d8256 2
a8257 2
  bfd_byte *contents;
  bfd_size_type i;
d8259 1
a8259 1
  int branch_ok;
d8268 3
d8273 2
a8274 1
  branch_ok = strcmp (isec->name, ".fixup") == 0;
d8276 13
a8288 2
  contents = elf_section_data (isec)->this_hdr.contents;
  if (contents == NULL)
d8290 40
a8329 1
      if (!bfd_malloc_and_get_section (isec->owner, isec, &contents))
d8331 42
a8372 3
	  if (contents != NULL)
	    free (contents);
	  return -1;
a8373 3
      if (info->keep_memory)
	elf_section_data (isec)->this_hdr.contents = contents;
    }
d8375 5
a8379 13
  /* Code scan, because we don't necessarily have relocs on calls to
     static functions.  */
  ret = 0;
  for (i = 0; i < isec->size; i += 4)
    {
      unsigned long insn = bfd_get_32 (isec->owner, contents + i);
      /* Is this a branch?  */
      if ((insn & (0x3f << 26)) == (18 << 26)
	  /* If branch and link, it's a function call.  */
	  && ((insn & 1) != 0
	      /* Sibling calls use a plain branch.  I don't know a way
		 of deciding whether a branch is really a sibling call.  */
	      || !branch_ok))
d8384 44
d8430 7
a8436 2
  if (elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
a8448 1
  int ret;
d8462 1
a8462 5
  /* If a code section has a function that uses the TOC then we need
     to use the right TOC (obviously).  Also, make sure that .opd gets
     the correct TOC value for R_PPC64_TOC relocs that don't have or
     can't find their function symbol (shouldn't ever happen now).  */
  if (isec->has_gp_reloc || (isec->flags & SEC_CODE) == 0)
d8464 17
a8480 2
      if (elf_gp (isec->owner) != 0)
	htab->toc_curr = elf_gp (isec->owner);
a8481 4
  else if ((ret = toc_adjusting_stub_needed (info, isec)) < 0)
    return FALSE;
  else
    isec->has_gp_reloc = ret;
d8805 2
a8806 1
			  && code_sec->has_gp_reloc)
@


1.182
log
@	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add opd_relocs.
	(opd_entry_value): Use opd_relocs if available.
	(ppc64_elf_relocate_section): Don't set reloc_done.  Instead
	copy .opd relocations to opd_relocs.
	(ppc64_elf_edit_toc): Set rel_hdr.sh_size after editing relocs.
@
text
@d8646 1
a8646 2
			  && code_sec->has_gp_reloc
			  && section->has_gp_reloc)
@


1.181
log
@	* elf64-ppc.c (opd_entry_value): Don't use cached relocs if they
	have been adjusted for output.
	(ppc64_elf_relocate_section): Mark sections with reloc_done.
@
text
@d2383 3
d4702 1
a4702 1
  Elf_Internal_Rela *relocs, *save_relocs = NULL;
d4732 3
a4734 7
  /* If the .opd relocs have been adjusted for output, then we need to
     re-read the original relocs rather than use the cached ones.  */
  if (opd_sec->reloc_done)
    {
      save_relocs = elf_section_data (opd_sec)->relocs;
      elf_section_data (opd_sec)->relocs = NULL;
    }
d4737 1
a4737 2
  lo = relocs = _bfd_elf_link_read_relocs (opd_bfd, opd_sec, NULL, NULL,
					   !opd_sec->reloc_done);
a4807 5
  if (opd_sec->reloc_done)
    {
      elf_section_data (opd_sec)->relocs = save_relocs;
      free (relocs);
    }
d6992 3
d10439 13
a10451 2
     file rather than the input.  Let opd_entry_value know.  */
  input_section->reloc_done = info->emitrelocations;
@


1.180
log
@	* elf.c (bfd_elf_sym_name): Add symtab_hdr param.
	(group_signature): Update call.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d4699 1
d4701 1
d4729 8
d4738 2
a4739 1
  lo = _bfd_elf_link_read_relocs (opd_bfd, opd_sec, NULL, NULL, TRUE);
d4742 1
a4742 1

a4756 1
	      bfd_vma val;
d4770 1
a4770 1
			return (bfd_vma) -1;
a4804 1
	      return val;
d4809 7
a4815 1
  return (bfd_vma) -1;
d10440 5
@


1.179
log
@	* elf.c (bfd_elf_sym_name): Rename from bfd_elf_local_sym_name.
	(group_signature): Update calls.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d6009 1
a6009 1
		sym_name = bfd_elf_sym_name (ibfd, sym);
d7054 1
a7054 1
			   bfd_elf_sym_name (ibfd, sym));
d9145 1
a9145 1
	  sym_name = bfd_elf_sym_name (input_bfd, sym);
@


1.178
log
@bfd/
	* elf64-ppc.h (ppc64_elf_edit_toc): Declare.
	* elf64-ppc.c (struct ppc_link_hash_entry <adjust_done>): Update
	comment.
	(struct adjust_toc_info): New.
	(adjust_toc_syms, ppc64_elf_edit_toc): New functions.
ld/
	* emultempl/ppc64elf.em (no_tls_opt): Rename from notlsopt.
	(no_opd_opt, no_toc_opt): New static vars.
	(ppc_before_allocation): Don't edit opt if no_opd_opt.  Call
	ppc64_elf_edit_toc.
	(OPTION_NO_OPD_OPT, OPTION_NO_TOC_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS): Add no-opd-optimize and no-toc-optimize.
	(PARSE_AND_LIST_OPTIONS): Describe new options.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
@
text
@d6009 1
a6009 1
		sym_name = bfd_elf_local_sym_name (ibfd, sym);
d7054 1
a7054 1
			   bfd_elf_local_sym_name (ibfd, sym));
d9145 1
a9145 1
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
@


1.177
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d3209 3
a3211 3
  /* Whether global opd sym has been adjusted or not.
     After ppc64_elf_edit_opd has run, this flag should be set for all
     globals defined in any opd section.  */
d6648 439
@


1.176
log
@	* elf64-ppc.c (opd_entry_value): Handle --just-symbols objects.
	(ppc64_elf_edit_opd): Likewise.
@
text
@d9966 2
a9967 1
		    (info, sym_name, ppc64_elf_howto_table[r_type]->name,
@


1.175
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d4701 26
d5928 2
a5929 2
	  /* Must be a ld -r link.  ie. check_relocs hasn't been
	     called.  */
d5935 3
@


1.174
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d4066 2
a4067 2
	      *pun = h->und_next;
	      h->und_next = NULL;
d4073 1
a4073 1
		    /* pun points at an und_next field.  Go back to
d4076 1
a4076 1
		      ((char *) pun - ((char *) &h->und_next - (char *) h));
d4081 1
a4081 1
	    pun = &h->und_next;
d5501 1
a5501 1
  if (h->weakdef != NULL)
d5503 4
a5506 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d5508 1
a5508 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.173
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Add stub_globals.
	(is_ppc64_elf_target): Rename from is_ppc64_target.  Update all
	callers.
	(ppc_stub_name): Remove trailing "+0" on stub name.
	(create_linkage_sections): Create relocations for
	branch lookup table when --emit-relocs as well as when --shared.
	(ppc_build_one_stub): Emit relocs for long branch stubs.  Adjust
	relbrlt test.  For --emit-stub-syms, always output a sym even when
	one already exists on a plt call stub.  Put stub type in the stub
	symbol name.
	(ppc_size_one_stub): Size long branch stub relocs.  Adjust relbrlt
	test.
	(ppc64_elf_size_stubs): Count global sym stubs added.  Zero
	reloc_count in stub sections.  Adjust relbrlt test.
	(ppc64_elf_build_stubs): Adjust relbrlt test.  Tweak stats output.
	* elflink.c (bfd_elf_size_dynamic_sections): Fix comment typo.
	(elf_link_input_bfd): Ignore symbol index zero relocs when checking
	for relocs against discarded symbols.  Fix comments.
@
text
@a3768 1
  flagword mask;
a3811 3
  mask = (ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF
	  | ELF_LINK_HASH_NEEDS_PLT);
d3813 1
a3813 1
     of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
d3815 9
a3823 6
  if (ELIMINATE_COPY_RELOCS
      && eind->elf.root.type != bfd_link_hash_indirect
      && (edir->elf.elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    mask &= ~ELF_LINK_NON_GOT_REF;

  edir->elf.elf_link_hash_flags |= eind->elf.elf_link_hash_flags & mask;
d4157 1
a4157 1
  eh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d4553 1
a4553 1
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d4586 1
a4586 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d4591 1
a4591 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d5080 1
a5080 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d5086 1
a5086 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d5311 1
a5311 1
      fh->elf.elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
d5362 1
a5362 1
      fdh->elf.elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
d5368 1
a5368 1
      && (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
d5370 2
a5371 2
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
d5378 4
a5381 5
      fdh->elf.elf_link_hash_flags
	|= (fh->elf.elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
				      | ELF_LINK_HASH_REF_DYNAMIC
				      | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				      | ELF_LINK_NON_GOT_REF));
d5389 1
a5389 1
	  fdh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d5405 1
a5405 1
       && ((fh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
d5407 2
a5408 2
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0));
d5478 1
a5478 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d5492 1
a5492 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d5508 1
a5508 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d5521 1
a5521 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d5541 1
a5541 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d5579 1
a5579 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d5809 1
a5809 1
	   && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
d6401 1
a6401 1
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
d6680 1
a6680 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d6686 1
a6686 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d6724 1
a6724 1
	    && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d6731 1
a6731 1
	    && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
d6798 3
a6800 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d6805 1
a6805 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d7534 5
a7538 4
	  h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
				    | ELF_LINK_HASH_DEF_REGULAR
				    | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				    | ELF_LINK_FORCED_LOCAL);
d8401 5
a8405 4
	      h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR
					| ELF_LINK_HASH_REF_REGULAR_NONWEAK
					| ELF_LINK_FORCED_LOCAL);
d9321 1
a9321 2
		    || (h->elf.elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) == 0))
d9640 3
a9642 3
		  && !(h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF)
		  && (h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		  && !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d9895 1
a9895 1
	       && (h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
d10033 1
a10033 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.172
log
@	* elf64-ppc.c (is_ppc64_target): New function, extracted from..
	(ppc64_elf_check_directives): ..here.
	(ppc64_elf_size_dynamic_sections): Use it here to check bfd type
	before accessing ppc64_elf_tdata.
	(ppc64_elf_finish_dynamic_sections): And here too.
@
text
@d2403 2
d2406 1
a2406 1
is_ppc64_target (const struct bfd_target *targ)
d3295 3
d3541 2
d3681 1
a3681 1
  if (info->shared)
d4048 1
a4048 1
  if (!is_ppc64_target (htab->elf.root.creator))
d6908 1
a6908 1
      if (!is_ppc64_target (ibfd->xvec))
d7078 1
a7078 1
      if (!is_ppc64_target (ibfd->xvec))
d7262 1
a7262 1
  bfd_vma off;
d7281 3
a7283 3
      off = (stub_entry->target_value
	     + stub_entry->target_section->output_offset
	     + stub_entry->target_section->output_section->vma);
d7310 61
d7393 1
a7393 1
      if (info->shared)
d7513 1
a7513 6
  if (htab->emit_stub_syms
      && !(stub_entry->stub_type == ppc_stub_plt_call
	   && stub_entry->h->oh != NULL
	   && stub_entry->h->oh->elf.root.type == bfd_link_hash_defined
	   && stub_entry->h->oh->elf.root.u.def.section == stub_entry->stub_sec
	   && stub_entry->h->oh->elf.root.u.def.value == stub_entry->stub_offset))
d7516 17
a7532 2
      h = elf_link_hash_lookup (&htab->elf, stub_entry->root.string,
				TRUE, FALSE, FALSE);
d7635 1
a7635 1
	      if (info->shared)
d7644 5
d8235 4
d8266 4
a8269 1
	  stub_sec->size = 0;
d8272 1
a8272 1
      if (info->shared)
d8477 1
a8477 1
  if (info->shared && htab->relbrlt->size != 0)
d8514 1
a8514 1
      sprintf (*stats, _("linker stubs in %u groups\n"
d8521 1
d8620 5
d10215 1
a10215 1
      if (!is_ppc64_target (dynobj->xvec))
@


1.171
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Use static_syms passed
	in when reading relocs, not our sorted syms.  Remove unnecessary
	var.
@
text
@d2403 9
a4038 2
  extern const bfd_target bfd_elf64_powerpc_vec;
  extern const bfd_target bfd_elf64_powerpcle_vec;
d4041 1
a4041 2
  if (htab->elf.root.creator != &bfd_elf64_powerpc_vec
      && htab->elf.root.creator != &bfd_elf64_powerpcle_vec)
d6901 1
a6901 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d7071 3
d10113 2
a10114 1
     since we didn't add them to DYNOBJ.  */
d10118 4
@


1.170
log
@	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Copy input
	symbol pointer arrays before modifying.
@
text
@d2691 1
a2691 1
  qsort (syms, symcount, sizeof (asymbol *), compare_symbols);
a2743 1
      asection *relopd;
a2745 1
      relopd = opd;
d2749 1
a2749 1
	  || ! (*slurp_relocs) (abfd, relopd, syms, FALSE))
d2753 1
a2753 1
      for (i = secsymend, r = relopd->relocation; i < opdsymend; ++i)
d2757 1
a2757 1
	  while (r < relopd->relocation + relcount
d2761 1
a2761 1
	  if (r == relopd->relocation + relcount)
d2789 1
a2789 1
      for (i = secsymend, r = relopd->relocation; i < opdsymend; ++i)
d2793 1
a2793 1
	  while (r < relopd->relocation + relcount
d2797 1
a2797 1
	  if (r == relopd->relocation + relcount)
@


1.169
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Pass counts and both symbol tables.
	* elf-bfd.h (_bfd_elf_get_synthetic_symtab): Adjust.
	* elf.c (_bfd_elf_get_synthetic_symtab): Adjust.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Adjust.
	* targets.c (struct bfd_target <_bfd_get_synthetic_symtab>): Adjust.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't read symbols.
	Use both symbol tables on non-relocatable objects.  Use a common
	error exit.  Fix "mid" warning.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
binutils/
	* objdump.c (dump_bfd): Pass both symbol tables to
	bfd_get_synthetic_symtab.
@
text
@d2648 3
a2650 2
ppc64_elf_get_synthetic_symtab (bfd *abfd, long symcount, asymbol **syms,
				long dynsymcount, asymbol **dynsyms,
d2657 1
a2657 1
  long codesecsym, codesecsymend, secsymend, opdsymend;
d2660 1
a2660 1
  asymbol **sy = NULL;
d2668 1
d2670 9
d2680 3
a2682 16
      if (symcount != 0 && dynsymcount != 0)
	{
	  /* Use both symbol tables.  */
	  sy = bfd_malloc ((symcount + dynsymcount + 1) * sizeof (*syms));
	  if (sy == NULL)
	    return 0;
	  memcpy (sy, syms, symcount * sizeof (*syms));
	  memcpy (sy + symcount, dynsyms, (dynsymcount + 1) * sizeof (*syms));
	  syms = sy;
	  symcount = symcount + dynsymcount;
	}
      else if (symcount == 0)
	{
	  syms = dynsyms;
	  symcount = dynsymcount;
	}
d2684 4
a2687 3

  if (symcount == 0)
    return 0;
d2918 1
a2918 2
  if (sy != NULL)
    free (sy);
@


1.168
log
@	* elf64-ppc.c (ppc64_elf_branch_reloc): Check .opd is in a regular
	object file.
	(struct sfpr_def_parms): Save some space.
	(sfpr_define): Here too.

	* elf64-ppc.c (compare_symbols): Put section syms first.
	(sym_exists_at): New function.
	(ppc64_elf_get_synthetic_symtab): Use relocs to find code entry
	points only for relocatable files.  Use .opd section contents
	otherwise.  Generally clean up the code.
@
text
@d2648 3
a2650 1
ppc64_elf_get_synthetic_symtab (bfd *abfd, asymbol **relsyms, asymbol **ret)
d2656 1
a2656 2
  asymbol **syms = NULL;
  long symcount = 0, codesecsym, codesecsymend, secsymend, opdsymend;
d2659 1
d2667 1
a2667 1
  if ((bfd_get_file_flags (abfd) & HAS_SYMS))
d2669 1
a2669 6
      long storage;
      storage = bfd_get_symtab_upper_bound (abfd);
      if (storage < 0)
	return 0;

      if (storage)
d2671 3
a2673 2
	  syms = bfd_malloc (storage);
	  if (syms == NULL)
d2675 4
d2680 1
a2680 9

      symcount = bfd_canonicalize_symtab (abfd, syms);
      if (symcount < 0)
	{
	  free (syms);
	  return 0;
	}

      if (symcount == 0)
d2682 2
a2683 2
	  free (syms);
	  syms = NULL;
d2688 1
a2688 21
    {
      long storage;

      storage = bfd_get_dynamic_symtab_upper_bound (abfd);
      if (storage < 0)
	return 0;

      if (storage)
	{
	  syms = bfd_malloc (storage);
	  if (syms == NULL)
	    return 0;
	}

      symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);
      if (symcount < 0)
	{
	  free (syms);
	  return 0;
	}
    }
d2694 13
d2735 1
d2737 1
a2737 4
    {
      free (syms);
      return 0;
    }
a2738 1
  count = 0;
d2752 2
a2753 5
	  || ! (*slurp_relocs) (abfd, relopd, relsyms, FALSE))
	{
	  free (syms);
	  return 0;
	}
d2786 2
a2787 2
	  free (syms);
	  return 0;
d2835 5
a2839 3
	    free (contents);
	  free (syms);
	  return 0;
d2859 2
a2860 3
	  free (contents);
	  free (syms);
	  return 0;
d2872 1
a2872 1
	      long lo, hi, mid;
d2874 1
a2874 1
	      asection *sec;
d2881 1
a2881 1
		  mid = (lo + hi) >> 1;
d2887 4
a2890 1
		    break;
d2893 1
a2893 3
	      if (lo < hi)
		sec = syms[mid]->section;
	      else if (lo > codesecsym)
a2894 2
	      else
		sec = abfd->sections;
d2918 3
a2920 1
  free (syms);
@


1.167
log
@	* elf64-ppc.c (STD_R0_0R1, STD_R0_0R12, LD_R0_0R1, LD_R0_0R12,
	LI_R12_0, STVX_VR0_R12_R0, LVX_VR0_R12_R0, MTLR_R0, SFPR_MAX): Define.
	(struct sfpr_def_parms): New.
	(sfpr_define): New function.
	(savegpr0, savegpr0_tail, restgpr0, restgpr0_tail): New functions.
	(savegpr1, savegpr1_tail, restgpr1, restgpr1_tail): New functions.
	(savefpr, savefpr0_tail, restfpr, restfpr0_tail): New functions.
	(savefpr1_tail, restfpr1_tail): New functions.
	(savevr, savevr_tail, restvr, restvr_tail): New functions.
	(MIN_SAVE_FPR, MAX_SAVE_FPR): Don't define.
	(ppc64_elf_func_desc_adjust): Use sfpr_define in place of existing
	code.  Define all ABI mandated _save and _rest functions.
@
text
@d2156 2
a2157 1
  if (strcmp (symbol->section->name, ".opd") == 0)
d2553 1
a2553 1
/* Helper routine for ppc64_elf_get_synthetic_symtab.  */
d2561 2
a2562 1
  if ((a->flags & BSF_SECTION_SYM) == 0 && (b->flags & BSF_SECTION_SYM))
d2564 1
a2564 1
  if ((a->flags & BSF_SECTION_SYM) && (b->flags & BSF_SECTION_SYM) == 0)
d2567 1
d2573 1
d2604 1
a2604 1
/* Helper routine for ppc64_elf_get_synthetic_symtab.  */
d2606 2
a2607 2
static int
compare_relocs (const void *ap, const void *bp)
d2609 1
a2609 2
  const arelent *a = * (const arelent **) ap;
  const arelent *b = * (const arelent **) bp;
d2611 31
a2641 7
  if (a->address < b->address)
    return -1;

  if (a->address > b->address)
    return 1;

  return 0;
d2644 2
a2645 1
/* Create synthetic symbols.  */
d2651 2
a2652 4
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  arelent **relocs, **r;
  long count, i;
  size_t size;
d2655 2
a2656 2
  long symcount = 0, opdsymcount, relcount;
  asection *relopd, *opd;
d2720 11
a2730 10
  opdsymcount = symcount;
  for (i = 0; i < symcount; ++i)
    {
      if (syms[i]->flags & BSF_SECTION_SYM)
	{
	  if (opdsymcount == symcount)
	    opdsymcount = i;
	  symcount = i;
	  break;
	}
d2732 4
a2735 2
      if (syms[i]->section == opd)
	continue;
d2737 4
a2740 2
      if (opdsymcount == symcount)
	opdsymcount = i;
d2742 5
a2746 7
      if ((syms[i]->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	  != (SEC_CODE | SEC_ALLOC))
	{
	  symcount = i;
	  break;
	}
    }
d2748 1
a2748 1
  if (opdsymcount == 0)
d2754 2
a2755 2
  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  if (! relocatable)
d2757 5
a2761 11
      relopd = bfd_get_section_by_name (abfd, ".rela.opd");
      if (relopd == NULL)
	{
	  relopd = bfd_get_section_by_name (abfd, ".rela.dyn");
	  if (relopd == NULL)
	    {
	      free (syms);
	      return 0;
	    }
	}
      relcount = relopd->size / 24;
d2763 1
a2763 9
      if (! relcount
	  || ! (*slurp_relocs) (abfd, relopd, relsyms, TRUE))
	{
	  free (syms);
	  return 0;
	}
    }
  else
    {
a2772 1
    }
d2774 11
a2784 6
  relocs = bfd_malloc (relcount * sizeof (arelent **));
  if (relocs == NULL)
    {
      free (syms);
      return 0;
    }
d2786 2
a2787 2
  for (i = 0; i < relcount; ++i)
    relocs[i] = &relopd->relocation[i];
d2789 2
a2790 1
  qsort (relocs, relcount, sizeof (*relocs), compare_relocs);
d2792 9
a2800 6
  size = 0;
  count = 0;
  for (i = 0, r = relocs; i < opdsymcount; ++i)
    {
      long lo, hi, mid;
      asymbol *sym;
d2802 6
a2807 3
      while (r < relocs + relcount
	     && (*r)->address < syms[i]->value + opd->vma)
	++r;
d2809 1
a2809 2
      if (r == relocs + relcount)
	continue;
d2811 3
a2813 2
      if ((*r)->address != syms[i]->value + opd->vma)
	continue;
d2815 3
a2817 3
      if ((*r)->howto->type != (relocatable
				? R_PPC64_ADDR64 : R_PPC64_RELATIVE))
	continue;
d2819 2
a2820 29
      lo = opdsymcount;
      hi = symcount;
      sym = *((*r)->sym_ptr_ptr);
      if (relocatable)
	while (lo < hi)
	  {
	    mid = (lo + hi) >> 1;
	    if (syms[mid]->section->id < sym->section->id)
	      lo = mid + 1;
	    else if (syms[mid]->section->id > sym->section->id)
	      hi = mid;
	    else if (syms[mid]->value < sym->value + (*r)->addend)
	      lo = mid + 1;
	    else if (syms[mid]->value > sym->value + (*r)->addend)
	      hi = mid;
	    else
	      break;
	  }
      else
	while (lo < hi)
	  {
	    mid = (lo + hi) >> 1;
	    if (syms[mid]->value + syms[mid]->section->vma < (*r)->addend)
	      lo = mid + 1;
	    else if (syms[mid]->value + syms[mid]->section->vma > (*r)->addend)
	      hi = mid;
	    else
	      break;
	  }
d2822 2
a2823 7
      if (lo >= hi)
	{
	  ++count;
	  size += sizeof (asymbol);
	  size += strlen (syms[i]->name) + 1;
	}
    }
d2825 2
a2826 7
  s = *ret = bfd_malloc (size);
  if (s == NULL)
    {
      free (syms);
      free (relocs);
      return 0;
    }
d2828 5
a2832 1
  names = (char *) (s + count);
d2834 13
a2846 1
  for (i = 0, r = relocs; i < opdsymcount; ++i)
d2848 2
a2849 2
      long lo, hi, mid;
      asymbol *sym;
d2851 7
a2857 3
      while (r < relocs + relcount
	     && (*r)->address < syms[i]->value + opd->vma)
	++r;
d2859 4
a2862 2
      if (r == relocs + relcount)
	continue;
d2864 8
a2871 2
      if ((*r)->address != syms[i]->value + opd->vma)
	continue;
d2873 7
a2879 3
      if ((*r)->howto->type != (relocatable
				? R_PPC64_ADDR64 : R_PPC64_RELATIVE))
	continue;
d2881 1
a2881 29
      lo = opdsymcount;
      hi = symcount;
      sym = *((*r)->sym_ptr_ptr);
      if (relocatable)
	while (lo < hi)
	  {
	    mid = (lo + hi) >> 1;
	    if (syms[mid]->section->id < sym->section->id)
	      lo = mid + 1;
	    else if (syms[mid]->section->id > sym->section->id)
	      hi = mid;
	    else if (syms[mid]->value < sym->value + (*r)->addend)
	      lo = mid + 1;
	    else if (syms[mid]->value > sym->value + (*r)->addend)
	      hi = mid;
	    else
	      break;
	  }
      else
	while (lo < hi)
	  {
	    mid = (lo + hi) >> 1;
	    if (syms[mid]->value + syms[mid]->section->vma < (*r)->addend)
	      lo = mid + 1;
	    else if (syms[mid]->value + syms[mid]->section->vma > (*r)->addend)
	      hi = mid;
	    else
	      break;
	  }
d2883 1
a2883 1
      if (lo >= hi)
d2885 1
a2885 1
	  size_t len;
d2887 2
a2888 3
	  *s = *syms[i];
	  
	  if (! relocatable)
d2890 2
d2894 29
a2922 7
	      s->section = &bfd_abs_section;
	      for (sec = abfd->sections; sec; sec = sec->next)
		if ((sec->flags & (SEC_ALLOC | SEC_CODE))
		    == (SEC_ALLOC | SEC_CODE)
		    && (*r)->addend >= sec->vma
		    && (*r)->addend < sec->vma + sec->size)
		  {
d2924 8
a2931 8
		    break;
		  }
	      s->value = (*r)->addend - sec->vma;
	    }
	  else
	    {
	      s->section = sym->section;
	      s->value = sym->value + (*r)->addend;
a2932 5
	  s->name = names;
	  len = strlen (syms[i]->name);
	  memcpy (names, syms[i]->name, len + 1);
	  names += len + 1;
	  s++;
d2934 1
a2937 1
  free (relocs);
a2939 1

d5063 2
a5064 2
  const char *name;
  unsigned int lo, hi;
d5078 1
a5078 1
  char sym[20];
d6276 1
a6276 1
                      
@


1.166
log
@	* elf64-ppc.c (ppc_get_stub_entry): Change third param to a
	"struct ppc_link_hash_entry *".
	(ppc64_elf_relocate_section): Ditto for type of h.  Introduce h_elf
	to satisfy RELOC_FOR_GLOBAL_SYMBOL.
@
text
@d177 5
a181 1
/* Instructions to save and restore floating point regs.  */
d184 4
d5048 225
d5276 1
a5415 3
#define MIN_SAVE_FPR 14
#define MAX_SAVE_FPR 31

d5420 1
a5425 2
  unsigned int lowest_savef = MAX_SAVE_FPR + 2;
  unsigned int lowest_restf = MAX_SAVE_FPR + 2;
d5427 15
a5441 3
  struct elf_link_hash_entry *h;
  bfd_byte *p;
  char sym[10];
a5443 1

d5448 5
a5452 41
  /* First provide any missing ._savef* and ._restf* functions.  */
  memcpy (sym, "._savef14", 10);
  for (i = MIN_SAVE_FPR; i <= MAX_SAVE_FPR; i++)
    {
      sym[7] = i / 10 + '0';
      sym[8] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
      if (h != NULL
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  if (lowest_savef > i)
	    lowest_savef = i;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = (i - lowest_savef) * 4;
	  h->type = STT_FUNC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
	}
    }

  memcpy (sym, "._restf14", 10);
  for (i = MIN_SAVE_FPR; i <= MAX_SAVE_FPR; i++)
    {
      sym[7] = i / 10 + '0';
      sym[8] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
      if (h != NULL
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  if (lowest_restf > i)
	    lowest_restf = i;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = ((MAX_SAVE_FPR + 2 - lowest_savef) * 4
				 + (i - lowest_restf) * 4);
	  h->type = STT_FUNC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
	}
    }
a5455 3
  htab->sfpr->size = ((MAX_SAVE_FPR + 2 - lowest_savef) * 4
		      + (MAX_SAVE_FPR + 2 - lowest_restf) * 4);

d5457 1
a5457 32
    {
      _bfd_strip_section_from_output (info, htab->sfpr);
      return TRUE;
    }

  p = bfd_alloc (htab->elf.dynobj, htab->sfpr->size);
  if (p == NULL)
    return FALSE;
  htab->sfpr->contents = p;

  for (i = lowest_savef; i <= MAX_SAVE_FPR; i++)
    {
      unsigned int fpr = i << 21;
      unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
      bfd_put_32 (htab->elf.dynobj, STFD_FR0_0R1 + fpr + stackoff, p);
      p += 4;
    }
  if (lowest_savef <= MAX_SAVE_FPR)
    {
      bfd_put_32 (htab->elf.dynobj, BLR, p);
      p += 4;
    }

  for (i = lowest_restf; i <= MAX_SAVE_FPR; i++)
    {
      unsigned int fpr = i << 21;
      unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
      bfd_put_32 (htab->elf.dynobj, LFD_FR0_0R1 + fpr + stackoff, p);
      p += 4;
    }
  if (lowest_restf <= MAX_SAVE_FPR)
    bfd_put_32 (htab->elf.dynobj, BLR, p);
@


1.165
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): Support 16 byte long .opd
	entries (where fd_aux overlaps next entry's fd_func).
	Add non_overlapping argument, use it.
	(ppc64_elf_check_relocs, ppc64_elf_gc_mark_hook, adjust_opd_syms,
	ppc64_elf_size_stubs, ppc64_elf_relocate_section,
	ppc64_elf_output_symbol_hook): Use address / 8 instead of address / 24
	as indexes into opd_sym_map/opd_adjust array.
	* elf64-ppc.h (ppc64_elf_edit_opd): Adjust prototype.

	* emultempl/ppc64elf.em (non_overlapping_opd): New variable.
	(ppc_before_allocation): Pass it to ppc64_elf_edit_opd).
	(OPTION_NON_OVERLAPPING_OPD): Define.
	(PARSE_AND_LIST_OPTIONS, PARSE_AND_LIST_ARGS_CASES): Add
	--non-overlapping-opd option.
@
text
@d3539 1
a3539 1
		    struct elf_link_hash_entry *hash,
a3543 1
  struct ppc_link_hash_entry *h = (struct ppc_link_hash_entry *) hash;
d8375 3
a8377 2
      struct elf_link_hash_entry *h;
      struct elf_link_hash_entry *fdh;
d8404 1
a8404 1
      h = NULL;
d8433 1
a8433 1
				   h, sec, relocation,
d8435 2
a8436 2
	  sym_name = h->root.root.string;
	  sym_type = h->type;
d8438 1
d8450 1
a8450 1
	    tls_mask = ((struct ppc_link_hash_entry *) h)->tls_mask;
d8476 2
a8477 2
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
d8833 3
a8835 3
		&& (((fdh = &((struct ppc_link_hash_entry *) h)->oh->elf) != NULL
		     && fdh->plt.plist != NULL)
		    || (fdh = h)->plt.plist != NULL))
d8874 1
a8874 1
			   && strcmp (h->root.root.string,
d8940 2
a8941 1
	    stub_entry = ppc_get_stub_entry (input_section, sec, h, rel, htab);
d8981 1
a8981 1
		   && h->root.type == bfd_link_hash_undefweak
d9060 2
a9061 1
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
d9070 2
a9071 1
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d9073 1
a9073 1
			    && SYMBOL_REFERENCES_LOCAL (info, h)))
d9081 1
a9081 1
			indx = h->dynindx;
d9084 1
a9084 1
		    ent = h->got.glist;
d9123 2
a9124 2
			|| ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			|| h->root.type != bfd_link_hash_undefweak))
d9232 1
a9232 1
	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
d9372 2
a9373 2
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d9375 1
a9375 1
		   || !SYMBOL_CALLS_LOCAL (info, h)))
d9379 4
a9382 4
		  && h->dynindx != -1
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d9421 1
a9421 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h)
d9424 1
a9424 1
		outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d9635 1
a9635 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d9643 1
a9643 1
	     h->root.root.string);
d9664 1
a9664 1
		  && h->root.type == bfd_link_hash_undefweak
@


1.164
log
@	* elf64-ppc.c (func_desc_adjust): Give undefined dot-symbols a value
	if we can look up their function descriptor in a regular file.
@
text
@d4209 1
a4209 1
      amt = sec->size * sizeof (union opd_info) / 24;
d4516 1
a4516 1
		    opd_sym_map[rel->r_offset / 24] = s;
d4895 1
a4895 1
	  rsec = opd_sym_section[sym->st_value / 24];
d5677 1
a5677 1
      long adjust = opd_adjust[eh->elf.root.u.def.value / 24];
d5708 2
a5709 1
ppc64_elf_edit_opd (bfd *obfd, struct bfd_link_info *info)
d5713 1
d5725 2
a5726 1
      bfd_boolean need_edit;
d5732 1
a5732 1
      amt = sec->size * sizeof (long) / 24;
d5763 1
d5774 1
a5774 1
	  /* .opd contains a regular array of 24 byte entries.  We're
d5786 1
a5833 1
	  offset += 24;
d5835 36
a5870 4
	  /* Allow for the possibility of a reloc on the third word.  */
	  if (rel < relend
	      && rel->r_offset == offset - 8)
	    rel += 1;
d5873 3
a5875 1
      if (need_edit)
d5879 1
d5881 1
d5910 11
d5924 1
d5940 13
d5969 1
a5969 1
		      opd_adjust[rel->r_offset / 24] = -1;
d5984 1
a5984 1
			  fdh->elf.root.u.def.value = wptr - sec->contents;
d5994 2
a5995 1
		      opd_adjust[rel->r_offset / 24] = wptr - rptr;
d5998 7
a6004 2
			memcpy (wptr, rptr, 24);
		      wptr += 24;
d6006 2
a6007 2
		  rptr += 24;
		  offset += 24;
d6045 1
a6045 1
		  rel->r_offset += wptr - rptr;
d6052 1
a6052 1
	  sec->size = wptr - sec->contents;
d6054 6
d6083 34
d7884 1
a7884 1
			  long adjust = opd_adjust[sym_value / 24];
d8422 1
a8422 1
	      long adjust = opd_adjust[(sym->st_value + rel->r_addend) / 24];
d9718 1
a9718 1
  adjust = opd_adjust[value / 24];
@


1.163
log
@bfd/
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Only define
	if not yet defined.
	* elf64-ppc.c (bfd_elf64_get_synthetic_symtab): Define.
	(synthetic_opd, synthetic_relocatable): New variables.
	(compare_symbols, compare_relocs): New helper routines.
	(ppc64_elf_get_synthetic_symtab): New function.
	* bfd.c (bfd_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.  Return 0 if abfd is relocatable.
binutils/
	* objdump.c (dump_bfd): For relocatable objects, pass syms instead
	of dynsyms to bfd_get_synthetic_symtab.
@
text
@d5064 18
@


1.162
log
@	* elf64-ppc.c (ppc64_elf_branch_reloc): New function.
	(ppc64_elf_howto_raw): Use ppc64_elf_branch_reloc.
	(ppc64_elf_brtaken_reloc): Here too.
@
text
@d82 1
d2540 383
@


1.161
log
@	* elf64-ppc.c (add_symbol_adjust): Correct mismatched function
	symbol visibility.
	(ppc64_elf_check_directives): Check that we have the right hash
	table before proceeding.
@
text
@d38 2
d54 2
a55 1

d311 1
a311 1
	 bfd_elf_generic_reloc,	/* special_function */
d360 1
a360 1
	 bfd_elf_generic_reloc,	/* special_function */
d375 1
a375 1
	 bfd_elf_generic_reloc,	/* special_function */
d2139 22
d2196 1
a2196 1
	return bfd_reloc_continue;
d2218 3
a2220 1
  return bfd_reloc_continue;
@


1.160
log
@	* elf64-ppc.c (struct ppc64_elf_obj_tdata): Add "deleted_section".
	(adjust_opd_syms): Attach opd syms for deleted entries to one of
	the sections that will be discarded.
@
text
@d3572 4
a3575 1
   prevents the linker complaining about undefined symbols.  */
d3591 1
a3591 2
  if (h->root.type != bfd_link_hash_undefined
      || h->root.root.string[0] != '.')
d3600 13
a3612 3
      eh->elf.root.type = bfd_link_hash_undefweak;
      eh->was_undefined = 1;
      htab->twiddled_syms = 1;
d3623 2
d3627 4
@


1.159
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d2336 4
d5234 10
d5245 1
a5245 1
	  eh->elf.root.u.def.section = &bfd_abs_section;
@


1.158
log
@bfd/
	* elf64-ppc.c (struct ppc_link_hash_entry): Add was_undefined.
	(struct ppc_link_hash_table): Remove no_multi_toc, multi_toc_needed.
	Make emit_stub_syms, stub_error and has_14bit_branch bit-fields.
	Add twiddled_syms.
	(link_hash_newfunc): Init was_undefined.
	(add_symbol_adjust): Don't set undefined dot symbols to defweak;
	Use undefweak instead.
	(ppc64_elf_check_directives): Fix undefs chain.
	(ppc64_elf_next_toc_section): Remove no_multi_toc and multi_toc_needed
	references.
	(ppc64_elf_size_stubs): Adjust for add_symbol_adjust change.
	(undo_symbol_twiddle, ppc64_elf_restore_symbols): New functions.
	* elf64-ppc.h (ppc64_elf_restore_symbols): Declare.
ld/
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_finish): Call
	ppc64_elf_restore_symbols.
@
text
@d2435 1
a2435 1
	msg = _("%s: compiled for a big endian system "
d2438 1
a2438 1
	msg = _("%s: compiled for a little endian system "
d2441 1
a2441 1
      (*_bfd_error_handler) (msg, bfd_archive_filename (ibfd));
d3208 2
a3209 3
      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
			     bfd_archive_filename (section->owner),
			     stub_name);
d4177 2
a4178 2
			(_("%s: bad relocation section name `%s\'"),
			 bfd_archive_filename (abfd), name);
d5322 1
a5322 2
		(_("%s: .opd is not a regular array of opd entries"),
		 bfd_archive_filename (ibfd));
d5331 2
a5332 2
		(_("%s: unexpected reloc type %u in .opd section"),
		 bfd_archive_filename (ibfd), r_type);
d5351 2
a5352 3
		(_("%s: undefined sym `%s' in .opd section"),
		 bfd_archive_filename (ibfd),
		 sym_name);
d7913 4
a7916 4
	       ? _("%s(%s+0x%lx): %s used with TLS symbol %s")
	       : _("%s(%s+0x%lx): %s used with non-TLS symbol %s"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
d8314 1
a8314 1
			  (_("%s(%s+0x%lx): automatic multiple TOCs "
d8317 2
a8318 2
			   bfd_archive_filename (input_bfd),
			   input_section->name,
d8322 1
a8322 1
			  (_("%s(%s+0x%lx): sibling call optimization to `%s' "
d8327 2
a8328 2
			   bfd_archive_filename (input_bfd),
			   input_section->name,
d8424 2
a8425 2
	    (_("%s: unknown relocation type %d for symbol %s"),
	     bfd_archive_filename (input_bfd), (int) r_type, sym_name);
d8964 2
a8965 2
	    (_("%s: relocation %s is not supported for symbol %s."),
	     bfd_archive_filename (input_bfd),
d9043 2
a9044 2
		(_("%s: error: relocation %s not a multiple of %d"),
		 bfd_archive_filename (input_bfd),
d9062 3
a9064 3
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
d9108 3
a9110 3
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
@


1.157
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_archive_symbol_lookup.
	(_bfd_elf_archive_symbol_lookup): Declare.
	* elflink.c (_bfd_elf_archive_symbol_lookup): New function..
	(elf_link_add_archive_symbols): ..extracted from here.  Call the
	backend version.
	* elfxx-target.h (elf_backend_archive_symbol_lookup): Provide default.
	(elfNN_bed): Init new field.
	* elf64-ppc.c (elf_backend_check_directives): Define.
	(elf_backend_archive_symbol_lookup): Define.
	(struct ppc_link_hash_table): Add tls_get_add_fd.  Make tls_get_add
	a ppc_link_hash_entry pointer.
	(get_fdh): Move.
	(ppc64_elf_archive_symbol_lookup, opd_entry_value): New functions.
	(add_symbol_adjust, ppc64_elf_check_directives): New functions.
	(ppc64_elf_check_relocs, ppc64_elf_gc_mark_hook, func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_tls_setup,
	ppc64_elf_tls_optimize, allocate_dynrelocs, ppc_type_of_stub,
	ppc_build_one_stub, ppc64_elf_size_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_symbol): Handle branch relocs to function
	descriptor symbols.
@
text
@d2791 3
a2841 4
  /* Support for multiple toc sections.  */
  unsigned int no_multi_toc;
  unsigned int multi_toc_needed;

d2873 1
a2873 1
  unsigned int emit_stub_syms;
d2876 1
a2876 1
  unsigned int stub_error;
d2880 4
a2883 1
  unsigned int has_14bit_branch;
d3000 1
d3566 4
a3569 4
   new ABI object defines "bar".  This stops later archive searches from
   including an object if we already have a function descriptor
   definition.  It also prevents the linker complaining about undefined
   symbols.  */
d3576 1
d3591 2
a3592 1
  fdh = get_fdh ((struct ppc_link_hash_entry *) h, htab);
d3595 3
a3597 3
      h->root.type = bfd_link_hash_defweak;
      h->root.u.def.section = &bfd_und_section;
      h->root.u.def.value = 0;
d3599 1
d3607 3
a3609 1
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
d3611 35
d6908 2
d6911 6
a6916 13
  if (!htab->no_multi_toc)
    {
      bfd_vma addr = isec->output_offset + isec->output_section->vma;
      bfd_vma off = addr - htab->toc_curr;
      if (off + isec->size > 0x10000)
	{
	  htab->toc_curr = addr;
	  htab->multi_toc_needed = 1;
	}
      elf_gp (isec->owner) = (htab->toc_curr
			      - elf_gp (isec->output_section->owner)
			      + TOC_BASE_OFF);
    }
d7263 3
a7265 5
		      /* Recognise an old ABI func code entry sym by
			 the weird section for a defined sym, and use
			 the func descriptor sym instead.  */
		      if (hash->elf.root.type == bfd_link_hash_defweak
			  && hash->elf.root.u.def.section == &bfd_und_section
a7268 1
			  sym_sec = NULL;
d7277 2
d7329 1
d7703 28
@


1.156
log
@	* elf64-ppc.c (struct ppc_link_hash_entry): Expand adjust_done comment.
	(ppc64_elf_add_symbol_hook): Test for NULL section.
	(get_sym_h): Formatting.
	(ppc64_elf_size_stubs): Include reloc addend in value stored as
	stub target_value.
@
text
@d86 2
d2574 5
a2578 1
   definition from some other object, eg. a static library.  */
d2866 3
a2868 2
  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;
d3473 43
a3515 1
/* Hack symbols defined in .opd sections to be function type.  */
d3532 74
a3678 25
/* Find the function descriptor hash entry from the given function code
   hash entry FH.  Link the entries via their OH fields.  */
static struct ppc_link_hash_entry *
get_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
{
  struct ppc_link_hash_entry *fdh = fh->oh;

  if (fdh == NULL)
    {
      const char *fd_name = fh->elf.root.root.string + 1;

      fdh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);
      if (fdh != NULL)
	{
	  fdh->is_func_descriptor = 1;
	  fdh->oh = fh;
	  fh->is_func = 1;
	  fh->oh = fdh;
	}
    }

  return fdh;
}

d3916 1
a3916 3
	  if (h != NULL
	      && h->root.root.string[0] == '.'
	      && h->root.root.string[1] != 0)
d3923 2
a3924 1
	      if (h == htab->tls_get_addr)
d3926 2
a3927 2
	      else if ((strncmp (h->root.root.string, ".__tls_get_addr", 15)
			== 0)
d3931 9
a3939 1
		  htab->tls_get_addr = h;
a4019 7
	      && h != NULL
	      && h->root.root.string[0] == '.'
	      && h->root.root.string[1] != 0)
	    get_fdh ((struct ppc_link_hash_entry *) h, htab);

	  if (opd_sym_map != NULL
	      && h == NULL
d4023 12
a4034 1
	      asection *s;
d4036 7
a4042 6
	      s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,
					     r_symndx);
	      if (s == NULL)
		return FALSE;
	      else if (s != sec)
		opd_sym_map[rel->r_offset / 24] = s;
d4208 88
d4329 5
d4387 9
d4660 5
a4664 1
	  fdh->elf.plt.plist = fh->elf.plt.plist;
d4825 1
a4825 2
      if (!((struct ppc_link_hash_entry *) h)->is_func_descriptor
	  || ent == NULL
d5157 1
a5157 2
   code these will already have been done, but I suppose we have to
   cater for all sorts of hand written assembly.  */
d5518 1
a5518 1
      struct elf_link_hash_entry *h = htab->tls_get_addr;
d5520 3
a5522 3
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
d5525 16
d5690 2
a5691 1
			&& h == htab->tls_get_addr)
a5871 2
	    BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);

d6396 4
a6399 1
	  && h->oh->elf.dynindx != -1)
d6402 2
a6403 1
	  for (ent = h->oh->elf.plt.plist; ent != NULL; ent = ent->next)
d6407 1
a6407 1
		*hash = h->oh;
d6613 2
a6614 1
      if (stub_entry->h->oh->elf.root.type != bfd_link_hash_defined
d6667 1
d7180 1
a7180 1
		  asection *sym_sec;
d7185 1
d7190 1
d7216 1
a7218 1
		      /* It's a local symbol.  */
a7223 1
		      /* It's an external symbol.  */
d7225 20
a7244 2
		      if (hash->elf.root.type == bfd_link_hash_defined
			  || hash->elf.root.type == bfd_link_hash_defweak)
d7270 28
d7310 3
a7312 3
		      if (sym_sec != NULL
			  && sym_sec->output_section != NULL
			  && (htab->stub_group[sym_sec->id].toc_off
d7314 1
a7314 1
			  && sym_sec->has_gp_reloc
d7325 2
a7326 1
		      && &hash->elf == htab->tls_get_addr
d7374 1
a7374 1
		  stub_entry->target_section = sym_sec;
d8058 2
a8059 1
		  if (h2 == NULL || h2 != htab->tls_get_addr)
d8195 1
d8197 4
a8200 3
		&& (fdh = &((struct ppc_link_hash_entry *) h)->oh->elf) != NULL
		&& fdh->plt.plist != NULL)
	       || ((fdh = h, sec) != NULL
d8279 14
d9102 3
d9109 5
a9113 5
  if (((struct ppc_link_hash_entry *) h)->is_func_descriptor)
    {
      struct plt_entry *ent;
      Elf_Internal_Rela rela;
      bfd_byte *loc;
d9115 18
a9132 25
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.offset != (bfd_vma) -1)
	  {
	    /* This symbol has an entry in the procedure linkage
	       table.  Set it up.  */

	    if (htab->plt == NULL
		|| htab->relplt == NULL
		|| htab->glink == NULL)
	      abort ();

	    /* Create a JMP_SLOT reloc to inform the dynamic linker to
	       fill in the PLT entry.  */
	    rela.r_offset = (htab->plt->output_section->vma
			     + htab->plt->output_offset
			     + ent->plt.offset);
	    rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	    rela.r_addend = ent->addend;

	    loc = htab->relplt->contents;
	    loc += ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		    * sizeof (Elf64_External_Rela));
	    bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
	  }
    }
@


1.155
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Combine handling of
	long branch stubs with code handling plt and r2off branch stubs.
@
text
@d2780 3
a2782 1
  /* Whether global opd sym has been adjusted or not.  */
d3477 2
a3478 1
  if (strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
d4796 7
a4802 3
get_sym_h (struct elf_link_hash_entry **hp, Elf_Internal_Sym **symp,
	   asection **symsecp, char **tls_maskp, Elf_Internal_Sym **locsymsp,
	   unsigned long r_symndx, bfd *ibfd)
d6948 1
a6972 1
		  destination = 0;
d6978 1
d6983 1
a6983 3
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
d6994 1
a6994 3
			    destination = (sym_value + irela->r_addend
					   + sym_sec->output_offset
					   + sym_sec->output_section->vma);
d7007 9
@


1.154
log
@bfd/
	* elf-bfd.h (_bfd_elf_gc_mark): Declare.
	* elflink.c (elf_link_input_bfd): Formatting.
	(_bfd_elf_gc_mark): Rename from elf_gc_mark and make global.  Adjust
	all callers.
	* elf64-ppc.c (struct ppc_link_hash_entry): Remove is_entry.
	(link_hash_newfunc): Don't set it.
	(ppc64_elf_copy_indirect_symbol): Nor copy it.
	(ppc64_elf_mark_entry_syms): Delete.
	(ppc64_elf_gc_mark_hook): Mark entry syms here.  Also mark opd
	sections.  Use get_opd_info.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Delete.
ld/
	* emultempl/ppc64elf.em (ppc_after_open): Delete.
	(LDEMUL_AFTER_OPEN): Don't define.
@
text
@d7866 2
d7884 1
a7884 22
	  if (is_power4)
	    {
	      /* Set 'a' bit.  This is 0b00010 in BO field for branch
		 on CR(BI) insns (BO == 001at or 011at), and 0b01000
		 for branch on CTR insns (BO == 1a00t or 1a01t).  */
	      if ((insn & (0x14 << 21)) == (0x04 << 21))
		insn |= 0x02 << 21;
	      else if ((insn & (0x14 << 21)) == (0x10 << 21))
		insn |= 0x08 << 21;
	      else
		break;
	    }
	  else
	    {
	      from = (rel->r_offset
		      + input_section->output_offset
		      + input_section->output_section->vma);

	      /* Invert 'y' bit if not the default.  */
	      if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
		insn ^= 0x01 << 21;
	    }
d7886 3
a7888 2
	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	  break;
d7897 1
d7903 1
d7912 1
a7912 1
	      bfd_boolean can_plt_call = 0;
d7916 4
a7919 3
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
		  if (insn == NOP
		      || insn == CROR_151515 || insn == CROR_313131)
d7923 1
a7923 1
		      can_plt_call = 1;
d7933 4
a7936 3
		      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      if ((insn & 1) == 0)
			can_plt_call = 1;
d7943 1
a7943 1
		      can_plt_call = 1;
d7975 31
a8005 1
	      if (can_plt_call)
d8007 15
a8021 5
		  relocation = (stub_entry->stub_offset
				+ stub_entry->stub_sec->output_offset
				+ stub_entry->stub_sec->output_section->vma);
		  if (stub_entry->stub_type == ppc_stub_plt_call)
		    unresolved_reloc = FALSE;
d8023 2
d8030 5
a8034 4
	  if (h != NULL
	      && h->root.type == bfd_link_hash_undefweak
	      && relocation == 0
	      && rel->r_addend == 0)
a8043 1
      addend = rel->r_addend;
a8675 34

	case R_PPC64_REL14:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL14_BRTAKEN:
	  max_br_offset = 1 << 15;
	  goto branch_check;

	case R_PPC64_REL24:
	  max_br_offset = 1 << 25;

	branch_check:
	  /* If the branch is out of reach or the TOC register needs
	     adjusting, then redirect the call to the local stub for
	     this function.  */
	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);
	  if ((relocation + addend - from + max_br_offset >= 2 * max_br_offset
	       || (sec != NULL
		   && sec->output_section != NULL
		   && sec->id <= htab->top_id
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off)))
	      && (stub_entry = ppc_get_stub_entry (input_section, sec, h,
						   rel, htab)) != NULL)
	    {
	      /* Munge up the value and addend so that we call the stub
		 rather than the procedure directly.  */
	      relocation = (stub_entry->stub_offset
			    + stub_entry->stub_sec->output_offset
			    + stub_entry->stub_sec->output_section->vma);
	      addend = 0;
	    }
	  break;
@


1.153
log
@	* elf64-ppc.c (adjust_opd_syms): Fix merge error.
@
text
@a2778 1
  unsigned int is_entry:1;
a2987 1
      eh->is_entry = 0;
a3372 1
  edir->is_entry |= eind->is_entry;
a3463 21
/* Set a flag, used by ppc64_elf_gc_mark_hook, on the entry symbol and
   symbols undefined on the command-line.  */

bfd_boolean
ppc64_elf_mark_entry_syms (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  struct bfd_sym_chain *sym;

  htab = ppc_hash_table (info);
  for (sym = info->gc_sym_list; sym; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
      if (h != NULL)
	((struct ppc_link_hash_entry *) h)->is_entry = 1;
    }
  return TRUE;
}

d4100 1
a4100 1
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
d4105 43
a4147 1
  asection *rsec = NULL;
d4152 1
a4152 1
      struct ppc_link_hash_entry *fdh;
d4166 3
a4168 1
	      fdh = (struct ppc_link_hash_entry *) h;
d4172 6
a4177 2
	      if (fdh->is_func_descriptor)
		rsec = fdh->oh->elf.root.u.def.section;
d4179 3
a4181 6
	      /* Function entry syms return NULL if they are in .opd
		 and are not ._start (or others undefined on the ld
		 command line).  Thus we avoid marking all function
		 sections, as all functions are referenced in .opd.  */
	      else if ((fdh->oh != NULL && fdh->oh->is_entry)
		       || ppc64_elf_section_data (sec)->opd.func_sec == NULL)
d4199 1
a4199 1
      opd_sym_section = ppc64_elf_section_data (rsec)->opd.func_sec;
d4201 6
a4206 3
	rsec = opd_sym_section[sym->st_value / 24];
      else if (ppc64_elf_section_data (sec)->opd.func_sec != NULL)
	rsec = NULL;
@


1.152
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Remove have_undefweak.
	(func_desc_adjust): Don't set have_undefweak.
	(ppc64_elf_func_desc_adjust): Don't add an extr nop to sfpr.
	(ppc64_elf_relocate_section): NOP out calls to undefweak functions.
@
text
@a4938 1
      eh->elf.root.u.def.value += opd_adjust[eh->elf.root.u.def.value / 24];
@


1.151
log
@	* elf64-ppc.c (struct ppc_link_hash_entry): Make "oh" a
	"struct ppc_link_hash_entry *".  Adjust all references.
	(ppc64_elf_hide_symbol): Correct a comment.
@
text
@a2874 3
  /* Set if we detect a reference undefined weak symbol.  */
  unsigned int have_undefweak;

a4354 4
  if (fh->elf.root.type == bfd_link_hash_undefweak
      && (fh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR))
    htab->have_undefweak = TRUE;

d4521 2
a4522 7
      if (!htab->have_undefweak)
	{
	  _bfd_strip_section_from_output (info, htab->sfpr);
	  return TRUE;
	}

      htab->sfpr->size = 4;
d4550 2
a4551 5
  if (lowest_restf <= MAX_SAVE_FPR
      || htab->sfpr->size == 4)
    {
      bfd_put_32 (htab->elf.dynobj, BLR, p);
    }
d7976 3
d7984 2
a7985 17
	      /* Tweak calls to undefined weak functions to point at a
		 blr.  We can thus call a weak function without first
		 checking whether the function is defined.  We have a
		 blr at the end of .sfpr.  */
	      BFD_ASSERT (htab->sfpr->size != 0);
	      relocation = (htab->sfpr->size - 4
			    + htab->sfpr->output_offset
			    + htab->sfpr->output_section->vma);
	      from = (rel->r_offset
		      + input_section->output_offset
		      + input_section->output_section->vma);

	      /* But let's not be silly about it.  If the blr isn't in
		 reach, just go to the next instruction.  */
	      if (relocation - from + (1 << 25) >= (1 << 26)
		  || htab->sfpr->size == 0)
		relocation = from + 4;
@


1.150
log
@	* elf64-ppc.c (get_opd_info): New function.
	(adjust_opd_syms): Use get_opd_info.  Define removed symbols as zero.
	(ppc64_elf_edit_opd): Use get_opd_info.  Check that sym has a dot
	before calling get_fdh.  Test fdh rather than h before dereferencing
	fdh.  Mark removed symbols in opd_adjust.
	(ppc64_elf_tls_optimize): Don't bother with opd adjustment here.
	(ppc64_elf_relocate_section): Use get_opd_info, and handle removed
	opd symbols.
	(ppc64_elf_output_symbol_hook): Likewise.
@
text
@d2774 1
a2774 1
  struct elf_link_hash_entry *oh;
d3585 1
a3585 1
  struct ppc_link_hash_entry *fdh = (struct ppc_link_hash_entry *) fh->oh;
d3596 1
a3596 1
	  fdh->oh = &fh->elf;
d3598 1
a3598 1
	  fh->oh = &fdh->elf;
d4156 1
a4156 1
		rsec = fdh->oh->root.u.def.section;
d4162 1
a4162 2
	      else if ((fdh->oh != NULL
			&& ((struct ppc_link_hash_entry *) fdh->oh)->is_entry)
d4432 2
a4433 2
      fdh->oh = &fh->elf;
      fh->oh = &fdh->elf;
d4728 1
d4731 2
a4732 1
  if (((struct ppc_link_hash_entry *) h)->is_func_descriptor)
d4734 1
a4734 1
      struct elf_link_hash_entry *fh = ((struct ppc_link_hash_entry *) h)->oh;
d4748 2
a4749 2
	     dereferenced;  It's either a string in an ELF string
	     table, or allocated in an objalloc structure.  */
d4751 1
a4751 1
	  p = h->root.root.string - 1;
d4755 2
a4756 1
	  fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d4765 2
a4766 2
	      q = h->root.root.string + strlen (h->root.root.string);
	      while (q >= h->root.root.string && *q == *p)
d4768 3
a4770 2
	      if (q < h->root.root.string && *p == '.')
		fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d4774 2
a4775 2
	      ((struct ppc_link_hash_entry *) h)->oh = fh;
	      ((struct ppc_link_hash_entry *) fh)->oh = h;
d4779 1
a4779 1
	_bfd_elf_link_hash_hide_symbol (info, fh, force_local);
d6152 1
a6152 1
	  && h->oh->dynindx != -1)
d6155 1
a6155 1
	  for (ent = h->oh->plt.plist; ent != NULL; ent = ent->next)
d6159 1
a6159 1
		*hash = (struct ppc_link_hash_entry *) h->oh;
d6365 2
a6366 2
      if (stub_entry->h->oh->root.type != bfd_link_hash_defined
	  && stub_entry->h->oh->root.type != bfd_link_hash_defweak)
d6373 3
a6375 3
	  stub_entry->h->oh->root.type = bfd_link_hash_defined;
	  stub_entry->h->oh->root.u.def.section = stub_entry->stub_sec;
	  stub_entry->h->oh->root.u.def.value = stub_entry->stub_offset;
d6418 3
a6420 3
	   && stub_entry->h->oh->root.type == bfd_link_hash_defined
	   && stub_entry->h->oh->root.u.def.section == stub_entry->stub_sec
	   && stub_entry->h->oh->root.u.def.value == stub_entry->stub_offset))
d7908 1
a7908 1
		&& (fdh = ((struct ppc_link_hash_entry *) h)->oh) != NULL
@


1.149
log
@	* elf64-ppc.c: Correct "Linker stubs" comment.
@
text
@d2495 10
d4948 2
a4949 3
  if (sym_sec != NULL
      && elf_section_data (sym_sec) != NULL
      && (opd_adjust = ppc64_elf_section_data (sym_sec)->opd.adjust) != NULL)
d4952 9
d4987 1
a4987 1
      long *adjust;
d4995 2
a4996 2
      adjust = ppc64_elf_section_data (sec)->opd.adjust;
      if (adjust == NULL)
d5000 2
a5001 2
	  adjust = bfd_zalloc (obfd, amt);
	  ppc64_elf_section_data (sec)->opd.adjust = adjust;
d5003 1
a5003 1
      memset (adjust, 0, amt);
d5155 2
a5156 1
		  if (h != NULL)
d5164 1
a5164 1
		      if (h != NULL && sym_sec->owner == ibfd)
d5171 1
d5177 1
a5177 1
		      if (h != NULL)
d5196 1
a5196 1
		      adjust[rel->r_offset / 24] = wptr - rptr;
d5368 3
a5370 11
		  {
		    value = sym->st_value;

		    if (elf_section_data (sym_sec) != NULL)
		      {
			long *adjust;
			adjust = ppc64_elf_section_data (sym_sec)->opd.adjust;
			if (adjust != NULL)
			  value += adjust[value / 24];
		      }
		  }
d7470 2
d7477 2
a7478 1
	  if (elf_section_data (sec) != NULL)
d7480 5
a7484 5
	      long *opd_sym_adjust;

	      opd_sym_adjust = ppc64_elf_section_data (sec)->opd.adjust;
	      if (opd_sym_adjust != NULL)
		relocation += opd_sym_adjust[sym->st_value / 24];
d8763 1
a8763 1
  long *adjust;
d8766 5
a8770 4
  if (h != NULL
      || input_sec == NULL
      || ppc64_elf_section_data (input_sec) == NULL
      || (adjust = ppc64_elf_section_data (input_sec)->opd.adjust) == NULL)
d8777 5
a8781 1
  elfsym->st_value += adjust[value / 24];
@


1.148
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2672 4
a2675 1
   Used to call a function in a shared library.
@


1.147
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2385 1
a2385 1
  size_t offset, raw_size;
d2398 1
a2398 1
  raw_size = 384;
d2402 1
a2402 1
					  raw_size, note->descpos + offset);
d3647 1
a3647 1
      amt = sec->_raw_size * sizeof (union opd_info) / 24;
d3891 1
a3891 1
	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8 + 1;
d4511 2
a4512 2
  htab->sfpr->_raw_size = ((MAX_SAVE_FPR + 2 - lowest_savef) * 4
			   + (MAX_SAVE_FPR + 2 - lowest_restf) * 4);
d4514 1
a4514 1
  if (htab->sfpr->_raw_size == 0)
d4522 1
a4522 1
      htab->sfpr->_raw_size = 4;
d4525 1
a4525 1
  p = bfd_alloc (htab->elf.dynobj, htab->sfpr->_raw_size);
d4551 1
a4551 1
      || htab->sfpr->_raw_size == 4)
d4680 1
a4680 1
      htab->relbss->_raw_size += sizeof (Elf64_External_Rela);
d4692 1
a4692 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
d4701 1
a4701 1
  h->root.u.def.value = s->_raw_size;
d4704 1
a4704 1
  s->_raw_size += h->size;
d4973 1
a4973 1
      amt = sec->_raw_size * sizeof (long) / 24;
d5095 2
a5096 4
	      bfd_byte *loc = bfd_alloc (ibfd, sec->_raw_size);
	      if (loc == NULL
		  || !bfd_get_section_contents (ibfd, sec, loc, 0,
						sec->_raw_size))
d5098 2
d5225 1
a5225 1
	  sec->_cooked_size = wptr - sec->contents;
d5613 2
a5614 2
	    if (s->_raw_size == 0)
	      s->_raw_size += PLT_INITIAL_ENTRY_SIZE;
d5616 1
a5616 1
	    pent->plt.offset = s->_raw_size;
d5619 1
a5619 1
	    s->_raw_size += PLT_ENTRY_SIZE;
d5623 2
a5624 2
	    if (s->_raw_size == 0)
	      s->_raw_size += GLINK_CALL_STUB_SIZE;
d5626 3
a5628 3
	    if (s->_raw_size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	      s->_raw_size += 4;
	    s->_raw_size += 2*4;
d5632 1
a5632 1
	    s->_raw_size += sizeof (Elf64_External_Rela);
d5698 2
a5699 2
	gent->got.offset = s->_raw_size;
	s->_raw_size
d5706 1
a5706 1
	  ppc64_elf_tdata (gent->owner)->relgot->_raw_size
d5786 1
a5786 1
      sreloc->_raw_size += p->count * sizeof (Elf64_External_Rela);
d5846 1
a5846 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d5868 2
a5869 2
	  ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
	  s->_raw_size += 16;
d5873 1
a5873 1
	      srel->_raw_size += sizeof (Elf64_External_Rela);
d5899 1
a5899 1
		  srel->_raw_size += p->count * sizeof (Elf64_External_Rela);
d5927 2
a5928 2
			ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
			s->_raw_size += 16;
d5930 1
a5930 1
			  srel->_raw_size += sizeof (Elf64_External_Rela);
d5936 1
a5936 1
		    ent->got.offset = s->_raw_size;
d5939 1
a5939 1
			s->_raw_size += 16;
d5941 1
a5941 1
			  srel->_raw_size += 2 * sizeof (Elf64_External_Rela);
d5945 1
a5945 1
			s->_raw_size += 8;
d5947 1
a5947 1
			  srel->_raw_size += sizeof (Elf64_External_Rela);
a5967 4
      /* Reset _cooked_size since prelim layout will set it wrongly,
	 and a non-zero _cooked_size sticks.  */
      s->_cooked_size = 0;

d5980 1
a5980 1
	  if (s->_raw_size == 0)
d6008 1
a6008 1
      if (s->_raw_size == 0)
d6025 1
a6025 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d6035 1
a6035 2
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
d6039 1
a6039 1
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
d6047 1
a6047 2
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
d6051 1
a6051 1
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
d6076 1
a6076 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
d6219 1
a6219 1
  stub_entry->stub_offset = stub_entry->stub_sec->_cooked_size;
d6396 1
a6396 1
  stub_entry->stub_sec->_cooked_size += size;
d6471 1
a6471 1
      off -= (stub_entry->stub_sec->_raw_size
d6506 2
a6507 2
	      br_entry->offset = htab->brlt->_raw_size;
	      htab->brlt->_raw_size += 8;
d6510 1
a6510 1
		htab->relbrlt->_raw_size += sizeof (Elf64_External_Rela);
d6520 1
a6520 1
  stub_entry->stub_sec->_raw_size += size;
d6602 1
a6602 1
      if (off + isec->_raw_size > 0x10000)
d6643 1
a6643 1
  if (isec->_raw_size == 0)
d6653 1
a6653 5
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	return -1;
      if (! bfd_get_section_contents (isec->owner, isec, contents,
				      0, isec->_raw_size))
d6655 2
a6656 1
	  free (contents);
d6666 1
a6666 1
  for (i = 0; i < isec->_raw_size; i += 4)
d6756 1
a6756 4
	  if (tail->_cooked_size)
	    total = tail->_cooked_size;
	  else
	    total = tail->_raw_size;
d7082 3
a7084 6
	  {
	    stub_sec->_raw_size = 0;
	    stub_sec->_cooked_size = 0;
	  }
      htab->brlt->_raw_size = 0;
      htab->brlt->_cooked_size = 0;
d7086 1
a7086 4
	{
	  htab->relbrlt->_raw_size = 0;
	  htab->relbrlt->_cooked_size = 0;
	}
d7173 2
d7178 2
a7179 1
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
d7181 7
a7187 11
	bfd_size_type size;

	/* Allocate memory to hold the linker stubs.  */
	size = stub_sec->_raw_size;
	if (size != 0)
	  {
	    stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
	    if (stub_sec->contents == NULL)
	      return FALSE;
	  }
	stub_sec->_cooked_size = 0;
d7261 1
a7261 1
      while (p < htab->glink->contents + htab->glink->_raw_size)
d7280 1
a7280 1
      htab->glink->_cooked_size = p - htab->glink->contents;
d7283 1
a7283 1
  if (htab->brlt->_raw_size != 0)
d7286 1
a7286 1
					 htab->brlt->_raw_size);
d7290 1
a7290 1
  if (info->shared && htab->relbrlt->_raw_size != 0)
d7293 1
a7293 1
					    htab->relbrlt->_raw_size);
d7307 1
a7307 1
	if (stub_sec->_raw_size != stub_sec->_cooked_size)
d7312 1
a7312 1
      || htab->glink->_raw_size != htab->glink->_cooked_size)
d7901 1
a7901 1
	      if (rel->r_offset + 8 <= input_section->_cooked_size)
d7979 2
a7980 2
	      BFD_ASSERT (htab->sfpr->_raw_size != 0);
	      relocation = (htab->sfpr->_raw_size - 4
d7990 1
a7990 1
		  || htab->sfpr->_raw_size == 0)
d8883 1
a8883 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d8917 1
a8917 1
	      dyn.d_un.d_val = s->_raw_size;
d8931 1
a8931 1
	      dyn.d_un.d_val = htab->relplt->_raw_size;
d8940 1
a8940 1
	      dyn.d_un.d_val -= s->_raw_size;
d8952 1
a8952 1
	      dyn.d_un.d_ptr += s->_raw_size;
d8960 1
a8960 1
  if (htab->got != NULL && htab->got->_raw_size != 0)
d8972 1
a8972 1
  if (htab->plt != NULL && htab->plt->_raw_size != 0)
d8986 1
a8986 1
	  && s->_raw_size != 0
d8990 1
a8990 1
					s->_raw_size))
d8994 1
a8994 1
	  && s->_raw_size != 0
d8998 1
a8998 1
					s->_raw_size))
@


1.146
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d3811 1
a3811 1
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3818 1
a3818 1
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d4407 1
a4407 1
	if (! bfd_elf64_link_record_dynamic_symbol (info, &fdh->elf))
a5576 11
/* This is the condition under which ppc64_elf_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in ppc64_elf_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d5686 1
a5686 1
	    if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d5767 1
a5767 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
@


1.145
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d85 1
d3475 16
@


1.144
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d6068 1
a6068 1
  bfd_elf64_add_dynamic_entry (info, (TAG), (VAL))
@


1.143
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Ignore !SEC_ALLOC relocs.
	(ppc64_elf_gc_sweep_hook): Likewise.
	(ppc64_elf_size_dynamic_sections): Test for .plt directly.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d7484 4
a7487 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.143.6.1
log
@Merge from mainline
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
a83 1
#define elf_backend_add_symbol_hook	      ppc64_elf_add_symbol_hook
a3475 16
/* Hack symbols defined in .opd sections to be function type.  */

static bfd_boolean
ppc64_elf_add_symbol_hook (bfd *ibfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   Elf_Internal_Sym *isym,
			   const char **name ATTRIBUTE_UNUSED,
			   flagword *flags ATTRIBUTE_UNUSED,
			   asection **sec,
			   bfd_vma *value ATTRIBUTE_UNUSED)
{
  if (strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
    isym->st_info = ELF_ST_INFO (ELF_ST_BIND (isym->st_info), STT_FUNC);
  return TRUE;
}

d3793 1
a3793 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3800 1
a3800 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d4389 1
a4389 1
	if (! bfd_elf_link_record_dynamic_symbol (info, &fdh->elf))
d5559 11
d5679 1
a5679 1
	    if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5760 1
a5760 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d6067 1
a6067 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d7483 4
a7486 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.143.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
a83 1
#define elf_backend_add_symbol_hook	      ppc64_elf_add_symbol_hook
a3475 16
/* Hack symbols defined in .opd sections to be function type.  */

static bfd_boolean
ppc64_elf_add_symbol_hook (bfd *ibfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   Elf_Internal_Sym *isym,
			   const char **name ATTRIBUTE_UNUSED,
			   flagword *flags ATTRIBUTE_UNUSED,
			   asection **sec,
			   bfd_vma *value ATTRIBUTE_UNUSED)
{
  if (strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
    isym->st_info = ELF_ST_INFO (ELF_ST_BIND (isym->st_info), STT_FUNC);
  return TRUE;
}

d6067 1
a6067 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d7483 4
a7486 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.143.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d3811 1
a3811 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3818 1
a3818 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d4407 1
a4407 1
	if (! bfd_elf_link_record_dynamic_symbol (info, &fdh->elf))
d5577 11
d5697 1
a5697 1
	    if (! bfd_elf_link_record_dynamic_symbol (info, h))
d5778 1
a5778 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
@


1.143.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a37 2
static bfd_reloc_status_type ppc64_elf_branch_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d52 1
a52 2
static bfd_vma opd_entry_value
  (asection *, bfd_vma, asection **, bfd_vma *);
a78 1
#define bfd_elf64_get_synthetic_symtab	      ppc64_elf_get_synthetic_symtab
a85 2
#define elf_backend_check_directives	      ppc64_elf_check_directives
#define elf_backend_archive_symbol_lookup     ppc64_elf_archive_symbol_lookup
d171 1
a171 5
/* Instructions used by the save and restore reg functions.  */
#define STD_R0_0R1	0xf8010000	/* std   %r0,0(%r1)	*/
#define STD_R0_0R12	0xf80c0000	/* std   %r0,0(%r12)	*/
#define LD_R0_0R1	0xe8010000	/* ld    %r0,0(%r1)	*/
#define LD_R0_0R12	0xe80c0000	/* ld    %r0,0(%r12)	*/
a173 4
#define LI_R12_0	0x39800000	/* li    %r12,0		*/
#define STVX_VR0_R12_R0	0x7c0c01ce	/* stvx  %v0,%r12,%r0	*/
#define LVX_VR0_R12_R0	0x7c0c00ce	/* lvx   %v0,%r12,%r0	*/
#define MTLR_R0		0x7c0803a6	/* mtlr  %r0		*/
d306 1
a306 1
	 ppc64_elf_branch_reloc, /* special_function */
d355 1
a355 1
	 ppc64_elf_branch_reloc, /* special_function */
d370 1
a370 1
	 ppc64_elf_branch_reloc, /* special_function */
a2133 23
ppc64_elf_branch_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section,
			bfd *output_bfd, char **error_message)
{
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (strcmp (symbol->section->name, ".opd") == 0
      && (symbol->section->owner->flags & DYNAMIC) == 0)
    {
      bfd_vma dest = opd_entry_value (symbol->section,
				      symbol->value + reloc_entry->addend,
				      NULL, NULL);
      if (dest != (bfd_vma) -1)
	reloc_entry->addend = dest - (symbol->value
				      + symbol->section->output_section->vma
				      + symbol->section->output_offset);
    }
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
d2169 1
a2169 1
	goto out;
d2191 1
a2191 3
 out:
  return ppc64_elf_branch_reloc (abfd, reloc_entry, symbol, data,
				 input_section, output_bfd, error_message);
a2333 4
  /* Used during garbage collection.  We attach global symbols defined
     on removed .opd entries to this section so that the sym is removed.  */
  asection *deleted_section;

a2359 11
/* Return 1 if target is one of ours.  */

static bfd_boolean
is_ppc64_elf_target (const struct bfd_target *targ)
{
  extern const bfd_target bfd_elf64_powerpc_vec;
  extern const bfd_target bfd_elf64_powerpcle_vec;

  return targ == &bfd_elf64_powerpc_vec || targ == &bfd_elf64_powerpcle_vec;
}

d2385 1
a2385 1
  size_t offset, size;
d2398 1
a2398 1
  size = 384;
d2402 1
a2402 1
					  size, note->descpos + offset);
d2433 1
a2433 1
	msg = _("%B: compiled for a big endian system "
d2436 1
a2436 1
	msg = _("%B: compiled for a little endian system "
d2439 1
a2439 1
      (*_bfd_error_handler) (msg, ibfd);
a2494 381

static void *
get_opd_info (asection * sec)
{
  if (sec != NULL
      && ppc64_elf_section_data (sec) != NULL
      && ppc64_elf_section_data (sec)->opd.adjust != NULL)
    return ppc64_elf_section_data (sec)->opd.adjust;
  return NULL;
}

/* Parameters for the qsort hook.  */
static asection *synthetic_opd;
static bfd_boolean synthetic_relocatable;

/* qsort comparison function for ppc64_elf_get_synthetic_symtab.  */

static int
compare_symbols (const void *ap, const void *bp)
{
  const asymbol *a = * (const asymbol **) ap;
  const asymbol *b = * (const asymbol **) bp;

  /* Section symbols first.  */
  if ((a->flags & BSF_SECTION_SYM) && !(b->flags & BSF_SECTION_SYM))
    return -1;
  if (!(a->flags & BSF_SECTION_SYM) && (b->flags & BSF_SECTION_SYM))
    return 1;

  /* then .opd symbols.  */
  if (a->section == synthetic_opd && b->section != synthetic_opd)
    return -1;
  if (a->section != synthetic_opd && b->section == synthetic_opd)
    return 1;

  /* then other code symbols.  */
  if ((a->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
      == (SEC_CODE | SEC_ALLOC)
      && (b->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 != (SEC_CODE | SEC_ALLOC))
    return -1;

  if ((a->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
      != (SEC_CODE | SEC_ALLOC)
      && (b->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 == (SEC_CODE | SEC_ALLOC))
    return 1;

  if (synthetic_relocatable)
    {
      if (a->section->id < b->section->id)
	return -1;

      if (a->section->id > b->section->id)
	return 1;
    }

  if (a->value + a->section->vma < b->value + b->section->vma)
    return -1;

  if (a->value + a->section->vma > b->value + b->section->vma)
    return 1;

  return 0;
}

/* Search SYMS for a symbol of the given VALUE.  */

static asymbol *
sym_exists_at (asymbol **syms, long lo, long hi, int id, bfd_vma value)
{
  long mid;

  if (id == -1)
    {
      while (lo < hi)
	{
	  mid = (lo + hi) >> 1;
	  if (syms[mid]->value + syms[mid]->section->vma < value)
	    lo = mid + 1;
	  else if (syms[mid]->value + syms[mid]->section->vma > value)
	    hi = mid;
	  else
	    return syms[mid];
	}
    }
  else
    {
      while (lo < hi)
	{
	  mid = (lo + hi) >> 1;
	  if (syms[mid]->section->id < id)
	    lo = mid + 1;
	  else if (syms[mid]->section->id > id)
	    hi = mid;
	  else if (syms[mid]->value < value)
	    lo = mid + 1;
	  else if (syms[mid]->value > value)
	    hi = mid;
	  else
	    return syms[mid];
	}
    }
  return NULL;
}

/* Create synthetic symbols, effectively restoring "dot-symbol" function
   entry syms.  */

static long
ppc64_elf_get_synthetic_symtab (bfd *abfd,
				long static_count, asymbol **static_syms,
				long dyn_count, asymbol **dyn_syms,
				asymbol **ret)
{
  asymbol *s;
  long i;
  long count;
  char *names;
  long symcount, codesecsym, codesecsymend, secsymend, opdsymend;
  asection *opd;
  bfd_boolean relocatable = (abfd->flags & (EXEC_P | DYNAMIC)) == 0;
  asymbol **syms;

  *ret = NULL;

  opd = bfd_get_section_by_name (abfd, ".opd");
  if (opd == NULL)
    return 0;

  symcount = static_count;
  if (!relocatable)
    symcount += dyn_count;
  if (symcount == 0)
    return 0;

  syms = bfd_malloc ((symcount + 1) * sizeof (*syms));
  if (syms == NULL)
    return 0;

  if (!relocatable && static_count != 0 && dyn_count != 0)
    {
      /* Use both symbol tables.  */
      memcpy (syms, static_syms, static_count * sizeof (*syms));
      memcpy (syms + static_count, dyn_syms, (dyn_count + 1) * sizeof (*syms));
    }
  else if (!relocatable && static_count == 0)
    memcpy (syms, dyn_syms, (symcount + 1) * sizeof (*syms));
  else
    memcpy (syms, static_syms, (symcount + 1) * sizeof (*syms));

  synthetic_opd = opd;
  synthetic_relocatable = relocatable;
  qsort (syms, symcount, sizeof (*syms), compare_symbols);

  if (!relocatable && symcount > 1)
    {
      long j;
      /* Trim duplicate syms, since we may have merged the normal and
	 dynamic symbols.  Actually, we only care about syms that have
	 different values, so trim any with the same value.  */ 
      for (i = 1, j = 1; i < symcount; ++i)
	if (syms[i - 1]->value + syms[i - 1]->section->vma
	    != syms[i]->value + syms[i]->section->vma)
	  syms[j++] = syms[i];
      symcount = j;
    }

  i = 0;
  if (syms[i]->section == opd)
    ++i;
  codesecsym = i;

  for (; i < symcount; ++i)
    if (((syms[i]->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	 != (SEC_CODE | SEC_ALLOC))
	|| (syms[i]->flags & BSF_SECTION_SYM) == 0)
      break;
  codesecsymend = i;

  for (; i < symcount; ++i)
    if ((syms[i]->flags & BSF_SECTION_SYM) == 0)
      break;
  secsymend = i;

  for (; i < symcount; ++i)
    if (syms[i]->section != opd)
      break;
  opdsymend = i;

  for (; i < symcount; ++i)
    if ((syms[i]->section->flags & (SEC_CODE | SEC_ALLOC | SEC_THREAD_LOCAL))
	!= (SEC_CODE | SEC_ALLOC))
      break;
  symcount = i;

  count = 0;
  if (opdsymend == secsymend)
    goto done;

  if (relocatable)
    {
      bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
      arelent *r;
      size_t size;
      long relcount;

      slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
      relcount = (opd->flags & SEC_RELOC) ? opd->reloc_count : 0;

      if (! relcount
	  || ! (*slurp_relocs) (abfd, opd, static_syms, FALSE))
	goto done;

      size = 0;
      for (i = secsymend, r = opd->relocation; i < opdsymend; ++i)
	{
	  asymbol *sym;

	  while (r < opd->relocation + relcount
		 && r->address < syms[i]->value + opd->vma)
	    ++r;

	  if (r == opd->relocation + relcount)
	    break;

	  if (r->address != syms[i]->value + opd->vma)
	    continue;

	  if (r->howto->type != R_PPC64_ADDR64)
	    continue;

	  sym = *r->sym_ptr_ptr;
	  if (!sym_exists_at (syms, opdsymend, symcount,
			      sym->section->id, sym->value + r->addend))
	    {
	      ++count;
	      size += sizeof (asymbol);
	      size += strlen (syms[i]->name) + 2;
	    }
	}

      s = *ret = bfd_malloc (size);
      if (s == NULL)
	{
	  count = 0;
	  goto done;
	}

      names = (char *) (s + count);

      for (i = secsymend, r = opd->relocation; i < opdsymend; ++i)
	{
	  asymbol *sym;

	  while (r < opd->relocation + relcount
		 && r->address < syms[i]->value + opd->vma)
	    ++r;

	  if (r == opd->relocation + relcount)
	    break;

	  if (r->address != syms[i]->value + opd->vma)
	    continue;

	  if (r->howto->type != R_PPC64_ADDR64)
	    continue;

	  sym = *r->sym_ptr_ptr;
	  if (!sym_exists_at (syms, opdsymend, symcount,
			      sym->section->id, sym->value + r->addend))
	    {
	      size_t len;

	      *s = *syms[i];
	      s->section = sym->section;
	      s->value = sym->value + r->addend;
	      s->name = names;
	      *names++ = '.';
	      len = strlen (syms[i]->name);
	      memcpy (names, syms[i]->name, len + 1);
	      names += len + 1;
	      s++;
	    }
	}
    }
  else
    {
      bfd_byte *contents;
      size_t size;

      if (!bfd_malloc_and_get_section (abfd, opd, &contents))
	{
	  if (contents)
	    {
	    free_contents_and_exit:
	      free (contents);
	    }
	  goto done;
	}

      size = 0;
      for (i = secsymend; i < opdsymend; ++i)
	{
	  bfd_vma ent;

	  ent = bfd_get_64 (abfd, contents + syms[i]->value);
	  if (!sym_exists_at (syms, opdsymend, symcount, -1, ent))
	    {
	      ++count;
	      size += sizeof (asymbol);
	      size += strlen (syms[i]->name) + 2;
	    }
	}

      s = *ret = bfd_malloc (size);
      if (s == NULL)
	{
	  count = 0;
	  goto free_contents_and_exit;
	}

      names = (char *) (s + count);

      for (i = secsymend; i < opdsymend; ++i)
	{
	  bfd_vma ent;

	  ent = bfd_get_64 (abfd, contents + syms[i]->value);
	  if (!sym_exists_at (syms, opdsymend, symcount, -1, ent))
	    {
	      long lo, hi;
	      size_t len;
	      asection *sec = abfd->sections;

	      *s = *syms[i];
	      lo = codesecsym;
	      hi = codesecsymend;
	      while (lo < hi)
		{
		  long mid = (lo + hi) >> 1;
		  if (syms[mid]->section->vma < ent)
		    lo = mid + 1;
		  else if (syms[mid]->section->vma > ent)
		    hi = mid;
		  else
		    {
		      sec = syms[mid]->section;
		      break;
		    }
		}

	      if (lo >= hi && lo > codesecsym)
		sec = syms[lo - 1]->section;

	      for (; sec != NULL; sec = sec->next)
		{
		  if (sec->vma > ent)
		    break;
		  if ((sec->flags & SEC_ALLOC) == 0
		      || (sec->flags & SEC_LOAD) == 0)
		    break;
		  if ((sec->flags & SEC_CODE) != 0)
		    s->section = sec;
		}
	      s->value = ent - s->section->vma;
	      s->name = names;
	      *names++ = '.';
	      len = strlen (syms[i]->name);
	      memcpy (names, syms[i]->name, len + 1);
	      names += len + 1;
	      s++;
	    }
	}
      free (contents);
    }

 done:
  free (syms);
  return count;
}
d2562 1
a2562 5
   definition from some other object, eg. a static library.

   Update: As of August 2004, we support a new convention.  Function
   calls may use the function descriptor symbol, ie. "bl foo".  This
   behaves exactly as "bl .foo".  */
d2672 1
a2672 4
   Used to call a function in a shared library.  If it so happens that
   the plt entry referenced crosses a 64k boundary, then an extra
   "addis %r12,%r12,1" will be inserted before the load at xxx+8 or
   xxx+16 as appropriate.
d2761 1
a2761 1
  struct ppc_link_hash_entry *oh;
d2766 1
d2768 1
a2768 3
  /* Whether global opd sym has been adjusted or not.
     After ppc64_elf_edit_opd has run, this flag should be set for all
     globals defined in any opd section.  */
a2770 3
  /* Set if we twiddled this symbol to weak at some stage.  */
  unsigned int was_undefined:1;

d2819 4
d2846 2
a2847 3
  /* Shortcut to .__tls_get_addr and __tls_get_addr.  */
  struct ppc_link_hash_entry *tls_get_addr;
  struct ppc_link_hash_entry *tls_get_addr_fd;
a2851 3
  /* Number of stubs against global syms.  */
  unsigned long stub_globals;

d2853 1
a2853 1
  unsigned int emit_stub_syms:1;
d2856 1
a2856 1
  unsigned int stub_error:1;
d2860 1
a2860 1
  unsigned int has_14bit_branch:1;
d2862 2
a2863 2
  /* Temp used by ppc64_elf_check_directives.  */
  unsigned int twiddled_syms:1;
d2979 1
a2980 1
      eh->was_undefined = 0;
a3094 2
  if (stub_name[len - 2] == '+' && stub_name[len - 1] == '0')
    stub_name[len - 2] = 0;
d3104 1
a3104 1
		    struct ppc_link_hash_entry *h,
d3109 1
d3188 3
a3190 2
      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
			     section->owner, stub_name);
d3235 1
a3235 1
  if (info->shared || info->emitrelocations)
d3365 1
d3457 2
a3458 2
/* Find the function descriptor hash entry from the given function code
   hash entry FH.  Link the entries via their OH fields.  */
d3460 2
a3461 2
static struct ppc_link_hash_entry *
get_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
d3463 2
a3464 1
  struct ppc_link_hash_entry *fdh = fh->oh;
d3466 2
a3467 1
  if (fdh == NULL)
d3469 1
a3469 1
      const char *fd_name = fh->elf.root.root.string + 1;
d3471 3
a3473 9
      fdh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);
      if (fdh != NULL)
	{
	  fdh->is_func_descriptor = 1;
	  fdh->oh = fh;
	  fh->is_func = 1;
	  fh->oh = fdh;
	}
d3475 1
a3475 2

  return fdh;
d3478 1
a3478 17
/* Hacks to support old ABI code.
   When making function calls, old ABI code references function entry
   points (dot symbols), while new ABI code references the function
   descriptor symbol.  We need to make any combination of reference and
   definition work together, without breaking archive linking.

   For a defined function "foo" and an undefined call to "bar":
   An old object defines "foo" and ".foo", references ".bar" (possibly
   "bar" too).
   A new object defines "foo" and references "bar".

   A new object thus has no problem with its undefined symbols being
   satisfied by definitions in an old object.  On the other hand, the
   old object won't have ".bar" satisfied by a new object.  */

/* Fix function descriptor symbols defined in .opd sections to be
   function type.  */
d3489 1
a3489 2
  if (*sec != NULL
      && strcmp (bfd_get_section_name (ibfd, *sec), ".opd") == 0)
a3493 129
/* This function makes an old ABI object reference to ".bar" cause the
   inclusion of a new ABI object archive that defines "bar".  */

static struct elf_link_hash_entry *
ppc64_elf_archive_symbol_lookup (bfd *abfd,
				 struct bfd_link_info *info,
				 const char *name)
{
  struct elf_link_hash_entry *h;
  char *dot_name;
  size_t len;

  h = _bfd_elf_archive_symbol_lookup (abfd, info, name);
  if (h != NULL)
    return h;

  if (name[0] == '.')
    return h;

  len = strlen (name);
  dot_name = bfd_alloc (abfd, len + 2);
  if (dot_name == NULL)
    return (struct elf_link_hash_entry *) 0 - 1;
  dot_name[0] = '.';
  memcpy (dot_name + 1, name, len + 1);
  h = _bfd_elf_archive_symbol_lookup (abfd, info, dot_name);
  bfd_release (abfd, dot_name);
  return h;
}

/* This function satisfies all old ABI object references to ".bar" if a
   new ABI object defines "bar".  Well, at least, undefined dot symbols
   are made weak.  This stops later archive searches from including an
   object if we already have a function descriptor definition.  It also
   prevents the linker complaining about undefined symbols.
   We also check and correct mismatched symbol visibility here.  The
   most restrictive visibility of the function descriptor and the
   function entry symbol is used.  */

static bfd_boolean
add_symbol_adjust (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info;
  struct ppc_link_hash_table *htab;
  struct ppc_link_hash_entry *eh;
  struct ppc_link_hash_entry *fdh;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->root.root.string[0] != '.')
    return TRUE;

  info = inf;
  htab = ppc_hash_table (info);
  eh = (struct ppc_link_hash_entry *) h;
  fdh = get_fdh (eh, htab);
  if (fdh != NULL)
    {
      unsigned entry_vis = ELF_ST_VISIBILITY (eh->elf.other) - 1;
      unsigned descr_vis = ELF_ST_VISIBILITY (fdh->elf.other) - 1;
      if (entry_vis < descr_vis)
	fdh->elf.other += entry_vis - descr_vis;
      else if (entry_vis > descr_vis)
	eh->elf.other += descr_vis - entry_vis;

      if (eh->elf.root.type == bfd_link_hash_undefined)
	{
	  eh->elf.root.type = bfd_link_hash_undefweak;
	  eh->was_undefined = 1;
	  htab->twiddled_syms = 1;
	}
    }

  return TRUE;
}

static bfd_boolean
ppc64_elf_check_directives (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  htab = ppc_hash_table (info);
  if (!is_ppc64_elf_target (htab->elf.root.creator))
    return TRUE;

  elf_link_hash_traverse (&htab->elf, add_symbol_adjust, info);

  /* We need to fix the undefs list for any syms we have twiddled to
     undef_weak.  */
  if (htab->twiddled_syms)
    {
      struct bfd_link_hash_entry **pun;

      pun = &htab->elf.root.undefs;
      while (*pun != NULL)
	{
	  struct bfd_link_hash_entry *h = *pun;

	  if (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common)
	    {
	      *pun = h->und_next;
	      h->und_next = NULL;
	      if (h == htab->elf.root.undefs_tail)
		{
		  if (pun == &htab->elf.root.undefs)
		    htab->elf.root.undefs_tail = NULL;
		  else
		    /* pun points at an und_next field.  Go back to
		       the start of the link_hash_entry.  */
		    htab->elf.root.undefs_tail = (struct bfd_link_hash_entry *)
		      ((char *) pun - ((char *) &h->und_next - (char *) h));
		  break;
		}
	    }
	  else
	    pun = &h->und_next;
	}

      htab->twiddled_syms = 0;
    }
  return TRUE;
}

d3567 25
d3647 1
a3647 1
      amt = sec->size * sizeof (union opd_info) / 8;
d3829 3
a3831 1
	  if (h != NULL)
d3838 1
a3838 2
	      if (h == &htab->tls_get_addr->elf
		  || h == &htab->tls_get_addr_fd->elf)
d3840 2
a3841 2
	      else if (htab->tls_get_addr == NULL
		       && !strncmp (h->root.root.string, ".__tls_get_addr", 15)
d3845 1
a3845 9
		  htab->tls_get_addr = (struct ppc_link_hash_entry *) h;
		  sec->has_tls_reloc = 1;
		}
	      else if (htab->tls_get_addr_fd == NULL
		       && !strncmp (h->root.root.string, "__tls_get_addr", 14)
		       && (h->root.root.string[14] == 0
			   || h->root.root.string[14] == '@@'))
		{
		  htab->tls_get_addr_fd = (struct ppc_link_hash_entry *) h;
d3891 1
a3891 1
	      bfd_size_type amt = sec->size * sizeof (unsigned) / 8 + 1;
d3926 7
d3936 1
a3936 12
	      if (h != NULL)
		{
		  if (h->root.root.string[0] == '.'
		      && h->root.root.string[1] != 0
		      && get_fdh ((struct ppc_link_hash_entry *) h, htab))
		    ;
		  else
		    ((struct ppc_link_hash_entry *) h)->is_func = 1;
		}
	      else
		{
		  asection *s;
d3938 6
a3943 7
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,
						 r_symndx);
		  if (s == NULL)
		    return FALSE;
		  else if (s != sec)
		    opd_sym_map[rel->r_offset / 8] = s;
		}
d4036 2
a4037 2
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
a4108 88
/* OFFSET in OPD_SEC specifies a function descriptor.  Return the address
   of the code entry point, and its section.  */

static bfd_vma
opd_entry_value (asection *opd_sec,
		 bfd_vma offset,
		 asection **code_sec,
		 bfd_vma *code_off)
{
  bfd *opd_bfd = opd_sec->owner;
  Elf_Internal_Rela *lo, *hi, *look;

  /* Go find the opd reloc at the sym address.  */
  lo = _bfd_elf_link_read_relocs (opd_bfd, opd_sec, NULL, NULL, TRUE);
  BFD_ASSERT (lo != NULL);
  hi = lo + opd_sec->reloc_count - 1; /* ignore last reloc */

  while (lo < hi)
    {
      look = lo + (hi - lo) / 2;
      if (look->r_offset < offset)
	lo = look + 1;
      else if (look->r_offset > offset)
	hi = look;
      else
	{
	  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (opd_bfd)->symtab_hdr;
	  if (ELF64_R_TYPE (look->r_info) == R_PPC64_ADDR64
	      && ELF64_R_TYPE ((look + 1)->r_info) == R_PPC64_TOC)
	    {
	      unsigned long symndx = ELF64_R_SYM (look->r_info);
	      bfd_vma val;
	      asection *sec;

	      if (symndx < symtab_hdr->sh_info)
		{
		  Elf_Internal_Sym *sym;

		  sym = (Elf_Internal_Sym *) symtab_hdr->contents;
		  if (sym == NULL)
		    {
		      sym = bfd_elf_get_elf_syms (opd_bfd, symtab_hdr,
						  symtab_hdr->sh_info,
						  0, NULL, NULL, NULL);
		      if (sym == NULL)
			return (bfd_vma) -1;
		      symtab_hdr->contents = (bfd_byte *) sym;
		    }

		  sym += symndx;
		  val = sym->st_value;
		  sec = NULL;
		  if ((sym->st_shndx != SHN_UNDEF
		       && sym->st_shndx < SHN_LORESERVE)
		      || sym->st_shndx > SHN_HIRESERVE)
		    sec = bfd_section_from_elf_index (opd_bfd, sym->st_shndx);
		  BFD_ASSERT ((sec->flags & SEC_MERGE) == 0);
		}
	      else
		{
		  struct elf_link_hash_entry **sym_hashes;
		  struct elf_link_hash_entry *rh;

		  sym_hashes = elf_sym_hashes (opd_bfd);
		  rh = sym_hashes[symndx - symtab_hdr->sh_info];
		  while (rh->root.type == bfd_link_hash_indirect
			 || rh->root.type == bfd_link_hash_warning)
		    rh = ((struct elf_link_hash_entry *) rh->root.u.i.link);
		  BFD_ASSERT (rh->root.type == bfd_link_hash_defined
			      || rh->root.type == bfd_link_hash_defweak);
		  val = rh->root.u.def.value;
		  sec = rh->root.u.def.section;
		}
	      val += look->r_addend;
	      if (code_off != NULL)
		*code_off = val;
	      if (code_sec != NULL)
		*code_sec = sec;
	      if (sec != NULL && sec->output_section != NULL)
		val += sec->output_section->vma + sec->output_offset;
	      return val;
	    }
	  break;
	}
    }
  return (bfd_vma) -1;
}

d4114 1
a4114 1
			struct bfd_link_info *info,
d4119 1
a4119 48
  asection *rsec;

  /* First mark all our entry sym sections.  */
  if (info->gc_sym_list != NULL)
    {
      struct ppc_link_hash_table *htab = ppc_hash_table (info);
      struct bfd_sym_chain *sym = info->gc_sym_list;

      info->gc_sym_list = NULL;
      do
	{
	  struct ppc_link_hash_entry *eh;

	  eh = (struct ppc_link_hash_entry *)
	    elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
	  if (eh == NULL)
	    continue;
	  if (eh->elf.root.type != bfd_link_hash_defined
	      && eh->elf.root.type != bfd_link_hash_defweak)
	    continue;

	  if (eh->is_func_descriptor)
	    rsec = eh->oh->elf.root.u.def.section;
	  else if (get_opd_info (eh->elf.root.u.def.section) != NULL
		   && opd_entry_value (eh->elf.root.u.def.section,
				       eh->elf.root.u.def.value,
				       &rsec, NULL) != (bfd_vma) -1)
	    ;
	  else
	    continue;

	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);

	  rsec = eh->elf.root.u.def.section;
	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);

	  sym = sym->next;
	}
      while (sym != NULL);
    }

  /* Syms return NULL if we're marking .opd, so we avoid marking all
     function sections, as all functions are referenced in .opd.  */
  rsec = NULL;
  if (get_opd_info (sec) != NULL)
    return rsec;
d4124 1
a4124 1
      struct ppc_link_hash_entry *eh;
d4138 1
a4138 3
	      eh = (struct ppc_link_hash_entry *) h;
	      if (eh->oh != NULL && eh->oh->is_func_descriptor)
		eh = eh->oh;
d4142 2
a4143 6
	      if (eh->is_func_descriptor)
		{
		  /* They also mark their opd section.  */
		  if (!eh->elf.root.u.def.section->gc_mark)
		    _bfd_elf_gc_mark (info, eh->elf.root.u.def.section,
				      ppc64_elf_gc_mark_hook);
d4145 7
a4151 12
		  rsec = eh->oh->elf.root.u.def.section;
		}
	      else if (get_opd_info (eh->elf.root.u.def.section) != NULL
		       && opd_entry_value (eh->elf.root.u.def.section,
					   eh->elf.root.u.def.value,
					   &rsec, NULL) != (bfd_vma) -1)
		{
		  if (!eh->elf.root.u.def.section->gc_mark)
		    _bfd_elf_gc_mark (info, eh->elf.root.u.def.section,
				      ppc64_elf_gc_mark_hook);
		}
	      else
d4169 1
a4169 1
      opd_sym_section = get_opd_info (rsec);
d4171 3
a4173 6
	{
	  if (!rsec->gc_mark)
	    _bfd_elf_gc_mark (info, rsec, ppc64_elf_gc_mark_hook);

	  rsec = opd_sym_section[sym->st_value / 8];
	}
a4317 225
/* The maximum size of .sfpr.  */
#define SFPR_MAX (218*4)

struct sfpr_def_parms
{
  const char name[12];
  unsigned char lo, hi;
  bfd_byte * (*write_ent) (bfd *, bfd_byte *, int);
  bfd_byte * (*write_tail) (bfd *, bfd_byte *, int);
};

/* Auto-generate _save*, _rest* functions in .sfpr.  */

static unsigned int
sfpr_define (struct bfd_link_info *info, const struct sfpr_def_parms *parm)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  unsigned int i;
  size_t len = strlen (parm->name);
  bfd_boolean writing = FALSE;
  char sym[16];

  memcpy (sym, parm->name, len);
  sym[len + 2] = 0;

  for (i = parm->lo; i <= parm->hi; i++)
    {
      struct elf_link_hash_entry *h;

      sym[len + 0] = i / 10 + '0';
      sym[len + 1] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
      if (h != NULL
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = htab->sfpr->size;
	  h->type = STT_FUNC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
	  writing = TRUE;
	  if (htab->sfpr->contents == NULL)
	    {
	      htab->sfpr->contents = bfd_alloc (htab->elf.dynobj, SFPR_MAX);
	      if (htab->sfpr->contents == NULL)
		return FALSE;
	    }
	}
      if (writing)
	{
	  bfd_byte *p = htab->sfpr->contents + htab->sfpr->size;
	  if (i != parm->hi)
	    p = (*parm->write_ent) (htab->elf.dynobj, p, i);
	  else
	    p = (*parm->write_tail) (htab->elf.dynobj, p, i);
	  htab->sfpr->size = p - htab->sfpr->contents;
	}
    }

  return TRUE;
}

static bfd_byte *
savegpr0 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STD_R0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savegpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savegpr0 (abfd, p, r);
  bfd_put_32 (abfd, STD_R0_0R1 + 16, p);
  p = p + 4;
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restgpr0 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restgpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + 16, p);
  p = p + 4;
  p = restgpr0 (abfd, p, r);
  bfd_put_32 (abfd, MTLR_R0, p);
  p = p + 4;
  if (r == 29)
    {
      p = restgpr0 (abfd, p, 30);
      p = restgpr0 (abfd, p, 31);
    }
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savegpr1 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STD_R0_0R12 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savegpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savegpr1 (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restgpr1 (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R12 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restgpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restgpr1 (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savefpr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, STFD_FR0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
savefpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savefpr (abfd, p, r);
  bfd_put_32 (abfd, STD_R0_0R1 + 16, p);
  p = p + 4;
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restfpr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LFD_FR0_0R1 + (r << 21) + (1 << 16) - (32 - r) * 8, p);
  return p + 4;
}

static bfd_byte *
restfpr0_tail (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LD_R0_0R1 + 16, p);
  p = p + 4;
  p = restfpr (abfd, p, r);
  bfd_put_32 (abfd, MTLR_R0, p);
  p = p + 4;
  if (r == 29)
    {
      p = restfpr (abfd, p, 30);
      p = restfpr (abfd, p, 31);
    }
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savefpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savefpr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restfpr1_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restfpr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
savevr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LI_R12_0 + (1 << 16) - (32 - r) * 16, p);
  p = p + 4;
  bfd_put_32 (abfd, STVX_VR0_R12_R0 + (r << 21), p);
  return p + 4;
}

static bfd_byte *
savevr_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = savevr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

static bfd_byte *
restvr (bfd *abfd, bfd_byte *p, int r)
{
  bfd_put_32 (abfd, LI_R12_0 + (1 << 16) - (32 - r) * 16, p);
  p = p + 4;
  bfd_put_32 (abfd, LVX_VR0_R12_R0 + (r << 21), p);
  return p + 4;
}

static bfd_byte *
restvr_tail (bfd *abfd, bfd_byte *p, int r)
{
  p = restvr (abfd, p, r);
  bfd_put_32 (abfd, BLR, p);
  return p + 4;
}

a4320 1

a4340 18
  /* Resolve undefined references to dot-symbols as the value
     in the function descriptor, if we have one in a regular object.
     This is to satisfy cases like ".quad .foo".  Calls to functions
     in dynamic objects are handled elsewhere.  */
  if (fh->elf.root.type == bfd_link_hash_undefweak
      && fh->was_undefined
      && (fh->oh->elf.root.type == bfd_link_hash_defined
	  || fh->oh->elf.root.type == bfd_link_hash_defweak)
      && get_opd_info (fh->oh->elf.root.u.def.section) != NULL
      && opd_entry_value (fh->oh->elf.root.u.def.section,
			  fh->oh->elf.root.u.def.value,
			  &fh->elf.root.u.def.section,
			  &fh->elf.root.u.def.value) != (bfd_vma) -1)
    {
      fh->elf.root.type = fh->oh->elf.root.type;
      fh->elf.elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
    }

d4346 4
d4416 1
a4416 5
	  struct plt_entry **ep = &fdh->elf.plt.plist;
	  while (*ep != NULL)
	    ep = &(*ep)->next;
	  *ep = fh->elf.plt.plist;
	  fh->elf.plt.plist = NULL;
d4420 2
a4421 2
      fdh->oh = fh;
      fh->oh = fdh;
d4442 3
a4448 1

d4454 2
d4457 3
a4459 15
  const struct sfpr_def_parms funcs[] =
    {
      { "_savegpr0_", 14, 31, savegpr0, savegpr0_tail },
      { "_restgpr0_", 14, 29, restgpr0, restgpr0_tail },
      { "_restgpr0_", 30, 31, restgpr0, restgpr0_tail },
      { "_savegpr1_", 14, 31, savegpr1, savegpr1_tail },
      { "_restgpr1_", 14, 31, restgpr1, restgpr1_tail },
      { "_savefpr_", 14, 31, savefpr, savefpr0_tail },
      { "_restfpr_", 14, 29, restfpr, restfpr0_tail },
      { "_restfpr_", 30, 31, restfpr, restfpr0_tail },
      { "._savef", 14, 31, savefpr, savefpr1_tail },
      { "._restf", 14, 31, restfpr, restfpr1_tail },
      { "_savevr_", 20, 31, savevr, savevr_tail },
      { "_restvr_", 20, 31, restvr, restvr_tail }
    };
d4462 1
d4467 41
a4507 5
  /* Provide any missing _save* and _rest* functions.  */
  htab->sfpr->size = 0;
  for (i = 0; i < sizeof (funcs) / sizeof (funcs[0]); i++)
    if (!sfpr_define (info, &funcs[i]))
      return FALSE;
d4511 44
a4554 2
  if (htab->sfpr->size == 0)
    _bfd_strip_section_from_output (info, htab->sfpr);
d4585 2
a4586 1
      if (ent == NULL
d4680 1
a4680 1
      htab->relbss->size += sizeof (Elf64_External_Rela);
d4692 1
a4692 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d4701 1
a4701 1
  h->root.u.def.value = s->size;
d4704 1
a4704 1
  s->size += h->size;
a4715 1
  struct ppc_link_hash_entry *eh;
d4718 1
a4718 2
  eh = (struct ppc_link_hash_entry *) h;
  if (eh->is_func_descriptor)
d4720 1
a4720 1
      struct ppc_link_hash_entry *fh = eh->oh;
d4734 2
a4735 2
	     accessed;  It's either a string in an ELF string table,
	     or allocated in an objalloc structure.  */
d4737 1
a4737 1
	  p = eh->elf.root.root.string - 1;
d4741 1
a4741 2
	  fh = (struct ppc_link_hash_entry *)
	    elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d4750 2
a4751 2
	      q = eh->elf.root.root.string + strlen (eh->elf.root.root.string);
	      while (q >= eh->elf.root.root.string && *q == *p)
d4753 2
a4754 3
	      if (q < eh->elf.root.root.string && *p == '.')
		fh = (struct ppc_link_hash_entry *)
		  elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d4758 2
a4759 2
	      eh->oh = fh;
	      fh->oh = eh;
d4763 1
a4763 1
	_bfd_elf_link_hash_hide_symbol (info, &fh->elf, force_local);
d4768 3
a4770 7
get_sym_h (struct elf_link_hash_entry **hp,
	   Elf_Internal_Sym **symp,
	   asection **symsecp,
	   char **tls_maskp,
	   Elf_Internal_Sym **locsymsp,
	   unsigned long r_symndx,
	   bfd *ibfd)
d4910 2
a4911 1
   code for the old ABI, these will already have been done.  */
d4935 3
a4937 2
  opd_adjust = get_opd_info (sym_sec);
  if (opd_adjust != NULL)
d4939 1
a4939 19
      long adjust = opd_adjust[eh->elf.root.u.def.value / 8];
      if (adjust == -1)
	{
	  /* This entry has been deleted.  */
	  asection *dsec = ppc64_elf_tdata (sym_sec->owner)->deleted_section;
	  if (dsec == NULL)
	    {
	      for (dsec = sym_sec->owner->sections; dsec; dsec = dsec->next)
		if (elf_discarded_section (dsec))
		  {
		    ppc64_elf_tdata (sym_sec->owner)->deleted_section = dsec;
		    break;
		  }
	    }
	  eh->elf.root.u.def.value = 0;
	  eh->elf.root.u.def.section = dsec;
	}
      else
	eh->elf.root.u.def.value += adjust;
d4952 1
a4952 2
ppc64_elf_edit_opd (bfd *obfd, struct bfd_link_info *info,
		    bfd_boolean non_overlapping)
a4955 1
  asection *need_pad = NULL;
d4966 2
a4967 3
      long *opd_adjust;
      bfd_boolean need_edit, add_aux_fields;
      bfd_size_type cnt_16b = 0;
d4973 3
a4975 3
      amt = sec->size * sizeof (long) / 8;
      opd_adjust = get_opd_info (sec);
      if (opd_adjust == NULL)
d4979 2
a4980 2
	  opd_adjust = bfd_zalloc (obfd, amt);
	  ppc64_elf_section_data (sec)->opd.adjust = opd_adjust;
d4982 1
a4982 1
      memset (opd_adjust, 0, amt);
a5003 1
      need_pad = sec;
d5014 1
a5014 1
	  /* .opd contains a regular array of 16 or 24 byte entries.  We're
a5025 1
	    broken_opd:
d5027 2
a5028 1
		(_("%B: .opd is not a regular array of opd entries"), ibfd);
d5037 2
a5038 2
		(_("%B: unexpected reloc type %u in .opd section"),
		 ibfd, r_type);
d5057 3
a5059 2
		(_("%B: undefined sym `%s' in .opd section"),
		 ibfd, sym_name);
d5075 1
d5077 4
a5080 36
	  if (rel == relend
	      || (rel + 1 == relend && rel->r_offset == offset + 16))
	    {
	      if (sec->size == offset + 24)
		{
		  need_pad = NULL;
		  break;
		}
	      if (rel == relend && sec->size == offset + 16)
		{
		  cnt_16b++;
		  break;
		}
	      goto broken_opd;
	    }

	  if (rel->r_offset == offset + 24)
	    offset += 24;
	  else if (rel->r_offset != offset + 16)
	    goto broken_opd;
	  else if (rel + 1 < relend
		   && ELF64_R_TYPE (rel[0].r_info) == R_PPC64_ADDR64
		   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOC)
	    {
	      offset += 16;
	      cnt_16b++;
	    }
	  else if (rel + 2 < relend
		   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_ADDR64
		   && ELF64_R_TYPE (rel[2].r_info) == R_PPC64_TOC)
	    {
	      offset += 24;
	      rel += 1;
	    }
	  else
	    goto broken_opd;
d5083 1
a5083 3
      add_aux_fields = non_overlapping && cnt_16b > 0;

      if (need_edit || add_aux_fields)
a5086 1
	  bfd_byte *new_contents = NULL;
a5087 1
	  long opd_ent_size;
d5095 4
a5098 2
	      bfd_byte *loc;
	      if (!bfd_malloc_and_get_section (ibfd, sec, &loc))
a5099 2
		  if (loc != NULL)
		    free (loc);
a5115 11
	  new_contents = sec->contents;

	  if (add_aux_fields)
	    {
	      new_contents = bfd_malloc (sec->size + cnt_16b * 8);
	      if (new_contents == NULL)
		return FALSE;
	      need_pad = FALSE;
	      wptr = new_contents;
	    }

a5118 1
	  opd_ent_size = 0;
d5134 1
a5134 15

		  /* See if the .opd entry is full 24 byte or
		     16 byte (with fd_aux entry overlapped with next
		     fd_func).  */
		  opd_ent_size = 24;
		  if ((rel + 2 == relend && sec->size == offset + 16)
		      || (rel + 3 < relend
			  && rel[2].r_offset == offset + 16
			  && rel[3].r_offset == offset + 24
			  && ELF64_R_TYPE (rel[2].r_info) == R_PPC64_ADDR64
			  && ELF64_R_TYPE (rel[3].r_info) == R_PPC64_TOC))
		    opd_ent_size = 16;

		  if (h != NULL
		      && h->root.root.string[0] == '.')
d5142 1
a5142 1
		      if (fdh != NULL && sym_sec->owner == ibfd)
a5148 1
		      opd_adjust[rel->r_offset / 8] = -1;
d5154 1
a5154 1
		      if (fdh != NULL)
d5163 1
a5163 1
			  fdh->elf.root.u.def.value = wptr - new_contents;
d5173 1
a5173 2
		      opd_adjust[rel->r_offset / 8]
			= (wptr - new_contents) - (rptr - sec->contents);
d5176 2
a5177 7
			memcpy (wptr, rptr, opd_ent_size);
		      wptr += opd_ent_size;
		      if (add_aux_fields && opd_ent_size == 16)
			{
			  memset (wptr, '\0', 8);
			  wptr += 8;
			}
d5179 2
a5180 2
		  rptr += opd_ent_size;
		  offset += opd_ent_size;
d5218 1
a5218 1
		  rel->r_offset += opd_adjust[(offset - opd_ent_size) / 8];
d5225 1
a5225 1
	  sec->size = wptr - new_contents;
a5226 6
	  if (add_aux_fields)
	    {
	      free (sec->contents);
	      sec->contents = new_contents;
	    }

a5249 34
  /* If we are doing a final link and the last .opd entry is just 16 byte
     long, add a 8 byte padding after it.  */
  if (need_pad != NULL && !info->relocatable)
    {
      bfd_byte *p;

      if ((need_pad->flags & SEC_IN_MEMORY) == 0)
	{
	  BFD_ASSERT (need_pad->size > 0);

	  p = bfd_malloc (need_pad->size + 8);
	  if (p == NULL)
	    return FALSE;

	  if (! bfd_get_section_contents (need_pad->owner, need_pad,
					  p, 0, need_pad->size))
	    return FALSE;

	  need_pad->contents = p;
	  need_pad->flags |= (SEC_IN_MEMORY | SEC_HAS_CONTENTS);
	}
      else
	{
	  p = bfd_realloc (need_pad->contents, need_pad->size + 8);
	  if (p == NULL)
	    return FALSE;

	  need_pad->contents = p;
	}

      memset (need_pad->contents + need_pad->size, 0, 8);
      need_pad->size += 8;
    }

d5263 1
a5263 1
      struct ppc_link_hash_entry *h = htab->tls_get_addr;
d5265 3
a5267 3
      while (h->elf.root.type == bfd_link_hash_indirect
	     || h->elf.root.type == bfd_link_hash_warning)
	h = (struct ppc_link_hash_entry *) h->elf.root.u.i.link;
a5269 16

      if (htab->tls_get_addr_fd == NULL
	  && h->oh != NULL
	  && h->oh->is_func_descriptor)
	htab->tls_get_addr_fd = h->oh;
    }

  if (htab->tls_get_addr_fd != NULL)
    {
      struct ppc_link_hash_entry *h = htab->tls_get_addr_fd;

      while (h->elf.root.type == bfd_link_hash_indirect
	     || h->elf.root.type == bfd_link_hash_warning)
	h = (struct ppc_link_hash_entry *) h->elf.root.u.i.link;

      htab->tls_get_addr_fd = h;
d5345 11
a5355 3
		  /* Symbols referenced by TLS relocs must be of type
		     STT_TLS.  So no need for .opd local sym adjust.  */
		  value = sym->st_value;
d5427 1
a5427 2
			&& (h == &htab->tls_get_addr->elf
			    || h == &htab->tls_get_addr_fd->elf))
d5608 2
d5613 2
a5614 2
	    if (s->size == 0)
	      s->size += PLT_INITIAL_ENTRY_SIZE;
d5616 1
a5616 1
	    pent->plt.offset = s->size;
d5619 1
a5619 1
	    s->size += PLT_ENTRY_SIZE;
d5623 2
a5624 2
	    if (s->size == 0)
	      s->size += GLINK_CALL_STUB_SIZE;
d5626 3
a5628 3
	    if (s->size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	      s->size += 4;
	    s->size += 2*4;
d5632 1
a5632 1
	    s->size += sizeof (Elf64_External_Rela);
d5698 2
a5699 2
	gent->got.offset = s->size;
	s->size
d5706 1
a5706 1
	  ppc64_elf_tdata (gent->owner)->relgot->size
d5786 1
a5786 1
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
d5846 1
a5846 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d5862 1
a5862 1
      if (!is_ppc64_elf_target (ibfd->xvec))
d5868 2
a5869 2
	  ppc64_tlsld_got (ibfd)->offset = s->size;
	  s->size += 16;
d5873 1
a5873 1
	      srel->size += sizeof (Elf64_External_Rela);
d5899 1
a5899 1
		  srel->size += p->count * sizeof (Elf64_External_Rela);
d5927 2
a5928 2
			ppc64_tlsld_got (ibfd)->offset = s->size;
			s->size += 16;
d5930 1
a5930 1
			  srel->size += sizeof (Elf64_External_Rela);
d5936 1
a5936 1
		    ent->got.offset = s->size;
d5939 1
a5939 1
			s->size += 16;
d5941 1
a5941 1
			  srel->size += 2 * sizeof (Elf64_External_Rela);
d5945 1
a5945 1
			s->size += 8;
d5947 1
a5947 1
			  srel->size += sizeof (Elf64_External_Rela);
d5968 4
d5984 1
a5984 1
	  if (s->size == 0)
d6012 1
a6012 1
      if (s->size == 0)
d6029 1
a6029 1
      s->contents = bfd_zalloc (dynobj, s->size);
a6035 3
      if (!is_ppc64_elf_target (ibfd->xvec))
	continue;

d6039 2
a6040 1
	  if (s->size == 0)
d6044 1
a6044 1
	      s->contents = bfd_zalloc (ibfd, s->size);
d6052 2
a6053 1
	  if (s->size == 0)
d6057 1
a6057 1
	      s->contents = bfd_zalloc (ibfd, s->size);
d6082 1
a6082 1
      if (htab->plt != NULL && htab->plt->size != 0)
d6140 1
a6140 4
	  && h->oh->is_func_descriptor)
	h = h->oh;

      if (h->elf.dynindx != -1)
d6143 1
a6143 2

	  for (ent = h->elf.plt.plist; ent != NULL; ent = ent->next)
d6147 1
a6147 1
		*hash = h;
d6215 1
a6215 1
  bfd_vma dest, off;
d6225 1
a6225 1
  stub_entry->stub_offset = stub_entry->stub_sec->size;
d6234 3
a6236 3
      off = dest = (stub_entry->target_value
		    + stub_entry->target_section->output_offset
		    + stub_entry->target_section->output_section->vma);
a6262 61

      if (info->emitrelocations)
	{
	  Elf_Internal_Rela *relocs, *r;
	  struct bfd_elf_section_data *elfsec_data;

	  elfsec_data = elf_section_data (stub_entry->stub_sec);
	  relocs = elfsec_data->relocs;
	  if (relocs == NULL)
	    {
	      bfd_size_type relsize;
	      relsize = stub_entry->stub_sec->reloc_count * sizeof (*relocs);
	      relocs = bfd_alloc (htab->stub_bfd, relsize);
	      if (relocs == NULL)
		return FALSE;
	      elfsec_data->relocs = relocs;
	      elfsec_data->rel_hdr.sh_size = relsize;
	      elfsec_data->rel_hdr.sh_entsize = 24;
	      stub_entry->stub_sec->reloc_count = 0;
	    }
	  r = relocs + stub_entry->stub_sec->reloc_count;
	  stub_entry->stub_sec->reloc_count += 1;
	  r->r_offset = loc - stub_entry->stub_sec->contents;
	  r->r_info = ELF64_R_INFO (0, R_PPC64_REL24);
	  r->r_addend = dest;
	  if (stub_entry->h != NULL)
	    {
	      struct elf_link_hash_entry **hashes;
	      unsigned long symndx;
	      struct ppc_link_hash_entry *h;

	      hashes = elf_sym_hashes (htab->stub_bfd);
	      if (hashes == NULL)
		{
		  bfd_size_type hsize;

		  hsize = (htab->stub_globals + 1) * sizeof (*hashes);
		  hashes = bfd_zalloc (htab->stub_bfd, hsize);
		  if (hashes == NULL)
		    return FALSE;
		  elf_sym_hashes (htab->stub_bfd) = hashes;
		  htab->stub_globals = 1;
		}
	      symndx = htab->stub_globals++;
	      h = stub_entry->h;
	      hashes[symndx] = &h->elf;
	      r->r_info = ELF64_R_INFO (symndx, R_PPC64_REL24);
	      if (h->oh != NULL && h->oh->is_func)
		h = h->oh;
	      if (h->elf.root.u.def.section != stub_entry->target_section)
		/* H is an opd symbol.  The addend must be zero.  */
		r->r_addend = 0;
	      else
		{
		  off = (h->elf.root.u.def.value
			 + h->elf.root.u.def.section->output_offset
			 + h->elf.root.u.def.section->output_section->vma);
		  r->r_addend -= off;
		}
	    }
	}
d6285 1
a6285 1
      if (htab->relbrlt != NULL)
d6353 2
a6354 3
      if (stub_entry->h->oh != NULL
	  && stub_entry->h->oh->elf.root.type != bfd_link_hash_defined
	  && stub_entry->h->oh->elf.root.type != bfd_link_hash_defweak)
d6361 3
a6363 3
	  stub_entry->h->oh->elf.root.type = bfd_link_hash_defined;
	  stub_entry->h->oh->elf.root.u.def.section = stub_entry->stub_sec;
	  stub_entry->h->oh->elf.root.u.def.value = stub_entry->stub_offset;
d6402 1
a6402 1
  stub_entry->stub_sec->size += size;
d6404 5
a6408 1
  if (htab->emit_stub_syms)
d6411 2
a6412 17
      size_t len1, len2;
      char *name;
      const char *const stub_str[] = { "long_branch",
				       "long_branch_r2off",
				       "plt_branch",
				       "plt_branch_r2off",
				       "plt_call" };

      len1 = strlen (stub_str[stub_entry->stub_type - 1]);
      len2 = strlen (stub_entry->root.string);
      name = bfd_malloc (len1 + len2 + 2);
      if (name == NULL)
	return FALSE;
      memcpy (name, stub_entry->root.string, 9);
      memcpy (name + 9, stub_str[stub_entry->stub_type - 1], len1);
      memcpy (name + len1 + 9, stub_entry->root.string + 8, len2 - 8 + 1);
      h = elf_link_hash_lookup (&htab->elf, name, TRUE, FALSE, FALSE);
d6477 1
a6477 1
      off -= (stub_entry->stub_sec->size
d6512 2
a6513 2
	      br_entry->offset = htab->brlt->size;
	      htab->brlt->size += 8;
d6515 2
a6516 2
	      if (htab->relbrlt != NULL)
		htab->relbrlt->size += sizeof (Elf64_External_Rela);
a6523 5

      if (info->emitrelocations
	  && (stub_entry->stub_type == ppc_stub_long_branch
	      || stub_entry->stub_type == ppc_stub_long_branch_r2off))
	stub_entry->stub_sec->reloc_count += 1;
d6526 1
a6526 1
  stub_entry->stub_sec->size += size;
a6602 2
  bfd_vma addr = isec->output_offset + isec->output_section->vma;
  bfd_vma off = addr - htab->toc_curr;
d6604 13
a6616 6
  if (off + isec->size > 0x10000)
    htab->toc_curr = addr;

  elf_gp (isec->owner) = (htab->toc_curr
			  - elf_gp (isec->output_section->owner)
			  + TOC_BASE_OFF);
d6649 1
a6649 1
  if (isec->size == 0)
d6659 5
a6663 1
      if (!bfd_malloc_and_get_section (isec->owner, isec, &contents))
d6665 1
a6665 2
	  if (contents != NULL)
	    free (contents);
d6675 1
a6675 1
  for (i = 0; i < isec->size; i += 4)
d6765 4
a6768 1
	  total = tail->size;
d6924 1
a6924 1
		  asection *sym_sec, *code_sec;
a6926 1
		  bfd_boolean ok_dest;
a6927 1
		  struct ppc_link_hash_entry *fdh;
a6931 1
		  long *opd_adjust;
d6951 1
a6956 2
		  ok_dest = FALSE;
		  fdh = NULL;
d6959 1
d6961 3
a6963 1
		      ok_dest = TRUE;
d6967 1
d6969 2
a6970 19
		      /* Recognise an old ABI func code entry sym, and
			 use the func descriptor sym instead.  */
		      if (hash->elf.root.type == bfd_link_hash_undefweak
			  && hash->elf.root.root.string[0] == '.'
			  && (fdh = get_fdh (hash, htab)) != NULL)
			{
			  if (fdh->elf.root.type == bfd_link_hash_defined
			      || fdh->elf.root.type == bfd_link_hash_defweak)
			    {
			      sym_sec = fdh->elf.root.u.def.section;
			      sym_value = fdh->elf.root.u.def.value;
			      if (sym_sec->output_section != NULL)
				ok_dest = TRUE;
			    }
			  else
			    fdh = NULL;
			}
		      else if (hash->elf.root.type == bfd_link_hash_defined
			       || hash->elf.root.type == bfd_link_hash_defweak)
d6974 3
a6976 1
			    ok_dest = TRUE;
a6988 38
		  destination = 0;
		  if (ok_dest)
		    {
		      sym_value += irela->r_addend;
		      destination = (sym_value
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		    }

		  code_sec = sym_sec;
		  opd_adjust = get_opd_info (sym_sec);
		  if (opd_adjust != NULL)
		    {
		      bfd_vma dest;

		      if (hash == NULL)
			{
			  long adjust = opd_adjust[sym_value / 8];
			  if (adjust == -1)
			    continue;
			  sym_value += adjust;
			}
		      dest = opd_entry_value (sym_sec, sym_value,
					      &code_sec, &sym_value);
		      if (dest != (bfd_vma) -1)
			{
			  destination = dest;
			  if (fdh != NULL)
			    {
			      /* Fixup old ABI sym to point at code
				 entry.  */
			      hash->elf.root.type = bfd_link_hash_defweak;
			      hash->elf.root.u.def.section = code_sec;
			      hash->elf.root.u.def.value = sym_value;
			    }
			}
		    }

d7001 3
a7003 3
		      if (code_sec != NULL
			  && code_sec->output_section != NULL
			  && (htab->stub_group[code_sec->id].toc_off
d7005 1
a7005 1
			  && code_sec->has_gp_reloc
d7016 1
a7016 2
		      && (hash == htab->tls_get_addr
			  || hash == htab->tls_get_addr_fd)
d7064 1
a7064 1
		  stub_entry->target_section = code_sec;
a7066 4

		  if (stub_entry->h != NULL)
		    htab->stub_globals += 1;

d7095 2
a7096 2
	    stub_sec->size = 0;
	    stub_sec->reloc_count = 0;
d7098 7
a7104 4

      htab->brlt->size = 0;
      if (htab->relbrlt != NULL)
	htab->relbrlt->size = 0;
a7190 2

  /* Allocate memory to hold the linker stubs.  */
d7194 1
a7194 2
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0
	&& stub_sec->size != 0)
d7196 11
a7206 7
	stub_sec->contents = bfd_zalloc (htab->stub_bfd, stub_sec->size);
	if (stub_sec->contents == NULL)
	  return FALSE;
	/* We want to check that built size is the same as calculated
	   size.  rawsize is a convenient location to use.  */
	stub_sec->rawsize = stub_sec->size;
	stub_sec->size = 0;
d7280 1
a7280 1
      while (p < htab->glink->contents + htab->glink->size)
d7299 1
a7299 1
      htab->glink->rawsize = p - htab->glink->contents;
d7302 1
a7302 1
  if (htab->brlt->size != 0)
d7305 1
a7305 1
					 htab->brlt->size);
d7309 1
a7309 1
  if (htab->relbrlt != NULL && htab->relbrlt->size != 0)
d7312 1
a7312 1
					    htab->relbrlt->size);
d7326 1
a7326 1
	if (stub_sec->rawsize != stub_sec->size)
d7331 1
a7331 1
      || htab->glink->rawsize != htab->glink->size)
d7346 1
a7346 1
      sprintf (*stats, _("linker stubs in %u group%s\n"
a7352 1
	       stub_sec_count == 1 ? "" : "s",
a7361 28
/* This function undoes the changes made by add_symbol_adjust.  */

static bfd_boolean
undo_symbol_twiddle (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  struct ppc_link_hash_entry *eh;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->elf.root.type != bfd_link_hash_undefweak || !eh->was_undefined)
    return TRUE;

  eh->elf.root.type = bfd_link_hash_undefined;
  return TRUE;
}

void
ppc64_elf_restore_symbols (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  elf_link_hash_traverse (&htab->elf, undo_symbol_twiddle, info);
}

a7422 5

  /* Don't relocate stub sections.  */
  if (input_section->owner == htab->stub_bfd)
    return TRUE;

d7438 2
a7439 3
      struct elf_link_hash_entry *h_elf;
      struct ppc_link_hash_entry *h;
      struct ppc_link_hash_entry *fdh;
d7466 1
a7466 1
      h_elf = NULL;
a7473 2
	  long *opd_adjust;

d7479 1
a7479 2
	  opd_adjust = get_opd_info (sec);
	  if (opd_adjust != NULL)
d7481 5
a7485 5
	      long adjust = opd_adjust[(sym->st_value + rel->r_addend) / 8];
	      if (adjust == -1)
		relocation = 0;
	      else
		relocation += adjust;
d7492 1
a7492 1
				   h_elf, sec, relocation,
d7494 2
a7495 2
	  sym_name = h_elf->root.root.string;
	  sym_type = h_elf->type;
a7496 1
      h = (struct ppc_link_hash_entry *) h_elf;
d7508 1
a7508 1
	    tls_mask = h->tls_mask;
d7534 2
a7535 2
	      || h->elf.root.type == bfd_link_hash_defined
	      || h->elf.root.type == bfd_link_hash_defweak)
d7544 4
a7547 4
	       ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
	       : _("%B(%A+0x%lx): %s used with non-TLS symbol %s"),
	       input_bfd,
	       input_section,
d7752 1
a7752 2
		  if (h2 == NULL || (h2 != &htab->tls_get_addr->elf
				     && h2 != &htab->tls_get_addr_fd->elf))
a7855 2
      max_br_offset = 1 << 25;
      addend = rel->r_addend;
d7872 22
a7893 1
	  /* Fall thru.  */
d7895 2
a7896 3
	case R_PPC64_REL14:
	  max_br_offset = 1 << 15;
	  /* Fall thru.  */
a7904 2
	  stub_entry = NULL;
	  fdh = h;
d7906 3
a7908 4
		&& (((fdh = h->oh) != NULL
		     && fdh->elf.plt.plist != NULL)
		    || (fdh = h)->elf.plt.plist != NULL))
	       || (sec != NULL
a7909 1
		   && sec->id <= htab->top_id
d7918 1
a7918 1
	      bfd_boolean can_plt_call = FALSE;
d7920 1
a7920 1
	      if (rel->r_offset + 8 <= input_section->size)
d7922 3
a7924 4
		  unsigned long nop;
		  nop = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
		  if (nop == NOP
		      || nop == CROR_151515 || nop == CROR_313131)
d7928 1
a7928 1
		      can_plt_call = TRUE;
d7938 3
a7940 4
		      unsigned long br;
		      br = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      if ((br & 1) == 0)
			can_plt_call = TRUE;
d7943 1
a7943 1
			   && strcmp (h->elf.root.root.string,
d7947 1
a7947 1
		      can_plt_call = TRUE;
d7956 1
a7956 1
			  (_("%B(%A+0x%lx): automatic multiple TOCs "
d7959 2
a7960 2
			   input_bfd,
			   input_section,
d7964 1
a7964 1
			  (_("%B(%A+0x%lx): sibling call optimization to `%s' "
d7969 2
a7970 2
			   input_bfd,
			   input_section,
d7979 1
a7979 13
	      if (can_plt_call
		  && stub_entry->stub_type == ppc_stub_plt_call)
		unresolved_reloc = FALSE;
	    }

	  if (stub_entry == NULL
	      && get_opd_info (sec) != NULL)
	    {
	      /* The branch destination is the value of the opd entry. */
	      bfd_vma off = (relocation - sec->output_section->vma
			     - sec->output_offset + rel->r_addend);
	      bfd_vma dest = opd_entry_value (sec, off, NULL, NULL);
	      if (dest != (bfd_vma) -1)
d7981 5
a7985 42
		  relocation = dest;
		  addend = 0;
		}
	    }

	  /* If the branch is out of reach we ought to have a long
	     branch stub.  */
	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);

	  if (stub_entry == NULL
	      && (relocation + rel->r_addend - from + max_br_offset
		  >= 2 * max_br_offset)
	      && r_type != R_PPC64_ADDR14_BRTAKEN
	      && r_type != R_PPC64_ADDR14_BRNTAKEN)
	    stub_entry = ppc_get_stub_entry (input_section, sec, h, rel,
					     htab);

	  if (stub_entry != NULL)
	    {
	      /* Munge up the value and addend so that we call the stub
		 rather than the procedure directly.  */
	      relocation = (stub_entry->stub_offset
			    + stub_entry->stub_sec->output_offset
			    + stub_entry->stub_sec->output_section->vma);
	      addend = 0;
	    }

	  if (insn != 0)
	    {
	      if (is_power4)
		{
		  /* Set 'a' bit.  This is 0b00010 in BO field for branch
		     on CR(BI) insns (BO == 001at or 011at), and 0b01000
		     for branch on CTR insns (BO == 1a00t or 1a01t).  */
		  if ((insn & (0x14 << 21)) == (0x04 << 21))
		    insn |= 0x02 << 21;
		  else if ((insn & (0x14 << 21)) == (0x10 << 21))
		    insn |= 0x08 << 21;
		  else
		    break;
a7986 8
	      else
		{
		  /* Invert 'y' bit if not the default.  */
		  if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
		    insn ^= 0x01 << 21;
		}

	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
d7989 22
a8010 11
	  /* NOP out calls to undefined weak functions.
	     We can thus call a weak function without first
	     checking whether the function is defined.  */
	  else if (h != NULL
		   && h->elf.root.type == bfd_link_hash_undefweak
		   && r_type == R_PPC64_REL24
		   && relocation == 0
		   && rel->r_addend == 0)
	    {
	      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
	      continue;
d8017 1
d8022 2
a8023 2
	    (_("%B: unknown relocation type %d for symbol %s"),
	     input_bfd, (int) r_type, sym_name);
d8084 1
a8084 2
		    || (h->elf.elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) == 0))
d8093 1
a8093 2
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared,
							  &h->elf)
d8095 1
a8095 1
			    && SYMBOL_REFERENCES_LOCAL (info, &h->elf)))
d8103 1
a8103 1
			indx = h->elf.dynindx;
d8106 1
a8106 1
		    ent = h->elf.got.glist;
d8145 2
a8146 2
			|| ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
			|| h->elf.root.type != bfd_link_hash_undefweak))
d8254 1
a8254 1
	      for (ent = h->elf.plt.plist; ent != NULL; ent = ent->next)
d8394 2
a8395 2
		   || ELF_ST_VISIBILITY (h->elf.other) == STV_DEFAULT
		   || h->elf.root.type != bfd_link_hash_undefweak)
d8397 1
a8397 1
		   || !SYMBOL_CALLS_LOCAL (info, &h->elf)))
d8401 4
a8404 4
		  && h->elf.dynindx != -1
		  && !(h->elf.elf_link_hash_flags & ELF_LINK_NON_GOT_REF)
		  && (h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		  && !(h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d8443 1
a8443 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, &h->elf)
d8446 1
a8446 1
		outrel.r_info = ELF64_R_INFO (h->elf.dynindx, r_type);
d8562 2
a8563 2
	    (_("%B: relocation %s is not supported for symbol %s."),
	     input_bfd,
d8641 2
a8642 2
		(_("%B: error: relocation %s not a multiple of %d"),
		 input_bfd,
d8650 34
d8691 1
a8691 1
	       && (h->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
d8694 3
a8696 3
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
d8699 1
a8699 1
	     h->elf.root.root.string);
d8720 1
a8720 1
		  && h->elf.root.type == bfd_link_hash_undefweak
d8740 3
a8742 3
		(_("%B(%A+0x%lx): %s reloc against `%s': error %d"),
		 input_bfd,
		 input_section,
d8764 1
a8764 1
  long *opd_adjust, adjust;
d8767 4
a8770 5
  if (h != NULL)
    return TRUE;

  opd_adjust = get_opd_info (input_sec);
  if (opd_adjust == NULL)
d8777 1
a8777 5
  adjust = opd_adjust[value / 8];
  if (adjust == -1)
    elfsym->st_value = 0;
  else
    elfsym->st_value += adjust;
a8791 3
  struct plt_entry *ent;
  Elf_Internal_Rela rela;
  bfd_byte *loc;
d8796 16
a8811 5
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.offset != (bfd_vma) -1)
      {
	/* This symbol has an entry in the procedure linkage
	   table.  Set it up.  */
d8813 14
a8826 18
	if (htab->plt == NULL
	    || htab->relplt == NULL
	    || htab->glink == NULL)
	  abort ();

	/* Create a JMP_SLOT reloc to inform the dynamic linker to
	   fill in the PLT entry.  */
	rela.r_offset = (htab->plt->output_section->vma
			 + htab->plt->output_offset
			 + ent->plt.offset);
	rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	rela.r_addend = ent->addend;

	loc = htab->relplt->contents;
	loc += ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		* sizeof (Elf64_External_Rela));
	bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
      }
d8902 1
a8902 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d8936 1
a8936 1
	      dyn.d_un.d_val = s->size;
d8950 1
a8950 1
	      dyn.d_un.d_val = htab->relplt->size;
d8959 1
a8959 1
	      dyn.d_un.d_val -= s->size;
d8971 1
a8971 1
	      dyn.d_un.d_ptr += s->size;
d8979 1
a8979 1
  if (htab->got != NULL && htab->got->size != 0)
d8991 1
a8991 1
  if (htab->plt != NULL && htab->plt->size != 0)
d8999 1
a8999 2
     since we didn't add them to DYNOBJ.  We know dynobj is the first
     bfd.  */
a9002 4

      if (!is_ppc64_elf_target (dynobj->xvec))
	continue;

d9005 1
a9005 1
	  && s->size != 0
d9009 1
a9009 1
					s->size))
d9013 1
a9013 1
	  && s->size != 0
d9017 1
a9017 1
					s->size))
@


1.143.8.4
log
@Merge from mainline.
@
text
@d3769 1
d3813 3
d3817 1
a3817 1
     of elf_adjust_dynamic_symbol, don't copy NON_GOT_REF.
d3819 6
a3824 9
  if (!(ELIMINATE_COPY_RELOCS
	&& eind->elf.root.type != bfd_link_hash_indirect
	&& edir->elf.dynamic_adjusted))
    edir->elf.non_got_ref |= eind->elf.non_got_ref;

  edir->elf.ref_dynamic |= eind->elf.ref_dynamic;
  edir->elf.ref_regular |= eind->elf.ref_regular;
  edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
  edir->elf.needs_plt |= eind->elf.needs_plt;
d4067 2
a4068 2
	      *pun = h->u.undef.next;
	      h->u.undef.next = NULL;
d4074 1
a4074 1
		    /* pun points at an u.undef.next field.  Go back to
d4077 1
a4077 1
		      ((char *) pun - ((char *) &h->u.undef.next - (char *) h));
d4082 1
a4082 1
	    pun = &h->u.undef.next;
d4158 1
a4158 1
  eh->elf.needs_plt = 1;
d4554 1
a4554 1
	    h->non_got_ref = 1;
d4587 2
a4588 1
			   || !h->def_regular))))
d4593 2
a4594 1
		      || !h->def_regular)))
d5083 1
a5083 1
	  && !h->def_regular)
d5089 1
a5089 1
	  h->def_regular = 1;
d5314 1
a5314 1
      fh->elf.forced_local = 1;
d5365 1
a5365 1
      fdh->elf.non_elf = 0;
d5371 1
a5371 1
      && !fdh->elf.forced_local
d5373 2
a5374 2
	  || fdh->elf.def_dynamic
	  || fdh->elf.ref_dynamic
d5381 5
a5385 4
      fdh->elf.ref_regular |= fh->elf.ref_regular;
      fdh->elf.ref_dynamic |= fh->elf.ref_dynamic;
      fdh->elf.ref_regular_nonweak |= fh->elf.ref_regular_nonweak;
      fdh->elf.non_got_ref |= fh->elf.non_got_ref;
d5393 1
a5393 1
	  fdh->elf.needs_plt = 1;
d5409 1
a5409 1
       && (!fh->elf.def_regular
d5411 2
a5412 2
	   || !fdh->elf.def_regular
	   || fdh->elf.forced_local));
d5482 1
a5482 1
      || h->needs_plt)
d5496 1
a5496 1
	  h->needs_plt = 0;
d5505 1
a5505 1
  if (h->u.weakdef != NULL)
d5507 4
a5510 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d5512 3
a5514 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d5527 1
a5527 1
  if (!h->non_got_ref)
d5547 1
a5547 1
	  h->non_got_ref = 0;
d5585 1
a5585 1
      h->needs_copy = 1;
d5815 1
a5815 1
	   && !h->def_dynamic))
d6407 1
a6407 1
		    || !h->def_dynamic)
d6686 1
a6686 1
	  h->needs_plt = 0;
d6692 1
a6692 1
      h->needs_plt = 0;
d6730 1
a6730 1
	    && !h->forced_local)
d6737 1
a6737 1
	    && !h->def_dynamic)
d6804 3
a6806 3
      if (!h->non_got_ref
	  && h->def_dynamic
	  && !h->def_regular)
d6811 1
a6811 1
	      && !h->forced_local)
d7540 4
a7543 5
	  h->ref_regular = 1;
	  h->def_regular = 1;
	  h->ref_regular_nonweak = 1;
	  h->forced_local = 1;
	  h->non_elf = 0;
d8406 4
a8409 5
	      h->ref_regular = 1;
	      h->def_regular = 1;
	      h->ref_regular_nonweak = 1;
	      h->forced_local = 1;
	      h->non_elf = 0;
d9325 2
a9326 1
		    || !h->elf.def_dynamic))
d9645 3
a9647 3
		  && !h->elf.non_got_ref
		  && h->elf.def_dynamic
		  && !h->elf.def_regular))
d9900 1
a9900 1
	       && h->elf.def_dynamic))
d10038 1
a10038 1
  if (h->needs_copy)
@


1.142
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d3593 9
a3958 4
	  /* Don't propagate relocs that the dynamic linker won't relocate.  */
	  if ((sec->flags & SEC_ALLOC) == 0)
	    break;

d4174 3
d6012 1
a6012 1
      if ((s->flags & SEC_LOAD) == 0)
@


1.141
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d95 1
d2766 3
d2978 1
d4883 42
d4929 1
d5130 7
a5136 4
			  /* Redefine the function descriptor symbol
			     to this location in the opd section.
			     We've checked above that opd relocs are
			     ordered.  */
d5138 1
d5140 8
a5147 10
		      else
			{
			  /* Local syms are a bit tricky.  We could
			     tweak them as they can be cached, but
			     we'd need to look through the local syms
			     for the function descriptor sym which we
			     don't have at the moment.  So keep an
			     array of adjustments.  */
			  adjust[rel->r_offset / 24] = wptr - rptr;
			}
d5206 1
d5221 3
d5319 11
a5329 1
		  value = sym->st_value;
d7469 1
a7469 1
	      if (opd_sym_adjust != NULL && sym->st_value % 24 == 0)
d8738 26
@


1.140
log
@	* elf64-ppc.c (ppc_type_of_stub): Disallow stubs other than
	ppc_stub_plt_call to symbols defined in shared libs.
@
text
@d2644 1
a2644 1
   redefines the function desctriptor symbol to point to the copy.  This
@


1.139
log
@	* elf64-ppc.c (toc_adjusting_stub_needed): Exit early if section
	size is zero.
@
text
@d6073 3
a6075 2
      if (h->elf.root.type != bfd_link_hash_defined
	  && h->elf.root.type != bfd_link_hash_defweak)
@


1.138
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d6569 3
@


1.137
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d3362 2
a3363 1
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF);
@


1.136
log
@	* elf64-ppc.c (ppc_size_one_stub): Size relbrlt.  Accept info arg
	rather than htab.
	(ppc64_elf_size_stubs): Adjust ppc_size_one_stub traversal.  Zero
	relbrlt size.
	(ppc64_elf_build_stubs): Allocate space for relbrlt.
@
text
@d7394 1
a7394 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d8187 3
a8189 1
	  else if (sec != NULL && !unresolved_reloc)
@


1.135
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d6357 1
d6364 3
a6366 1
  htab = in_arg;
d6433 3
d7016 5
d7022 1
a7022 1
      bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, htab);
d7223 7
@


1.134
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@a2839 3
  /* Short-cut to first output tls section.  */
  asection *tls_sec;

d5172 1
a5172 1
/* Set htab->tls_sec.  */
d5174 1
a5174 1
bfd_boolean
a5176 1
  asection *tls;
a5178 5
  for (tls = obfd->sections; tls != NULL; tls = tls->next)
    if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
	== (SEC_THREAD_LOCAL | SEC_LOAD))
      break;

a5179 2
  htab->tls_sec = tls;

d5191 1
a5191 1
  return tls != NULL;
d5274 1
a5274 1
		    value -= htab->tls_sec->vma;
d7682 2
a7683 2
			  rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
d8088 1
a8088 1
			  outrel.r_addend -= htab->tls_sec->vma;
d8105 1
a8105 1
			relocation -= htab->tls_sec->vma + DTP_OFFSET;
d8215 1
a8215 1
	  addend -= htab->tls_sec->vma + TP_OFFSET;
d8233 1
a8233 1
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
d8242 1
a8242 1
	  addend -= htab->tls_sec->vma + TP_OFFSET;
d8246 1
a8246 1
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
@


1.133
log
@	* elf64-ppc.c (elf_backend_grok_prstatus): Define.
	(elf_backend_grok_psinfo): Define.
	(ppc64_elf_grok_prstatus, ppc64_elf_grok_psinfo): New functions.
@
text
@a67 1
#define elf_backend_plt_header_size PLT_INITIAL_ENTRY_SIZE
@


1.132
log
@	* elf64-ppc.c (get_tls_mask): Add toc_symndx param, save toc
	reloc symbol index to it.  Don't allow gd syms in shared libs
	to be optimized.
	(ppc64_elf_tls_optimize): Adjust get_tls_mask call.
	(ppc64_elf_size_stubs): Likewise.
	(ppc64_elf_relocate_section): Check that tls relocs are only used
	with tls syms, and similarly for non-tls.  Correct symbol used
	when optimizing toc tls code.
@
text
@d5 1
d81 2
d2378 39
d5057 1
a5057 1
			      r_symndx, ibfd))	
d5133 1
a5133 1
				*pp = p->next;	
@


1.131
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d4794 2
a4795 1
get_tls_mask (char **tls_maskp, Elf_Internal_Sym **locsymsp,
d4799 1
a4799 1
  unsigned int next_r;
d4828 8
a4835 11
  if (h == NULL
      || h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      if (next_r == (unsigned) -1)
	return 2;
      if (next_r == (unsigned) -2
	  && (h == NULL
	      || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	return 3;
    }
d5319 1
a5319 1
			    retval = get_tls_mask (&toc_tls, &locsyms,
d6903 1
a6903 1
		      if (!get_tls_mask (&tls_mask, &local_syms,
d7309 1
a7309 1
      unsigned long r_symndx;
d7311 1
d7345 1
d7363 1
d7372 1
d7383 36
d7433 1
d7448 2
a7449 1
	    retval = get_tls_mask (&toc_tls, &local_syms, rel, input_bfd);
d7494 10
a7503 1
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
a7507 11
	  if (tls_mask == 0)
	    {
	      /* Check for toc tls entries.  */
	      char *toc_tls;

	      if (!get_tls_mask (&toc_tls, &local_syms, rel, input_bfd))
		return FALSE;

	      if (toc_tls)
		tls_mask = *toc_tls;
	    }
a7542 2
	      r_type = R_PPC64_TPREL16_LO;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7546 11
d7655 2
d7673 1
a7673 1
		  if (tls_gd == 0)
d7675 2
a7676 2
		      /* We changed the symbol on an LD reloc.  Start over
			 in order to get h, sym, sec etc. right.  */
@


1.130
log
@Better handking for unresolved symbols
@
text
@d2408 7
a2414 14
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".plt",		0,	NULL,	0,
    SHT_NOBITS,		0 },
  { ".toc",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".toc1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".tocbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.129
log
@	* elf64-ppc.c: Don't include elf/ppc.h.
@
text
@d7365 4
a7368 5
	  /* It's a global symbol.  */
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a7369 32
	  relocation = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_offset, (info->executable
				      || info->no_undefined
				      || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      warned = TRUE;
	    }
@


1.128
log
@	* elf64-ppc.c (ppc64_elf_next_input_section): Update comment.
	(ppc64_elf_relocate_section): For zero sym R_PPC64_TOC relocs,
	use the function sym from the previous reloc.
@
text
@a30 1
#include "elf/ppc.h"
@


1.127
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d6611 2
a6612 1
     the correct TOC value.  */
d7331 10
@


1.126
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Add special case for crt1.o
	branch to __libc_start_main.
@
text
@d7387 1
a7387 1
		      rel->r_offset, (!info->shared
@


1.125
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d7791 7
@


1.124
log
@	* elf64-ppc.c (ppc_stub_name): Tweak names for better readability.
	(ppc64_elf_adjust_dynamic_symbol): Allow copy relocs against
	function descriptors, but warn.
	(ppc_build_one_stub): Remove a couple of vars.  Move code creating
	stub syms so that we can avoid a stub sym if we already have a
	plt sym.  Do not redefine an existing symbol.
	(ppc64_elf_build_stubs): When --emit-stub-syms, print a symbol for
	glink.
@
text
@d3280 4
a3283 3
ppc64_elf_copy_indirect_symbol (struct elf_backend_data *bed ATTRIBUTE_UNUSED,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
@


1.123
log
@	* elf.c (bfd_section_from_r_symndx): Test for SHN_UNDEF.
	* elf64-ppc.c (get_fdh): New function, split out from
	ppc64_elf_edit_opd.
	(ppc64_elf_check_relocs): Use get_fdh.
	(func_desc_adjust): Likewise.  Tidy.
	(ppc64_elf_edit_opd): Tighten reloc checks.  Free local_syms on error
	exit.  Use get_fdh.  Account for superfluous dynamic relocs.
	(ppc64_elf_relocate_section): Warning fix.
@
text
@d3039 1
a3039 1
	  sprintf (stub_name, "%08x_%s+%x",
d3051 1
a3051 1
	  sprintf (stub_name, "%08x_%x:%x+%x",
d4586 11
a4596 1
    return TRUE;
a6108 2
  asection *stub_sec;
  bfd *stub_bfd;
a6120 1
  stub_sec = stub_entry->stub_sec;
d6123 2
a6124 20
  stub_entry->stub_offset = stub_sec->_cooked_size;
  loc = stub_sec->contents + stub_entry->stub_offset;

  if (htab->emit_stub_syms)
    {
      struct elf_link_hash_entry *h;
      h = elf_link_hash_lookup (&htab->elf, stub_entry->root.string,
				TRUE, FALSE, FALSE);
      if (h == NULL)
	return FALSE;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = stub_entry->stub_sec;
      h->root.u.def.value = stub_entry->stub_offset;
      h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
				| ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR_NONWEAK
				| ELF_LINK_FORCED_LOCAL);
    }

  stub_bfd = stub_sec->owner;
d6138 2
a6139 2
	      + stub_sec->output_offset
	      + stub_sec->output_section->vma);
d6149 1
a6149 1
	  bfd_put_32 (stub_bfd, STD_R2_40R1, loc);
d6151 1
a6151 1
	  bfd_put_32 (stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6153 1
a6153 1
	  bfd_put_32 (stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
d6158 1
a6158 1
      bfd_put_32 (stub_bfd, B_DOT | (off & 0x3fffffc), loc);
d6219 1
a6219 1
	  bfd_put_32 (stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d6221 1
a6221 1
	  bfd_put_32 (stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d6230 1
a6230 1
	  bfd_put_32 (stub_bfd, STD_R2_40R1, loc);
d6232 1
a6232 1
	  bfd_put_32 (stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d6234 1
a6234 1
	  bfd_put_32 (stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d6236 1
a6236 1
	  bfd_put_32 (stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6238 1
a6238 1
	  bfd_put_32 (stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
d6242 1
a6242 1
      bfd_put_32 (stub_bfd, MTCTR_R11, loc);
d6244 1
a6244 1
      bfd_put_32 (stub_bfd, BCTR, loc);
d6291 1
a6291 1
      p = build_plt_stub (stub_bfd, loc, off);
d6300 25
a6324 1
  stub_sec->_cooked_size += size;
d7110 17
@


1.122
log
@	* elf64-ppc.c (func_desc_adjust): Give linker created function
	descriptor symbols a size and type.
	(ppc64_elf_relocate_section): Correct lq insn test.
@
text
@d3512 25
d3865 1
a3865 2
	    {
	      struct elf_link_hash_entry *fdh;
a3866 10
	      fdh = elf_link_hash_lookup (&htab->elf, h->root.root.string + 1,
					  FALSE, FALSE, FALSE);
	      if (fdh != NULL)
		{
		  ((struct ppc_link_hash_entry *) fdh)->is_func_descriptor = 1;
		  ((struct ppc_link_hash_entry *) fdh)->oh = h;
		  ((struct ppc_link_hash_entry *) h)->is_func = 1;
		  ((struct ppc_link_hash_entry *) h)->oh = fdh;
		}
	    }
d4264 3
d4268 2
a4269 1
  if (h->root.type == bfd_link_hash_indirect)
d4272 2
a4273 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d4280 1
a4280 1
  if (!((struct ppc_link_hash_entry *) h)->is_func)
d4283 2
a4284 2
  if (h->root.type == bfd_link_hash_undefweak
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR))
d4287 1
a4287 1
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
d4290 36
a4325 52
  if (ent != NULL
      && h->root.root.string[0] == '.'
      && h->root.root.string[1] != '\0')
    {
      struct elf_link_hash_entry *fdh = ((struct ppc_link_hash_entry *) h)->oh;
      bfd_boolean force_local;

      /* Find the corresponding function descriptor symbol.  Create it
	 as undefined if necessary.  */

      if (fdh == NULL)
	fdh = elf_link_hash_lookup (&htab->elf, h->root.root.string + 1,
				    FALSE, FALSE, TRUE);

      if (fdh == NULL
	  && info->shared
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak))
	{
	  bfd *abfd;
	  asymbol *newsym;
	  struct bfd_link_hash_entry *bh;

	  abfd = h->root.u.undef.abfd;
	  newsym = bfd_make_empty_symbol (abfd);
	  newsym->name = h->root.root.string + 1;
	  newsym->section = bfd_und_section_ptr;
	  newsym->value = 0;
	  newsym->flags = BSF_OBJECT;
	  if (h->root.type == bfd_link_hash_undefweak)
	    newsym->flags |= BSF_WEAK;

	  bh = &fdh->root;
	  if ( !(_bfd_generic_link_add_one_symbol
		 (info, abfd, newsym->name, newsym->flags,
		  newsym->section, newsym->value, NULL, FALSE, FALSE, &bh)))
	    {
	      return FALSE;
	    }
	  fdh = (struct elf_link_hash_entry *) bh;
	  fdh->elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
	  fdh->size = 24;
	  fdh->type = STT_OBJECT;
	}

      if (fdh != NULL
	  && (fdh->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
	  && (info->shared
	      || (fdh->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	      || (fdh->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
	      || (fdh->root.type == bfd_link_hash_undefweak
		  && ELF_ST_VISIBILITY (fdh->other) == STV_DEFAULT)))
d4327 48
a4374 35
	  if (fdh->dynindx == -1)
	    if (! bfd_elf64_link_record_dynamic_symbol (info, fdh))
	      return FALSE;
	  fdh->elf_link_hash_flags |= (h->elf_link_hash_flags
				       & (ELF_LINK_HASH_REF_REGULAR
					  | ELF_LINK_HASH_REF_DYNAMIC
					  | ELF_LINK_HASH_REF_REGULAR_NONWEAK
					  | ELF_LINK_NON_GOT_REF));
	  if (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    {
	      fdh->plt.plist = h->plt.plist;
	      fdh->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    }
	  ((struct ppc_link_hash_entry *) fdh)->is_func_descriptor = 1;
	  ((struct ppc_link_hash_entry *) fdh)->oh = h;
	  ((struct ppc_link_hash_entry *) h)->oh = fdh;
	}

      /* Now that the info is on the function descriptor, clear the
	 function code sym info.  Any function code syms for which we
	 don't have a definition in a regular file, we force local.
	 This prevents a shared library from exporting syms that have
	 been imported from another library.  Function code syms that
	 are really in the library we must leave global to prevent the
	 linker dragging in a definition from a static library.  */
      force_local = (info->shared
		     && ((h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0
			 || fdh == NULL
			 || (fdh->elf_link_hash_flags
			     & ELF_LINK_HASH_DEF_REGULAR) == 0
			 || (fdh->elf_link_hash_flags
			     & ELF_LINK_FORCED_LOCAL) != 0));
      _bfd_elf_link_hash_hide_symbol (info, h, force_local);
    }
d4892 1
a4892 1
      for (rel = relstart; rel < relend; rel++)
d4903 3
a4905 20
	  r_type = ELF64_R_TYPE (rel->r_info);
	  if (r_type == R_PPC64_TOC)
	    continue;

	  if (r_type != R_PPC64_ADDR64)
	    {
	      (*_bfd_error_handler)
		(_("%s: unexpected reloc type %u in .opd section"),
		 bfd_archive_filename (ibfd), r_type);
	      need_edit = FALSE;
	      break;
	    }

	  if (rel + 1 >= relend)
	    continue;
	  r_type = ELF64_R_TYPE ((rel + 1)->r_info);
	  if (r_type != R_PPC64_TOC)
	    continue;

	  if (rel->r_offset != offset)
d4919 10
d4932 1
a4932 1
	    goto error_free_rel;
d4962 5
d4986 1
a4989 1
		error_free_rel:
d5007 10
d5019 4
a5022 8
		  unsigned long r_symndx;
		  asection *sym_sec;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;

		  r_symndx = ELF64_R_SYM (rel->r_info);
		  get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			     r_symndx, ibfd);
a5031 21
			  struct ppc_link_hash_entry *fdh;
			  struct ppc_link_hash_entry *fh;

			  fh = (struct ppc_link_hash_entry *) h;
			  fdh = (struct ppc_link_hash_entry *) fh->oh;
			  if (fdh == NULL)
			    {
			      const char *fd_name;
			      struct ppc_link_hash_table *htab;

			      fd_name = h->root.root.string + 1;
			      htab = ppc_hash_table (info);
			      fdh = (struct ppc_link_hash_entry *)
				elf_link_hash_lookup (&htab->elf, fd_name,
						      FALSE, FALSE, FALSE);
			      fdh->is_func_descriptor = 1;
			      fdh->oh = &fh->elf;
			      fh->is_func = 1;
			      fh->oh = &fdh->elf;
			    }

a5045 21
			  struct ppc_link_hash_entry *fdh;
			  struct ppc_link_hash_entry *fh;

			  fh = (struct ppc_link_hash_entry *) h;
			  fdh = (struct ppc_link_hash_entry *) fh->oh;
			  if (fdh == NULL)
			    {
			      const char *fd_name;
			      struct ppc_link_hash_table *htab;

			      fd_name = h->root.root.string + 1;
			      htab = ppc_hash_table (info);
			      fdh = (struct ppc_link_hash_entry *)
				elf_link_hash_lookup (&htab->elf, fd_name,
						      FALSE, FALSE, FALSE);
			      fdh->is_func_descriptor = 1;
			      fdh->oh = &fh->elf;
			      fh->is_func = 1;
			      fh->oh = &fdh->elf;
			    }

d5067 31
a5097 4
	      /* We need to adjust any reloc offsets to point to the
		 new opd entries.  While we're at it, we may as well
		 remove redundant relocs.  */
	      if (!skip)
d5099 3
d7292 1
a7292 1
      long insn, mask;
a7446 1
	      bfd_vma insn;
d7472 1
a7472 1
	      bfd_vma insn, rtra;
@


1.121
log
@	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Ensure no copy relocs
	on function descriptors.
	(ELIMINATE_COPY_RELOCS): Expand comment.
	(ppc64_elf_special_sections): Move.  Don't include non-ppc64 sections.
	Do include ".toc1".
@
text
@d4313 2
d8439 1
a8439 1
	  if ((insn & (0x3f << 26)) == (56 << 26))
@


1.120
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d2405 20
d2603 12
a2614 1
   shared lib.  */
a4533 3
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

d4568 6
a8797 33

/* Add extra PPC sections -- Note, for now, make .sbss2 and
   .PPC.EMB.sbss0 a normal section, and not a bss section so
   that the linker doesn't crater when trying to make more than
   2 sections.  */

static struct bfd_elf_special_section const ppc64_elf_special_sections[]=
{
  { ".tags",		0,	NULL,	0,
    SHT_ORDERED,	SHF_ALLOC },
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".sdata2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".sbss2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.apuinfo",	0,	NULL,	0,
    SHT_NOTE,		0 },
  { ".PPC.EMB.sdata0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.sbss0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".plt",		0,	NULL,	0,
    SHT_NOBITS,		0 },
  { ".toc",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".tocbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
};
@


1.119
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use..
	(_bfd_elf_symbol_refs_local_p): ..this.  Declare.
	* elflink.c (_bfd_elf_symbol_refs_local_p): New function.
	* elf32-i386.c (elf_i386_relocate_section): Remove h NULL test
	now done in _bfd_elf_symbol_refs_local_p.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d31 1
d94 1
d8764 33
@


1.118
log
@	* elf64-ppc.c (bfd_elf64_mkobject): Define.
	(struct ppc64_elf_obj_tdata): New.
	(ppc64_elf_tdata, ppc64_tlsld_got): Define.
	(ppc64_elf_mkobject): New function.
	(struct got_entry): Add "owner".  Move "tls_type".
	(struct ppc_link_hash_table): Delete "relgot", "tlsld_got".
	(ppc64_elf_init_stub_bfd): New function.
	(create_got_section): Create header .got in dynobj.  Create .got
	and .rela.got in each bfd.  Stash pointers in ppc64_elf_obj_tdata.
	(ppc64_elf_create_dynamic_sections): Don't call create_got_section.
	Look for dynobj .got, and test it.
	(ppc64_elf_copy_indirect_symbol): Adjust for changed got.
	(update_local_sym_info): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	(ppc64_elf_gc_sweep_hook): Likewise.
	(ppc64_elf_tls_optimize): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	(ppc64_elf_next_toc_section): Update comment.
	(toc_adjusting_stub_needed): Remove unneeded cast.
	(ppc64_elf_build_stubs): Check for stub sections in stub bfd by
	testing section flags.
	(ppc64_elf_build_stubs): Likewise.
	(ppc64_elf_size_stubs): Likewise.  Remove stub_bfd param.
	(ppc64_elf_finish_dynamic_sections): Write out got sections.
	(func_desc_adjust): Copy over dynamic info for undef weaks.
	* elf64-ppc.h (ppc64_elf_init_stub_bfd): Declare.
	(ppc64_elf_size_stubs): Update prototype.
	* elflink.h (elf_link_sort_relocs): Use link_orders to find reldyn
	input sections rather than scanning dynobj.
@
text
@d8162 1
a8162 2
		   || (h != NULL
		       && !SYMBOL_CALLS_LOCAL (info, h))))
d8208 1
a8208 2
	      else if (h != NULL
		       && !SYMBOL_REFERENCES_LOCAL (info, h)
d8759 1
a8759 1
  
@


1.117
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d72 1
d2320 34
d2535 12
a2552 4

  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
  char tls_type;
a2764 1
  asection *relgot;
a2779 6
  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;

d2967 17
d3178 2
a3179 2
/* Create .got and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */
d3182 1
a3182 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d3184 16
a3199 1
  struct ppc_link_hash_table *htab;
d3201 4
a3204 1
  if (! _bfd_elf_create_got_section (dynobj, info))
d3207 5
a3211 4
  htab = ppc_hash_table (info);
  htab->got = bfd_get_section_by_name (dynobj, ".got");
  if (!htab->got)
    abort ();
d3213 2
a3214 8
  htab->relgot = bfd_make_section (dynobj, ".rela.got");
  if (!htab->relgot
      || ! bfd_set_section_flags (dynobj, htab->relgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->relgot, 3))
    return FALSE;
a3224 4
  htab = ppc_hash_table (info);
  if (!htab->got && !create_got_section (dynobj, info))
    return FALSE;

d3228 3
d3237 1
a3237 1
  if (!htab->plt || !htab->relplt || !htab->dynbss
d3328 1
d3429 3
a3431 1
	if (ent->addend == r_addend && ent->tls_type == tls_type)
d3441 1
a3531 2
  if (htab->elf.dynobj == NULL)
    htab->elf.dynobj = abfd;
d3557 1
a3557 1
	  htab->tlsld_got.refcount += 1;
d3594 2
a3595 2
	  if (htab->got == NULL
	      && !create_got_section (htab->elf.dynobj, info))
d3606 1
d3617 1
d4126 1
a4126 1
	  htab->tlsld_got.refcount -= 1;
d4168 1
d4286 3
a4288 1
	      || (fdh->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0))
d5213 1
a5213 1
		    htab->tlsld_got.refcount -= 1;
d5351 1
d5507 2
a5508 1
		&& ent->addend == gent->addend)
d5537 1
a5537 1
	    gent->got.offset = htab->tlsld_got.offset;
d5541 1
a5541 1
	s = htab->got;
d5550 1
a5550 1
	  htab->relgot->_raw_size
a5694 10
  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = htab->got->_raw_size;
      htab->got->_raw_size += 16;
      if (info->shared)
	htab->relgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tlsld_got.offset = (bfd_vma) -1;

d5709 14
d5758 2
a5759 2
      s = htab->got;
      srel = htab->relgot;
d5769 1
a5769 1
		    if (htab->tlsld_got.offset == (bfd_vma) -1)
d5771 1
a5771 1
			htab->tlsld_got.offset = s->_raw_size;
d5776 1
a5776 1
		    ent->got.offset = htab->tlsld_got.offset;
d5819 2
a5820 10
      else if (s == htab->got)
	{
	  /* Automatic multiple tocs aren't possible if we are using the
	     GOT.  The GOT is accessed via r2, so we can't adjust r2.
	     FIXME: There's no reason why we couldn't lay out multiple
	     GOTs too.  */
	  if (s->_raw_size > elf_backend_got_header_size)
	    htab->no_multi_toc = 1;
	}
      else if (s == htab->plt
d5878 32
d6428 4
a6431 4
/* The linker repeatedly calls this function for each toc input
   section.  Group input bfds such that the toc within a group
   is less than 64k in size.  Will break with cute linker scripts
   that play games with dot in the output toc section.  */
d6494 1
a6494 1
				      (file_ptr) 0, isec->_raw_size))
a6659 1
		      bfd *stub_bfd,
a6669 1
  htab->stub_bfd = stub_bfd;
d6923 5
a6927 4
	{
	  stub_sec->_raw_size = 0;
	  stub_sec->_cooked_size = 0;
	}
d7013 1
d7019 3
a7021 2
    {
      bfd_size_type size;
d7023 10
a7032 10
      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->_raw_size;
      if (size != 0)
	{
	  stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
	  if (stub_sec->contents == NULL)
	    return FALSE;
	}
      stub_sec->_cooked_size = 0;
    }
d7124 6
a7129 4
    {
      if (stub_sec->_raw_size != stub_sec->_cooked_size)
	break;
    }
d7153 1
a7153 1
	       htab->stub_bfd->section_count,
d7844 1
a7848 3
	    if (htab->got == NULL)
	      abort ();

d7852 1
a7852 1
	      offp = &htab->tlsld_got.offset;
d7884 1
d7892 4
d7907 2
d7915 2
a7916 2
		    outrel.r_offset = (htab->got->output_section->vma
				       + htab->got->output_offset
d7925 2
a7926 2
			    loc = htab->relgot->contents;
			    loc += (htab->relgot->reloc_count++
d7946 1
a7946 1
			loc = htab->got->contents + off;
d7959 2
a7960 2
		    loc = htab->relgot->contents;
		    loc += (htab->relgot->reloc_count++
d7981 1
a7981 1
					htab->got->contents + off + 8);
d7987 1
a7987 1
				htab->got->contents + off);
d7994 1
a7994 1
	    relocation = htab->got->output_offset + off;
d7997 1
a7997 1
	    addend = - TOC_BASE_OFF;
d8739 23
@


1.116
log
@	* elf64-ppc.c (ppc64_elf_func_desc_adjust): Don't allow _savef* and
	_restf* to be satisfied by shared libs, and always force them local.
	(toc_adjusting_stub_needed): Avoid scanning linker created sections.
	Correct test for "bl".
	(ppc64_elf_relocate_section <R_PPC64_TLS>): Correct test for
	primary opcode 31.
@
text
@d7198 1
a7198 1
	  else if (info->shared
@


1.115
log
@Correct spelling of "relocatable".
@
text
@d4290 1
a4290 1
	  && h->root.type == bfd_link_hash_undefined)
d4299 1
a4299 1
	  _bfd_elf_link_hash_hide_symbol (info, h, info->shared);
d4310 1
a4310 1
	  && h->root.type == bfd_link_hash_undefined)
d4320 1
a4320 1
	  _bfd_elf_link_hash_hide_symbol (info, h, info->shared);
d6377 4
d6408 1
a6408 1
      if ((insn & (0x1f << 26)) == (18 << 26)
d7325 1
a7325 1
	      if ((insn & ((31 << 26) | (31 << 11)))
d7328 1
a7328 1
	      else if ((insn & ((31 << 26) | (31 << 16)))
@


1.114
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Add top_id.
	(ppc64_elf_setup_section_lists): Set it.
	(ppc64_elf_relocate_section): Check sym section id against top_id.
	(ppc_build_one_stub): Comment on top_id.
@
text
@d3426 1
a3426 1
  if (info->relocateable)
d5060 1
a5060 1
  if (info->relocateable || info->shared)
d7063 1
a7063 1
   relocateable output file) adjusting the reloc addend as
d7077 1
a7077 1
   When generating relocateable output, this function must handle
d7107 1
a7107 1
  if (info->relocateable)
@


1.113
log
@	* elf64-ppc.c: Convert to C90 function definitions, remove unnecessary
	prototypes and casts.  Replace PTR with void *.  Format copyright.
	Mention ABI links.
	(struct ppc_link_hash_table): Rename sgot, srelgot, splt, srelplt,
	sdynbss, srelbss, sglink, sbrlt and srelbrlt to got, relgot .. relbrlt.
	(ppc_type_of_stub): Make r_type an enum.
	(ppc64_elf_size_stubs): Likewise.
	* elf64-ppc.h: Remove PARAMS macro.
@
text
@d2711 3
d6120 3
a6122 1
	     defined somewhere.  */
d6293 1
d8323 1
@


1.112
log
@	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Reinstate init of
	elf hash tab fields.
@
text
@d18 7
a24 6
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* This file is based on the 64-bit PowerPC ELF ABI.  It is also based
   on the file elf32-ppc.c.  */
a33 6
static void ppc_howto_init
  PARAMS ((void));
static reloc_howto_type *ppc64_elf_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void ppc64_elf_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d35 1
a35 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d37 1
a37 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d39 1
a39 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d41 1
a41 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d43 1
a43 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d45 1
a45 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d47 1
a47 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d49 1
a49 7
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean ppc64_elf_object_p
  PARAMS ((bfd *));
static bfd_boolean ppc64_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean ppc64_elf_new_section_hook
  PARAMS ((bfd *, asection *));
d1850 1
a1850 1
ppc_howto_init ()
d1866 2
a1867 3
ppc64_elf_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1875 1
a1875 1
  switch ((int) code)
d1878 1
a1878 1
      return (reloc_howto_type *) NULL;
d2084 1
a2084 1
  return ppc64_elf_howto_table[(int) r];
d2090 2
a2091 4
ppc64_elf_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d2108 3
a2110 9
ppc64_elf_ha_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2127 3
a2129 9
ppc64_elf_brtaken_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2147 1
a2147 1
  r_type = (enum elf_ppc64_reloc_type) reloc_entry->howto->type;
d2183 1
a2183 1
  bfd_put_32 (abfd, (bfd_vma) insn, (bfd_byte *) data + octets);
d2188 3
a2190 9
ppc64_elf_sectoff_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2205 3
a2207 9
ppc64_elf_sectoff_ha_reloc (abfd, reloc_entry, symbol, data,
			    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2225 3
a2227 9
ppc64_elf_toc_reloc (abfd, reloc_entry, symbol, data,
		     input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2248 3
a2250 9
ppc64_elf_toc_ha_reloc (abfd, reloc_entry, symbol, data,
			input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2274 3
a2276 9
ppc64_elf_toc64_reloc (abfd, reloc_entry, symbol, data,
		       input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2298 3
a2300 9
ppc64_elf_unhandled_reloc (abfd, reloc_entry, symbol, data,
			   input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d2323 1
a2323 2
ppc64_elf_object_p (abfd)
     bfd *abfd;
d2343 1
a2343 3
ppc64_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2353 2
a2354 1
	msg = _("%s: compiled for a big endian system and target is little endian");
d2356 2
a2357 1
	msg = _("%s: compiled for a little endian system and target is big endian");
d2390 1
a2390 3
ppc64_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d2395 1
a2395 1
  sdata = (struct _ppc64_elf_section_data *) bfd_zalloc (abfd, amt);
d2398 1
a2398 1
  sec->used_by_bfd = (PTR) sdata;
d2690 2
a2691 2
  asection * (*add_stub_section) PARAMS ((const char *, asection *));
  void (*layout_sections_again) PARAMS ((void));
d2718 7
a2724 7
  asection *sgot;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
  asection *sglink;
d2726 2
a2727 2
  asection *sbrlt;
  asection *srelbrlt;
a2763 84
static struct bfd_hash_entry *stub_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_hash_entry *branch_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *ppc64_elf_link_hash_table_create
  PARAMS ((bfd *));
static void ppc64_elf_link_hash_table_free
  PARAMS ((struct bfd_link_hash_table *));
static char *ppc_stub_name
  PARAMS ((const asection *, const asection *,
	   const struct ppc_link_hash_entry *, const Elf_Internal_Rela *));
static struct ppc_stub_hash_entry *ppc_get_stub_entry
  PARAMS ((const asection *, const asection *, struct elf_link_hash_entry *,
	   const Elf_Internal_Rela *, struct ppc_link_hash_table *));
static struct ppc_stub_hash_entry *ppc_add_stub
  PARAMS ((const char *, asection *, struct ppc_link_hash_table *));
static bfd_boolean create_linkage_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc64_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void ppc64_elf_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static bfd_boolean update_local_sym_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned long, bfd_vma, int));
static bfd_boolean update_plt_info
  PARAMS ((bfd *, struct ppc_link_hash_entry *, bfd_vma));
static bfd_boolean ppc64_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection * ppc64_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ppc64_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean func_desc_adjust
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean ppc64_elf_func_desc_adjust
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc64_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void ppc64_elf_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
static bfd_boolean get_sym_h
  PARAMS ((struct elf_link_hash_entry **, Elf_Internal_Sym **, asection **,
	   char **, Elf_Internal_Sym **, unsigned long, bfd *));
static int get_tls_mask
  PARAMS ((char **, Elf_Internal_Sym **, const Elf_Internal_Rela *, bfd *));
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static enum elf_reloc_type_class ppc64_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean ppc64_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static enum ppc_stub_type ppc_type_of_stub
  PARAMS ((asection *, const Elf_Internal_Rela *,
	   struct ppc_link_hash_entry **, bfd_vma));
static bfd_byte *build_plt_stub
  PARAMS ((bfd *, bfd_byte *, int));
static bfd_boolean ppc_build_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));
static bfd_boolean ppc_size_one_stub
  PARAMS ((struct bfd_hash_entry *, PTR));
static int toc_adjusting_stub_needed
  PARAMS ((struct bfd_link_info *, asection *));
static void group_sections
  PARAMS ((struct ppc_link_hash_table *, bfd_size_type, bfd_boolean));
static bfd_boolean ppc64_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *info, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	   asection **));
static bfd_boolean ppc64_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean ppc64_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

d2780 3
a2782 4
stub_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d2816 3
a2818 4
branch_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d2847 3
a2849 4
link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d2881 1
a2881 2
ppc64_elf_link_hash_table_create (abfd)
     bfd *abfd;
d2886 1
a2886 1
  htab = (struct ppc_link_hash_table *) bfd_zmalloc (amt);
d2919 1
a2919 2
ppc64_elf_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d2931 4
a2934 5
ppc_stub_name (input_section, sym_sec, h, rel)
     const asection *input_section;
     const asection *sym_sec;
     const struct ppc_link_hash_entry *h;
     const Elf_Internal_Rela *rel;
d2976 5
a2980 6
ppc_get_stub_entry (input_section, sym_sec, hash, rel, htab)
     const asection *input_section;
     const asection *sym_sec;
     struct elf_link_hash_entry *hash;
     const Elf_Internal_Rela *rel;
     struct ppc_link_hash_table *htab;
d3022 3
a3024 4
ppc_add_stub (stub_name, section, htab)
     const char *stub_name;
     asection *section;
     struct ppc_link_hash_table *htab;
d3077 1
a3077 3
create_linkage_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d3094 4
a3097 4
  htab->sglink = bfd_make_section_anyway (dynobj, ".glink");
  if (htab->sglink == NULL
      || ! bfd_set_section_flags (dynobj, htab->sglink, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sglink, 2))
d3103 4
a3106 4
  htab->sbrlt = bfd_make_section_anyway (dynobj, ".branch_lt");
  if (htab->sbrlt == NULL
      || ! bfd_set_section_flags (dynobj, htab->sbrlt, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sbrlt, 3))
d3113 4
a3116 4
      htab->srelbrlt = bfd_make_section_anyway (dynobj, ".rela.branch_lt");
      if (!htab->srelbrlt
	  || ! bfd_set_section_flags (dynobj, htab->srelbrlt, flags)
	  || ! bfd_set_section_alignment (dynobj, htab->srelbrlt, 3))
d3126 1
a3126 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d3134 2
a3135 2
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  if (!htab->sgot)
d3138 3
a3140 3
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (!htab->srelgot
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
d3144 1
a3144 1
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
d3152 1
a3152 3
ppc64_elf_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d3157 1
a3157 1
  if (!htab->sgot && !create_got_section (dynobj, info))
d3163 3
a3165 3
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d3167 1
a3167 1
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d3169 2
a3170 2
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
d3179 3
a3181 3
ppc64_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *dir, *ind;
d3320 1
a3320 2
ppc64_elf_mark_entry_syms (info)
     struct bfd_link_info *info;
d3338 2
a3339 6
update_local_sym_info (abfd, symtab_hdr, r_symndx, r_addend, tls_type)
     bfd *abfd;
     Elf_Internal_Shdr *symtab_hdr;
     unsigned long r_symndx;
     bfd_vma r_addend;
     int tls_type;
d3349 1
a3349 1
      local_got_ents = (struct got_entry **) bfd_zalloc (abfd, size);
d3365 1
a3365 1
	  ent = (struct got_entry *) bfd_alloc (abfd, amt);
d3383 1
a3383 4
update_plt_info (abfd, eh, addend)
     bfd *abfd;
     struct ppc_link_hash_entry *eh;
     bfd_vma addend;
d3393 1
a3393 1
      ent = (struct plt_entry *) bfd_alloc (abfd, amt);
d3412 2
a3413 5
ppc64_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3454 1
a3454 1
      opd_sym_map = (asection **) bfd_zalloc (abfd, amt);
d3480 1
a3480 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d3524 1
a3524 1
	  if (htab->sgot == NULL
d3541 1
a3541 1
		  ent = (struct got_entry *) bfd_alloc (abfd, amt);
d3698 1
a3698 2
	      ppc64_elf_section_data (sec)->t_symndx
		= (unsigned *) bfd_zalloc (abfd, amt);
d3751 1
a3751 2
	      && ((enum elf_ppc64_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info)
		  == R_PPC64_TOC))
d3906 1
a3906 3
		  p = ((struct ppc_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj,
				  (bfd_size_type) sizeof *p));
d3934 5
a3938 6
ppc64_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3947 1
a3947 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d4004 2
a4005 5
ppc64_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d4029 1
a4029 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d4139 1
a4139 3
func_desc_adjust (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d4151 1
a4151 1
  info = (struct bfd_link_info *) inf;
d4262 2
a4263 3
ppc64_elf_func_desc_adjust (obfd, info)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d4321 1
a4321 1
  elf_link_hash_traverse (&htab->elf, func_desc_adjust, (PTR) info);
d4337 1
a4337 1
  p = (bfd_byte *) bfd_alloc (htab->elf.dynobj, htab->sfpr->_raw_size);
d4378 2
a4379 3
ppc64_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d4479 1
a4479 1
      htab->srelbss->_raw_size += sizeof (Elf64_External_Rela);
d4490 1
a4490 1
  s = htab->sdynbss;
d4511 3
a4513 4
ppc64_elf_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
d4567 3
a4569 8
get_sym_h (hp, symp, symsecp, tls_maskp, locsymsp, r_symndx, ibfd)
     struct elf_link_hash_entry **hp;
     Elf_Internal_Sym **symp;
     asection **symsecp;
     char **tls_maskp;
     Elf_Internal_Sym **locsymsp;
     unsigned long r_symndx;
     bfd *ibfd;
d4663 2
a4664 5
get_tls_mask (tls_maskp, locsymsp, rel, ibfd)
     char **tls_maskp;
     Elf_Internal_Sym **locsymsp;
     const Elf_Internal_Rela *rel;
     bfd *ibfd;
d4711 1
a4711 3
ppc64_elf_edit_opd (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
d4737 1
a4737 1
	  adjust = (long *) bfd_zalloc (obfd, amt);
d4740 1
a4740 1
      memset (adjust, 0, (size_t) amt);
d4754 1
a4754 2
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
d4775 1
a4775 1
	  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d4790 1
a4790 1
	  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info);
d4857 1
a4857 1
		  || !bfd_get_section_contents (ibfd, sec, loc, (bfd_vma) 0,
d5016 1
a5016 3
ppc64_elf_tls_setup (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
d5051 1
a5051 3
ppc64_elf_tls_optimize (obfd, info)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d5072 1
a5072 2
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
d5128 1
a5128 2
		r_type
		  = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d5349 1
a5349 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d5380 1
a5380 1
	    s = htab->splt;
d5390 1
a5390 1
	    s = htab->sglink;
d5399 1
a5399 1
	    s = htab->srelplt;
d5464 1
a5464 1
	s = htab->sgot;
d5473 1
a5473 1
	  htab->srelgot->_raw_size
d5562 1
a5562 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d5577 1
a5577 1
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d5591 2
a5592 3
ppc64_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d5620 2
a5621 2
      htab->tlsld_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 16;
d5623 1
a5623 1
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d5677 2
a5678 2
      s = htab->sgot;
      srel = htab->srelgot;
d5721 1
a5721 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d5735 1
a5735 1
      if (s == htab->sbrlt || s == htab->srelbrlt)
d5738 1
a5738 1
      else if (s == htab->sgot)
d5747 2
a5748 2
      else if (s == htab->splt
	       || s == htab->sglink)
d5769 1
a5769 1
	      if (s != htab->srelplt)
d5800 1
a5800 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d5813 1
a5813 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
d5821 1
a5821 1
      if (htab->splt != NULL && htab->splt->_raw_size != 0)
d5848 1
a5848 2
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);
d5864 5
a5868 6
static INLINE enum ppc_stub_type
ppc_type_of_stub (input_sec, rel, hash, destination)
     asection *input_sec;
     const Elf_Internal_Rela *rel;
     struct ppc_link_hash_entry **hash;
     bfd_vma destination;
d5874 1
a5874 1
  unsigned int r_type;
d5906 1
a5906 1
  if (r_type != (unsigned int) R_PPC64_REL24)
d5919 2
a5920 5
static bfd_byte *
build_plt_stub (obfd, p, offset)
     bfd *obfd;
     bfd_byte *p;
     int offset;
d5943 1
a5943 3
ppc_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d5960 1
a5960 1
  info = (struct bfd_link_info *) in_arg;
d5987 1
a5987 1
  htab->stub_count[(int) stub_entry->stub_type - 1] += 1;
d6010 1
a6010 1
	  bfd_put_32 (stub_bfd, (bfd_vma) STD_R2_40R1, loc);
d6012 1
a6012 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6014 1
a6014 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDI_R2_R2 | PPC_LO (r2off), loc);
d6019 1
a6019 1
      bfd_put_32 (stub_bfd, (bfd_vma) B_DOT | (off & 0x3fffffc), loc);
d6041 2
a6042 2
      bfd_put_64 (htab->sbrlt->owner, off,
		  htab->sbrlt->contents + br_entry->offset);
d6051 2
a6052 2
			   + htab->sbrlt->output_offset
			   + htab->sbrlt->output_section->vma);
d6056 3
a6058 3
	  rl = htab->srelbrlt->contents;
	  rl += htab->srelbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->srelbrlt->owner, &rela, rl);
d6062 3
a6064 3
	     + htab->sbrlt->output_offset
	     + htab->sbrlt->output_section->vma
	     - elf_gp (htab->sbrlt->output_section->owner)
d6080 1
a6080 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDIS_R12_R2 | PPC_HA (indx), loc);
d6082 1
a6082 1
	  bfd_put_32 (stub_bfd, (bfd_vma) LD_R11_0R12 | PPC_LO (indx), loc);
d6091 1
a6091 1
	  bfd_put_32 (stub_bfd, (bfd_vma) STD_R2_40R1, loc);
d6093 1
a6093 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDIS_R12_R2 | PPC_HA (indx), loc);
d6095 1
a6095 1
	  bfd_put_32 (stub_bfd, (bfd_vma) LD_R11_0R12 | PPC_LO (indx), loc);
d6097 1
a6097 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6099 1
a6099 1
	  bfd_put_32 (stub_bfd, (bfd_vma) ADDI_R2_R2 | PPC_LO (r2off), loc);
d6103 1
a6103 1
      bfd_put_32 (stub_bfd, (bfd_vma) MTCTR_R11, loc);
d6105 1
a6105 1
      bfd_put_32 (stub_bfd, (bfd_vma) BCTR, loc);
d6135 3
a6137 3
      off += (htab->splt->output_offset
	      + htab->splt->output_section->vma
	      - elf_gp (htab->splt->output_section->owner)
d6150 1
a6150 1
      p = build_plt_stub (stub_bfd, loc, (int) off);
d6168 1
a6168 3
ppc_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d6177 1
a6177 1
  htab = (struct ppc_link_hash_table *) in_arg;
d6191 3
a6193 3
      off += (htab->splt->output_offset
	      + htab->splt->output_section->vma
	      - elf_gp (htab->splt->output_section->owner)
d6197 1
a6197 1
      if (PPC_HA ((int) off + 16) != PPC_HA ((int) off))
d6242 2
a6243 2
	      br_entry->offset = htab->sbrlt->_raw_size;
	      htab->sbrlt->_raw_size += 8;
d6262 1
a6262 3
ppc64_elf_setup_section_lists (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d6271 1
a6271 1
  if (htab->sbrlt == NULL)
d6289 1
a6289 1
  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
d6312 1
a6312 1
  input_list = (asection **) bfd_zmalloc (amt);
d6326 1
a6326 3
ppc64_elf_next_toc_section (info, isec)
     struct bfd_link_info *info;
     asection *isec;
d6348 2
a6349 3
ppc64_elf_reinit_toc (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d6364 1
a6364 3
toc_adjusting_stub_needed (info, isec)
     struct bfd_link_info *info;
     asection *isec;
d6421 1
a6421 3
ppc64_elf_next_input_section (info, isec)
     struct bfd_link_info *info;
     asection *isec;
d6466 3
a6468 4
group_sections (htab, stub_group_size, stubs_always_before_branch)
     struct ppc_link_hash_table *htab;
     bfd_size_type stub_group_size;
     bfd_boolean stubs_always_before_branch;
d6547 6
a6552 8
ppc64_elf_size_stubs (output_bfd, stub_bfd, info, group_size,
		      add_stub_section, layout_sections_again)
     bfd *output_bfd;
     bfd *stub_bfd;
     struct bfd_link_info *info;
     bfd_signed_vma group_size;
     asection * (*add_stub_section) PARAMS ((const char *, asection *));
     void (*layout_sections_again) PARAMS ((void));
d6630 1
a6630 2
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
d6640 2
a6641 1
		  unsigned int r_type, r_indx;
d6656 1
a6656 1
		  if (r_type >= (unsigned int) R_PPC64_max)
d6663 4
a6666 4
		  if (r_type != (unsigned int) R_PPC64_REL24
		      && r_type != (unsigned int) R_PPC64_REL14
		      && r_type != (unsigned int) R_PPC64_REL14_BRTAKEN
		      && r_type != (unsigned int) R_PPC64_REL14_BRNTAKEN)
d6817 2
a6818 2
      htab->sbrlt->_raw_size = 0;
      htab->sbrlt->_cooked_size = 0;
d6838 1
a6838 2
ppc64_elf_toc (obfd)
     bfd *obfd;
d6895 3
a6897 4
ppc64_elf_build_stubs (emit_stub_syms, info, stats)
     bfd_boolean emit_stub_syms;
     struct bfd_link_info *info;
     char **stats;
d6914 1
a6914 1
	  stub_sec->contents = (bfd_byte *) bfd_zalloc (htab->stub_bfd, size);
d6921 1
a6921 1
  if (htab->splt != NULL)
d6927 4
a6930 4
      plt0 = (htab->splt->output_section->vma
	      + htab->splt->output_offset
	      - (htab->sglink->output_section->vma
		 + htab->sglink->output_offset
d6939 2
a6940 2
      p = htab->sglink->contents;
      bfd_put_32 (htab->sglink->owner, MFCTR_R12, p);
d6942 1
a6942 1
      bfd_put_32 (htab->sglink->owner, SLDI_R11_R0_3, p);
d6944 1
a6944 1
      bfd_put_32 (htab->sglink->owner, ADDIC_R2_R0_32K, p);
d6946 1
a6946 1
      bfd_put_32 (htab->sglink->owner, SUB_R12_R12_R11, p);
d6948 1
a6948 1
      bfd_put_32 (htab->sglink->owner, SRADI_R2_R2_63, p);
d6950 1
a6950 1
      bfd_put_32 (htab->sglink->owner, SLDI_R11_R0_2, p);
d6952 1
a6952 1
      bfd_put_32 (htab->sglink->owner, AND_R2_R2_R11, p);
d6954 1
a6954 1
      bfd_put_32 (htab->sglink->owner, SUB_R12_R12_R11, p);
d6956 1
a6956 1
      bfd_put_32 (htab->sglink->owner, ADD_R12_R12_R2, p);
d6958 1
a6958 1
      bfd_put_32 (htab->sglink->owner, ADDIS_R12_R12 | PPC_HA (plt0), p);
d6960 1
a6960 1
      bfd_put_32 (htab->sglink->owner, LD_R11_0R12 | PPC_LO (plt0), p);
d6962 1
a6962 1
      bfd_put_32 (htab->sglink->owner, ADDI_R12_R12 | PPC_LO (plt0), p);
d6964 1
a6964 1
      bfd_put_32 (htab->sglink->owner, LD_R2_0R12 | 8, p);
d6966 1
a6966 1
      bfd_put_32 (htab->sglink->owner, MTCTR_R11, p);
d6968 1
a6968 1
      bfd_put_32 (htab->sglink->owner, LD_R11_0R12 | 16, p);
d6970 1
a6970 1
      bfd_put_32 (htab->sglink->owner, BCTR, p);
d6975 1
a6975 1
      while (p < htab->sglink->contents + htab->sglink->_raw_size)
d6979 1
a6979 1
	      bfd_put_32 (htab->sglink->owner, LI_R0_0 | indx, p);
d6984 1
a6984 1
	      bfd_put_32 (htab->sglink->owner, LIS_R0_0 | PPC_HI (indx), p);
d6986 1
a6986 1
	      bfd_put_32 (htab->sglink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
d6989 2
a6990 2
	  bfd_put_32 (htab->sglink->owner,
		      B_DOT | ((htab->sglink->contents - p) & 0x3fffffc), p);
d6994 1
a6994 1
      htab->sglink->_cooked_size = p - htab->sglink->contents;
d6997 1
a6997 1
  if (htab->sbrlt->_raw_size != 0)
d6999 3
a7001 3
      htab->sbrlt->contents = (bfd_byte *) bfd_zalloc (htab->sbrlt->owner,
						       htab->sbrlt->_raw_size);
      if (htab->sbrlt->contents == NULL)
d7017 1
a7017 1
      || htab->sglink->_raw_size != htab->sglink->_cooked_size)
d7039 5
a7043 5
	       htab->stub_count[(int) ppc_stub_long_branch - 1],
	       htab->stub_count[(int) ppc_stub_long_branch_r2off - 1],
	       htab->stub_count[(int) ppc_stub_plt_branch - 1],
	       htab->stub_count[(int) ppc_stub_plt_branch_r2off - 1],
	       htab->stub_count[(int) ppc_stub_plt_call - 1]);
d7078 8
a7085 10
ppc64_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d7137 1
a7137 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d7139 4
a7142 4
      sym = (Elf_Internal_Sym *) 0;
      sec = (asection *) 0;
      h = (struct elf_link_hash_entry *) 0;
      sym_name = (const char *) 0;
d7400 1
a7400 2
		  r_type2
		    = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel[1].r_info);
d7487 1
a7487 2
		      bfd_put_64 (output_bfd, (bfd_vma) 1,
				  contents + rel->r_offset);
d7497 1
a7497 2
		  bfd_put_64 (output_bfd, (bfd_vma) 1,
			      contents + rel->r_offset);
d7554 1
a7554 1
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + rel->r_offset);
d7585 1
a7585 1
		      bfd_put_32 (input_bfd, (bfd_vma) LD_R2_40R1,
d7733 1
a7733 1
	    if (htab->sgot == NULL)
d7795 2
a7796 2
		    outrel.r_offset = (htab->sgot->output_section->vma
				       + htab->sgot->output_offset
d7805 2
a7806 2
			    loc = htab->srelgot->contents;
			    loc += (htab->srelgot->reloc_count++
d7826 1
a7826 1
			loc = htab->sgot->contents + off;
d7839 2
a7840 2
		    loc = htab->srelgot->contents;
		    loc += (htab->srelgot->reloc_count++
d7861 1
a7861 1
					htab->sgot->contents + off + 8);
d7867 1
a7867 1
				htab->sgot->contents + off);
d7874 1
a7874 1
	    relocation = htab->sgot->output_offset + off;
d7898 1
a7898 1
	  if (htab->splt != NULL)
d7905 2
a7906 2
		    relocation = (htab->splt->output_section->vma
				  + htab->splt->output_offset
d7944 1
a7944 1
	  if (sec != (asection *) 0)
d8182 1
a8182 1
		  else if (ppc64_elf_howto_table[(int) r_type]->pc_relative)
d8211 1
a8211 1
	     ppc64_elf_howto_table[(int) r_type]->name, sym_name);
d8290 1
a8290 1
		 ppc64_elf_howto_table[(int) r_type]->name,
d8367 1
a8367 1
		  && ppc64_elf_howto_table[(int) r_type]->pc_relative)
d8379 1
a8379 1
		    (info, sym_name, ppc64_elf_howto_table[(int) r_type]->name,
d8390 1
a8390 1
		 ppc64_elf_howto_table[(int) r_type]->name,
d8405 4
a8408 5
ppc64_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d8428 3
a8430 3
	    if (htab->splt == NULL
		|| htab->srelplt == NULL
		|| htab->sglink == NULL)
d8435 2
a8436 2
	    rela.r_offset = (htab->splt->output_section->vma
			     + htab->splt->output_offset
d8441 1
a8441 1
	    loc = htab->srelplt->contents;
d8458 1
a8458 1
	  || htab->srelbss == NULL)
d8466 2
a8467 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d8482 1
a8482 2
ppc64_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d8486 1
a8486 1
  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rela->r_info);
d8503 2
a8504 3
ppc64_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d8518 1
a8518 1
      if (sdyn == NULL || htab->sgot == NULL)
d8536 1
a8536 1
	      s = htab->sglink;
d8560 1
a8560 1
	      s = htab->splt;
d8565 1
a8565 1
	      s = htab->srelplt;
d8570 1
a8570 1
	      dyn.d_un.d_val = htab->srelplt->_raw_size;
d8576 1
a8576 1
	      s = htab->srelplt;
d8586 1
a8586 1
	      s = htab->srelplt;
d8599 1
a8599 1
  if (htab->sgot != NULL && htab->sgot->_raw_size != 0)
d8605 1
a8605 1
		  htab->sgot->contents);
d8608 1
a8608 1
      elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize = 8;
d8611 1
a8611 1
  if (htab->splt != NULL && htab->splt->_raw_size != 0)
d8614 1
a8614 1
      elf_section_data (htab->splt->output_section)->this_hdr.sh_entsize
@


1.111
log
@	* elf64-ppc.c (ppc64_elf_reloc_type_lookup): Tidy prototype.
	(ppc64_elf_info_to_howto): Likewise.
	(ppc64_elf_build_stubs): Add "stats" param, and print statistics.
	* elf64-ppc.h (ppc64_elf_build_stubs): Adjust prototype.
@
text
@d3057 9
@


1.110
log
@	* elf64-ppc.c (toc_adjusting_stub_needed): New function.
	(ppc64_elf_next_input_section): Use it here to set has_gp_reloc.
	Return error condition.
	(ppc64_elf_size_stubs): Restrict toc adjusting stubs to sections
	that have has_gp_reloc set.
	(struct ppc_link_hash_table): Add stub_count.
	(ppc_build_one_stub): Increment it.
	(ppc64_elf_link_hash_table_create): zmalloc rather than clearing
	individual fields.
	* elf64-ppc.h (ppc64_elf_next_input_section): Update prototype.
@
text
@d36 1
a36 1
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
d38 1
a38 1
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst));
d7117 1
a7117 1
ppc64_elf_build_stubs (emit_stub_syms, info)
d7120 1
d7246 23
a7268 1
  return !htab->stub_error;
@


1.109
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Accept a symbol on
	R_PPC64_TOC relocs.
@
text
@d2806 3
d2899 2
d3039 1
a3039 1
  htab = (struct ppc_link_hash_table *) bfd_malloc (amt);
a3056 35
  htab->stub_bfd = NULL;
  htab->add_stub_section = NULL;
  htab->layout_sections_again = NULL;
  htab->stub_group = NULL;
  htab->no_multi_toc = 0;
  htab->multi_toc_needed = 0;
  htab->toc_curr = 0;
  htab->sgot = NULL;
  htab->srelgot = NULL;
  htab->splt = NULL;
  htab->srelplt = NULL;
  htab->sdynbss = NULL;
  htab->srelbss = NULL;
  htab->sglink = NULL;
  htab->sfpr = NULL;
  htab->sbrlt = NULL;
  htab->srelbrlt = NULL;
  htab->tls_sec = NULL;
  htab->tls_get_addr = NULL;
  htab->tlsld_got.refcount = 0;
  htab->emit_stub_syms = 0;
  htab->stub_error = 0;
  htab->has_14bit_branch = 0;
  htab->have_undefweak = 0;
  htab->stub_iteration = 0;
  htab->sym_sec.abfd = NULL;
  /* Initializing two fields of the union is just cosmetic.  We really
     only care about glist, but when compiled on a 32-bit host the
     bfd_vma fields are larger.  Setting the bfd_vma to zero makes
     debugger inspection of these fields look nicer.  */
  htab->elf.init_refcount.refcount = 0;
  htab->elf.init_refcount.glist = NULL;
  htab->elf.init_offset.offset = 0;
  htab->elf.init_offset.glist = NULL;

d6194 1
d6572 59
d6636 1
a6636 1
void
d6642 1
d6660 8
a6667 2
    if (elf_gp (isec->owner) != 0)
      htab->toc_curr = elf_gp (isec->owner);
d6673 1
d6945 3
a6947 1
			      != htab->stub_group[section->id].toc_off))
@


1.108
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Do unaligned reloc
	optimizations earlier.
@
text
@d7308 1
a7308 6
      if (r_type == R_PPC64_TOC)
	{
	  /* Relocation value is TOC base.  */
	  relocation = TOCstart + htab->stub_group[input_section->id].toc_off;
	}
      else if (r_symndx < symtab_hdr->sh_info)
d8078 11
d8195 1
a8195 1
	case R_PPC64_TOC:
d8256 2
a8257 1
		       && !is_opd)
@


1.107
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Reinstate top_index.
	Restore previous input_list type.
	(ppc64_elf_link_hash_table_create): Undo last change.
	(ppc64_elf_setup_section_lists): Reinstate code setting up input lists
	per output section, but don't bother with bfd_abs_section marker.
	(ppc64_elf_next_input_section): Adjust for multiple input section
	lists.
	(group_sections): Likewise.
@
text
@d8215 1
d8224 3
a8226 4
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
d8228 1
a8228 1
	      else if (outrel.r_offset == (bfd_vma) -2)
d8230 3
a8232 2
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
d8235 11
a8310 20

	      /* Optimize unaligned reloc use.  */
	      if ((ELF64_R_TYPE (outrel.r_info) == R_PPC64_ADDR64
		   && (outrel.r_offset & 7) != 0)
		  || (ELF64_R_TYPE (outrel.r_info) == R_PPC64_UADDR64
		      && (outrel.r_offset & 7) == 0))
		outrel.r_info ^= (ELF64_R_INFO (0, R_PPC64_ADDR64)
				  ^ ELF64_R_INFO (0, R_PPC64_UADDR64));
	      else if ((ELF64_R_TYPE (outrel.r_info) == R_PPC64_ADDR32
			&& (outrel.r_offset & 3) != 0)
		       || (ELF64_R_TYPE (outrel.r_info) == R_PPC64_UADDR32
			   && (outrel.r_offset & 3) == 0))
		outrel.r_info ^= (ELF64_R_INFO (0, R_PPC64_ADDR32)
				  ^ ELF64_R_INFO (0, R_PPC64_UADDR32));
	      else if ((ELF64_R_TYPE (outrel.r_info) == R_PPC64_ADDR16
			&& (outrel.r_offset & 1) != 0)
		       || (ELF64_R_TYPE (outrel.r_info) == R_PPC64_UADDR16
			   && (outrel.r_offset & 1) == 0))
		outrel.r_info ^= (ELF64_R_INFO (0, R_PPC64_ADDR16)
				  ^ ELF64_R_INFO (0, R_PPC64_UADDR16));
@


1.106
log
@	* elf64-ppc.c (ppc64_elf_relocation_section): Ensure
	*r_offset == r_addend for RELATIVE relocs against .got.
@
text
@d2776 5
a2780 2
  /* List of input code sections used by ppc64_elf_size_stubs.  */
  asection *input_list;
a3058 1
  htab->input_list = NULL;
d6505 1
a6505 1
  int top_id, id;
d6507 1
d6538 19
d6613 2
a6614 1
  if ((isec->output_section->flags & SEC_CODE) != 0)
d6616 1
d6621 2
a6622 2
      PREV_SEC (isec) = htab->input_list;
      htab->input_list = isec;
d6651 2
a6652 2
  asection *tail = htab->input_list;
  while (tail != NULL)
d6654 19
a6672 54
      asection *curr;
      asection *prev;
      bfd_size_type total;
      bfd_boolean big_sec;
      bfd_vma curr_toc;

      curr = tail;
      if (tail->_cooked_size)
	total = tail->_cooked_size;
      else
	total = tail->_raw_size;
      big_sec = total >= stub_group_size;
      curr_toc = htab->stub_group[tail->id].toc_off;

      while ((prev = PREV_SEC (curr)) != NULL
	     && ((total += (curr->output_section->vma
			    + curr->output_offset
			    - prev->output_section->vma
			    - prev->output_offset))
		 < stub_group_size)
	     && htab->stub_group[prev->id].toc_off == curr_toc)
	curr = prev;

      /* OK, the size from the start of CURR to the end is less
	 than stub_group_size and thus can be handled by one stub
	 section.  (or the tail section is itself larger than
	 stub_group_size, in which case we may be toast.)  We
	 should really be keeping track of the total size of stubs
	 added here, as stubs contribute to the final output
	 section size.  That's a little tricky, and this way will
	 only break if stubs added make the total size more than
	 2^25, ie. for the default stub_group_size, if stubs total
	 more than 2097152 bytes, or nearly 75000 plt call stubs.  */
      do
	{
	  prev = PREV_SEC (tail);
	  /* Set up this stub group.  */
	  htab->stub_group[tail->id].link_sec = curr;
	}
      while (tail != curr && (tail = prev) != NULL);

      /* But wait, there's more!  Input sections up to stub_group_size
	 bytes before the stub section can be handled by it too.
	 Don't do this if we have a really large section after the
	 stubs, as adding more stubs increases the chance that
	 branches may not reach into the stub section.  */
      if (!stubs_always_before_branch && !big_sec)
	{
	  total = 0;
	  while (prev != NULL
		 && ((total += (tail->output_section->vma
				+ tail->output_offset
				- prev->output_section->vma
				- prev->output_offset))
d6675 13
a6688 1
	      tail = prev;
d6690 1
d6693 21
a6714 1
      tail = prev;
d6716 2
@


1.105
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Optimize unaligned relocs.
@
text
@d7973 2
a7974 1
			bfd_put_64 (output_bfd, outrel.r_addend, loc);
@


1.104
log
@	* elf64-ppc.c (struct ppc_link_hash_table): Remove top_index.  Modify
	input_list.
	(ppc64_elf_link_hash_table_create): Init input_list here.
	(ppc64_elf_setup_section_lists): Remove code setting up input lists
	per output section.  Set toc_off for abs and other standard sections.
	(ppc64_elf_reinit_toc): Don't set elf_gp on input bfds lacking a toc.
	(ppc64_elf_next_input_section): Adjust for single input section list.
	Don't set toc_curr from input bfds that haven't set elf_gp.
	(group_sections): Adjust for single input section list.
@
text
@d8275 20
@


1.103
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Correct pcrel section zero.
@
text
@d2776 2
a2777 3
  /* Assorted information used by ppc64_elf_size_stubs.  */
  int top_index;
  asection **input_list;
d3056 1
d6503 1
a6503 1
  int top_id, top_index;
a6504 1
  asection **input_list, **list;
d6512 1
a6512 1
  for (input_bfd = info->input_bfds, top_id = 0;
d6530 4
a6534 34

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     _bfd_strip_section_from_output doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = (asection **) bfd_malloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    {
      if ((section->flags & SEC_CODE) != 0)
	input_list[section->index] = NULL;
    }

a6572 2
  bfd *ibfd;
  bfd_vma curr;
d6576 1
a6576 11
  htab->toc_curr = curr = TOC_BASE_OFF;

  /* Set the TOC base in all input bfds.  Some may not have a TOC
     section and thus not be set in ppc64_elf_next_toc_section.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      if (elf_gp (ibfd) == 0)
	elf_gp (ibfd) = curr;
      else
	curr = elf_gp (ibfd);
    }
d6591 1
a6591 1
  if (isec->output_section->index <= htab->top_index)
d6593 1
a6593 4
      asection **list = htab->input_list + isec->output_section->index;
      if (*list != bfd_abs_section_ptr)
	{
	  /* Steal the link_sec pointer for our list.  */
d6595 4
a6598 5
	  /* This happens to make the list in reverse order,
	     which is what we want.  */
	  PREV_SEC (isec) = *list;
	  *list = isec;
	}
d6605 2
a6606 1
    htab->toc_curr = elf_gp (isec->owner);
d6627 2
a6628 2
  asection **list = htab->input_list + htab->top_index;
  do
d6630 54
a6683 21
      asection *tail = *list;
      if (tail == bfd_abs_section_ptr)
	continue;
      while (tail != NULL)
	{
	  asection *curr;
	  asection *prev;
	  bfd_size_type total;
	  bfd_boolean big_sec;
	  bfd_vma curr_toc;

	  curr = tail;
	  if (tail->_cooked_size)
	    total = tail->_cooked_size;
	  else
	    total = tail->_raw_size;
	  big_sec = total >= stub_group_size;
	  curr_toc = htab->stub_group[tail->id].toc_off;

	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
a6685 13
	    curr = prev;

	  /* OK, the size from the start of CURR to the end is less
	     than stub_group_size and thus can be handled by one stub
	     section.  (or the tail section is itself larger than
	     stub_group_size, in which case we may be toast.)  We
	     should really be keeping track of the total size of stubs
	     added here, as stubs contribute to the final output
	     section size.  That's a little tricky, and this way will
	     only break if stubs added make the total size more than
	     2^25, ie. for the default stub_group_size, if stubs total
	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
	  do
d6687 1
a6688 1
	      /* Set up this stub group.  */
a6690 21
	  while (tail != curr && (tail = prev) != NULL);

	  /* But wait, there's more!  Input sections up to stub_group_size
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
	    {
	      total = 0;
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
			 < stub_group_size)
		     && htab->stub_group[prev->id].toc_off == curr_toc)
		{
		  tail = prev;
		  prev = PREV_SEC (tail);
		  htab->stub_group[tail->id].link_sec = curr;
		}
	    }
	  tail = prev;
d6692 1
a6693 2
  while (list-- != htab->input_list);
  free (htab->input_list);
@


1.102
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): When optimizing toctprel
	tls, check that a TOC16_DS or TOC16_LO_DS reloc isn't pointing to a
	dtprel entry.  Ensure TLS_LD DTPMOD reloc has a zero addend.  Write
	got section for RELATIVE relocs.  Fix wrong comment.  Change condition
	under which dynamic relocs update the section contents.
@
text
@d8352 3
a8354 1
		    addend = outrel.r_offset;
@


1.101
log
@Add "attn", "lq" and "stq" power4 insns.
@
text
@d7448 5
a7452 1
		  goto toctprel;
a7474 1
	toctprel:
d7479 1
d7992 1
d8005 1
d8015 8
a8022 1
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);
d8025 2
a8026 2
		    outrel.r_addend = rel->r_addend;
		    if (indx == 0)
d8039 1
a8039 2
		   emitting a reloc.  A reloc will also init the
		   section contents via _bfd_final_link_relocate.  */
a8268 3
		  /* We need to relocate .opd contents for ld.so, and
		     it doesn't hurt to relocate in other cases.  */
		  relocate = TRUE;
d8286 6
d8333 2
a8334 1
		 anything now.  */
d8336 18
a8353 1
		continue;
@


1.100
log
@	* elf64-ppc.c: Move TARGET_LITTLE_SYM and other macros used by
	elfxx-target.h so that we can use elf_backend_got_header_size.
	(ELF_MACHINE_ALT1, ELF_MACHINE_ALT2): Delete.
	(GLINK_CALL_STUB_SIZE): Modify.  Define new glink call stub and
	associated macros.
	(ppc64_elf_howto_raw <GOT_TPREL16_DS, GOT_TPREL16_LO_DS>): Correct
	dst_mask.
	(enum ppc_stub_type): Add ppc_stub_long_branch_r2off and
	ppc_stub_plt_branch_r2off.
	(struct ppc_stub_hash_entry): Reorganize.
	(struct ppc_link_hash_table): Add no_multi_toc, multi_toc_needed,
	toc_curr, toc_off and emit_stub_syms.
	(ppc64_elf_link_hash_table_create): Init them.
	(ppc_stub_name): Correct string size.
	(ppc64_elf_check_relocs): Set has_gp_reloc on GOT and TOC relocs.
	(ppc64_elf_size_dynamic_sections): Set no_multi_toc if GOT entries
	used.
	(ppc_type_of_stub): Tweak root.type test.
	(build_plt_stub): Remove glink code.  Adjust for insn macro changes.
	(ppc_size_one_stub): Handle ppc_stub_long_branch_r2off and
	ppc_stub_plt_branch_r2off.
	(ppc_build_one_stub): Likewise.  Fix var shadowing.  Correct addis,addi
	range test.  Use toc_off to calculte r2 values.  Handle emit_stub_syms.
	(ppc64_elf_setup_section_lists): Remove htab creator flavour test.
	Initialize elf_gp and toc_curr.
	(ppc64_elf_next_toc_section, ppc64_elf_reinit_toc): New functions.
	(ppc64_elf_next_input_section): Set toc_off.
	(group_sections): Ensure groups have the same TOC.
	(ppc64_elf_size_stubs): Check whether we need a TOC adjusting stub.
	(ppc64_elf_build_stubs): Add emit_stub_syms param, and stash in htab.
	Build new glink stub.
	(ppc64_elf_relocate_section): Handle multiple TOCs.  Fix comments.
	(ppc64_elf_finish_dynamic_sections): Adjust DT_PPC64_GLINK.
	* elf64-ppc.h (ppc64_elf_build_stubs): Update prototype.
	(ppc64_elf_next_toc_section, ppc64_elf_reinit_toc): Declare.
	* section.c (struct sec): Rename flag12 to has_gp_reloc.
	(STD_SECTION): Update.
	* ecoff.c (bfd_debug_section): Update comment.
	* bfd-in2.h: Regenerate.
@
text
@d7318 1
a7318 1
      long insn;
d8409 11
a8419 1
	  if (((relocation + addend) & 3) != 0)
d8422 1
a8422 1
		(_("%s: error: relocation %s not a multiple of 4"),
d8424 2
a8425 1
		 ppc64_elf_howto_table[(int) r_type]->name);
@


1.99
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d63 41
d121 4
a124 1
/* .plt call stub instructions.  */
a132 2
/* The normal stub is this size.  */
#define PLT_CALL_STUB_SIZE (7*4)
d134 4
a137 7
/* But sometimes the .plt entry crosses a 64k boundary, and we need
   to adjust the high word with this insn.  */
#define ADDIS_R12_R12_1	0x3d8c0001	/* addis %r12,%r12,1	*/

/* The .glink fixup call stub is the same as the .plt call stub, but
   the first instruction restores r2, and the std is omitted.  */
#define LD_R2_40R1	0xe8410028	/* ld    %r2,40(%r1)	*/
d139 19
a157 2
/* Always allow this much space.  */
#define GLINK_CALL_STUB_SIZE (8*4)
d1777 1
a1777 1
	 0xffff,		/* dst_mask */
d1792 1
a1792 1
	 0xffff,		/* dst_mask */
d2633 17
d2655 1
d2657 1
d2666 2
a2678 2
  enum ppc_stub_type stub_type;

d2765 2
d2769 7
d2804 3
d2889 1
a2889 1
  PARAMS ((bfd *, bfd_byte *, int, int));
d2944 1
a2948 1
      eh->stub_type = ppc_stub_none;
d3054 3
d3070 1
d3132 1
a3132 1
      len = 8 + 1 + 8 + 1 + 8 + 1 + 16 + 1;
d3716 1
a3784 6
	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_HI:
	case R_PPC64_TOC16_HA:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
d3797 10
d4871 1
a4871 1
   type suitable for optimization, and 1 otherwise.  */  
d5966 9
a5975 1
	       || s == htab->sgot
d6121 2
a6122 2
      if (h->elf.root.type == bfd_link_hash_undefweak
	  || h->elf.root.type == bfd_link_hash_undefined)
d6150 1
a6150 1
build_plt_stub (obfd, p, offset, glink)
a6153 1
     int glink;
a6158 2
  if (glink)
    bfd_put_32 (obfd, LD_R2_40R1, p),			p += 4;
d6160 1
a6160 2
  if (!glink)
    bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d6163 1
a6163 1
    bfd_put_32 (obfd, ADDIS_R12_R12_1, p),		p += 4;
d6167 1
a6167 1
    bfd_put_32 (obfd, ADDIS_R12_R12_1, p),		p += 4;
d6204 16
d6225 1
d6236 5
a6240 1
      BFD_ASSERT (off + (1 << 25) < (bfd_vma) (1 << 26));
d6242 11
d6254 2
a6255 1
      size = 4;
d6259 1
d6282 1
a6282 1
	  bfd_byte *loc;
d6290 3
a6292 3
	  loc = htab->srelbrlt->contents;
	  loc += htab->srelbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->srelbrlt->owner, &rela, loc);
d6299 1
a6299 1
	     - TOC_BASE_OFF);
d6301 1
a6301 1
      if (off + 0x80000000 > 0xffffffff || (off & 7) != 0)
d6312 28
a6339 5
      bfd_put_32 (stub_bfd, (bfd_vma) ADDIS_R12_R2 | PPC_HA (indx), loc);
      bfd_put_32 (stub_bfd, (bfd_vma) LD_R11_0R12 | PPC_LO (indx), loc + 4);
      bfd_put_32 (stub_bfd, (bfd_vma) MTCTR_R11, loc + 8);
      bfd_put_32 (stub_bfd, (bfd_vma) BCTR, loc + 12);
      size = 16;
d6372 1
a6372 1
	      - TOC_BASE_OFF);
d6374 1
a6374 1
      if (off + 0x80000000 > 0xffffffff || (off & 7) != 0)
d6384 1
a6384 1
      p = build_plt_stub (stub_bfd, loc, (int) off, 0);
d6430 1
a6430 1
	      - TOC_BASE_OFF);
d6432 1
a6432 1
      size = 28;
d6438 2
a6439 4
      /* ppc_stub_long_branch or ppc_stub_plt_branch.  */
      stub_entry->stub_type = ppc_stub_long_branch;
      size = 4;

d6447 13
d6481 2
a6482 1
	  stub_entry->stub_type = ppc_stub_plt_branch;
d6484 2
d6509 1
a6509 2
  if (htab->elf.root.creator->flavour != bfd_target_elf_flavour
      || htab->sbrlt == NULL)
d6531 2
d6569 53
d6647 11
d6685 1
d6693 1
d6697 2
a6698 1
		     < stub_group_size))
d6729 2
a6730 1
			 < stub_group_size))
d6919 16
d6987 1
a6989 1
		  stub_entry->stub_type = stub_type;
d7101 2
a7102 1
ppc64_elf_build_stubs (info)
a7106 1
  bfd_vma plt_r2;
d7109 1
d7130 1
d7133 6
a7138 7
      plt_r2 = (htab->splt->output_offset
		+ htab->splt->output_section->vma
		- elf_gp (htab->splt->output_section->owner)
		- TOC_BASE_OFF);
      p = htab->sglink->contents;
      p = build_plt_stub (htab->sglink->owner, p, (int) plt_r2, 1);
      while (p < htab->sglink->contents + GLINK_CALL_STUB_SIZE)
d7140 3
a7142 2
	  bfd_put_32 (htab->sglink->owner, NOP, p);
	  p += 4;
d7145 34
d7334 2
a7335 2
	  /* Relocation value is TOC base.  Symbol is ignored.  */
	  relocation = TOCstart + TOC_BASE_OFF;
d7655 1
a7655 1
			 in order to get h, sym, sec etc. right.  */ 
d7748 13
a7760 8
	  /* A REL24 branching to a linkage function is followed by a
	     nop.  We replace the nop with a ld in order to restore
	     the TOC base pointer.  Only calls to shared objects need
	     to alter the TOC base.  These are recognized by their
	     need for a PLT entry.  */
	  if (h != NULL
	      && (fdh = ((struct ppc_link_hash_entry *) h)->oh) != NULL
	      && fdh->plt.plist != NULL
d7762 4
a7765 1
						   rel, htab)) != NULL)
d7783 36
a7818 5
		  /* If this is a plain branch rather than a branch
		     and link, don't require a nop.  */
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  if ((insn & 1) == 0)
		    can_plt_call = 1;
d7826 2
a7827 1
		  unresolved_reloc = FALSE;
d8025 3
a8027 2
		/* Init the .got section contents if we're not
		   emitting a reloc.  */
d8104 1
a8104 1
	  addend -= TOCstart + TOC_BASE_OFF;
d8257 2
a8258 1
		  /* ??? why? */
d8431 3
a8433 2
	  /* If the branch is out of reach, then redirect the
	     call to the local stub for this function.  */
d8437 5
a8441 1
	  if (relocation + addend - from + max_br_offset >= 2 * max_br_offset
d8664 5
a8745 49

#define TARGET_LITTLE_SYM	bfd_elf64_powerpcle_vec
#define TARGET_LITTLE_NAME	"elf64-powerpcle"
#define TARGET_BIG_SYM		bfd_elf64_powerpc_vec
#define TARGET_BIG_NAME		"elf64-powerpc"
#define ELF_ARCH		bfd_arch_powerpc
#define ELF_MACHINE_CODE	EM_PPC64
#define ELF_MAXPAGESIZE		0x10000
#define elf_info_to_howto	ppc64_elf_info_to_howto

#ifdef  EM_CYGNUS_POWERPC
#define ELF_MACHINE_ALT1	EM_CYGNUS_POWERPC
#endif

#ifdef EM_PPC_OLD
#define ELF_MACHINE_ALT2	EM_PPC_OLD
#endif

#define elf_backend_want_got_sym 0
#define elf_backend_want_plt_sym 0
#define elf_backend_plt_alignment 3
#define elf_backend_plt_not_loaded 1
#define elf_backend_got_symbol_offset 0
#define elf_backend_got_header_size 8
#define elf_backend_plt_header_size PLT_INITIAL_ENTRY_SIZE
#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_rela_normal 1

#define bfd_elf64_bfd_reloc_type_lookup	      ppc64_elf_reloc_type_lookup
#define bfd_elf64_bfd_merge_private_bfd_data  ppc64_elf_merge_private_bfd_data
#define bfd_elf64_new_section_hook	      ppc64_elf_new_section_hook
#define bfd_elf64_bfd_link_hash_table_create  ppc64_elf_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free    ppc64_elf_link_hash_table_free

#define elf_backend_object_p		      ppc64_elf_object_p
#define elf_backend_create_dynamic_sections   ppc64_elf_create_dynamic_sections
#define elf_backend_copy_indirect_symbol      ppc64_elf_copy_indirect_symbol
#define elf_backend_check_relocs	      ppc64_elf_check_relocs
#define elf_backend_gc_mark_hook	      ppc64_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	      ppc64_elf_gc_sweep_hook
#define elf_backend_adjust_dynamic_symbol     ppc64_elf_adjust_dynamic_symbol
#define elf_backend_hide_symbol		      ppc64_elf_hide_symbol
#define elf_backend_always_size_sections      ppc64_elf_func_desc_adjust
#define elf_backend_size_dynamic_sections     ppc64_elf_size_dynamic_sections
#define elf_backend_relocate_section	      ppc64_elf_relocate_section
#define elf_backend_finish_dynamic_symbol     ppc64_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class	      ppc64_elf_reloc_type_class
#define elf_backend_finish_dynamic_sections   ppc64_elf_finish_dynamic_sections
@


1.98
log
@	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't test
	dynamic_sections_created here.  Update comment.  Move undefweak
	non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elflink.h (elf_link_output_extsym): Compare ELF_ST_VISIBILITY with
	STV_DEFAULT rather than comparing with zero.
	* elflink.c (_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.  Format comment.
@
text
@d5740 1
a5740 1
      if (! info->shared)
d5939 1
a5939 1
      if (!info->shared)
@


1.97
log
@	* elf32-i386.c (allocate_dynrelocs): Use SYMBOL_CALLS_LOCAL.
	(elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (allocate_dynrelocs): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d4508 3
a4510 4
	  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0))
d5498 1
a5498 3
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h)
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d5621 6
a5626 6
      /* Relocs that use pc_count are those that appear on a call
	 insn, or certain REL relocs (see MUST_BE_DYN_RELOC) that can
	 generated via assembly.  We want calls to protected symbols
	 to resolve directly to the function rather than going via the
	 plt.  If people want function pointer comparisons to work as
	 expected then they should avoid writing weird assembly.  */
@


1.96
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Move from
	elf32-ppc.c.  Add ELF_LINK_FORCED_LOCAL check.
	* elf32-ppc.c: (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Delete.
	(allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL for dynreloc check.
	(ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
	(ppc64_elf_relocate_section): Likewise.  Use for .got relocs too.
	(ppc64_elf_adjust_dynamic_symbol): Don't assume symbols with .plt
	relocs need no other types.
	* elf32-i386.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL for
	dynreloc check.
	(elf_i386_relocate_section): Likewise.  Use for .got relocs too.
	(elf_i386_finish_dynamic_symbol): Use SYMBOL_REFERENCES_LOCAL for
	.got relocs.
@
text
@d5624 7
a5630 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d7883 1
a7883 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.95
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@a4515 1
      return TRUE;
d5624 1
a5624 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d7604 1
a7604 6
			    && (info->symbolic
				|| h->dynindx == -1
				|| (h->elf_link_hash_flags
				    & ELF_LINK_FORCED_LOCAL))
			    && (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR)))
d7877 1
a7877 4
		       && h->dynindx != -1
		       && (! info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d7912 2
a7913 7
		       && h->dynindx != -1
		       && !is_opd
		       && (!MUST_BE_DYN_RELOC (r_type)
			   || !info->shared
			   || !info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
@


1.94
log
@	* elf32-i386.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't make them dynamic, b) discard
	space for dynamic relocs.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.

	* elf32-ppc.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't allocate plt entries, b) don't
	allocate .got relocs, c) discard dyn rel space,
	(ppc_elf_relocate_section): d) don't generate .got relocs, e)
	don't generate dynamic relocs.
	* elf64-ppc.c (allocate_dynrelocs): As above.
	(ppc64_elf_relocate_section): As above.
@
text
@d4876 3
a4878 3
      relstart = _bfd_elf64_link_read_relocs (ibfd, sec, (PTR) NULL,
					      (Elf_Internal_Rela *) NULL,
					      info->keep_memory);
d5199 3
a5201 3
	    relstart = _bfd_elf64_link_read_relocs (ibfd, sec, (PTR) NULL,
						    (Elf_Internal_Rela *) NULL,
						    info->keep_memory);
d6597 3
a6599 3
		= _bfd_elf64_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
@


1.93
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Test whether the
	weakdef sym has already been adjusted before treating it specially.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_check_relocs): Set ELF_LINK_NON_GOT_REF.
@
text
@d5500 3
a5502 1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d5602 4
a5605 2
	if (info->shared
	    || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
d5641 6
d7653 4
a7656 1
		if (info->shared || indx != 0)
d7880 3
@


1.92
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Subtract tls seg vma from
	zero index dynamic tls relocs generated for the GOT.  Tidy code.
	Set "relocation" to 1 on DTPMOD32 relocs.  Optimize HA adjustment.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.

	* ld-powerpc/tlsso.r: Adjust for corrected zero symbol index relocs.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d3275 1
d3320 11
a3330 8
  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */
  edir->elf.elf_link_hash_flags |=
    (eind->elf.elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));
d3336 2
a3337 1
  /* Copy over got entries.  */
d3885 4
@


1.92.12.1
log
@Merge from mainline.
@
text
@a3274 1
  flagword mask;
d3319 8
a3326 11
  mask = (ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF);
  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (ELIMINATE_COPY_RELOCS
      && eind->elf.root.type != bfd_link_hash_indirect
      && (edir->elf.elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    mask &= ~ELF_LINK_NON_GOT_REF;

  edir->elf.elf_link_hash_flags |= eind->elf.elf_link_hash_flags & mask;
d3332 1
a3332 2
  /* Copy over got entries that we may have already seen to the
     symbol which just became indirect.  */
a3879 4
	  if (h != NULL && !info->shared)
	    /* We may need a copy reloc.  */
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

@


1.92.12.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d4508 4
a4511 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d4516 1
d4876 3
a4878 3
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d5199 3
a5201 3
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
						  info->keep_memory);
d5600 2
a5601 4
	if ((info->shared
	     || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	    && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak))
d5621 3
a5623 7
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
a5636 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d6587 3
a6589 3
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d7597 6
a7602 1
			    && SYMBOL_REFERENCES_LOCAL (info, h)))
d7643 1
a7643 4
		if ((info->shared || indx != 0)
		    && (h == NULL
			|| ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			|| h->root.type != bfd_link_hash_undefweak))
a7866 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d7869 4
a7872 1
		       && !SYMBOL_CALLS_LOCAL (info, h))))
d7907 7
a7913 2
		       && !SYMBOL_REFERENCES_LOCAL (info, h)
		       && !is_opd)
@


1.92.14.1
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Test whether the
	weakdef sym has already been adjusted before treating it specially.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_check_relocs): Set ELF_LINK_NON_GOT_REF.
@
text
@a3274 1
  flagword mask;
d3319 8
a3326 11
  mask = (ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF);
  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (ELIMINATE_COPY_RELOCS
      && eind->elf.root.type != bfd_link_hash_indirect
      && (edir->elf.elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    mask &= ~ELF_LINK_NON_GOT_REF;

  edir->elf.elf_link_hash_flags |= eind->elf.elf_link_hash_flags & mask;
d3332 1
a3332 2
  /* Copy over got entries that we may have already seen to the
     symbol which just became indirect.  */
a3879 4
	  if (h != NULL && !info->shared)
	    /* We may need a copy reloc.  */
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

@


1.91
log
@	* elf32-ppc.c (ELIMINATE_COPY_RELOCS): Define as one.
	(ppc_elf_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	* elf64-ppc.c (ELIMINATE_COPY_RELOCS): Define as one.
	(ppc64_elf_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	* elf32-i386.c (ELIMINATE_COPY_RELOCS): Define as one.  Use throughout.
	(elf_i386_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
@
text
@d7641 1
a7642 1
			outrel.r_addend = 0;
d7650 1
a7652 1
			    outrel.r_offset += 8;
d7665 5
a7669 1
		      outrel.r_addend += relocation;
d7805 5
a7819 1
	case R_PPC64_DTPMOD64:
d8039 3
a8041 2
	    /* Add 0x10000 if sign bit in 0:15 is set.  */
	    addend += ((relocation + addend) & 0x8000) << 1;
@


1.91.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d7641 1
a7642 1
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
a7649 1
			    outrel.r_offset += 8;
d7652 1
d7665 1
a7665 5
		      {
			outrel.r_addend += relocation;
			if (tls_type & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			  outrel.r_addend -= htab->tls_sec->vma;
		      }
a7800 5
	case R_PPC64_DTPMOD64:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

d7811 1
d8031 2
a8032 3
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
@


1.90
log
@	* elf32-ppc.c (ppc_elf_create_linker_section): Don't capitalize
	error messages.
	(ELIMINATE_COPY_RELOCS): Define to zero.
	(ppc_elf_relocate_section): Don't deref htab->tls_sec when calculating
	TLSLD relocs.  Report reloc types on a number of errors.  Optimize
	LOCAL24PC check for non-local syms.  Don't capitalize error messages.
	* elf64-ppc.c (ELIMINATE_COPY_RELOCS): Define to zero.
	(ppc64_elf_relocate_section): Don't deref htab->tls_sec when
	calculating TLSLD relocs.  Report reloc types on a number of errors.
	Don't capitalize error messages.
@
text
@d2548 1
a2548 1
#define ELIMINATE_COPY_RELOCS 0
d4521 4
@


1.89
log
@	* elf64-ppc.c (ELIMINATE_COPY_RELOCS): Define.
	(ppc64_elf_check_relocs): Use it.  Correct comment.  Move SEC_ALLOC
	test.
	(ppc64_elf_adjust_dynamic_symbol): Use ELIMINATE_COPY_RELOCS.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.  Use ELIMINATE_COPY_RELOCS.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d2548 1
a2548 1
#define ELIMINATE_COPY_RELOCS 1
d7673 3
a7675 1
		    if (tls_type != 0)
d7678 1
a7678 1
			if ((tls_type & TLS_TPREL) != 0)
d7680 7
a7688 8
		    if ((tls_type & TLS_GD) != 0)
		      {
			bfd_put_64 (output_bfd, relocation,
				    htab->sgot->contents + off + 8);
			relocation = 1;
		      }
		    else if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
d7985 1
a7985 1
	    (_("%s: Relocation %s is not supported for symbol %s."),
d8099 1
a8099 1
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
d8103 1
d8145 1
a8145 1
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
d8148 4
a8151 1
		 (long) rel->r_offset, sym_name, (int) r);
@


1.88
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Remove unnecessary test.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Decrement tlsld_got.refcount
	on invalid LD relocs.
	(allocate_dynrelocs): Invalid LD relocs don't use tlsld_got entry.
	(ppc64_elf_relocate_section): Unify new handling of LD relocs and
	tlsld_got entry.  Use IS_PPC64_TLS_RELOC.
@
text
@d2544 6
d3884 4
d3900 1
a3900 1
	     storing information in the relocs_copied field of the hash
a3910 1
	       && (sec->flags & SEC_ALLOC) != 0
d3917 2
a3918 2
	      || (!info->shared
		  && (sec->flags & SEC_ALLOC) != 0
a4481 2
  struct ppc_link_hash_entry * eh;
  struct ppc_dyn_relocs *p;
d4539 1
a4539 2
  eh = (struct ppc_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d4541 10
a4550 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d4552 7
a4558 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
d5454 1
a5454 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d5456 1
a5456 1
   && ((INFO)->shared							\
d5487 1
a5487 1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d5587 2
a5588 1
	if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d5625 1
a5625 1
  else
d7582 1
a7582 1
		    if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d7851 2
a7852 1
	      || (!info->shared
@


1.87
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Don't init "r".  Don't
	rebuild sym name when reporting errors.
@
text
@d5241 1
a5244 1
		    htab->tlsld_got.refcount -= 1;
d5562 2
a5563 1
	if ((gent->tls_type & TLS_LD) != 0)
d5571 2
a5572 1
	s->_raw_size += (gent->tls_type & eh->tls_mask & TLS_GD) ? 16 : 8;
a6965 20
  if ((htab->tlsld_got.offset & 1) == 0)
    {
      if (info->shared)
	{
	  outrel.r_offset = (htab->sgot->output_section->vma
			     + htab->sgot->output_offset
			     + htab->tlsld_got.offset);
	  outrel.r_info = ELF64_R_INFO (0, R_PPC64_DTPMOD64);
	  outrel.r_addend = 0;

	  loc = htab->srelgot->contents;
	  loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	}
      else
	bfd_put_64 (output_bfd, (bfd_vma) 1,
		    htab->sgot->contents + htab->tlsld_got.offset);

      htab->tlsld_got.offset |= 1;
    }
d7072 1
a7072 1
      if (IS_TLS_RELOC (r_type))
d7550 1
a7550 1
	    struct got_entry *ent;
d7552 1
a7552 1
	    unsigned long indx;
d7557 4
a7560 2
	    if (h != NULL)
	      ent = h->got.glist;
d7563 1
a7563 4
		if (local_got_ents == NULL)
		  abort ();
		ent = local_got_ents[r_symndx];
	      }
d7565 23
a7587 25
	    for (; ent != NULL; ent = ent->next)
	      if (ent->addend == rel->r_addend
		  && ent->tls_type == tls_type)
		break;
	    if (ent == NULL)
	      abort ();

	    off = ent->got.offset;
	    indx = 0;
	    if (h != NULL)
	      {
		bfd_boolean dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
		    || (info->shared
			&& (info->symbolic
			    || h->dynindx == -1
			    || (h->elf_link_hash_flags
				& ELF_LINK_FORCED_LOCAL))
			&& (h->elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR)))
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  */
		  ;
d7590 3
a7592 2
		    indx = h->dynindx;
		    unresolved_reloc = FALSE;
d7594 8
d7607 1
d7615 2
a7616 2
		if ((info->shared || indx != 0)
		    && tls_type != (TLS_TLS | TLS_LD))
d7621 1
a7621 1
		    if (tls_type == (TLS_TLS | TLS_GD))
d7625 11
a7635 6
			loc = htab->srelgot->contents;
			loc += (htab->srelgot->reloc_count++
				* sizeof (Elf64_External_Rela));
			bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
			outrel.r_offset += 8;
d7656 1
a7656 2
		if (!(info->shared || indx != 0)
		    && tls_type != (TLS_TLS | TLS_LD))
d7658 1
a7658 1
		    relocation += ent->addend;
d7672 2
a7676 1
		ent->got.offset |= 1;
@


1.86
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@a7013 1
      r = bfd_reloc_other;
d8107 3
a8109 3
	  const char *name;

	  if (h != NULL)
d8111 4
a8114 1
	      if (h->root.type == bfd_link_hash_undefweak
a8125 13
	      name = h->root.root.string;
	    }
	  else
	    {
	      name = bfd_elf_local_sym_name (input_bfd, sym);
	      if (name == NULL)
		continue;
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (warned)
		continue;
d8127 1
a8127 1
		    (info, name, ppc64_elf_howto_table[(int) r_type]->name,
d8137 1
a8137 1
		 (long) rel->r_offset, name, (int) r);
@


1.85
log
@	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Init tls_get_addr.
	(ppc64_elf_copy_indirect_symbol): Merge tls_mask too.
	(ppc64_elf_gc_sweep_hook): Simplify removal of dyn_relocs.
	(allocate_dynrelocs): Don't treat undefined and undefweak specially.
	(ppc_size_one_stub): Fix warning, and tighten plt entry check.
	(group_sections): Don't share a stub section if stubs are for a large
	section.  Adjust comment.
	(ppc64_elf_size_stubs): Roughly double the size left for stubs if
	!stubs_always_before_branch.
	(ppc64_elf_relocate_section): Initialize tlsld GOT entry once.  Don't
	treat undefined and undefweak specially when processing dyn relocs.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a7069 1
		   && (!info->symbolic || info->allow_shlib_undefined)
d7963 1
a7963 1
	  /* Fall thru */
a8191 1

@


1.84
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Match versioned
	.__tls_get_addr too.
	(ppc64_elf_tls_setup): Ensure cached tls_get_addr is not indirect.
@
text
@d2536 2
a2537 1
   selects those that must be copied when linking a shared library.  */
d2972 1
d3311 1
d4112 1
a4112 1
      struct elf_link_hash_entry *h;
d4117 18
d4176 2
a4177 5
	    if (r_symndx >= symtab_hdr->sh_info)
	      {
		h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		ent = h->got.glist;
	      }
d4201 1
a4201 1
	  if (r_symndx >= symtab_hdr->sh_info)
a4204 1
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
a4214 67
	case R_PPC64_REL30:
	case R_PPC64_REL32:
	case R_PPC64_REL64:
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      struct ppc_link_hash_entry *eh;
	      struct ppc_dyn_relocs **pp;
	      struct ppc_dyn_relocs *p;

	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      eh = (struct ppc_link_hash_entry *) h;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;

	case R_PPC64_DTPMOD64:
	case R_PPC64_DTPREL64:
	case R_PPC64_TPREL64:
	case R_PPC64_ADDR14:
	case R_PPC64_ADDR14_BRNTAKEN:
	case R_PPC64_ADDR14_BRTAKEN:
	case R_PPC64_ADDR16:
	case R_PPC64_ADDR16_DS:
	case R_PPC64_ADDR16_HA:
	case R_PPC64_ADDR16_HI:
	case R_PPC64_ADDR16_HIGHER:
	case R_PPC64_ADDR16_HIGHERA:
	case R_PPC64_ADDR16_HIGHEST:
	case R_PPC64_ADDR16_HIGHESTA:
	case R_PPC64_ADDR16_LO:
	case R_PPC64_ADDR16_LO_DS:
	case R_PPC64_ADDR24:
	case R_PPC64_ADDR32:
	case R_PPC64_ADDR64:
	case R_PPC64_UADDR16:
	case R_PPC64_UADDR32:
	case R_PPC64_UADDR64:
	case R_PPC64_TOC:
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      struct ppc_link_hash_entry *eh;
	      struct ppc_dyn_relocs **pp;
	      struct ppc_dyn_relocs *p;

	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      eh = (struct ppc_link_hash_entry *) h;

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;

d5616 2
a5617 5
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
d6222 1
d6229 1
a6229 1
      if (ent == NULL)
d6409 1
d6416 2
d6432 1
a6432 1
	     more than 2834432 bytes, or over 100000 plt call stubs.  */
d6442 5
a6446 2
	     bytes before the stub section can be handled by it too.  */
	  if (!stubs_always_before_branch)
d6498 12
a6509 3
      stub_group_size = 30720000;
      if (htab->has_14bit_branch)
	stub_group_size = 30000;
d6964 1
a6964 1
  if (info->shared && (htab->tlsld_got.offset & 1) == 0)
d6966 16
a6981 9
      outrel.r_offset = (htab->sgot->output_section->vma
			 + htab->sgot->output_offset
			 + htab->tlsld_got.offset);
      outrel.r_info = ELF64_R_INFO (0, R_PPC64_DTPMOD64);
      outrel.r_addend = 0;

      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a6983 1

d7664 2
a7665 1
		if (!(info->shared || indx != 0))
a7666 1

d7675 1
a7675 1
		    if ((tls_type & (TLS_GD | TLS_LD)) != 0)
a7676 2
			if ((tls_type & TLS_LD) != 0)
			  relocation = - DTP_OFFSET;
d7849 2
a7850 6
		  && (((h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
@


1.83
log
@	* elf64-ppc.c: Rename assorted occurrences of tls_type and similar
	variables, structure fields or function params to tls_mask or
	similar to better reflect usage.
	(struct got_entry): Comment.
	(struct ppc_link_hash_entry):  Expand comment, and renumber TLS_*.
	(get_tls_mask): Rename from get_tls_type.
@
text
@d3729 4
a3732 1
	      else if (strcmp (h->root.root.string, ".__tls_get_addr") == 0)
d5177 12
@


1.82
log
@	* elf64-ppc.c (TLS_GD_LD): Don't define..
	(TLS_GD): ..define this instead and update all uses.
	(TLS_TPRELGD): Define.
	(ppc64_elf_link_hash_table_create): Tweak initialization of
	init_refcount and init_offset.
	(ppc64_elf_check_relocs): Add one extra element to t_symndx array.
	Mark second slot of GD or LD toc entries.
	(get_tls_type): Return an int.  Distinguish toc GD and LD entries
	from other tls types.
	(ppc64_elf_tls_setup): New function, split out from..
	(ppc64_elf_tls_optimize): ..here.  Don't optimize when symbols are
	defined in a dynamic object.  Fix LD optimization.  Don't set TLS_TPREL
	on GD->IE optimization, use TLS_TPRELGD instead.  Use get_tls_type
	return value to properly decide whether toc GD and LD entries can
	optimize away __tls_get_addr call.  Check next reloc after DTPMOD64
	to determine GD or LD rather than looking at TLS_LD flag.  Don't
	attempt to adjust got entry tls_type here..
	(allocate_dynrelocs): ..instead, adjust got entry tls_type here, and
	look for possible merges.
	(ppc64_elf_size_dynamic_sections): Adjust local got entries for
	optimization.
	(ppc64_elf_size_stubs): Tweak __tls_get_addr fudge.
	(ppc64_elf_relocate_section): Rename some vars to better reflect usage.
	Make use of return value from get_tls_type to properly detect GD and
	LD optimizations.  Split tlsld/gd hi/ha from lo/ds case.  Don't
	handle tls_get_addr removal when looking at REL24 relocs, do it when
	looking at the previous reloc.  Check reloc after DTPMOD64 to determine
	GD or LD.
	* elf64-ppc.h (ppc64_elf_tls_setup): Declare.
@
text
@d2506 1
d2509 1
d2516 2
d2640 15
a2654 9
     Linker optimization will result in various transformations.  */
#define TLS_TLS		1	/* Any TLS reloc.  */
#define TLS_GD		2	/* GD reloc. */
#define TLS_LD		4	/* LD reloc. */
#define TLS_TPREL	8	/* TPREL reloc, => IE. */
#define TLS_DTPREL     16	/* DTPREL reloc, => LD. */
#define TLS_EXPLICIT   32	/* Marks TOC section relocs. */
#define TLS_TPRELGD    64	/* TPREL reloc resulting from GD->IE. */
  char tls_type;
d2781 1
a2781 1
static int get_tls_type
d2923 1
a2923 1
      eh->tls_type = 0;
d3424 1
a3424 1
  char *local_got_tls_types;
d3430 1
a3430 1
      size *= sizeof (*local_got_ents) + sizeof (char);
d3459 2
a3460 2
  local_got_tls_types = (char *) (local_got_ents + symtab_hdr->sh_info);
  local_got_tls_types[r_symndx] |= tls_type;
d3638 1
a3638 1
	      eh->tls_type |= tls_type;
d3767 1
a3767 1
	      eh->tls_type |= tls_type;
d3776 1
a3776 1
	      /* One extra to simplify get_tls_type.  */
d4700 1
a4700 1
get_sym_h (hp, symp, symsecp, tlstypep, locsymsp, r_symndx, ibfd)
d4704 1
a4704 1
     char **tlstypep;
d4736 1
a4736 1
      if (tlstypep != NULL)
d4741 1
a4741 1
	  *tlstypep = &eh->tls_type;
d4778 1
a4778 1
      if (tlstypep != NULL)
d4781 1
a4781 1
	  char *tlstype;
d4783 1
a4783 1
	  tlstype = NULL;
d4787 2
a4788 2
	      char *lgot_types = (char *) (lgot_ents + symtab_hdr->sh_info);
	      tlstype = &lgot_types[r_symndx];
d4790 1
a4790 1
	  *tlstypep = tlstype;
d4796 1
a4796 1
/* Returns TLS_TYPE for the given REL symbol.  Function return is 0 on
d4801 2
a4802 2
get_tls_type (tls_type, locsymsp, rel, ibfd)
     char **tls_type;
d4815 1
a4815 1
  if (!get_sym_h (&h, &sym, &sec, tls_type, locsymsp, r_symndx, ibfd))
d4818 1
a4818 1
  if ((*tls_type != NULL && **tls_type != 0)
d4835 1
a4835 1
  if (!get_sym_h (&h, &sym, &sec, tls_type, locsymsp, r_symndx, ibfd))
d5223 2
a5224 2
		char *tls_type;
		char tls_set, tls_clear, got_tls_type = 0;
d5229 1
a5229 1
		if (!get_sym_h (&h, &sym, &sym_sec, &tls_type, &locsyms,
d5283 1
a5283 1
		    got_tls_type = TLS_TLS | TLS_LD;
d5298 1
a5298 1
		    got_tls_type = TLS_TLS | TLS_GD;
d5312 1
a5312 1
			got_tls_type = TLS_TLS | TLS_TPREL;
d5336 1
a5336 1
			    retval = get_tls_type (&toc_tls, &locsyms,
d5414 1
a5414 1
			  && ent->tls_type == got_tls_type)
d5451 2
a5452 2
		*tls_type |= tls_set;
		*tls_type &= ~tls_clear;
d5560 1
a5560 1
  if ((eh->tls_type & TLS_TPRELGD) != 0)
d5605 1
a5605 1
	s->_raw_size += (gent->tls_type & eh->tls_type & TLS_GD) ? 16 : 8;
d5609 1
a5609 1
	    += (gent->tls_type & eh->tls_type & TLS_GD
d5765 1
a5765 1
      char *lgot_types;
d5807 1
a5807 1
      lgot_types = (char *) end_lgot_ents;
d5810 1
a5810 1
      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_types)
d5817 1
a5817 1
		if ((ent->tls_type & *lgot_types & TLS_LD) != 0)
d5831 1
a5831 1
		    if ((ent->tls_type & *lgot_types & TLS_GD) != 0)
d6673 1
a6673 1
		      char *tls_type;
d6675 1
a6675 1
		      if (!get_tls_type (&tls_type, &local_syms,
d6678 1
a6678 1
		      if (*tls_type != 0)
d7111 1
a7111 1
	    tls_mask = ((struct ppc_link_hash_entry *) h)->tls_type;
d7114 3
a7116 3
	      char *lgot_types;
	      lgot_types = (char *) (local_got_ents + symtab_hdr->sh_info);
	      tls_mask = lgot_types[r_symndx];
d7146 1
a7146 1
	    retval = get_tls_type (&toc_tls, &local_syms, rel, input_bfd);
d7198 1
a7198 1
	      if (!get_tls_type (&toc_tls, &local_syms, rel, input_bfd))
d7684 1
a7684 1
		    if ((tls_type & TLS_TLS) != 0)
@


1.81
log
@	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Don't copy got and
	plt info when called to transfer weak sym info.
@
text
@d2638 1
a2638 1
#define TLS_GD_LD	2	/* GD or LD reloc requiring 2 got slots. */
d2643 1
d2771 1
a2771 1
static bfd_boolean get_tls_type
d2967 5
d2973 1
d3566 1
a3566 1
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
d3573 1
a3573 1
	  tls_type = TLS_TLS | TLS_GD_LD;
d3737 1
a3737 1
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD;
d3739 1
a3739 1
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD | TLS_LD;
d3766 2
a3767 1
	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8;
d3775 7
d4108 1
a4108 1
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
d4115 1
a4115 1
	  tls_type = TLS_TLS | TLS_GD_LD;
d4786 5
a4790 1
static bfd_boolean
d4798 1
d4806 1
a4806 1
    return FALSE;
d4811 1
a4811 1
    return TRUE;
d4824 15
a4838 1
  return get_sym_h (&h, &sym, NULL, tls_type, locsymsp, r_symndx, ibfd);
d5147 20
d5176 1
a5176 1
     bfd *obfd;
a5178 1
  asection *tls;
d5183 1
a5183 8
  if (info->relocateable)
    return TRUE;

  for (tls = obfd->sections; tls != NULL; tls = tls->next)
    if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
	== (SEC_THREAD_LOCAL | SEC_LOAD))
      break;
  if (tls == NULL)
a5186 5
  htab->tls_sec = tls;

  if (info->shared)
    return TRUE;

d5216 1
a5216 1
		bfd_boolean ok_tprel;
d5241 1
d5243 3
a5245 1
		if (sym_sec != NULL && sym_sec->output_section != NULL)
d5247 1
d5263 6
d5270 4
a5273 9
		    if (ok_tprel)
		      /* LD -> LE */
		      tls_set = 0;
		    else
		      /* We still need a GOT entry as the offset is
			 too big.  ie. LD -> IE.  */
		      tls_set = TLS_TLS | TLS_TPREL;
		    tls_clear = TLS_GD_LD;
		    got_tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
d5281 1
a5281 8
		    if (ok_tprel
			&& (h == NULL
			    || ((h->elf_link_hash_flags
				 & ELF_LINK_HASH_DEF_REGULAR) != 0
				&& ((h->elf_link_hash_flags
				     & ELF_LINK_FORCED_LOCAL) != 0
				    || !info->shared
				    || info->symbolic))))
d5286 3
a5288 3
		      tls_set = TLS_TLS | TLS_TPREL;
		    tls_clear = TLS_GD_LD;
		    got_tls_type = TLS_TLS | TLS_GD_LD;
d5324 1
d5326 3
a5328 2
			    if (!get_tls_type (&toc_tls, &locsyms,
					       rel - 1, ibfd))
d5331 1
a5331 1
			      expecting_tls_get_addr = *toc_tls != 0;
d5363 4
a5366 1
		    if ((*tls_type & TLS_LD) == 0)
d5368 1
a5368 8
			if ((h == NULL
			     || ((h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_REGULAR) != 0
				 && ((h->elf_link_hash_flags
				      & ELF_LINK_FORCED_LOCAL) != 0
				     || !info->shared
				     || info->symbolic)))
			    && ok_tprel)
d5370 1
a5370 1
			  tls_set = TLS_EXPLICIT;
d5373 2
a5374 2
			  tls_set = TLS_EXPLICIT | TLS_TPREL;
			tls_clear = TLS_GD_LD;
d5378 6
a5383 7
			if (ok_tprel)
			  /* LD -> LE */
			  tls_set = TLS_EXPLICIT;
			else
			  /* LD -> IE */
			  tls_set = TLS_EXPLICIT | TLS_TPREL;
			tls_clear = TLS_GD_LD;
a5414 2
		    else
		      ent->tls_type = tls_set;
d5432 1
a5432 7
			  if (tls_clear == TLS_GD_LD
			      && rel + 1 < relend
			      && (rel[1].r_info
				  == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			      && rel[1].r_offset == rel->r_offset + 8)
			    p->count -= 1;
			  if (tls_set == TLS_EXPLICIT)
d5434 1
d5547 25
d5575 2
d5578 2
a5579 1
	   Undefined weak syms won't yet be marked as dynamic.  */
a5587 2
	  gent->got.offset = htab->tlsld_got.offset;
	else
d5589 3
a5591 1
	    bfd_boolean dyn;
d5593 9
a5601 10
	    s = htab->sgot;
	    gent->got.offset = s->_raw_size;
	    s->_raw_size += (gent->tls_type & TLS_GD_LD) != 0 ? 16 : 8;
	    dyn = htab->elf.dynamic_sections_created;
	    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	      htab->srelgot->_raw_size
		+= ((gent->tls_type & TLS_GD_LD) != 0
		    ? 2 * sizeof (Elf64_External_Rela)
		    : sizeof (Elf64_External_Rela));
	  }
a5605 1
  eh = (struct ppc_link_hash_entry *) h;
d5755 1
d5797 1
d5800 1
a5800 1
      for (; lgot_ents < end_lgot_ents; ++lgot_ents)
d5807 1
a5807 1
		if ((ent->tls_type & TLS_LD) != 0)
d5821 1
a5821 1
		    if ((ent->tls_type & TLS_GD_LD) != 0)
d6668 1
a6668 2
		      if (tls_type != NULL
			  && (*tls_type & (TLS_TLS | TLS_GD_LD)) == TLS_TLS)
a6960 1
  unsigned int tls_get_addr_type;
a6995 1
  tls_get_addr_type = 0;
d7009 1
a7009 1
      char tls_type;
d7092 6
a7097 2
      /* TLS optimizations.  */
      tls_type = 0;
d7101 1
a7101 1
	    tls_type = ((struct ppc_link_hash_entry *) h)->tls_type;
d7106 1
a7106 1
	      tls_type = lgot_types[r_symndx];
a7124 1
	  tls_get_addr_type = 0;
a7130 1
	  tls_get_addr_type = 0;
d7134 1
d7136 2
a7137 1
	    if (!get_tls_type (&toc_tls, &local_syms, rel, input_bfd))
d7142 1
a7142 1
		tls_type = *toc_tls;
d7147 15
a7161 1
		  tls_get_addr_type = tls_type;
a7167 1
	  tls_get_addr_type = 0;
d7169 2
a7170 2
	  if (tls_type != 0
	      && (tls_type & TLS_TPREL) == 0)
d7183 1
a7183 2
	  tls_get_addr_type = 0;
	  if (tls_type == 0)
d7192 1
a7192 1
		tls_type = *toc_tls;
d7194 2
a7195 2
	  if (tls_type != 0
	      && (tls_type & TLS_TPREL) == 0)
d7237 25
d7264 5
a7268 2
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
d7271 1
a7271 4
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_get_addr_type = 0;
	  if (tls_type != 0 && (tls_type & TLS_GD_LD) == 0)
d7273 2
a7274 4
	      if (r_type == R_PPC64_GOT_TLSGD16_HI
		  || r_type == R_PPC64_GOT_TLSGD16_HA
		  || r_type == R_PPC64_GOT_TLSLD16_HI
		  || r_type == R_PPC64_GOT_TLSLD16_HA)
d7276 32
a7307 1
		  if ((tls_type & TLS_LD) != 0)
d7309 11
a7319 3
		      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		      r_type = R_PPC64_NONE;
		      rel->r_offset -= 2;
d7322 34
a7355 4
		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			      + R_PPC64_GOT_TPREL16_DS);
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		  break;
a7356 7

	      /* This reloc and its instruction will be replaced so there's
		 not much point in doing anything more here.  We know the
		 next reloc will be a REL24 to __tls_get_addr, and will
		 be handled below.  */
	      tls_get_addr_type = tls_type;
	      continue;
d7360 6
a7365 16
	case R_PPC64_REL14:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL24:
	  if (h != NULL
	      && h == htab->tls_get_addr
	      && tls_get_addr_type != 0
	      && (tls_get_addr_type & TLS_GD_LD) == 0)
	    {
	      /* Replace the call.  */
	      bfd_vma insn1, insn2, insn3;
	      bfd_vma offset = rel->r_offset;

	      insn1 = bfd_get_32 (output_bfd, contents + rel[-1].r_offset - 2);
	      insn3 = bfd_get_32 (output_bfd, contents + offset + 4);
	      if (tls_get_addr_type & TLS_TPREL)
d7367 3
a7369 8
		  /* IE */
		  insn1 &= (1 << 26) - (1 << 2);
		  insn1 |= 58 << 26;	/* ld */
		  insn2 = 0x7c636a14;	/* add 3,3,13 */
		  /* Fix the relocs for --emit-relocs.  */
		  r_type = ELF64_R_TYPE (rel[-1].r_info);
		  if (tls_get_addr_type & TLS_EXPLICIT)
		    r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
a7370 12
		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			      + R_PPC64_GOT_TPREL16_DS);
		  rel[-1].r_info
		    = ELF64_R_INFO (ELF64_R_SYM (rel[-1].r_info), r_type);
		  rel->r_info = 0;
		}
	      else
		{
		  /* LE */
		  insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		  insn2 = 0x38630000;	/* addi 3,3,0 */
		  if (tls_get_addr_type & TLS_LD)
d7372 3
a7374 3
		      r_symndx = 0;
		      rel[-1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
		      rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
d7376 1
a7376 5
		  else
		    r_symndx = ELF64_R_SYM (rel[-1].r_info);
		  rel[-1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_HA);
		  rel->r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_LO);
		  rel->r_offset += 2;
a7377 14
	      if (insn3 == NOP
		  || insn3 == CROR_151515 || insn3 == CROR_313131)
		{
		  insn3 = insn2;
		  insn2 = NOP;
		  rel->r_offset += 4;
		}
	      bfd_put_32 (output_bfd, insn1, contents + rel[-1].r_offset - 2);
	      bfd_put_32 (output_bfd, insn2, contents + offset);
	      bfd_put_32 (output_bfd, insn3, contents + offset + 4);
	      /* Do the relocs again.  */
	      rel -= 2;
	      tls_get_addr_type = 0;
	      continue;
d7379 1
a7379 5
	  tls_get_addr_type = 0;
	  break;

	case R_PPC64_DTPMOD64:
	  if ((tls_type & TLS_GD_LD) == 0)
d7381 1
a7381 3
	      if ((tls_type & TLS_TPREL) != 0)
		r_type = R_PPC64_TPREL64;
	      else
d7386 1
a7387 3
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	      if ((tls_type & TLS_LD) == 0)
		rel[1].r_info = 0;
d7392 1
a7392 1
	  if ((tls_type & TLS_TPREL) == 0)
d7542 1
a7542 1
	  tls_type = TLS_TLS | TLS_GD_LD;
d7549 1
a7549 1
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
d7635 1
a7635 1
		    && ent->tls_type != (TLS_TLS | TLS_GD_LD | TLS_LD))
d7640 1
a7640 1
		    if (ent->tls_type == (TLS_TLS | TLS_GD_LD))
d7651 1
a7651 1
		    else if (ent->tls_type == (TLS_TLS | TLS_DTPREL))
d7653 1
a7653 1
		    else if (ent->tls_type == (TLS_TLS | TLS_TPREL))
d7659 1
a7659 1
		    outrel.r_addend = ent->addend;
d7681 1
a7681 1
		    if ((tls_type & TLS_GD_LD) != 0)
@


1.80
log
@	* reloc.c: Add PPC and PPC64 TLS relocs.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (TP_OFFSET, DTP_OFFSET): Declare.
	(ppc64_elf_howto_raw): Add TLS howto's.  Adjust R_PPC64_NONE to be
	against a 32 bit field.
	(ppc64_elf_reloc_type_lookup): Handle TLS relocs.
	(_ppc64_elf_section_data): Add t_symndx and comments.
	(ppc64_elf_section_data): Use elf_section_data macro.
	(ppc64_elf_new_section_hook): American spelling.
	(struct got_entry, struct plt_entry): New.
	(MUST_BE_DYN_RELOC): Rename from IS_ABSOLUTE_RELOC.
	(struct ppc_stub_hash_entry): Add "addend" field.
	(struct ppc_link_hash_entry): Add "tls_type".
	(TLS_TLS, TLS_GD_LD, TLS_LD, TLS_TPREL, TLS_DTPREL,
	TLS_EXPLICIT): Define.
	(struct ppc_link_hash_table): Add tls_sec, tls_get_addr, tlsld_got.
	(link_hash_newfunc): Init new fields.
	(ppc64_elf_link_hash_table_create): Likewise.  Set init_relcount and
	init_offset to NULL.
	(ppc64_elf_copy_indirect_symbol): Copy got and plt info.  Don't call
	_bfd_elf_link_hash_copy_indirect, rather insert relevant code from
	there.
	(update_local_sym_info, update_plt_info): New functions.
	(ppc64_elf_check_relocs): Use them.  Handle TLS relocs.  Adjust GOT
	handling to use got.glist rather than got.refcount.  Likewise for PLT.
	(ppc64_elf_gc_sweep_hook): Handle TLS relocs, new GOT and PLT lists.
	(func_desc_adjust): Adjust for new PLT list.
	(ppc64_elf_adjust_dynamic_symbol): Likewise.
	(get_sym_h, get_tls_type): New functions.
	(ppc64_elf_edit_opd): Remove unused variable.  Use get_sym_h.
	(ppc64_elf_tls_optimize): New function.
	(allocate_dynrelocs): Adjust for new PLT and GOT lists.  Allocate
	TLS relocs.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc_type_of_stub): Adjust for new PLT list.
	(ppc_build_one_stub): Likewise.
	(ppc64_elf_size_stubs): Likewise.  Use get_sym_h.  Treat __tls_get_addr
	calls specially.
	(ppc64_elf_relocate_section): Adjust for new GOT and PLT lists.  Handle
	TLS relocs.  Report local syms using bfd_elf_local_sym_name.  Don't
	init GOT entries that have a reloc.  Generate GOT relocs here..
	(ppc64_elf_finish_dynamic_symbol): ..not here.  Adjust for PLT list.
	* elf64-ppc.h (ppc64_elf_tls_optimize): Declare.
@
text
@d3289 18
a3306 1
  /* Do the same for got entries.  */
a3363 16

  edir->is_func |= eind->is_func;
  edir->is_func_descriptor |= eind->is_func_descriptor;
  edir->is_entry |= eind->is_entry;

  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */
  edir->elf.elf_link_hash_flags |=
    (eind->elf.elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));

  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;
@


1.79
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d74 5
a78 1
#define TOC_BASE_OFF (0x8000)
d141 2
a142 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
d910 608
a1517 4
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_toc64_reloc,	/* special_function */
	 "R_PPC64_TOC",		/* name */
d1520 1
a1520 1
	 ONES (64),		/* dst_mask */
d1523 4
a1526 10
  /* Like R_PPC64_GOT16, but also informs the link editor that the
     value to relocate may (!) refer to a PLT entry which the link
     editor (a) may replace with the symbol value.  If the link editor
     is unable to fully resolve the symbol, it may (b) create a PLT
     entry and store the address to the new PLT entry in the GOT.
     This permits lazy resolution of function symbols at run time.
     The link editor may also skip all of this and just (c) emit a
     R_PPC64_GLOB_DAT to tie the symbol to the GOT entry.  */
  /* FIXME: R_PPC64_PLTGOT16 not implemented.  */
    HOWTO (R_PPC64_PLTGOT16,	/* type */
d1534 1
a1534 1
	 "R_PPC64_PLTGOT16",	/* name */
d1540 2
a1541 3
  /* Like R_PPC64_PLTGOT16, but without overflow.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO,	/* type */
d1549 1
a1549 1
	 "R_PPC64_PLTGOT16_LO",	/* name */
d1555 2
a1556 3
  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
  /* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HI,	/* type */
d1564 1
a1564 1
	 "R_PPC64_PLTGOT16_HI",	/* name */
d1570 2
a1571 5
  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus
     1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  /* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HA,	/* type */
d1577 1
a1577 1
	 complain_overflow_dont,/* complain_on_overflow */
d1579 1
a1579 1
	 "R_PPC64_PLTGOT16_HA",	/* name */
d1585 4
a1588 2
  /* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_DS,	/* type */
d1594 3
a1596 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_DS",	/* name */
d1599 1
a1599 1
	 0xfffc,		/* dst_mask */
d1602 2
a1603 2
  /* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_LO_DS,	/* type */
d1609 18
a1626 3
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_LO_DS",/* name */
d1629 1
a1629 1
	 0xfffc,		/* dst_mask */
d1632 3
a1634 3
  /* Like R_PPC64_GOT16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_DS,	/* type */
	 0,			/* rightshift */
d1639 1
a1639 1
	 complain_overflow_signed, /* complain_on_overflow */
d1641 1
a1641 1
	 "R_PPC64_GOT16_DS",	/* name */
d1644 1
a1644 1
	 0xfffc,		/* dst_mask */
d1647 3
a1649 2
  /* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_LO_DS,	/* type */
d1655 1
a1655 1
	 complain_overflow_dont, /* complain_on_overflow */
d1657 1
a1657 1
	 "R_PPC64_GOT16_LO_DS",	/* name */
d1663 2
a1664 2
  /* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_PLT16_LO_DS,	/* type */
d1672 1
a1672 1
	 "R_PPC64_PLT16_LO_DS",	/* name */
d1678 3
a1680 3
  /* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_DS,	/* type */
	 0,			/* rightshift */
d1685 3
a1687 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_DS",	/* name */
d1690 1
a1690 1
	 0xfffc,		/* dst_mask */
d1693 3
a1695 3
  /* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_LO_DS, /* type */
	 0,			/* rightshift */
d1701 2
a1702 2
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_LO_DS",/* name */
d1705 1
a1705 1
	 0xfffc,		/* dst_mask */
d1708 3
a1710 2
  /* Like R_PPC64_TOC16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_DS,	/* type */
d1717 2
a1718 2
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_DS",	/* name */
d1721 1
a1721 1
	 0xfffc,		/* dst_mask */
d1724 2
a1725 2
  /* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_LO_DS,	/* type */
d1732 2
a1733 2
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_LO_DS",	/* name */
d1736 1
a1736 1
	 0xfffc,		/* dst_mask */
d1739 3
a1741 4
  /* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
    HOWTO (R_PPC64_PLTGOT16_DS,	/* type */
	 0,			/* rightshift */
d1746 1
a1746 1
	 complain_overflow_signed, /* complain_on_overflow */
d1748 1
a1748 1
	 "R_PPC64_PLTGOT16_DS",	/* name */
d1751 1
a1751 1
	 0xfffc,		/* dst_mask */
d1754 3
a1756 4
  /* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO_DS,/* type */
	 0,			/* rightshift */
d1763 1
a1763 1
	 "R_PPC64_PLTGOT16_LO_DS",/* name */
d1766 1
a1766 1
	 0xfffc,		/* dst_mask */
d1825 1
a1825 1
  enum elf_ppc64_reloc_type ppc_reloc = R_PPC64_NONE;
d1836 57
a1892 1
    case BFD_RELOC_NONE:		 ppc_reloc = R_PPC64_NONE;
d1894 1
a1894 1
    case BFD_RELOC_32:			 ppc_reloc = R_PPC64_ADDR32;
d1896 1
a1896 1
    case BFD_RELOC_PPC_BA26:		 ppc_reloc = R_PPC64_ADDR24;
d1898 1
a1898 1
    case BFD_RELOC_16:			 ppc_reloc = R_PPC64_ADDR16;
d1900 1
a1900 1
    case BFD_RELOC_LO16:		 ppc_reloc = R_PPC64_ADDR16_LO;
d1902 1
a1902 1
    case BFD_RELOC_HI16:		 ppc_reloc = R_PPC64_ADDR16_HI;
d1904 1
a1904 1
    case BFD_RELOC_HI16_S:		 ppc_reloc = R_PPC64_ADDR16_HA;
d1906 1
a1906 1
    case BFD_RELOC_PPC_BA16:		 ppc_reloc = R_PPC64_ADDR14;
d1908 1
a1908 1
    case BFD_RELOC_PPC_BA16_BRTAKEN:	 ppc_reloc = R_PPC64_ADDR14_BRTAKEN;
d1910 1
a1910 1
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	 ppc_reloc = R_PPC64_ADDR14_BRNTAKEN;
d1912 1
a1912 1
    case BFD_RELOC_PPC_B26:		 ppc_reloc = R_PPC64_REL24;
d1914 1
a1914 1
    case BFD_RELOC_PPC_B16:		 ppc_reloc = R_PPC64_REL14;
d1916 1
a1916 1
    case BFD_RELOC_PPC_B16_BRTAKEN:	 ppc_reloc = R_PPC64_REL14_BRTAKEN;
d1918 1
a1918 1
    case BFD_RELOC_PPC_B16_BRNTAKEN:	 ppc_reloc = R_PPC64_REL14_BRNTAKEN;
d1920 1
a1920 1
    case BFD_RELOC_16_GOTOFF:		 ppc_reloc = R_PPC64_GOT16;
d1922 1
a1922 1
    case BFD_RELOC_LO16_GOTOFF:		 ppc_reloc = R_PPC64_GOT16_LO;
d1924 1
a1924 1
    case BFD_RELOC_HI16_GOTOFF:		 ppc_reloc = R_PPC64_GOT16_HI;
d1926 1
a1926 1
    case BFD_RELOC_HI16_S_GOTOFF:	 ppc_reloc = R_PPC64_GOT16_HA;
d1928 1
a1928 1
    case BFD_RELOC_PPC_COPY:		 ppc_reloc = R_PPC64_COPY;
d1930 1
a1930 1
    case BFD_RELOC_PPC_GLOB_DAT:	 ppc_reloc = R_PPC64_GLOB_DAT;
d1932 1
a1932 1
    case BFD_RELOC_32_PCREL:		 ppc_reloc = R_PPC64_REL32;
d1934 1
a1934 1
    case BFD_RELOC_32_PLTOFF:		 ppc_reloc = R_PPC64_PLT32;
d1936 1
a1936 1
    case BFD_RELOC_32_PLT_PCREL:	 ppc_reloc = R_PPC64_PLTREL32;
d1938 1
a1938 1
    case BFD_RELOC_LO16_PLTOFF:		 ppc_reloc = R_PPC64_PLT16_LO;
d1940 1
a1940 1
    case BFD_RELOC_HI16_PLTOFF:		 ppc_reloc = R_PPC64_PLT16_HI;
d1942 1
a1942 1
    case BFD_RELOC_HI16_S_PLTOFF:	 ppc_reloc = R_PPC64_PLT16_HA;
d1944 1
a1944 1
    case BFD_RELOC_16_BASEREL:		 ppc_reloc = R_PPC64_SECTOFF;
d1946 1
a1946 1
    case BFD_RELOC_LO16_BASEREL:	 ppc_reloc = R_PPC64_SECTOFF_LO;
d1948 1
a1948 1
    case BFD_RELOC_HI16_BASEREL:	 ppc_reloc = R_PPC64_SECTOFF_HI;
d1950 1
a1950 1
    case BFD_RELOC_HI16_S_BASEREL:	 ppc_reloc = R_PPC64_SECTOFF_HA;
d1952 1
a1952 1
    case BFD_RELOC_CTOR:		 ppc_reloc = R_PPC64_ADDR64;
d1954 1
a1954 1
    case BFD_RELOC_64:			 ppc_reloc = R_PPC64_ADDR64;
d1956 1
a1956 1
    case BFD_RELOC_PPC64_HIGHER:	 ppc_reloc = R_PPC64_ADDR16_HIGHER;
d1958 1
a1958 1
    case BFD_RELOC_PPC64_HIGHER_S:	 ppc_reloc = R_PPC64_ADDR16_HIGHERA;
d1960 1
a1960 1
    case BFD_RELOC_PPC64_HIGHEST:	 ppc_reloc = R_PPC64_ADDR16_HIGHEST;
d1962 1
a1962 1
    case BFD_RELOC_PPC64_HIGHEST_S:	 ppc_reloc = R_PPC64_ADDR16_HIGHESTA;
d1964 1
a1964 1
    case BFD_RELOC_64_PCREL:		 ppc_reloc = R_PPC64_REL64;
d1966 1
a1966 1
    case BFD_RELOC_64_PLTOFF:		 ppc_reloc = R_PPC64_PLT64;
d1968 1
a1968 1
    case BFD_RELOC_64_PLT_PCREL:	 ppc_reloc = R_PPC64_PLTREL64;
d1970 1
a1970 1
    case BFD_RELOC_PPC_TOC16:		 ppc_reloc = R_PPC64_TOC16;
d1972 1
a1972 1
    case BFD_RELOC_PPC64_TOC16_LO:	 ppc_reloc = R_PPC64_TOC16_LO;
d1974 1
a1974 1
    case BFD_RELOC_PPC64_TOC16_HI:	 ppc_reloc = R_PPC64_TOC16_HI;
d1976 1
a1976 1
    case BFD_RELOC_PPC64_TOC16_HA:	 ppc_reloc = R_PPC64_TOC16_HA;
d1978 1
a1978 1
    case BFD_RELOC_PPC64_TOC:		 ppc_reloc = R_PPC64_TOC;
d1980 1
a1980 1
    case BFD_RELOC_PPC64_PLTGOT16:	 ppc_reloc = R_PPC64_PLTGOT16;
d1982 1
a1982 1
    case BFD_RELOC_PPC64_PLTGOT16_LO:	 ppc_reloc = R_PPC64_PLTGOT16_LO;
d1984 1
a1984 1
    case BFD_RELOC_PPC64_PLTGOT16_HI:	 ppc_reloc = R_PPC64_PLTGOT16_HI;
d1986 1
a1986 1
    case BFD_RELOC_PPC64_PLTGOT16_HA:	 ppc_reloc = R_PPC64_PLTGOT16_HA;
d1988 1
a1988 1
    case BFD_RELOC_PPC64_ADDR16_DS:      ppc_reloc = R_PPC64_ADDR16_DS;
d1990 1
a1990 1
    case BFD_RELOC_PPC64_ADDR16_LO_DS:   ppc_reloc = R_PPC64_ADDR16_LO_DS;
d1992 1
a1992 1
    case BFD_RELOC_PPC64_GOT16_DS:       ppc_reloc = R_PPC64_GOT16_DS;
d1994 1
a1994 1
    case BFD_RELOC_PPC64_GOT16_LO_DS:    ppc_reloc = R_PPC64_GOT16_LO_DS;
d1996 1
a1996 1
    case BFD_RELOC_PPC64_PLT16_LO_DS:    ppc_reloc = R_PPC64_PLT16_LO_DS;
d1998 1
a1998 1
    case BFD_RELOC_PPC64_SECTOFF_DS:     ppc_reloc = R_PPC64_SECTOFF_DS;
d2000 1
a2000 1
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:  ppc_reloc = R_PPC64_SECTOFF_LO_DS;
d2002 1
a2002 1
    case BFD_RELOC_PPC64_TOC16_DS:       ppc_reloc = R_PPC64_TOC16_DS;
d2004 1
a2004 1
    case BFD_RELOC_PPC64_TOC16_LO_DS:    ppc_reloc = R_PPC64_TOC16_LO_DS;
d2006 1
a2006 1
    case BFD_RELOC_PPC64_PLTGOT16_DS:    ppc_reloc = R_PPC64_PLTGOT16_DS;
d2008 1
a2008 1
    case BFD_RELOC_PPC64_PLTGOT16_LO_DS: ppc_reloc = R_PPC64_PLTGOT16_LO_DS;
d2010 1
a2010 1
    case BFD_RELOC_VTABLE_INHERIT:	 ppc_reloc = R_PPC64_GNU_VTINHERIT;
d2012 25
a2036 1
    case BFD_RELOC_VTABLE_ENTRY:	 ppc_reloc = R_PPC64_GNU_VTENTRY;
d2040 1
a2040 1
  return ppc64_elf_howto_table[(int) ppc_reloc];
d2378 2
d2382 1
d2384 1
d2387 4
d2394 1
a2394 1
  ((struct _ppc64_elf_section_data *) (sec)->used_by_bfd)
d2452 1
a2452 1
   .		addi	12,12,Lfoo@@toc@@l	# is slightly optimised, but
d2500 31
d2532 1
a2532 1
   selects between relative and absolute types.  */
d2534 1
a2534 1
#define IS_ABSOLUTE_RELOC(RTYPE)		\
d2596 3
d2634 10
d2690 12
d2746 4
d2767 5
d2780 1
a2780 1
static INLINE enum ppc_stub_type ppc_type_of_stub
d2912 1
d2959 2
d2966 2
d3246 1
a3246 1
     struct elf_backend_data *bed;
d3254 1
d3262 1
a3262 1
	  if (ind->root.type == bfd_link_hash_indirect)
d3289 59
d3352 21
a3372 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d3392 79
a3470 2
	((struct ppc_link_hash_entry *) h)->is_entry = 1;
    }
d3542 1
d3553 33
a3585 1
	  /* GOT16 relocations */
a3591 1

d3599 2
a3600 5
	      h->got.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_got_refcounts;
d3602 6
a3607 3
	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
d3609 3
a3611 7
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
d3613 5
a3617 1
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
d3619 2
a3620 1
	      local_got_refcounts[r_symndx] += 1;
d3622 5
d3646 4
a3649 4

	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->plt.refcount += 1;
	  ((struct ppc_link_hash_entry *) h)->is_func = 1;
d3667 10
d3706 76
a3781 3
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	      ((struct ppc_link_hash_entry *) h)->is_func = 1;
d3867 1
d3870 1
a3870 1
	       && (IS_ABSOLUTE_RELOC (r_type)
d3968 1
a3968 1
	      if (!IS_ABSOLUTE_RELOC (r_type))
d4058 1
a4058 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d4062 1
d4065 1
a4065 1
  bfd_signed_vma *local_got_refcounts;
d4070 1
d4073 1
a4073 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d4081 1
d4087 29
d4122 21
a4142 11
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
a4149 8
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  break;

d4156 2
d4159 7
a4165 2
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
d4193 3
d4253 1
d4273 4
a4276 1
  if (h->plt.refcount > 0
d4335 1
a4335 1
	      fdh->plt.refcount = h->plt.refcount;
d4507 4
d4512 1
a4512 1
	  || h->plt.refcount <= 0
d4518 1
a4518 1
	  h->plt.offset = (bfd_vma) -1;
d4524 1
a4524 1
    h->plt.offset = (bfd_vma) -1;
d4673 133
a4811 1
  unsigned int bfd_indx;
d4813 1
a4813 3
  for (bfd_indx = 0, ibfd = info->input_bfds;
       ibfd != NULL;
       ibfd = ibfd->link_next, bfd_indx++)
d4908 3
a4910 31
	  sym_sec = NULL;
	  h = NULL;
	  sym = NULL;
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		sym_sec = h->root.u.def.section;
	    }
	  else
	    {
	      if (local_syms == NULL)
		{
		  local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
		  if (local_syms == NULL)
		    local_syms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
						       symtab_hdr->sh_info, 0,
						       NULL, NULL, NULL);
		  if (local_syms == NULL)
		    goto error_free_rel;
		}
	      sym = local_syms + r_symndx;
	      if ((sym->st_shndx != SHN_UNDEF
		   && sym->st_shndx < SHN_LORESERVE)
		  || sym->st_shndx > SHN_HIRESERVE)
		sym_sec = bfd_section_from_elf_index (ibfd, sym->st_shndx);
	    }
d4914 6
d4923 1
a4923 1
		 h != NULL ? h->root.root.string : "<local symbol>");
d4988 2
a4989 22
		  sym_sec = NULL;
		  h = NULL;
		  sym = NULL;
		  if (r_symndx >= symtab_hdr->sh_info)
		    {
		      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;
		      if (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
			sym_sec = h->root.u.def.section;
		    }
		  else
		    {
		      sym = local_syms + r_symndx;
		      if ((sym->st_shndx != SHN_UNDEF
			   && sym->st_shndx < SHN_LORESERVE)
			  || sym->st_shndx > SHN_HIRESERVE)
			sym_sec = bfd_section_from_elf_index (ibfd,
							      sym->st_shndx);
		    }
d5086 328
a5413 1
	    }
d5415 3
a5417 10
	  sec->_cooked_size = wptr - sec->contents;
	  sec->reloc_count = write_rel - relstart;
	  /* Fudge the size too, as this is used later in
	     elf_bfd_final_link if we are emitting relocs.  */
	  elf_section_data (sec)->rel_hdr.sh_size
	    = sec->reloc_count * elf_section_data (sec)->rel_hdr.sh_entsize;
	  BFD_ASSERT (elf_section_data (sec)->rel_hdr2 == NULL);
	}
      else if (elf_section_data (sec)->relocs != relstart)
	free (relstart);
d5419 3
a5421 2
      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
d5424 1
a5424 1
	    free (local_syms);
d5426 1
a5426 1
	    symtab_hdr->contents = (unsigned char *) local_syms;
a5428 1

d5456 1
d5468 2
a5469 2
      && h->plt.refcount > 0
      && h->dynindx != -1)
d5471 6
a5476 1
      BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);
d5478 28
a5505 27
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  s = htab->splt;
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* Make room for the .glink code.  */
	  s = htab->sglink;
	  if (s->_raw_size == 0)
	    s->_raw_size += GLINK_CALL_STUB_SIZE;
	  /* We need bigger stubs past index 32767.  */
	  if (s->_raw_size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	    s->_raw_size += 4;
	  s->_raw_size += 2*4;

	  /* We also need to make an entry in the .rela.plt section.  */
	  s = htab->srelplt;
	  s->_raw_size += sizeof (Elf64_External_Rela);
	}
      else
d5507 1
a5507 1
	  h->plt.offset = (bfd_vma) -1;
d5513 1
a5513 1
      h->plt.offset = (bfd_vma) -1;
d5517 11
a5527 3
  if (h->got.refcount > 0)
    {
      bfd_boolean dyn;
d5529 5
a5533 8
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
d5535 13
a5547 9
      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += 8;
      dyn = htab->elf.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;
d5683 10
d5697 2
a5698 2
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
d5733 2
a5734 2
      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
d5739 1
a5739 1
      end_local_got = local_got + locsymcount;
d5742 1
a5742 1
      for (; local_got < end_local_got; ++local_got)
d5744 35
a5778 9
	  if (*local_got > 0)
	    {
	      *local_got = s->_raw_size;
	      s->_raw_size += 8;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf64_External_Rela);
	    }
	  else
	    *local_got = (bfd_vma) -1;
d5794 4
d5851 4
a5854 2
	 but this way if it does, we get a R_PPC64_NONE reloc instead
	 of garbage.  */
a5935 1
	  && h->oh->plt.offset != (bfd_vma) -1
d5938 8
a5945 2
	  *hash = (struct ppc_link_hash_entry *) h->oh;
	  return ppc_stub_plt_call;
d6020 1
d6132 7
a6138 1
      off = stub_entry->h->elf.plt.offset;
d6191 9
a6199 1
      off = stub_entry->h->elf.plt.offset & ~(bfd_vma) 1;
d6530 2
a6552 2
		  sym_sec = NULL;
		  sym_value = 0;
d6554 6
a6559 2
		  hash = NULL;
		  if (r_indx < symtab_hdr->sh_info)
d6562 1
a6562 20
		      Elf_Internal_Sym *sym;
		      Elf_Internal_Shdr *hdr;

		      if (local_syms == NULL)
			{
			  local_syms
			    = (Elf_Internal_Sym *) symtab_hdr->contents;
			  if (local_syms == NULL)
			    local_syms
			      = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
						      symtab_hdr->sh_info, 0,
						      NULL, NULL, NULL);
			  if (local_syms == NULL)
			    goto error_ret_free_internal;
			}
		      sym = local_syms + r_indx;
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
			sym_value = sym->st_value;
d6570 1
a6570 11
		      int e_indx;

		      e_indx = r_indx - symtab_hdr->sh_info;
		      hash = ((struct ppc_link_hash_entry *)
			      elf_sym_hashes (input_bfd)[e_indx]);

		      while (hash->elf.root.type == bfd_link_hash_indirect
			     || hash->elf.root.type == bfd_link_hash_warning)
			hash = ((struct ppc_link_hash_entry *)
				hash->elf.root.u.i.link);

a6573 1
			  sym_sec = hash->elf.root.u.def.section;
d6597 18
d6651 1
d6902 4
a6905 1
  bfd_vma *local_got_offsets;
d6920 15
a6934 1
  local_got_offsets = elf_local_got_offsets (input_bfd);
d6940 1
a6945 1
      bfd_vma offset;
d6954 1
a6964 2
      offset = rel->r_offset;
      addend = rel->r_addend;
d6983 1
a6983 2
	  sym_name = "<local symbol>";

a6984 3
	  /* rel may have changed, update our copy of addend.  */
	  addend = rel->r_addend;

d7029 3
a7031 3
		      offset, (!info->shared
			       || info->no_undefined
			       || ELF_ST_VISIBILITY (h->other)))))
d7037 261
a7297 1
      /* First handle relocations that tweak non-addend part of insn.  */
d7313 2
a7314 1
	  insn |= bfd_get_32 (output_bfd, contents + offset) & ~(0x01 << 21);
d7329 1
a7329 1
	      from = (offset
d7334 1
a7334 1
	      if ((bfd_signed_vma) (relocation + addend - from) < 0)
d7338 1
a7338 1
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
d7349 1
a7349 1
	      && fdh->plt.offset != (bfd_vma) -1
d7355 1
a7355 1
	      if (offset + 8 <= input_section->_cooked_size)
d7357 1
a7357 1
		  insn = bfd_get_32 (input_bfd, contents + offset + 4);
d7362 1
a7362 1
				  contents + offset + 4);
d7371 1
a7371 1
		  insn = bfd_get_32 (input_bfd, contents + offset);
a7380 1
		  addend = 0;
d7388 1
a7388 1
	      && addend == 0)
d7398 1
a7398 1
	      from = (offset
d7412 2
d7426 1
d7433 1
a7433 1
	     symbols value itself.  Also, create a GOT entry for the
d7435 28
d7469 1
d7473 1
d7475 1
d7481 2
d7484 4
a7487 1
		bfd_boolean dyn;
d7489 12
a7500 2
		off = h->got.offset;
		dyn = htab->elf.dynamic_sections_created;
d7509 6
d7516 2
a7517 20
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally, or the symbol was forced to be local
		       because of a version file.  We must initialize
		       this entry in the global offset table.  Since the
		       offset must always be a multiple of 8, we use the
		       least significant bit to record whether we have
		       initialized it already.

		       When doing a dynamic link, we create a .rel.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			bfd_put_64 (output_bfd, relocation,
				    htab->sgot->contents + off);
			h->got.offset |= 1;
		      }
a7518 2
		else
		  unresolved_reloc = FALSE;
d7520 6
d7528 5
a7532 11
		if (local_got_offsets == NULL)
		  abort ();

		off = local_got_offsets[r_symndx];

		/* The offset must always be a multiple of 8.  We use
		   the least significant bit to record whether we have
		   already processed this entry.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
d7534 4
a7537 4
		    bfd_put_64 (output_bfd, relocation,
				htab->sgot->contents + off);

		    if (info->shared)
d7539 2
a7540 10
			Elf_Internal_Rela outrel;
			bfd_byte *loc;

			/* We need to generate a R_PPC64_RELATIVE reloc
			   for the dynamic linker.  */
			outrel.r_offset = (htab->sgot->output_section->vma
					   + htab->sgot->output_offset
					   + off);
			outrel.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
			outrel.r_addend = relocation;
d7545 31
d7578 10
a7587 1
		    local_got_offsets[r_symndx] |= 1;
d7589 1
d7598 1
a7598 1
	    addend -= TOC_BASE_OFF;
d7615 16
a7630 7
	  if (h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
a7631 5

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
d7664 39
d7705 1
d7731 1
d7744 1
a7744 1
	       && (IS_ABSOLUTE_RELOC (r_type)
d7782 1
a7782 1
	      outrel.r_addend = addend;
d7789 1
a7789 1
		       && (!IS_ABSOLUTE_RELOC (r_type)
d7801 1
d7909 14
d7943 8
d7975 1
a7975 1
	  from = (offset
d8012 1
a8012 1
				    offset,
d8038 1
a8038 3
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
a8040 2
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
d8049 1
a8049 1
		     rel->r_addend, input_bfd, input_section, offset)))
d8083 1
a8083 2
  if (h->plt.offset != (bfd_vma) -1
      && ((struct ppc_link_hash_entry *) h)->is_func_descriptor)
d8085 1
d8089 5
a8093 2
      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
d8095 4
a8098 4
      if (htab->splt == NULL
	  || htab->srelplt == NULL
	  || htab->sglink == NULL)
	abort ();
d8100 2
a8101 2
      /* Create a JMP_SLOT reloc to inform the dynamic linker to
	 fill in the PLT entry.  */
d8103 11
a8113 56
      rela.r_offset = (htab->splt->output_section->vma
		       + htab->splt->output_offset
		       + h->plt.offset);
      rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
      rela.r_addend = 0;

      loc = htab->srelplt->contents;
      loc += ((h->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      * sizeof (Elf64_External_Rela));
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      if (htab->sgot == NULL || htab->srelgot == NULL)
	abort ();

      rela.r_offset = (htab->sgot->output_section->vma
		       + htab->sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	{
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rela.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT ((h->got.offset & 1) == 0);
	  bfd_put_64 (output_bfd, (bfd_vma) 0,
		      htab->sgot->contents + h->got.offset);
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_GLOB_DAT);
	  rela.r_addend = 0;
	}

      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
@


1.78
log
@	* elf64-ppc.c: Include elf/ppc64.h rather than elf/ppc.h.
	(R_PPC_*): Rename all occurrences to R_PPC64_*.
	(R_PPC64_ADDR30): Rename all occurrences to R_PPC64_REL30.
	(enum elf_ppc_reloc_type): Ditto to enum elf_ppc64_reloc_type.
	(ppc64_elf_gc_sweep_hook): Handle R_PPC64_REL30 along with other
	relative relocs, not with absolute ones.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d59 2
d1680 29
d2598 1
a2598 1
      elf_section_data (sec)->tdata = opd_sym_map;
d2973 1
a2973 1
		       || elf_section_data (sec)->tdata == NULL)
d2991 1
a2991 1
      opd_sym_section = (asection **) elf_section_data (rsec)->tdata;
d2994 1
a2994 1
      else if (elf_section_data (sec)->tdata != NULL)
d3597 1
a3597 1
      adjust = (long *) elf_section_data (sec)->tdata;
d3603 1
a3603 1
	  elf_section_data (sec)->tdata = adjust;
d5339 1
a5339 1
  is_opd = elf_section_data (input_section)->tdata != NULL;
d5395 1
a5395 1
	      opd_sym_adjust = (long *) elf_section_data (sec)->tdata;
d6372 1
@


1.77
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Adjust addend for GOT16_HA.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.  PLTGOT16_HA too.
@
text
@d30 1
a30 1
#include "elf/ppc.h"
d129 1
a129 1
static reloc_howto_type *ppc64_elf_howto_table[(int) R_PPC_max];
d670 2
a671 3
  /* Like R_PPC64_REL24 without touching the two least significant
     bits.  Should have been named R_PPC64_REL30!  */
  HOWTO (R_PPC64_ADDR30,	/* type */
d679 1
a679 1
	 "R_PPC64_ADDR30",	/* name */
d1209 1
a1209 1
  enum elf_ppc_reloc_type ppc_reloc = R_PPC_NONE;
d1367 1
a1367 1
/* Handle the R_PPC_ADDR16_HA and similar relocs.  */
d1406 1
a1406 1
  enum elf_ppc_reloc_type r_type;
d1421 1
a1421 1
  r_type = (enum elf_ppc_reloc_type) reloc_entry->howto->type;
d1773 1
a1773 1
   && (RTYPE) != R_PPC64_ADDR30)
d2581 1
a2581 1
      enum elf_ppc_reloc_type r_type;
d2589 1
a2589 1
      r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
d2725 1
a2725 1
	      && ((enum elf_ppc_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info)
d2739 2
a2741 1
	case R_PPC64_REL32:
a2755 1
	case R_PPC64_ADDR30:
d2914 1
a2914 1
      enum elf_ppc_reloc_type r_type;
d2917 1
a2917 1
      r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
d2995 1
a2995 1
      enum elf_ppc_reloc_type r_type;
d2999 1
a2999 1
      r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
d3046 1
a3083 1
	case R_PPC64_ADDR30:
d3445 2
a3446 2
  /* We must generate a R_PPC_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
d3601 1
a3601 1
	  enum elf_ppc_reloc_type r_type;
d3610 1
a3610 1
	  r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
d3625 1
a3625 1
	  r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info);
d4916 1
a4916 1
		  if (r_type >= (unsigned int) R_PPC_max)
d5314 1
a5314 1
      enum elf_ppc_reloc_type r_type;
d5332 1
a5332 1
      r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
d5539 2
a5540 2
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
d5709 1
a5725 1
	case R_PPC64_ADDR30:
d6178 1
a6178 1
  enum elf_ppc_reloc_type r_type;
d6180 1
a6180 1
  r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rela->r_info);
@


1.76
log
@	* elf32-i386.c (elf_i386_finish_dynamic_sections): Add output_offset
	to DT_JMPREL.  Use srelplt input section size for DT_PLTRELSZ and
	DT_RELSZ adjustment, not output section.  Avoid writing tags when
	unchanged.  Don't assume linker script is sane, adjust DT_REL too.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Just use raw
	size of srelplt for DT_PLTRELSZ.  Use srelplt input section size for
	DT_RELASZ adjustment, not output section.  Avoid writing tags when
	unchanged.  Adjust DT_RELA.
	* elf64-ppc.c (ppc64_elf_finish_dynamic_sections): Tweaks for better
	formatting.  Avoid writing tags when unchanged.  Adjust DT_RELA.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d5906 2
@


1.75
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): Correct typo.
@
text
@d6230 2
a6231 2
	      dyn.d_un.d_ptr = (htab->sglink->output_section->vma
				+ htab->sglink->output_offset);
d6236 3
a6238 2
	      if (s != NULL)
		dyn.d_un.d_ptr = s->vma;
d6243 3
a6245 2
	      if (s != NULL)
		dyn.d_un.d_val = s->_raw_size;
d6249 2
a6250 2
	      dyn.d_un.d_ptr = (htab->splt->output_section->vma
				+ htab->splt->output_offset);
d6254 2
a6255 2
	      dyn.d_un.d_ptr = (htab->srelplt->output_section->vma
				+ htab->srelplt->output_offset);
d6265 16
a6280 2
	      if (htab->srelplt != NULL)
		dyn.d_un.d_val -= htab->srelplt->_raw_size;
@


1.74
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3589 1
a3589 1
      relstart = _bfd_elf64_link_read_relocs (obfd, sec, (PTR) NULL,
@


1.73
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d55 1
a55 1
static boolean ppc64_elf_object_p
d57 1
a57 1
static boolean ppc64_elf_merge_private_bfd_data
d127 1
a127 1
 
d137 1
a137 1
	 false,			/* pc_relative */
d142 1
a142 1
	 false,			/* partial_inplace */
d145 1
a145 1
	 false),		/* pcrel_offset */
d152 1
a152 1
	 false,			/* pc_relative */
d157 1
a157 1
	 false,			/* partial_inplace */
d160 1
a160 1
	 false),		/* pcrel_offset */
d168 1
a168 1
	 false,			/* pc_relative */
d173 1
a173 1
	 false,			/* partial_inplace */
d176 1
a176 1
	 false),		/* pcrel_offset */
d183 1
a183 1
	 false,			/* pc_relative */
d188 1
a188 1
	 false,			/* partial_inplace */
d191 1
a191 1
	 false),		/* pcrel_offset */
d198 1
a198 1
	 false,			/* pc_relative */
d203 1
a203 1
	 false,			/* partial_inplace */
d206 1
a206 1
	 false),		/* pcrel_offset */
d213 1
a213 1
	 false,			/* pc_relative */
d218 1
a218 1
	 false,			/* partial_inplace */
d221 1
a221 1
	 false),		/* pcrel_offset */
d229 1
a229 1
	 false,			/* pc_relative */
d234 1
a234 1
	 false,			/* partial_inplace */
d237 1
a237 1
	 false),		/* pcrel_offset */
d245 1
a245 1
	 false,			/* pc_relative */
d250 1
a250 1
	 false,			/* partial_inplace */
d253 1
a253 1
	 false),		/* pcrel_offset */
d262 1
a262 1
	 false,			/* pc_relative */
d267 1
a267 1
	 false,			/* partial_inplace */
d270 1
a270 1
	 false),		/* pcrel_offset */
d279 1
a279 1
	 false,			/* pc_relative */
d284 1
a284 1
	 false,			/* partial_inplace */
d287 1
a287 1
	 false),		/* pcrel_offset */
d294 1
a294 1
	 true,			/* pc_relative */
d299 1
a299 1
	 false,			/* partial_inplace */
d302 1
a302 1
	 true),			/* pcrel_offset */
d309 1
a309 1
	 true,			/* pc_relative */
d314 1
a314 1
	 false,			/* partial_inplace */
d317 1
a317 1
	 true),			/* pcrel_offset */
d326 1
a326 1
	 true,			/* pc_relative */
d331 1
a331 1
	 false,			/* partial_inplace */
d334 1
a334 1
	 true),			/* pcrel_offset */
d343 1
a343 1
	 true,			/* pc_relative */
d348 1
a348 1
	 false,			/* partial_inplace */
d351 1
a351 1
	 true),			/* pcrel_offset */
d359 1
a359 1
	 false,			/* pc_relative */
d364 1
a364 1
	 false,			/* partial_inplace */
d367 1
a367 1
	 false),		/* pcrel_offset */
d375 1
a375 1
	 false,			/* pc_relative */
d380 1
a380 1
	 false,			/* partial_inplace */
d383 1
a383 1
	 false),		/* pcrel_offset */
d391 1
a391 1
	 false,			/* pc_relative */
d396 1
a396 1
	 false,			/* partial_inplace */
d399 1
a399 1
	 false),		/* pcrel_offset */
d407 1
a407 1
	 false,			/* pc_relative */
d412 1
a412 1
	 false,			/* partial_inplace */
d415 1
a415 1
	 false),		/* pcrel_offset */
d426 1
a426 1
	 false,			/* pc_relative */
d431 1
a431 1
	 false,			/* partial_inplace */
d434 1
a434 1
	 false),		/* pcrel_offset */
d442 1
a442 1
	 false,			/* pc_relative */
d447 1
a447 1
	 false,			/* partial_inplace */
d450 1
a450 1
	 false),		/* pcrel_offset */
d458 1
a458 1
	 false,			/* pc_relative */
d463 1
a463 1
	 false,			/* partial_inplace */
d466 1
a466 1
	 false),		/* pcrel_offset */
d475 1
a475 1
	 false,			/* pc_relative */
d480 1
a480 1
	 false,			/* partial_inplace */
d483 1
a483 1
	 false),		/* pcrel_offset */
d490 1
a490 1
	 false,			/* pc_relative */
d495 1
a495 1
	 false,			/* partial_inplace */
d498 1
a498 1
	 false),		/* pcrel_offset */
d505 1
a505 1
	 false,			/* pc_relative */
d510 1
a510 1
	 false,			/* partial_inplace */
d513 1
a513 1
	 false),		/* pcrel_offset */
d520 1
a520 1
	 true,			/* pc_relative */
d526 1
a526 1
	 false,			/* partial_inplace */
d529 1
a529 1
	 true),			/* pcrel_offset */
d536 1
a536 1
	 false,			/* pc_relative */
d541 1
a541 1
	 false,			/* partial_inplace */
d544 1
a544 1
	 false),		/* pcrel_offset */
d552 1
a552 1
	 true,			/* pc_relative */
d557 1
a557 1
	 false,			/* partial_inplace */
d560 1
a560 1
	 true),			/* pcrel_offset */
d568 1
a568 1
	 false,			/* pc_relative */
d573 1
a573 1
	 false,			/* partial_inplace */
d576 1
a576 1
	 false),		/* pcrel_offset */
d584 1
a584 1
	 false,			/* pc_relative */
d589 1
a589 1
	 false,			/* partial_inplace */
d592 1
a592 1
	 false),		/* pcrel_offset */
d600 1
a600 1
	 false,			/* pc_relative */
d605 1
a605 1
	 false,			/* partial_inplace */
d608 1
a608 1
	 false),		/* pcrel_offset */
d615 1
a615 1
	 false,			/* pc_relative */
d620 1
a620 1
	 false,			/* partial_inplace */
d623 1
a623 1
	 false),		/* pcrel_offset */
d630 1
a630 1
	 false,			/* pc_relative */
d635 1
a635 1
	 false,			/* partial_inplace */
d638 1
a638 1
	 false),		/* pcrel_offset */
d645 1
a645 1
	 false,			/* pc_relative */
d650 1
a650 1
	 false,			/* partial_inplace */
d653 1
a653 1
	 false),		/* pcrel_offset */
d660 1
a660 1
	 false,			/* pc_relative */
d665 1
a665 1
	 false,			/* partial_inplace */
d668 1
a668 1
	 false),		/* pcrel_offset */
d676 1
a676 1
	 true,			/* pc_relative */
d681 1
a681 1
	 false,			/* partial_inplace */
d684 1
a684 1
	 true),			/* pcrel_offset */
d693 1
a693 1
	 false,			/* pc_relative */
d698 1
a698 1
	 false,			/* partial_inplace */
d701 1
a701 1
	 false),		/* pcrel_offset */
d708 1
a708 1
	 false,			/* pc_relative */
d713 1
a713 1
	 false,			/* partial_inplace */
d716 1
a716 1
	 false),		/* pcrel_offset */
d724 1
a724 1
	 false,			/* pc_relative */
d729 1
a729 1
	 false,			/* partial_inplace */
d732 1
a732 1
	 false),		/* pcrel_offset */
d739 1
a739 1
	 false,			/* pc_relative */
d744 1
a744 1
	 false,			/* partial_inplace */
d747 1
a747 1
	 false),		/* pcrel_offset */
d755 1
a755 1
	 false,			/* pc_relative */
d760 1
a760 1
	 false,			/* partial_inplace */
d763 1
a763 1
	 false),		/* pcrel_offset */
d770 1
a770 1
	 false,			/* pc_relative */
d775 1
a775 1
	 false,			/* partial_inplace */
d778 1
a778 1
	 false),		/* pcrel_offset */
d785 1
a785 1
	 true,			/* pc_relative */
d790 1
a790 1
	 false,			/* partial_inplace */
d793 1
a793 1
	 true),			/* pcrel_offset */
d800 1
a800 1
	 false,			/* pc_relative */
d805 1
a805 1
	 false,			/* partial_inplace */
d808 1
a808 1
	 false),		/* pcrel_offset */
d817 1
a817 1
	 true,			/* pc_relative */
d822 1
a822 1
	 false,			/* partial_inplace */
d825 1
a825 1
	 true),			/* pcrel_offset */
d834 1
a834 1
	 false,			/* pc_relative */
d839 1
a839 1
	 false,			/* partial_inplace */
d842 1
a842 1
	 false),		/* pcrel_offset */
d851 1
a851 1
	 false,			/* pc_relative */
d856 1
a856 1
	 false,			/* partial_inplace */
d859 1
a859 1
	 false),		/* pcrel_offset */
d868 1
a868 1
	 false,			/* pc_relative */
d873 1
a873 1
	 false,			/* partial_inplace */
d876 1
a876 1
	 false),		/* pcrel_offset */
d887 1
a887 1
	 false,			/* pc_relative */
d892 1
a892 1
	 false,			/* partial_inplace */
d895 1
a895 1
	 false),		/* pcrel_offset */
d904 1
a904 1
	 false,			/* pc_relative */
d909 1
a909 1
	 false,			/* partial_inplace */
d912 1
a912 1
	 false),		/* pcrel_offset */
d927 1
a927 1
	 false,			/* pc_relative */
d932 1
a932 1
	 false,			/* partial_inplace */
d935 1
a935 1
	 false),		/* pcrel_offset */
d943 1
a943 1
	 false,			/* pc_relative */
d948 1
a948 1
	 false,			/* partial_inplace */
d951 1
a951 1
	 false),		/* pcrel_offset */
d959 1
a959 1
	 false,			/* pc_relative */
d964 1
a964 1
	 false,			/* partial_inplace */
d967 1
a967 1
	 false),		/* pcrel_offset */
d977 1
a977 1
	 false,			/* pc_relative */
d982 1
a982 1
	 false,			/* partial_inplace */
d985 1
a985 1
	 false),		/* pcrel_offset */
d992 1
a992 1
	 false,			/* pc_relative */
d997 1
a997 1
	 false,			/* partial_inplace */
d1000 1
a1000 1
	 false),		/* pcrel_offset */
d1007 1
a1007 1
	 false,			/* pc_relative */
d1012 1
a1012 1
	 false,			/* partial_inplace */
d1015 1
a1015 1
	 false),		/* pcrel_offset */
d1022 1
a1022 1
	 false,			/* pc_relative */
d1027 1
a1027 1
	 false,			/* partial_inplace */
d1030 1
a1030 1
	 false),		/* pcrel_offset */
d1037 1
a1037 1
	 false,			/* pc_relative */
d1042 1
a1042 1
	 false,			/* partial_inplace */
d1045 1
a1045 1
	 false),		/* pcrel_offset */
d1052 1
a1052 1
	 false,			/* pc_relative */
d1057 1
a1057 1
	 false,			/* partial_inplace */
d1060 1
a1060 1
	 false),		/* pcrel_offset */
d1067 1
a1067 1
	 false,			/* pc_relative */
d1072 1
a1072 1
	 false,			/* partial_inplace */
d1075 1
a1075 1
	 false),		/* pcrel_offset */
d1082 1
a1082 1
	 false,			/* pc_relative */
d1087 1
a1087 1
	 false,			/* partial_inplace */
d1090 1
a1090 1
	 false),		/* pcrel_offset */
d1097 1
a1097 1
	 false,			/* pc_relative */
d1102 1
a1102 1
	 false,			/* partial_inplace */
d1105 1
a1105 1
	 false),		/* pcrel_offset */
d1112 1
a1112 1
	 false,			/* pc_relative */
d1117 1
a1117 1
	 false,			/* partial_inplace */
d1120 1
a1120 1
	 false),		/* pcrel_offset */
d1128 1
a1128 1
	 false,			/* pc_relative */
d1133 1
a1133 1
	 false,			/* partial_inplace */
d1136 1
a1136 1
	 false),		/* pcrel_offset */
d1144 1
a1144 1
	 false,			/* pc_relative */
d1149 1
a1149 1
	 false,			/* partial_inplace */
d1152 1
a1152 1
	 false),		/* pcrel_offset */
d1159 1
a1159 1
	 false,			/* pc_relative */
d1164 1
a1164 1
	 false,			/* partial_inplace */
d1167 1
a1167 1
	 false),		/* pcrel_offset */
d1174 1
a1174 1
	 false,			/* pc_relative */
d1179 1
a1179 1
	 false,			/* partial_inplace */
d1182 1
a1182 1
	 false),		/* pcrel_offset */
d1410 1
a1410 1
  boolean is_power4 = false;
d1633 1
a1633 1
static boolean
d1648 1
a1648 1
  return true;
d1654 1
a1654 1
static boolean
d1674 1
a1674 1
      return false;
d1677 1
a1677 1
  return true;
d1949 1
a1949 1
static boolean create_linkage_sections
d1951 1
a1951 1
static boolean create_got_section
d1953 1
a1953 1
static boolean ppc64_elf_create_dynamic_sections
d1958 1
a1958 1
static boolean ppc64_elf_check_relocs
d1964 1
a1964 1
static boolean ppc64_elf_gc_sweep_hook
d1967 1
a1967 1
static boolean func_desc_adjust
d1969 1
a1969 1
static boolean ppc64_elf_func_desc_adjust
d1971 1
a1971 1
static boolean ppc64_elf_adjust_dynamic_symbol
d1974 2
a1975 2
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, boolean));
static boolean allocate_dynrelocs
d1977 1
a1977 1
static boolean readonly_dynrelocs
d1981 1
a1981 1
static boolean ppc64_elf_size_dynamic_sections
d1988 1
a1988 1
static boolean ppc_build_one_stub
d1990 1
a1990 1
static boolean ppc_size_one_stub
d1993 2
a1994 2
  PARAMS ((struct ppc_link_hash_table *, bfd_size_type, boolean));
static boolean ppc64_elf_relocate_section
d1998 1
a1998 1
static boolean ppc64_elf_finish_dynamic_symbol
d2001 1
a2001 1
static boolean ppc64_elf_finish_dynamic_sections
d2265 1
a2265 1
					 stub_name, false, false);
d2317 1
a2317 1
				     true, false);
d2334 1
a2334 1
static boolean
d2351 1
a2351 1
    return false;
d2358 1
a2358 1
    return false;
d2367 1
a2367 1
    return false;
d2377 1
a2377 1
	return false;
d2379 1
a2379 1
  return true;
d2385 1
a2385 1
static boolean
d2393 1
a2393 1
    return false;
d2407 2
a2408 2
    return false;
  return true;
d2413 1
a2413 1
static boolean
d2422 1
a2422 1
    return false;
d2425 1
a2425 1
    return false;
d2437 1
a2437 1
  return true;
d2496 1
a2496 1
boolean
d2508 1
a2508 1
      h = elf_link_hash_lookup (&htab->elf, sym->name, false, false, false);
d2512 1
a2512 1
  return true;
d2519 1
a2519 1
static boolean
d2535 1
a2535 1
    return true;
d2567 1
a2567 1
	return false;
d2575 1
a2575 1
    return false;
d2604 1
a2604 1
	    return false;
d2625 1
a2625 1
		    return false;
d2647 1
a2647 1
	      return false;
d2676 1
a2676 1
	    return false;
d2683 1
a2683 1
	    return false;
d2714 1
a2714 1
					  false, false, false);
d2734 1
a2734 1
		return false;
d2818 1
a2818 1
		    return false;
d2844 1
a2844 1
			return false;
d2865 1
a2865 1
		    return false;
d2878 1
a2878 1
		    return false;
d2897 1
a2897 1
  return true;
d2940 1
a2940 1
		 sections, as all functions are referenced in .opd.  */ 
d2974 1
a2974 1
static boolean
d3115 1
a3115 1
  return true;
d3121 1
a3121 1
static boolean
d3130 1
a3130 1
    return true;
d3141 1
a3141 1
    return true;
d3145 1
a3145 1
    htab->have_undefweak = true;
d3152 1
a3152 1
      boolean force_local;
d3159 1
a3159 1
				    false, false, true);
d3182 1
a3182 1
		  newsym->section, newsym->value, NULL, false, false, &bh)))
d3184 1
a3184 1
	      return false;
d3198 1
a3198 1
	      return false;
d3232 1
a3232 1
  return true;
d3242 1
a3242 1
static boolean
d3259 1
a3259 1
    return true;
d3267 1
a3267 1
      h = elf_link_hash_lookup (&htab->elf, sym, false, false, true);
d3287 1
a3287 1
      h = elf_link_hash_lookup (&htab->elf, sym, false, false, true);
d3313 1
a3313 1
	  return true;
d3321 1
a3321 1
    return false;
d3350 1
a3350 1
  return true;
d3359 1
a3359 1
static boolean
d3388 1
a3388 1
      return true;
d3402 1
a3402 1
      return true;
d3413 1
a3413 1
    return true;
d3418 1
a3418 1
    return true;
d3433 1
a3433 1
      return true;
d3468 1
a3468 1
	return false;
d3478 1
a3478 1
  return true;
d3487 1
a3487 1
     boolean force_local;
d3514 1
a3514 1
	  fh = elf_link_hash_lookup (&htab->elf, p, false, false, false);
d3527 1
a3527 1
		fh = elf_link_hash_lookup (&htab->elf, p, false, false, false);
d3540 1
a3540 1
boolean
d3560 1
a3560 1
      boolean need_edit;
d3593 1
a3593 1
	return false;
d3597 1
a3597 1
      need_edit = false;
d3620 1
a3620 1
	      need_edit = false;
d3636 1
a3636 1
		 optimization for them!  */ 
d3640 1
a3640 1
	      need_edit = false;
d3683 1
a3683 1
	      need_edit = false;
d3696 1
a3696 1
	    need_edit = true;
d3705 1
a3705 1
	  boolean skip;
d3724 1
a3724 1
		  return false;
d3735 1
a3735 1
	  skip = false;
d3792 1
a3792 1
						      false, false, false);
d3827 1
a3827 1
						      false, false, false);
d3843 1
a3843 1
			     array of adjustments.  */ 
d3888 1
a3888 1
  return true;
d3890 1
a3890 1
     
d3905 1
a3905 1
static boolean
d3917 1
a3917 1
    return true;
d3971 1
a3971 1
      boolean dyn;
d3979 1
a3979 1
	    return false;
d3994 1
a3994 1
    return true;
d4040 1
a4040 1
		return false;
d4061 1
a4061 1
  return true;
d4066 1
a4066 1
static boolean
d4089 1
a4089 1
	  return false;
d4092 1
a4092 1
  return true;
d4097 1
a4097 1
static boolean
d4105 1
a4105 1
  boolean relocs;
d4195 1
a4195 1
  relocs = false;
d4228 1
a4228 1
		relocs = true;
d4258 1
a4258 1
	return false;
d4274 1
a4274 1
	    return false;
d4284 1
a4284 1
	    return false;
d4291 1
a4291 1
	    return false;
d4299 1
a4299 1
	    return false;
d4310 1
a4310 1
		return false;
d4316 1
a4316 1
  return true;
d4402 1
a4402 1
static boolean
d4454 1
a4454 1
					 false, false);
d4459 2
a4460 2
	  htab->stub_error = true;
	  return false;
d4499 2
a4500 2
	  htab->stub_error = true;
	  return false;
d4543 2
a4544 2
	  htab->stub_error = true;
	  return false;
d4553 1
a4553 1
      return false;
d4557 1
a4557 1
  return true;
d4564 1
a4564 1
static boolean
d4609 1
a4609 1
					     true, false);
d4614 2
a4615 2
	      htab->stub_error = true;
	      return false;
d4630 1
a4630 1
  return true;
d4746 1
a4746 1
     boolean stubs_always_before_branch;
d4816 1
a4816 1
boolean
d4827 1
a4827 1
  boolean stubs_always_before_branch;
d4854 1
a4854 1
      boolean stub_changed;
d4857 1
a4857 1
      stub_changed = false;
d5013 1
a5013 1
						     stub_name, false, false);
d5033 1
a5033 1
		      return false;
d5040 1
a5040 1
		  stub_changed = true;
d5084 1
a5084 1
  return true;
d5148 1
a5148 1
boolean
d5169 1
a5169 1
	    return false;
d5220 1
a5220 1
	return false;
d5237 1
a5237 1
      htab->stub_error = true;
d5273 1
a5273 1
static boolean
d5292 2
a5293 2
  boolean ret = true;
  boolean is_opd;
d5295 1
a5295 1
  boolean is_power4 = false;
d5298 1
a5298 1
    return true;
d5326 2
a5327 2
      boolean unresolved_reloc;
      boolean warned;
d5342 2
a5343 2
      unresolved_reloc = false;
      warned = false;
d5388 1
a5388 1
		unresolved_reloc = true;
d5408 2
a5409 2
		return false;
	      warned = true;
d5468 1
a5468 1
	      boolean can_plt_call = 0;
d5497 1
a5497 1
		  unresolved_reloc = false;
d5536 1
a5536 1
	  ret = false;
d5564 1
a5564 1
		boolean dyn;
d5599 1
a5599 1
		  unresolved_reloc = false;
d5675 1
a5675 1
	  unresolved_reloc = false;
d5765 1
a5765 1
	      boolean skip, relocate;
d5773 2
a5774 2
	      skip = false;
	      relocate = false;
d5780 1
a5780 1
		skip = true;
d5782 1
a5782 1
		skip = true, relocate = true;
d5804 1
a5804 1
		  relocate = true;
d5819 1
a5819 1
			  unresolved_reloc = false;
d5832 1
a5832 1
			  return false;
d5893 1
a5893 1
	  ret = false;
d5936 1
a5936 1
	      ret = false;
d5983 1
a5983 1
	  ret = false;
d6032 1
a6032 1
		return false;
d6041 1
a6041 1
	      ret = false;
d6052 1
a6052 1
static boolean
d6167 1
a6167 1
  return true;
d6195 1
a6195 1
static boolean
d6291 1
a6291 1
  return true;
@


1.72
log
@	* elf64-ppc.c (ppc64_elf_edit_opd): When deleting relocs, adjust
	rel_hdr.sh_size too.
@
text
@d38 1
a38 1
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf64_Internal_Rela *dst));
d1354 1
a1354 1
     Elf64_Internal_Rela *dst;
d4474 1
a4474 1
	  Elf64_External_Rela *r;
d4482 3
a4484 3
	  r = (Elf64_External_Rela *) htab->srelbrlt->contents;
	  r += htab->srelbrlt->reloc_count++;
	  bfd_elf64_swap_reloca_out (htab->srelbrlt->owner, &rela, r);
d5621 1
a5621 1
			Elf64_External_Rela *loc;
d5630 3
a5632 2
			loc = (Elf64_External_Rela *) htab->srelgot->contents;
			loc += htab->srelgot->reloc_count++;
d5767 1
a5767 1
	      Elf64_External_Rela *loc;
d5857 2
a5858 2
	      loc = (Elf64_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
d6069 1
a6069 1
      Elf64_External_Rela *loc;
d6088 3
a6090 2
      loc = (Elf64_External_Rela *) htab->srelplt->contents;
      loc += (h->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE;
d6097 1
a6097 1
      Elf64_External_Rela *loc;
d6135 2
a6136 2
      loc = (Elf64_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
d6143 1
a6143 1
      Elf64_External_Rela *loc;
d6158 2
a6159 2
      loc = (Elf64_External_Rela *) htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++;
@


1.71
log
@	* elflink.h (elf_link_add_object_symbols): Optimize stabs for
	relocatable link too.
	(elf_link_input_bfd): When emitting relocs, adjust offsets for
	eh_frame and stab sections.  Zap deleted relocs.
	(elf_reloc_symbol_deleted_p): Return true for zero r_symndx.
	(elf_bfd_discard_info): Run for relocatable link too.
	* elf64-ppc.c (ppc64_elf_edit_opd): Rename from edit_opd.  Make global.
	Handle ld -r case.
	(ppc64_elf_size_dynamic_sections): Don't call edit_opd from here.
	* elf64-ppc.h (ppc64_elf_edit_opd): Declare.
@
text
@d3869 5
@


1.70
log
@	* elf64-ppc.c: Comment typo fixes.
	(ppc64_elf_merge_private_bfd_data): Allow BFD_ENDIAN_UNKNOWN input.
@
text
@a1974 2
static boolean edit_opd
  PARAMS ((bfd *, struct bfd_link_info *));
d3540 2
a3541 2
static boolean
edit_opd (obfd, info)
d3558 1
d3566 1
d3568 8
a3575 2
      BFD_ASSERT (adjust != NULL);
      memset (adjust, 0, (size_t) sec->_raw_size * sizeof (long) / 24);
d3778 1
a3778 1
			  struct elf_link_hash_entry *fdh;
d3782 19
a3800 4
			  BFD_ASSERT (fh->is_func);
			  fdh = fh->oh;
			  fdh->root.u.def.value = 0;
			  fdh->root.u.def.section = sym_sec;
d3813 1
a3813 1
			  struct elf_link_hash_entry *fdh;
d3817 18
a3834 3
			  BFD_ASSERT (fh->is_func);
			  fdh = fh->oh;
			  fdh->root.u.def.value = wptr - sec->contents;
a4182 3

  if (!edit_opd (output_bfd, info))
    return false;
@


1.69
log
@	* elf64-ppc.c (edit_opd): Correct local sym adjustment.
@
text
@d1661 1
d1789 2
a1790 2
   .	addis	%r12,%r2,xxx@@ha
   .	ld	%r11,xxx@@l(%r12)
d1796 1
a1796 1
   .	addis	%r12,%r2,xxx@@ha
d1798 2
a1799 2
   .	ld	%r11,xxx+0@@l(%r12)
   .	ld	%r2,xxx+8@@l(%r12)
d1801 1
a1801 1
   .	ld	%r11,xxx+16@@l(%r12)
@


1.68
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d3807 1
a3807 2
			  adjust[(rel->r_offset + wptr - rptr) / 24]
			    = wptr - rptr;
@


1.67
log
@	* elf64-ppc.c (edit_opd): Only zero opd syms when function is
	completely removed.
@
text
@d3169 1
d3180 1
d3183 1
a3183 2
		  newsym->section, newsym->value, NULL, false, false,
		  (struct bfd_link_hash_entry **) &fdh)))
d3187 1
@


1.66
log
@	* elf64-ppc.c (edit_opd): Correct test for discarded sections.
@
text
@d3765 1
a3765 1
		      if (h != NULL)
@


1.65
log
@	* elf64-ppc.c (ppc64_elf_build_stubs): Increment .glink indx.
@
text
@d3678 10
a3687 6
	  if (sym_sec->output_section == bfd_abs_section_ptr)
	    {
	      /* OK, we've found a function that's excluded from the
		 link.  */
	      need_edit = true;
	    }
d3761 2
a3762 1
		  skip = sym_sec->output_section == bfd_abs_section_ptr;
@


1.64
log
@	* elf64-ppc.c (ppc_build_one_stub): Don't build glink stubs here.
	(ppc64_elf_build_stubs): Build them here instead.
@
text
@d5164 1
@


1.64.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a3168 1
	  struct bfd_link_hash_entry *bh;
a3178 1
	  bh = &fdh->root;
d3181 2
a3182 1
		  newsym->section, newsym->value, NULL, false, false, &bh)))
a3185 1
	  fdh = (struct elf_link_hash_entry *) bh;
d3678 6
a3683 10
	  /* opd entries are always for functions defined in the
	     current input bfd.  If the symbol isn't defined in the
	     input bfd, then we won't be using the function in this
	     bfd;  It must be defined in a linkonce section in another
	     bfd, or is weak.  It's also possible that we are
	     discarding the function due to a linker script /DISCARD/,
	     which we test for via the output_section.  */
	  if (sym_sec->owner != ibfd
	      || sym_sec->output_section == bfd_abs_section_ptr)
	    need_edit = true;
d3757 1
a3757 2
		  skip = (sym_sec->owner != ibfd
			  || sym_sec->output_section == bfd_abs_section_ptr);
d3760 1
a3760 1
		      if (h != NULL && sym_sec->owner == ibfd)
d3800 2
a3801 1
			  adjust[rel->r_offset / 24] = wptr - rptr;
a5163 1
	  indx++;
@


1.64.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a4 1
   Largely rewritten by Alan Modra <amodra@@bigpond.net.au>
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 16
a23 17
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* The 64-bit PowerPC ELF ABI may be found at
   http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi.txt, and
   http://www.linuxbase.org/spec/ELF/ppc64/spec/book1.html  */
d30 1
a30 1
#include "elf/ppc64.h"
d33 6
d40 1
a40 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d42 1
a42 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d44 1
a44 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d46 1
a46 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d48 1
a48 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d50 1
a50 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d52 1
a52 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d54 5
a58 28
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);


#define TARGET_LITTLE_SYM	bfd_elf64_powerpcle_vec
#define TARGET_LITTLE_NAME	"elf64-powerpcle"
#define TARGET_BIG_SYM		bfd_elf64_powerpc_vec
#define TARGET_BIG_NAME		"elf64-powerpc"
#define ELF_ARCH		bfd_arch_powerpc
#define ELF_MACHINE_CODE	EM_PPC64
#define ELF_MAXPAGESIZE		0x10000
#define elf_info_to_howto	ppc64_elf_info_to_howto

#define elf_backend_want_got_sym 0
#define elf_backend_want_plt_sym 0
#define elf_backend_plt_alignment 3
#define elf_backend_plt_not_loaded 1
#define elf_backend_got_symbol_offset 0
#define elf_backend_got_header_size 8
#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_rela_normal 1

#define bfd_elf64_mkobject		      ppc64_elf_mkobject
#define bfd_elf64_bfd_reloc_type_lookup	      ppc64_elf_reloc_type_lookup
#define bfd_elf64_bfd_merge_private_bfd_data  ppc64_elf_merge_private_bfd_data
#define bfd_elf64_new_section_hook	      ppc64_elf_new_section_hook
#define bfd_elf64_bfd_link_hash_table_create  ppc64_elf_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free    ppc64_elf_link_hash_table_free
a59 18
#define elf_backend_object_p		      ppc64_elf_object_p
#define elf_backend_grok_prstatus	      ppc64_elf_grok_prstatus
#define elf_backend_grok_psinfo		      ppc64_elf_grok_psinfo
#define elf_backend_create_dynamic_sections   ppc64_elf_create_dynamic_sections
#define elf_backend_copy_indirect_symbol      ppc64_elf_copy_indirect_symbol
#define elf_backend_check_relocs	      ppc64_elf_check_relocs
#define elf_backend_gc_mark_hook	      ppc64_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	      ppc64_elf_gc_sweep_hook
#define elf_backend_adjust_dynamic_symbol     ppc64_elf_adjust_dynamic_symbol
#define elf_backend_hide_symbol		      ppc64_elf_hide_symbol
#define elf_backend_always_size_sections      ppc64_elf_func_desc_adjust
#define elf_backend_size_dynamic_sections     ppc64_elf_size_dynamic_sections
#define elf_backend_relocate_section	      ppc64_elf_relocate_section
#define elf_backend_finish_dynamic_symbol     ppc64_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class	      ppc64_elf_reloc_type_class
#define elf_backend_finish_dynamic_sections   ppc64_elf_finish_dynamic_sections
#define elf_backend_link_output_symbol_hook   ppc64_elf_output_symbol_hook
#define elf_backend_special_sections	      ppc64_elf_special_sections
d72 1
a72 1
#define TOC_BASE_OFF	0x8000
d74 1
a74 8
/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000

/* .plt call stub instructions.  The normal stub is like this, but
   sometimes the .plt entry crosses a 64k boundary and we need to
   insert an addis to adjust r12.  */
#define PLT_CALL_STUB_SIZE (7*4)
d83 2
d86 7
a92 2
#define ADDIS_R2_R2	0x3c420000	/* addis %r2,%r2,off@@ha  */
#define ADDI_R2_R2	0x38420000	/* addi  %r2,%r2,off@@l   */
d94 2
a95 21
#define LD_R2_40R1	0xe8410028	/* ld    %r2,40(%r1)     */

/* glink call stub instructions.  We enter with the index in R0, and the
   address of glink entry in CTR.  From that, we can calculate PLT0.  */
#define GLINK_CALL_STUB_SIZE (16*4)
#define MFCTR_R12	0x7d8902a6	/* mfctr  %r12			*/
#define SLDI_R11_R0_3	0x780b1f24	/* sldi	  %r11,%r0,3		*/
#define ADDIC_R2_R0_32K 0x34408000	/* addic. %r2,%r0,-32768	*/
#define SUB_R12_R12_R11 0x7d8b6050	/* sub	  %r12,%r12,%r11	*/
#define SRADI_R2_R2_63	0x7c42fe76	/* sradi  %r2,%r2,63		*/
#define SLDI_R11_R0_2	0x780b1764	/* sldi	  %r11,%r0,2		*/
#define AND_R2_R2_R11	0x7c425838	/* and	  %r2,%r2,%r11		*/
					/* sub	  %r12,%r12,%r11	*/
#define ADD_R12_R12_R2	0x7d8c1214	/* add	  %r12,%r12,%r2		*/
#define ADDIS_R12_R12	0x3d8c0000	/* addis  %r12,%r12,xxx@@ha	*/
					/* ld	  %r11,xxx@@l(%r12)	*/
#define ADDI_R12_R12	0x398c0000	/* addi	  %r12,%r12,xxx@@l	*/
					/* ld	  %r2,8(%r12)		*/
					/* mtctr  %r11			*/
					/* ld	  %r11,16(%r12)		*/
					/* bctr				*/
d127 1
a127 1

d129 1
a129 1
static reloc_howto_type *ppc64_elf_howto_table[(int) R_PPC64_max];
d135 3
a137 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d142 1
a142 1
	 FALSE,			/* partial_inplace */
d145 1
a145 1
	 FALSE),		/* pcrel_offset */
d152 1
a152 1
	 FALSE,			/* pc_relative */
d157 1
a157 1
	 FALSE,			/* partial_inplace */
d160 1
a160 1
	 FALSE),		/* pcrel_offset */
d168 1
a168 1
	 FALSE,			/* pc_relative */
d173 1
a173 1
	 FALSE,			/* partial_inplace */
d176 1
a176 1
	 FALSE),		/* pcrel_offset */
d183 1
a183 1
	 FALSE,			/* pc_relative */
d188 1
a188 1
	 FALSE,			/* partial_inplace */
d191 1
a191 1
	 FALSE),		/* pcrel_offset */
d198 1
a198 1
	 FALSE,			/* pc_relative */
d203 1
a203 1
	 FALSE,			/* partial_inplace */
d206 1
a206 1
	 FALSE),		/* pcrel_offset */
d213 1
a213 1
	 FALSE,			/* pc_relative */
d218 1
a218 1
	 FALSE,			/* partial_inplace */
d221 1
a221 1
	 FALSE),		/* pcrel_offset */
d229 1
a229 1
	 FALSE,			/* pc_relative */
d234 1
a234 1
	 FALSE,			/* partial_inplace */
d237 1
a237 1
	 FALSE),		/* pcrel_offset */
d245 1
a245 1
	 FALSE,			/* pc_relative */
d250 1
a250 1
	 FALSE,			/* partial_inplace */
d253 1
a253 1
	 FALSE),		/* pcrel_offset */
d262 1
a262 1
	 FALSE,			/* pc_relative */
d267 1
a267 1
	 FALSE,			/* partial_inplace */
d270 1
a270 1
	 FALSE),		/* pcrel_offset */
d279 1
a279 1
	 FALSE,			/* pc_relative */
d284 1
a284 1
	 FALSE,			/* partial_inplace */
d287 1
a287 1
	 FALSE),		/* pcrel_offset */
d294 1
a294 1
	 TRUE,			/* pc_relative */
d299 1
a299 1
	 FALSE,			/* partial_inplace */
d302 1
a302 1
	 TRUE),			/* pcrel_offset */
d309 1
a309 1
	 TRUE,			/* pc_relative */
d314 1
a314 1
	 FALSE,			/* partial_inplace */
d317 1
a317 1
	 TRUE),			/* pcrel_offset */
d326 1
a326 1
	 TRUE,			/* pc_relative */
d331 1
a331 1
	 FALSE,			/* partial_inplace */
d334 1
a334 1
	 TRUE),			/* pcrel_offset */
d343 1
a343 1
	 TRUE,			/* pc_relative */
d348 1
a348 1
	 FALSE,			/* partial_inplace */
d351 1
a351 1
	 TRUE),			/* pcrel_offset */
d359 1
a359 1
	 FALSE,			/* pc_relative */
d364 1
a364 1
	 FALSE,			/* partial_inplace */
d367 1
a367 1
	 FALSE),		/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 FALSE),		/* pcrel_offset */
d391 1
a391 1
	 FALSE,			/* pc_relative */
d396 1
a396 1
	 FALSE,			/* partial_inplace */
d399 1
a399 1
	 FALSE),		/* pcrel_offset */
d407 1
a407 1
	 FALSE,			/* pc_relative */
d412 1
a412 1
	 FALSE,			/* partial_inplace */
d415 1
a415 1
	 FALSE),		/* pcrel_offset */
d426 1
a426 1
	 FALSE,			/* pc_relative */
d431 1
a431 1
	 FALSE,			/* partial_inplace */
d434 1
a434 1
	 FALSE),		/* pcrel_offset */
d442 1
a442 1
	 FALSE,			/* pc_relative */
d447 1
a447 1
	 FALSE,			/* partial_inplace */
d450 1
a450 1
	 FALSE),		/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),		/* pcrel_offset */
d475 1
a475 1
	 FALSE,			/* pc_relative */
d480 1
a480 1
	 FALSE,			/* partial_inplace */
d483 1
a483 1
	 FALSE),		/* pcrel_offset */
d490 1
a490 1
	 FALSE,			/* pc_relative */
d495 1
a495 1
	 FALSE,			/* partial_inplace */
d498 1
a498 1
	 FALSE),		/* pcrel_offset */
d505 1
a505 1
	 FALSE,			/* pc_relative */
d510 1
a510 1
	 FALSE,			/* partial_inplace */
d513 1
a513 1
	 FALSE),		/* pcrel_offset */
d520 1
a520 1
	 TRUE,			/* pc_relative */
d526 1
a526 1
	 FALSE,			/* partial_inplace */
d529 1
a529 1
	 TRUE),			/* pcrel_offset */
d536 1
a536 1
	 FALSE,			/* pc_relative */
d541 1
a541 1
	 FALSE,			/* partial_inplace */
d544 1
a544 1
	 FALSE),		/* pcrel_offset */
d552 1
a552 1
	 TRUE,			/* pc_relative */
d557 1
a557 1
	 FALSE,			/* partial_inplace */
d560 1
a560 1
	 TRUE),			/* pcrel_offset */
d568 1
a568 1
	 FALSE,			/* pc_relative */
d573 1
a573 1
	 FALSE,			/* partial_inplace */
d576 1
a576 1
	 FALSE),		/* pcrel_offset */
d584 1
a584 1
	 FALSE,			/* pc_relative */
d589 1
a589 1
	 FALSE,			/* partial_inplace */
d592 1
a592 1
	 FALSE),		/* pcrel_offset */
d600 1
a600 1
	 FALSE,			/* pc_relative */
d605 1
a605 1
	 FALSE,			/* partial_inplace */
d608 1
a608 1
	 FALSE),		/* pcrel_offset */
d615 1
a615 1
	 FALSE,			/* pc_relative */
d620 1
a620 1
	 FALSE,			/* partial_inplace */
d623 1
a623 1
	 FALSE),		/* pcrel_offset */
d630 1
a630 1
	 FALSE,			/* pc_relative */
d635 1
a635 1
	 FALSE,			/* partial_inplace */
d638 1
a638 1
	 FALSE),		/* pcrel_offset */
d645 1
a645 1
	 FALSE,			/* pc_relative */
d650 1
a650 1
	 FALSE,			/* partial_inplace */
d653 1
a653 1
	 FALSE),		/* pcrel_offset */
d660 1
a660 1
	 FALSE,			/* pc_relative */
d665 1
a665 1
	 FALSE,			/* partial_inplace */
d668 1
a668 1
	 FALSE),		/* pcrel_offset */
d670 3
a672 2
  /* Like R_PPC64_REL24 without touching the two least significant bits.  */
  HOWTO (R_PPC64_REL30,		/* type */
d676 1
a676 1
	 TRUE,			/* pc_relative */
d680 2
a681 2
	 "R_PPC64_REL30",	/* name */
	 FALSE,			/* partial_inplace */
d684 1
a684 1
	 TRUE),			/* pcrel_offset */
d693 1
a693 1
	 FALSE,			/* pc_relative */
d698 1
a698 1
	 FALSE,			/* partial_inplace */
d701 1
a701 1
	 FALSE),		/* pcrel_offset */
d708 1
a708 1
	 FALSE,			/* pc_relative */
d713 1
a713 1
	 FALSE,			/* partial_inplace */
d716 1
a716 1
	 FALSE),		/* pcrel_offset */
d724 1
a724 1
	 FALSE,			/* pc_relative */
d729 1
a729 1
	 FALSE,			/* partial_inplace */
d732 1
a732 1
	 FALSE),		/* pcrel_offset */
d739 1
a739 1
	 FALSE,			/* pc_relative */
d744 1
a744 1
	 FALSE,			/* partial_inplace */
d747 1
a747 1
	 FALSE),		/* pcrel_offset */
d755 1
a755 1
	 FALSE,			/* pc_relative */
d760 1
a760 1
	 FALSE,			/* partial_inplace */
d763 1
a763 1
	 FALSE),		/* pcrel_offset */
d770 1
a770 1
	 FALSE,			/* pc_relative */
d775 1
a775 1
	 FALSE,			/* partial_inplace */
d778 1
a778 1
	 FALSE),		/* pcrel_offset */
d785 1
a785 1
	 TRUE,			/* pc_relative */
d790 1
a790 1
	 FALSE,			/* partial_inplace */
d793 1
a793 1
	 TRUE),			/* pcrel_offset */
d800 1
a800 1
	 FALSE,			/* pc_relative */
d805 1
a805 1
	 FALSE,			/* partial_inplace */
d808 1
a808 1
	 FALSE),		/* pcrel_offset */
d817 1
a817 1
	 TRUE,			/* pc_relative */
d822 1
a822 1
	 FALSE,			/* partial_inplace */
d825 1
a825 1
	 TRUE),			/* pcrel_offset */
d834 1
a834 1
	 FALSE,			/* pc_relative */
d839 1
a839 1
	 FALSE,			/* partial_inplace */
d842 1
a842 1
	 FALSE),		/* pcrel_offset */
d851 1
a851 1
	 FALSE,			/* pc_relative */
d856 1
a856 1
	 FALSE,			/* partial_inplace */
d859 1
a859 1
	 FALSE),		/* pcrel_offset */
d868 1
a868 1
	 FALSE,			/* pc_relative */
d873 1
a873 1
	 FALSE,			/* partial_inplace */
d876 1
a876 1
	 FALSE),		/* pcrel_offset */
d887 1
a887 1
	 FALSE,			/* pc_relative */
d892 1
a892 1
	 FALSE,			/* partial_inplace */
d895 1
a895 1
	 FALSE),		/* pcrel_offset */
d904 1
a904 1
	 FALSE,			/* pc_relative */
d909 1
a909 1
	 FALSE,			/* partial_inplace */
d912 1
a912 1
	 FALSE),		/* pcrel_offset */
d927 1
a927 1
	 FALSE,			/* pc_relative */
d932 1
a932 1
	 FALSE,			/* partial_inplace */
d935 1
a935 1
	 FALSE),		/* pcrel_offset */
d943 1
a943 1
	 FALSE,			/* pc_relative */
d948 1
a948 1
	 FALSE,			/* partial_inplace */
d951 1
a951 1
	 FALSE),		/* pcrel_offset */
d959 1
a959 1
	 FALSE,			/* pc_relative */
d964 1
a964 1
	 FALSE,			/* partial_inplace */
d967 1
a967 1
	 FALSE),		/* pcrel_offset */
d977 1
a977 1
	 FALSE,			/* pc_relative */
d982 1
a982 1
	 FALSE,			/* partial_inplace */
d985 1
a985 1
	 FALSE),		/* pcrel_offset */
d992 1
a992 1
	 FALSE,			/* pc_relative */
d997 1
a997 1
	 FALSE,			/* partial_inplace */
d1000 1
a1000 1
	 FALSE),		/* pcrel_offset */
d1007 1
a1007 1
	 FALSE,			/* pc_relative */
d1012 1
a1012 1
	 FALSE,			/* partial_inplace */
d1015 1
a1015 1
	 FALSE),		/* pcrel_offset */
d1022 1
a1022 1
	 FALSE,			/* pc_relative */
d1027 1
a1027 1
	 FALSE,			/* partial_inplace */
d1030 1
a1030 1
	 FALSE),		/* pcrel_offset */
d1037 1
a1037 1
	 FALSE,			/* pc_relative */
d1042 1
a1042 1
	 FALSE,			/* partial_inplace */
d1045 1
a1045 1
	 FALSE),		/* pcrel_offset */
d1052 1
a1052 1
	 FALSE,			/* pc_relative */
d1057 1
a1057 1
	 FALSE,			/* partial_inplace */
d1060 1
a1060 1
	 FALSE),		/* pcrel_offset */
d1067 1
a1067 1
	 FALSE,			/* pc_relative */
d1072 1
a1072 1
	 FALSE,			/* partial_inplace */
d1075 1
a1075 1
	 FALSE),		/* pcrel_offset */
d1082 1
a1082 1
	 FALSE,			/* pc_relative */
d1087 1
a1087 1
	 FALSE,			/* partial_inplace */
d1090 1
a1090 1
	 FALSE),		/* pcrel_offset */
d1097 1
a1097 1
	 FALSE,			/* pc_relative */
d1102 1
a1102 1
	 FALSE,			/* partial_inplace */
d1105 1
a1105 1
	 FALSE),		/* pcrel_offset */
d1112 1
a1112 1
	 FALSE,			/* pc_relative */
d1117 1
a1117 1
	 FALSE,			/* partial_inplace */
d1120 1
a1120 1
	 FALSE),		/* pcrel_offset */
d1128 1
a1128 1
	 FALSE,			/* pc_relative */
d1133 1
a1133 1
	 FALSE,			/* partial_inplace */
d1136 1
a1136 1
	 FALSE),		/* pcrel_offset */
d1144 1
a1144 1
	 FALSE,			/* pc_relative */
d1149 1
a1149 1
	 FALSE,			/* partial_inplace */
d1152 1
a1152 1
	 FALSE),		/* pcrel_offset */
d1154 2
a1155 2
  /* Marker reloc for TLS.  */
  HOWTO (R_PPC64_TLS,
d1157 3
a1159 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d1162 3
a1164 3
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TLS",		/* name */
	 FALSE,			/* partial_inplace */
d1167 1
a1167 1
	 FALSE),		/* pcrel_offset */
d1169 2
a1170 3
  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC64_DTPMOD64,
d1172 3
a1174 3
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
d1177 3
a1179 3
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPMOD64",	/* name */
	 FALSE,			/* partial_inplace */
d1181 12
a1192 2
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1194 10
a1203 16
  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC64_DTPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1205 6
a1210 14
  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC64_DTPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1212 3
a1214 14
  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1216 4
a1219 14
  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1221 123
a1343 14
  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1345 2
a1346 14
  /* Like DTPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHER", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1348 1
a1348 14
  /* Like DTPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1350 7
a1356 14
  /* Like DTPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1358 3
a1360 14
  /* Like DTPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1362 5
a1366 14
  /* Like DTPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_DTPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1368 1
a1368 14
  /* Like DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1370 11
a1380 710
  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC64_TPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC64_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_TPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSGD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSGD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSLD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSLD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_DTPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_DTPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_TPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC64_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC64_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC64_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC64_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
};


/* Initialize the ppc64_elf_howto_table, so that linear accesses can
   be done.  */

static void
ppc_howto_init (void)
{
  unsigned int i, type;

  for (i = 0;
       i < sizeof (ppc64_elf_howto_raw) / sizeof (ppc64_elf_howto_raw[0]);
       i++)
    {
      type = ppc64_elf_howto_raw[i].type;
      BFD_ASSERT (type < (sizeof (ppc64_elf_howto_table)
			  / sizeof (ppc64_elf_howto_table[0])));
      ppc64_elf_howto_table[type] = &ppc64_elf_howto_raw[i];
    }
}

static reloc_howto_type *
ppc64_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     bfd_reloc_code_real_type code)
{
  enum elf_ppc64_reloc_type r = R_PPC64_NONE;

  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
    /* Initialize howto table if needed.  */
    ppc_howto_init ();

  switch (code)
    {
    default:
      return NULL;

    case BFD_RELOC_NONE:			r = R_PPC64_NONE;
      break;
    case BFD_RELOC_32:				r = R_PPC64_ADDR32;
      break;
    case BFD_RELOC_PPC_BA26:			r = R_PPC64_ADDR24;
      break;
    case BFD_RELOC_16:				r = R_PPC64_ADDR16;
      break;
    case BFD_RELOC_LO16:			r = R_PPC64_ADDR16_LO;
      break;
    case BFD_RELOC_HI16:			r = R_PPC64_ADDR16_HI;
      break;
    case BFD_RELOC_HI16_S:			r = R_PPC64_ADDR16_HA;
      break;
    case BFD_RELOC_PPC_BA16:			r = R_PPC64_ADDR14;
      break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:		r = R_PPC64_ADDR14_BRTAKEN;
      break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:		r = R_PPC64_ADDR14_BRNTAKEN;
      break;
    case BFD_RELOC_PPC_B26:			r = R_PPC64_REL24;
      break;
    case BFD_RELOC_PPC_B16:			r = R_PPC64_REL14;
      break;
    case BFD_RELOC_PPC_B16_BRTAKEN:		r = R_PPC64_REL14_BRTAKEN;
      break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:		r = R_PPC64_REL14_BRNTAKEN;
      break;
    case BFD_RELOC_16_GOTOFF:			r = R_PPC64_GOT16;
      break;
    case BFD_RELOC_LO16_GOTOFF:			r = R_PPC64_GOT16_LO;
      break;
    case BFD_RELOC_HI16_GOTOFF:			r = R_PPC64_GOT16_HI;
      break;
    case BFD_RELOC_HI16_S_GOTOFF:		r = R_PPC64_GOT16_HA;
      break;
    case BFD_RELOC_PPC_COPY:			r = R_PPC64_COPY;
      break;
    case BFD_RELOC_PPC_GLOB_DAT:		r = R_PPC64_GLOB_DAT;
      break;
    case BFD_RELOC_32_PCREL:			r = R_PPC64_REL32;
      break;
    case BFD_RELOC_32_PLTOFF:			r = R_PPC64_PLT32;
      break;
    case BFD_RELOC_32_PLT_PCREL:		r = R_PPC64_PLTREL32;
      break;
    case BFD_RELOC_LO16_PLTOFF:			r = R_PPC64_PLT16_LO;
      break;
    case BFD_RELOC_HI16_PLTOFF:			r = R_PPC64_PLT16_HI;
      break;
    case BFD_RELOC_HI16_S_PLTOFF:		r = R_PPC64_PLT16_HA;
      break;
    case BFD_RELOC_16_BASEREL:			r = R_PPC64_SECTOFF;
      break;
    case BFD_RELOC_LO16_BASEREL:		r = R_PPC64_SECTOFF_LO;
      break;
    case BFD_RELOC_HI16_BASEREL:		r = R_PPC64_SECTOFF_HI;
      break;
    case BFD_RELOC_HI16_S_BASEREL:		r = R_PPC64_SECTOFF_HA;
      break;
    case BFD_RELOC_CTOR:			r = R_PPC64_ADDR64;
      break;
    case BFD_RELOC_64:				r = R_PPC64_ADDR64;
      break;
    case BFD_RELOC_PPC64_HIGHER:		r = R_PPC64_ADDR16_HIGHER;
      break;
    case BFD_RELOC_PPC64_HIGHER_S:		r = R_PPC64_ADDR16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_HIGHEST:		r = R_PPC64_ADDR16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_HIGHEST_S:		r = R_PPC64_ADDR16_HIGHESTA;
      break;
    case BFD_RELOC_64_PCREL:			r = R_PPC64_REL64;
      break;
    case BFD_RELOC_64_PLTOFF:			r = R_PPC64_PLT64;
      break;
    case BFD_RELOC_64_PLT_PCREL:		r = R_PPC64_PLTREL64;
      break;
    case BFD_RELOC_PPC_TOC16:			r = R_PPC64_TOC16;
      break;
    case BFD_RELOC_PPC64_TOC16_LO:		r = R_PPC64_TOC16_LO;
      break;
    case BFD_RELOC_PPC64_TOC16_HI:		r = R_PPC64_TOC16_HI;
      break;
    case BFD_RELOC_PPC64_TOC16_HA:		r = R_PPC64_TOC16_HA;
      break;
    case BFD_RELOC_PPC64_TOC:			r = R_PPC64_TOC;
      break;
    case BFD_RELOC_PPC64_PLTGOT16:		r = R_PPC64_PLTGOT16;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_LO:		r = R_PPC64_PLTGOT16_LO;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_HI:		r = R_PPC64_PLTGOT16_HI;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_HA:		r = R_PPC64_PLTGOT16_HA;
      break;
    case BFD_RELOC_PPC64_ADDR16_DS:		r = R_PPC64_ADDR16_DS;
      break;
    case BFD_RELOC_PPC64_ADDR16_LO_DS:		r = R_PPC64_ADDR16_LO_DS;
      break;
    case BFD_RELOC_PPC64_GOT16_DS:		r = R_PPC64_GOT16_DS;
      break;
    case BFD_RELOC_PPC64_GOT16_LO_DS:		r = R_PPC64_GOT16_LO_DS;
      break;
    case BFD_RELOC_PPC64_PLT16_LO_DS:		r = R_PPC64_PLT16_LO_DS;
      break;
    case BFD_RELOC_PPC64_SECTOFF_DS:		r = R_PPC64_SECTOFF_DS;
      break;
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:		r = R_PPC64_SECTOFF_LO_DS;
      break;
    case BFD_RELOC_PPC64_TOC16_DS:		r = R_PPC64_TOC16_DS;
      break;
    case BFD_RELOC_PPC64_TOC16_LO_DS:		r = R_PPC64_TOC16_LO_DS;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_DS:		r = R_PPC64_PLTGOT16_DS;
      break;
    case BFD_RELOC_PPC64_PLTGOT16_LO_DS:	r = R_PPC64_PLTGOT16_LO_DS;
      break;
    case BFD_RELOC_PPC_TLS:			r = R_PPC64_TLS;
      break;
    case BFD_RELOC_PPC_DTPMOD:			r = R_PPC64_DTPMOD64;
      break;
    case BFD_RELOC_PPC_TPREL16:			r = R_PPC64_TPREL16;
      break;
    case BFD_RELOC_PPC_TPREL16_LO:		r = R_PPC64_TPREL16_LO;
      break;
    case BFD_RELOC_PPC_TPREL16_HI:		r = R_PPC64_TPREL16_HI;
      break;
    case BFD_RELOC_PPC_TPREL16_HA:		r = R_PPC64_TPREL16_HA;
      break;
    case BFD_RELOC_PPC_TPREL:			r = R_PPC64_TPREL64;
      break;
    case BFD_RELOC_PPC_DTPREL16:		r = R_PPC64_DTPREL16;
      break;
    case BFD_RELOC_PPC_DTPREL16_LO:		r = R_PPC64_DTPREL16_LO;
      break;
    case BFD_RELOC_PPC_DTPREL16_HI:		r = R_PPC64_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_DTPREL16_HA:		r = R_PPC64_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC_DTPREL:			r = R_PPC64_DTPREL64;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16:		r = R_PPC64_GOT_TLSGD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:		r = R_PPC64_GOT_TLSGD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:		r = R_PPC64_GOT_TLSGD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:		r = R_PPC64_GOT_TLSGD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16:		r = R_PPC64_GOT_TLSLD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:		r = R_PPC64_GOT_TLSLD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:		r = R_PPC64_GOT_TLSLD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:		r = R_PPC64_GOT_TLSLD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16:		r = R_PPC64_GOT_TPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:		r = R_PPC64_GOT_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:		r = R_PPC64_GOT_TPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:		r = R_PPC64_GOT_TPREL16_HA;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16:		r = R_PPC64_GOT_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:		r = R_PPC64_GOT_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:		r = R_PPC64_GOT_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:		r = R_PPC64_GOT_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC64_TPREL16_DS:		r = R_PPC64_TPREL16_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_LO_DS:		r = R_PPC64_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHER:	r = R_PPC64_TPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHERA:	r = R_PPC64_TPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHEST:	r = R_PPC64_TPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHESTA:	r = R_PPC64_TPREL16_HIGHESTA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_DS:		r = R_PPC64_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_LO_DS:	r = R_PPC64_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHER:	r = R_PPC64_DTPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHERA:	r = R_PPC64_DTPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHEST:	r = R_PPC64_DTPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:	r = R_PPC64_DTPREL16_HIGHESTA;
      break;
    case BFD_RELOC_VTABLE_INHERIT:		r = R_PPC64_GNU_VTINHERIT;
      break;
    case BFD_RELOC_VTABLE_ENTRY:		r = R_PPC64_GNU_VTENTRY;
      break;
    }

  return ppc64_elf_howto_table[r];
};

/* Set the howto pointer for a PowerPC ELF reloc.  */

static void
ppc64_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			 Elf_Internal_Rela *dst)
{
  unsigned int type;

  /* Initialize howto table if needed.  */
  if (!ppc64_elf_howto_table[R_PPC64_ADDR32])
    ppc_howto_init ();

  type = ELF64_R_TYPE (dst->r_info);
  BFD_ASSERT (type < (sizeof (ppc64_elf_howto_table)
		      / sizeof (ppc64_elf_howto_table[0])));
  cache_ptr->howto = ppc64_elf_howto_table[type];
}

/* Handle the R_PPC64_ADDR16_HA and similar relocs.  */

static bfd_reloc_status_type
ppc64_elf_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
{
d1396 9
a1404 3
ppc64_elf_brtaken_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
d1407 1
a1407 1
  enum elf_ppc64_reloc_type r_type;
d1410 1
a1410 1
  bfd_boolean is_power4 = FALSE;
d1422 1
a1422 1
  r_type = reloc_entry->howto->type;
d1458 1
a1458 1
  bfd_put_32 (abfd, insn, (bfd_byte *) data + octets);
d1463 9
a1471 3
ppc64_elf_sectoff_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
d1486 9
a1494 3
ppc64_elf_sectoff_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			    void *data, asection *input_section,
			    bfd *output_bfd, char **error_message)
d1512 9
a1520 3
ppc64_elf_toc_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
d1541 9
a1549 3
ppc64_elf_toc_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section,
			bfd *output_bfd, char **error_message)
d1573 9
a1581 3
ppc64_elf_toc64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		       void *data, asection *input_section,
		       bfd *output_bfd, char **error_message)
d1603 9
a1611 3
ppc64_elf_unhandled_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
a1629 34
struct ppc64_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* Shortcuts to dynamic linker sections.  */
  asection *got;
  asection *relgot;

  /* TLS local dynamic got entry handling.  Suppose for multiple GOT
     sections means we potentially need one of these for each input bfd.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;
};

#define ppc64_elf_tdata(bfd) \
  ((struct ppc64_elf_obj_tdata *) (bfd)->tdata.any)

#define ppc64_tlsld_got(bfd) \
  (&ppc64_elf_tdata (bfd)->tlsld_got)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc64_elf_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct ppc64_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

d1633 3
a1635 2
static bfd_boolean
ppc64_elf_object_p (bfd *abfd)
d1648 1
a1648 40
  return TRUE;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
ppc64_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t offset, raw_size;

  if (note->descsz != 504)
    return FALSE;

  /* pr_cursig */
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

  /* pr_pid */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

  /* pr_reg */
  offset = 112;
  raw_size = 384;

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
ppc64_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz != 136)
    return FALSE;

  elf_tdata (abfd)->core_program
    = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
  elf_tdata (abfd)->core_command
    = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);

  return TRUE;
d1654 4
a1657 2
static bfd_boolean
ppc64_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
a1660 1
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
d1666 1
a1666 2
	msg = _("%s: compiled for a big endian system "
		"and target is little endian");
d1668 1
a1668 2
	msg = _("%s: compiled for a little endian system "
		"and target is big endian");
d1673 1
a1673 1
      return FALSE;
d1676 1
a1676 49
  return TRUE;
}

/* Add extra PPC sections.  */

static struct bfd_elf_special_section const ppc64_elf_special_sections[]=
{
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".plt",     4,  0, SHT_NOBITS,   0 },
  { ".toc",     4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".toc1",    5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".tocbss",  7,  0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
};

struct _ppc64_elf_section_data
{
  struct bfd_elf_section_data elf;

  /* An array with one entry for each opd function descriptor.  */
  union
  {
    /* Points to the function code section for local opd entries.  */
    asection **func_sec;
    /* After editing .opd, adjust references to opd local syms.  */
    long *adjust;
  } opd;

  /* An array for toc sections, indexed by offset/8.
     Specifies the relocation symbol index used at a given toc offset.  */
  unsigned *t_symndx;
};

#define ppc64_elf_section_data(sec) \
  ((struct _ppc64_elf_section_data *) elf_section_data (sec))

static bfd_boolean
ppc64_elf_new_section_hook (bfd *abfd, asection *sec)
{
  struct _ppc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
d1719 1
a1719 1
   .		addi	12,12,Lfoo@@toc@@l	# is slightly optimized, but
a1766 43
/* Track GOT entries needed for a given symbol.  We might need more
   than one got entry per symbol.  */
struct got_entry
{
  struct got_entry *next;

  /* The symbol addend that we'll be placing in the GOT.  */
  bfd_vma addend;

  /* Unlike other ELF targets, we use separate GOT entries for the same
     symbol referenced from different input files.  This is to support
     automatic multiple TOC/GOT sections, where the TOC base can vary
     from one input file to another.

     Point to the BFD owning this GOT entry.  */
  bfd *owner;

  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
  char tls_type;

  /* Reference count until size_dynamic_sections, GOT offset thereafter.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } got;
};

/* The same for PLT.  */
struct plt_entry
{
  struct plt_entry *next;

  bfd_vma addend;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
};

d1768 1
a1768 2
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */
d1770 1
a1770 1
#define MUST_BE_DYN_RELOC(RTYPE)		\
d1773 1
a1773 18
   && (RTYPE) != R_PPC64_REL30)

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  With code that gcc generates, it's vital that this be
   enabled;  In the PowerPC64 ABI, the address of a function is actually
   the address of a function descriptor, which resides in the .opd
   section.  gcc uses the descriptor directly rather than going via the
   GOT as some other ABI's do, which means that initialized function
   pointers must reference the descriptor.  Thus, a function pointer
   initialized to the address of a function in a shared library will
   either require a copy reloc, or a dynamic reloc.  Using a copy reloc
   redefines the function descriptor symbol to point to the copy.  This
   presents a problem as a plt entry for that function is also
   initialized from the function descriptor symbol and the copy reloc
   may not be initialized first.  */
#define ELIMINATE_COPY_RELOCS 1
d1788 2
a1789 2
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
d1795 1
a1795 17
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	std	%r2,40(%r1)
   .	ld	%r11,xxx+0@@toc@@l(%r12)
   .	ld	%r2,xxx+8@@toc@@l(%r12)
   .	mtctr	%r11
   .	ld	%r11,xxx+16@@toc@@l(%r12)
   .	bctr

   ppc_stub_long_branch and ppc_stub_plt_branch may also have additional
   code to adjust the value and save r2 to support multiple toc sections.
   A ppc_stub_long_branch with an r2 offset looks like:
   .	std	%r2,40(%r1)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
   .	b	dest

   A ppc_stub_plt_branch with an r2 offset looks like:
d1797 2
a1798 4
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
d1800 1
a1806 1
  ppc_stub_long_branch_r2off,
a1807 1
  ppc_stub_plt_branch_r2off,
a1815 2
  enum ppc_stub_type stub_type;

d1827 2
a1831 3
  /* And the reloc addend that this was derived from.  */
  bfd_vma addend;

a1866 20

  /* Whether global opd sym has been adjusted or not.  */
  unsigned int adjust_done:1;

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.
     tls_optimize may also set TLS_TPRELGD when a GD reloc turns into
     a TPREL one.  We use a separate flag rather than setting TPREL
     just for convenience in distinguishing the two cases.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_EXPLICIT	32	/* Marks TOC section TLS relocs. */
#define TLS_TPRELGD	64	/* TPREL reloc resulting from GD->IE. */
  char tls_mask;
d1885 2
a1886 2
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);
a1894 2
    /* Along with elf_gp, specifies the TOC pointer used in this group.  */
    bfd_vma toc_off;
d1897 1
a1897 11
  /* Support for multiple toc sections.  */
  unsigned int no_multi_toc;
  unsigned int multi_toc_needed;

  /* Temp used when calculating TOC pointers.  */
  bfd_vma toc_curr;

  /* Highest input section id.  */
  int top_id;

  /* Highest output section index.  */
a1898 2

  /* List of input sections for each output section.  */
d1902 7
a1908 6
  asection *got;
  asection *plt;
  asection *relplt;
  asection *dynbss;
  asection *relbss;
  asection *glink;
d1910 2
a1911 11
  asection *brlt;
  asection *relbrlt;

  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* Statistics.  */
  unsigned long stub_count[ppc_stub_plt_call];

  /* Set if we should emit symbols for stubs.  */
  unsigned int emit_stub_syms;
d1930 75
d2021 4
a2024 3
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
a2042 1
      eh->stub_type = ppc_stub_none;
d2047 1
d2058 4
a2061 3
branch_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table,
		     const char *string)
d2090 4
a2093 3
link_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
a2115 2
      eh->adjust_done = 0;
      eh->tls_mask = 0;
d2124 2
a2125 1
ppc64_elf_link_hash_table_create (bfd *abfd)
d2130 1
a2130 1
  htab = bfd_zmalloc (amt);
d2148 19
a2166 8
  /* Initializing two fields of the union is just cosmetic.  We really
     only care about glist, but when compiled on a 32-bit host the
     bfd_vma fields are larger.  Setting the bfd_vma to zero makes
     debugger inspection of these fields look nicer.  */
  htab->elf.init_refcount.refcount = 0;
  htab->elf.init_refcount.glist = NULL;
  htab->elf.init_offset.offset = 0;
  htab->elf.init_offset.glist = NULL;
d2174 2
a2175 1
ppc64_elf_link_hash_table_free (struct bfd_link_hash_table *hash)
a2183 17
/* Satisfy the ELF linker by filling in some fields in our fake bfd.  */

void
ppc64_elf_init_stub_bfd (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  elf_elfheader (abfd)->e_ident[EI_CLASS] = ELFCLASS64;

/* Always hook our dynamic sections into the first bfd, which is the
   linker created stub bfd.  This ensures that the GOT header is at
   the start of the output TOC section.  */
  htab = ppc_hash_table (info);
  htab->stub_bfd = abfd;
  htab->elf.dynobj = abfd;
}

d2187 5
a2191 4
ppc_stub_name (const asection *input_section,
	       const asection *sym_sec,
	       const struct ppc_link_hash_entry *h,
	       const Elf_Internal_Rela *rel)
d2207 1
a2207 1
	  sprintf (stub_name, "%08x.%s+%x",
d2215 1
a2215 1
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
d2219 1
a2219 1
	  sprintf (stub_name, "%08x.%x:%x+%x",
d2233 6
a2238 5
ppc_get_stub_entry (const asection *input_section,
		    const asection *sym_sec,
		    struct elf_link_hash_entry *hash,
		    const Elf_Internal_Rela *rel,
		    struct ppc_link_hash_table *htab)
d2266 1
a2266 1
					 stub_name, FALSE, FALSE);
d2280 4
a2283 3
ppc_add_stub (const char *stub_name,
	      asection *section,
	      struct ppc_link_hash_table *htab)
d2318 1
a2318 1
				     TRUE, FALSE);
d2335 4
a2338 2
static bfd_boolean
create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)
d2352 1
a2352 1
    return FALSE;
d2355 5
a2359 5
  htab->glink = bfd_make_section_anyway (dynobj, ".glink");
  if (htab->glink == NULL
      || ! bfd_set_section_flags (dynobj, htab->glink, flags)
      || ! bfd_set_section_alignment (dynobj, htab->glink, 2))
    return FALSE;
d2364 5
a2368 5
  htab->brlt = bfd_make_section_anyway (dynobj, ".branch_lt");
  if (htab->brlt == NULL
      || ! bfd_set_section_flags (dynobj, htab->brlt, flags)
      || ! bfd_set_section_alignment (dynobj, htab->brlt, 3))
    return FALSE;
d2374 16
a2389 14
      htab->relbrlt = bfd_make_section_anyway (dynobj, ".rela.branch_lt");
      if (!htab->relbrlt
	  || ! bfd_set_section_flags (dynobj, htab->relbrlt, flags)
	  || ! bfd_set_section_alignment (dynobj, htab->relbrlt, 3))
	return FALSE;
    }
  return TRUE;
}

/* Create .got and .rela.got sections in ABFD, and .got in dynobj if
   not already done.  */

static bfd_boolean
create_got_section (bfd *abfd, struct bfd_link_info *info)
d2391 1
a2391 3
  asection *got, *relgot;
  flagword flags;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
d2393 2
a2394 4
  if (!htab->got)
    {
      if (! _bfd_elf_create_got_section (htab->elf.dynobj, info))
	return FALSE;
d2396 4
a2399 4
      htab->got = bfd_get_section_by_name (htab->elf.dynobj, ".got");
      if (!htab->got)
	abort ();
    }
d2401 9
a2409 18
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  got = bfd_make_section (abfd, ".got");
  if (!got
      || !bfd_set_section_flags (abfd, got, flags)
      || !bfd_set_section_alignment (abfd, got, 3))
    return FALSE;

  relgot = bfd_make_section (abfd, ".rela.got");
  if (!relgot
      || ! bfd_set_section_flags (abfd, relgot, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, relgot, 3))
    return FALSE;

  ppc64_elf_tdata (abfd)->got = got;
  ppc64_elf_tdata (abfd)->relgot = relgot;
  return TRUE;
d2414 4
a2417 2
static bfd_boolean
ppc64_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d2421 4
d2426 1
a2426 1
    return FALSE;
d2428 3
a2430 6
  htab = ppc_hash_table (info);
  if (!htab->got)
    htab->got = bfd_get_section_by_name (dynobj, ".got");
  htab->plt = bfd_get_section_by_name (dynobj, ".plt");
  htab->relplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->dynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d2432 1
a2432 1
    htab->relbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d2434 2
a2435 2
  if (!htab->got || !htab->plt || !htab->relplt || !htab->dynbss
      || (!info->shared && !htab->relbss))
d2438 1
a2438 1
  return TRUE;
d2444 3
a2446 4
ppc64_elf_copy_indirect_symbol
  (const struct elf_backend_data *bed ATTRIBUTE_UNUSED,
   struct elf_link_hash_entry *dir,
   struct elf_link_hash_entry *ind)
a2448 1
  flagword mask;
a2452 1
  /* Copy over any dynamic relocs we may have on the indirect sym.  */
d2460 1
a2460 1
	  if (eind->elf.root.type == bfd_link_hash_indirect)
a2489 79
  edir->tls_mask |= eind->tls_mask;

  mask = (ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF
	  | ELF_LINK_HASH_NEEDS_PLT);
  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (ELIMINATE_COPY_RELOCS
      && eind->elf.root.type != bfd_link_hash_indirect
      && (edir->elf.elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    mask &= ~ELF_LINK_NON_GOT_REF;

  edir->elf.elf_link_hash_flags |= eind->elf.elf_link_hash_flags & mask;

  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

  /* Copy over got entries that we may have already seen to the
     symbol which just became indirect.  */
  if (eind->elf.got.glist != NULL)
    {
      if (edir->elf.got.glist != NULL)
	{
	  struct got_entry **entp;
	  struct got_entry *ent;

	  for (entp = &eind->elf.got.glist; (ent = *entp) != NULL; )
	    {
	      struct got_entry *dent;

	      for (dent = edir->elf.got.glist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend
		    && dent->owner == ent->owner
		    && dent->tls_type == ent->tls_type)
		  {
		    dent->got.refcount += ent->got.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.got.glist;
	}

      edir->elf.got.glist = eind->elf.got.glist;
      eind->elf.got.glist = NULL;
    }

  /* And plt entries.  */
  if (eind->elf.plt.plist != NULL)
    {
      if (edir->elf.plt.plist != NULL)
	{
	  struct plt_entry **entp;
	  struct plt_entry *ent;

	  for (entp = &eind->elf.plt.plist; (ent = *entp) != NULL; )
	    {
	      struct plt_entry *dent;

	      for (dent = edir->elf.plt.plist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend)
		  {
		    dent->plt.refcount += ent->plt.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.plt.plist;
	}

      edir->elf.plt.plist = eind->elf.plt.plist;
      eind->elf.plt.plist = NULL;
    }
d2491 1
a2491 9
  if (edir->elf.dynindx == -1)
    {
      edir->elf.dynindx = eind->elf.dynindx;
      edir->elf.dynstr_index = eind->elf.dynstr_index;
      eind->elf.dynindx = -1;
      eind->elf.dynstr_index = 0;
    }
  else
    BFD_ASSERT (eind->elf.dynindx == -1);
d2497 3
a2499 95
bfd_boolean
ppc64_elf_mark_entry_syms (struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;
  struct bfd_sym_chain *sym;

  htab = ppc_hash_table (info);
  for (sym = info->gc_sym_list; sym; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
      if (h != NULL)
	((struct ppc_link_hash_entry *) h)->is_entry = 1;
    }
  return TRUE;
}

static bfd_boolean
update_local_sym_info (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx, bfd_vma r_addend, int tls_type)
{
  struct got_entry **local_got_ents = elf_local_got_ents (abfd);
  char *local_got_tls_masks;

  if (local_got_ents == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= sizeof (*local_got_ents) + sizeof (*local_got_tls_masks);
      local_got_ents = bfd_zalloc (abfd, size);
      if (local_got_ents == NULL)
	return FALSE;
      elf_local_got_ents (abfd) = local_got_ents;
    }

  if ((tls_type & TLS_EXPLICIT) == 0)
    {
      struct got_entry *ent;

      for (ent = local_got_ents[r_symndx]; ent != NULL; ent = ent->next)
	if (ent->addend == r_addend
	    && ent->owner == abfd
	    && ent->tls_type == tls_type)
	  break;
      if (ent == NULL)
	{
	  bfd_size_type amt = sizeof (*ent);
	  ent = bfd_alloc (abfd, amt);
	  if (ent == NULL)
	    return FALSE;
	  ent->next = local_got_ents[r_symndx];
	  ent->addend = r_addend;
	  ent->owner = abfd;
	  ent->tls_type = tls_type;
	  ent->got.refcount = 0;
	  local_got_ents[r_symndx] = ent;
	}
      ent->got.refcount += 1;
    }

  local_got_tls_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
  return TRUE;
}

static bfd_boolean
update_plt_info (bfd *abfd, struct ppc_link_hash_entry *eh, bfd_vma addend)
{
  struct plt_entry *ent;

  for (ent = eh->elf.plt.plist; ent != NULL; ent = ent->next)
    if (ent->addend == addend)
      break;
  if (ent == NULL)
    {
      bfd_size_type amt = sizeof (*ent);
      ent = bfd_alloc (abfd, amt);
      if (ent == NULL)
	return FALSE;
      ent->next = eh->elf.plt.plist;
      ent->addend = addend;
      ent->plt.refcount = 0;
      eh->elf.plt.plist = ent;
    }
  ent->plt.refcount += 1;
  eh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
  eh->is_func = 1;
  return TRUE;
}

/* Find the function descriptor hash entry from the given function code
   hash entry FH.  Link the entries via their OH fields.  */
static struct ppc_link_hash_entry *
get_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
d2501 2
a2502 1
  struct ppc_link_hash_entry *fdh = (struct ppc_link_hash_entry *) fh->oh;
d2504 2
a2505 1
  if (fdh == NULL)
d2507 1
a2507 1
      const char *fd_name = fh->elf.root.root.string + 1;
d2509 3
a2511 9
      fdh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);
      if (fdh != NULL)
	{
	  fdh->is_func_descriptor = 1;
	  fdh->oh = &fh->elf;
	  fh->is_func = 1;
	  fh->oh = &fdh->elf;
	}
d2513 1
a2513 2

  return fdh;
d2520 6
a2525 3
static bfd_boolean
ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
d2535 2
a2536 2
  if (info->relocatable)
    return TRUE;
d2566 1
a2566 1
      opd_sym_map = bfd_zalloc (abfd, amt);
d2568 2
a2569 2
	return FALSE;
      ppc64_elf_section_data (sec)->opd.func_sec = opd_sym_map;
d2572 2
d2576 1
a2576 1
    return FALSE;
d2583 1
a2583 2
      enum elf_ppc64_reloc_type r_type;
      int tls_type = 0;
d2591 1
a2591 1
      r_type = ELF64_R_TYPE (rel->r_info);
d2594 1
a2594 33
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  ppc64_tlsld_got (abfd)->refcount += 1;
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

d2601 1
d2603 3
a2605 4
	  sec->has_gp_reloc = 1;
	  if (ppc64_elf_tdata (abfd)->got == NULL
	      && !create_got_section (abfd, info))
	    return FALSE;
d2609 5
a2613 2
	      struct ppc_link_hash_entry *eh;
	      struct got_entry *ent;
d2615 3
a2617 7
	      eh = (struct ppc_link_hash_entry *) h;
	      for (ent = eh->elf.got.glist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend
		    && ent->owner == abfd
		    && ent->tls_type == tls_type)
		  break;
	      if (ent == NULL)
d2619 9
a2627 10
		  bfd_size_type amt = sizeof (*ent);
		  ent = bfd_alloc (abfd, amt);
		  if (ent == NULL)
		    return FALSE;
		  ent->next = eh->elf.got.glist;
		  ent->addend = rel->r_addend;
		  ent->owner = abfd;
		  ent->tls_type = tls_type;
		  ent->got.refcount = 0;
		  eh->elf.got.glist = ent;
d2629 1
a2629 2
	      ent->got.refcount += 1;
	      eh->tls_mask |= tls_type;
a2630 5
	  else
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;
d2648 1
a2648 1
	      return FALSE;
d2650 4
a2653 4
	  else
	    if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				  rel->r_addend))
	      return FALSE;
a2664 13
	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  break;

	  /* Nor do these.  */
a2670 1
	  sec->has_gp_reloc = 1;
d2677 1
a2677 1
	    return FALSE;
d2684 1
a2684 1
	    return FALSE;
d2700 3
a2702 86
	      if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				    rel->r_addend))
		return FALSE;
	      if (h == htab->tls_get_addr)
		sec->has_tls_reloc = 1;
	      else if ((strncmp (h->root.root.string, ".__tls_get_addr", 15)
			== 0)
		       && (h->root.root.string[15] == 0
			   || h->root.root.string[15] == '@@'))
		{
		  htab->tls_get_addr = h;
		  sec->has_tls_reloc = 1;
		}
	    }
	  break;

	case R_PPC64_TPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dotlstoc;

	case R_PPC64_DTPMOD64:
	  if (rel + 1 < rel_end
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD;
	  else
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_LD;
	  goto dotlstoc;

	case R_PPC64_DTPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_DTPREL;
	  if (rel != relocs
	      && rel[-1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPMOD64)
	      && rel[-1].r_offset == rel->r_offset - 8)
	    /* This is the second reloc of a dtpmod, dtprel pair.
	       Don't mark with TLS_DTPREL.  */
	    goto dodyn;

	dotlstoc:
	  sec->has_tls_reloc = 1;
	  if (h != NULL)
	    {
	      struct ppc_link_hash_entry *eh;
	      eh = (struct ppc_link_hash_entry *) h;
	      eh->tls_mask |= tls_type;
	    }
	  else
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;

	  if (ppc64_elf_section_data (sec)->t_symndx == NULL)
	    {
	      /* One extra to simplify get_tls_mask.  */
	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8 + 1;
	      ppc64_elf_section_data (sec)->t_symndx = bfd_zalloc (abfd, amt);
	      if (ppc64_elf_section_data (sec)->t_symndx == NULL)
		return FALSE;
	    }
	  BFD_ASSERT (rel->r_offset % 8 == 0);
	  ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8] = r_symndx;

	  /* Mark the second slot of a GD or LD entry.
	     -1 to indicate GD and -2 to indicate LD.  */
	  if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_GD))
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -1;
	  else if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_LD))
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -2;
	  goto dodyn;

	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  if (info->shared)
	    {
	      info->flags |= DF_STATIC_TLS;
	      goto dodyn;
d2711 2
a2712 1
	    get_fdh ((struct ppc_link_hash_entry *) h, htab);
d2714 10
d2727 2
a2728 1
	      && ELF64_R_TYPE ((rel + 1)->r_info) == R_PPC64_TOC)
d2735 1
a2735 1
		return FALSE;
d2741 1
a2741 1
	case R_PPC64_REL30:
a2742 1
	case R_PPC64_REL64:
d2757 1
a2762 4
	  if (h != NULL && !info->shared)
	    /* We may need a copy reloc.  */
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

a2766 4
	  /* Don't propagate relocs that the dynamic linker won't relocate.  */
	  if ((sec->flags & SEC_ALLOC) == 0)
	    break;

d2779 1
a2779 1
	     storing information in the dyn_relocs field of the hash
a2787 1
	dodyn:
d2789 2
a2790 1
	       && (MUST_BE_DYN_RELOC (r_type)
d2796 2
a2797 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d2819 1
a2819 1
		    return FALSE;
d2845 1
a2845 1
			return FALSE;
d2866 1
a2866 1
		    return FALSE;
d2875 3
a2877 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d2879 1
a2879 1
		    return FALSE;
d2888 1
a2888 1
	      if (!MUST_BE_DYN_RELOC (r_type))
d2898 1
a2898 1
  return TRUE;
d2905 6
a2910 5
ppc64_elf_gc_mark_hook (asection *sec,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
d2916 1
a2916 1
      enum elf_ppc64_reloc_type r_type;
d2919 1
a2919 1
      r_type = ELF64_R_TYPE (rel->r_info);
d2941 1
a2941 1
		 sections, as all functions are referenced in .opd.  */
d2944 1
a2944 1
		       || ppc64_elf_section_data (sec)->opd.func_sec == NULL)
d2962 1
a2962 1
      opd_sym_section = ppc64_elf_section_data (rsec)->opd.func_sec;
d2965 1
a2965 1
      else if (ppc64_elf_section_data (sec)->opd.func_sec != NULL)
d2975 6
a2980 3
static bfd_boolean
ppc64_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			 asection *sec, const Elf_Internal_Rela *relocs)
a2981 1
  struct ppc_link_hash_table *htab;
d2984 1
a2984 1
  struct got_entry **local_got_ents;
a2988 1
  htab = ppc_hash_table (info);
d2991 1
a2991 1
  local_got_ents = elf_local_got_ents (abfd);
d2997 2
a2998 3
      enum elf_ppc64_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;
      char tls_type = 0;
d3001 1
a3001 19
      r_type = ELF64_R_TYPE (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_link_hash_entry *eh;
	  struct ppc_dyn_relocs **pp;
	  struct ppc_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct ppc_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

a3003 29
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  ppc64_tlsld_got (abfd)->refcount -= 1;
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

d3010 11
a3020 19
	dogot:
	  {
	    struct got_entry *ent;

	    if (h != NULL)
	      ent = h->got.glist;
	    else
	      ent = local_got_ents[r_symndx];

	    for (; ent != NULL; ent = ent->next)
	      if (ent->addend == rel->r_addend
		  && ent->owner == abfd
		  && ent->tls_type == tls_type)
		break;
	    if (ent == NULL)
	      abort ();
	    if (ent->got.refcount > 0)
	      ent->got.refcount -= 1;
	  }
d3028 8
d3040 53
a3092 1
	  if (h != NULL)
d3094 3
a3096 1
	      struct plt_entry *ent;
d3098 11
a3108 7
	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend)
		  break;
	      if (ent == NULL)
		abort ();
	      if (ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
d3116 1
a3116 1
  return TRUE;
d3122 4
a3125 2
static bfd_boolean
func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
a3128 8
  struct plt_entry *ent;
  struct ppc_link_hash_entry *fh;
  struct ppc_link_hash_entry *fdh;
  bfd_boolean force_local;

  fh = (struct ppc_link_hash_entry *) h;
  if (fh->elf.root.type == bfd_link_hash_indirect)
    return TRUE;
d3130 5
a3134 2
  if (fh->elf.root.type == bfd_link_hash_warning)
    fh = (struct ppc_link_hash_entry *) fh->elf.root.u.i.link;
d3136 1
a3136 1
  info = inf;
d3141 2
a3142 2
  if (!fh->is_func)
    return TRUE;
d3144 88
a3231 92
  if (fh->elf.root.type == bfd_link_hash_undefweak
      && (fh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR))
    htab->have_undefweak = TRUE;

  for (ent = fh->elf.plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.refcount > 0)
      break;
  if (ent == NULL
      || fh->elf.root.root.string[0] != '.'
      || fh->elf.root.root.string[1] == '\0')
    return TRUE;

  /* Find the corresponding function descriptor symbol.  Create it
     as undefined if necessary.  */

  fdh = get_fdh (fh, htab);
  if (fdh != NULL)
    while (fdh->elf.root.type == bfd_link_hash_indirect
	   || fdh->elf.root.type == bfd_link_hash_warning)
      fdh = (struct ppc_link_hash_entry *) fdh->elf.root.u.i.link;

  if (fdh == NULL
      && info->shared
      && (fh->elf.root.type == bfd_link_hash_undefined
	  || fh->elf.root.type == bfd_link_hash_undefweak))
    {
      bfd *abfd;
      asymbol *newsym;
      struct bfd_link_hash_entry *bh;

      abfd = fh->elf.root.u.undef.abfd;
      newsym = bfd_make_empty_symbol (abfd);
      newsym->name = fh->elf.root.root.string + 1;
      newsym->section = bfd_und_section_ptr;
      newsym->value = 0;
      newsym->flags = BSF_OBJECT;
      if (fh->elf.root.type == bfd_link_hash_undefweak)
	newsym->flags |= BSF_WEAK;

      bh = &fdh->elf.root;
      if ( !(_bfd_generic_link_add_one_symbol
	     (info, abfd, newsym->name, newsym->flags,
	      newsym->section, newsym->value, NULL, FALSE, FALSE, &bh)))
	{
	  return FALSE;
	}
      fdh = (struct ppc_link_hash_entry *) bh;
      fdh->elf.elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      fdh->elf.size = 24;
      fdh->elf.type = STT_OBJECT;
    }

  if (fdh != NULL
      && (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
      && (info->shared
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
	  || (fdh->elf.root.type == bfd_link_hash_undefweak
	      && ELF_ST_VISIBILITY (fdh->elf.other) == STV_DEFAULT)))
    {
      if (fdh->elf.dynindx == -1)
	if (! bfd_elf64_link_record_dynamic_symbol (info, &fdh->elf))
	  return FALSE;
      fdh->elf.elf_link_hash_flags
	|= (fh->elf.elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
				      | ELF_LINK_HASH_REF_DYNAMIC
				      | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				      | ELF_LINK_NON_GOT_REF));
      if (ELF_ST_VISIBILITY (fh->elf.other) == STV_DEFAULT)
	{
	  fdh->elf.plt.plist = fh->elf.plt.plist;
	  fdh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	}
      fdh->is_func_descriptor = 1;
      fdh->oh = &fh->elf;
      fh->oh = &fdh->elf;
    }

  /* Now that the info is on the function descriptor, clear the
     function code sym info.  Any function code syms for which we
     don't have a definition in a regular file, we force local.
     This prevents a shared library from exporting syms that have
     been imported from another library.  Function code syms that
     are really in the library we must leave global to prevent the
     linker dragging in a definition from a static library.  */
  force_local
    = (info->shared
       && ((fh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   || fdh == NULL
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0));
  _bfd_elf_link_hash_hide_symbol (info, &fh->elf, force_local);
d3233 1
a3233 1
  return TRUE;
d3243 4
a3246 3
static bfd_boolean
ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
d3260 1
a3260 1
    return TRUE;
d3268 1
a3268 1
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
d3270 1
a3270 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3279 1
a3279 1
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
d3288 1
a3288 1
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
d3290 1
a3290 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3300 1
a3300 1
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
d3304 1
a3304 1
  elf_link_hash_traverse (&htab->elf, func_desc_adjust, info);
d3314 1
a3314 1
	  return TRUE;
d3320 1
a3320 1
  p = bfd_alloc (htab->elf.dynobj, htab->sfpr->_raw_size);
d3322 1
a3322 1
    return FALSE;
d3351 1
a3351 1
  return TRUE;
d3360 4
a3363 3
static bfd_boolean
ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
d3366 2
a3378 4
      struct plt_entry *ent;
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.refcount > 0)
	  break;
d3380 5
a3384 4
	  || ent == NULL
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d3386 1
a3386 1
	  h->plt.plist = NULL;
d3389 1
d3392 1
a3392 1
    h->plt.plist = NULL;
d3403 1
a3403 5
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d3406 3
d3414 1
a3414 1
    return TRUE;
d3419 1
a3419 1
    return TRUE;
d3421 2
a3422 1
  if (ELIMINATE_COPY_RELOCS)
d3424 3
a3426 18
      struct ppc_link_hash_entry * eh;
      struct ppc_dyn_relocs *p;

      eh = (struct ppc_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d3429 6
a3434 11
  if (h->plt.plist != NULL)
    {
      /* We should never get here, but unfortunately there are versions
	 of gcc out there that improperly (for this ABI) put initialized
	 function pointers, vtable refs and suchlike in read-only
	 sections.  Allow them to proceed, but warn that this might
	 break at runtime.  */
      (*_bfd_error_handler)
	(_("copy reloc against `%s' requires lazy plt linking; "
	   "avoid setting LD_BIND_NOW=1 or upgrade gcc"),
	 h->root.root.string);
a3436 3
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

d3447 2
a3448 2
  /* We must generate a R_PPC64_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
d3453 1
a3453 1
      htab->relbss->_raw_size += sizeof (Elf64_External_Rela);
d3464 1
a3464 1
  s = htab->dynbss;
d3469 1
a3469 1
	return FALSE;
d3479 1
a3479 201
  return TRUE;
}

/* If given a function descriptor symbol, hide both the function code
   sym and the descriptor.  */
static void
ppc64_elf_hide_symbol (struct bfd_link_info *info,
		       struct elf_link_hash_entry *h,
		       bfd_boolean force_local)
{
  _bfd_elf_link_hash_hide_symbol (info, h, force_local);

  if (((struct ppc_link_hash_entry *) h)->is_func_descriptor)
    {
      struct elf_link_hash_entry *fh = ((struct ppc_link_hash_entry *) h)->oh;

      if (fh == NULL)
	{
	  const char *p, *q;
	  struct ppc_link_hash_table *htab;
	  char save;

	  /* We aren't supposed to use alloca in BFD because on
	     systems which do not have alloca the version in libiberty
	     calls xmalloc, which might cause the program to crash
	     when it runs out of memory.  This function doesn't have a
	     return status, so there's no way to gracefully return an
	     error.  So cheat.  We know that string[-1] can be safely
	     dereferenced;  It's either a string in an ELF string
	     table, or allocated in an objalloc structure.  */

	  p = h->root.root.string - 1;
	  save = *p;
	  *(char *) p = '.';
	  htab = ppc_hash_table (info);
	  fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
	  *(char *) p = save;

	  /* Unfortunately, if it so happens that the string we were
	     looking for was allocated immediately before this string,
	     then we overwrote the string terminator.  That's the only
	     reason the lookup should fail.  */
	  if (fh == NULL)
	    {
	      q = h->root.root.string + strlen (h->root.root.string);
	      while (q >= h->root.root.string && *q == *p)
		--q, --p;
	      if (q < h->root.root.string && *p == '.')
		fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
	    }
	  if (fh != NULL)
	    {
	      ((struct ppc_link_hash_entry *) h)->oh = fh;
	      ((struct ppc_link_hash_entry *) fh)->oh = h;
	    }
	}
      if (fh != NULL)
	_bfd_elf_link_hash_hide_symbol (info, fh, force_local);
    }
}

static bfd_boolean
get_sym_h (struct elf_link_hash_entry **hp, Elf_Internal_Sym **symp,
	   asection **symsecp, char **tls_maskp, Elf_Internal_Sym **locsymsp,
	   unsigned long r_symndx, bfd *ibfd)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;

  if (r_symndx >= symtab_hdr->sh_info)
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (hp != NULL)
	*hp = h;

      if (symp != NULL)
	*symp = NULL;

      if (symsecp != NULL)
	{
	  asection *symsec = NULL;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    symsec = h->root.u.def.section;
	  *symsecp = symsec;
	}

      if (tls_maskp != NULL)
	{
	  struct ppc_link_hash_entry *eh;

	  eh = (struct ppc_link_hash_entry *) h;
	  *tls_maskp = &eh->tls_mask;
	}
    }
  else
    {
      Elf_Internal_Sym *sym;
      Elf_Internal_Sym *locsyms = *locsymsp;

      if (locsyms == NULL)
	{
	  locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (locsyms == NULL)
	    locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
					    symtab_hdr->sh_info,
					    0, NULL, NULL, NULL);
	  if (locsyms == NULL)
	    return FALSE;
	  *locsymsp = locsyms;
	}
      sym = locsyms + r_symndx;

      if (hp != NULL)
	*hp = NULL;

      if (symp != NULL)
	*symp = sym;

      if (symsecp != NULL)
	{
	  asection *symsec = NULL;
	  if ((sym->st_shndx != SHN_UNDEF
	       && sym->st_shndx < SHN_LORESERVE)
	      || sym->st_shndx > SHN_HIRESERVE)
	    symsec = bfd_section_from_elf_index (ibfd, sym->st_shndx);
	  *symsecp = symsec;
	}

      if (tls_maskp != NULL)
	{
	  struct got_entry **lgot_ents;
	  char *tls_mask;

	  tls_mask = NULL;
	  lgot_ents = elf_local_got_ents (ibfd);
	  if (lgot_ents != NULL)
	    {
	      char *lgot_masks = (char *) (lgot_ents + symtab_hdr->sh_info);
	      tls_mask = &lgot_masks[r_symndx];
	    }
	  *tls_maskp = tls_mask;
	}
    }
  return TRUE;
}

/* Returns TLS_MASKP for the given REL symbol.  Function return is 0 on
   error, 2 on a toc GD type suitable for optimization, 3 on a toc LD
   type suitable for optimization, and 1 otherwise.  */

static int
get_tls_mask (char **tls_maskp, unsigned long *toc_symndx,
	      Elf_Internal_Sym **locsymsp,
	      const Elf_Internal_Rela *rel, bfd *ibfd)
{
  unsigned long r_symndx;
  int next_r;
  struct elf_link_hash_entry *h;
  Elf_Internal_Sym *sym;
  asection *sec;
  bfd_vma off;

  r_symndx = ELF64_R_SYM (rel->r_info);
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;

  if ((*tls_maskp != NULL && **tls_maskp != 0)
      || sec == NULL
      || ppc64_elf_section_data (sec)->t_symndx == NULL)
    return 1;

  /* Look inside a TOC section too.  */
  if (h != NULL)
    {
      BFD_ASSERT (h->root.type == bfd_link_hash_defined);
      off = h->root.u.def.value;
    }
  else
    off = sym->st_value;
  off += rel->r_addend;
  BFD_ASSERT (off % 8 == 0);
  r_symndx = ppc64_elf_section_data (sec)->t_symndx[off / 8];
  next_r = ppc64_elf_section_data (sec)->t_symndx[off / 8 + 1];
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;
  if (toc_symndx != NULL)
    *toc_symndx = r_symndx;
  if ((h == NULL
       || ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
      && (next_r == -1 || next_r == -2))
    return 1 - next_r;
  return 1;
d3482 7
a3488 6
/* Adjust all global syms defined in opd sections.  In gcc generated
   code these will already have been done, but I suppose we have to
   cater for all sorts of hand written assembly.  */

static bfd_boolean
adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
d3490 1
a3490 3
  struct ppc_link_hash_entry *eh;
  asection *sym_sec;
  long *opd_adjust;
d3492 3
a3494 2
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
d3496 5
a3500 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d3502 8
a3509 3
  if (h->root.type != bfd_link_hash_defined
      && h->root.type != bfd_link_hash_defweak)
    return TRUE;
d3511 6
a3516 3
  eh = (struct ppc_link_hash_entry *) h;
  if (eh->adjust_done)
    return TRUE;
d3518 20
a3537 7
  sym_sec = eh->elf.root.u.def.section;
  if (sym_sec != NULL
      && elf_section_data (sym_sec) != NULL
      && (opd_adjust = ppc64_elf_section_data (sym_sec)->opd.adjust) != NULL)
    {
      eh->elf.root.u.def.value += opd_adjust[eh->elf.root.u.def.value / 24];
      eh->adjust_done = 1;
a3538 1
  return TRUE;
d3541 4
a3544 8
/* Remove unused Official Procedure Descriptor entries.  Currently we
   only remove those associated with functions in discarded link-once
   sections, or weakly defined functions that have been overridden.  It
   would be possible to remove many more entries for statically linked
   applications.  */

bfd_boolean
ppc64_elf_edit_opd (bfd *obfd, struct bfd_link_info *info)
d3547 1
a3547 1
  bfd_boolean some_edited = FALSE;
d3549 3
a3551 1
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
a3558 1
      bfd_size_type amt;
d3560 1
a3560 1
      bfd_boolean need_edit;
d3566 3
a3568 10
      amt = sec->_raw_size * sizeof (long) / 24;
      adjust = ppc64_elf_section_data (sec)->opd.adjust;
      if (adjust == NULL)
	{
	  /* Must be a ld -r link.  ie. check_relocs hasn't been
	     called.  */
	  adjust = bfd_zalloc (obfd, amt);
	  ppc64_elf_section_data (sec)->opd.adjust = adjust;
	}
      memset (adjust, 0, amt);
d3582 3
a3584 2
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
					    info->keep_memory);
d3586 1
a3586 1
	return FALSE;
d3590 1
a3590 1
      need_edit = FALSE;
d3593 1
a3593 1
      for (rel = relstart; rel < relend; )
d3595 1
a3595 1
	  enum elf_ppc64_reloc_type r_type;
d3604 20
a3623 3
	  if (rel->r_offset != offset
	      || rel + 1 >= relend
	      || (rel + 1)->r_offset != offset + 8)
d3629 1
a3629 1
		 optimization for them!  */
d3633 1
a3633 1
	      need_edit = FALSE;
d3637 15
a3651 2
	  if ((r_type = ELF64_R_TYPE (rel->r_info)) != R_PPC64_ADDR64
	      || (r_type = ELF64_R_TYPE ((rel + 1)->r_info)) != R_PPC64_TOC)
d3653 15
a3667 5
	      (*_bfd_error_handler)
		(_("%s: unexpected reloc type %u in .opd section"),
		 bfd_archive_filename (ibfd), r_type);
	      need_edit = FALSE;
	      break;
a3669 5
	  r_symndx = ELF64_R_SYM (rel->r_info);
	  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			  r_symndx, ibfd))
	    goto error_ret;

a3671 6
	      const char *sym_name;
	      if (h != NULL)
		sym_name = h->root.root.string;
	      else
		sym_name = bfd_elf_local_sym_name (ibfd, sym);

d3675 2
a3676 2
		 sym_name);
	      need_edit = FALSE;
d3689 1
a3689 1
	    need_edit = TRUE;
a3691 5
	  rel += 2;
	  /* Allow for the possibility of a reloc on the third word.  */
	  if (rel < relend
	      && rel->r_offset == offset - 8)
	    rel += 1;
d3698 1
a3698 1
	  bfd_boolean skip;
d3708 1
a3708 1
		  || !bfd_get_section_contents (ibfd, sec, loc, 0,
a3710 1
		error_ret:
d3714 1
d3717 1
a3717 1
		  return FALSE;
d3728 1
a3728 1
	  skip = FALSE;
a3731 10
	      unsigned long r_symndx;
	      asection *sym_sec;
	      struct elf_link_hash_entry *h;
	      Elf_Internal_Sym *sym;

	      r_symndx = ELF64_R_SYM (rel->r_info);
	      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			      r_symndx, ibfd))
		goto error_ret;

d3734 28
a3761 4
		  struct ppc_link_hash_entry *fdh = NULL;
		  if (h != NULL)
		    fdh = get_fdh ((struct ppc_link_hash_entry *) h,
				   ppc_hash_table (info));
d3771 8
a3778 2
			  fdh->elf.root.u.def.value = 0;
			  fdh->elf.root.u.def.section = sym_sec;
d3787 21
a3807 9
			  /* Redefine the function descriptor symbol to
			     this location in the opd section.  It is
			     necessary to update the value here rather
			     than using an array of adjustments as we do
			     for local symbols, because various places
			     in the generic ELF code use the value
			     stored in u.def.value.  */
			  fdh->elf.root.u.def.value = wptr - sec->contents;
			  fdh->adjust_done = 1;
a3809 8
		      /* Local syms are a bit tricky.  We could
			 tweak them as they can be cached, but
			 we'd need to look through the local syms
			 for the function descriptor sym which we
			 don't have at the moment.  So keep an
			 array of adjustments.  */
		      adjust[rel->r_offset / 24] = wptr - rptr;

d3818 4
a3821 31
	      if (skip)
		{
		  BFD_ASSERT (MUST_BE_DYN_RELOC (ELF64_R_TYPE (rel->r_info)));
		  if (info->shared)
		    {
		      /* We won't be needing dynamic relocs here.  */
		      struct ppc_dyn_relocs **pp;
		      struct ppc_dyn_relocs *p;

		      if (h != NULL)
			pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
		      else if (sym_sec != NULL)
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sym_sec)->local_dynrel);
		      else
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sec)->local_dynrel);
		      while ((p = *pp) != NULL)
			{
			  if (p->sec == sec)
			    {
			      p->count -= 1;
			      if (p->count == 0)
				*pp = p->next;
			      break;
			    }
			  pp = &p->next;
			}
		    }
		}
	      else
a3822 3
		  /* We need to adjust any reloc offsets to point to the
		     new opd entries.  While we're at it, we may as well
		     remove redundant relocs.  */
a3831 6
	  /* Fudge the size too, as this is used later in
	     elf_bfd_final_link if we are emitting relocs.  */
	  elf_section_data (sec)->rel_hdr.sh_size
	    = sec->reloc_count * elf_section_data (sec)->rel_hdr.sh_entsize;
	  BFD_ASSERT (elf_section_data (sec)->rel_hdr2 == NULL);
	  some_edited = TRUE;
d3846 1
a3846 328
  if (some_edited)
    elf_link_hash_traverse (elf_hash_table (info), adjust_opd_syms, NULL);

  return TRUE;
}

/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */

asection *
ppc64_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  htab = ppc_hash_table (info);
  if (htab->tls_get_addr != NULL)
    {
      struct elf_link_hash_entry *h = htab->tls_get_addr;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      htab->tls_get_addr = h;
    }

  return _bfd_elf_tls_setup (obfd, info);
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  The linker has been hacked (see ppc64elf.em) to do
   a preliminary section layout so that we know the TLS segment
   offsets.  We can't optimize earlier because some optimizations need
   to know the tp offset, and we need to optimize before allocating
   dynamic relocations.  */

bfd_boolean
ppc64_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;
  struct ppc_link_hash_table *htab;

  if (info->relocatable || info->shared)
    return TRUE;

  htab = ppc_hash_table (info);
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	  {
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;

	    /* Read the relocations.  */
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						  info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;

	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc64_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h;
		Elf_Internal_Sym *sym;
		asection *sym_sec;
		char *tls_mask;
		char tls_set, tls_clear, tls_type = 0;
		bfd_vma value;
		bfd_boolean ok_tprel, is_local;

		r_symndx = ELF64_R_SYM (rel->r_info);
		if (!get_sym_h (&h, &sym, &sym_sec, &tls_mask, &locsyms,
				r_symndx, ibfd))
		  {
		  err_free_rel:
		    if (elf_section_data (sec)->relocs != relstart)
		      free (relstart);
		    if (locsyms != NULL
			&& (elf_tdata (ibfd)->symtab_hdr.contents
			    != (unsigned char *) locsyms))
		      free (locsyms);
		    return FALSE;
		  }

		if (h != NULL)
		  {
		    if (h->root.type != bfd_link_hash_defined
			&& h->root.type != bfd_link_hash_defweak)
		      continue;
		    value = h->root.u.def.value;
		  }
		else
		  {
		    value = sym->st_value;

		    if (elf_section_data (sym_sec) != NULL)
		      {
			long *adjust;
			adjust = ppc64_elf_section_data (sym_sec)->opd.adjust;
			if (adjust != NULL)
			  value += adjust[value / 24];
		      }
		  }

		ok_tprel = FALSE;
		is_local = FALSE;
		if (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
		  {
		    is_local = TRUE;
		    value += sym_sec->output_offset;
		    value += sym_sec->output_section->vma;
		    value -= htab->elf.tls_sec->vma;
		    ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				< (bfd_vma) 1 << 32);
		  }

		r_type = ELF64_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC64_GOT_TLSLD16:
		  case R_PPC64_GOT_TLSLD16_LO:
		  case R_PPC64_GOT_TLSLD16_HI:
		  case R_PPC64_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    ppc64_tlsld_got (ibfd)->refcount -= 1;
		    if (!is_local)
		      continue;

		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    tls_type = TLS_TLS | TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC64_GOT_TLSGD16:
		  case R_PPC64_GOT_TLSGD16_LO:
		  case R_PPC64_GOT_TLSGD16_HI:
		  case R_PPC64_GOT_TLSGD16_HA:
		    if (ok_tprel)
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    tls_type = TLS_TLS | TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC64_GOT_TPREL16_DS:
		  case R_PPC64_GOT_TPREL16_LO_DS:
		  case R_PPC64_GOT_TPREL16_HI:
		  case R_PPC64_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			tls_type = TLS_TLS | TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC64_REL14:
		  case R_PPC64_REL14_BRTAKEN:
		  case R_PPC64_REL14_BRNTAKEN:
		  case R_PPC64_REL24:
		    if (h != NULL
			&& h == htab->tls_get_addr)
		      {
			if (!expecting_tls_get_addr
			    && rel != relstart
			    && ((ELF64_R_TYPE (rel[-1].r_info)
				 == R_PPC64_TOC16)
				|| (ELF64_R_TYPE (rel[-1].r_info)
				    == R_PPC64_TOC16_LO)))
			  {
			    /* Check for toc tls entries.  */
			    char *toc_tls;
			    int retval;

			    retval = get_tls_mask (&toc_tls, NULL, &locsyms,
						   rel - 1, ibfd);
			    if (retval == 0)
			      goto err_free_rel;
			    if (toc_tls != NULL)
			      expecting_tls_get_addr = retval > 1;
			  }

			if (expecting_tls_get_addr)
			  {
			    struct plt_entry *ent;
			    for (ent = h->plt.plist; ent; ent = ent->next)
			      if (ent->addend == 0)
				{
				  if (ent->plt.refcount > 0)
				    ent->plt.refcount -= 1;
				  break;
				}
			  }
		      }
		    expecting_tls_get_addr = 0;
		    continue;

		  case R_PPC64_TPREL64:
		    expecting_tls_get_addr = 0;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC64_DTPMOD64:
		    expecting_tls_get_addr = 0;
		    if (rel + 1 < relend
			&& (rel[1].r_info
			    == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			&& rel[1].r_offset == rel->r_offset + 8)
		      {
			if (ok_tprel)
			  /* GD -> LE */
			  tls_set = TLS_EXPLICIT | TLS_GD;
			else
			  /* GD -> IE */
			  tls_set = TLS_EXPLICIT | TLS_GD | TLS_TPRELGD;
			tls_clear = TLS_GD;
		      }
		    else
		      {
			if (!is_local)
			  continue;

			/* LD -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_LD;
		      }
		    break;

		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }

		if ((tls_set & TLS_EXPLICIT) == 0)
		  {
		    struct got_entry *ent;

		    /* Adjust got entry for this reloc.  */
		    if (h != NULL)
		      ent = h->got.glist;
		    else
		      ent = elf_local_got_ents (ibfd)[r_symndx];

		    for (; ent != NULL; ent = ent->next)
		      if (ent->addend == rel->r_addend
			  && ent->owner == ibfd
			  && ent->tls_type == tls_type)
			break;
		    if (ent == NULL)
		      abort ();

		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (ent->got.refcount > 0)
			  ent->got.refcount -= 1;
		      }
		  }
		else if (h != NULL)
		  {
		    struct ppc_link_hash_entry * eh;
		    struct ppc_dyn_relocs **pp;
		    struct ppc_dyn_relocs *p;

		    /* Adjust dynamic relocs.  */
		    eh = (struct ppc_link_hash_entry *) h;
		    for (pp = &eh->dyn_relocs;
			 (p = *pp) != NULL;
			 pp = &p->next)
		      if (p->sec == sec)
			{
			  /* If we got rid of a DTPMOD/DTPREL reloc
			     pair then we'll lose one or two dyn
			     relocs.  */
			  if (tls_set == (TLS_EXPLICIT | TLS_GD))
			    p->count -= 1;
			  p->count -= 1;
			  if (p->count == 0)
			    *pp = p->next;
			  break;
			}
		  }

		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }

	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
	  }

      if (locsyms != NULL
	  && (elf_tdata (ibfd)->symtab_hdr.contents
	      != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    elf_tdata (ibfd)->symtab_hdr.contents = (unsigned char *) locsyms;
	}
    }
  return TRUE;
d3848 1
a3848 1

d3853 1
a3853 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d3855 1
a3855 1
   && ((SHARED)								\
d3863 4
a3866 2
static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
a3872 1
  struct got_entry *gent;
d3875 1
a3875 1
    return TRUE;
d3884 2
a3885 2
      && h->dynindx != -1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
d3887 14
a3900 6
      struct plt_entry *pent;
      bfd_boolean doneone = FALSE;
      for (pent = h->plt.plist; pent != NULL; pent = pent->next)
	if (pent->plt.refcount > 0)
	  {
	    BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);
d3902 14
a3915 28
	    /* If this is the first .plt entry, make room for the special
	       first entry.  */
	    s = htab->plt;
	    if (s->_raw_size == 0)
	      s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

	    pent->plt.offset = s->_raw_size;

	    /* Make room for this entry.  */
	    s->_raw_size += PLT_ENTRY_SIZE;

	    /* Make room for the .glink code.  */
	    s = htab->glink;
	    if (s->_raw_size == 0)
	      s->_raw_size += GLINK_CALL_STUB_SIZE;
	    /* We need bigger stubs past index 32767.  */
	    if (s->_raw_size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	      s->_raw_size += 4;
	    s->_raw_size += 2*4;

	    /* We also need to make an entry in the .rela.plt section.  */
	    s = htab->relplt;
	    s->_raw_size += sizeof (Elf64_External_Rela);
	    doneone = TRUE;
	  }
	else
	  pent->plt.offset = (bfd_vma) -1;
      if (!doneone)
d3917 1
a3917 1
	  h->plt.plist = NULL;
d3923 1
a3923 1
      h->plt.plist = NULL;
d3927 3
a3929 20
  eh = (struct ppc_link_hash_entry *) h;
  /* Run through the TLS GD got entries first if we're changing them
     to TPREL.  */
  if ((eh->tls_mask & TLS_TPRELGD) != 0)
    for (gent = h->got.glist; gent != NULL; gent = gent->next)
      if (gent->got.refcount > 0
	  && (gent->tls_type & TLS_GD) != 0)
	{
	  /* This was a GD entry that has been converted to TPREL.  If
	     there happens to be a TPREL entry we can use that one.  */
	  struct got_entry *ent;
	  for (ent = h->got.glist; ent != NULL; ent = ent->next)
	    if (ent->got.refcount > 0
		&& (ent->tls_type & TLS_TPREL) != 0
		&& ent->addend == gent->addend
		&& ent->owner == gent->owner)
	      {
		gent->got.refcount = 0;
		break;
	      }
d3931 7
a3937 3
	  /* If not, then we'll be using our own TPREL entry.  */
	  if (gent->got.refcount != 0)
	    gent->tls_type = TLS_TLS | TLS_TPREL;
d3940 9
a3948 38
  for (gent = h->got.glist; gent != NULL; gent = gent->next)
    if (gent->got.refcount > 0)
      {
	bfd_boolean dyn;

	/* Make sure this symbol is output as a dynamic symbol.
	   Undefined weak syms won't yet be marked as dynamic,
	   nor will all TLS symbols.  */
	if (h->dynindx == -1
	    && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	  {
	    if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	      return FALSE;
	  }

	if ((gent->tls_type & TLS_LD) != 0
	    && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
	  {
	    gent->got.offset = ppc64_tlsld_got (gent->owner)->offset;
	    continue;
	  }

	s = ppc64_elf_tdata (gent->owner)->got;
	gent->got.offset = s->_raw_size;
	s->_raw_size
	  += (gent->tls_type & eh->tls_mask & (TLS_GD | TLS_LD)) ? 16 : 8;
	dyn = htab->elf.dynamic_sections_created;
	if ((info->shared
	     || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	    && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak))
	  ppc64_elf_tdata (gent->owner)->relgot->_raw_size
	    += (gent->tls_type & eh->tls_mask & TLS_GD
		? 2 * sizeof (Elf64_External_Rela)
		: sizeof (Elf64_External_Rela));
      }
    else
      gent->got.offset = (bfd_vma) -1;
d3950 1
d3952 1
a3952 1
    return TRUE;
d3962 3
a3964 7
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
a3977 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d3979 1
a3979 1
  else if (ELIMINATE_COPY_RELOCS)
d3986 5
a3990 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3998 1
a3998 1
		return FALSE;
d4019 1
a4019 1
  return TRUE;
d4024 4
a4027 2
static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d4042 1
a4042 1
	  struct bfd_link_info *info = inf;
d4047 1
a4047 1
	  return FALSE;
d4050 1
a4050 1
  return TRUE;
d4055 4
a4058 3
static bfd_boolean
ppc64_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info)
d4063 1
a4063 1
  bfd_boolean relocs;
d4074 1
a4074 1
      if (info->executable)
d4088 2
a4089 3
      struct got_entry **lgot_ents;
      struct got_entry **end_lgot_ents;
      char *lgot_masks;
a4096 14
      if (ppc64_tlsld_got (ibfd)->refcount > 0)
	{
	  s = ppc64_elf_tdata (ibfd)->got;
	  ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
	  s->_raw_size += 16;
	  if (info->shared)
	    {
	      srel = ppc64_elf_tdata (ibfd)->relgot;
	      srel->_raw_size += sizeof (Elf64_External_Rela);
	    }
	}
      else
	ppc64_tlsld_got (ibfd)->offset = (bfd_vma) -1;

d4124 2
a4125 2
      lgot_ents = elf_local_got_ents (ibfd);
      if (!lgot_ents)
d4130 4
a4133 5
      end_lgot_ents = lgot_ents + locsymcount;
      lgot_masks = (char *) end_lgot_ents;
      s = ppc64_elf_tdata (ibfd)->got;
      srel = ppc64_elf_tdata (ibfd)->relgot;
      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_masks)
d4135 9
a4143 35
	  struct got_entry *ent;

	  for (ent = *lgot_ents; ent != NULL; ent = ent->next)
	    if (ent->got.refcount > 0)
	      {
		if ((ent->tls_type & *lgot_masks & TLS_LD) != 0)
		  {
		    if (ppc64_tlsld_got (ibfd)->offset == (bfd_vma) -1)
		      {
			ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
			s->_raw_size += 16;
			if (info->shared)
			  srel->_raw_size += sizeof (Elf64_External_Rela);
		      }
		    ent->got.offset = ppc64_tlsld_got (ibfd)->offset;
		  }
		else
		  {
		    ent->got.offset = s->_raw_size;
		    if ((ent->tls_type & *lgot_masks & TLS_GD) != 0)
		      {
			s->_raw_size += 16;
			if (info->shared)
			  srel->_raw_size += 2 * sizeof (Elf64_External_Rela);
		      }
		    else
		      {
			s->_raw_size += 8;
			if (info->shared)
			  srel->_raw_size += sizeof (Elf64_External_Rela);
		      }
		  }
	      }
	    else
	      ent->got.offset = (bfd_vma) -1;
d4147 3
d4152 1
a4152 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d4156 1
a4156 1
  relocs = FALSE;
d4162 1
a4162 5
      /* Reset _cooked_size since prelim layout will set it wrongly,
	 and a non-zero _cooked_size sticks.  */
      s->_cooked_size = 0;

      if (s == htab->brlt || s == htab->relbrlt)
d4165 3
a4167 3
      else if (s == htab->got
	       || s == htab->plt
	       || s == htab->glink)
d4188 2
a4189 2
	      if (s != htab->relplt)
		relocs = TRUE;
d4215 3
a4217 5
	 but this way if it does we get a R_PPC64_NONE reloc in .rela
	 sections instead of garbage.
	 We also rely on the section contents being zero when writing
	 the GOT.  */
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d4219 1
a4219 33
	return FALSE;
    }

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      s = ppc64_elf_tdata (ibfd)->got;
      if (s != NULL && s != htab->got)
	{
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
	    _bfd_strip_section_from_output (info, s);
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
	      if (s->contents == NULL)
		return FALSE;
	    }
	}
      s = ppc64_elf_tdata (ibfd)->relgot;
      if (s != NULL)
	{
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
	    _bfd_strip_section_from_output (info, s);
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
	      if (s->contents == NULL)
		return FALSE;
	      relocs = TRUE;
	      s->reloc_count = 0;
	    }
	}
d4230 1
a4230 1
  bfd_elf64_add_dynamic_entry (info, (TAG), (VAL))
d4232 1
a4232 1
      if (info->executable)
d4235 1
a4235 1
	    return FALSE;
d4238 1
a4238 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
d4245 1
a4245 1
	    return FALSE;
d4252 1
a4252 1
	    return FALSE;
d4260 1
a4260 1
	    return FALSE;
d4265 2
a4266 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d4271 1
a4271 1
		return FALSE;
d4277 1
a4277 1
  return TRUE;
d4282 6
a4287 5
static inline enum ppc_stub_type
ppc_type_of_stub (asection *input_sec,
		  const Elf_Internal_Rela *rel,
		  struct ppc_link_hash_entry **hash,
		  bfd_vma destination)
d4293 1
a4293 1
  enum elf_ppc64_reloc_type r_type;
d4298 1
d4301 2
a4302 8
	  struct plt_entry *ent;
	  for (ent = h->oh->plt.plist; ent != NULL; ent = ent->next)
	    if (ent->addend == rel->r_addend
		&& ent->plt.offset != (bfd_vma) -1)
	      {
		*hash = (struct ppc_link_hash_entry *) h->oh;
		return ppc_stub_plt_call;
	      }
d4305 2
a4306 3
      if (!(h->elf.root.type == bfd_link_hash_defined
	    || h->elf.root.type == bfd_link_hash_defweak)
	  || h->elf.root.u.def.section->output_section == NULL)
d4320 1
a4320 1
  if (r_type != R_PPC64_REL24)
d4333 6
a4338 2
static inline bfd_byte *
build_plt_stub (bfd *obfd, bfd_byte *p, int offset)
d4344 2
d4347 2
a4348 1
  bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d4351 1
a4351 1
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
d4355 1
a4355 1
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
d4363 4
a4366 2
static bfd_boolean
ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d4372 2
a4376 1
  struct plt_entry *ent;
d4382 1
a4382 1
  info = in_arg;
d4385 1
d4388 4
a4391 2
  stub_entry->stub_offset = stub_entry->stub_sec->_cooked_size;
  loc = stub_entry->stub_sec->contents + stub_entry->stub_offset;
a4392 1
  htab->stub_count[stub_entry->stub_type - 1] += 1;
a4395 1
    case ppc_stub_long_branch_r2off:
d4403 2
a4404 2
	      + stub_entry->stub_sec->output_offset
	      + stub_entry->stub_sec->output_section->vma);
d4406 1
a4406 5
      if (stub_entry->stub_type != ppc_stub_long_branch_r2off)
	size = 4;
      else
	{
	  bfd_vma r2off;
d4408 2
a4409 14
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	  loc += 4;
	  off -= 12;
	  size = 16;
	}
      bfd_put_32 (htab->stub_bfd, B_DOT | (off & 0x3fffffc), loc);

      BFD_ASSERT (off + (1 << 25) < (bfd_vma) (1 << 26));
a4412 1
    case ppc_stub_plt_branch_r2off:
d4415 1
a4415 1
					 FALSE, FALSE);
d4420 2
a4421 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4428 2
a4429 2
      bfd_put_64 (htab->brlt->owner, off,
		  htab->brlt->contents + br_entry->offset);
d4435 1
a4435 1
	  bfd_byte *rl;
d4438 2
a4439 2
			   + htab->brlt->output_offset
			   + htab->brlt->output_section->vma);
d4443 3
a4445 3
	  rl = htab->relbrlt->contents;
	  rl += htab->relbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->relbrlt->owner, &rela, rl);
d4449 4
a4452 4
	     + htab->brlt->output_offset
	     + htab->brlt->output_section->vma
	     - elf_gp (htab->brlt->output_section->owner)
	     - htab->stub_group[stub_entry->id_sec->id].toc_off);
d4454 1
a4454 1
      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
d4460 2
a4461 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4465 5
a4469 28
      if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
	{
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  size = 16;
	}
      else
	{
	  bfd_vma r2off;

	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	  size = 28;
	}
      loc += 4;
      bfd_put_32 (htab->stub_bfd, MTCTR_R11, loc);
      loc += 4;
      bfd_put_32 (htab->stub_bfd, BCTR, loc);
d4481 1
a4481 3
	     defined somewhere.  Maybe defining the symbol in the stub
	     section is a silly idea.  If we didn't do this, htab->top_id
	     could disappear.  */
d4488 1
a4488 7
      off = (bfd_vma) -1;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    off = ent->plt.offset;
	    break;
	  }
d4493 4
a4496 4
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);
d4498 1
a4498 1
      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
d4504 2
a4505 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4508 1
a4508 1
      p = build_plt_stub (htab->stub_bfd, loc, off);
d4514 1
a4514 26
      return FALSE;
    }

  stub_entry->stub_sec->_cooked_size += size;

  if (htab->emit_stub_syms
      && !(stub_entry->stub_type == ppc_stub_plt_call
	   && stub_entry->h->oh->root.type == bfd_link_hash_defined
	   && stub_entry->h->oh->root.u.def.section == stub_entry->stub_sec
	   && stub_entry->h->oh->root.u.def.value == stub_entry->stub_offset))
    {
      struct elf_link_hash_entry *h;
      h = elf_link_hash_lookup (&htab->elf, stub_entry->root.string,
				TRUE, FALSE, FALSE);
      if (h == NULL)
	return FALSE;
      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = stub_entry->stub_sec;
	  h->root.u.def.value = stub_entry->stub_offset;
	  h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
				    | ELF_LINK_HASH_DEF_REGULAR
				    | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				    | ELF_LINK_FORCED_LOCAL);
	}
d4517 2
a4518 1
  return TRUE;
d4525 4
a4528 2
static bfd_boolean
ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
a4530 1
  struct bfd_link_info *info;
d4537 1
a4537 3
  info = in_arg;

  htab = ppc_hash_table (info);
d4541 5
a4545 14
      struct plt_entry *ent;
      off = (bfd_vma) -1;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    off = ent->plt.offset & ~(bfd_vma) 1;
	    break;
	  }
      if (off >= (bfd_vma) -2)
	abort ();
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);
d4547 2
a4548 2
      size = PLT_CALL_STUB_SIZE;
      if (PPC_HA (off + 16) != PPC_HA (off))
d4553 4
a4556 2
      /* ppc_stub_long_branch or ppc_stub_plt_branch, or their r2off
	 variants.  */
a4563 13
      /* Reset the stub type from the plt variant in case we now
	 can reach with a shorter stub.  */
      if (stub_entry->stub_type >= ppc_stub_plt_branch)
	stub_entry->stub_type += ppc_stub_long_branch - ppc_stub_plt_branch;

      size = 4;
      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
	{
	  off -= 12;
	  size = 16;
	}

      /* If the branch offset if too big, use a ppc_stub_plt_branch.  */
d4570 1
a4570 1
					     TRUE, FALSE);
d4575 2
a4576 2
	      htab->stub_error = TRUE;
	      return FALSE;
d4582 2
a4583 5
	      br_entry->offset = htab->brlt->_raw_size;
	      htab->brlt->_raw_size += 8;

	      if (info->shared)
		htab->relbrlt->_raw_size += sizeof (Elf64_External_Rela);
d4585 1
a4585 2

	  stub_entry->stub_type += ppc_stub_plt_branch - ppc_stub_long_branch;
a4586 2
	  if (stub_entry->stub_type != ppc_stub_plt_branch)
	    size = 28;
d4591 1
a4591 1
  return TRUE;
d4599 3
a4601 1
ppc64_elf_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d4604 1
a4604 1
  int top_id, top_index, id;
d4606 1
a4606 1
  asection **input_list;
d4610 2
a4611 1
  if (htab->brlt == NULL)
d4615 1
a4615 1
  for (input_bfd = info->input_bfds, top_id = 3;
a4627 1
  htab->top_id = top_id;
d4629 1
a4629 1
  htab->stub_group = bfd_zmalloc (amt);
a4632 6
  /* Set toc_off for com, und, abs and ind sections.  */
  for (id = 0; id < 3; id++)
    htab->stub_group[id].toc_off = TOC_BASE_OFF;

  elf_gp (output_bfd) = htab->toc_curr = ppc64_elf_toc (output_bfd);

d4646 1
a4646 1
  input_list = bfd_zmalloc (amt);
d4651 6
a4656 2
  return 1;
}
d4658 3
a4660 11
/* The linker repeatedly calls this function for each TOC input section
   and linker generated GOT section.  Group input bfds such that the toc
   within a group is less than 64k in size.  Will break with cute linker
   scripts that play games with dot in the output toc section.  */

void
ppc64_elf_next_toc_section (struct bfd_link_info *info, asection *isec)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (!htab->no_multi_toc)
d4662 2
a4663 10
      bfd_vma addr = isec->output_offset + isec->output_section->vma;
      bfd_vma off = addr - htab->toc_curr;
      if (off + isec->_raw_size > 0x10000)
	{
	  htab->toc_curr = addr;
	  htab->multi_toc_needed = 1;
	}
      elf_gp (isec->owner) = (htab->toc_curr
			      - elf_gp (isec->output_section->owner)
			      + TOC_BASE_OFF);
a4664 1
}
d4666 1
a4666 75
/* Called after the last call to the above function.  */

void
ppc64_elf_reinit_toc (bfd *output_bfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  /* toc_curr tracks the TOC offset used for code sections below in
     ppc64_elf_next_input_section.  Start off at 0x8000.  */
  htab->toc_curr = TOC_BASE_OFF;
}

/* No toc references were found in ISEC.  If the code in ISEC makes no
   calls, then there's no need to use toc adjusting stubs when branching
   into ISEC.  Actually, indirect calls from ISEC are OK as they will
   load r2.  */

static int
toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)
{
  bfd_byte *contents;
  bfd_size_type i;
  int ret;
  int branch_ok;

  /* We know none of our code bearing sections will need toc stubs.  */
  if ((isec->flags & SEC_LINKER_CREATED) != 0)
    return 0;

  if (isec->_raw_size == 0)
    return 0;

  /* Hack for linux kernel.  .fixup contains branches, but only back to
     the function that hit an exception.  */
  branch_ok = strcmp (isec->name, ".fixup") == 0;

  contents = elf_section_data (isec)->this_hdr.contents;
  if (contents == NULL)
    {
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	return -1;
      if (! bfd_get_section_contents (isec->owner, isec, contents,
				      0, isec->_raw_size))
	{
	  free (contents);
	  return -1;
	}
      if (info->keep_memory)
	elf_section_data (isec)->this_hdr.contents = contents;
    }

  /* Code scan, because we don't necessarily have relocs on calls to
     static functions.  */
  ret = 0;
  for (i = 0; i < isec->_raw_size; i += 4)
    {
      unsigned long insn = bfd_get_32 (isec->owner, contents + i);
      /* Is this a branch?  */
      if ((insn & (0x3f << 26)) == (18 << 26)
	  /* If branch and link, it's a function call.  */
	  && ((insn & 1) != 0
	      /* Sibling calls use a plain branch.  I don't know a way
		 of deciding whether a branch is really a sibling call.  */
	      || !branch_ok))
	{
	  ret = 1;
	  break;
	}
    }

  if (elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  return ret;
d4674 4
a4677 2
bfd_boolean
ppc64_elf_next_input_section (struct bfd_link_info *info, asection *isec)
a4679 1
  int ret;
d4681 1
a4681 2
  if ((isec->output_section->flags & SEC_CODE) != 0
      && isec->output_section->index <= htab->top_index)
d4684 3
a4686 1
      /* Steal the link_sec pointer for our list.  */
d4688 5
a4692 14
      /* This happens to make the list in reverse order,
	 which is what we want.  */
      PREV_SEC (isec) = *list;
      *list = isec;
    }

  /* If a code section has a function that uses the TOC then we need
     to use the right TOC (obviously).  Also, make sure that .opd gets
     the correct TOC value for R_PPC64_TOC relocs that don't have or
     can't find their function symbol (shouldn't ever happen now).  */
  if (isec->has_gp_reloc || (isec->flags & SEC_CODE) == 0)
    {
      if (elf_gp (isec->owner) != 0)
	htab->toc_curr = elf_gp (isec->owner);
a4693 10
  else if ((ret = toc_adjusting_stub_needed (info, isec)) < 0)
    return FALSE;
  else
    isec->has_gp_reloc = ret;

  /* Functions that don't use the TOC can belong in any TOC group.
     Use the last TOC base.  This happens to make _init and _fini
     pasting work.  */
  htab->stub_group[isec->id].toc_off = htab->toc_curr;
  return TRUE;
d4704 4
a4707 3
group_sections (struct ppc_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
d4713 2
a4719 2
	  bfd_boolean big_sec;
	  bfd_vma curr_toc;
a4725 3
	  big_sec = total >= stub_group_size;
	  curr_toc = htab->stub_group[tail->id].toc_off;

d4728 1
a4728 2
		     < stub_group_size)
		 && htab->stub_group[prev->id].toc_off == curr_toc)
d4740 1
a4740 1
	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
d4750 2
a4751 5
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
d4756 1
a4756 2
			 < stub_group_size)
		     && htab->stub_group[prev->id].toc_off == curr_toc)
d4777 9
a4785 6
bfd_boolean
ppc64_elf_size_stubs (bfd *output_bfd,
		      struct bfd_link_info *info,
		      bfd_signed_vma group_size,
		      asection *(*add_stub_section) (const char *, asection *),
		      void (*layout_sections_again) (void))
d4788 1
a4788 1
  bfd_boolean stubs_always_before_branch;
d4792 1
d4803 3
a4805 12
      if (stubs_always_before_branch)
	{
	  stub_group_size = 0x1e00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7800;
	}
      else
	{
	  stub_group_size = 0x1c00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7000;
	}
d4815 1
a4815 1
      bfd_boolean stub_changed;
d4818 1
a4818 1
      stub_changed = FALSE;
d4854 3
a4856 2
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
					     info->keep_memory);
d4865 1
a4865 2
		  enum elf_ppc64_reloc_type r_type;
		  unsigned int r_indx;
a4871 2
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
d4878 1
a4878 1
		  if (r_type >= R_PPC64_max)
d4885 4
a4888 4
		  if (r_type != R_PPC64_REL24
		      && r_type != R_PPC64_REL14
		      && r_type != R_PPC64_REL14_BRTAKEN
		      && r_type != R_PPC64_REL14_BRNTAKEN)
d4893 2
d4896 2
a4897 6
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_indx, input_bfd))
		    goto error_ret_free_internal;
		  hash = (struct ppc_link_hash_entry *) h;

		  if (hash == NULL)
d4900 20
a4919 1
		      sym_value = sym->st_value;
d4927 11
a4937 1
		      sym_value = 0;
d4941 1
a4961 18

		  if (stub_type != ppc_stub_plt_call)
		    {
		      /* Check whether we need a TOC adjusting stub.
			 Since the linker pastes together pieces from
			 different object files when creating the
			 _init and _fini functions, it may be that a
			 call to what looks like a local sym is in
			 fact a call needing a TOC adjustment.  */
		      if (sym_sec != NULL
			  && sym_sec->output_section != NULL
			  && (htab->stub_group[sym_sec->id].toc_off
			      != htab->stub_group[section->id].toc_off)
			  && sym_sec->has_gp_reloc
			  && section->has_gp_reloc)
			stub_type = ppc_stub_long_branch_r2off;
		    }

a4964 17
		  /* __tls_get_addr calls might be eliminated.  */
		  if (stub_type != ppc_stub_plt_call
		      && hash != NULL
		      && &hash->elf == htab->tls_get_addr
		      && section->has_tls_reloc
		      && irela != internal_relocs)
		    {
		      /* Get tls info.  */
		      char *tls_mask;

		      if (!get_tls_mask (&tls_mask, NULL, &local_syms,
					 irela - 1, input_bfd))
			goto error_ret_free_internal;
		      if (*tls_mask != 0)
			continue;
		    }

d4974 1
a4974 1
						     stub_name, FALSE, FALSE);
d4994 1
a4994 1
		      return FALSE;
a4996 1
		  stub_entry->stub_type = stub_type;
d4999 1
d5001 1
a5001 2
		  stub_entry->addend = irela->r_addend;
		  stub_changed = TRUE;
a5026 8
	if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	  {
	    stub_sec->_raw_size = 0;
	    stub_sec->_cooked_size = 0;
	  }
      htab->brlt->_raw_size = 0;
      htab->brlt->_cooked_size = 0;
      if (info->shared)
d5028 2
a5029 2
	  htab->relbrlt->_raw_size = 0;
	  htab->relbrlt->_cooked_size = 0;
d5031 2
d5034 1
a5034 1
      bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, info);
d5045 1
a5045 1
  return TRUE;
d5052 2
a5053 1
ppc64_elf_toc (bfd *obfd)
d5109 3
a5111 4
bfd_boolean
ppc64_elf_build_stubs (bfd_boolean emit_stub_syms,
		       struct bfd_link_info *info,
		       char **stats)
d5115 1
a5116 1
  int stub_sec_count = 0;
a5117 1
  htab->emit_stub_syms = emit_stub_syms;
d5121 13
a5133 14
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
      {
	bfd_size_type size;

	/* Allocate memory to hold the linker stubs.  */
	size = stub_sec->_raw_size;
	if (size != 0)
	  {
	    stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
	    if (stub_sec->contents == NULL)
	      return FALSE;
	  }
	stub_sec->_cooked_size = 0;
      }
d5135 1
a5135 1
  if (htab->plt != NULL)
a5137 1
      bfd_vma plt0;
d5140 7
a5146 6
      plt0 = (htab->plt->output_section->vma
	      + htab->plt->output_offset
	      - (htab->glink->output_section->vma
		 + htab->glink->output_offset
		 + GLINK_CALL_STUB_SIZE));
      if (plt0 + 0x80008000 > 0xffffffff)
d5148 2
a5149 21
	  (*_bfd_error_handler) (_(".glink and .plt too far apart"));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (htab->emit_stub_syms)
	{
	  struct elf_link_hash_entry *h;
	  h = elf_link_hash_lookup (&htab->elf, "__glink", TRUE, FALSE, FALSE);
	  if (h == NULL)
	    return FALSE;
	  if (h->root.type == bfd_link_hash_new)
	    {
	      h->root.type = bfd_link_hash_defined;
	      h->root.u.def.section = htab->glink;
	      h->root.u.def.value = 0;
	      h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR
					| ELF_LINK_HASH_REF_REGULAR_NONWEAK
					| ELF_LINK_FORCED_LOCAL);
	    }
a5150 33
      p = htab->glink->contents;
      bfd_put_32 (htab->glink->owner, MFCTR_R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_3, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDIC_R2_R0_32K, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SRADI_R2_R2_63, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_2, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, AND_R2_R2_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADD_R12_R12_R2, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDIS_R12_R12 | PPC_HA (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | PPC_LO (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDI_R12_R12 | PPC_LO (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R2_0R12 | 8, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, MTCTR_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | 16, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, BCTR, p);
      p += 4;
d5154 1
a5154 1
      while (p < htab->glink->contents + htab->glink->_raw_size)
d5158 1
a5158 1
	      bfd_put_32 (htab->glink->owner, LI_R0_0 | indx, p);
d5163 1
a5163 1
	      bfd_put_32 (htab->glink->owner, LIS_R0_0 | PPC_HI (indx), p);
d5165 1
a5165 1
	      bfd_put_32 (htab->glink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
d5168 2
a5169 2
	  bfd_put_32 (htab->glink->owner,
		      B_DOT | ((htab->glink->contents - p) & 0x3fffffc), p);
d5173 1
a5173 1
      htab->glink->_cooked_size = p - htab->glink->contents;
d5176 1
a5176 1
  if (htab->brlt->_raw_size != 0)
d5178 4
a5181 11
      htab->brlt->contents = bfd_zalloc (htab->brlt->owner,
					 htab->brlt->_raw_size);
      if (htab->brlt->contents == NULL)
	return FALSE;
    }
  if (info->shared && htab->relbrlt->_raw_size != 0)
    {
      htab->relbrlt->contents = bfd_zalloc (htab->relbrlt->owner,
					    htab->relbrlt->_raw_size);
      if (htab->relbrlt->contents == NULL)
	return FALSE;
d5190 4
a5193 6
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
      {
	stub_sec_count += 1;
	if (stub_sec->_raw_size != stub_sec->_cooked_size)
	  break;
      }
d5196 1
a5196 1
      || htab->glink->_raw_size != htab->glink->_cooked_size)
d5198 1
a5198 1
      htab->stub_error = TRUE;
d5202 1
a5202 23
  if (htab->stub_error)
    return FALSE;

  if (stats != NULL)
    {
      *stats = bfd_malloc (500);
      if (*stats == NULL)
	return FALSE;

      sprintf (*stats, _("linker stubs in %u groups\n"
			 "  branch       %lu\n"
			 "  toc adjust   %lu\n"
			 "  long branch  %lu\n"
			 "  long toc adj %lu\n"
			 "  plt call     %lu"),
	       stub_sec_count,
	       htab->stub_count[ppc_stub_long_branch - 1],
	       htab->stub_count[ppc_stub_long_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_branch - 1],
	       htab->stub_count[ppc_stub_plt_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_call - 1]);
    }
  return TRUE;
d5214 1
a5214 1
   relocatable output file) adjusting the reloc addend as
d5228 1
a5228 1
   When generating relocatable output, this function must handle
d5234 11
a5244 9
static bfd_boolean
ppc64_elf_relocate_section (bfd *output_bfd,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
d5251 1
a5251 3
  Elf_Internal_Rela outrel;
  bfd_byte *loc;
  struct got_entry **local_got_ents;
d5253 2
a5254 2
  bfd_boolean ret = TRUE;
  bfd_boolean is_opd;
d5256 1
a5256 1
  bfd_boolean is_power4 = FALSE;
d5258 2
a5259 2
  if (info->relocatable)
    return TRUE;
d5266 1
a5266 1
  local_got_ents = elf_local_got_ents (input_bfd);
d5270 1
a5270 1
  is_opd = ppc64_elf_section_data (input_section)->opd.adjust != NULL;
d5276 2
a5277 1
      enum elf_ppc64_reloc_type r_type;
d5285 1
a5285 3
      unsigned long r_symndx, toc_symndx;
      char tls_mask, tls_gd, tls_type;
      char sym_type;
d5287 3
a5289 3
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      unsigned long insn, mask;
d5294 11
a5304 186
      r_type = ELF64_R_TYPE (rel->r_info);
      r_symndx = ELF64_R_SYM (rel->r_info);

      /* For old style R_PPC64_TOC relocs with a zero symbol, use the
	 symbol of the previous ADDR64 reloc.  The symbol gives us the
	 proper TOC base to use.  */
      if (rel->r_info == ELF64_R_INFO (0, R_PPC64_TOC)
	  && rel != relocs
	  && ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_ADDR64
	  && is_opd)
	r_symndx = ELF64_R_SYM (rel[-1].r_info);

      sym = NULL;
      sec = NULL;
      h = NULL;
      sym_name = NULL;
      unresolved_reloc = FALSE;
      warned = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* It's a local symbol.  */
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
	  sym_type = ELF64_ST_TYPE (sym->st_info);
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	  if (elf_section_data (sec) != NULL)
	    {
	      long *opd_sym_adjust;

	      opd_sym_adjust = ppc64_elf_section_data (sec)->opd.adjust;
	      if (opd_sym_adjust != NULL)
		relocation += opd_sym_adjust[sym->st_value / 24];
	    }
	}
      else
	{
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	  sym_name = h->root.root.string;
	  sym_type = h->type;
	}

      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      toc_symndx = 0;
      if (IS_PPC64_TLS_RELOC (r_type))
	{
	  if (h != NULL)
	    tls_mask = ((struct ppc_link_hash_entry *) h)->tls_mask;
	  else if (local_got_ents != NULL)
	    {
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
	    }
	  if (tls_mask == 0 && r_type == R_PPC64_TLS)
	    {
	      /* Check for toc tls entries.  */
	      char *toc_tls;

	      if (!get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				 rel, input_bfd))
		return FALSE;

	      if (toc_tls)
		tls_mask = *toc_tls;
	    }
	}

      /* Check that tls relocs are used with tls syms, and non-tls
	 relocs are used with non-tls syms.  */
      if (r_symndx != 0
	  && r_type != R_PPC64_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && IS_PPC64_TLS_RELOC (r_type) != (sym_type == STT_TLS))
	{
	  if (r_type == R_PPC64_TLS && tls_mask != 0)
	    /* R_PPC64_TLS is OK against a symbol in the TOC.  */
	    ;
	  else
	    (*_bfd_error_handler)
	      (sym_type == STT_TLS
	       ? _("%s(%s+0x%lx): %s used with TLS symbol %s")
	       : _("%s(%s+0x%lx): %s used with non-TLS symbol %s"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       ppc64_elf_howto_table[r_type]->name,
	       sym_name);
	}

      /* Ensure reloc mapping code below stays sane.  */
      if (R_PPC64_TOC16_LO_DS != R_PPC64_TOC16_DS + 1
	  || R_PPC64_TOC16_LO != R_PPC64_TOC16 + 1
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TLSGD16 & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TLSGD16_LO & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TLSGD16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TLSGD16_HA & 3)
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TPREL16_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TPREL16_LO_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TPREL16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TPREL16_HA & 3))
	abort ();

      switch (r_type)
	{
	default:
	  break;

	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	  {
	    /* Check for toc tls entries.  */
	    char *toc_tls;
	    int retval;

	    retval = get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				   rel, input_bfd);
	    if (retval == 0)
	      return FALSE;

	    if (toc_tls)
	      {
		tls_mask = *toc_tls;
		if (r_type == R_PPC64_TOC16_DS
		    || r_type == R_PPC64_TOC16_LO_DS)
		  {
		    if (tls_mask != 0
			&& (tls_mask & (TLS_DTPREL | TLS_TPREL)) == 0)
		      goto toctprel;
		  }
		else
		  {
		    /* If we found a GD reloc pair, then we might be
		       doing a GD->IE transition.  */
		    if (retval == 2)
		      {
			tls_gd = TLS_TPRELGD;
			if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
			  goto tls_get_addr_check;
		      }
		    else if (retval == 3)
		      {
			if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
			  goto tls_get_addr_check;
		      }
		  }
	      }
	  }
	  break;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	    toctprel:
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
	      insn &= 31 << 21;
	      insn |= 0x3c0d0000;	/* addis 0,13,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
	      r_type = R_PPC64_TPREL16_HA;
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;
d5306 11
a5316 52
	case R_PPC64_TLS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma rtra;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      if ((insn & ((0x3f << 26) | (31 << 11)))
		  == ((31 << 26) | (13 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((0x3f << 26) | (31 << 16)))
		       == ((31 << 26) | (13 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
		abort ();
	      insn |= rtra;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      /* Was PPC64_TLS which sits on insn boundary, now
		 PPC64_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
	      r_type = R_PPC64_TPREL16_LO;
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;
d5318 3
a5320 6
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;
d5322 1
a5322 28
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC64_GOT_TPREL16_DS);
	      else
		{
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  rel->r_offset -= 2;
		  r_type = R_PPC64_NONE;
		}
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_get_addr_check;
	  break;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d5324 1
a5324 19
	    tls_get_addr_check:
	      if (rel + 1 < relend)
		{
		  enum elf_ppc64_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2, insn3;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2 = ELF64_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF64_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC64_REL14
			  && r_type2 != R_PPC64_REL14_BRTAKEN
			  && r_type2 != R_PPC64_REL14_BRNTAKEN
			  && r_type2 != R_PPC64_REL24))
		    break;
d5326 3
a5328 65
		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || h2 != htab->tls_get_addr)
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - 2);
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
		  if ((tls_mask & tls_gd) != 0)
		    {
		      /* IE */
		      insn1 &= (1 << 26) - (1 << 2);
		      insn1 |= 58 << 26;	/* ld */
		      insn2 = 0x7c636a14;	/* add 3,3,13 */
		      rel[1].r_info = ELF64_R_INFO (r_symndx2, R_PPC64_NONE);
		      if ((tls_mask & TLS_EXPLICIT) == 0)
			r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
				  + R_PPC64_GOT_TPREL16_DS);
		      else
			r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		    }
		  else
		    {
		      /* LE */
		      insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			}
		      else if (toc_symndx != 0)
			r_symndx = toc_symndx;
		      r_type = R_PPC64_TPREL16_HA;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF64_R_INFO (r_symndx,
						    R_PPC64_TPREL16_LO);
		      rel[1].r_offset += 2;
		    }
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      insn3 = insn2;
		      insn2 = NOP;
		      rel[1].r_offset += 4;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
		  if (tls_gd == 0 || toc_symndx != 0)
		    {
		      /* We changed the symbol.  Start over in order
			 to get h, sym, sec etc. right.  */
		      rel--;
		      continue;
		    }
		}
d5330 12
a5341 6
	  break;

	case R_PPC64_DTPMOD64:
	  if (rel + 1 < relend
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
d5343 11
a5353 12
	      if ((tls_mask & TLS_GD) == 0)
		{
		  rel[1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_NONE);
		  if ((tls_mask & TLS_TPRELGD) != 0)
		    r_type = R_PPC64_TPREL64;
		  else
		    {
		      bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
		      r_type = R_PPC64_NONE;
		    }
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
d5355 7
d5364 7
a5370 14
	      if ((tls_mask & TLS_LD) == 0)
		{
		  bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
		  r_type = R_PPC64_NONE;
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
	    }
	  break;

	case R_PPC64_TPREL64:
	  if ((tls_mask & TLS_TPREL) == 0)
	    {
	      r_type = R_PPC64_NONE;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
a5371 1
	  break;
d5374 1
a5374 1
      /* Handle other relocations that tweak non-addend part of insn.  */
d5390 1
a5390 2
	  insn |= bfd_get_32 (output_bfd,
			      contents + rel->r_offset) & ~(0x01 << 21);
d5405 1
a5405 1
	      from = (rel->r_offset
d5410 1
a5410 1
	      if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
d5414 1
a5414 1
	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
d5418 8
a5425 13
	  /* Calls to functions with a different TOC, such as calls to
	     shared objects, need to alter the TOC pointer.  This is
	     done using a linkage stub.  A REL24 branching to these
	     linkage stubs needs to be followed by a nop, as the nop
	     will be replaced with an instruction to restore the TOC
	     base pointer.  */
	  if (((h != NULL
		&& (fdh = ((struct ppc_link_hash_entry *) h)->oh) != NULL
		&& fdh->plt.plist != NULL)
	       || ((fdh = h, sec) != NULL
		   && sec->output_section != NULL
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off)))
d5427 1
a5427 4
						   rel, htab)) != NULL
	      && (stub_entry->stub_type == ppc_stub_plt_call
		  || stub_entry->stub_type == ppc_stub_plt_branch_r2off
		  || stub_entry->stub_type == ppc_stub_long_branch_r2off))
d5429 1
a5429 1
	      bfd_boolean can_plt_call = 0;
d5431 1
a5431 1
	      if (rel->r_offset + 8 <= input_section->_cooked_size)
d5433 1
a5433 1
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
d5437 2
a5438 2
		      bfd_put_32 (input_bfd, LD_R2_40R1,
				  contents + rel->r_offset + 4);
d5445 5
a5449 43
		  if (stub_entry->stub_type == ppc_stub_plt_call)
		    {
		      /* If this is a plain branch rather than a branch
			 and link, don't require a nop.  */
		      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      if ((insn & 1) == 0)
			can_plt_call = 1;
		    }
		  else if (h != NULL
			   && strcmp (h->root.root.string,
				      ".__libc_start_main") == 0)
		    {
		      /* Allow crt1 branch to go via a toc adjusting stub.  */
		      can_plt_call = 1;
		    }
		  else
		    {
		      if (strcmp (input_section->output_section->name,
				  ".init") == 0
			  || strcmp (input_section->output_section->name,
				     ".fini") == 0)
			(*_bfd_error_handler)
			  (_("%s(%s+0x%lx): automatic multiple TOCs "
			     "not supported using your crt files; "
			     "recompile with -mminimal-toc or upgrade gcc"),
			   bfd_archive_filename (input_bfd),
			   input_section->name,
			   (long) rel->r_offset);
		      else
			(*_bfd_error_handler)
			  (_("%s(%s+0x%lx): sibling call optimization to `%s' "
			     "does not allow automatic multiple TOCs; "
			     "recompile with -mminimal-toc or "
			     "-fno-optimize-sibling-calls, "
			     "or make `%s' extern"),
			   bfd_archive_filename (input_bfd),
			   input_section->name,
			   (long) rel->r_offset,
			   sym_name,
			   sym_name);
		      bfd_set_error (bfd_error_bad_value);
		      ret = FALSE;
		    }
d5457 2
a5458 2
		  if (stub_entry->stub_type == ppc_stub_plt_call)
		    unresolved_reloc = FALSE;
d5465 1
a5465 1
	      && rel->r_addend == 0)
d5475 1
a5475 1
	      from = (rel->r_offset
a5488 2
      tls_type = 0;
      addend = rel->r_addend;
d5497 1
a5497 1
	  ret = FALSE;
d5501 2
a5502 3
	case R_PPC64_TLS:
	case R_PPC64_GNU_VTINHERIT:
	case R_PPC64_GNU_VTENTRY:
d5507 1
a5507 1
	     symbol's value itself.  Also, create a GOT entry for the
a5508 28
	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

a5514 1
	dogot:
a5517 2
	    asection *got;
	    bfd_vma *offp;
a5518 1
	    unsigned long indx = 0;
d5520 4
a5523 5
	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	      offp = &ppc64_tlsld_got (input_bfd)->offset;
	    else
d5525 1
a5525 1
		struct got_entry *ent;
d5527 10
a5536 1
		if (h != NULL)
d5538 14
a5551 9
		    bfd_boolean dyn = htab->elf.dynamic_sections_created;
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
			|| (info->shared
			    && SYMBOL_REFERENCES_LOCAL (info, h)))
		      /* This is actually a static link, or it is a
			 -Bsymbolic link and the symbol is defined
			 locally, or the symbol was forced to be local
			 because of a version file.  */
		      ;
d5554 3
a5556 2
			indx = h->dynindx;
			unresolved_reloc = FALSE;
a5557 1
		    ent = h->got.glist;
d5560 1
a5560 14
		  {
		    if (local_got_ents == NULL)
		      abort ();
		    ent = local_got_ents[r_symndx];
		  }

		for (; ent != NULL; ent = ent->next)
		  if (ent->addend == rel->r_addend
		      && ent->owner == input_bfd
		      && ent->tls_type == tls_type)
		    break;
		if (ent == NULL)
		  abort ();
		offp = &ent->got.offset;
a5561 11

	    got = ppc64_elf_tdata (input_bfd)->got;
	    if (got == NULL)
	      abort ();

	    /* The offset must always be a multiple of 8.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    off = *offp;
	    if ((off & 1) != 0)
	      off &= ~1;
d5564 2
a5565 48
		/* Generate relocs for the dynamic linker, except in
		   the case of TLSLD where we'll use one entry per
		   module.  */
		asection *relgot = ppc64_elf_tdata (input_bfd)->relgot;

		*offp = off | 1;
		if ((info->shared || indx != 0)
		    && (h == NULL
			|| ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			|| h->root.type != bfd_link_hash_undefweak))
		  {
		    outrel.r_offset = (got->output_section->vma
				       + got->output_offset
				       + off);
		    outrel.r_addend = rel->r_addend;
		    if (tls_type & (TLS_LD | TLS_GD))
		      {
			outrel.r_addend = 0;
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    loc = relgot->contents;
			    loc += (relgot->reloc_count++
				    * sizeof (Elf64_External_Rela));
			    bfd_elf64_swap_reloca_out (output_bfd,
						       &outrel, loc);
			    outrel.r_offset += 8;
			    outrel.r_addend = rel->r_addend;
			    outrel.r_info
			      = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
			  }
		      }
		    else if (tls_type == (TLS_TLS | TLS_DTPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
		    else if (tls_type == (TLS_TLS | TLS_TPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_TPREL64);
		    else if (indx == 0)
		      {
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);

			/* Write the .got section contents for the sake
			   of prelink.  */
			loc = got->contents + off;
			bfd_put_64 (output_bfd, outrel.r_addend + relocation,
				    loc);
		      }
		    else
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_GLOB_DAT);
d5567 1
a5567 11
		    if (indx == 0 && tls_type != (TLS_TLS | TLS_LD))
		      {
			outrel.r_addend += relocation;
			if (tls_type & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			  outrel.r_addend -= htab->elf.tls_sec->vma;
		      }
		    loc = relgot->contents;
		    loc += (relgot->reloc_count++
			    * sizeof (Elf64_External_Rela));
		    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  }
d5569 5
a5573 2
		/* Init the .got section contents here if we're not
		   emitting a reloc.  */
d5576 4
a5579 4
		    relocation += rel->r_addend;
		    if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
		    else if (tls_type != 0)
d5581 13
a5593 10
			relocation -= htab->elf.tls_sec->vma + DTP_OFFSET;
			if (tls_type == (TLS_TLS | TLS_TPREL))
			  relocation += DTP_OFFSET - TP_OFFSET;

			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    bfd_put_64 (output_bfd, relocation,
					got->contents + off + 8);
			    relocation = 1;
			  }
d5596 1
a5596 2
		    bfd_put_64 (output_bfd, relocation,
				got->contents + off);
d5603 1
a5603 1
	    relocation = got->output_offset + off;
d5606 1
a5606 1
	    addend = -TOC_BASE_OFF;
d5623 7
a5629 16
	  /* It's possible that we didn't make a PLT entry for this
	     symbol.  This happens when statically linking PIC code,
	     or when using -Bsymbolic.  Go find a match if there is a
	     PLT entry.  */
	  if (htab->plt != NULL)
	    {
	      struct plt_entry *ent;
	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend
		    && ent->plt.offset != (bfd_vma) -1)
		  {
		    relocation = (htab->plt->output_section->vma
				  + htab->plt->output_offset
				  + ent->plt.offset);
		    unresolved_reloc = FALSE;
		  }
d5631 5
a5637 13
	case R_PPC64_TOC:
	  /* Relocation value is TOC base.  */
	  relocation = TOCstart;
	  if (r_symndx == 0)
	    relocation += htab->stub_group[input_section->id].toc_off;
	  else if (unresolved_reloc)
	    ;
	  else if (sec != NULL && sec->id <= htab->top_id)
	    relocation += htab->stub_group[sec->id].toc_off;
	  else
	    unresolved_reloc = TRUE;
	  goto dodyn2;

d5648 1
a5648 1
	  addend -= TOCstart + htab->stub_group[input_section->id].toc_off;
d5658 1
a5658 1
	  if (sec != NULL)
a5667 44
	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  if (info->shared)
	    /* The TPREL16 relocs shouldn't really be used in shared
	       libs as they will result in DT_TEXTREL being set, but
	       support them anyway.  */
	    goto dodyn;
	  break;

	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  break;

	case R_PPC64_DTPMOD64:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

	case R_PPC64_TPREL64:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC64_DTPREL64:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  /* Fall thru */

a5669 1
	case R_PPC64_REL30:
d5686 1
a5694 1
	dodyn:
d5699 1
a5699 1
	dodyn2:
d5707 7
a5713 7
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && (MUST_BE_DYN_RELOC (r_type)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d5717 6
a5722 2
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d5725 1
a5725 1
	      bfd_boolean skip, relocate;
d5727 1
a5727 2
	      bfd_byte *loc;
	      bfd_vma out_off;
d5733 2
a5734 2
	      skip = FALSE;
	      relocate = FALSE;
d5736 10
a5745 21
	      out_off = _bfd_elf_section_offset (output_bfd, info,
						 input_section, rel->r_offset);
	      if (out_off == (bfd_vma) -1)
		skip = TRUE;
	      else if (out_off == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      out_off += (input_section->output_section->vma
			  + input_section->output_offset);
	      outrel.r_offset = out_off;
	      outrel.r_addend = rel->r_addend;

	      /* Optimize unaligned reloc use.  */
	      if ((r_type == R_PPC64_ADDR64 && (out_off & 7) != 0)
		  || (r_type == R_PPC64_UADDR64 && (out_off & 7) == 0))
		r_type ^= R_PPC64_ADDR64 ^ R_PPC64_UADDR64;
	      else if ((r_type == R_PPC64_ADDR32 && (out_off & 3) != 0)
		       || (r_type == R_PPC64_UADDR32 && (out_off & 3) == 0))
		r_type ^= R_PPC64_ADDR32 ^ R_PPC64_UADDR32;
	      else if ((r_type == R_PPC64_ADDR16 && (out_off & 1) != 0)
		       || (r_type == R_PPC64_UADDR16 && (out_off & 1) == 0))
		r_type ^= R_PPC64_ADDR16 ^ R_PPC64_UADDR16;
d5749 2
a5750 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h)
d5752 5
a5756 1
		       && r_type != R_PPC64_TOC)
d5764 1
d5779 1
a5779 1
			  unresolved_reloc = FALSE;
a5781 6

		      /* We need to relocate .opd contents for ld.so.
			 Prelink also wants simple and consistent rules
			 for relocs.  This make all RELATIVE relocs have
			 *r_offset equal to r_addend.  */
		      relocate = TRUE;
d5792 1
a5792 1
			  return FALSE;
d5817 2
a5818 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
d5823 1
a5823 2
		 anything now.  However, for the sake of prelink ensure
		 that the section contents are a known value.  */
d5825 1
a5825 20
		{
		  unresolved_reloc = FALSE;
		  /* The value chosen here is quite arbitrary as ld.so
		     ignores section contents except for the special
		     case of .opd where the contents might be accessed
		     before relocation.  Choose zero, as that won't
		     cause reloc overflow.  */
		  relocation = 0;
		  addend = 0;
		  /* Use *r_offset == r_addend for R_PPC64_ADDR64 relocs
		     to improve backward compatibility with older
		     versions of ld.  */
		  if (r_type == R_PPC64_ADDR64)
		    addend = outrel.r_addend;
		  /* Adjust pc_relative relocs to have zero in *r_offset.  */
		  else if (ppc64_elf_howto_table[r_type]->pc_relative)
		    addend = (input_section->output_section->vma
			      + input_section->output_offset
			      + rel->r_offset);
		}
d5835 1
a5835 1
	  /* Fall through.  */
d5848 1
a5848 1
	    (_("%s: relocation %s is not supported for symbol %s."),
d5850 1
a5850 1
	     ppc64_elf_howto_table[r_type]->name, sym_name);
d5853 1
a5853 1
	  ret = FALSE;
a5865 2
	case R_PPC64_GOT16_HA:
	case R_PPC64_PLTGOT16_HA:
a5868 14
	case R_PPC64_TPREL16_HA:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TLSLD16_HA:
	case R_PPC64_GOT_TPREL16_HA:
	case R_PPC64_GOT_DTPREL16_HA:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
d5874 2
a5875 3
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
d5889 1
a5889 19
	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	  insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));
	  mask = 3;
	  /* If this reloc is against an lq insn, then the value must be
	     a multiple of 16.  This is somewhat of a hack, but the
	     "correct" way to do this by defining _DQ forms of all the
	     _DS relocs bloats all reloc switches in this file.  It
	     doesn't seem to make much sense to use any of these relocs
	     in data, so testing the insn should be safe.  */
	  if ((insn & (0x3f << 26)) == (56u << 26))
	    mask = 15;
	  if (((relocation + addend) & mask) != 0)
d5892 1
a5892 1
		(_("%s: error: relocation %s not a multiple of %d"),
d5894 1
a5894 2
		 ppc64_elf_howto_table[r_type]->name,
		 mask + 1);
d5896 1
a5896 1
	      ret = FALSE;
d5911 3
a5913 4
	  /* If the branch is out of reach or the TOC register needs
	     adjusting, then redirect the call to the local stub for
	     this function.  */
	  from = (rel->r_offset
d5916 1
a5916 6
	  if ((relocation + addend - from + max_br_offset >= 2 * max_br_offset
	       || (sec != NULL
		   && sec->output_section != NULL
		   && sec->id <= htab->top_id
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off)))
d5938 1
a5938 1
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
a5941 1
	     ppc64_elf_howto_table[(int) r_type]->name,
d5943 1
a5943 1
	  ret = FALSE;
d5950 1
a5950 1
				    rel->r_offset,
d5956 3
a5958 3
	  if (sym_name == NULL)
	    sym_name = "(null)";
	  if (r == bfd_reloc_overflow)
d5960 2
a5961 5
	      if (warned)
		continue;
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
		  && ppc64_elf_howto_table[r_type]->pc_relative)
d5972 17
d5990 3
a5992 3
		    (info, sym_name, ppc64_elf_howto_table[r_type]->name,
		     rel->r_addend, input_bfd, input_section, rel->r_offset)))
		return FALSE;
d5997 1
a5997 1
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
d6000 2
a6001 5
		 (long) rel->r_offset,
		 ppc64_elf_howto_table[r_type]->name,
		 sym_name,
		 (int) r);
	      ret = FALSE;
a6008 26
/* Adjust the value of any local symbols in opd sections.  */

static bfd_boolean
ppc64_elf_output_symbol_hook (struct bfd_link_info *info,
			      const char *name ATTRIBUTE_UNUSED,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h)
{
  long *adjust;
  bfd_vma value;

  if (h != NULL
      || input_sec == NULL
      || ppc64_elf_section_data (input_sec) == NULL
      || (adjust = ppc64_elf_section_data (input_sec)->opd.adjust) == NULL)
    return TRUE;

  value = elfsym->st_value - input_sec->output_offset;
  if (!info->relocatable)
    value -= input_sec->output_section->vma;

  elfsym->st_value += adjust[value / 24];
  return TRUE;
}

d6012 6
a6017 5
static bfd_boolean
ppc64_elf_finish_dynamic_symbol (bfd *output_bfd,
				 struct bfd_link_info *info,
				 struct elf_link_hash_entry *h,
				 Elf_Internal_Sym *sym)
d6025 29
a6053 1
  if (((struct ppc_link_hash_entry *) h)->is_func_descriptor)
a6054 1
      struct plt_entry *ent;
d6056 1
a6056 1
      bfd_byte *loc;
d6058 5
a6062 5
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.offset != (bfd_vma) -1)
	  {
	    /* This symbol has an entry in the procedure linkage
	       table.  Set it up.  */
d6064 29
a6092 4
	    if (htab->plt == NULL
		|| htab->relplt == NULL
		|| htab->glink == NULL)
	      abort ();
d6094 3
a6096 13
	    /* Create a JMP_SLOT reloc to inform the dynamic linker to
	       fill in the PLT entry.  */
	    rela.r_offset = (htab->plt->output_section->vma
			     + htab->plt->output_offset
			     + ent->plt.offset);
	    rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	    rela.r_addend = ent->addend;

	    loc = htab->relplt->contents;
	    loc += ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		    * sizeof (Elf64_External_Rela));
	    bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
	  }
d6102 1
a6102 1
      bfd_byte *loc;
d6109 1
a6109 1
	  || htab->relbss == NULL)
d6117 2
a6118 2
      loc = htab->relbss->contents;
      loc += htab->relbss->reloc_count++ * sizeof (Elf64_External_Rela);
d6126 1
a6126 1
  return TRUE;
d6133 2
a6134 1
ppc64_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d6136 1
a6136 1
  enum elf_ppc64_reloc_type r_type;
d6138 1
a6138 1
  r_type = ELF64_R_TYPE (rela->r_info);
d6154 4
a6157 3
static bfd_boolean
ppc64_elf_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
d6171 1
a6171 1
      if (sdyn == NULL || htab->got == NULL)
d6189 2
a6190 7
	      s = htab->glink;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      /* We stupidly defined DT_PPC64_GLINK to be the start
		 of glink rather than the first entry point, which is
		 what ld.so needs, and now have a bigger stub to
		 support automatic multiple TOCs.  */
	      dyn.d_un.d_ptr += GLINK_CALL_STUB_SIZE - 32;
d6195 2
a6196 3
	      if (s == NULL)
		continue;
	      dyn.d_un.d_ptr = s->vma;
d6201 2
a6202 3
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val = s->_raw_size;
d6206 2
a6207 2
	      s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d6211 2
a6212 2
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d6216 1
a6216 1
	      dyn.d_un.d_val = htab->relplt->_raw_size;
d6222 2
a6223 16
	      s = htab->relplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->relplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
d6231 1
a6231 1
  if (htab->got != NULL && htab->got->_raw_size != 0)
d6237 1
a6237 1
		  htab->got->contents);
d6240 1
a6240 1
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 8;
d6243 1
a6243 1
  if (htab->plt != NULL && htab->plt->_raw_size != 0)
d6246 1
a6246 1
      elf_section_data (htab->plt->output_section)->this_hdr.sh_entsize
d6250 35
a6284 22
  /* We need to handle writing out multiple GOT sections ourselves,
     since we didn't add them to DYNOBJ.  */
  while ((dynobj = dynobj->link_next) != NULL)
    {
      asection *s;
      s = ppc64_elf_tdata (dynobj)->got;
      if (s != NULL
	  && s->_raw_size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->_raw_size))
	return FALSE;
      s = ppc64_elf_tdata (dynobj)->relgot;
      if (s != NULL
	  && s->_raw_size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->_raw_size))
	return FALSE;
    }
d6286 14
a6299 2
  return TRUE;
}
@


1.64.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a3592 9
  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d3950 4
a4168 3
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d6004 1
a6004 1
      if (s == htab->plt)
@


1.63
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@a4466 21
      /* Build the .glink lazy link call stub.  */
      p = htab->sglink->contents + htab->sglink->_cooked_size;
      indx = htab->sglink->reloc_count;
      if (indx < 0x8000)
	{
	  bfd_put_32 (htab->sglink->owner, LI_R0_0 | indx, p);
	  p += 4;
	}
      else
	{
	  bfd_put_32 (htab->sglink->owner, LIS_R0_0 | PPC_HI (indx), p);
	  p += 4;
	  bfd_put_32 (htab->sglink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
	  p += 4;
	}
      bfd_put_32 (htab->sglink->owner,
		  B_DOT | ((htab->sglink->contents - p) & 0x3fffffc), p);
      p += 4;
      htab->sglink->_cooked_size = p - htab->sglink->contents;
      htab->sglink->reloc_count += 1;

d5131 2
d5140 1
a5140 1
      while (p - htab->sglink->contents < GLINK_CALL_STUB_SIZE)
d5145 21
a5166 3

      /* Use reloc_count to count entries.  */
      htab->sglink->reloc_count = 0;
a5178 1
  htab->sglink->reloc_count = 0;
@


1.63.10.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d4467 21
a5151 2
      unsigned int indx;

d5159 1
a5159 1
      while (p < htab->sglink->contents + GLINK_CALL_STUB_SIZE)
d5164 1
d5166 2
a5167 21
      /* Build the .glink lazy link call stubs.  */
      indx = 0;
      while (p < htab->sglink->contents + htab->sglink->_raw_size)
	{
	  if (indx < 0x8000)
	    {
	      bfd_put_32 (htab->sglink->owner, LI_R0_0 | indx, p);
	      p += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->sglink->owner, LIS_R0_0 | PPC_HI (indx), p);
	      p += 4;
	      bfd_put_32 (htab->sglink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
	      p += 4;
	    }
	  bfd_put_32 (htab->sglink->owner,
		      B_DOT | ((htab->sglink->contents - p) & 0x3fffffc), p);
	  p += 4;
	}
      htab->sglink->_cooked_size = p - htab->sglink->contents;
d5180 1
@


1.63.10.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a3168 1
	  struct bfd_link_hash_entry *bh;
a3178 1
	  bh = &fdh->root;
d3181 2
a3182 1
		  newsym->section, newsym->value, NULL, false, false, &bh)))
a3185 1
	  fdh = (struct elf_link_hash_entry *) bh;
d3678 6
a3683 10
	  /* opd entries are always for functions defined in the
	     current input bfd.  If the symbol isn't defined in the
	     input bfd, then we won't be using the function in this
	     bfd;  It must be defined in a linkonce section in another
	     bfd, or is weak.  It's also possible that we are
	     discarding the function due to a linker script /DISCARD/,
	     which we test for via the output_section.  */
	  if (sym_sec->owner != ibfd
	      || sym_sec->output_section == bfd_abs_section_ptr)
	    need_edit = true;
d3757 1
a3757 2
		  skip = (sym_sec->owner != ibfd
			  || sym_sec->output_section == bfd_abs_section_ptr);
d3760 1
a3760 1
		      if (h != NULL && sym_sec->owner == ibfd)
d3800 2
a3801 1
			  adjust[rel->r_offset / 24] = wptr - rptr;
a5163 1
	  indx++;
@


1.63.10.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a1660 1
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
d1788 2
a1789 2
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
d1795 1
a1795 1
   .	addis	%r12,%r2,xxx@@toc@@ha
d1797 2
a1798 2
   .	ld	%r11,xxx+0@@toc@@l(%r12)
   .	ld	%r2,xxx+8@@toc@@l(%r12)
d1800 1
a1800 1
   .	ld	%r11,xxx+16@@toc@@l(%r12)
d1974 2
d3541 2
a3542 2
boolean
ppc64_elf_edit_opd (obfd, info)
a3558 1
      bfd_size_type amt;
a3565 1
      amt = sec->_raw_size * sizeof (long) / 24;
d3567 2
a3568 8
      if (adjust == NULL)
	{
	  /* Must be a ld -r link.  ie. check_relocs hasn't been
	     called.  */
	  adjust = (long *) bfd_zalloc (obfd, amt);
	  elf_section_data (sec)->tdata = adjust;
	}
      memset (adjust, 0, (size_t) amt);
d3771 1
a3771 1
			  struct ppc_link_hash_entry *fdh;
d3775 4
a3778 19
			  fdh = (struct ppc_link_hash_entry *) fh->oh;
			  if (fdh == NULL)
			    {
			      const char *fd_name;
			      struct ppc_link_hash_table *htab;

			      fd_name = h->root.root.string + 1;
			      htab = ppc_hash_table (info);
			      fdh = (struct ppc_link_hash_entry *)
				elf_link_hash_lookup (&htab->elf, fd_name,
						      false, false, false);
			      fdh->is_func_descriptor = 1;
			      fdh->oh = &fh->elf;
			      fh->is_func = 1;
			      fh->oh = &fdh->elf;
			    }

			  fdh->elf.root.u.def.value = 0;
			  fdh->elf.root.u.def.section = sym_sec;
d3791 1
a3791 1
			  struct ppc_link_hash_entry *fdh;
d3795 3
a3797 18
			  fdh = (struct ppc_link_hash_entry *) fh->oh;
			  if (fdh == NULL)
			    {
			      const char *fd_name;
			      struct ppc_link_hash_table *htab;

			      fd_name = h->root.root.string + 1;
			      htab = ppc_hash_table (info);
			      fdh = (struct ppc_link_hash_entry *)
				elf_link_hash_lookup (&htab->elf, fd_name,
						      false, false, false);
			      fdh->is_func_descriptor = 1;
			      fdh->oh = &fh->elf;
			      fh->is_func = 1;
			      fh->oh = &fdh->elf;
			    }

			  fdh->elf.root.u.def.value = wptr - sec->contents;
d4146 3
@


1.63.10.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d38 1
a38 1
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst));
d55 1
a55 1
static bfd_boolean ppc64_elf_object_p
d57 1
a57 1
static bfd_boolean ppc64_elf_merge_private_bfd_data
d127 1
a127 1

d137 1
a137 1
	 FALSE,			/* pc_relative */
d142 1
a142 1
	 FALSE,			/* partial_inplace */
d145 1
a145 1
	 FALSE),		/* pcrel_offset */
d152 1
a152 1
	 FALSE,			/* pc_relative */
d157 1
a157 1
	 FALSE,			/* partial_inplace */
d160 1
a160 1
	 FALSE),		/* pcrel_offset */
d168 1
a168 1
	 FALSE,			/* pc_relative */
d173 1
a173 1
	 FALSE,			/* partial_inplace */
d176 1
a176 1
	 FALSE),		/* pcrel_offset */
d183 1
a183 1
	 FALSE,			/* pc_relative */
d188 1
a188 1
	 FALSE,			/* partial_inplace */
d191 1
a191 1
	 FALSE),		/* pcrel_offset */
d198 1
a198 1
	 FALSE,			/* pc_relative */
d203 1
a203 1
	 FALSE,			/* partial_inplace */
d206 1
a206 1
	 FALSE),		/* pcrel_offset */
d213 1
a213 1
	 FALSE,			/* pc_relative */
d218 1
a218 1
	 FALSE,			/* partial_inplace */
d221 1
a221 1
	 FALSE),		/* pcrel_offset */
d229 1
a229 1
	 FALSE,			/* pc_relative */
d234 1
a234 1
	 FALSE,			/* partial_inplace */
d237 1
a237 1
	 FALSE),		/* pcrel_offset */
d245 1
a245 1
	 FALSE,			/* pc_relative */
d250 1
a250 1
	 FALSE,			/* partial_inplace */
d253 1
a253 1
	 FALSE),		/* pcrel_offset */
d262 1
a262 1
	 FALSE,			/* pc_relative */
d267 1
a267 1
	 FALSE,			/* partial_inplace */
d270 1
a270 1
	 FALSE),		/* pcrel_offset */
d279 1
a279 1
	 FALSE,			/* pc_relative */
d284 1
a284 1
	 FALSE,			/* partial_inplace */
d287 1
a287 1
	 FALSE),		/* pcrel_offset */
d294 1
a294 1
	 TRUE,			/* pc_relative */
d299 1
a299 1
	 FALSE,			/* partial_inplace */
d302 1
a302 1
	 TRUE),			/* pcrel_offset */
d309 1
a309 1
	 TRUE,			/* pc_relative */
d314 1
a314 1
	 FALSE,			/* partial_inplace */
d317 1
a317 1
	 TRUE),			/* pcrel_offset */
d326 1
a326 1
	 TRUE,			/* pc_relative */
d331 1
a331 1
	 FALSE,			/* partial_inplace */
d334 1
a334 1
	 TRUE),			/* pcrel_offset */
d343 1
a343 1
	 TRUE,			/* pc_relative */
d348 1
a348 1
	 FALSE,			/* partial_inplace */
d351 1
a351 1
	 TRUE),			/* pcrel_offset */
d359 1
a359 1
	 FALSE,			/* pc_relative */
d364 1
a364 1
	 FALSE,			/* partial_inplace */
d367 1
a367 1
	 FALSE),		/* pcrel_offset */
d375 1
a375 1
	 FALSE,			/* pc_relative */
d380 1
a380 1
	 FALSE,			/* partial_inplace */
d383 1
a383 1
	 FALSE),		/* pcrel_offset */
d391 1
a391 1
	 FALSE,			/* pc_relative */
d396 1
a396 1
	 FALSE,			/* partial_inplace */
d399 1
a399 1
	 FALSE),		/* pcrel_offset */
d407 1
a407 1
	 FALSE,			/* pc_relative */
d412 1
a412 1
	 FALSE,			/* partial_inplace */
d415 1
a415 1
	 FALSE),		/* pcrel_offset */
d426 1
a426 1
	 FALSE,			/* pc_relative */
d431 1
a431 1
	 FALSE,			/* partial_inplace */
d434 1
a434 1
	 FALSE),		/* pcrel_offset */
d442 1
a442 1
	 FALSE,			/* pc_relative */
d447 1
a447 1
	 FALSE,			/* partial_inplace */
d450 1
a450 1
	 FALSE),		/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),		/* pcrel_offset */
d475 1
a475 1
	 FALSE,			/* pc_relative */
d480 1
a480 1
	 FALSE,			/* partial_inplace */
d483 1
a483 1
	 FALSE),		/* pcrel_offset */
d490 1
a490 1
	 FALSE,			/* pc_relative */
d495 1
a495 1
	 FALSE,			/* partial_inplace */
d498 1
a498 1
	 FALSE),		/* pcrel_offset */
d505 1
a505 1
	 FALSE,			/* pc_relative */
d510 1
a510 1
	 FALSE,			/* partial_inplace */
d513 1
a513 1
	 FALSE),		/* pcrel_offset */
d520 1
a520 1
	 TRUE,			/* pc_relative */
d526 1
a526 1
	 FALSE,			/* partial_inplace */
d529 1
a529 1
	 TRUE),			/* pcrel_offset */
d536 1
a536 1
	 FALSE,			/* pc_relative */
d541 1
a541 1
	 FALSE,			/* partial_inplace */
d544 1
a544 1
	 FALSE),		/* pcrel_offset */
d552 1
a552 1
	 TRUE,			/* pc_relative */
d557 1
a557 1
	 FALSE,			/* partial_inplace */
d560 1
a560 1
	 TRUE),			/* pcrel_offset */
d568 1
a568 1
	 FALSE,			/* pc_relative */
d573 1
a573 1
	 FALSE,			/* partial_inplace */
d576 1
a576 1
	 FALSE),		/* pcrel_offset */
d584 1
a584 1
	 FALSE,			/* pc_relative */
d589 1
a589 1
	 FALSE,			/* partial_inplace */
d592 1
a592 1
	 FALSE),		/* pcrel_offset */
d600 1
a600 1
	 FALSE,			/* pc_relative */
d605 1
a605 1
	 FALSE,			/* partial_inplace */
d608 1
a608 1
	 FALSE),		/* pcrel_offset */
d615 1
a615 1
	 FALSE,			/* pc_relative */
d620 1
a620 1
	 FALSE,			/* partial_inplace */
d623 1
a623 1
	 FALSE),		/* pcrel_offset */
d630 1
a630 1
	 FALSE,			/* pc_relative */
d635 1
a635 1
	 FALSE,			/* partial_inplace */
d638 1
a638 1
	 FALSE),		/* pcrel_offset */
d645 1
a645 1
	 FALSE,			/* pc_relative */
d650 1
a650 1
	 FALSE,			/* partial_inplace */
d653 1
a653 1
	 FALSE),		/* pcrel_offset */
d660 1
a660 1
	 FALSE,			/* pc_relative */
d665 1
a665 1
	 FALSE,			/* partial_inplace */
d668 1
a668 1
	 FALSE),		/* pcrel_offset */
d676 1
a676 1
	 TRUE,			/* pc_relative */
d681 1
a681 1
	 FALSE,			/* partial_inplace */
d684 1
a684 1
	 TRUE),			/* pcrel_offset */
d693 1
a693 1
	 FALSE,			/* pc_relative */
d698 1
a698 1
	 FALSE,			/* partial_inplace */
d701 1
a701 1
	 FALSE),		/* pcrel_offset */
d708 1
a708 1
	 FALSE,			/* pc_relative */
d713 1
a713 1
	 FALSE,			/* partial_inplace */
d716 1
a716 1
	 FALSE),		/* pcrel_offset */
d724 1
a724 1
	 FALSE,			/* pc_relative */
d729 1
a729 1
	 FALSE,			/* partial_inplace */
d732 1
a732 1
	 FALSE),		/* pcrel_offset */
d739 1
a739 1
	 FALSE,			/* pc_relative */
d744 1
a744 1
	 FALSE,			/* partial_inplace */
d747 1
a747 1
	 FALSE),		/* pcrel_offset */
d755 1
a755 1
	 FALSE,			/* pc_relative */
d760 1
a760 1
	 FALSE,			/* partial_inplace */
d763 1
a763 1
	 FALSE),		/* pcrel_offset */
d770 1
a770 1
	 FALSE,			/* pc_relative */
d775 1
a775 1
	 FALSE,			/* partial_inplace */
d778 1
a778 1
	 FALSE),		/* pcrel_offset */
d785 1
a785 1
	 TRUE,			/* pc_relative */
d790 1
a790 1
	 FALSE,			/* partial_inplace */
d793 1
a793 1
	 TRUE),			/* pcrel_offset */
d800 1
a800 1
	 FALSE,			/* pc_relative */
d805 1
a805 1
	 FALSE,			/* partial_inplace */
d808 1
a808 1
	 FALSE),		/* pcrel_offset */
d817 1
a817 1
	 TRUE,			/* pc_relative */
d822 1
a822 1
	 FALSE,			/* partial_inplace */
d825 1
a825 1
	 TRUE),			/* pcrel_offset */
d834 1
a834 1
	 FALSE,			/* pc_relative */
d839 1
a839 1
	 FALSE,			/* partial_inplace */
d842 1
a842 1
	 FALSE),		/* pcrel_offset */
d851 1
a851 1
	 FALSE,			/* pc_relative */
d856 1
a856 1
	 FALSE,			/* partial_inplace */
d859 1
a859 1
	 FALSE),		/* pcrel_offset */
d868 1
a868 1
	 FALSE,			/* pc_relative */
d873 1
a873 1
	 FALSE,			/* partial_inplace */
d876 1
a876 1
	 FALSE),		/* pcrel_offset */
d887 1
a887 1
	 FALSE,			/* pc_relative */
d892 1
a892 1
	 FALSE,			/* partial_inplace */
d895 1
a895 1
	 FALSE),		/* pcrel_offset */
d904 1
a904 1
	 FALSE,			/* pc_relative */
d909 1
a909 1
	 FALSE,			/* partial_inplace */
d912 1
a912 1
	 FALSE),		/* pcrel_offset */
d927 1
a927 1
	 FALSE,			/* pc_relative */
d932 1
a932 1
	 FALSE,			/* partial_inplace */
d935 1
a935 1
	 FALSE),		/* pcrel_offset */
d943 1
a943 1
	 FALSE,			/* pc_relative */
d948 1
a948 1
	 FALSE,			/* partial_inplace */
d951 1
a951 1
	 FALSE),		/* pcrel_offset */
d959 1
a959 1
	 FALSE,			/* pc_relative */
d964 1
a964 1
	 FALSE,			/* partial_inplace */
d967 1
a967 1
	 FALSE),		/* pcrel_offset */
d977 1
a977 1
	 FALSE,			/* pc_relative */
d982 1
a982 1
	 FALSE,			/* partial_inplace */
d985 1
a985 1
	 FALSE),		/* pcrel_offset */
d992 1
a992 1
	 FALSE,			/* pc_relative */
d997 1
a997 1
	 FALSE,			/* partial_inplace */
d1000 1
a1000 1
	 FALSE),		/* pcrel_offset */
d1007 1
a1007 1
	 FALSE,			/* pc_relative */
d1012 1
a1012 1
	 FALSE,			/* partial_inplace */
d1015 1
a1015 1
	 FALSE),		/* pcrel_offset */
d1022 1
a1022 1
	 FALSE,			/* pc_relative */
d1027 1
a1027 1
	 FALSE,			/* partial_inplace */
d1030 1
a1030 1
	 FALSE),		/* pcrel_offset */
d1037 1
a1037 1
	 FALSE,			/* pc_relative */
d1042 1
a1042 1
	 FALSE,			/* partial_inplace */
d1045 1
a1045 1
	 FALSE),		/* pcrel_offset */
d1052 1
a1052 1
	 FALSE,			/* pc_relative */
d1057 1
a1057 1
	 FALSE,			/* partial_inplace */
d1060 1
a1060 1
	 FALSE),		/* pcrel_offset */
d1067 1
a1067 1
	 FALSE,			/* pc_relative */
d1072 1
a1072 1
	 FALSE,			/* partial_inplace */
d1075 1
a1075 1
	 FALSE),		/* pcrel_offset */
d1082 1
a1082 1
	 FALSE,			/* pc_relative */
d1087 1
a1087 1
	 FALSE,			/* partial_inplace */
d1090 1
a1090 1
	 FALSE),		/* pcrel_offset */
d1097 1
a1097 1
	 FALSE,			/* pc_relative */
d1102 1
a1102 1
	 FALSE,			/* partial_inplace */
d1105 1
a1105 1
	 FALSE),		/* pcrel_offset */
d1112 1
a1112 1
	 FALSE,			/* pc_relative */
d1117 1
a1117 1
	 FALSE,			/* partial_inplace */
d1120 1
a1120 1
	 FALSE),		/* pcrel_offset */
d1128 1
a1128 1
	 FALSE,			/* pc_relative */
d1133 1
a1133 1
	 FALSE,			/* partial_inplace */
d1136 1
a1136 1
	 FALSE),		/* pcrel_offset */
d1144 1
a1144 1
	 FALSE,			/* pc_relative */
d1149 1
a1149 1
	 FALSE,			/* partial_inplace */
d1152 1
a1152 1
	 FALSE),		/* pcrel_offset */
d1159 1
a1159 1
	 FALSE,			/* pc_relative */
d1164 1
a1164 1
	 FALSE,			/* partial_inplace */
d1167 1
a1167 1
	 FALSE),		/* pcrel_offset */
d1174 1
a1174 1
	 FALSE,			/* pc_relative */
d1179 1
a1179 1
	 FALSE,			/* partial_inplace */
d1182 1
a1182 1
	 FALSE),		/* pcrel_offset */
d1354 1
a1354 1
     Elf_Internal_Rela *dst;
d1410 1
a1410 1
  bfd_boolean is_power4 = FALSE;
d1633 1
a1633 1
static bfd_boolean
d1648 1
a1648 1
  return TRUE;
d1654 1
a1654 1
static bfd_boolean
d1674 1
a1674 1
      return FALSE;
d1677 1
a1677 1
  return TRUE;
d1949 1
a1949 1
static bfd_boolean create_linkage_sections
d1951 1
a1951 1
static bfd_boolean create_got_section
d1953 1
a1953 1
static bfd_boolean ppc64_elf_create_dynamic_sections
d1958 1
a1958 1
static bfd_boolean ppc64_elf_check_relocs
d1964 1
a1964 1
static bfd_boolean ppc64_elf_gc_sweep_hook
d1967 1
a1967 1
static bfd_boolean func_desc_adjust
d1969 1
a1969 1
static bfd_boolean ppc64_elf_func_desc_adjust
d1971 1
a1971 1
static bfd_boolean ppc64_elf_adjust_dynamic_symbol
d1974 2
a1975 2
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean));
static bfd_boolean allocate_dynrelocs
d1977 1
a1977 1
static bfd_boolean readonly_dynrelocs
d1981 1
a1981 1
static bfd_boolean ppc64_elf_size_dynamic_sections
d1988 1
a1988 1
static bfd_boolean ppc_build_one_stub
d1990 1
a1990 1
static bfd_boolean ppc_size_one_stub
d1993 2
a1994 2
  PARAMS ((struct ppc_link_hash_table *, bfd_size_type, bfd_boolean));
static bfd_boolean ppc64_elf_relocate_section
d1998 1
a1998 1
static bfd_boolean ppc64_elf_finish_dynamic_symbol
d2001 1
a2001 1
static bfd_boolean ppc64_elf_finish_dynamic_sections
d2265 1
a2265 1
					 stub_name, FALSE, FALSE);
d2317 1
a2317 1
				     TRUE, FALSE);
d2334 1
a2334 1
static bfd_boolean
d2351 1
a2351 1
    return FALSE;
d2358 1
a2358 1
    return FALSE;
d2367 1
a2367 1
    return FALSE;
d2377 1
a2377 1
	return FALSE;
d2379 1
a2379 1
  return TRUE;
d2385 1
a2385 1
static bfd_boolean
d2393 1
a2393 1
    return FALSE;
d2407 2
a2408 2
    return FALSE;
  return TRUE;
d2413 1
a2413 1
static bfd_boolean
d2422 1
a2422 1
    return FALSE;
d2425 1
a2425 1
    return FALSE;
d2437 1
a2437 1
  return TRUE;
d2496 1
a2496 1
bfd_boolean
d2508 1
a2508 1
      h = elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
d2512 1
a2512 1
  return TRUE;
d2519 1
a2519 1
static bfd_boolean
d2535 1
a2535 1
    return TRUE;
d2567 1
a2567 1
	return FALSE;
d2575 1
a2575 1
    return FALSE;
d2604 1
a2604 1
	    return FALSE;
d2625 1
a2625 1
		    return FALSE;
d2647 1
a2647 1
	      return FALSE;
d2676 1
a2676 1
	    return FALSE;
d2683 1
a2683 1
	    return FALSE;
d2714 1
a2714 1
					  FALSE, FALSE, FALSE);
d2734 1
a2734 1
		return FALSE;
d2818 1
a2818 1
		    return FALSE;
d2844 1
a2844 1
			return FALSE;
d2865 1
a2865 1
		    return FALSE;
d2878 1
a2878 1
		    return FALSE;
d2897 1
a2897 1
  return TRUE;
d2940 1
a2940 1
		 sections, as all functions are referenced in .opd.  */
d2974 1
a2974 1
static bfd_boolean
d3115 1
a3115 1
  return TRUE;
d3121 1
a3121 1
static bfd_boolean
d3130 1
a3130 1
    return TRUE;
d3141 1
a3141 1
    return TRUE;
d3145 1
a3145 1
    htab->have_undefweak = TRUE;
d3152 1
a3152 1
      bfd_boolean force_local;
d3159 1
a3159 1
				    FALSE, FALSE, TRUE);
d3182 1
a3182 1
		  newsym->section, newsym->value, NULL, FALSE, FALSE, &bh)))
d3184 1
a3184 1
	      return FALSE;
d3198 1
a3198 1
	      return FALSE;
d3232 1
a3232 1
  return TRUE;
d3242 1
a3242 1
static bfd_boolean
d3259 1
a3259 1
    return TRUE;
d3267 1
a3267 1
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
d3287 1
a3287 1
      h = elf_link_hash_lookup (&htab->elf, sym, FALSE, FALSE, TRUE);
d3313 1
a3313 1
	  return TRUE;
d3321 1
a3321 1
    return FALSE;
d3350 1
a3350 1
  return TRUE;
d3359 1
a3359 1
static bfd_boolean
d3388 1
a3388 1
      return TRUE;
d3402 1
a3402 1
      return TRUE;
d3413 1
a3413 1
    return TRUE;
d3418 1
a3418 1
    return TRUE;
d3433 1
a3433 1
      return TRUE;
d3468 1
a3468 1
	return FALSE;
d3478 1
a3478 1
  return TRUE;
d3487 1
a3487 1
     bfd_boolean force_local;
d3514 1
a3514 1
	  fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d3527 1
a3527 1
		fh = elf_link_hash_lookup (&htab->elf, p, FALSE, FALSE, FALSE);
d3540 1
a3540 1
bfd_boolean
d3560 1
a3560 1
      bfd_boolean need_edit;
d3589 1
a3589 1
      relstart = _bfd_elf64_link_read_relocs (ibfd, sec, (PTR) NULL,
d3593 1
a3593 1
	return FALSE;
d3597 1
a3597 1
      need_edit = FALSE;
d3620 1
a3620 1
	      need_edit = FALSE;
d3636 1
a3636 1
		 optimization for them!  */
d3640 1
a3640 1
	      need_edit = FALSE;
d3683 1
a3683 1
	      need_edit = FALSE;
d3696 1
a3696 1
	    need_edit = TRUE;
d3705 1
a3705 1
	  bfd_boolean skip;
d3724 1
a3724 1
		  return FALSE;
d3735 1
a3735 1
	  skip = FALSE;
d3792 1
a3792 1
						      FALSE, FALSE, FALSE);
d3827 1
a3827 1
						      FALSE, FALSE, FALSE);
d3843 1
a3843 1
			     array of adjustments.  */
a3868 5
	  /* Fudge the size too, as this is used later in
	     elf_bfd_final_link if we are emitting relocs.  */
	  elf_section_data (sec)->rel_hdr.sh_size
	    = sec->reloc_count * elf_section_data (sec)->rel_hdr.sh_entsize;
	  BFD_ASSERT (elf_section_data (sec)->rel_hdr2 == NULL);
d3883 1
a3883 1
  return TRUE;
d3885 1
a3885 1

d3900 1
a3900 1
static bfd_boolean
d3912 1
a3912 1
    return TRUE;
d3966 1
a3966 1
      bfd_boolean dyn;
d3974 1
a3974 1
	    return FALSE;
d3989 1
a3989 1
    return TRUE;
d4035 1
a4035 1
		return FALSE;
d4056 1
a4056 1
  return TRUE;
d4061 1
a4061 1
static bfd_boolean
d4084 1
a4084 1
	  return FALSE;
d4087 1
a4087 1
  return TRUE;
d4092 1
a4092 1
static bfd_boolean
d4100 1
a4100 1
  bfd_boolean relocs;
d4190 1
a4190 1
  relocs = FALSE;
d4223 1
a4223 1
		relocs = TRUE;
d4253 1
a4253 1
	return FALSE;
d4269 1
a4269 1
	    return FALSE;
d4279 1
a4279 1
	    return FALSE;
d4286 1
a4286 1
	    return FALSE;
d4294 1
a4294 1
	    return FALSE;
d4305 1
a4305 1
		return FALSE;
d4311 1
a4311 1
  return TRUE;
d4397 1
a4397 1
static bfd_boolean
d4449 1
a4449 1
					 FALSE, FALSE);
d4454 2
a4455 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4469 1
a4469 1
	  bfd_byte *loc;
d4477 3
a4479 3
	  loc = htab->srelbrlt->contents;
	  loc += htab->srelbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->srelbrlt->owner, &rela, loc);
d4494 2
a4495 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4538 2
a4539 2
	  htab->stub_error = TRUE;
	  return FALSE;
d4548 1
a4548 1
      return FALSE;
d4552 1
a4552 1
  return TRUE;
d4559 1
a4559 1
static bfd_boolean
d4604 1
a4604 1
					     TRUE, FALSE);
d4609 2
a4610 2
	      htab->stub_error = TRUE;
	      return FALSE;
d4625 1
a4625 1
  return TRUE;
d4741 1
a4741 1
     bfd_boolean stubs_always_before_branch;
d4811 1
a4811 1
bfd_boolean
d4822 1
a4822 1
  bfd_boolean stubs_always_before_branch;
d4849 1
a4849 1
      bfd_boolean stub_changed;
d4852 1
a4852 1
      stub_changed = FALSE;
d5008 1
a5008 1
						     stub_name, FALSE, FALSE);
d5028 1
a5028 1
		      return FALSE;
d5035 1
a5035 1
		  stub_changed = TRUE;
d5079 1
a5079 1
  return TRUE;
d5143 1
a5143 1
bfd_boolean
d5164 1
a5164 1
	    return FALSE;
d5215 1
a5215 1
	return FALSE;
d5232 1
a5232 1
      htab->stub_error = TRUE;
d5268 1
a5268 1
static bfd_boolean
d5287 2
a5288 2
  bfd_boolean ret = TRUE;
  bfd_boolean is_opd;
d5290 1
a5290 1
  bfd_boolean is_power4 = FALSE;
d5293 1
a5293 1
    return TRUE;
d5321 2
a5322 2
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
d5337 2
a5338 2
      unresolved_reloc = FALSE;
      warned = FALSE;
d5383 1
a5383 1
		unresolved_reloc = TRUE;
d5403 2
a5404 2
		return FALSE;
	      warned = TRUE;
d5463 1
a5463 1
	      bfd_boolean can_plt_call = 0;
d5492 1
a5492 1
		  unresolved_reloc = FALSE;
d5531 1
a5531 1
	  ret = FALSE;
d5559 1
a5559 1
		bfd_boolean dyn;
d5594 1
a5594 1
		  unresolved_reloc = FALSE;
d5616 1
a5616 1
			bfd_byte *loc;
d5625 2
a5626 3
			loc = htab->srelgot->contents;
			loc += (htab->srelgot->reloc_count++
				* sizeof (Elf64_External_Rela));
d5669 1
a5669 1
	  unresolved_reloc = FALSE;
d5759 1
a5759 1
	      bfd_boolean skip, relocate;
d5761 1
a5761 1
	      bfd_byte *loc;
d5767 2
a5768 2
	      skip = FALSE;
	      relocate = FALSE;
d5774 1
a5774 1
		skip = TRUE;
d5776 1
a5776 1
		skip = TRUE, relocate = TRUE;
d5798 1
a5798 1
		  relocate = TRUE;
d5813 1
a5813 1
			  unresolved_reloc = FALSE;
d5826 1
a5826 1
			  return FALSE;
d5851 2
a5852 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
d5887 1
a5887 1
	  ret = FALSE;
d5930 1
a5930 1
	      ret = FALSE;
d5977 1
a5977 1
	  ret = FALSE;
d6026 1
a6026 1
		return FALSE;
d6035 1
a6035 1
	      ret = FALSE;
d6046 1
a6046 1
static bfd_boolean
d6063 1
a6063 1
      bfd_byte *loc;
d6082 2
a6083 3
      loc = htab->srelplt->contents;
      loc += ((h->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      * sizeof (Elf64_External_Rela));
d6090 1
a6090 1
      bfd_byte *loc;
d6128 2
a6129 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d6136 1
a6136 1
      bfd_byte *loc;
d6151 2
a6152 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d6160 1
a6160 1
  return TRUE;
d6188 1
a6188 1
static bfd_boolean
d6223 2
a6224 2
	      s = htab->sglink;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d6229 2
a6230 3
	      if (s == NULL)
		continue;
	      dyn.d_un.d_ptr = s->vma;
d6235 2
a6236 3
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val = s->_raw_size;
d6240 2
a6241 2
	      s = htab->splt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d6245 2
a6246 2
	      s = htab->srelplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d6256 2
a6257 16
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      dyn.d_un.d_val -= s->_raw_size;
	      break;

	    case DT_RELA:
	      /* We may not be using the standard ELF linker script.
		 If .rela.plt is the first .rela section, we adjust
		 DT_RELA to not include it.  */
	      s = htab->srelplt;
	      if (s == NULL)
		continue;
	      if (dyn.d_un.d_ptr != s->output_section->vma + s->output_offset)
		continue;
	      dyn.d_un.d_ptr += s->_raw_size;
d6284 1
a6284 1
  return TRUE;
@


1.63.10.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d30 1
a30 1
#include "elf/ppc64.h"
a58 2
static bfd_boolean ppc64_elf_new_section_hook
  PARAMS ((bfd *, asection *));
d72 1
a72 5
#define TOC_BASE_OFF	0x8000

/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000
d129 1
a129 1
static reloc_howto_type *ppc64_elf_howto_table[(int) R_PPC64_max];
d135 2
a136 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d670 3
a672 2
  /* Like R_PPC64_REL24 without touching the two least significant bits.  */
  HOWTO (R_PPC64_REL30,		/* type */
d680 1
a680 1
	 "R_PPC64_REL30",	/* name */
d931 1
a931 599
	 "R_PPC64_PLTGOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16, but without overflow.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address.  */
  /* FIXME: R_PPC64_PLTGOT16_HI not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT_GOT16, but using bits 16-31 of the address, plus
     1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  /* FIXME: R_PPC64_PLTGOT16_HA not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_ADDR16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_ADDR16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_ADDR16_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_GOT16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_GOT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_GOT16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLT16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_PLT16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLT16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_SECTOFF, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_SECTOFF_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_SECTOFF_LO_DS, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_sectoff_reloc, /* special_function */
	 "R_PPC64_SECTOFF_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_TOC16, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_TOC16_LO, but for instructions with a DS field.  */
  HOWTO (R_PPC64_TOC16_LO_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_toc_reloc,	/* special_function */
	 "R_PPC64_TOC16_LO_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_DS not implemented.  */
    HOWTO (R_PPC64_PLTGOT16_DS,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC64_PLTGOT16_LO, but for instructions with a DS field.  */
  /* FIXME: R_PPC64_PLTGOT16_LO not implemented.  */
  HOWTO (R_PPC64_PLTGOT16_LO_DS,/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_PLTGOT16_LO_DS",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marker reloc for TLS.  */
  HOWTO (R_PPC64_TLS,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC64_TLS",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC64_DTPMOD64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPMOD64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC64_DTPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC64_DTPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHER", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_DTPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_DTPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_DTPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_DTPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC64_TPREL64,
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ONES (64),		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC64_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHER,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHERA,
	 32,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHERA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHER, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHEST,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHEST", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HIGHEST, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_TPREL16_HIGHESTA,
	 48,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_HIGHESTA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but for insns with a DS field.  */
  HOWTO (R_PPC64_TPREL16_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_DS",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_TPREL16_LO_DS,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_TPREL16_LO_DS", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSGD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSGD16",	/* name */
d937 3
a939 2
  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSGD16_LO,
d947 1
a947 1
	 "R_PPC64_GOT_TLSGD16_LO", /* name */
d953 3
a955 2
  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HI,
d963 1
a963 1
	 "R_PPC64_GOT_TLSGD16_HI", /* name */
d969 5
a973 2
  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSGD16_HA,
d979 1
a979 1
	 complain_overflow_dont, /* complain_on_overflow */
d981 1
a981 1
	 "R_PPC64_GOT_TLSGD16_HA", /* name */
d987 2
a988 4
  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TLSLD16,
d994 3
a996 3
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16",	/* name */
d999 1
a999 1
	 0xffff,		/* dst_mask */
d1002 2
a1003 2
  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC64_GOT_TLSLD16_LO,
d1009 3
a1011 3
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TLSLD16_LO", /* name */
d1014 1
a1014 1
	 0xffff,		/* dst_mask */
d1017 3
a1019 3
  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HI,
	 16,			/* rightshift */
d1024 1
a1024 1
	 complain_overflow_dont, /* complain_on_overflow */
d1026 1
a1026 1
	 "R_PPC64_GOT_TLSLD16_HI", /* name */
d1029 1
a1029 1
	 0xffff,		/* dst_mask */
d1032 3
a1034 3
  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TLSLD16_HA,
	 16,			/* rightshift */
d1041 1
a1041 1
	 "R_PPC64_GOT_TLSLD16_HA", /* name */
d1044 1
a1044 1
	 0xffff,		/* dst_mask */
d1047 2
a1048 3
  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_DTPREL16_DS,
d1054 1
a1054 1
	 complain_overflow_signed, /* complain_on_overflow */
d1056 1
a1056 1
	 "R_PPC64_GOT_DTPREL16_DS", /* name */
d1062 2
a1063 2
  /* Like GOT_DTPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_DTPREL16_LO_DS,
d1069 3
a1071 3
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_LO_DS", /* name */
d1077 3
a1079 3
  /* Like GOT_DTPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HI,
	 16,			/* rightshift */
d1085 2
a1086 2
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HI", /* name */
d1089 1
a1089 1
	 0xffff,		/* dst_mask */
d1092 2
a1093 18
  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry relative to the TOC base (r2).  */
  HOWTO (R_PPC64_GOT_TPREL16_DS,
d1100 2
a1101 2
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_DS", /* name */
d1104 1
a1104 1
	 0xffff,		/* dst_mask */
d1107 2
a1108 2
  /* Like GOT_TPREL16_DS, but no overflow.  */
  HOWTO (R_PPC64_GOT_TPREL16_LO_DS,
d1115 2
a1116 2
	 ppc64_elf_unhandled_reloc, /* special_function */
	 "R_PPC64_GOT_TPREL16_LO_DS", /* name */
d1119 1
a1119 1
	 0xffff,		/* dst_mask */
d1122 4
a1125 3
  /* Like GOT_TPREL16_LO_DS, but next higher group of 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HI,
	 16,			/* rightshift */
d1130 1
a1130 1
	 complain_overflow_dont, /* complain_on_overflow */
d1132 1
a1132 1
	 "R_PPC64_GOT_TPREL16_HI", /* name */
d1135 1
a1135 1
	 0xffff,		/* dst_mask */
d1138 4
a1141 3
  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC64_GOT_TPREL16_HA,
	 16,			/* rightshift */
d1148 1
a1148 1
	 "R_PPC64_GOT_TPREL16_HA", /* name */
d1151 1
a1151 1
	 0xffff,		/* dst_mask */
d1210 1
a1210 1
  enum elf_ppc64_reloc_type r = R_PPC64_NONE;
d1221 1
a1221 15
    case BFD_RELOC_NONE:			r = R_PPC64_NONE;
      break;
    case BFD_RELOC_32:				r = R_PPC64_ADDR32;
      break;
    case BFD_RELOC_PPC_BA26:			r = R_PPC64_ADDR24;
      break;
    case BFD_RELOC_16:				r = R_PPC64_ADDR16;
      break;
    case BFD_RELOC_LO16:			r = R_PPC64_ADDR16_LO;
      break;
    case BFD_RELOC_HI16:			r = R_PPC64_ADDR16_HI;
      break;
    case BFD_RELOC_HI16_S:			r = R_PPC64_ADDR16_HA;
      break;
    case BFD_RELOC_PPC_BA16:			r = R_PPC64_ADDR14;
d1223 1
a1223 1
    case BFD_RELOC_PPC_BA16_BRTAKEN:		r = R_PPC64_ADDR14_BRTAKEN;
d1225 1
a1225 1
    case BFD_RELOC_PPC_BA16_BRNTAKEN:		r = R_PPC64_ADDR14_BRNTAKEN;
d1227 1
a1227 1
    case BFD_RELOC_PPC_B26:			r = R_PPC64_REL24;
d1229 1
a1229 1
    case BFD_RELOC_PPC_B16:			r = R_PPC64_REL14;
d1231 1
a1231 1
    case BFD_RELOC_PPC_B16_BRTAKEN:		r = R_PPC64_REL14_BRTAKEN;
d1233 1
a1233 1
    case BFD_RELOC_PPC_B16_BRNTAKEN:		r = R_PPC64_REL14_BRNTAKEN;
d1235 1
a1235 1
    case BFD_RELOC_16_GOTOFF:			r = R_PPC64_GOT16;
d1237 1
a1237 1
    case BFD_RELOC_LO16_GOTOFF:			r = R_PPC64_GOT16_LO;
d1239 1
a1239 1
    case BFD_RELOC_HI16_GOTOFF:			r = R_PPC64_GOT16_HI;
d1241 1
a1241 1
    case BFD_RELOC_HI16_S_GOTOFF:		r = R_PPC64_GOT16_HA;
d1243 1
a1243 1
    case BFD_RELOC_PPC_COPY:			r = R_PPC64_COPY;
d1245 1
a1245 1
    case BFD_RELOC_PPC_GLOB_DAT:		r = R_PPC64_GLOB_DAT;
d1247 1
a1247 1
    case BFD_RELOC_32_PCREL:			r = R_PPC64_REL32;
d1249 1
a1249 1
    case BFD_RELOC_32_PLTOFF:			r = R_PPC64_PLT32;
d1251 1
a1251 1
    case BFD_RELOC_32_PLT_PCREL:		r = R_PPC64_PLTREL32;
d1253 1
a1253 1
    case BFD_RELOC_LO16_PLTOFF:			r = R_PPC64_PLT16_LO;
d1255 1
a1255 1
    case BFD_RELOC_HI16_PLTOFF:			r = R_PPC64_PLT16_HI;
d1257 1
a1257 1
    case BFD_RELOC_HI16_S_PLTOFF:		r = R_PPC64_PLT16_HA;
d1259 1
a1259 1
    case BFD_RELOC_16_BASEREL:			r = R_PPC64_SECTOFF;
d1261 1
a1261 1
    case BFD_RELOC_LO16_BASEREL:		r = R_PPC64_SECTOFF_LO;
d1263 1
a1263 1
    case BFD_RELOC_HI16_BASEREL:		r = R_PPC64_SECTOFF_HI;
d1265 1
a1265 1
    case BFD_RELOC_HI16_S_BASEREL:		r = R_PPC64_SECTOFF_HA;
d1267 1
a1267 1
    case BFD_RELOC_CTOR:			r = R_PPC64_ADDR64;
d1269 1
a1269 1
    case BFD_RELOC_64:				r = R_PPC64_ADDR64;
d1271 1
a1271 1
    case BFD_RELOC_PPC64_HIGHER:		r = R_PPC64_ADDR16_HIGHER;
d1273 1
a1273 1
    case BFD_RELOC_PPC64_HIGHER_S:		r = R_PPC64_ADDR16_HIGHERA;
d1275 1
a1275 1
    case BFD_RELOC_PPC64_HIGHEST:		r = R_PPC64_ADDR16_HIGHEST;
d1277 1
a1277 1
    case BFD_RELOC_PPC64_HIGHEST_S:		r = R_PPC64_ADDR16_HIGHESTA;
d1279 1
a1279 1
    case BFD_RELOC_64_PCREL:			r = R_PPC64_REL64;
d1281 1
a1281 1
    case BFD_RELOC_64_PLTOFF:			r = R_PPC64_PLT64;
d1283 1
a1283 1
    case BFD_RELOC_64_PLT_PCREL:		r = R_PPC64_PLTREL64;
d1285 1
a1285 1
    case BFD_RELOC_PPC_TOC16:			r = R_PPC64_TOC16;
d1287 1
a1287 1
    case BFD_RELOC_PPC64_TOC16_LO:		r = R_PPC64_TOC16_LO;
d1289 1
a1289 1
    case BFD_RELOC_PPC64_TOC16_HI:		r = R_PPC64_TOC16_HI;
d1291 1
a1291 1
    case BFD_RELOC_PPC64_TOC16_HA:		r = R_PPC64_TOC16_HA;
d1293 1
a1293 1
    case BFD_RELOC_PPC64_TOC:			r = R_PPC64_TOC;
d1295 1
a1295 1
    case BFD_RELOC_PPC64_PLTGOT16:		r = R_PPC64_PLTGOT16;
d1297 1
a1297 1
    case BFD_RELOC_PPC64_PLTGOT16_LO:		r = R_PPC64_PLTGOT16_LO;
d1299 1
a1299 1
    case BFD_RELOC_PPC64_PLTGOT16_HI:		r = R_PPC64_PLTGOT16_HI;
d1301 1
a1301 1
    case BFD_RELOC_PPC64_PLTGOT16_HA:		r = R_PPC64_PLTGOT16_HA;
d1303 1
a1303 1
    case BFD_RELOC_PPC64_ADDR16_DS:		r = R_PPC64_ADDR16_DS;
d1305 1
a1305 1
    case BFD_RELOC_PPC64_ADDR16_LO_DS:		r = R_PPC64_ADDR16_LO_DS;
d1307 1
a1307 1
    case BFD_RELOC_PPC64_GOT16_DS:		r = R_PPC64_GOT16_DS;
d1309 1
a1309 1
    case BFD_RELOC_PPC64_GOT16_LO_DS:		r = R_PPC64_GOT16_LO_DS;
d1311 1
a1311 1
    case BFD_RELOC_PPC64_PLT16_LO_DS:		r = R_PPC64_PLT16_LO_DS;
d1313 1
a1313 1
    case BFD_RELOC_PPC64_SECTOFF_DS:		r = R_PPC64_SECTOFF_DS;
d1315 1
a1315 1
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:		r = R_PPC64_SECTOFF_LO_DS;
d1317 1
a1317 1
    case BFD_RELOC_PPC64_TOC16_DS:		r = R_PPC64_TOC16_DS;
d1319 1
a1319 1
    case BFD_RELOC_PPC64_TOC16_LO_DS:		r = R_PPC64_TOC16_LO_DS;
d1321 1
a1321 1
    case BFD_RELOC_PPC64_PLTGOT16_DS:		r = R_PPC64_PLTGOT16_DS;
d1323 1
a1323 1
    case BFD_RELOC_PPC64_PLTGOT16_LO_DS:	r = R_PPC64_PLTGOT16_LO_DS;
d1325 1
a1325 1
    case BFD_RELOC_PPC_TLS:			r = R_PPC64_TLS;
d1327 1
a1327 1
    case BFD_RELOC_PPC_DTPMOD:			r = R_PPC64_DTPMOD64;
d1329 1
a1329 1
    case BFD_RELOC_PPC_TPREL16:			r = R_PPC64_TPREL16;
d1331 1
a1331 1
    case BFD_RELOC_PPC_TPREL16_LO:		r = R_PPC64_TPREL16_LO;
d1333 1
a1333 1
    case BFD_RELOC_PPC_TPREL16_HI:		r = R_PPC64_TPREL16_HI;
d1335 1
a1335 1
    case BFD_RELOC_PPC_TPREL16_HA:		r = R_PPC64_TPREL16_HA;
d1337 1
a1337 1
    case BFD_RELOC_PPC_TPREL:			r = R_PPC64_TPREL64;
d1339 1
a1339 1
    case BFD_RELOC_PPC_DTPREL16:		r = R_PPC64_DTPREL16;
d1341 1
a1341 67
    case BFD_RELOC_PPC_DTPREL16_LO:		r = R_PPC64_DTPREL16_LO;
      break;
    case BFD_RELOC_PPC_DTPREL16_HI:		r = R_PPC64_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_DTPREL16_HA:		r = R_PPC64_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC_DTPREL:			r = R_PPC64_DTPREL64;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16:		r = R_PPC64_GOT_TLSGD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:		r = R_PPC64_GOT_TLSGD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:		r = R_PPC64_GOT_TLSGD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:		r = R_PPC64_GOT_TLSGD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16:		r = R_PPC64_GOT_TLSLD16;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:		r = R_PPC64_GOT_TLSLD16_LO;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:		r = R_PPC64_GOT_TLSLD16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:		r = R_PPC64_GOT_TLSLD16_HA;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16:		r = R_PPC64_GOT_TPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:		r = R_PPC64_GOT_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:		r = R_PPC64_GOT_TPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:		r = R_PPC64_GOT_TPREL16_HA;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16:		r = R_PPC64_GOT_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:		r = R_PPC64_GOT_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:		r = R_PPC64_GOT_DTPREL16_HI;
      break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:		r = R_PPC64_GOT_DTPREL16_HA;
      break;
    case BFD_RELOC_PPC64_TPREL16_DS:		r = R_PPC64_TPREL16_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_LO_DS:		r = R_PPC64_TPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHER:	r = R_PPC64_TPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHERA:	r = R_PPC64_TPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHEST:	r = R_PPC64_TPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_TPREL16_HIGHESTA:	r = R_PPC64_TPREL16_HIGHESTA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_DS:		r = R_PPC64_DTPREL16_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_LO_DS:	r = R_PPC64_DTPREL16_LO_DS;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHER:	r = R_PPC64_DTPREL16_HIGHER;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHERA:	r = R_PPC64_DTPREL16_HIGHERA;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHEST:	r = R_PPC64_DTPREL16_HIGHEST;
      break;
    case BFD_RELOC_PPC64_DTPREL16_HIGHESTA:	r = R_PPC64_DTPREL16_HIGHESTA;
      break;
    case BFD_RELOC_VTABLE_INHERIT:		r = R_PPC64_GNU_VTINHERIT;
      break;
    case BFD_RELOC_VTABLE_ENTRY:		r = R_PPC64_GNU_VTENTRY;
d1345 1
a1345 1
  return ppc64_elf_howto_table[(int) r];
d1368 1
a1368 1
/* Handle the R_PPC64_ADDR16_HA and similar relocs.  */
d1407 1
a1407 1
  enum elf_ppc64_reloc_type r_type;
d1422 1
a1422 1
  r_type = (enum elf_ppc64_reloc_type) reloc_entry->howto->type;
a1678 37

struct _ppc64_elf_section_data
{
  struct bfd_elf_section_data elf;

  /* An array with one entry for each opd function descriptor.  */
  union
  {
    /* Points to the function code section for local opd entries.  */
    asection **func_sec;
    /* After editing .opd, adjust references to opd local syms.  */
    long *adjust;
  } opd;

  /* An array for toc sections, indexed by offset/8.
     Specifies the relocation symbol index used at a given toc offset.  */
  unsigned *t_symndx;
};

#define ppc64_elf_section_data(sec) \
  ((struct _ppc64_elf_section_data *) elf_section_data (sec))

static bfd_boolean
ppc64_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct _ppc64_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct _ppc64_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}
d1720 1
a1720 1
   .		addi	12,12,Lfoo@@toc@@l	# is slightly optimized, but
a1767 31
/* Track GOT entries needed for a given symbol.  We might need more
   than one got entry per symbol.  */
struct got_entry
{
  struct got_entry *next;

  bfd_vma addend;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } got;

  char tls_type;
};

/* The same for PLT.  */
struct plt_entry
{
  struct plt_entry *next;

  bfd_vma addend;

  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;
};

d1769 1
a1769 1
   selects those that must be copied when linking a shared library.  */
d1771 1
a1771 1
#define MUST_BE_DYN_RELOC(RTYPE)		\
d1774 1
a1774 1
   && (RTYPE) != R_PPC64_REL30)
a1832 3
  /* And the reloc addend that this was derived from.  */
  bfd_vma addend;

a1867 10

  /* Contexts in which symbol is used in the GOT (or TOC).
     Linker optimization will result in various transformations.  */
#define TLS_TLS		1	/* Any TLS reloc.  */
#define TLS_GD_LD	2	/* GD or LD reloc requiring 2 got slots. */
#define TLS_LD		4	/* LD reloc. */
#define TLS_TPREL	8	/* TPREL reloc, => IE. */
#define TLS_DTPREL     16	/* DTPREL reloc, => LD. */
#define TLS_EXPLICIT   32	/* Marks TOC section relocs. */
  char tls_type;
a1913 12
  /* Short-cut to first output tls section.  */
  asection *tls_sec;

  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;

a1957 4
static bfd_boolean update_local_sym_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned long, bfd_vma, int));
static bfd_boolean update_plt_info
  PARAMS ((bfd *, struct ppc_link_hash_entry *, bfd_vma));
a1974 5
static bfd_boolean get_sym_h
  PARAMS ((struct elf_link_hash_entry **, Elf_Internal_Sym **, asection **,
	   char **, Elf_Internal_Sym **, unsigned long, bfd *));
static bfd_boolean get_tls_type
  PARAMS ((char **, Elf_Internal_Sym **, const Elf_Internal_Rela *, bfd *));
d1983 1
a1983 1
static enum ppc_stub_type ppc_type_of_stub
a2114 1
      eh->tls_type = 0;
a2160 2
  htab->tls_sec = NULL;
  htab->tlsld_got.refcount = 0;
a2165 2
  htab->elf.init_refcount.glist = NULL;
  htab->elf.init_offset.glist = NULL;
d2444 1
a2444 1
     struct elf_backend_data *bed ATTRIBUTE_UNUSED;
a2451 1
  /* Copy over any dynamic relocs we may have on the indirect sym.  */
d2459 1
a2459 1
	  if (eind->elf.root.type == bfd_link_hash_indirect)
d2490 1
a2490 81
  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */
  edir->elf.elf_link_hash_flags |=
    (eind->elf.elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));

  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

  /* Copy over got entries.  */
  if (eind->elf.got.glist != NULL)
    {
      if (edir->elf.got.glist != NULL)
	{
	  struct got_entry **entp;
	  struct got_entry *ent;

	  for (entp = &eind->elf.got.glist; (ent = *entp) != NULL; )
	    {
	      struct got_entry *dent;

	      for (dent = edir->elf.got.glist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend
		    && dent->tls_type == ent->tls_type)
		  {
		    dent->got.refcount += ent->got.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.got.glist;
	}

      edir->elf.got.glist = eind->elf.got.glist;
      eind->elf.got.glist = NULL;
    }

  /* And plt entries.  */
  if (eind->elf.plt.plist != NULL)
    {
      if (edir->elf.plt.plist != NULL)
	{
	  struct plt_entry **entp;
	  struct plt_entry *ent;

	  for (entp = &eind->elf.plt.plist; (ent = *entp) != NULL; )
	    {
	      struct plt_entry *dent;

	      for (dent = edir->elf.plt.plist; dent != NULL; dent = dent->next)
		if (dent->addend == ent->addend)
		  {
		    dent->plt.refcount += ent->plt.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.plt.plist;
	}

      edir->elf.plt.plist = eind->elf.plt.plist;
      eind->elf.plt.plist = NULL;
    }

  if (edir->elf.dynindx == -1)
    {
      edir->elf.dynindx = eind->elf.dynindx;
      edir->elf.dynstr_index = eind->elf.dynstr_index;
      eind->elf.dynindx = -1;
      eind->elf.dynstr_index = 0;
    }
  else
    BFD_ASSERT (eind->elf.dynindx == -1);
d2500 2
a2501 71
  struct ppc_link_hash_table *htab;
  struct bfd_sym_chain *sym;

  htab = ppc_hash_table (info);
  for (sym = info->gc_sym_list; sym; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (&htab->elf, sym->name, FALSE, FALSE, FALSE);
      if (h != NULL)
	((struct ppc_link_hash_entry *) h)->is_entry = 1;
    }
  return TRUE;
}

static bfd_boolean
update_local_sym_info (abfd, symtab_hdr, r_symndx, r_addend, tls_type)
     bfd *abfd;
     Elf_Internal_Shdr *symtab_hdr;
     unsigned long r_symndx;
     bfd_vma r_addend;
     int tls_type;
{
  struct got_entry **local_got_ents = elf_local_got_ents (abfd);
  char *local_got_tls_types;

  if (local_got_ents == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= sizeof (*local_got_ents) + sizeof (char);
      local_got_ents = (struct got_entry **) bfd_zalloc (abfd, size);
      if (local_got_ents == NULL)
	return FALSE;
      elf_local_got_ents (abfd) = local_got_ents;
    }

  if ((tls_type & TLS_EXPLICIT) == 0)
    {
      struct got_entry *ent;

      for (ent = local_got_ents[r_symndx]; ent != NULL; ent = ent->next)
	if (ent->addend == r_addend && ent->tls_type == tls_type)
	  break;
      if (ent == NULL)
	{
	  bfd_size_type amt = sizeof (*ent);
	  ent = (struct got_entry *) bfd_alloc (abfd, amt);
	  if (ent == NULL)
	    return FALSE;
	  ent->next = local_got_ents[r_symndx];
	  ent->addend = r_addend;
	  ent->tls_type = tls_type;
	  ent->got.refcount = 0;
	  local_got_ents[r_symndx] = ent;
	}
      ent->got.refcount += 1;
    }

  local_got_tls_types = (char *) (local_got_ents + symtab_hdr->sh_info);
  local_got_tls_types[r_symndx] |= tls_type;
  return TRUE;
}

static bfd_boolean
update_plt_info (abfd, eh, addend)
     bfd *abfd;
     struct ppc_link_hash_entry *eh;
     bfd_vma addend;
{
  struct plt_entry *ent;
d2503 2
a2504 4
  for (ent = eh->elf.plt.plist; ent != NULL; ent = ent->next)
    if (ent->addend == addend)
      break;
  if (ent == NULL)
d2506 6
a2511 12
      bfd_size_type amt = sizeof (*ent);
      ent = (struct plt_entry *) bfd_alloc (abfd, amt);
      if (ent == NULL)
	return FALSE;
      ent->next = eh->elf.plt.plist;
      ent->addend = addend;
      ent->plt.refcount = 0;
      eh->elf.plt.plist = ent;
    }
  ent->plt.refcount += 1;
  eh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
  eh->is_func = 1;
d2568 1
a2568 1
      ppc64_elf_section_data (sec)->opd.func_sec = opd_sym_map;
d2582 1
a2582 2
      enum elf_ppc64_reloc_type r_type;
      int tls_type = 0;
d2590 1
a2590 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d2593 1
a2593 33
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount += 1;
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
	  goto dogottls;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD_LD;
	  goto dogottls;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

d2600 1
d2608 5
a2612 2
	      struct ppc_link_hash_entry *eh;
	      struct got_entry *ent;
d2614 3
a2616 6
	      eh = (struct ppc_link_hash_entry *) h;
	      for (ent = eh->elf.got.glist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend
		    && ent->tls_type == tls_type)
		  break;
	      if (ent == NULL)
d2618 7
a2624 3
		  bfd_size_type amt = sizeof (*ent);
		  ent = (struct got_entry *) bfd_alloc (abfd, amt);
		  if (ent == NULL)
d2626 1
a2626 5
		  ent->next = eh->elf.got.glist;
		  ent->addend = rel->r_addend;
		  ent->tls_type = tls_type;
		  ent->got.refcount = 0;
		  eh->elf.got.glist = ent;
d2628 1
a2628 2
	      ent->got.refcount += 1;
	      eh->tls_type |= tls_type;
a2629 5
	  else
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;
d2649 4
a2652 4
	  else
	    if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				  rel->r_addend))
	      return FALSE;
a2669 10
	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
d2699 3
a2701 76
	      if (!update_plt_info (abfd, (struct ppc_link_hash_entry *) h,
				    rel->r_addend))
		return FALSE;
	      if (h == htab->tls_get_addr)
		sec->has_tls_reloc = 1;
	      else if (strcmp (h->root.root.string, ".__tls_get_addr") == 0)
		{
		  htab->tls_get_addr = h;
		  sec->has_tls_reloc = 1;
		}
	    }
	  break;

	case R_PPC64_TPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_TPREL;
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dotlstoc;

	case R_PPC64_DTPMOD64:
	  if (rel + 1 < rel_end
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD;
	  else
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD | TLS_LD;
	  goto dotlstoc;

	case R_PPC64_DTPREL64:
	  tls_type = TLS_EXPLICIT | TLS_TLS | TLS_DTPREL;
	  if (rel != relocs
	      && rel[-1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPMOD64)
	      && rel[-1].r_offset == rel->r_offset - 8)
	    /* This is the second reloc of a dtpmod, dtprel pair.
	       Don't mark with TLS_DTPREL.  */
	    goto dodyn;

	dotlstoc:
	  sec->has_tls_reloc = 1;
	  if (h != NULL)
	    {
	      struct ppc_link_hash_entry *eh;
	      eh = (struct ppc_link_hash_entry *) h;
	      eh->tls_type |= tls_type;
	    }
	  else
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx,
					rel->r_addend, tls_type))
	      return FALSE;

	  if (ppc64_elf_section_data (sec)->t_symndx == NULL)
	    {
	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8;
	      ppc64_elf_section_data (sec)->t_symndx
		= (unsigned *) bfd_zalloc (abfd, amt);
	      if (ppc64_elf_section_data (sec)->t_symndx == NULL)
		return FALSE;
	    }
	  BFD_ASSERT (rel->r_offset % 8 == 0);
	  ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8] = r_symndx;
	  goto dodyn;

	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  if (info->shared)
	    {
	      info->flags |= DF_STATIC_TLS;
	      goto dodyn;
d2726 1
a2726 1
	      && ((enum elf_ppc64_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info)
d2740 1
a2740 1
	case R_PPC64_REL30:
a2741 1
	case R_PPC64_REL64:
d2756 1
a2786 1
	dodyn:
d2789 1
a2789 1
	       && (MUST_BE_DYN_RELOC (r_type)
d2887 1
a2887 1
	      if (!MUST_BE_DYN_RELOC (r_type))
d2915 1
a2915 1
      enum elf_ppc64_reloc_type r_type;
d2918 1
a2918 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d2943 1
a2943 1
		       || ppc64_elf_section_data (sec)->opd.func_sec == NULL)
d2961 1
a2961 1
      opd_sym_section = ppc64_elf_section_data (rsec)->opd.func_sec;
d2964 1
a2964 1
      else if (ppc64_elf_section_data (sec)->opd.func_sec != NULL)
d2977 1
a2977 1
     struct bfd_link_info *info;
a2980 1
  struct ppc_link_hash_table *htab;
d2983 1
a2983 1
  struct got_entry **local_got_ents;
a2987 1
  htab = ppc_hash_table (info);
d2990 1
a2990 1
  local_got_ents = elf_local_got_ents (abfd);
d2996 1
a2996 1
      enum elf_ppc64_reloc_type r_type;
a2997 1
      char tls_type = 0;
d3000 1
a3000 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
a3002 29
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount -= 1;
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD_LD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

d3009 11
a3019 21
	dogot:
	  {
	    struct got_entry *ent;

	    if (r_symndx >= symtab_hdr->sh_info)
	      {
		h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		ent = h->got.glist;
	      }
	    else
	      ent = local_got_ents[r_symndx];

	    for (; ent != NULL; ent = ent->next)
	      if (ent->addend == rel->r_addend
		  && ent->tls_type == tls_type)
		break;
	    if (ent == NULL)
	      abort ();
	    if (ent->got.refcount > 0)
	      ent->got.refcount -= 1;
	  }
d3027 8
a3040 2
	      struct plt_entry *ent;

d3042 2
a3043 7
	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend)
		  break;
	      if (ent == NULL)
		abort ();
	      if (ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
a3046 1
	case R_PPC64_REL30:
a3069 3
	case R_PPC64_DTPMOD64:
	case R_PPC64_DTPREL64:
	case R_PPC64_TPREL64:
d3084 1
a3127 1
  struct plt_entry *ent;
d3147 1
a3147 4
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.refcount > 0)
      break;
  if (ent != NULL
d3206 1
a3206 1
	      fdh->plt.plist = h->plt.plist;
a3377 4
      struct plt_entry *ent;
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.refcount > 0)
	  break;
d3379 1
a3379 1
	  || ent == NULL
d3385 1
a3385 1
	  h->plt.plist = NULL;
d3391 1
a3391 1
    h->plt.plist = NULL;
d3446 2
a3447 2
  /* We must generate a R_PPC64_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
a3539 133
static bfd_boolean
get_sym_h (hp, symp, symsecp, tlstypep, locsymsp, r_symndx, ibfd)
     struct elf_link_hash_entry **hp;
     Elf_Internal_Sym **symp;
     asection **symsecp;
     char **tlstypep;
     Elf_Internal_Sym **locsymsp;
     unsigned long r_symndx;
     bfd *ibfd;
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;

  if (r_symndx >= symtab_hdr->sh_info)
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (hp != NULL)
	*hp = h;

      if (symp != NULL)
	*symp = NULL;

      if (symsecp != NULL)
	{
	  asection *symsec = NULL;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    symsec = h->root.u.def.section;
	  *symsecp = symsec;
	}

      if (tlstypep != NULL)
	{
	  struct ppc_link_hash_entry *eh;

	  eh = (struct ppc_link_hash_entry *) h;
	  *tlstypep = &eh->tls_type;
	}
    }
  else
    {
      Elf_Internal_Sym *sym;
      Elf_Internal_Sym *locsyms = *locsymsp;

      if (locsyms == NULL)
	{
	  locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (locsyms == NULL)
	    locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
					    symtab_hdr->sh_info,
					    0, NULL, NULL, NULL);
	  if (locsyms == NULL)
	    return FALSE;
	  *locsymsp = locsyms;
	}
      sym = locsyms + r_symndx;

      if (hp != NULL)
	*hp = NULL;

      if (symp != NULL)
	*symp = sym;

      if (symsecp != NULL)
	{
	  asection *symsec = NULL;
	  if ((sym->st_shndx != SHN_UNDEF
	       && sym->st_shndx < SHN_LORESERVE)
	      || sym->st_shndx > SHN_HIRESERVE)
	    symsec = bfd_section_from_elf_index (ibfd, sym->st_shndx);
	  *symsecp = symsec;
	}

      if (tlstypep != NULL)
	{
	  struct got_entry **lgot_ents;
	  char *tlstype;

	  tlstype = NULL;
	  lgot_ents = elf_local_got_ents (ibfd);
	  if (lgot_ents != NULL)
	    {
	      char *lgot_types = (char *) (lgot_ents + symtab_hdr->sh_info);
	      tlstype = &lgot_types[r_symndx];
	    }
	  *tlstypep = tlstype;
	}
    }
  return TRUE;
}

static bfd_boolean
get_tls_type (tls_type, locsymsp, rel, ibfd)
     char **tls_type;
     Elf_Internal_Sym **locsymsp;
     const Elf_Internal_Rela *rel;
     bfd *ibfd;
{
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
  Elf_Internal_Sym *sym;
  asection *sec;
  bfd_vma off;

  r_symndx = ELF64_R_SYM (rel->r_info);
  if (!get_sym_h (&h, &sym, &sec, tls_type, locsymsp, r_symndx, ibfd))
    return FALSE;

  if ((*tls_type != NULL && **tls_type != 0)
      || sec == NULL
      || ppc64_elf_section_data (sec)->t_symndx == NULL)
    return TRUE;

  /* Look inside a TOC section too.  */
  if (h != NULL)
    {
      BFD_ASSERT (h->root.type == bfd_link_hash_defined);
      off = h->root.u.def.value;
    }
  else
    off = sym->st_value;
  off += rel->r_addend;
  BFD_ASSERT (off % 8 == 0);
  r_symndx = ppc64_elf_section_data (sec)->t_symndx[off / 8];
  return get_sym_h (&h, &sym, NULL, tls_type, locsymsp, r_symndx, ibfd);
}

d3546 1
d3548 3
a3550 1
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
d3567 1
a3567 1
      adjust = ppc64_elf_section_data (sec)->opd.adjust;
d3573 1
a3573 1
	  ppc64_elf_section_data (sec)->opd.adjust = adjust;
d3602 1
a3602 1
	  enum elf_ppc64_reloc_type r_type;
d3611 1
a3611 1
	  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d3626 1
a3626 1
	  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info);
d3645 31
a3675 3
	  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			  r_symndx, ibfd))
	    goto error_free_rel;
a3678 6
	      const char *sym_name;
	      if (h != NULL)
		sym_name = h->root.root.string;
	      else
		sym_name = bfd_elf_local_sym_name (ibfd, sym);

d3682 1
a3682 1
		 sym_name);
d3747 22
a3768 2
		  get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			     r_symndx, ibfd);
d3878 2
a3879 323
      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (!info->keep_memory)
	    free (local_syms);
	  else
	    symtab_hdr->contents = (unsigned char *) local_syms;
	}
    }

  return TRUE;
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  The linker has been hacked (see ppc64elf.em) to do
   a preliminary section layout so that we know the TLS segment
   offsets.  We can't optimize earlier because some optimizations need
   to know the tp offset, and we need to optimize before allocating
   dynamic relocations.  */

bfd_boolean
ppc64_elf_tls_optimize (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
{
  asection *tls;
  bfd *ibfd;
  asection *sec;
  struct ppc_link_hash_table *htab;

  if (info->relocateable)
    return TRUE;

  for (tls = obfd->sections; tls != NULL; tls = tls->next)
    if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
	== (SEC_THREAD_LOCAL | SEC_LOAD))
      break;
  if (tls == NULL)
    return TRUE;

  htab = ppc_hash_table (info);
  htab->tls_sec = tls;

  if (info->shared)
    return TRUE;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	  {
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;

	    /* Read the relocations.  */
	    relstart = _bfd_elf64_link_read_relocs (ibfd, sec, (PTR) NULL,
						    (Elf_Internal_Rela *) NULL,
						    info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;

	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc64_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h;
		Elf_Internal_Sym *sym;
		asection *sym_sec;
		char *tls_type;
		char tls_set, tls_clear, got_tls_type = 0;
		bfd_vma value;
		bfd_boolean ok_tprel;

		r_symndx = ELF64_R_SYM (rel->r_info);
		if (!get_sym_h (&h, &sym, &sym_sec, &tls_type, &locsyms,
				r_symndx, ibfd))
		  {
		  err_free_rel:
		    if (elf_section_data (sec)->relocs != relstart)
		      free (relstart);
		    if (locsyms != NULL
			&& (elf_tdata (ibfd)->symtab_hdr.contents
			    != (unsigned char *) locsyms))
		      free (locsyms);
		    return FALSE;
		  }

		if (h != NULL)
		  {
		    if (h->root.type != bfd_link_hash_defined
			&& h->root.type != bfd_link_hash_defweak)
		      continue;
		    value = h->root.u.def.value;
		  }
		else
		  value = sym->st_value;
		ok_tprel = FALSE;
		if (sym_sec != NULL && sym_sec->output_section != NULL)
		  {
		    value += sym_sec->output_offset;
		    value += sym_sec->output_section->vma;
		    value -= htab->tls_sec->vma;
		    ok_tprel = (value + TP_OFFSET + ((bfd_vma) 1 << 31)
				< (bfd_vma) 1 << 32);
		  }

		r_type
		  = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC64_GOT_TLSLD16:
		  case R_PPC64_GOT_TLSLD16_LO:
		  case R_PPC64_GOT_TLSLD16_HI:
		  case R_PPC64_GOT_TLSLD16_HA:
		    htab->tlsld_got.refcount -= 1;
		    if (ok_tprel)
		      /* LD -> LE */
		      tls_set = 0;
		    else
		      /* We still need a GOT entry as the offset is
			 too big.  ie. LD -> IE.  */
		      tls_set = TLS_TLS | TLS_TPREL;
		    tls_clear = TLS_GD_LD;
		    got_tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC64_GOT_TLSGD16:
		  case R_PPC64_GOT_TLSGD16_LO:
		  case R_PPC64_GOT_TLSGD16_HI:
		  case R_PPC64_GOT_TLSGD16_HA:
		    if (ok_tprel
			&& (h == NULL
			    || ((h->elf_link_hash_flags
				 & ELF_LINK_HASH_DEF_REGULAR) != 0
				&& ((h->elf_link_hash_flags
				     & ELF_LINK_FORCED_LOCAL) != 0
				    || !info->shared
				    || info->symbolic))))
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPREL;
		    tls_clear = TLS_GD_LD;
		    got_tls_type = TLS_TLS | TLS_GD_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC64_GOT_TPREL16_DS:
		  case R_PPC64_GOT_TPREL16_LO_DS:
		  case R_PPC64_GOT_TPREL16_HI:
		  case R_PPC64_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			got_tls_type = TLS_TLS | TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC64_REL14:
		  case R_PPC64_REL14_BRTAKEN:
		  case R_PPC64_REL14_BRNTAKEN:
		  case R_PPC64_REL24:
		    if (h != NULL
			&& h == htab->tls_get_addr)
		      {
			if (!expecting_tls_get_addr
			    && rel != relstart
			    && ((ELF64_R_TYPE (rel[-1].r_info)
				 == R_PPC64_TOC16)
				|| (ELF64_R_TYPE (rel[-1].r_info)
				    == R_PPC64_TOC16_LO)))
			  {
			    /* Check for toc tls entries.  */
			    char *toc_tls;

			    if (!get_tls_type (&toc_tls, &locsyms,
					       rel - 1, ibfd))
			      goto err_free_rel;
			    if (toc_tls != NULL)
			      expecting_tls_get_addr = *toc_tls != 0;
			  }

			if (expecting_tls_get_addr)
			  {
			    struct plt_entry *ent;
			    for (ent = h->plt.plist; ent; ent = ent->next)
			      if (ent->addend == 0)
				{
				  if (ent->plt.refcount > 0)
				    ent->plt.refcount -= 1;
				  break;
				}
			  }
		      }
		    expecting_tls_get_addr = 0;
		    continue;

		  case R_PPC64_TPREL64:
		    expecting_tls_get_addr = 0;
		    if (ok_tprel)
		      {
			/* IE -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC64_DTPMOD64:
		    expecting_tls_get_addr = 0;
		    if ((*tls_type & TLS_LD) == 0)
		      {
			if ((h == NULL
			     || ((h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_REGULAR) != 0
				 && ((h->elf_link_hash_flags
				      & ELF_LINK_FORCED_LOCAL) != 0
				     || !info->shared
				     || info->symbolic)))
			    && ok_tprel)
			  /* GD -> LE */
			  tls_set = TLS_EXPLICIT;
			else
			  /* GD -> IE */
			  tls_set = TLS_EXPLICIT | TLS_TPREL;
			tls_clear = TLS_GD_LD;
		      }
		    else
		      {
			if (ok_tprel)
			  /* LD -> LE */
			  tls_set = TLS_EXPLICIT;
			else
			  /* LD -> IE */
			  tls_set = TLS_EXPLICIT | TLS_TPREL;
			tls_clear = TLS_GD_LD;
		      }
		    break;

		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }

		if ((tls_set & TLS_EXPLICIT) == 0)
		  {
		    struct got_entry *ent;

		    /* Adjust got entry for this reloc.  */
		    if (h != NULL)
		      ent = h->got.glist;
		    else
		      ent = elf_local_got_ents (ibfd)[r_symndx];

		    for (; ent != NULL; ent = ent->next)
		      if (ent->addend == rel->r_addend
			  && ent->tls_type == got_tls_type)
			break;
		    if (ent == NULL)
		      abort ();

		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (ent->got.refcount > 0)
			  ent->got.refcount -= 1;
		      }
		    else
		      ent->tls_type = tls_set;
		  }
		else if (h != NULL)
		  {
		    struct ppc_link_hash_entry * eh;
		    struct ppc_dyn_relocs **pp;
		    struct ppc_dyn_relocs *p;

		    /* Adjust dynamic relocs.  */
		    eh = (struct ppc_link_hash_entry *) h;
		    for (pp = &eh->dyn_relocs;
			 (p = *pp) != NULL;
			 pp = &p->next)
		      if (p->sec == sec)
			{
			  /* If we got rid of a DTPMOD/DTPREL reloc
			     pair then we'll lose one or two dyn
			     relocs.  */
			  if (tls_clear == TLS_GD_LD
			      && rel + 1 < relend
			      && (rel[1].r_info
				  == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			      && rel[1].r_offset == rel->r_offset + 8)
			    p->count -= 1;
			  if (tls_set == TLS_EXPLICIT)
			    p->count -= 1;
			  if (p->count == 0)
			    *pp = p->next;
			  break;
			}
		  }

		*tls_type |= tls_set;
		*tls_type &= ~tls_clear;
	      }

	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
	  }

      if (locsyms != NULL
	  && (elf_tdata (ibfd)->symtab_hdr.contents
	      != (unsigned char *) locsyms))
d3882 1
a3882 1
	    free (locsyms);
d3884 1
a3884 1
	    elf_tdata (ibfd)->symtab_hdr.contents = (unsigned char *) locsyms;
d3887 1
a3914 1
  struct got_entry *gent;
d3926 2
a3927 2
      && h->dynindx != -1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d3929 14
a3942 6
      struct plt_entry *pent;
      bfd_boolean doneone = FALSE;
      for (pent = h->plt.plist; pent != NULL; pent = pent->next)
	if (pent->plt.refcount > 0)
	  {
	    BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);
d3944 14
a3957 28
	    /* If this is the first .plt entry, make room for the special
	       first entry.  */
	    s = htab->splt;
	    if (s->_raw_size == 0)
	      s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

	    pent->plt.offset = s->_raw_size;

	    /* Make room for this entry.  */
	    s->_raw_size += PLT_ENTRY_SIZE;

	    /* Make room for the .glink code.  */
	    s = htab->sglink;
	    if (s->_raw_size == 0)
	      s->_raw_size += GLINK_CALL_STUB_SIZE;
	    /* We need bigger stubs past index 32767.  */
	    if (s->_raw_size >= GLINK_CALL_STUB_SIZE + 32768*2*4)
	      s->_raw_size += 4;
	    s->_raw_size += 2*4;

	    /* We also need to make an entry in the .rela.plt section.  */
	    s = htab->srelplt;
	    s->_raw_size += sizeof (Elf64_External_Rela);
	    doneone = TRUE;
	  }
	else
	  pent->plt.offset = (bfd_vma) -1;
      if (!doneone)
d3959 1
a3959 1
	  h->plt.plist = NULL;
d3965 1
a3965 1
      h->plt.plist = NULL;
d3969 3
a3971 11
  for (gent = h->got.glist; gent != NULL; gent = gent->next)
    if (gent->got.refcount > 0)
      {
	/* Make sure this symbol is output as a dynamic symbol.
	   Undefined weak syms won't yet be marked as dynamic.  */
	if (h->dynindx == -1
	    && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	  {
	    if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	      return FALSE;
	  }
d3973 8
a3980 5
	if ((gent->tls_type & TLS_LD) != 0)
	  gent->got.offset = htab->tlsld_got.offset;
	else
	  {
	    bfd_boolean dyn;
d3982 9
a3990 13
	    s = htab->sgot;
	    gent->got.offset = s->_raw_size;
	    s->_raw_size += (gent->tls_type & TLS_GD_LD) != 0 ? 16 : 8;
	    dyn = htab->elf.dynamic_sections_created;
	    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	      htab->srelgot->_raw_size
		+= ((gent->tls_type & TLS_GD_LD) != 0
		    ? 2 * sizeof (Elf64_External_Rela)
		    : sizeof (Elf64_External_Rela));
	  }
      }
    else
      gent->got.offset = (bfd_vma) -1;
a4125 10
  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 16;
      if (info->shared)
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tlsld_got.offset = (bfd_vma) -1;

d4130 2
a4131 2
      struct got_entry **lgot_ents;
      struct got_entry **end_lgot_ents;
d4166 2
a4167 2
      lgot_ents = elf_local_got_ents (ibfd);
      if (!lgot_ents)
d4172 1
a4172 1
      end_lgot_ents = lgot_ents + locsymcount;
d4175 1
a4175 1
      for (; lgot_ents < end_lgot_ents; ++lgot_ents)
d4177 9
a4185 35
	  struct got_entry *ent;

	  for (ent = *lgot_ents; ent != NULL; ent = ent->next)
	    if (ent->got.refcount > 0)
	      {
		if ((ent->tls_type & TLS_LD) != 0)
		  {
		    if (htab->tlsld_got.offset == (bfd_vma) -1)
		      {
			htab->tlsld_got.offset = s->_raw_size;
			s->_raw_size += 16;
			if (info->shared)
			  srel->_raw_size += sizeof (Elf64_External_Rela);
		      }
		    ent->got.offset = htab->tlsld_got.offset;
		  }
		else
		  {
		    ent->got.offset = s->_raw_size;
		    if ((ent->tls_type & TLS_GD_LD) != 0)
		      {
			s->_raw_size += 16;
			if (info->shared)
			  srel->_raw_size += 2 * sizeof (Elf64_External_Rela);
		      }
		    else
		      {
			s->_raw_size += 8;
			if (info->shared)
			  srel->_raw_size += sizeof (Elf64_External_Rela);
		      }
		  }
	      }
	    else
	      ent->got.offset = (bfd_vma) -1;
a4200 4
      /* Reset _cooked_size since prelim layout will set it wrongly,
	 and a non-zero _cooked_size sticks.  */
      s->_cooked_size = 0;

d4254 2
a4255 4
	 but this way if it does we get a R_PPC64_NONE reloc in .rela
	 sections instead of garbage.
	 We also rely on the section contents being zero when writing
	 the GOT.  */
d4337 1
d4340 2
a4341 8
	  struct plt_entry *ent;
	  for (ent = h->oh->plt.plist; ent != NULL; ent = ent->next)
	    if (ent->addend == rel->r_addend
		&& ent->plt.offset != (bfd_vma) -1)
	      {
		*hash = (struct ppc_link_hash_entry *) h->oh;
		return ppc_stub_plt_call;
	      }
a4415 1
  struct plt_entry *ent;
d4527 1
a4527 7
      off = (bfd_vma) -1;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    off = ent->plt.offset;
	    break;
	  }
d4580 1
a4580 9
      struct plt_entry *ent;
      for (ent = stub_entry->h->elf.plt.plist; ent != NULL; ent = ent->next)
	if (ent->addend == stub_entry->addend)
	  {
	    off = ent->plt.offset & ~(bfd_vma) 1;
	    break;
	  }
      if (ent == NULL)
	abort ();
a4910 2
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;
d4917 1
a4917 1
		  if (r_type >= (unsigned int) R_PPC64_max)
d4932 2
d4935 2
a4936 6
		  if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
				  r_indx, input_bfd))
		    goto error_ret_free_internal;
		  hash = (struct ppc_link_hash_entry *) h;

		  if (hash == NULL)
d4939 20
a4958 1
		      sym_value = sym->st_value;
d4966 11
a4976 1
		      sym_value = 0;
d4980 1
a5003 18
		  /* __tls_get_addr calls might be eliminated.  */
		  if (stub_type != ppc_stub_plt_call
		      && hash != NULL
		      && &hash->elf == htab->tls_get_addr
		      && section->has_tls_reloc
		      && irela != internal_relocs)
		    {
		      /* Get tls info.  */
		      char *tls_type;

		      if (!get_tls_type (&tls_type, &local_syms,
					 irela - 1, input_bfd))
			goto error_ret_free_internal;
		      if (tls_type != NULL
			  && (*tls_type & (TLS_TLS | TLS_GD_LD)) == TLS_TLS)
			continue;
		    }

a5039 1
		  stub_entry->addend = irela->r_addend;
d5290 1
a5290 4
  Elf_Internal_Rela outrel;
  bfd_byte *loc;
  unsigned int tls_get_addr_type;
  struct got_entry **local_got_ents;
d5305 1
a5305 15
  if (info->shared && (htab->tlsld_got.offset & 1) == 0)
    {
      outrel.r_offset = (htab->sgot->output_section->vma
			 + htab->sgot->output_offset
			 + htab->tlsld_got.offset);
      outrel.r_info = ELF64_R_INFO (0, R_PPC64_DTPMOD64);
      outrel.r_addend = 0;

      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
      htab->tlsld_got.offset |= 1;
    }

  local_got_ents = elf_local_got_ents (input_bfd);
d5309 1
a5309 1
  is_opd = ppc64_elf_section_data (input_section)->opd.adjust != NULL;
a5310 1
  tls_get_addr_type = 0;
d5315 2
a5316 1
      enum elf_ppc64_reloc_type r_type;
a5324 1
      char tls_type;
d5333 1
a5333 1
      r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel->r_info);
d5335 2
d5355 2
a5356 1
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
d5358 3
d5365 1
a5365 1
	      opd_sym_adjust = ppc64_elf_section_data (sec)->opd.adjust;
d5405 3
a5407 3
		      rel->r_offset, (!info->shared
				      || info->no_undefined
				      || ELF_ST_VISIBILITY (h->other)))))
d5413 1
a5413 261
      /* TLS optimizations.  */
      tls_type = 0;
      if (IS_TLS_RELOC (r_type))
	{
	  if (h != NULL)
	    tls_type = ((struct ppc_link_hash_entry *) h)->tls_type;
	  else if (local_got_ents != NULL)
	    {
	      char *lgot_types;
	      lgot_types = (char *) (local_got_ents + symtab_hdr->sh_info);
	      tls_type = lgot_types[r_symndx];
	    }
	}

      /* Ensure reloc mapping code below stays sane.  */
      if (R_PPC64_TOC16_LO_DS != R_PPC64_TOC16_DS + 1
	  || R_PPC64_TOC16_LO != R_PPC64_TOC16 + 1
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TLSGD16 & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TLSGD16_LO & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TLSGD16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TLSGD16_HA & 3)
	  || (R_PPC64_GOT_TLSLD16 & 3)    != (R_PPC64_GOT_TPREL16_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_LO & 3) != (R_PPC64_GOT_TPREL16_LO_DS & 3)
	  || (R_PPC64_GOT_TLSLD16_HI & 3) != (R_PPC64_GOT_TPREL16_HI & 3)
	  || (R_PPC64_GOT_TLSLD16_HA & 3) != (R_PPC64_GOT_TPREL16_HA & 3))
	abort ();
      switch (r_type)
	{
	default:
	  tls_get_addr_type = 0;
	  break;

	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	  tls_get_addr_type = 0;
	  {
	    /* Check for toc tls entries.  */
	    char *toc_tls;

	    if (!get_tls_type (&toc_tls, &local_syms, rel, input_bfd))
	      return FALSE;

	    if (toc_tls)
	      {
		tls_type = *toc_tls;
		if (r_type == R_PPC64_TOC16_DS
		    || r_type == R_PPC64_TOC16_LO_DS)
		  goto toctprel;
		else
		  tls_get_addr_type = tls_type;
	      }
	  }
	  break;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	  tls_get_addr_type = 0;
	toctprel:
	  if (tls_type != 0
	      && (tls_type & TLS_TPREL) == 0)
	    {
	      bfd_vma insn;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
	      insn &= 31 << 21;
	      insn |= 0x3c0d0000;	/* addis 0,13,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
	      r_type = R_PPC64_TPREL16_HA;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC64_TLS:
	  tls_get_addr_type = 0;
	  if (tls_type == 0)
	    {
	      /* Check for toc tls entries.  */
	      char *toc_tls;

	      if (!get_tls_type (&toc_tls, &local_syms, rel, input_bfd))
		return FALSE;

	      if (toc_tls)
		tls_type = *toc_tls;
	    }
	  if (tls_type != 0
	      && (tls_type & TLS_TPREL) == 0)
	    {
	      bfd_vma insn, rtra;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      if ((insn & ((31 << 26) | (31 << 11)))
		  == ((31 << 26) | (13 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((31 << 26) | (31 << 16)))
		       == ((31 << 26) | (13 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
		abort ();
	      insn |= rtra;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      r_type = R_PPC64_TPREL16_LO;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	      /* Was PPC64_TLS which sits on insn boundary, now
		 PPC64_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
	    }
	  break;

	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_get_addr_type = 0;
	  if (tls_type != 0 && (tls_type & TLS_GD_LD) == 0)
	    {
	      if (r_type == R_PPC64_GOT_TLSGD16_HI
		  || r_type == R_PPC64_GOT_TLSGD16_HA
		  || r_type == R_PPC64_GOT_TLSLD16_HI
		  || r_type == R_PPC64_GOT_TLSLD16_HA)
		{
		  if ((tls_type & TLS_LD) != 0)
		    {
		      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		      r_type = R_PPC64_NONE;
		      rel->r_offset -= 2;
		    }
		  else
		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			      + R_PPC64_GOT_TPREL16_DS);
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		  break;
		}

	      /* This reloc and its instruction will be replaced so there's
		 not much point in doing anything more here.  We know the
		 next reloc will be a REL24 to __tls_get_addr, and will
		 be handled below.  */
	      tls_get_addr_type = tls_type;
	      continue;
	    }
	  break;

	case R_PPC64_REL14:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL24:
	  if (h != NULL
	      && h == htab->tls_get_addr
	      && tls_get_addr_type != 0
	      && (tls_get_addr_type & TLS_GD_LD) == 0)
	    {
	      /* Replace the call.  */
	      bfd_vma insn1, insn2, insn3;
	      bfd_vma offset = rel->r_offset;

	      insn1 = bfd_get_32 (output_bfd, contents + rel[-1].r_offset - 2);
	      insn3 = bfd_get_32 (output_bfd, contents + offset + 4);
	      if (tls_get_addr_type & TLS_TPREL)
		{
		  /* IE */
		  insn1 &= (1 << 26) - (1 << 2);
		  insn1 |= 58 << 26;	/* ld */
		  insn2 = 0x7c636a14;	/* add 3,3,13 */
		  /* Fix the relocs for --emit-relocs.  */
		  r_type = ELF64_R_TYPE (rel[-1].r_info);
		  if (tls_get_addr_type & TLS_EXPLICIT)
		    r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
		  else
		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			      + R_PPC64_GOT_TPREL16_DS);
		  rel[-1].r_info
		    = ELF64_R_INFO (ELF64_R_SYM (rel[-1].r_info), r_type);
		  rel->r_info = 0;
		}
	      else
		{
		  /* LE */
		  insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		  insn2 = 0x38630000;	/* addi 3,3,0 */
		  if (tls_get_addr_type & TLS_LD)
		    {
		      r_symndx = 0;
		      rel[-1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
		      rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
		    }
		  else
		    r_symndx = ELF64_R_SYM (rel[-1].r_info);
		  rel[-1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_HA);
		  rel->r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_LO);
		  rel->r_offset += 2;
		}
	      if (insn3 == NOP
		  || insn3 == CROR_151515 || insn3 == CROR_313131)
		{
		  insn3 = insn2;
		  insn2 = NOP;
		  rel->r_offset += 4;
		}
	      bfd_put_32 (output_bfd, insn1, contents + rel[-1].r_offset - 2);
	      bfd_put_32 (output_bfd, insn2, contents + offset);
	      bfd_put_32 (output_bfd, insn3, contents + offset + 4);
	      /* Do the relocs again.  */
	      rel -= 2;
	      tls_get_addr_type = 0;
	      continue;
	    }
	  tls_get_addr_type = 0;
	  break;

	case R_PPC64_DTPMOD64:
	  if ((tls_type & TLS_GD_LD) == 0)
	    {
	      if ((tls_type & TLS_TPREL) != 0)
		r_type = R_PPC64_TPREL64;
	      else
		{
		  bfd_put_64 (output_bfd, (bfd_vma) 1,
			      contents + rel->r_offset);
		  r_type = R_PPC64_NONE;
		}
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	      if ((tls_type & TLS_LD) == 0)
		rel[1].r_info = 0;
	    }
	  break;

	case R_PPC64_TPREL64:
	  if ((tls_type & TLS_TPREL) == 0)
	    {
	      r_type = R_PPC64_NONE;
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
	    }
	  break;
	}

      /* Handle other relocations that tweak non-addend part of insn.  */
d5429 1
a5429 2
	  insn |= bfd_get_32 (output_bfd,
			      contents + rel->r_offset) & ~(0x01 << 21);
d5444 1
a5444 1
	      from = (rel->r_offset
d5449 1
a5449 1
	      if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
d5453 1
a5453 1
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + rel->r_offset);
d5464 1
a5464 1
	      && fdh->plt.plist != NULL
d5470 1
a5470 1
	      if (rel->r_offset + 8 <= input_section->_cooked_size)
d5472 1
a5472 1
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset + 4);
d5477 1
a5477 1
				  contents + rel->r_offset + 4);
d5486 1
a5486 1
		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
d5496 1
d5504 1
a5504 1
	      && rel->r_addend == 0)
d5514 1
a5514 1
	      from = (rel->r_offset
a5527 2
      tls_type = 0;
      addend = rel->r_addend;
d5540 2
a5541 3
	case R_PPC64_TLS:
	case R_PPC64_GNU_VTINHERIT:
	case R_PPC64_GNU_VTENTRY:
d5546 1
a5546 1
	     symbol's value itself.  Also, create a GOT entry for the
a5547 28
	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	case R_PPC64_GOT_TLSGD16_HI:
	case R_PPC64_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD_LD;
	  goto dogot;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	case R_PPC64_GOT_TLSLD16_HI:
	case R_PPC64_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
	  goto dogot;

	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_TPREL16_HI:
	case R_PPC64_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_HI:
	case R_PPC64_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

a5553 1
	dogot:
a5556 1
	    struct got_entry *ent;
a5557 1
	    unsigned long indx;
a5562 2
	      ent = h->got.glist;
	    else
d5564 1
a5564 11
		if (local_got_ents == NULL)
		  abort ();
		ent = local_got_ents[r_symndx];
	      }

	    for (; ent != NULL; ent = ent->next)
	      if (ent->addend == rel->r_addend
		  && ent->tls_type == tls_type)
		break;
	    if (ent == NULL)
	      abort ();
d5566 2
a5567 5
	    off = ent->got.offset;
	    indx = 0;
	    if (h != NULL)
	      {
		bfd_boolean dyn = htab->elf.dynamic_sections_created;
a5575 6
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  */
		  ;
		else
d5577 20
a5596 2
		    indx = h->dynindx;
		    unresolved_reloc = FALSE;
d5598 2
a5600 6

	    /* The offset must always be a multiple of 8.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    if ((off & 1) != 0)
	      off &= ~1;
d5603 11
a5613 5
		/* Generate relocs for the dynamic linker, except in
		   the case of TLSLD where we'll use one entry per
		   module.  */
		if ((info->shared || indx != 0)
		    && ent->tls_type != (TLS_TLS | TLS_GD_LD | TLS_LD))
d5615 4
a5618 4
		    outrel.r_offset = (htab->sgot->output_section->vma
				       + htab->sgot->output_offset
				       + off);
		    if (ent->tls_type == (TLS_TLS | TLS_GD_LD))
d5620 10
a5629 2
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
			outrel.r_addend = 0;
a5633 31
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
			outrel.r_offset += 8;
		      }
		    else if (ent->tls_type == (TLS_TLS | TLS_DTPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
		    else if (ent->tls_type == (TLS_TLS | TLS_TPREL))
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_TPREL64);
		    else if (indx == 0)
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);
		    else
		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_GLOB_DAT);
		    outrel.r_addend = ent->addend;
		    if (indx == 0)
		      outrel.r_addend += relocation;
		    loc = htab->srelgot->contents;
		    loc += (htab->srelgot->reloc_count++
			    * sizeof (Elf64_External_Rela));
		    bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		  }

		/* Init the .got section contents if we're not
		   emitting a reloc.  */
		if (!(info->shared || indx != 0))
		  {

		    relocation += ent->addend;
		    if ((tls_type & TLS_TLS) != 0)
		      {
			relocation -= htab->tls_sec->vma + DTP_OFFSET;
			if ((tls_type & TLS_TPREL) != 0)
			  relocation += DTP_OFFSET - TP_OFFSET;
d5636 1
a5636 10
		    if ((tls_type & TLS_GD_LD) != 0)
		      {
			if ((tls_type & TLS_LD) != 0)
			  relocation = - DTP_OFFSET;
			bfd_put_64 (output_bfd, relocation,
				    htab->sgot->contents + off + 8);
			relocation = 1;
		      }
		    bfd_put_64 (output_bfd, relocation,
				htab->sgot->contents + off);
a5637 1
		ent->got.offset |= 1;
d5646 1
a5646 1
	    addend = - TOC_BASE_OFF;
d5663 7
a5669 16
	  /* It's possible that we didn't make a PLT entry for this
	     symbol.  This happens when statically linking PIC code,
	     or when using -Bsymbolic.  Go find a match if there is a
	     PLT entry.  */
	  if (htab->splt != NULL)
	    {
	      struct plt_entry *ent;
	      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
		if (ent->addend == rel->r_addend
		    && ent->plt.offset != (bfd_vma) -1)
		  {
		    relocation = (htab->splt->output_section->vma
				  + htab->splt->output_offset
				  + ent->plt.offset);
		    unresolved_reloc = FALSE;
		  }
d5671 5
a5707 39
	case R_PPC64_TPREL16:
	case R_PPC64_TPREL16_LO:
	case R_PPC64_TPREL16_HI:
	case R_PPC64_TPREL16_HA:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	  addend -= htab->tls_sec->vma + TP_OFFSET;
	  if (info->shared)
	    /* The TPREL16 relocs shouldn't really be used in shared
	       libs as they will result in DT_TEXTREL being set, but
	       support them anyway.  */
	    goto dodyn;
	  break;

	case R_PPC64_DTPREL16:
	case R_PPC64_DTPREL16_LO:
	case R_PPC64_DTPREL16_HI:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
	  break;

	case R_PPC64_TPREL64:
	  addend -= htab->tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC64_DTPREL64:
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
	  /* Fall thru */

a5709 2
	case R_PPC64_DTPMOD64:
	case R_PPC64_REL30:
d5726 1
a5734 1
	dodyn:
d5747 1
a5747 1
	       && (MUST_BE_DYN_RELOC (r_type)
d5785 1
a5785 1
	      outrel.r_addend = rel->r_addend;
d5792 1
a5792 1
		       && (!MUST_BE_DYN_RELOC (r_type)
a5803 1
		  /* ??? why? */
a5905 2
	case R_PPC64_GOT16_HA:
	case R_PPC64_PLTGOT16_HA:
a5908 14
	case R_PPC64_TPREL16_HA:
	case R_PPC64_DTPREL16_HA:
	case R_PPC64_GOT_TLSGD16_HA:
	case R_PPC64_GOT_TLSLD16_HA:
	case R_PPC64_GOT_TPREL16_HA:
	case R_PPC64_GOT_DTPREL16_HA:
	case R_PPC64_TPREL16_HIGHER:
	case R_PPC64_TPREL16_HIGHERA:
	case R_PPC64_TPREL16_HIGHEST:
	case R_PPC64_TPREL16_HIGHESTA:
	case R_PPC64_DTPREL16_HIGHER:
	case R_PPC64_DTPREL16_HIGHERA:
	case R_PPC64_DTPREL16_HIGHEST:
	case R_PPC64_DTPREL16_HIGHESTA:
a5928 8
	case R_PPC64_GOT_TPREL16_DS:
	case R_PPC64_GOT_TPREL16_LO_DS:
	case R_PPC64_GOT_DTPREL16_DS:
	case R_PPC64_GOT_DTPREL16_LO_DS:
	case R_PPC64_TPREL16_DS:
	case R_PPC64_TPREL16_LO_DS:
	case R_PPC64_DTPREL16_DS:
	case R_PPC64_DTPREL16_LO_DS:
d5953 1
a5953 1
	  from = (rel->r_offset
d5990 1
a5990 1
				    rel->r_offset,
d6016 3
a6018 1
	      name = bfd_elf_local_sym_name (input_bfd, sym);
d6021 2
d6031 1
a6031 1
		     rel->r_addend, input_bfd, input_section, rel->r_offset)))
d6065 30
a6094 1
  if (((struct ppc_link_hash_entry *) h)->is_func_descriptor)
a6095 1
      struct plt_entry *ent;
d6099 2
a6100 5
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.offset != (bfd_vma) -1)
	  {
	    /* This symbol has an entry in the procedure linkage
	       table.  Set it up.  */
d6102 2
a6103 4
	    if (htab->splt == NULL
		|| htab->srelplt == NULL
		|| htab->sglink == NULL)
	      abort ();
d6105 29
a6133 2
	    /* Create a JMP_SLOT reloc to inform the dynamic linker to
	       fill in the PLT entry.  */
d6135 3
a6137 11
	    rela.r_offset = (htab->splt->output_section->vma
			     + htab->splt->output_offset
			     + ent->plt.offset);
	    rela.r_info = ELF64_R_INFO (h->dynindx, R_PPC64_JMP_SLOT);
	    rela.r_addend = ent->addend;

	    loc = htab->srelplt->contents;
	    loc += ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		    * sizeof (Elf64_External_Rela));
	    bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
	  }
d6177 1
a6177 1
  enum elf_ppc64_reloc_type r_type;
d6179 1
a6179 1
  r_type = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rela->r_info);
a6339 1
#define bfd_elf64_new_section_hook	      ppc64_elf_new_section_hook
@


1.63.10.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a2505 1
  /* The symbol addend that we'll be placing in the GOT.  */
a2507 1
  /* Reference count until size_dynamic_sections, GOT offset thereafter.  */
a2513 2
  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
d2532 1
a2532 2
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */
a2538 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d2636 8
a2643 15
     TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.
     tls_optimize may also set TLS_TPRELGD when a GD reloc turns into
     a TPREL one.  We use a separate flag rather than setting TPREL
     just for convenience in distinguishing the two cases.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_EXPLICIT	32	/* Marks TOC section TLS relocs. */
#define TLS_TPRELGD	64	/* TPREL reloc resulting from GD->IE. */
  char tls_mask;
d2770 1
a2770 1
static int get_tls_mask
d2912 1
a2912 1
      eh->tls_mask = 0;
a2959 1
  htab->tls_get_addr = NULL;
a2965 5
  /* Initializing two fields of the union is just cosmetic.  We really
     only care about glist, but when compiled on a 32-bit host the
     bfd_vma fields are larger.  Setting the bfd_vma to zero makes
     debugger inspection of these fields look nicer.  */
  htab->elf.init_refcount.refcount = 0;
a2966 1
  htab->elf.init_offset.offset = 0;
a3291 1
  edir->tls_mask |= eind->tls_mask;
d3407 1
a3407 1
  char *local_got_tls_masks;
d3413 1
a3413 1
      size *= sizeof (*local_got_ents) + sizeof (*local_got_tls_masks);
d3442 2
a3443 2
  local_got_tls_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
d3559 1
a3559 1
	  tls_type = TLS_TLS | TLS_LD;
d3566 1
a3566 1
	  tls_type = TLS_TLS | TLS_GD;
d3621 1
a3621 1
	      eh->tls_mask |= tls_type;
d3712 1
a3712 4
	      else if ((strncmp (h->root.root.string, ".__tls_get_addr", 15)
			== 0)
		       && (h->root.root.string[15] == 0
			   || h->root.root.string[15] == '@@'))
d3730 1
a3730 1
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD;
d3732 1
a3732 1
	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_LD;
d3750 1
a3750 1
	      eh->tls_mask |= tls_type;
d3759 1
a3759 2
	      /* One extra to simplify get_tls_mask.  */
	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8 + 1;
a3766 7

	  /* Mark the second slot of a GD or LD entry.
	     -1 to indicate GD and -2 to indicate LD.  */
	  if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_GD))
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -1;
	  else if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_LD))
	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -2;
a3846 4
	  /* Don't propagate relocs that the dynamic linker won't relocate.  */
	  if ((sec->flags & SEC_ALLOC) == 0)
	    break;

d3859 1
a3859 1
	     storing information in the dyn_relocs field of the hash
d3870 1
d3877 2
a3878 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d4081 1
a4081 1
      struct elf_link_hash_entry *h = NULL;
a4085 18
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_link_hash_entry *eh;
	  struct ppc_dyn_relocs **pp;
	  struct ppc_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct ppc_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

d4093 1
a4093 1
	  tls_type = TLS_TLS | TLS_LD;
d4100 1
a4100 1
	  tls_type = TLS_TLS | TLS_GD;
d4127 5
a4131 2
	    if (h != NULL)
	      ent = h->got.glist;
d4155 1
a4155 1
	  if (h != NULL)
d4159 1
d4170 67
d4495 2
d4554 2
a4555 1
  if (ELIMINATE_COPY_RELOCS)
d4557 4
a4560 2
      struct ppc_link_hash_entry * eh;
      struct ppc_dyn_relocs *p;
d4562 6
a4567 15
      eh = (struct ppc_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d4675 1
a4675 1
get_sym_h (hp, symp, symsecp, tls_maskp, locsymsp, r_symndx, ibfd)
d4679 1
a4679 1
     char **tls_maskp;
d4711 1
a4711 1
      if (tls_maskp != NULL)
d4716 1
a4716 1
	  *tls_maskp = &eh->tls_mask;
d4753 1
a4753 1
      if (tls_maskp != NULL)
d4756 1
a4756 1
	  char *tls_mask;
d4758 1
a4758 1
	  tls_mask = NULL;
d4762 2
a4763 2
	      char *lgot_masks = (char *) (lgot_ents + symtab_hdr->sh_info);
	      tls_mask = &lgot_masks[r_symndx];
d4765 1
a4765 1
	  *tls_maskp = tls_mask;
d4771 3
a4773 7
/* Returns TLS_MASKP for the given REL symbol.  Function return is 0 on
   error, 2 on a toc GD type suitable for optimization, 3 on a toc LD
   type suitable for optimization, and 1 otherwise.  */  

static int
get_tls_mask (tls_maskp, locsymsp, rel, ibfd)
     char **tls_maskp;
a4778 1
  unsigned int next_r;
d4785 2
a4786 2
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;
d4788 1
a4788 1
  if ((*tls_maskp != NULL && **tls_maskp != 0)
d4791 1
a4791 1
    return 1;
d4804 1
a4804 15
  next_r = ppc64_elf_section_data (sec)->t_symndx[off / 8 + 1];
  if (!get_sym_h (&h, &sym, &sec, tls_maskp, locsymsp, r_symndx, ibfd))
    return 0;
  if (h == NULL
      || h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      if (next_r == (unsigned) -1)
	return 2;
      if (next_r == (unsigned) -2
	  && (h == NULL
	      || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	return 3;
    }
  return 1;
d5113 6
a5118 1
/* Set htab->tls_sec.  */
d5121 1
a5121 1
ppc64_elf_tls_setup (obfd, info)
d5126 2
d5130 3
d5137 2
d5143 1
a5143 31
  if (htab->tls_get_addr != NULL)
    {
      struct elf_link_hash_entry *h = htab->tls_get_addr;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      htab->tls_get_addr = h;
    }

  return tls != NULL;
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  The linker has been hacked (see ppc64elf.em) to do
   a preliminary section layout so that we know the TLS segment
   offsets.  We can't optimize earlier because some optimizations need
   to know the tp offset, and we need to optimize before allocating
   dynamic relocations.  */

bfd_boolean
ppc64_elf_tls_optimize (obfd, info)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *ibfd;
  asection *sec;
  struct ppc_link_hash_table *htab;

  if (info->relocateable || info->shared)
a5145 1
  htab = ppc_hash_table (info);
d5172 2
a5173 2
		char *tls_mask;
		char tls_set, tls_clear, tls_type = 0;
d5175 1
a5175 1
		bfd_boolean ok_tprel, is_local;
d5178 1
a5178 1
		if (!get_sym_h (&h, &sym, &sym_sec, &tls_mask, &locsyms,
a5199 1

d5201 1
a5201 3
		is_local = FALSE;
		if (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
a5202 1
		    is_local = TRUE;
a5217 3
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
d5219 9
a5227 7
		    if (!is_local)
		      continue;

		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    tls_type = TLS_TLS | TLS_LD;
d5235 8
a5242 1
		    if (ok_tprel)
d5247 3
a5249 3
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    tls_type = TLS_TLS | TLS_GD;
d5263 1
a5263 1
			tls_type = TLS_TLS | TLS_TPREL;
a5284 1
			    int retval;
d5286 2
a5287 3
			    retval = get_tls_mask (&toc_tls, &locsyms,
						   rel - 1, ibfd);
			    if (retval == 0)
d5290 1
a5290 1
			      expecting_tls_get_addr = retval > 1;
d5322 1
a5322 4
		    if (rel + 1 < relend
			&& (rel[1].r_info
			    == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
			&& rel[1].r_offset == rel->r_offset + 8)
d5324 8
a5331 1
			if (ok_tprel)
d5333 1
a5333 1
			  tls_set = TLS_EXPLICIT | TLS_GD;
d5336 2
a5337 2
			  tls_set = TLS_EXPLICIT | TLS_GD | TLS_TPRELGD;
			tls_clear = TLS_GD;
d5341 7
a5347 6
			if (!is_local)
			  continue;

			/* LD -> LE */
			tls_set = TLS_EXPLICIT;
			tls_clear = TLS_LD;
d5368 1
a5368 1
			  && ent->tls_type == tls_type)
d5379 2
d5398 7
a5404 1
			  if (tls_set == (TLS_EXPLICIT | TLS_GD))
a5405 1
			  p->count -= 1;
d5412 2
a5413 2
		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
d5437 1
a5437 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d5439 1
a5439 1
   && ((SHARED)								\
d5470 1
a5470 1
      && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
a5517 25
  eh = (struct ppc_link_hash_entry *) h;
  /* Run through the TLS GD got entries first if we're changing them
     to TPREL.  */
  if ((eh->tls_mask & TLS_TPRELGD) != 0)
    for (gent = h->got.glist; gent != NULL; gent = gent->next)
      if (gent->got.refcount > 0
	  && (gent->tls_type & TLS_GD) != 0)
	{
	  /* This was a GD entry that has been converted to TPREL.  If
	     there happens to be a TPREL entry we can use that one.  */
	  struct got_entry *ent;
	  for (ent = h->got.glist; ent != NULL; ent = ent->next)
	    if (ent->got.refcount > 0
		&& (ent->tls_type & TLS_TPREL) != 0
		&& ent->addend == gent->addend)
	      {
		gent->got.refcount = 0;
		break;
	      }

	  /* If not, then we'll be using our own TPREL entry.  */
	  if (gent->got.refcount != 0)
	    gent->tls_type = TLS_TLS | TLS_TPREL;
	}

a5520 2
	bfd_boolean dyn;

d5522 1
a5522 2
	   Undefined weak syms won't yet be marked as dynamic,
	   nor will all TLS symbols.  */
d5530 3
a5532 2
	if ((gent->tls_type & TLS_LD) != 0
	    && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
d5534 11
a5544 2
	    gent->got.offset = htab->tlsld_got.offset;
	    continue;
a5545 12

	s = htab->sgot;
	gent->got.offset = s->_raw_size;
	s->_raw_size
	  += (gent->tls_type & eh->tls_mask & (TLS_GD | TLS_LD)) ? 16 : 8;
	dyn = htab->elf.dynamic_sections_created;
	if (info->shared
	    || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	  htab->srelgot->_raw_size
	    += (gent->tls_type & eh->tls_mask & TLS_GD
		? 2 * sizeof (Elf64_External_Rela)
		: sizeof (Elf64_External_Rela));
d5550 1
d5579 1
a5579 1
  else if (ELIMINATE_COPY_RELOCS)
d5586 5
a5590 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
a5699 1
      char *lgot_masks;
a5740 1
      lgot_masks = (char *) end_lgot_ents;
d5743 1
a5743 1
      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_masks)
d5750 1
a5750 1
		if ((ent->tls_type & *lgot_masks & TLS_LD) != 0)
d5764 1
a5764 1
		    if ((ent->tls_type & *lgot_masks & TLS_GD) != 0)
a6192 1
      off = (bfd_vma) -1;
d6199 1
a6199 1
      if (off >= (bfd_vma) -2)
a6378 1
	  bfd_boolean big_sec;
a6384 2
	  big_sec = total >= stub_group_size;

d6399 1
a6399 1
	     more than 2097152 bytes, or nearly 75000 plt call stubs.  */
d6409 2
a6410 5
	     bytes before the stub section can be handled by it too.
	     Don't do this if we have a really large section after the
	     stubs, as adding more stubs increases the chance that
	     branches may not reach into the stub section.  */
	  if (!stubs_always_before_branch && !big_sec)
d6462 3
a6464 12
      if (stubs_always_before_branch)
	{
	  stub_group_size = 0x1e00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7800;
	}
      else
	{
	  stub_group_size = 0x1c00000;
	  if (htab->has_14bit_branch)
	    stub_group_size = 0x7000;
	}
d6606 1
a6606 1
		      char *tls_mask;
d6608 1
a6608 1
		      if (!get_tls_mask (&tls_mask, &local_syms,
d6611 2
a6612 1
		      if (*tls_mask != 0)
d6905 1
d6921 14
d6941 1
d6955 1
a6955 1
      char tls_mask, tls_gd, tls_type;
d6966 1
d7022 1
d7038 3
a7040 7
      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      if (IS_PPC64_TLS_RELOC (r_type))
d7043 1
a7043 1
	    tls_mask = ((struct ppc_link_hash_entry *) h)->tls_mask;
d7046 3
a7048 3
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_ents + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
d7067 1
d7074 1
a7077 1
	    int retval;
d7079 1
a7079 2
	    retval = get_tls_mask (&toc_tls, &local_syms, rel, input_bfd);
	    if (retval == 0)
d7084 1
a7084 1
		tls_mask = *toc_tls;
d7089 1
a7089 15
		  {
		    /* If we found a GD reloc pair, then we might be
		       doing a GD->IE transition.  */
		    if (retval == 2)
		      {
			tls_gd = TLS_TPRELGD;
			if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
			  goto tls_get_addr_check;
		      }
		    else if (retval == 3)
		      {
			if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
			  goto tls_get_addr_check;
		      }
		  }
d7096 1
d7098 2
a7099 2
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
d7112 2
a7113 1
	  if (tls_mask == 0)
d7118 1
a7118 1
	      if (!get_tls_mask (&toc_tls, &local_syms, rel, input_bfd))
d7122 1
a7122 1
		tls_mask = *toc_tls;
d7124 2
a7125 2
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
d7167 2
d7171 2
a7172 5
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;

d7175 2
a7176 1
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d7178 4
a7181 5
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC64_GOT_TPREL16_DS);
	      else
d7183 11
a7193 3
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  rel->r_offset -= 2;
		  r_type = R_PPC64_NONE;
d7195 7
a7201 1
	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7205 33
a7237 13
	case R_PPC64_GOT_TLSGD16:
	case R_PPC64_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_get_addr_check;
	  break;

	case R_PPC64_GOT_TLSLD16:
	case R_PPC64_GOT_TLSLD16_LO:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_get_addr_check:
	      if (rel + 1 < relend)
d7239 4
a7242 32
		  enum elf_ppc64_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2, insn3;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2
		    = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF64_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC64_REL14
			  && r_type2 != R_PPC64_REL14_BRTAKEN
			  && r_type2 != R_PPC64_REL14_BRNTAKEN
			  && r_type2 != R_PPC64_REL24))
		    break;

		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || h2 != htab->tls_get_addr)
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - 2);
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
		  if ((tls_mask & tls_gd) != 0)
d7244 3
a7246 11
		      /* IE */
		      insn1 &= (1 << 26) - (1 << 2);
		      insn1 |= 58 << 26;	/* ld */
		      insn2 = 0x7c636a14;	/* add 3,3,13 */
		      rel[1].r_info = ELF64_R_INFO (r_symndx2, R_PPC64_NONE);
		      if ((tls_mask & TLS_EXPLICIT) == 0)
			r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
				  + R_PPC64_GOT_TPREL16_DS);
		      else
			r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7249 11
a7259 34
		    {
		      /* LE */
		      insn1 = 0x3c6d0000;	/* addis 3,13,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
			}
		      r_type = R_PPC64_TPREL16_HA;
		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF64_R_INFO (r_symndx,
						    R_PPC64_TPREL16_LO);
		      rel[1].r_offset += 2;
		    }
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      insn3 = insn2;
		      insn2 = NOP;
		      rel[1].r_offset += 4;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
		  if (tls_gd == 0)
		    {
		      /* We changed the symbol on an LD reloc.  Start over
			 in order to get h, sym, sec etc. right.  */ 
		      rel--;
		      continue;
		    }
d7261 7
d7269 1
d7273 1
a7273 3
	  if (rel + 1 < relend
	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
	      && rel[1].r_offset == rel->r_offset + 8)
d7275 3
a7277 17
	      if ((tls_mask & TLS_GD) == 0)
		{
		  rel[1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_NONE);
		  if ((tls_mask & TLS_TPRELGD) != 0)
		    r_type = R_PPC64_TPREL64;
		  else
		    {
		      bfd_put_64 (output_bfd, (bfd_vma) 1,
				  contents + rel->r_offset);
		      r_type = R_PPC64_NONE;
		    }
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
		}
	    }
	  else
	    {
	      if ((tls_mask & TLS_LD) == 0)
a7281 1
		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7283 3
d7290 1
a7290 1
	  if ((tls_mask & TLS_TPREL) == 0)
d7440 1
a7440 1
	  tls_type = TLS_TLS | TLS_GD;
d7447 1
a7447 1
	  tls_type = TLS_TLS | TLS_LD;
d7474 1
a7474 1
	    bfd_vma *offp;
d7476 1
a7476 1
	    unsigned long indx = 0;
d7481 2
a7482 4
	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	      offp = &htab->tlsld_got.offset;
d7485 4
a7488 1
		struct got_entry *ent;
d7490 25
a7514 23
		if (h != NULL)
		  {
		    bfd_boolean dyn = htab->elf.dynamic_sections_created;
		    if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
			|| (info->shared
			    && (info->symbolic
				|| h->dynindx == -1
				|| (h->elf_link_hash_flags
				    & ELF_LINK_FORCED_LOCAL))
			    && (h->elf_link_hash_flags
				& ELF_LINK_HASH_DEF_REGULAR)))
		      /* This is actually a static link, or it is a
			 -Bsymbolic link and the symbol is defined
			 locally, or the symbol was forced to be local
			 because of a version file.  */
		      ;
		    else
		      {
			indx = h->dynindx;
			unresolved_reloc = FALSE;
		      }
		    ent = h->got.glist;
		  }
d7517 2
a7518 3
		    if (local_got_ents == NULL)
		      abort ();
		    ent = local_got_ents[r_symndx];
a7519 8

		for (; ent != NULL; ent = ent->next)
		  if (ent->addend == rel->r_addend
		      && ent->tls_type == tls_type)
		    break;
		if (ent == NULL)
		  abort ();
		offp = &ent->got.offset;
a7524 1
	    off = *offp;
d7532 2
a7533 2
		*offp = off | 1;
		if (info->shared || indx != 0)
d7538 1
a7538 1
		    if (tls_type & (TLS_LD | TLS_GD))
d7542 6
a7547 11
			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    loc = htab->srelgot->contents;
			    loc += (htab->srelgot->reloc_count++
				    * sizeof (Elf64_External_Rela));
			    bfd_elf64_swap_reloca_out (output_bfd,
						       &outrel, loc);
			    outrel.r_info
			      = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
			    outrel.r_offset += 8;
			  }
d7549 1
a7549 1
		    else if (tls_type == (TLS_TLS | TLS_DTPREL))
d7551 1
a7551 1
		    else if (tls_type == (TLS_TLS | TLS_TPREL))
d7557 1
a7557 1
		    outrel.r_addend = rel->r_addend;
d7568 1
a7568 1
		else
d7570 3
a7572 2
		    relocation += rel->r_addend;
		    if (tls_type != 0)
d7579 1
a7579 1
		    if ((tls_type & TLS_GD) != 0)
d7581 2
a7586 2
		    else if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
d7590 1
d7751 1
a7751 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d7755 6
a7760 2
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d7874 1
a7874 1
	  /* Fall through.  */
d8019 3
a8021 3
	  if (sym_name == NULL)
	    sym_name = "(null)";
	  if (r == bfd_reloc_overflow)
d8023 1
a8023 4
	      if (warned)
		continue;
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
d8035 13
d8049 1
a8049 1
		    (info, sym_name, ppc64_elf_howto_table[(int) r_type]->name,
d8059 1
a8059 1
		 (long) rel->r_offset, sym_name, (int) r);
d8103 1
@


1.63.10.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a4520 4
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d7637 1
a7638 1
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
a7645 1
			    outrel.r_offset += 8;
d7648 1
d7661 1
a7661 5
		      {
			outrel.r_addend += relocation;
			if (tls_type & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			  outrel.r_addend -= htab->tls_sec->vma;
		      }
d7673 1
a7673 3
		    if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
		    else if (tls_type != 0)
d7676 1
a7676 1
			if (tls_type == (TLS_TLS | TLS_TPREL))
d7678 1
d7680 5
a7684 6
			if (tls_type == (TLS_TLS | TLS_GD))
			  {
			    bfd_put_64 (output_bfd, relocation,
					htab->sgot->contents + off + 8);
			    relocation = 1;
			  }
d7686 2
a7687 1

a7795 5
	case R_PPC64_DTPMOD64:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

d7806 1
d7984 1
a7984 1
	    (_("%s: relocation %s is not supported for symbol %s."),
d8026 2
a8027 3
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
d8098 1
a8098 1
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
a8101 1
	     ppc64_elf_howto_table[(int) r_type]->name,
d8143 1
a8143 1
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
d8146 1
a8146 4
		 (long) rel->r_offset,
		 ppc64_elf_howto_table[(int) r_type]->name,
		 sym_name,
		 (int) r);
@


1.63.10.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a3274 1
  flagword mask;
d3319 8
a3326 11
  mask = (ELF_LINK_HASH_REF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF);
  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (ELIMINATE_COPY_RELOCS
      && eind->elf.root.type != bfd_link_hash_indirect
      && (edir->elf.elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    mask &= ~ELF_LINK_NON_GOT_REF;

  edir->elf.elf_link_hash_flags |= eind->elf.elf_link_hash_flags & mask;
d3332 1
a3332 2
  /* Copy over got entries that we may have already seen to the
     symbol which just became indirect.  */
a3879 4
	  if (h != NULL && !info->shared)
	    /* We may need a copy reloc.  */
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

d4499 4
a4502 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d4507 1
d4867 3
a4869 3
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
					    (Elf_Internal_Rela *) NULL,
					    info->keep_memory);
d5190 3
a5192 3
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
						  info->keep_memory);
d5591 2
a5592 4
	if ((info->shared
	     || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	    && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak))
d5612 3
a5614 7
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
a5627 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d6578 3
a6580 3
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     (Elf_Internal_Rela *) NULL,
					     info->keep_memory);
d7588 6
a7593 1
			    && SYMBOL_REFERENCES_LOCAL (info, h)))
d7634 1
a7634 4
		if ((info->shared || indx != 0)
		    && (h == NULL
			|| ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			|| h->root.type != bfd_link_hash_undefweak))
a7857 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d7860 4
a7863 1
		       && !SYMBOL_CALLS_LOCAL (info, h))))
d7898 7
a7904 2
		       && !SYMBOL_REFERENCES_LOCAL (info, h)
		       && !is_opd)
@


1.63.10.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d18 6
a23 7
   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* The 64-bit PowerPC ELF ABI may be found at
   http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi.txt, and
   http://www.linuxbase.org/spec/ELF/ppc64/spec/book1.html  */
d33 6
d40 1
a40 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d42 1
a42 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d44 1
a44 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d46 1
a46 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d48 1
a48 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d50 1
a50 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d52 1
a52 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d54 7
a60 22
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);


#define TARGET_LITTLE_SYM	bfd_elf64_powerpcle_vec
#define TARGET_LITTLE_NAME	"elf64-powerpcle"
#define TARGET_BIG_SYM		bfd_elf64_powerpc_vec
#define TARGET_BIG_NAME		"elf64-powerpc"
#define ELF_ARCH		bfd_arch_powerpc
#define ELF_MACHINE_CODE	EM_PPC64
#define ELF_MAXPAGESIZE		0x10000
#define elf_info_to_howto	ppc64_elf_info_to_howto

#define elf_backend_want_got_sym 0
#define elf_backend_want_plt_sym 0
#define elf_backend_plt_alignment 3
#define elf_backend_plt_not_loaded 1
#define elf_backend_got_symbol_offset 0
#define elf_backend_got_header_size 8
#define elf_backend_plt_header_size PLT_INITIAL_ENTRY_SIZE
#define elf_backend_can_gc_sections 1
#define elf_backend_can_refcount 1
#define elf_backend_rela_normal 1
a61 20
#define bfd_elf64_bfd_reloc_type_lookup	      ppc64_elf_reloc_type_lookup
#define bfd_elf64_bfd_merge_private_bfd_data  ppc64_elf_merge_private_bfd_data
#define bfd_elf64_new_section_hook	      ppc64_elf_new_section_hook
#define bfd_elf64_bfd_link_hash_table_create  ppc64_elf_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free    ppc64_elf_link_hash_table_free

#define elf_backend_object_p		      ppc64_elf_object_p
#define elf_backend_create_dynamic_sections   ppc64_elf_create_dynamic_sections
#define elf_backend_copy_indirect_symbol      ppc64_elf_copy_indirect_symbol
#define elf_backend_check_relocs	      ppc64_elf_check_relocs
#define elf_backend_gc_mark_hook	      ppc64_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	      ppc64_elf_gc_sweep_hook
#define elf_backend_adjust_dynamic_symbol     ppc64_elf_adjust_dynamic_symbol
#define elf_backend_hide_symbol		      ppc64_elf_hide_symbol
#define elf_backend_always_size_sections      ppc64_elf_func_desc_adjust
#define elf_backend_size_dynamic_sections     ppc64_elf_size_dynamic_sections
#define elf_backend_relocate_section	      ppc64_elf_relocate_section
#define elf_backend_finish_dynamic_symbol     ppc64_elf_finish_dynamic_symbol
#define elf_backend_reloc_type_class	      ppc64_elf_reloc_type_class
#define elf_backend_finish_dynamic_sections   ppc64_elf_finish_dynamic_sections
d80 1
a80 4
/* .plt call stub instructions.  The normal stub is like this, but
   sometimes the .plt entry crosses a 64k boundary and we need to
   insert an addis to adjust r12.  */
#define PLT_CALL_STUB_SIZE (7*4)
d89 2
d92 7
a98 4
#define ADDIS_R2_R2	0x3c420000	/* addis %r2,%r2,off@@ha  */
#define ADDI_R2_R2	0x38420000	/* addi  %r2,%r2,off@@l   */

#define LD_R2_40R1	0xe8410028	/* ld    %r2,40(%r1)     */
d100 2
a101 19
/* glink call stub instructions.  We enter with the index in R0, and the
   address of glink entry in CTR.  From that, we can calculate PLT0.  */
#define GLINK_CALL_STUB_SIZE (16*4)
#define MFCTR_R12	0x7d8902a6	/* mfctr  %r12			*/
#define SLDI_R11_R0_3	0x780b1f24	/* sldi	  %r11,%r0,3		*/
#define ADDIC_R2_R0_32K 0x34408000	/* addic. %r2,%r0,-32768	*/
#define SUB_R12_R12_R11 0x7d8b6050	/* sub	  %r12,%r12,%r11	*/
#define SRADI_R2_R2_63	0x7c42fe76	/* sradi  %r2,%r2,63		*/
#define SLDI_R11_R0_2	0x780b1764	/* sldi	  %r11,%r0,2		*/
#define AND_R2_R2_R11	0x7c425838	/* and	  %r2,%r2,%r11		*/
					/* sub	  %r12,%r12,%r11	*/
#define ADD_R12_R12_R2	0x7d8c1214	/* add	  %r12,%r12,%r2		*/
#define ADDIS_R12_R12	0x3d8c0000	/* addis  %r12,%r12,xxx@@ha	*/
					/* ld	  %r11,xxx@@l(%r12)	*/
#define ADDI_R12_R12	0x398c0000	/* addi	  %r12,%r12,xxx@@l	*/
					/* ld	  %r2,8(%r12)		*/
					/* mtctr  %r11			*/
					/* ld	  %r11,16(%r12)		*/
					/* bctr				*/
d1721 1
a1721 1
	 0xfffc,		/* dst_mask */
d1736 1
a1736 1
	 0xfffc,		/* dst_mask */
d1805 1
a1805 1
ppc_howto_init (void)
d1821 3
a1823 2
ppc64_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     bfd_reloc_code_real_type code)
d1831 1
a1831 1
  switch (code)
d1834 1
a1834 1
      return NULL;
d2040 1
a2040 1
  return ppc64_elf_howto_table[r];
d2046 4
a2049 2
ppc64_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			 Elf_Internal_Rela *dst)
d2066 9
a2074 3
ppc64_elf_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section,
		    bfd *output_bfd, char **error_message)
d2091 9
a2099 3
ppc64_elf_brtaken_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
d2117 1
a2117 1
  r_type = reloc_entry->howto->type;
d2153 1
a2153 1
  bfd_put_32 (abfd, insn, (bfd_byte *) data + octets);
d2158 9
a2166 3
ppc64_elf_sectoff_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section,
			 bfd *output_bfd, char **error_message)
d2181 9
a2189 3
ppc64_elf_sectoff_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			    void *data, asection *input_section,
			    bfd *output_bfd, char **error_message)
d2207 9
a2215 3
ppc64_elf_toc_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		     void *data, asection *input_section,
		     bfd *output_bfd, char **error_message)
d2236 9
a2244 3
ppc64_elf_toc_ha_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section,
			bfd *output_bfd, char **error_message)
d2268 9
a2276 3
ppc64_elf_toc64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		       void *data, asection *input_section,
		       bfd *output_bfd, char **error_message)
d2298 9
a2306 3
ppc64_elf_unhandled_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			   void *data, asection *input_section,
			   bfd *output_bfd, char **error_message)
d2329 2
a2330 1
ppc64_elf_object_p (bfd *abfd)
d2350 3
a2352 1
ppc64_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d2362 1
a2362 2
	msg = _("%s: compiled for a big endian system "
		"and target is little endian");
d2364 1
a2364 2
	msg = _("%s: compiled for a little endian system "
		"and target is big endian");
d2397 3
a2399 1
ppc64_elf_new_section_hook (bfd *abfd, asection *sec)
d2404 1
a2404 1
  sdata = bfd_zalloc (abfd, amt);
d2407 1
a2407 1
  sec->used_by_bfd = sdata;
a2576 17

   ppc_stub_long_branch and ppc_stub_plt_branch may also have additional
   code to adjust the value and save r2 to support multiple toc sections.
   A ppc_stub_long_branch with an r2 offset looks like:
   .	std	%r2,40(%r1)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
   .	b	dest

   A ppc_stub_plt_branch with an r2 offset looks like:
   .	std	%r2,40(%r1)
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
   .	addis	%r2,%r2,off@@ha
   .	addi	%r2,%r2,off@@l
   .	mtctr	%r11
   .	bctr
a2581 1
  ppc_stub_long_branch_r2off,
a2582 1
  ppc_stub_plt_branch_r2off,
a2590 2
  enum ppc_stub_type stub_type;

d2602 2
d2680 2
a2681 2
  asection * (*add_stub_section) (const char *, asection *);
  void (*layout_sections_again) (void);
a2689 2
    /* Along with elf_gp, specifies the TOC pointer used in this group.  */
    bfd_vma toc_off;
d2692 1
a2692 11
  /* Support for multiple toc sections.  */
  unsigned int no_multi_toc;
  unsigned int multi_toc_needed;

  /* Temp used when calculating TOC pointers.  */
  bfd_vma toc_curr;

  /* Highest input section id.  */
  int top_id;

  /* Highest output section index.  */
a2693 2

  /* List of input sections for each output section.  */
d2697 7
a2703 7
  asection *got;
  asection *relgot;
  asection *plt;
  asection *relplt;
  asection *dynbss;
  asection *relbss;
  asection *glink;
d2705 2
a2706 2
  asection *brlt;
  asection *relbrlt;
a2719 6
  /* Statistics.  */
  unsigned long stub_count[ppc_stub_plt_call];

  /* Set if we should emit symbols for stubs.  */
  unsigned int emit_stub_syms;

d2737 82
d2835 4
a2838 3
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
a2856 1
      eh->stub_type = ppc_stub_none;
d2861 1
d2872 4
a2875 3
branch_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table,
		     const char *string)
d2904 4
a2907 3
link_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
d2939 2
a2940 1
ppc64_elf_link_hash_table_create (bfd *abfd)
d2945 1
a2945 1
  htab = bfd_zmalloc (amt);
d2963 22
d3000 2
a3001 1
ppc64_elf_link_hash_table_free (struct bfd_link_hash_table *hash)
d3013 5
a3017 4
ppc_stub_name (const asection *input_section,
	       const asection *sym_sec,
	       const struct ppc_link_hash_entry *h,
	       const Elf_Internal_Rela *rel)
d3041 1
a3041 1
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
d3059 6
a3064 5
ppc_get_stub_entry (const asection *input_section,
		    const asection *sym_sec,
		    struct elf_link_hash_entry *hash,
		    const Elf_Internal_Rela *rel,
		    struct ppc_link_hash_table *htab)
d3106 4
a3109 3
ppc_add_stub (const char *stub_name,
	      asection *section,
	      struct ppc_link_hash_table *htab)
d3162 3
a3164 1
create_linkage_sections (bfd *dynobj, struct bfd_link_info *info)
d3181 4
a3184 4
  htab->glink = bfd_make_section_anyway (dynobj, ".glink");
  if (htab->glink == NULL
      || ! bfd_set_section_flags (dynobj, htab->glink, flags)
      || ! bfd_set_section_alignment (dynobj, htab->glink, 2))
d3190 4
a3193 4
  htab->brlt = bfd_make_section_anyway (dynobj, ".branch_lt");
  if (htab->brlt == NULL
      || ! bfd_set_section_flags (dynobj, htab->brlt, flags)
      || ! bfd_set_section_alignment (dynobj, htab->brlt, 3))
d3200 4
a3203 4
      htab->relbrlt = bfd_make_section_anyway (dynobj, ".rela.branch_lt");
      if (!htab->relbrlt
	  || ! bfd_set_section_flags (dynobj, htab->relbrlt, flags)
	  || ! bfd_set_section_alignment (dynobj, htab->relbrlt, 3))
d3213 3
a3215 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d3223 2
a3224 2
  htab->got = bfd_get_section_by_name (dynobj, ".got");
  if (!htab->got)
d3227 3
a3229 3
  htab->relgot = bfd_make_section (dynobj, ".rela.got");
  if (!htab->relgot
      || ! bfd_set_section_flags (dynobj, htab->relgot,
d3233 1
a3233 1
      || ! bfd_set_section_alignment (dynobj, htab->relgot, 3))
d3241 3
a3243 1
ppc64_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d3248 1
a3248 1
  if (!htab->got && !create_got_section (dynobj, info))
d3254 3
a3256 3
  htab->plt = bfd_get_section_by_name (dynobj, ".plt");
  htab->relplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->dynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d3258 1
a3258 1
    htab->relbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d3260 2
a3261 2
  if (!htab->plt || !htab->relplt || !htab->dynbss
      || (!info->shared && !htab->relbss))
d3270 3
a3272 3
ppc64_elf_copy_indirect_symbol (struct elf_backend_data *bed ATTRIBUTE_UNUSED,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
d3411 2
a3412 1
ppc64_elf_mark_entry_syms (struct bfd_link_info *info)
d3430 6
a3435 2
update_local_sym_info (bfd *abfd, Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx, bfd_vma r_addend, int tls_type)
d3445 1
a3445 1
      local_got_ents = bfd_zalloc (abfd, size);
d3461 1
a3461 1
	  ent = bfd_alloc (abfd, amt);
d3479 4
a3482 1
update_plt_info (bfd *abfd, struct ppc_link_hash_entry *eh, bfd_vma addend)
d3492 1
a3492 1
      ent = bfd_alloc (abfd, amt);
d3511 5
a3515 2
ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
d3525 1
a3525 1
  if (info->relocatable)
d3556 1
a3556 1
      opd_sym_map = bfd_zalloc (abfd, amt);
d3582 1
a3582 1
      r_type = ELF64_R_TYPE (rel->r_info);
d3625 1
a3625 2
	  sec->has_gp_reloc = 1;
	  if (htab->got == NULL
d3642 1
a3642 1
		  ent = bfd_alloc (abfd, amt);
d3693 6
a3710 10
	  /* Nor do these.  */
	case R_PPC64_TOC16:
	case R_PPC64_TOC16_LO:
	case R_PPC64_TOC16_HI:
	case R_PPC64_TOC16_HA:
	case R_PPC64_TOC16_DS:
	case R_PPC64_TOC16_LO_DS:
	  sec->has_gp_reloc = 1;
	  break;

d3795 2
a3796 1
	      ppc64_elf_section_data (sec)->t_symndx = bfd_zalloc (abfd, amt);
d3849 2
a3850 1
	      && ELF64_R_TYPE ((rel + 1)->r_info) == R_PPC64_TOC)
d4005 3
a4007 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d4035 6
a4040 5
ppc64_elf_gc_mark_hook (asection *sec,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
d4049 1
a4049 1
      r_type = ELF64_R_TYPE (rel->r_info);
d4106 5
a4110 2
ppc64_elf_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			 asection *sec, const Elf_Internal_Rela *relocs)
d4134 1
a4134 1
      r_type = ELF64_R_TYPE (rel->r_info);
d4244 3
a4246 1
func_desc_adjust (struct elf_link_hash_entry *h, void *inf)
d4258 1
a4258 1
  info = inf;
d4369 3
a4371 2
ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
d4429 1
a4429 1
  elf_link_hash_traverse (&htab->elf, func_desc_adjust, info);
d4445 1
a4445 1
  p = bfd_alloc (htab->elf.dynobj, htab->sfpr->_raw_size);
d4486 3
a4488 2
ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *h)
d4588 1
a4588 1
      htab->relbss->_raw_size += sizeof (Elf64_External_Rela);
d4599 1
a4599 1
  s = htab->dynbss;
d4620 4
a4623 3
ppc64_elf_hide_symbol (struct bfd_link_info *info,
		       struct elf_link_hash_entry *h,
		       bfd_boolean force_local)
d4677 8
a4684 3
get_sym_h (struct elf_link_hash_entry **hp, Elf_Internal_Sym **symp,
	   asection **symsecp, char **tls_maskp, Elf_Internal_Sym **locsymsp,
	   unsigned long r_symndx, bfd *ibfd)
d4775 1
a4775 1
   type suitable for optimization, and 1 otherwise.  */
d4778 5
a4782 2
get_tls_mask (char **tls_maskp, Elf_Internal_Sym **locsymsp,
	      const Elf_Internal_Rela *rel, bfd *ibfd)
d4829 3
a4831 1
ppc64_elf_edit_opd (bfd *obfd, struct bfd_link_info *info)
d4857 1
a4857 1
	  adjust = bfd_zalloc (obfd, amt);
d4860 1
a4860 1
      memset (adjust, 0, amt);
d4874 2
a4875 1
      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
d4896 1
a4896 1
	  r_type = ELF64_R_TYPE (rel->r_info);
d4911 1
a4911 1
	  r_type = ELF64_R_TYPE ((rel + 1)->r_info);
d4978 1
a4978 1
		  || !bfd_get_section_contents (ibfd, sec, loc, 0,
d5137 3
a5139 1
ppc64_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
d5174 3
a5176 1
ppc64_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)
d5182 1
a5182 1
  if (info->relocatable || info->shared)
d5197 2
a5198 1
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
d5254 2
a5255 1
		r_type = ELF64_R_TYPE (rel->r_info);
d5476 3
a5478 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d5509 1
a5509 1
	    s = htab->plt;
d5519 1
a5519 1
	    s = htab->glink;
d5528 1
a5528 1
	    s = htab->relplt;
d5593 1
a5593 1
	s = htab->got;
d5602 1
a5602 1
	  htab->relgot->_raw_size
d5691 3
a5693 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d5708 1
a5708 1
	  struct bfd_link_info *info = inf;
d5722 3
a5724 2
ppc64_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info)
d5740 1
a5740 1
      if (info->executable)
d5752 2
a5753 2
      htab->tlsld_got.offset = htab->got->_raw_size;
      htab->got->_raw_size += 16;
d5755 1
a5755 1
	htab->relgot->_raw_size += sizeof (Elf64_External_Rela);
d5809 2
a5810 2
      s = htab->got;
      srel = htab->relgot;
d5853 1
a5853 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d5867 1
a5867 1
      if (s == htab->brlt || s == htab->relbrlt)
d5870 3
a5872 11
      else if (s == htab->got)
	{
	  /* Automatic multiple tocs aren't possible if we are using the
	     GOT.  The GOT is accessed via r2, so we can't adjust r2.
	     FIXME: There's no reason why we couldn't lay out multiple
	     GOTs too.  */
	  if (s->_raw_size > elf_backend_got_header_size)
	    htab->no_multi_toc = 1;
	}
      else if (s == htab->plt
	       || s == htab->glink)
d5893 1
a5893 1
	      if (s != htab->relplt)
d5924 1
a5924 1
      s->contents = bfd_zalloc (dynobj, s->_raw_size);
d5937 1
a5937 1
  bfd_elf64_add_dynamic_entry (info, (TAG), (VAL))
d5939 1
a5939 1
      if (info->executable)
d5945 1
a5945 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
d5972 2
a5973 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d5989 6
a5994 5
static inline enum ppc_stub_type
ppc_type_of_stub (asection *input_sec,
		  const Elf_Internal_Rela *rel,
		  struct ppc_link_hash_entry **hash,
		  bfd_vma destination)
d6000 1
a6000 1
  enum elf_ppc64_reloc_type r_type;
d6017 2
a6018 2
      if (h->elf.root.type != bfd_link_hash_defined
	  && h->elf.root.type != bfd_link_hash_defweak)
d6032 1
a6032 1
  if (r_type != R_PPC64_REL24)
d6045 6
a6050 2
static inline bfd_byte *
build_plt_stub (bfd *obfd, bfd_byte *p, int offset)
d6056 2
d6059 2
a6060 1
  bfd_put_32 (obfd, STD_R2_40R1, p),			p += 4;
d6063 1
a6063 1
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
d6067 1
a6067 1
    bfd_put_32 (obfd, ADDIS_R12_R12 | 1, p),		p += 4;
d6076 3
a6078 1
ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d6095 1
a6095 1
  info = in_arg;
a6103 16
  if (htab->emit_stub_syms)
    {
      struct elf_link_hash_entry *h;
      h = elf_link_hash_lookup (&htab->elf, stub_entry->root.string,
				TRUE, FALSE, FALSE);
      if (h == NULL)
	return FALSE;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = stub_entry->stub_sec;
      h->root.u.def.value = stub_entry->stub_offset;
      h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
				| ELF_LINK_HASH_DEF_REGULAR
				| ELF_LINK_HASH_REF_REGULAR_NONWEAK
				| ELF_LINK_FORCED_LOCAL);
    }

a6105 1
  htab->stub_count[stub_entry->stub_type - 1] += 1;
a6108 1
    case ppc_stub_long_branch_r2off:
d6119 1
a6119 5
      if (stub_entry->stub_type != ppc_stub_long_branch_r2off)
	size = 4;
      else
	{
	  bfd_vma r2off;
d6121 2
a6122 14
	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
	  bfd_put_32 (stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	  loc += 4;
	  off -= 12;
	  size = 16;
	}
      bfd_put_32 (stub_bfd, B_DOT | (off & 0x3fffffc), loc);

      BFD_ASSERT (off + (1 << 25) < (bfd_vma) (1 << 26));
a6125 1
    case ppc_stub_plt_branch_r2off:
d6141 2
a6142 2
      bfd_put_64 (htab->brlt->owner, off,
		  htab->brlt->contents + br_entry->offset);
d6148 1
a6148 1
	  bfd_byte *rl;
d6151 2
a6152 2
			   + htab->brlt->output_offset
			   + htab->brlt->output_section->vma);
d6156 3
a6158 3
	  rl = htab->relbrlt->contents;
	  rl += htab->relbrlt->reloc_count++ * sizeof (Elf64_External_Rela);
	  bfd_elf64_swap_reloca_out (htab->relbrlt->owner, &rela, rl);
d6162 4
a6165 4
	     + htab->brlt->output_offset
	     + htab->brlt->output_section->vma
	     - elf_gp (htab->brlt->output_section->owner)
	     - htab->stub_group[stub_entry->id_sec->id].toc_off);
d6167 1
a6167 1
      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
d6178 5
a6182 28
      if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)
	{
	  bfd_put_32 (stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  size = 16;
	}
      else
	{
	  bfd_vma r2off;

	  r2off = (htab->stub_group[stub_entry->target_section->id].toc_off
		   - htab->stub_group[stub_entry->id_sec->id].toc_off);
	  bfd_put_32 (stub_bfd, STD_R2_40R1, loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
	  loc += 4;
	  bfd_put_32 (stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
	  size = 28;
	}
      loc += 4;
      bfd_put_32 (stub_bfd, MTCTR_R11, loc);
      loc += 4;
      bfd_put_32 (stub_bfd, BCTR, loc);
d6194 1
a6194 3
	     defined somewhere.  Maybe defining the symbol in the stub
	     section is a silly idea.  If we didn't do this, htab->top_id
	     could disappear.  */
d6212 4
a6215 4
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);
d6217 1
a6217 1
      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)
d6227 1
a6227 1
      p = build_plt_stub (stub_bfd, loc, off);
d6245 3
a6247 1
ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d6256 1
a6256 1
  htab = in_arg;
d6270 4
a6273 4
      off += (htab->plt->output_offset
	      + htab->plt->output_section->vma
	      - elf_gp (htab->plt->output_section->owner)
	      - htab->stub_group[stub_entry->id_sec->id].toc_off);
d6275 2
a6276 2
      size = PLT_CALL_STUB_SIZE;
      if (PPC_HA (off + 16) != PPC_HA (off))
d6281 4
a6284 2
      /* ppc_stub_long_branch or ppc_stub_plt_branch, or their r2off
	 variants.  */
a6291 13
      /* Reset the stub type from the plt variant in case we now
	 can reach with a shorter stub.  */
      if (stub_entry->stub_type >= ppc_stub_plt_branch)
	stub_entry->stub_type += ppc_stub_long_branch - ppc_stub_plt_branch;

      size = 4;
      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)
	{
	  off -= 12;
	  size = 16;
	}

      /* If the branch offset if too big, use a ppc_stub_plt_branch.  */
d6310 2
a6311 2
	      br_entry->offset = htab->brlt->_raw_size;
	      htab->brlt->_raw_size += 8;
d6313 1
a6313 2

	  stub_entry->stub_type += ppc_stub_plt_branch - ppc_stub_long_branch;
a6314 2
	  if (stub_entry->stub_type != ppc_stub_plt_branch)
	    size = 28;
d6327 3
a6329 1
ppc64_elf_setup_section_lists (bfd *output_bfd, struct bfd_link_info *info)
d6332 1
a6332 1
  int top_id, top_index, id;
d6334 1
a6334 1
  asection **input_list;
d6338 2
a6339 1
  if (htab->brlt == NULL)
d6343 1
a6343 1
  for (input_bfd = info->input_bfds, top_id = 3;
a6355 1
  htab->top_id = top_id;
d6357 1
a6357 1
  htab->stub_group = bfd_zmalloc (amt);
a6360 6
  /* Set toc_off for com, und, abs and ind sections.  */
  for (id = 0; id < 3; id++)
    htab->stub_group[id].toc_off = TOC_BASE_OFF;

  elf_gp (output_bfd) = htab->toc_curr = ppc64_elf_toc (output_bfd);

d6374 1
a6374 1
  input_list = bfd_zmalloc (amt);
d6379 6
a6384 2
  return 1;
}
d6386 3
a6388 11
/* The linker repeatedly calls this function for each toc input
   section.  Group input bfds such that the toc within a group
   is less than 64k in size.  Will break with cute linker scripts
   that play games with dot in the output toc section.  */

void
ppc64_elf_next_toc_section (struct bfd_link_info *info, asection *isec)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  if (!htab->no_multi_toc)
d6390 2
a6391 10
      bfd_vma addr = isec->output_offset + isec->output_section->vma;
      bfd_vma off = addr - htab->toc_curr;
      if (off + isec->_raw_size > 0x10000)
	{
	  htab->toc_curr = addr;
	  htab->multi_toc_needed = 1;
	}
      elf_gp (isec->owner) = (htab->toc_curr
			      - elf_gp (isec->output_section->owner)
			      + TOC_BASE_OFF);
a6392 1
}
d6394 1
a6394 68
/* Called after the last call to the above function.  */

void
ppc64_elf_reinit_toc (bfd *output_bfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);

  /* toc_curr tracks the TOC offset used for code sections below in
     ppc64_elf_next_input_section.  Start off at 0x8000.  */
  htab->toc_curr = TOC_BASE_OFF;
}

/* No toc references were found in ISEC.  If the code in ISEC makes no
   calls, then there's no need to use toc adjusting stubs when branching
   into ISEC.  Actually, indirect calls from ISEC are OK as they will
   load r2.  */

static int
toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)
{
  bfd_byte *contents;
  bfd_size_type i;
  int ret;
  int branch_ok;

  /* Hack for linux kernel.  .fixup contains branches, but only back to
     the function that hit an exception.  */
  branch_ok = strcmp (isec->name, ".fixup") == 0;

  contents = elf_section_data (isec)->this_hdr.contents;
  if (contents == NULL)
    {
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	return -1;
      if (! bfd_get_section_contents (isec->owner, isec, contents,
				      (file_ptr) 0, isec->_raw_size))
	{
	  free (contents);
	  return -1;
	}
      if (info->keep_memory)
	elf_section_data (isec)->this_hdr.contents = contents;
    }

  /* Code scan, because we don't necessarily have relocs on calls to
     static functions.  */
  ret = 0;
  for (i = 0; i < isec->_raw_size; i += 4)
    {
      unsigned long insn = bfd_get_32 (isec->owner, contents + i);
      /* Is this a branch?  */
      if ((insn & (0x1f << 26)) == (18 << 26)
	  /* If branch and link, it's a function call.  */
	  && ((insn & 1) != 0
	      /* Sibling calls use a plain branch.  I don't know a way
		 of deciding whether a branch is really a sibling call.  */
	      || !branch_ok))
	{
	  ret = 1;
	  break;
	}
    }

  if (elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  return ret;
d6402 4
a6405 2
bfd_boolean
ppc64_elf_next_input_section (struct bfd_link_info *info, asection *isec)
a6407 1
  int ret;
d6409 1
a6409 2
  if ((isec->output_section->flags & SEC_CODE) != 0
      && isec->output_section->index <= htab->top_index)
d6412 3
a6414 1
      /* Steal the link_sec pointer for our list.  */
d6416 5
a6420 4
      /* This happens to make the list in reverse order,
	 which is what we want.  */
      PREV_SEC (isec) = *list;
      *list = isec;
a6421 19

  /* If a code section has a function that uses the TOC then we need
     to use the right TOC (obviously).  Also, make sure that .opd gets
     the correct TOC value.  */
  if (isec->has_gp_reloc || (isec->flags & SEC_CODE) == 0)
    {
      if (elf_gp (isec->owner) != 0)
	htab->toc_curr = elf_gp (isec->owner);
    }
  else if ((ret = toc_adjusting_stub_needed (info, isec)) < 0)
    return FALSE;
  else
    isec->has_gp_reloc = ret;

  /* Functions that don't use the TOC can belong in any TOC group.
     Use the last TOC base.  This happens to make _init and _fini
     pasting work.  */
  htab->stub_group[isec->id].toc_off = htab->toc_curr;
  return TRUE;
d6432 4
a6435 3
group_sections (struct ppc_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_before_branch)
d6441 2
a6448 1
	  bfd_vma curr_toc;
a6455 1
	  curr_toc = htab->stub_group[tail->id].toc_off;
d6459 1
a6459 2
		     < stub_group_size)
		 && htab->stub_group[prev->id].toc_off == curr_toc)
d6490 1
a6490 2
			 < stub_group_size)
		     && htab->stub_group[prev->id].toc_off == curr_toc)
d6512 8
a6519 6
ppc64_elf_size_stubs (bfd *output_bfd,
		      bfd *stub_bfd,
		      struct bfd_link_info *info,
		      bfd_signed_vma group_size,
		      asection *(*add_stub_section) (const char *, asection *),
		      void (*layout_sections_again) (void))
d6597 2
a6598 1
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
d6608 1
a6608 2
		  enum elf_ppc64_reloc_type r_type;
		  unsigned int r_indx;
d6623 1
a6623 1
		  if (r_type >= R_PPC64_max)
d6630 4
a6633 4
		  if (r_type != R_PPC64_REL24
		      && r_type != R_PPC64_REL14
		      && r_type != R_PPC64_REL14_BRTAKEN
		      && r_type != R_PPC64_REL14_BRNTAKEN)
a6678 18

		  if (stub_type != ppc_stub_plt_call)
		    {
		      /* Check whether we need a TOC adjusting stub.
			 Since the linker pastes together pieces from
			 different object files when creating the
			 _init and _fini functions, it may be that a
			 call to what looks like a local sym is in
			 fact a call needing a TOC adjustment.  */
		      if (sym_sec != NULL
			  && sym_sec->output_section != NULL
			  && (htab->stub_group[sym_sec->id].toc_off
			      != htab->stub_group[section->id].toc_off)
			  && sym_sec->has_gp_reloc
			  && section->has_gp_reloc)
			stub_type = ppc_stub_long_branch_r2off;
		    }

a6730 1
		  stub_entry->stub_type = stub_type;
d6733 1
d6766 2
a6767 2
      htab->brlt->_raw_size = 0;
      htab->brlt->_cooked_size = 0;
d6787 2
a6788 1
ppc64_elf_toc (bfd *obfd)
d6845 2
a6846 3
ppc64_elf_build_stubs (bfd_boolean emit_stub_syms,
		       struct bfd_link_info *info,
		       char **stats)
d6850 1
a6852 1
  htab->emit_stub_syms = emit_stub_syms;
d6863 1
a6863 1
	  stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
d6870 1
a6870 1
  if (htab->plt != NULL)
a6872 1
      bfd_vma plt0;
d6875 7
a6881 6
      plt0 = (htab->plt->output_section->vma
	      + htab->plt->output_offset
	      - (htab->glink->output_section->vma
		 + htab->glink->output_offset
		 + GLINK_CALL_STUB_SIZE));
      if (plt0 + 0x80008000 > 0xffffffff)
d6883 2
a6884 3
	  (*_bfd_error_handler) (_(".glink and .plt too far apart"));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
a6886 34
      p = htab->glink->contents;
      bfd_put_32 (htab->glink->owner, MFCTR_R12, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_3, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDIC_R2_R0_32K, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SRADI_R2_R2_63, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SLDI_R11_R0_2, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, AND_R2_R2_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, SUB_R12_R12_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADD_R12_R12_R2, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDIS_R12_R12 | PPC_HA (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | PPC_LO (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, ADDI_R12_R12 | PPC_LO (plt0), p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R2_0R12 | 8, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, MTCTR_R11, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, LD_R11_0R12 | 16, p);
      p += 4;
      bfd_put_32 (htab->glink->owner, BCTR, p);
      p += 4;

d6889 1
a6889 1
      while (p < htab->glink->contents + htab->glink->_raw_size)
d6893 1
a6893 1
	      bfd_put_32 (htab->glink->owner, LI_R0_0 | indx, p);
d6898 1
a6898 1
	      bfd_put_32 (htab->glink->owner, LIS_R0_0 | PPC_HI (indx), p);
d6900 1
a6900 1
	      bfd_put_32 (htab->glink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
d6903 2
a6904 2
	  bfd_put_32 (htab->glink->owner,
		      B_DOT | ((htab->glink->contents - p) & 0x3fffffc), p);
d6908 1
a6908 1
      htab->glink->_cooked_size = p - htab->glink->contents;
d6911 1
a6911 1
  if (htab->brlt->_raw_size != 0)
d6913 3
a6915 3
      htab->brlt->contents = bfd_zalloc (htab->brlt->owner,
					 htab->brlt->_raw_size);
      if (htab->brlt->contents == NULL)
d6931 1
a6931 1
      || htab->glink->_raw_size != htab->glink->_cooked_size)
d6937 1
a6937 23
  if (htab->stub_error)
    return FALSE;

  if (stats != NULL)
    {
      *stats = bfd_malloc (500);
      if (*stats == NULL)
	return FALSE;

      sprintf (*stats, _("linker stubs in %u groups\n"
			 "  branch       %lu\n"
			 "  toc adjust   %lu\n"
			 "  long branch  %lu\n"
			 "  long toc adj %lu\n"
			 "  plt call     %lu"),
	       htab->stub_bfd->section_count,
	       htab->stub_count[ppc_stub_long_branch - 1],
	       htab->stub_count[ppc_stub_long_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_branch - 1],
	       htab->stub_count[ppc_stub_plt_branch_r2off - 1],
	       htab->stub_count[ppc_stub_plt_call - 1]);
    }
  return TRUE;
d6949 1
a6949 1
   relocatable output file) adjusting the reloc addend as
d6963 1
a6963 1
   When generating relocatable output, this function must handle
d6970 10
a6979 8
ppc64_elf_relocate_section (bfd *output_bfd,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
d6995 1
a6995 1
  if (info->relocatable)
d7026 1
a7026 1
      long insn, mask;
d7031 1
a7031 1
      r_type = ELF64_R_TYPE (rel->r_info);
d7033 4
a7036 4
      sym = NULL;
      sec = NULL;
      h = NULL;
      sym_name = NULL;
d7040 6
a7045 1
      if (r_symndx < symtab_hdr->sh_info)
d7156 1
a7156 5
		  {
		    if (tls_mask != 0
			&& (tls_mask & (TLS_DTPREL | TLS_TPREL)) == 0)
		      goto toctprel;
		  }
d7179 1
a7183 1
	    toctprel:
d7295 2
a7296 1
		  r_type2 = ELF64_R_TYPE (rel[1].r_info);
d7363 1
a7363 1
			 in order to get h, sym, sec etc. right.  */
d7383 2
a7384 1
		      bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
d7394 2
a7395 1
		  bfd_put_64 (output_bfd, 1, contents + rel->r_offset);
d7452 1
a7452 1
	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
d7456 8
a7463 13
	  /* Calls to functions with a different TOC, such as calls to
	     shared objects, need to alter the TOC pointer.  This is
	     done using a linkage stub.  A REL24 branching to these
	     linkage stubs needs to be followed by a nop, as the nop
	     will be replaced with an instruction to restore the TOC
	     base pointer.  */
	  if (((h != NULL
		&& (fdh = ((struct ppc_link_hash_entry *) h)->oh) != NULL
		&& fdh->plt.plist != NULL)
	       || ((fdh = h, sec) != NULL
		   && sec->output_section != NULL
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off)))
d7465 1
a7465 4
						   rel, htab)) != NULL
	      && (stub_entry->stub_type == ppc_stub_plt_call
		  || stub_entry->stub_type == ppc_stub_plt_branch_r2off
		  || stub_entry->stub_type == ppc_stub_long_branch_r2off))
d7475 1
a7475 1
		      bfd_put_32 (input_bfd, LD_R2_40R1,
d7483 5
a7487 36
		  if (stub_entry->stub_type == ppc_stub_plt_call)
		    {
		      /* If this is a plain branch rather than a branch
			 and link, don't require a nop.  */
		      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      if ((insn & 1) == 0)
			can_plt_call = 1;
		    }
		  else
		    {
		      if (strcmp (input_section->output_section->name,
				  ".init") == 0
			  || strcmp (input_section->output_section->name,
				     ".fini") == 0)
			(*_bfd_error_handler)
			  (_("%s(%s+0x%lx): automatic multiple TOCs "
			     "not supported using your crt files; "
			     "recompile with -mminimal-toc or upgrade gcc"),
			   bfd_archive_filename (input_bfd),
			   input_section->name,
			   (long) rel->r_offset);
		      else
			(*_bfd_error_handler)
			  (_("%s(%s+0x%lx): sibling call optimization to `%s' "
			     "does not allow automatic multiple TOCs; "
			     "recompile with -mminimal-toc or "
			     "-fno-optimize-sibling-calls, "
			     "or make `%s' extern"),
			   bfd_archive_filename (input_bfd),
			   input_section->name,
			   (long) rel->r_offset,
			   sym_name,
			   sym_name);
		      bfd_set_error (bfd_error_bad_value);
		      ret = FALSE;
		    }
d7495 1
a7495 2
		  if (stub_entry->stub_type == ppc_stub_plt_call)
		    unresolved_reloc = FALSE;
d7591 1
a7591 1
	    if (htab->got == NULL)
d7653 2
a7654 2
		    outrel.r_offset = (htab->got->output_section->vma
				       + htab->got->output_offset
a7655 1
		    outrel.r_addend = rel->r_addend;
d7662 2
a7663 2
			    loc = htab->relgot->contents;
			    loc += (htab->relgot->reloc_count++
a7667 1
			    outrel.r_addend = rel->r_addend;
d7677 1
a7677 9
		      {
			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);

			/* Write the .got section contents for the sake
			   of prelink.  */
			loc = htab->got->contents + off;
			bfd_put_64 (output_bfd, outrel.r_addend + relocation,
				    loc);
		      }
d7680 2
a7681 2

		    if (indx == 0 && tls_type != (TLS_TLS | TLS_LD))
d7687 2
a7688 2
		    loc = htab->relgot->contents;
		    loc += (htab->relgot->reloc_count++
d7693 1
a7693 1
		/* Init the .got section contents here if we're not
d7709 1
a7709 1
					htab->got->contents + off + 8);
d7715 1
a7715 1
				htab->got->contents + off);
d7722 1
a7722 1
	    relocation = htab->got->output_offset + off;
d7746 1
a7746 1
	  if (htab->plt != NULL)
d7753 2
a7754 2
		    relocation = (htab->plt->output_section->vma
				  + htab->plt->output_offset
a7760 11
	case R_PPC64_TOC:
	  /* Relocation value is TOC base.  */
	  relocation = TOCstart;
	  if (r_symndx == 0)
	    relocation += htab->stub_group[input_section->id].toc_off;
	  else if (sec != NULL && !unresolved_reloc)
	    relocation += htab->stub_group[sec->id].toc_off;
	  else
	    unresolved_reloc = TRUE;
	  goto dodyn2;

d7771 1
a7771 1
	  addend -= TOCstart + htab->stub_group[input_section->id].toc_off;
d7781 1
a7781 1
	  if (sec != NULL)
d7867 1
a7867 1
	dodyn2:
a7892 1
	      bfd_vma out_off;
d7901 4
a7904 3
	      out_off = _bfd_elf_section_offset (output_bfd, info,
						 input_section, rel->r_offset);
	      if (out_off == (bfd_vma) -1)
d7906 1
a7906 1
	      else if (out_off == (bfd_vma) -2)
d7908 2
a7909 3
	      out_off += (input_section->output_section->vma
			  + input_section->output_offset);
	      outrel.r_offset = out_off;
a7911 11
	      /* Optimize unaligned reloc use.  */
	      if ((r_type == R_PPC64_ADDR64 && (out_off & 7) != 0)
		  || (r_type == R_PPC64_UADDR64 && (out_off & 7) == 0))
		r_type ^= R_PPC64_ADDR64 ^ R_PPC64_UADDR64;
	      else if ((r_type == R_PPC64_ADDR32 && (out_off & 3) != 0)
		       || (r_type == R_PPC64_UADDR32 && (out_off & 3) == 0))
		r_type ^= R_PPC64_ADDR32 ^ R_PPC64_UADDR32;
	      else if ((r_type == R_PPC64_ADDR16 && (out_off & 1) != 0)
		       || (r_type == R_PPC64_UADDR16 && (out_off & 1) == 0))
		r_type ^= R_PPC64_ADDR16 ^ R_PPC64_UADDR16;

d7916 1
a7916 2
		       && !is_opd
		       && r_type != R_PPC64_TOC)
d7924 2
a7942 6

		      /* We need to relocate .opd contents for ld.so.
			 Prelink also wants simple and consistent rules
			 for relocs.  This make all RELATIVE relocs have
			 *r_offset equal to r_addend.  */
		      relocate = TRUE;
d7984 1
a7984 2
		 anything now.  However, for the sake of prelink ensure
		 that the section contents are a known value.  */
d7986 1
a7986 20
		{
		  unresolved_reloc = FALSE;
		  /* The value chosen here is quite arbitrary as ld.so
		     ignores section contents except for the special
		     case of .opd where the contents might be accessed
		     before relocation.  Choose zero, as that won't
		     cause reloc overflow.  */
		  relocation = 0;
		  addend = 0;
		  /* Use *r_offset == r_addend for R_PPC64_ADDR64 relocs
		     to improve backward compatibility with older
		     versions of ld.  */
		  if (r_type == R_PPC64_ADDR64)
		    addend = outrel.r_addend;
		  /* Adjust pc_relative relocs to have zero in *r_offset.  */
		  else if (ppc64_elf_howto_table[r_type]->pc_relative)
		    addend = (input_section->output_section->vma
			      + input_section->output_offset
			      + rel->r_offset);
		}
d8011 1
a8011 1
	     ppc64_elf_howto_table[r_type]->name, sym_name);
d8075 1
a8075 11
	  insn = bfd_get_32 (input_bfd, contents + (rel->r_offset & ~3));
	  mask = 3;
	  /* If this reloc is against an lq insn, then the value must be
	     a multiple of 16.  This is somewhat of a hack, but the
	     "correct" way to do this by defining _DQ forms of all the
	     _DS relocs bloats all reloc switches in this file.  It
	     doesn't seem to make much sense to use any of these relocs
	     in data, so testing the insn should be safe.  */
	  if ((insn & (0x3f << 26)) == (56 << 26))
	    mask = 15;
	  if (((relocation + addend) & mask) != 0)
d8078 1
a8078 1
		(_("%s: error: relocation %s not a multiple of %d"),
d8080 1
a8080 2
		 ppc64_elf_howto_table[r_type]->name,
		 mask + 1);
d8097 2
a8098 3
	  /* If the branch is out of reach or the TOC register needs
	     adjusting, then redirect the call to the local stub for
	     this function.  */
d8102 1
a8102 6
	  if ((relocation + addend - from + max_br_offset >= 2 * max_br_offset
	       || (sec != NULL
		   && sec->output_section != NULL
		   && sec->id <= htab->top_id
		   && (htab->stub_group[sec->id].toc_off
		       != htab->stub_group[input_section->id].toc_off)))
d8151 1
a8151 1
		  && ppc64_elf_howto_table[r_type]->pc_relative)
d8163 1
a8163 1
		    (info, sym_name, ppc64_elf_howto_table[r_type]->name,
d8174 1
a8174 1
		 ppc64_elf_howto_table[r_type]->name,
d8189 5
a8193 4
ppc64_elf_finish_dynamic_symbol (bfd *output_bfd,
				 struct bfd_link_info *info,
				 struct elf_link_hash_entry *h,
				 Elf_Internal_Sym *sym)
d8213 3
a8215 3
	    if (htab->plt == NULL
		|| htab->relplt == NULL
		|| htab->glink == NULL)
d8220 2
a8221 2
	    rela.r_offset = (htab->plt->output_section->vma
			     + htab->plt->output_offset
d8226 1
a8226 1
	    loc = htab->relplt->contents;
d8243 1
a8243 1
	  || htab->relbss == NULL)
d8251 2
a8252 2
      loc = htab->relbss->contents;
      loc += htab->relbss->reloc_count++ * sizeof (Elf64_External_Rela);
d8267 2
a8268 1
ppc64_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d8272 1
a8272 1
  r_type = ELF64_R_TYPE (rela->r_info);
d8289 3
a8291 2
ppc64_elf_finish_dynamic_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
d8305 1
a8305 1
      if (sdyn == NULL || htab->got == NULL)
d8323 1
a8323 1
	      s = htab->glink;
a8324 5
	      /* We stupidly defined DT_PPC64_GLINK to be the start
		 of glink rather than the first entry point, which is
		 what ld.so needs, and now have a bigger stub to
		 support automatic multiple TOCs.  */
	      dyn.d_un.d_ptr += GLINK_CALL_STUB_SIZE - 32;
d8342 1
a8342 1
	      s = htab->plt;
d8347 1
a8347 1
	      s = htab->relplt;
d8352 1
a8352 1
	      dyn.d_un.d_val = htab->relplt->_raw_size;
d8358 1
a8358 1
	      s = htab->relplt;
d8368 1
a8368 1
	      s = htab->relplt;
d8381 1
a8381 1
  if (htab->got != NULL && htab->got->_raw_size != 0)
d8387 1
a8387 1
		  htab->got->contents);
d8390 1
a8390 1
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 8;
d8393 1
a8393 1
  if (htab->plt != NULL && htab->plt->_raw_size != 0)
d8396 1
a8396 1
      elf_section_data (htab->plt->output_section)->this_hdr.sh_entsize
d8402 49
@


1.63.10.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a30 1
#include "elf/ppc.h"
a71 1
#define bfd_elf64_mkobject		      ppc64_elf_mkobject
a91 1
#define elf_backend_special_sections	      ppc64_elf_special_sections
a2318 34
struct ppc64_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* Shortcuts to dynamic linker sections.  */
  asection *got;
  asection *relgot;

  /* TLS local dynamic got entry handling.  Suppose for multiple GOT
     sections means we potentially need one of these for each input bfd.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;
};

#define ppc64_elf_tdata(bfd) \
  ((struct ppc64_elf_obj_tdata *) (bfd)->tdata.any)

#define ppc64_tlsld_got(bfd) \
  (&ppc64_elf_tdata (bfd)->tlsld_got)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc64_elf_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct ppc64_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

a2367 20
/* Add extra PPC sections.  */

static struct bfd_elf_special_section const ppc64_elf_special_sections[]=
{
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".plt",		0,	NULL,	0,
    SHT_NOBITS,		0 },
  { ".toc",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".toc1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".tocbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a2499 12
  /* Unlike other ELF targets, we use separate GOT entries for the same
     symbol referenced from different input files.  This is to support
     automatic multiple TOC/GOT sections, where the TOC base can vary
     from one input file to another.

     Point to the BFD owning this GOT entry.  */
  bfd *owner;

  /* Zero for non-tls entries, or TLS_TLS and one of TLS_GD, TLS_LD,
     TLS_TPREL or TLS_DTPREL for tls entries.  */
  char tls_type;

d2506 4
d2538 1
a2538 12
   shared lib.  With code that gcc generates, it's vital that this be
   enabled;  In the PowerPC64 ABI, the address of a function is actually
   the address of a function descriptor, which resides in the .opd
   section.  gcc uses the descriptor directly rather than going via the
   GOT as some other ABI's do, which means that initialized function
   pointers must reference the descriptor.  Thus, a function pointer
   initialized to the address of a function in a shared library will
   either require a copy reloc, or a dynamic reloc.  Using a copy reloc
   redefines the function desctriptor symbol to point to the copy.  This
   presents a problem as a plt entry for that function is also
   initialized from the function descriptor symbol and the copy reloc
   may not be initialized first.  */
d2722 1
d2738 6
a2930 17
/* Satisfy the ELF linker by filling in some fields in our fake bfd.  */

void
ppc64_elf_init_stub_bfd (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_link_hash_table *htab;

  elf_elfheader (abfd)->e_ident[EI_CLASS] = ELFCLASS64;

/* Always hook our dynamic sections into the first bfd, which is the
   linker created stub bfd.  This ensures that the GOT header is at
   the start of the output TOC section.  */
  htab = ppc_hash_table (info);
  htab->stub_bfd = abfd;
  htab->elf.dynobj = abfd;
}

d3125 2
a3126 2
/* Create .got and .rela.got sections in ABFD, and .got in dynobj if
   not already done.  */
d3129 1
a3129 1
create_got_section (bfd *abfd, struct bfd_link_info *info)
d3131 4
a3134 3
  asection *got, *relgot;
  flagword flags;
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
d3136 2
d3139 1
a3139 17
    {
      if (! _bfd_elf_create_got_section (htab->elf.dynobj, info))
	return FALSE;

      htab->got = bfd_get_section_by_name (htab->elf.dynobj, ".got");
      if (!htab->got)
	abort ();
    }

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  got = bfd_make_section (abfd, ".got");
  if (!got
      || !bfd_set_section_flags (abfd, got, flags)
      || !bfd_set_section_alignment (abfd, got, 3))
    return FALSE;
d3141 7
a3147 4
  relgot = bfd_make_section (abfd, ".rela.got");
  if (!relgot
      || ! bfd_set_section_flags (abfd, relgot, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, relgot, 3))
a3148 3

  ppc64_elf_tdata (abfd)->got = got;
  ppc64_elf_tdata (abfd)->relgot = relgot;
d3159 4
a3165 3
  htab = ppc_hash_table (info);
  if (!htab->got)
    htab->got = bfd_get_section_by_name (dynobj, ".got");
d3172 1
a3172 1
  if (!htab->got || !htab->plt || !htab->relplt || !htab->dynbss
a3262 1
		    && dent->owner == ent->owner
d3363 1
a3363 3
	if (ent->addend == r_addend
	    && ent->owner == abfd
	    && ent->tls_type == tls_type)
a3372 1
	  ent->owner = abfd;
a3409 25
/* Find the function descriptor hash entry from the given function code
   hash entry FH.  Link the entries via their OH fields.  */
static struct ppc_link_hash_entry *
get_fdh (struct ppc_link_hash_entry *fh, struct ppc_link_hash_table *htab)
{
  struct ppc_link_hash_entry *fdh = (struct ppc_link_hash_entry *) fh->oh;

  if (fdh == NULL)
    {
      const char *fd_name = fh->elf.root.root.string + 1;

      fdh = (struct ppc_link_hash_entry *)
	elf_link_hash_lookup (&htab->elf, fd_name, FALSE, FALSE, FALSE);
      if (fdh != NULL)
	{
	  fdh->is_func_descriptor = 1;
	  fdh->oh = &fh->elf;
	  fh->is_func = 1;
	  fh->oh = &fdh->elf;
	}
    }

  return fdh;
}

d3463 2
d3490 1
a3490 1
	  ppc64_tlsld_got (abfd)->refcount += 1;
d3527 2
a3528 2
	  if (ppc64_elf_tdata (abfd)->got == NULL
	      && !create_got_section (abfd, info))
a3538 1
		    && ent->owner == abfd
a3548 1
		  ent->owner = abfd;
d3738 2
a3739 1
	    get_fdh ((struct ppc_link_hash_entry *) h, htab);
d3741 10
d4057 1
a4057 1
	  ppc64_tlsld_got (abfd)->refcount -= 1;
a4098 1
		  && ent->owner == abfd
a4146 3
  struct ppc_link_hash_entry *fh;
  struct ppc_link_hash_entry *fdh;
  bfd_boolean force_local;
d4148 1
a4148 2
  fh = (struct ppc_link_hash_entry *) h;
  if (fh->elf.root.type == bfd_link_hash_indirect)
d4151 2
a4152 2
  if (fh->elf.root.type == bfd_link_hash_warning)
    fh = (struct ppc_link_hash_entry *) fh->elf.root.u.i.link;
d4159 1
a4159 1
  if (!fh->is_func)
d4162 2
a4163 2
  if (fh->elf.root.type == bfd_link_hash_undefweak
      && (fh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR))
d4166 1
a4166 1
  for (ent = fh->elf.plt.plist; ent != NULL; ent = ent->next)
d4169 42
a4210 7
  if (ent == NULL
      || fh->elf.root.root.string[0] != '.'
      || fh->elf.root.root.string[1] == '\0')
    return TRUE;

  /* Find the corresponding function descriptor symbol.  Create it
     as undefined if necessary.  */
d4212 5
a4216 28
  fdh = get_fdh (fh, htab);
  if (fdh != NULL)
    while (fdh->elf.root.type == bfd_link_hash_indirect
	   || fdh->elf.root.type == bfd_link_hash_warning)
      fdh = (struct ppc_link_hash_entry *) fdh->elf.root.u.i.link;

  if (fdh == NULL
      && info->shared
      && (fh->elf.root.type == bfd_link_hash_undefined
	  || fh->elf.root.type == bfd_link_hash_undefweak))
    {
      bfd *abfd;
      asymbol *newsym;
      struct bfd_link_hash_entry *bh;

      abfd = fh->elf.root.u.undef.abfd;
      newsym = bfd_make_empty_symbol (abfd);
      newsym->name = fh->elf.root.root.string + 1;
      newsym->section = bfd_und_section_ptr;
      newsym->value = 0;
      newsym->flags = BSF_OBJECT;
      if (fh->elf.root.type == bfd_link_hash_undefweak)
	newsym->flags |= BSF_WEAK;

      bh = &fdh->elf.root;
      if ( !(_bfd_generic_link_add_one_symbol
	     (info, abfd, newsym->name, newsym->flags,
	      newsym->section, newsym->value, NULL, FALSE, FALSE, &bh)))
d4218 35
a4252 48
	  return FALSE;
	}
      fdh = (struct ppc_link_hash_entry *) bh;
      fdh->elf.elf_link_hash_flags &= ~ELF_LINK_NON_ELF;
      fdh->elf.size = 24;
      fdh->elf.type = STT_OBJECT;
    }

  if (fdh != NULL
      && (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0
      && (info->shared
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0
	  || (fdh->elf.root.type == bfd_link_hash_undefweak
	      && ELF_ST_VISIBILITY (fdh->elf.other) == STV_DEFAULT)))
    {
      if (fdh->elf.dynindx == -1)
	if (! bfd_elf64_link_record_dynamic_symbol (info, &fdh->elf))
	  return FALSE;
      fdh->elf.elf_link_hash_flags
	|= (fh->elf.elf_link_hash_flags & (ELF_LINK_HASH_REF_REGULAR
				      | ELF_LINK_HASH_REF_DYNAMIC
				      | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				      | ELF_LINK_NON_GOT_REF));
      if (ELF_ST_VISIBILITY (fh->elf.other) == STV_DEFAULT)
	{
	  fdh->elf.plt.plist = fh->elf.plt.plist;
	  fdh->elf.elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	}
      fdh->is_func_descriptor = 1;
      fdh->oh = &fh->elf;
      fh->oh = &fdh->elf;
    }

  /* Now that the info is on the function descriptor, clear the
     function code sym info.  Any function code syms for which we
     don't have a definition in a regular file, we force local.
     This prevents a shared library from exporting syms that have
     been imported from another library.  Function code syms that
     are really in the library we must leave global to prevent the
     linker dragging in a definition from a static library.  */
  force_local
    = (info->shared
       && ((fh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   || fdh == NULL
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   || (fdh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0));
  _bfd_elf_link_hash_hide_symbol (info, &fh->elf, force_local);
d4290 1
a4290 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4299 1
a4299 1
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
d4310 1
a4310 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4320 1
a4320 1
	  _bfd_elf_link_hash_hide_symbol (info, h, TRUE);
d4429 3
a4465 6
  if (h->plt.plist != NULL)
    return TRUE;

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

d4767 1
a4767 1
      for (rel = relstart; rel < relend; )
d4778 20
a4797 3
	  if (rel->r_offset != offset
	      || rel + 1 >= relend
	      || (rel + 1)->r_offset != offset + 8)
a4810 10
	  if ((r_type = ELF64_R_TYPE (rel->r_info)) != R_PPC64_ADDR64
	      || (r_type = ELF64_R_TYPE ((rel + 1)->r_info)) != R_PPC64_TOC)
	    {
	      (*_bfd_error_handler)
		(_("%s: unexpected reloc type %u in .opd section"),
		 bfd_archive_filename (ibfd), r_type);
	      need_edit = FALSE;
	      break;
	    }

d4814 1
a4814 1
	    goto error_ret;
a4843 5
	  rel += 2;
	  /* Allow for the possibility of a reloc on the third word.  */
	  if (rel < relend
	      && rel->r_offset == offset - 8)
	    rel += 1;
a4862 1
		error_ret:
d4866 1
a4883 10
	      unsigned long r_symndx;
	      asection *sym_sec;
	      struct elf_link_hash_entry *h;
	      Elf_Internal_Sym *sym;

	      r_symndx = ELF64_R_SYM (rel->r_info);
	      if (!get_sym_h (&h, &sym, &sym_sec, NULL, &local_syms,
			      r_symndx, ibfd))	
		goto error_ret;

d4886 8
a4893 4
		  struct ppc_link_hash_entry *fdh = NULL;
		  if (h != NULL)
		    fdh = get_fdh ((struct ppc_link_hash_entry *) h,
				   ppc_hash_table (info));
d4903 21
d4938 21
d4980 4
a4983 31
	      if (skip)
		{
		  BFD_ASSERT (MUST_BE_DYN_RELOC (ELF64_R_TYPE (rel->r_info)));
		  if (info->shared)
		    {
		      /* We won't be needing dynamic relocs here.  */
		      struct ppc_dyn_relocs **pp;
		      struct ppc_dyn_relocs *p;

		      if (h != NULL)
			pp = &((struct ppc_link_hash_entry *) h)->dyn_relocs;
		      else if (sym_sec != NULL)
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sym_sec)->local_dynrel);
		      else
			pp = ((struct ppc_dyn_relocs **)
			      &elf_section_data (sec)->local_dynrel);
		      while ((p = *pp) != NULL)
			{
			  if (p->sec == sec)
			    {
			      p->count -= 1;
			      if (p->count == 0)
				*pp = p->next;	
			      break;
			    }
			  pp = &p->next;
			}
		    }
		}
	      else
a4984 3
		  /* We need to adjust any reloc offsets to point to the
		     new opd entries.  While we're at it, we may as well
		     remove redundant relocs.  */
d5141 1
a5141 1
		    ppc64_tlsld_got (ibfd)->refcount -= 1;
a5278 1
			  && ent->owner == ibfd
d5434 1
a5434 2
		&& ent->addend == gent->addend
		&& ent->owner == gent->owner)
d5463 1
a5463 1
	    gent->got.offset = ppc64_tlsld_got (gent->owner)->offset;
d5467 1
a5467 1
	s = ppc64_elf_tdata (gent->owner)->got;
d5476 1
a5476 1
	  ppc64_elf_tdata (gent->owner)->relgot->_raw_size
d5621 10
a5644 14
      if (ppc64_tlsld_got (ibfd)->refcount > 0)
	{
	  s = ppc64_elf_tdata (ibfd)->got;
	  ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
	  s->_raw_size += 16;
	  if (info->shared)
	    {
	      srel = ppc64_elf_tdata (ibfd)->relgot;
	      srel->_raw_size += sizeof (Elf64_External_Rela);
	    }
	}
      else
	ppc64_tlsld_got (ibfd)->offset = (bfd_vma) -1;

d5680 2
a5681 2
      s = ppc64_elf_tdata (ibfd)->got;
      srel = ppc64_elf_tdata (ibfd)->relgot;
d5691 1
a5691 1
		    if (ppc64_tlsld_got (ibfd)->offset == (bfd_vma) -1)
d5693 1
a5693 1
			ppc64_tlsld_got (ibfd)->offset = s->_raw_size;
d5698 1
a5698 1
		    ent->got.offset = ppc64_tlsld_got (ibfd)->offset;
d5741 10
a5750 2
      else if (s == htab->got
	       || s == htab->plt
a5807 32
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      s = ppc64_elf_tdata (ibfd)->got;
      if (s != NULL && s != htab->got)
	{
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
	    _bfd_strip_section_from_output (info, s);
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
	      if (s->contents == NULL)
		return FALSE;
	    }
	}
      s = ppc64_elf_tdata (ibfd)->relgot;
      if (s != NULL)
	{
	  s->_cooked_size = 0;
	  if (s->_raw_size == 0)
	    _bfd_strip_section_from_output (info, s);
	  else
	    {
	      s->contents = bfd_zalloc (ibfd, s->_raw_size);
	      if (s->contents == NULL)
		return FALSE;
	      relocs = TRUE;
	      s->reloc_count = 0;
	    }
	}
    }

d6326 4
a6329 4
/* The linker repeatedly calls this function for each TOC input section
   and linker generated GOT section.  Group input bfds such that the toc
   within a group is less than 64k in size.  Will break with cute linker
   scripts that play games with dot in the output toc section.  */
a6376 4
  /* We know none of our code bearing sections will need toc stubs.  */
  if ((isec->flags & SEC_LINKER_CREATED) != 0)
    return 0;

d6388 1
a6388 1
				      0, isec->_raw_size))
d6404 1
a6404 1
      if ((insn & (0x3f << 26)) == (18 << 26)
d6554 1
d6565 1
d6819 4
a6822 5
	if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
	  {
	    stub_sec->_raw_size = 0;
	    stub_sec->_cooked_size = 0;
	  }
a6907 1
  int stub_sec_count = 0;
d6913 2
a6914 3
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
      {
	bfd_size_type size;
d6916 10
a6925 10
	/* Allocate memory to hold the linker stubs.  */
	size = stub_sec->_raw_size;
	if (size != 0)
	  {
	    stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
	    if (stub_sec->contents == NULL)
	      return FALSE;
	  }
	stub_sec->_cooked_size = 0;
      }
d7017 4
a7020 6
    if ((stub_sec->flags & SEC_LINKER_CREATED) == 0)
      {
	stub_sec_count += 1;
	if (stub_sec->_raw_size != stub_sec->_cooked_size)
	  break;
      }
d7044 1
a7044 1
	       stub_sec_count,
d7138 1
a7138 1
      unsigned long insn, mask;
d7194 1
a7194 1
	  else if (!info->executable
d7293 1
d7319 1
a7319 1
	      bfd_vma rtra;
d7321 1
a7321 1
	      if ((insn & ((0x3f << 26) | (31 << 11)))
d7324 1
a7324 1
	      else if ((insn & ((0x3f << 26) | (31 << 16)))
a7734 1
	    asection *got;
d7739 3
d7745 1
a7745 1
	      offp = &ppc64_tlsld_got (input_bfd)->offset;
a7776 1
		      && ent->owner == input_bfd
a7783 4
	    got = ppc64_elf_tdata (input_bfd)->got;
	    if (got == NULL)
	      abort ();

a7794 2
		asection *relgot = ppc64_elf_tdata (input_bfd)->relgot;

d7801 2
a7802 2
		    outrel.r_offset = (got->output_section->vma
				       + got->output_offset
d7811 2
a7812 2
			    loc = relgot->contents;
			    loc += (relgot->reloc_count++
d7832 1
a7832 1
			loc = got->contents + off;
d7845 2
a7846 2
		    loc = relgot->contents;
		    loc += (relgot->reloc_count++
d7867 1
a7867 1
					got->contents + off + 8);
d7873 1
a7873 1
				got->contents + off);
d7880 1
a7880 1
	    relocation = got->output_offset + off;
d7883 1
a7883 1
	    addend = -TOC_BASE_OFF;
d8048 2
a8049 1
		   || !SYMBOL_CALLS_LOCAL (info, h)))
d8095 2
a8096 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h)
d8289 1
a8289 1
	  if ((insn & (0x3f << 26)) == (56u << 26))
a8622 23
    }

  /* We need to handle writing out multiple GOT sections ourselves,
     since we didn't add them to DYNOBJ.  */
  while ((dynobj = dynobj->link_next) != NULL)
    {
      asection *s;
      s = ppc64_elf_tdata (dynobj)->got;
      if (s != NULL
	  && s->_raw_size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->_raw_size))
	return FALSE;
      s = ppc64_elf_tdata (dynobj)->relgot;
      if (s != NULL
	  && s->_raw_size != 0
	  && s->output_section != bfd_abs_section_ptr
	  && !bfd_set_section_contents (output_bfd, s->output_section,
					s->contents, s->output_offset,
					s->_raw_size))
	return FALSE;
@


1.63.10.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d31 1
d3039 1
a3039 1
	  sprintf (stub_name, "%08x.%s+%x",
d3051 1
a3051 1
	  sprintf (stub_name, "%08x.%x:%x+%x",
d3280 3
a3282 4
ppc64_elf_copy_indirect_symbol
  (const struct elf_backend_data *bed ATTRIBUTE_UNUSED,
   struct elf_link_hash_entry *dir,
   struct elf_link_hash_entry *ind)
d4586 1
a4586 11
    {
      /* We should never get here, but unfortunately there are versions
	 of gcc out there that improperly (for this ABI) put initialized
	 function pointers, vtable refs and suchlike in read-only
	 sections.  Allow them to proceed, but warn that this might
	 break at runtime.  */
      (*_bfd_error_handler)
	(_("copy reloc against `%s' requires lazy plt linking; "
	   "avoid setting LD_BIND_NOW=1 or upgrade gcc"),
	 h->root.root.string);
    }
d6099 2
d6113 1
d6116 20
a6135 2
  stub_entry->stub_offset = stub_entry->stub_sec->_cooked_size;
  loc = stub_entry->stub_sec->contents + stub_entry->stub_offset;
d6149 2
a6150 2
	      + stub_entry->stub_sec->output_offset
	      + stub_entry->stub_sec->output_section->vma);
d6160 1
a6160 1
	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
d6162 1
a6162 1
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6164 1
a6164 1
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
d6169 1
a6169 1
      bfd_put_32 (htab->stub_bfd, B_DOT | (off & 0x3fffffc), loc);
d6230 1
a6230 1
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d6232 1
a6232 1
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d6241 1
a6241 1
	  bfd_put_32 (htab->stub_bfd, STD_R2_40R1, loc);
d6243 1
a6243 1
	  bfd_put_32 (htab->stub_bfd, ADDIS_R12_R2 | PPC_HA (indx), loc);
d6245 1
a6245 1
	  bfd_put_32 (htab->stub_bfd, LD_R11_0R12 | PPC_LO (indx), loc);
d6247 1
a6247 1
	  bfd_put_32 (htab->stub_bfd, ADDIS_R2_R2 | PPC_HA (r2off), loc);
d6249 1
a6249 1
	  bfd_put_32 (htab->stub_bfd, ADDI_R2_R2 | PPC_LO (r2off), loc);
d6253 1
a6253 1
      bfd_put_32 (htab->stub_bfd, MTCTR_R11, loc);
d6255 1
a6255 1
      bfd_put_32 (htab->stub_bfd, BCTR, loc);
d6302 1
a6302 1
      p = build_plt_stub (htab->stub_bfd, loc, off);
d6311 1
a6311 25
  stub_entry->stub_sec->_cooked_size += size;

  if (htab->emit_stub_syms
      && !(stub_entry->stub_type == ppc_stub_plt_call
	   && stub_entry->h->oh->root.type == bfd_link_hash_defined
	   && stub_entry->h->oh->root.u.def.section == stub_entry->stub_sec
	   && stub_entry->h->oh->root.u.def.value == stub_entry->stub_offset))
    {
      struct elf_link_hash_entry *h;
      h = elf_link_hash_lookup (&htab->elf, stub_entry->root.string,
				TRUE, FALSE, FALSE);
      if (h == NULL)
	return FALSE;
      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = stub_entry->stub_sec;
	  h->root.u.def.value = stub_entry->stub_offset;
	  h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
				    | ELF_LINK_HASH_DEF_REGULAR
				    | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				    | ELF_LINK_FORCED_LOCAL);
	}
    }

d6597 1
a6597 2
     the correct TOC value for R_PPC64_TOC relocs that don't have or
     can't find their function symbol (shouldn't ever happen now).  */
a7096 17
      if (htab->emit_stub_syms)
	{
	  struct elf_link_hash_entry *h;
	  h = elf_link_hash_lookup (&htab->elf, "__glink", TRUE, FALSE, FALSE);
	  if (h == NULL)
	    return FALSE;
	  if (h->root.type == bfd_link_hash_new)
	    {
	      h->root.type = bfd_link_hash_defined;
	      h->root.u.def.section = htab->glink;
	      h->root.u.def.value = 0;
	      h->elf_link_hash_flags = (ELF_LINK_HASH_REF_REGULAR
					| ELF_LINK_HASH_DEF_REGULAR
					| ELF_LINK_HASH_REF_REGULAR_NONWEAK
					| ELF_LINK_FORCED_LOCAL);
	    }
	}
a7298 10

      /* For old style R_PPC64_TOC relocs with a zero symbol, use the
	 symbol of the previous ADDR64 reloc.  The symbol gives us the
	 proper TOC base to use.  */
      if (rel->r_info == ELF64_R_INFO (0, R_PPC64_TOC)
	  && rel != relocs
	  && ELF64_R_TYPE (rel[-1].r_info) == R_PPC64_ADDR64
	  && is_opd)
	r_symndx = ELF64_R_SYM (rel[-1].r_info);

d7324 5
a7328 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
d7330 32
a7758 7
		    }
		  else if (h != NULL
			   && strcmp (h->root.root.string,
				      ".__libc_start_main") == 0)
		    {
		      /* Allow crt1 branch to go via a toc adjusting stub.  */
		      can_plt_call = 1;
@


1.63.10.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a4 1
   Largely rewritten by Alan Modra <amodra@@bigpond.net.au>
d67 1
a79 2
#define elf_backend_grok_prstatus	      ppc64_elf_grok_prstatus
#define elf_backend_grok_psinfo		      ppc64_elf_grok_psinfo
a2374 39
/* Support for core dump NOTE sections.  */

static bfd_boolean
ppc64_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t offset, raw_size;

  if (note->descsz != 504)
    return FALSE;

  /* pr_cursig */
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

  /* pr_pid */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

  /* pr_reg */
  offset = 112;
  raw_size = 384;

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
ppc64_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz != 136)
    return FALSE;

  elf_tdata (abfd)->core_program
    = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
  elf_tdata (abfd)->core_command
    = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);

  return TRUE;
}

d2408 14
a2421 7
  { ".sdata",   6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",    5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".plt",     4,  0, SHT_NOBITS,   0 },
  { ".toc",     4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".toc1",    5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".tocbss",  7,  0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,       0,  0, 0,            0 }
d2806 3
d4801 1
a4801 2
get_tls_mask (char **tls_maskp, unsigned long *toc_symndx,
	      Elf_Internal_Sym **locsymsp,
d4805 1
a4805 1
  int next_r;
d4834 11
a4844 8
  if (toc_symndx != NULL)
    *toc_symndx = r_symndx;
  if ((h == NULL
       || ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
      && (next_r == -1 || next_r == -2))
    return 1 - next_r;
d5024 1
a5024 1
			      r_symndx, ibfd))
d5100 1
a5100 1
				*pp = p->next;
d5143 1
a5143 1
/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
d5145 1
a5145 1
asection *
d5148 1
d5151 5
d5157 2
d5170 1
a5170 1
  return _bfd_elf_tls_setup (obfd, info);
d5253 1
a5253 1
		    value -= htab->elf.tls_sec->vma;
d5328 1
a5328 1
			    retval = get_tls_mask (&toc_tls, NULL, &locsyms,
a6335 1
  struct bfd_link_info *info;
d6342 1
a6342 3
  info = in_arg;

  htab = ppc_hash_table (info);
a6408 3

	      if (info->shared)
		htab->relbrlt->_raw_size += sizeof (Elf64_External_Rela);
d6912 1
a6912 1
		      if (!get_tls_mask (&tls_mask, NULL, &local_syms,
a6988 5
      if (info->shared)
	{
	  htab->relbrlt->_raw_size = 0;
	  htab->relbrlt->_cooked_size = 0;
	}
d6990 1
a6990 1
      bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, info);
a7192 7
  if (info->shared && htab->relbrlt->_raw_size != 0)
    {
      htab->relbrlt->contents = bfd_zalloc (htab->relbrlt->owner,
					    htab->relbrlt->_raw_size);
      if (htab->relbrlt->contents == NULL)
	return FALSE;
    }
d7318 1
a7318 1
      unsigned long r_symndx, toc_symndx;
a7319 1
      char sym_type;
d7353 1
a7353 2
	  sym_type = ELF64_ST_TYPE (sym->st_info);
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
a7369 1
	  sym_type = h->type;
a7377 1
      toc_symndx = 0;
a7387 36
	  if (tls_mask == 0 && r_type == R_PPC64_TLS)
	    {
	      /* Check for toc tls entries.  */
	      char *toc_tls;

	      if (!get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				 rel, input_bfd))
		return FALSE;

	      if (toc_tls)
		tls_mask = *toc_tls;
	    }
	}

      /* Check that tls relocs are used with tls syms, and non-tls
	 relocs are used with non-tls syms.  */
      if (r_symndx != 0
	  && r_type != R_PPC64_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && IS_PPC64_TLS_RELOC (r_type) != (sym_type == STT_TLS))
	{
	  if (r_type == R_PPC64_TLS && tls_mask != 0)
	    /* R_PPC64_TLS is OK against a symbol in the TOC.  */
	    ;
	  else
	    (*_bfd_error_handler)
	      (sym_type == STT_TLS
	       ? _("%s(%s+0x%lx): %s used with TLS symbol %s")
	       : _("%s(%s+0x%lx): %s used with non-TLS symbol %s"),
	       bfd_archive_filename (input_bfd),
	       input_section->name,
	       (long) rel->r_offset,
	       ppc64_elf_howto_table[r_type]->name,
	       sym_name);
a7401 1

d7416 1
a7416 2
	    retval = get_tls_mask (&toc_tls, &toc_symndx, &local_syms,
				   rel, input_bfd);
d7461 1
a7461 10
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7466 11
d7512 2
a7516 11
	      r_type = R_PPC64_TPREL16_LO;
	      if (toc_symndx != 0)
		{
		  rel->r_info = ELF64_R_INFO (toc_symndx, r_type);
		  /* We changed the symbol.  Start over in order to
		     get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	      else
		rel->r_info = ELF64_R_INFO (r_symndx, r_type);
d7612 2
a7613 2
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
a7614 2
		      else if (toc_symndx != 0)
			r_symndx = toc_symndx;
d7631 1
a7631 1
		  if (tls_gd == 0 || toc_symndx != 0)
d7633 2
a7634 2
		      /* We changed the symbol.  Start over in order
			 to get h, sym, sec etc. right.  */
d8016 1
a8016 1
			  outrel.r_addend -= htab->elf.tls_sec->vma;
d8033 1
a8033 1
			relocation -= htab->elf.tls_sec->vma + DTP_OFFSET;
d8097 1
a8097 3
	  else if (unresolved_reloc)
	    ;
	  else if (sec != NULL && sec->id <= htab->top_id)
d8143 1
a8143 1
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
d8161 1
a8161 1
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
d8170 1
a8170 1
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
d8174 1
a8174 1
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
@


1.63.10.13
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a94 1
#define elf_backend_link_output_symbol_hook   ppc64_elf_output_symbol_hook
d2644 1
a2644 1
   redefines the function descriptor symbol to point to the copy.  This
a2764 3
  /* Whether global opd sym has been adjusted or not.  */
  unsigned int adjust_done:1;

a2973 1
      eh->adjust_done = 0;
d3362 1
a3362 2
	  | ELF_LINK_HASH_REF_REGULAR_NONWEAK | ELF_LINK_NON_GOT_REF
	  | ELF_LINK_HASH_NEEDS_PLT);
a4876 42
/* Adjust all global syms defined in opd sections.  In gcc generated
   code these will already have been done, but I suppose we have to
   cater for all sorts of hand written assembly.  */

static bfd_boolean
adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
{
  struct ppc_link_hash_entry *eh;
  asection *sym_sec;
  long *opd_adjust;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->root.type != bfd_link_hash_defined
      && h->root.type != bfd_link_hash_defweak)
    return TRUE;

  eh = (struct ppc_link_hash_entry *) h;
  if (eh->adjust_done)
    return TRUE;

  sym_sec = eh->elf.root.u.def.section;
  if (sym_sec != NULL
      && elf_section_data (sym_sec) != NULL
      && (opd_adjust = ppc64_elf_section_data (sym_sec)->opd.adjust) != NULL)
    {
      eh->elf.root.u.def.value += opd_adjust[eh->elf.root.u.def.value / 24];
      eh->adjust_done = 1;
    }
  return TRUE;
}

/* Remove unused Official Procedure Descriptor entries.  Currently we
   only remove those associated with functions in discarded link-once
   sections, or weakly defined functions that have been overridden.  It
   would be possible to remove many more entries for statically linked
   applications.  */

a4880 1
  bfd_boolean some_edited = FALSE;
d5081 4
a5084 7
			  /* Redefine the function descriptor symbol to
			     this location in the opd section.  It is
			     necessary to update the value here rather
			     than using an array of adjustments as we do
			     for local symbols, because various places
			     in the generic ELF code use the value
			     stored in u.def.value.  */
a5085 1
			  fdh->adjust_done = 1;
d5087 10
a5096 8

		      /* Local syms are a bit tricky.  We could
			 tweak them as they can be cached, but
			 we'd need to look through the local syms
			 for the function descriptor sym which we
			 don't have at the moment.  So keep an
			 array of adjustments.  */
		      adjust[rel->r_offset / 24] = wptr - rptr;
a5154 1
	  some_edited = TRUE;
a5168 3
  if (some_edited)
    elf_link_hash_traverse (elf_hash_table (info), adjust_opd_syms, NULL);

d5264 1
a5264 11
		  {
		    value = sym->st_value;

		    if (elf_section_data (sym_sec) != NULL)
		      {
			long *adjust;
			adjust = ppc64_elf_section_data (sym_sec)->opd.adjust;
			if (adjust != NULL)
			  value += adjust[value / 24];
		      }
		  }
d6072 2
a6073 3
      if (!(h->elf.root.type == bfd_link_hash_defined
	    || h->elf.root.type == bfd_link_hash_defweak)
	  || h->elf.root.u.def.section->output_section == NULL)
a6567 3
  if (isec->_raw_size == 0)
    return 0;

d7400 1
a7400 1
	      if (opd_sym_adjust != NULL)
a8668 26
}

/* Adjust the value of any local symbols in opd sections.  */

static bfd_boolean
ppc64_elf_output_symbol_hook (struct bfd_link_info *info,
			      const char *name ATTRIBUTE_UNUSED,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h)
{
  long *adjust;
  bfd_vma value;

  if (h != NULL
      || input_sec == NULL
      || ppc64_elf_section_data (input_sec) == NULL
      || (adjust = ppc64_elf_section_data (input_sec)->opd.adjust) == NULL)
    return TRUE;

  value = elfsym->st_value - input_sec->output_offset;
  if (!info->relocatable)
    value -= input_sec->output_section->vma;

  elfsym->st_value += adjust[value / 24];
  return TRUE;
@


1.63.10.14
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a3592 9
  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d3950 4
a4168 3
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d6004 1
a6004 1
      if (s == htab->plt)
@


1.62
log
@	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.
@
text
@d1955 2
a1956 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d2444 2
a2445 1
ppc64_elf_copy_indirect_symbol (dir, ind)
d2491 1
a2491 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.61
log
@	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.
@
text
@d3756 17
a3772 1
		  if (!skip)
@


1.60
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d143 1
a143 1
	 0xff,			/* src_mask */
d174 1
a174 1
	 0xfc000003,		/* src_mask */
d251 1
a251 1
	 0xffff0003,		/* src_mask */
d268 1
a268 1
	 0xffff0003,		/* src_mask */
d285 1
a285 1
	 0xffff0003,		/* src_mask */
d300 1
a300 1
	 0xfc000003,		/* src_mask */
d315 1
a315 1
	 0xffff0003,		/* src_mask */
d332 1
a332 1
	 0xffff0003,		/* src_mask */
d349 1
a349 1
	 0xffff0003,		/* src_mask */
d682 1
a682 1
	 0x00000003,		/* src_mask */
d998 1
a998 1
	 0x0003,		/* src_mask */
d1013 1
a1013 1
	 0x0003,		/* src_mask */
d1028 1
a1028 1
	 0x0003,		/* src_mask */
d1043 1
a1043 1
	 0x0003,		/* src_mask */
d1058 1
a1058 1
	 0x0003,		/* src_mask */
d1073 1
a1073 1
	 0x0003,		/* src_mask */
d1088 1
a1088 1
	 0x0003,		/* src_mask */
d1103 1
a1103 1
	 0x0003,		/* src_mask */
d1118 1
a1118 1
	 0x0003,		/* src_mask */
d1134 1
a1134 1
	 0x0003,		/* src_mask */
d1150 1
a1150 1
	 0x0003,		/* src_mask */
@


1.59
log
@	* elf32-i386.c (elf_i386_relocate_section): Don't complain about
	unresolved debugging relocs in dynamic applications.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@a32 3
#define USE_RELA		/* we want RELA relocations, not REL.  */


@


1.59.2.1
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d1958 1
a1958 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d2446 1
a2446 2
ppc64_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d2492 1
a2492 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.59.2.2
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d146 1
a146 1
	 0,			/* src_mask */
d177 1
a177 1
	 0,			/* src_mask */
d254 1
a254 1
	 0,			/* src_mask */
d271 1
a271 1
	 0,			/* src_mask */
d288 1
a288 1
	 0,			/* src_mask */
d303 1
a303 1
	 0,			/* src_mask */
d318 1
a318 1
	 0,			/* src_mask */
d335 1
a335 1
	 0,			/* src_mask */
d352 1
a352 1
	 0,			/* src_mask */
d685 1
a685 1
	 0,			/* src_mask */
d1001 1
a1001 1
	 0,			/* src_mask */
d1016 1
a1016 1
	 0,			/* src_mask */
d1031 1
a1031 1
	 0,			/* src_mask */
d1046 1
a1046 1
	 0,			/* src_mask */
d1061 1
a1061 1
	 0,			/* src_mask */
d1076 1
a1076 1
	 0,			/* src_mask */
d1091 1
a1091 1
	 0,			/* src_mask */
d1106 1
a1106 1
	 0,			/* src_mask */
d1121 1
a1121 1
	 0,			/* src_mask */
d1137 1
a1137 1
	 0,			/* src_mask */
d1153 1
a1153 1
	 0,			/* src_mask */
d3761 1
a3761 17
		  if (skip)
		    {
		      if (h != NULL)
			{
			  /* Arrange for the function descriptor sym
			     to be dropped.  */
			  struct elf_link_hash_entry *fdh;
			  struct ppc_link_hash_entry *fh;

			  fh = (struct ppc_link_hash_entry *) h;
			  BFD_ASSERT (fh->is_func);
			  fdh = fh->oh;
			  fdh->root.u.def.value = 0;
			  fdh->root.u.def.section = sym_sec;
			}
		    }
		  else
@


1.59.2.3
log
@	* elf64-ppc.c (ppc_build_one_stub): Don't build glink stubs here.
	(ppc64_elf_build_stubs): Build them here instead.
@
text
@d4470 21
a5154 2
      unsigned int indx;

d5162 1
a5162 1
      while (p < htab->sglink->contents + GLINK_CALL_STUB_SIZE)
d5167 1
d5169 2
a5170 21
      /* Build the .glink lazy link call stubs.  */
      indx = 0;
      while (p < htab->sglink->contents + htab->sglink->_raw_size)
	{
	  if (indx < 0x8000)
	    {
	      bfd_put_32 (htab->sglink->owner, LI_R0_0 | indx, p);
	      p += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->sglink->owner, LIS_R0_0 | PPC_HI (indx), p);
	      p += 4;
	      bfd_put_32 (htab->sglink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
	      p += 4;
	    }
	  bfd_put_32 (htab->sglink->owner,
		      B_DOT | ((htab->sglink->contents - p) & 0x3fffffc), p);
	  p += 4;
	}
      htab->sglink->_cooked_size = p - htab->sglink->contents;
d5183 1
@


1.59.2.4
log
@	* elf64-ppc.c (ppc64_elf_build_stubs): Increment .glink indx.
@
text
@a5166 1
	  indx++;
@


1.59.2.5
log
@	* elf64-ppc.c (edit_opd): Correct test for discarded sections.
@
text
@d3681 6
a3686 10
	  /* opd entries are always for functions defined in the
	     current input bfd.  If the symbol isn't defined in the
	     input bfd, then we won't be using the function in this
	     bfd;  It must be defined in a linkonce section in another
	     bfd, or is weak.  It's also possible that we are
	     discarding the function due to a linker script /DISCARD/,
	     which we test for via the output_section.  */
	  if (sym_sec->owner != ibfd
	      || sym_sec->output_section == bfd_abs_section_ptr)
	    need_edit = true;
d3760 1
a3760 2
		  skip = (sym_sec->owner != ibfd
			  || sym_sec->output_section == bfd_abs_section_ptr);
@


1.59.2.6
log
@	* elf64-ppc.c (edit_opd): Only zero opd syms when function is
	completely removed.
@
text
@d3768 1
a3768 1
		      if (h != NULL && sym_sec->owner == ibfd)
@


1.59.2.7
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a3171 1
	  struct bfd_link_hash_entry *bh;
a3181 1
	  bh = &fdh->root;
d3184 2
a3185 1
		  newsym->section, newsym->value, NULL, false, false, &bh)))
a3188 1
	  fdh = (struct elf_link_hash_entry *) bh;
@


1.59.2.8
log
@	* elf64-ppc.c (edit_opd): Correct local sym adjustment.
@
text
@d3810 2
a3811 1
			  adjust[rel->r_offset / 24] = wptr - rptr;
@


1.59.2.9
log
@	Merge from mainline.
	2002-11-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c: Comment typo fixes.
	(ppc64_elf_merge_private_bfd_data): Allow BFD_ENDIAN_UNKNOWN input.
@
text
@a1663 1
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
d1791 2
a1792 2
   .	addis	%r12,%r2,xxx@@toc@@ha
   .	ld	%r11,xxx@@toc@@l(%r12)
d1798 1
a1798 1
   .	addis	%r12,%r2,xxx@@toc@@ha
d1800 2
a1801 2
   .	ld	%r11,xxx+0@@toc@@l(%r12)
   .	ld	%r2,xxx+8@@toc@@l(%r12)
d1803 1
a1803 1
   .	ld	%r11,xxx+16@@toc@@l(%r12)
@


1.59.2.10
log
@	* elf64-ppc.c (edit_opd): Correct typo.
@
text
@d3586 1
a3586 1
      relstart = _bfd_elf64_link_read_relocs (ibfd, sec, (PTR) NULL,
@


1.58
log
@	* elf64-ppc.c (ONES): Define.
	(ppc64_elf_howto_table): Use ONES here to avoid warnings.  Fill in
	missing src_mask fields.  Tweak R_PPC64_NONE, R_PPC64_COPY.  Fill
	in missing dst_mask fields on R_PPC64_PLT32, R_PPC64_PLTREL32.
@
text
@d5910 3
a5912 4
      /* FIXME: Why do we allow debugging sections to escape this error?
	 More importantly, why do we not emit dynamic relocs above in
	 debugging sections (which are ! SEC_ALLOC)?  If we had
	 emitted the dynamic reloc, we could remove the fudge here.  */
d5914 1
a5914 2
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
@


1.57
log
@	* elf64-ppc.c (ppc64_elf_get_symbol_info): Delete.
	(ppc64_elf_set_private_flags): Delete.
	(ppc64_elf_section_from_shdr): Delete.
	(ppc64_elf_merge_private_bfd_data): Remove flag checking/merging code.
	(ppc64_elf_fake_sections): Delete.
	(bfd_elf64_bfd_set_private_flags): Don't define.
	(bfd_elf64_get_symbol_info): Likewise.
	(elf_backend_section_from_shdr): Likewise.
	(elf_backend_fake_sections): Likewise.
@
text
@d129 2
d138 2
a139 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d142 1
a142 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d146 1
a146 1
	 0,			/* src_mask */
d177 2
a178 2
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
d254 2
a255 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d271 2
a272 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d288 2
a289 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d303 2
a304 2
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
d318 2
a319 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d335 2
a336 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d352 2
a353 2
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
d427 2
a428 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d431 2
a432 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc,  /* special_function */
d452 1
a452 1
	 0xffffffffffffffff,	/* dst_mask */
d485 1
a485 1
	 0xffffffffffffffff,	/* dst_mask */
d546 1
a546 1
	 0,			/* dst_mask */
d562 1
a562 1
	 0,			/* dst_mask */
d685 1
a685 1
	 0,			/* src_mask */
d703 1
a703 1
	 0xffffffffffffffff,	/* dst_mask */
d780 1
a780 1
	 0xffffffffffffffff,	/* dst_mask */
d795 1
a795 1
	 0xffffffffffffffff,	/* dst_mask */
d810 1
a810 1
	 0,			/* dst_mask */
d827 1
a827 1
	 0,			/* dst_mask */
d914 1
a914 1
	 0xffffffffffffffff,	/* dst_mask */
d1001 1
a1001 1
	 0,			/* src_mask */
d1016 1
a1016 1
	 0,			/* src_mask */
d1031 1
a1031 1
	 0,			/* src_mask */
d1046 1
a1046 1
	 0,			/* src_mask */
d1061 1
a1061 1
	 0,			/* src_mask */
d1076 1
a1076 1
	 0,			/* src_mask */
d1091 1
a1091 1
	 0,			/* src_mask */
d1106 1
a1106 1
	 0,			/* src_mask */
d1121 1
a1121 1
	 0,			/* src_mask */
d1137 1
a1137 1
	 0,			/* src_mask */
d1153 1
a1153 1
	 0,			/* src_mask */
@


1.56
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@a57 2
static void ppc64_elf_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
a59 2
static boolean ppc64_elf_set_private_flags
  PARAMS ((bfd *, flagword));
a61 2
static boolean ppc64_elf_section_from_shdr
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
a1630 16
/* Return symbol info as per usual for ELF targets, except that
   symbols in .opd are given 'd' or 'D' for type.  */

static void
ppc64_elf_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
{
  _bfd_elf_get_symbol_info (abfd, symbol, ret);
  if (ret->type == '?'
      && (symbol->flags & (BSF_GLOBAL | BSF_LOCAL)) != 0
      && strcmp (symbol->section->name, ".opd") == 0)
    ret->type = (symbol->flags & BSF_GLOBAL) != 0 ? 'D' : 'd';
}

a1651 15
/* Function to set whether a module needs the -mrelocatable bit set.  */

static boolean
ppc64_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

d1654 1
a1659 4
  flagword old_flags;
  flagword new_flags;
  boolean error;

a1676 100
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;
  if (!elf_flags_init (obfd))
    {
      /* First call, no flags set.  */
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  else if (new_flags == old_flags)
    /* Compatible flags are ok.  */
    ;

  else
    {
      /* Incompatible flags.  Warn about -mrelocatable mismatch.
	 Allow -mrelocatable-lib to be linked with either.  */
      error = false;
      if ((new_flags & EF_PPC_RELOCATABLE) != 0
	  && (old_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0)
	{
	  error = true;
	  (*_bfd_error_handler)
	    (_("%s: compiled with -mrelocatable and linked with modules compiled normally"),
	     bfd_archive_filename (ibfd));
	}
      else if ((new_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0
	       && (old_flags & EF_PPC_RELOCATABLE) != 0)
	{
	  error = true;
	  (*_bfd_error_handler)
	    (_("%s: compiled normally and linked with modules compiled with -mrelocatable"),
	     bfd_archive_filename (ibfd));
	}

      /* The output is -mrelocatable-lib iff both the input files are.  */
      if (! (new_flags & EF_PPC_RELOCATABLE_LIB))
	elf_elfheader (obfd)->e_flags &= ~EF_PPC_RELOCATABLE_LIB;

      /* The output is -mrelocatable iff it can't be -mrelocatable-lib,
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
      if (! (elf_elfheader (obfd)->e_flags & EF_PPC_RELOCATABLE_LIB)
	  && (new_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE))
	  && (old_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE)))
	elf_elfheader (obfd)->e_flags |= EF_PPC_RELOCATABLE;

      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit
	 if any module uses it.  */
      elf_elfheader (obfd)->e_flags |= (new_flags & EF_PPC_EMB);

      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);

      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = true;
	  (*_bfd_error_handler)
	    (_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	     bfd_archive_filename (ibfd), (long) new_flags, (long) old_flags);
	}

      if (error)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
    }

  return true;
}

/* Handle a PowerPC specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.  */

static boolean
ppc64_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf64_Internal_Shdr *hdr;
     const char *name;
{
  asection *newsect;
  flagword flags;

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return false;

  newsect = hdr->bfd_section;
  flags = bfd_get_section_flags (abfd, newsect);
  if (hdr->sh_flags & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  if (hdr->sh_type == SHT_ORDERED)
    flags |= SEC_SORT_ENTRIES;

  bfd_set_section_flags (abfd, newsect, flags);
a1994 2
static boolean ppc64_elf_fake_sections
  PARAMS ((bfd *, Elf64_Internal_Shdr *, asection *));
a5182 17
/* Set up any other section flags and such that may be necessary.  */

static boolean
ppc64_elf_fake_sections (abfd, shdr, asect)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf64_Internal_Shdr *shdr;
     asection *asect;
{
  if ((asect->flags & SEC_EXCLUDE) != 0)
    shdr->sh_flags |= SHF_EXCLUDE;

  if ((asect->flags & SEC_SORT_ENTRIES) != 0)
    shdr->sh_type = SHT_ORDERED;

  return true;
}

a6261 1
#define bfd_elf64_bfd_set_private_flags	      ppc64_elf_set_private_flags
a6264 1
#define bfd_elf64_get_symbol_info	      ppc64_elf_get_symbol_info
a6266 1
#define elf_backend_section_from_shdr	      ppc64_elf_section_from_shdr
a6275 1
#define elf_backend_fake_sections	      ppc64_elf_fake_sections
@


1.55
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a2038 1
  unsigned int bfd_count;
a2040 1
  Elf_Internal_Sym **all_local_syms;
a2134 2
static boolean get_local_syms
  PARAMS ((bfd *, struct ppc_link_hash_table *));
a2293 1
  htab->all_local_syms = NULL;
a3686 1
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
d3695 1
d3716 1
d3792 11
a3802 1
	      sym = htab->all_local_syms[bfd_indx] + r_symndx;
d3842 12
a3853 5
	      if (loc == NULL)
		return false;
	      if (! bfd_get_section_contents (ibfd, sec, loc, (bfd_vma) 0,
					      sec->_raw_size))
		return false;
d3890 1
a3890 1
		      sym = htab->all_local_syms[bfd_indx] + r_symndx;
d3919 6
a3924 7
			  /* Local syms are a bit tricky.  Other parts
			     of the linker re-read them so it's not
			     possible to tweak local sym values.  In
			     any case, we'd need to look through the
			     local syms for the function descriptor
			     sym which we don't have at the moment.
			     So keep an array of adjustments.  */
d3952 1
a3952 1
      else if (elf_section_data (sec)->relocs == NULL)
d3954 9
a4265 3
  if (!get_local_syms (info->input_bfds, htab))
    return false;

a4910 104
/* Read in all local syms for all input bfds.  */

static boolean
get_local_syms (input_bfd, htab)
     bfd *input_bfd;
     struct ppc_link_hash_table *htab;
{
  unsigned int bfd_indx;
  bfd *ibfd;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  bfd_size_type amt;

  if (htab->all_local_syms != NULL)
    return true;

  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  for (ibfd = input_bfd, bfd_indx = 0; ibfd != NULL; ibfd = ibfd->link_next)
    bfd_indx += 1;
  htab->bfd_count = bfd_indx;
  amt = sizeof (Elf_Internal_Sym *) * bfd_indx;
  all_local_syms = (Elf_Internal_Sym **) bfd_zmalloc (amt);
  htab->all_local_syms = all_local_syms;
  if (all_local_syms == NULL)
    return false;

  /* Walk over all the input BFDs, swapping in local symbols.  */
  for (bfd_indx = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, bfd_indx++)
    {
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Shdr *shndx_hdr;
      Elf_Internal_Sym *isym;
      Elf64_External_Sym *ext_syms, *esym, *end_sy;
      Elf_External_Sym_Shndx *shndx_buf, *shndx;
      bfd_size_type sec_size;

      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour)
	continue;

      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.
	 Unfortunately, we're going to have to read & swap them in.  */
      sec_size = symtab_hdr->sh_info;
      sec_size *= sizeof (Elf_Internal_Sym);
      local_syms = (Elf_Internal_Sym *) bfd_malloc (sec_size);
      if (local_syms == NULL)
	return false;

      all_local_syms[bfd_indx] = local_syms;
      sec_size = symtab_hdr->sh_info;
      sec_size *= sizeof (Elf64_External_Sym);
      ext_syms = (Elf64_External_Sym *) bfd_malloc (sec_size);
      if (ext_syms == NULL)
	return false;

      if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) ext_syms, sec_size, input_bfd) != sec_size)
	{
	error_ret_free_ext_syms:
	  free (ext_syms);
	  return false;
	}

      shndx_buf = NULL;
      shndx_hdr = &elf_tdata (input_bfd)->symtab_shndx_hdr;
      if (shndx_hdr->sh_size != 0)
	{
	  sec_size = symtab_hdr->sh_info;
	  sec_size *= sizeof (Elf_External_Sym_Shndx);
	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (sec_size);
	  if (shndx_buf == NULL)
	    goto error_ret_free_ext_syms;

	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) shndx_buf, sec_size, input_bfd) != sec_size)
	    {
	      free (shndx_buf);
	      goto error_ret_free_ext_syms;
	    }
	}

      /* Swap the local symbols in.  */
      for (esym = ext_syms, end_sy = esym + symtab_hdr->sh_info,
	     isym = local_syms, shndx = shndx_buf;
	   esym < end_sy;
	   esym++, isym++, shndx = (shndx ? shndx + 1 : NULL))
	bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);

      /* Now we can free the external symbols.  */
      free (shndx_buf);
      free (ext_syms);
    }

  return true;
}

a4928 1
  boolean ret = false;
a4949 7
  if (! get_local_syms (info->input_bfds, htab))
    {
      if (htab->all_local_syms)
	goto error_ret_free_local;
      return false;
    }

d4966 1
a4966 1
	  Elf_Internal_Sym *local_syms;
a4972 2
	  local_syms = htab->all_local_syms[bfd_indx];

d5021 1
a5021 4
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
d5043 12
d5126 9
a5134 1
		      goto error_ret_free_internal;
d5145 1
a5145 1
	      if (elf_section_data (section)->relocs == NULL)
d5148 9
d5185 1
a5185 9
  ret = true;

 error_ret_free_local:
  while (htab->bfd_count-- > 0)
    if (htab->all_local_syms[htab->bfd_count])
      free (htab->all_local_syms[htab->bfd_count]);
  free (htab->all_local_syms);

  return ret;
@


1.54
log
@	* cpu-powerpc.c: Comment on ordering of arch_info.
	* elf32-ppc.c (ppc_elf_object_p): New function.
	(elf_backend_object_p): Define.
	* elf64-ppc.c (ppc64_elf_object_p): New function.
	(elf_backend_object_p): Define.
@
text
@d130 1
a130 2
   relocate .opd without reloc entries.  FIXME: .opd should be trimmed
   of unused values.  */
d2007 1
d2103 2
a2104 2
  PARAMS ((bfd *abfd, struct bfd_link_info *info, Elf_Internal_Rela *rel,
	   struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
d2106 2
a2107 2
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   const Elf_Internal_Rela *relocs));
d2116 2
d2261 1
d2298 1
d2521 1
a2521 1
      htab->srelbrlt = bfd_make_section (dynobj, ".rela.branch_lt");
d2635 1
d2640 22
d2679 1
a2679 1
  boolean is_opd;
d2689 2
a2690 3
		    + symtab_hdr->sh_size / sizeof (Elf64_External_Sym));
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
d2693 24
a2716 1
  is_opd = strcmp (bfd_get_section_name (abfd, sec), ".opd") == 0;
d2853 1
a2853 1
	  if (is_opd
d2870 15
d2910 1
a2910 1
	  if (NO_OPD_RELOCS && is_opd)
d3051 2
a3052 2
ppc64_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d3058 2
d3063 1
d3077 16
a3092 1
	      return h->root.u.def.section;
d3095 2
a3096 1
	      return h->root.u.c.p->section;
d3105 8
a3112 1
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
d3115 1
a3115 1
  return NULL;
d3685 262
d4245 6
a4725 1
  unsigned int bfd_count;
d4736 2
a4737 2
  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
a4740 1
      bfd_count += 1;
a4748 1
  htab->bfd_count = bfd_count;
d4901 1
d4903 4
d4911 4
a4914 1
  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
d4920 1
a4920 3
  /* Walk over all the input BFDs, swapping in local symbols.
     If we are creating a shared library, create hash entries for the
     export stubs.  */
d4932 3
a5073 2
	      Elf_Internal_Shdr *input_rel_hdr;
	      Elf64_External_Rela *external_relocs, *erelaend, *erela;
a5074 1
	      bfd_size_type amt;
d5088 5
a5092 13
	      /* Allocate space for the external relocations.  */
	      amt = section->reloc_count;
	      amt *= sizeof (Elf64_External_Rela);
	      external_relocs = (Elf64_External_Rela *) bfd_malloc (amt);
	      if (external_relocs == NULL)
		{
		  goto error_ret_free_local;
		}

	      /* Likewise for the internal relocations.  */
	      amt = section->reloc_count;
	      amt *= sizeof (Elf_Internal_Rela);
	      internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
d5094 1
a5094 27
		{
		  free (external_relocs);
		  goto error_ret_free_local;
		}

	      /* Read in the external relocs.  */
	      input_rel_hdr = &elf_section_data (section)->rel_hdr;
	      if (bfd_seek (input_bfd, input_rel_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) external_relocs,
				input_rel_hdr->sh_size,
				input_bfd) != input_rel_hdr->sh_size)
		{
		  free (external_relocs);
		error_ret_free_internal:
		  free (internal_relocs);
		  goto error_ret_free_local;
		}

	      /* Swap in the relocs.  */
	      erela = external_relocs;
	      erelaend = erela + section->reloc_count;
	      irela = internal_relocs;
	      for (; erela < erelaend; erela++, irela++)
		bfd_elf64_swap_reloca_in (input_bfd, erela, irela);

	      /* We're done with the external relocs, free them.  */
	      free (external_relocs);
d5117 4
a5120 1
		      goto error_ret_free_internal;
d5213 1
a5213 1
		      goto error_ret_free_local;
d5224 2
a5225 1
	      free (internal_relocs);
d5485 1
a5485 1
  is_opd = strcmp (bfd_get_section_name (abfd, input_section), ".opd") == 0;
d5536 9
d5993 1
a5993 2
			     entry in this lib;  We ought to edit the
			     opd section to remove unused entries.  */
@


1.53
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d60 2
d1654 21
d6166 1
@


1.52
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Allow unresolved
	relocs in opd for non-shared too.
@
text
@d2416 1
d2420 2
a2421 1
	  len = strlen (link_sec->name) + sizeof (STUB_SUFFIX);
d2426 2
a2427 2
	  strcpy (s_name, link_sec->name);
	  strcpy (s_name + len - sizeof (STUB_SUFFIX), STUB_SUFFIX);
@


1.51
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d1739 1
a1739 1
         but each input file is either -mrelocatable or -mrelocatable-lib.  */
d2711 4
a2714 4
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */
d2718 1
a2718 1
                 table entry for a local symbol.  */
d5617 1
a5617 1
		      if (is_opd && h != NULL && info->shared)
d5622 6
a5627 1
			     lib.  In that case we won't use the opd
d5885 1
a5885 1
         it up.  */
d5912 1
a5912 1
         up.  */
@


1.50
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d4597 2
a4598 2
	bfd_elf64_swap_symbol_in (input_bfd, (const PTR *) esym,
				  (const PTR *) shndx, isym);
@


1.49
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d4597 2
a4598 1
	bfd_elf64_swap_symbol_in (input_bfd, esym, shndx, isym);
@


1.48
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d65 1
a65 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, char *));
d1778 1
a1778 1
     char *name;
@


1.47
log
@	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Don't allocate
	space for bss .plt.
@
text
@d111 1
a111 1
/* .glink entries for the first 32k functions are two instructions. */
d528 1
a528 1
	 /* FIXME: Verify.  Was complain_overflow_bitfield. */
d801 1
a801 1
  /* 64-bit relocation to the symbol's procedure linkage table. */
d1391 1
a1391 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1422 1
a1422 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1431 1
a1431 1
    insn |= 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field. */
d1483 1
a1483 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1506 1
a1506 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1534 1
a1534 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1563 1
a1563 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1596 1
a1596 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d1623 1
a1623 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
d4335 1
a4335 1
   0 when no stubs will be needed, and 1 on success. */
d5233 2
a5234 2
	  insn = 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field. */
	  /* Fall thru. */
@


1.46
log
@	* elf64-ppc.c (ppc64_elf_get_symbol_info): New function.
	(bfd_elf64_get_symbol_info): Define.
	* elfxx-target.h (bfd_elfNN_get_symbol_info): Only define if undef.
@
text
@d3926 4
@


1.45
log
@	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Revert last change.
	(ppc64_elf_check_relocs): Don't set up function descriptor symbol
	strings to point inside function code sym string.
	(func_desc_adjust): Likewise.
	(ppc64_elf_hide_symbol): Rewrite code to look up function code sym.
@
text
@d58 2
d1636 16
d6129 1
@


1.45.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a57 2
static void ppc64_elf_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d63 1
a63 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
d109 1
a109 1
/* .glink entries for the first 32k functions are two instructions.  */
d526 1
a526 1
	 /* FIXME: Verify.  Was complain_overflow_bitfield.  */
d799 1
a799 1
  /* 64-bit relocation to the symbol's procedure linkage table.  */
d1389 1
a1389 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1420 1
a1420 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1429 1
a1429 1
    insn |= 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */
d1481 1
a1481 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1504 1
a1504 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1532 1
a1532 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1561 1
a1561 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1594 1
a1594 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1621 1
a1621 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
a1633 16
/* Return symbol info as per usual for ELF targets, except that
   symbols in .opd are given 'd' or 'D' for type.  */

static void
ppc64_elf_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
{
  _bfd_elf_get_symbol_info (abfd, symbol, ret);
  if (ret->type == '?'
      && (symbol->flags & (BSF_GLOBAL | BSF_LOCAL)) != 0
      && strcmp (symbol->section->name, ".opd") == 0)
    ret->type = (symbol->flags & BSF_GLOBAL) != 0 ? 'D' : 'd';
}

d1721 1
a1721 1
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
d1760 1
a1760 1
     const char *name;
d2693 4
a2696 4
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
d2700 1
a2700 1
		 table entry for a local symbol.  */
a3907 4
      /* .plt is in the bss section.  We don't initialise it.  */
      if ((s->flags & SEC_LOAD) == 0)
	continue;

d4313 1
a4313 1
   0 when no stubs will be needed, and 1 on success.  */
d4575 1
a4575 2
	bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);
d5211 2
a5212 2
	  insn = 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */
	  /* Fall thru.  */
d5594 1
a5594 1
		      if (is_opd && h != NULL)
d5599 1
a5599 6
			     lib.  The same thing happens for a weak
			     definition in an application that's
			     overridden by a strong definition in a
			     shared lib.  (I believe this is a generic
			     bug in binutils handling of weak syms.)
			     In these cases we won't use the opd
d5857 1
a5857 1
	 it up.  */
d5884 1
a5884 1
	 up.  */
a6110 1
#define bfd_elf64_get_symbol_info	      ppc64_elf_get_symbol_info
@


1.45.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d58 4
a61 2
static boolean ppc64_elf_object_p
  PARAMS ((bfd *));
d64 2
d128 2
a129 1
   relocate .opd without reloc entries.  */
a133 2
#define ONES(n) (((bfd_vma) 1 << ((n) - 1) << 1) - 1)
 
d141 2
a142 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
d145 1
a145 1
	 complain_overflow_dont, /* complain_on_overflow */
d149 1
a149 1
	 0xff,			/* src_mask */
d180 2
a181 2
	 0xfc000003,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
d257 2
a258 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d274 2
a275 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d291 2
a292 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d306 2
a307 2
	 0xfc000003,		/* src_mask */
	 0x03fffffc,		/* dst_mask */
d321 2
a322 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d338 2
a339 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d355 2
a356 2
	 0xffff0003,		/* src_mask */
	 0x0000fffc,		/* dst_mask */
d430 2
a431 2
	 0,			/* this one is variable size */
	 0,			/* bitsize */
d434 2
a435 2
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc64_elf_unhandled_reloc, /* special_function */
d455 1
a455 1
	 ONES (64),		/* dst_mask */
d488 1
a488 1
	 ONES (64),		/* dst_mask */
d549 1
a549 1
	 0xffffffff,		/* dst_mask */
d565 1
a565 1
	 0xffffffff,		/* dst_mask */
d688 1
a688 1
	 0x00000003,		/* src_mask */
d706 1
a706 1
	 ONES (64),		/* dst_mask */
d783 1
a783 1
	 ONES (64),		/* dst_mask */
d798 1
a798 1
	 ONES (64),		/* dst_mask */
d813 1
a813 1
	 ONES (64),		/* dst_mask */
d830 1
a830 1
	 ONES (64),		/* dst_mask */
d917 1
a917 1
	 ONES (64),		/* dst_mask */
d1004 1
a1004 1
	 0x0003,		/* src_mask */
d1019 1
a1019 1
	 0x0003,		/* src_mask */
d1034 1
a1034 1
	 0x0003,		/* src_mask */
d1049 1
a1049 1
	 0x0003,		/* src_mask */
d1064 1
a1064 1
	 0x0003,		/* src_mask */
d1079 1
a1079 1
	 0x0003,		/* src_mask */
d1094 1
a1094 1
	 0x0003,		/* src_mask */
d1109 1
a1109 1
	 0x0003,		/* src_mask */
d1124 1
a1124 1
	 0x0003,		/* src_mask */
d1140 1
a1140 1
	 0x0003,		/* src_mask */
d1156 1
a1156 1
	 0x0003,		/* src_mask */
d1636 17
a1652 2
/* Fix bad default arch selected for a 64 bit input bfd when the
   default is 32 bit.  */
d1655 1
a1655 1
ppc64_elf_object_p (abfd)
d1657 1
d1659 2
a1660 3
  if (abfd->arch_info->the_default && abfd->arch_info->bits_per_word == 32)
    {
      Elf_Internal_Ehdr *i_ehdr = elf_elfheader (abfd);
d1662 2
a1663 7
      if (i_ehdr->e_ident[EI_CLASS] == ELFCLASS64)
	{
	  /* Relies on arch after 32 bit default being 64 bit default.  */
	  abfd->arch_info = abfd->arch_info->next;
	  BFD_ASSERT (abfd->arch_info->bits_per_word == 64);
	}
    }
a1668 1

d1674 4
d1695 100
a1984 1
  unsigned int is_entry:1;
d2016 1
d2019 1
d2080 2
a2081 2
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d2083 2
a2084 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
a2092 2
static boolean edit_opd
  PARAMS ((bfd *, struct bfd_link_info *));
d2112 4
a2235 1
      eh->is_entry = 0;
a2415 1
	  size_t namelen;
d2419 1
a2419 2
	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
d2424 2
a2425 2
	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
d2492 1
a2492 1
      htab->srelbrlt = bfd_make_section_anyway (dynobj, ".rela.branch_lt");
a2605 1
  edir->is_entry |= eind->is_entry;
a2609 22
/* Set a flag, used by ppc64_elf_gc_mark_hook, on the entry symbol and
   symbols undefined on the command-line.  */

boolean
ppc64_elf_mark_entry_syms (info)
     struct bfd_link_info *info;
{
  struct ppc_link_hash_table *htab;
  struct bfd_sym_chain *sym;

  htab = ppc_hash_table (info);
  for (sym = info->gc_sym_list; sym; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (&htab->elf, sym->name, false, false, false);
      if (h != NULL)
	((struct ppc_link_hash_entry *) h)->is_entry = 1;
    }
  return true;
}

d2627 1
a2627 1
  asection **opd_sym_map;
d2637 3
a2639 2
		    + symtab_hdr->sh_size / sizeof (Elf64_External_Sym)
		    - symtab_hdr->sh_info);
d2642 1
a2642 24
  opd_sym_map = NULL;
  if (strcmp (bfd_get_section_name (abfd, sec), ".opd") == 0)
    {
      /* Garbage collection needs some extra help with .opd sections.
	 We don't want to necessarily keep everything referenced by
	 relocs in .opd, as that would keep all functions.  Instead,
	 if we reference an .opd symbol (a function descriptor), we
	 want to keep the function code symbol's section.  This is
	 easy for global symbols, but for local syms we need to keep
	 information about the associated function section.  Later, if
	 edit_opd deletes entries, we'll use this array to adjust
	 local syms in .opd.  */
      union opd_info {
	asection *func_section;
	long entry_adjust;
      };
      bfd_size_type amt;

      amt = sec->_raw_size * sizeof (union opd_info) / 24;
      opd_sym_map = (asection **) bfd_zalloc (abfd, amt);
      if (opd_sym_map == NULL)
	return false;
      elf_section_data (sec)->tdata = opd_sym_map;
    }
d2779 1
a2779 1
	  if (opd_sym_map != NULL
a2795 15
	  if (opd_sym_map != NULL
	      && h == NULL
	      && rel + 1 < rel_end
	      && ((enum elf_ppc_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info)
		  == R_PPC64_TOC))
	    {
	      asection *s;

	      s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,
					     r_symndx);
	      if (s == NULL)
		return false;
	      else if (s != sec)
		opd_sym_map[rel->r_offset / 24] = s;
	    }
d2821 1
a2821 1
	  if (NO_OPD_RELOCS && opd_sym_map != NULL)
d2962 2
a2963 2
ppc64_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
a2968 2
  asection *rsec = NULL;

a2971 1
      struct ppc_link_hash_entry *fdh;
d2985 1
a2985 16
	      fdh = (struct ppc_link_hash_entry *) h;

	      /* Function descriptor syms cause the associated
		 function code sym section to be marked.  */
	      if (fdh->is_func_descriptor)
		rsec = fdh->oh->root.u.def.section;

	      /* Function entry syms return NULL if they are in .opd
		 and are not ._start (or others undefined on the ld
		 command line).  Thus we avoid marking all function
		 sections, as all functions are referenced in .opd.  */ 
	      else if ((fdh->oh != NULL
			&& ((struct ppc_link_hash_entry *) fdh->oh)->is_entry)
		       || elf_section_data (sec)->tdata == NULL)
		rsec = h->root.u.def.section;
	      break;
d2988 1
a2988 2
	      rsec = h->root.u.c.p->section;
	      break;
d2997 1
a2997 8
      asection **opd_sym_section;

      rsec = bfd_section_from_elf_index (sec->owner, sym->st_shndx);
      opd_sym_section = (asection **) elf_section_data (rsec)->tdata;
      if (opd_sym_section != NULL)
	rsec = opd_sym_section[sym->st_value / 24];
      else if (elf_section_data (sec)->tdata != NULL)
	rsec = NULL;
d3000 1
a3000 1
  return rsec;
a3569 288
static boolean
edit_opd (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
{
  bfd *ibfd;
  unsigned int bfd_indx;

  for (bfd_indx = 0, ibfd = info->input_bfds;
       ibfd != NULL;
       ibfd = ibfd->link_next, bfd_indx++)
    {
      asection *sec;
      Elf_Internal_Rela *relstart, *rel, *relend;
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Sym *local_syms;
      struct elf_link_hash_entry **sym_hashes;
      bfd_vma offset;
      long *adjust;
      boolean need_edit;

      sec = bfd_get_section_by_name (ibfd, ".opd");
      if (sec == NULL)
	continue;

      adjust = (long *) elf_section_data (sec)->tdata;
      BFD_ASSERT (adjust != NULL);
      memset (adjust, 0, (size_t) sec->_raw_size * sizeof (long) / 24);

      if (sec->output_section == bfd_abs_section_ptr)
	continue;

      /* Look through the section relocs.  */
      if ((sec->flags & SEC_RELOC) == 0 || sec->reloc_count == 0)
	continue;

      local_syms = NULL;
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      sym_hashes = elf_sym_hashes (ibfd);

      /* Read the relocations.  */
      relstart = _bfd_elf64_link_read_relocs (obfd, sec, (PTR) NULL,
					      (Elf_Internal_Rela *) NULL,
					      info->keep_memory);
      if (relstart == NULL)
	return false;

      /* First run through the relocs to check they are sane, and to
	 determine whether we need to edit this opd section.  */
      need_edit = false;
      offset = 0;
      relend = relstart + sec->reloc_count;
      for (rel = relstart; rel < relend; rel++)
	{
	  enum elf_ppc_reloc_type r_type;
	  unsigned long r_symndx;
	  asection *sym_sec;
	  struct elf_link_hash_entry *h;
	  Elf_Internal_Sym *sym;

	  /* .opd contains a regular array of 24 byte entries.  We're
	     only interested in the reloc pointing to a function entry
	     point.  */
	  r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE (rel->r_info);
	  if (r_type == R_PPC64_TOC)
	    continue;

	  if (r_type != R_PPC64_ADDR64)
	    {
	      (*_bfd_error_handler)
		(_("%s: unexpected reloc type %u in .opd section"),
		 bfd_archive_filename (ibfd), r_type);
	      need_edit = false;
	      break;
	    }

	  if (rel + 1 >= relend)
	    continue;
	  r_type = (enum elf_ppc_reloc_type) ELF64_R_TYPE ((rel + 1)->r_info);
	  if (r_type != R_PPC64_TOC)
	    continue;

	  if (rel->r_offset != offset)
	    {
	      /* If someone messes with .opd alignment then after a
		 "ld -r" we might have padding in the middle of .opd.
		 Also, there's nothing to prevent someone putting
		 something silly in .opd with the assembler.  No .opd
		 optimization for them!  */ 
	      (*_bfd_error_handler)
		(_("%s: .opd is not a regular array of opd entries"),
		 bfd_archive_filename (ibfd));
	      need_edit = false;
	      break;
	    }

	  r_symndx = ELF64_R_SYM (rel->r_info);
	  sym_sec = NULL;
	  h = NULL;
	  sym = NULL;
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		sym_sec = h->root.u.def.section;
	    }
	  else
	    {
	      if (local_syms == NULL)
		{
		  local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
		  if (local_syms == NULL)
		    local_syms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
						       symtab_hdr->sh_info, 0,
						       NULL, NULL, NULL);
		  if (local_syms == NULL)
		    goto error_free_rel;
		}
	      sym = local_syms + r_symndx;
	      if ((sym->st_shndx != SHN_UNDEF
		   && sym->st_shndx < SHN_LORESERVE)
		  || sym->st_shndx > SHN_HIRESERVE)
		sym_sec = bfd_section_from_elf_index (ibfd, sym->st_shndx);
	    }

	  if (sym_sec == NULL || sym_sec->owner == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s: undefined sym `%s' in .opd section"),
		 bfd_archive_filename (ibfd),
		 h != NULL ? h->root.root.string : "<local symbol>");
	      need_edit = false;
	      break;
	    }

	  if (sym_sec->output_section == bfd_abs_section_ptr)
	    {
	      /* OK, we've found a function that's excluded from the
		 link.  */
	      need_edit = true;
	    }

	  offset += 24;
	}

      if (need_edit)
	{
	  Elf_Internal_Rela *write_rel;
	  bfd_byte *rptr, *wptr;
	  boolean skip;

	  /* This seems a waste of time as input .opd sections are all
	     zeros as generated by gcc, but I suppose there's no reason
	     this will always be so.  We might start putting something in
	     the third word of .opd entries.  */
	  if ((sec->flags & SEC_IN_MEMORY) == 0)
	    {
	      bfd_byte *loc = bfd_alloc (ibfd, sec->_raw_size);
	      if (loc == NULL
		  || !bfd_get_section_contents (ibfd, sec, loc, (bfd_vma) 0,
						sec->_raw_size))
		{
		  if (local_syms != NULL
		      && symtab_hdr->contents != (unsigned char *) local_syms)
		    free (local_syms);
		error_free_rel:
		  if (elf_section_data (sec)->relocs != relstart)
		    free (relstart);
		  return false;
		}
	      sec->contents = loc;
	      sec->flags |= (SEC_IN_MEMORY | SEC_HAS_CONTENTS);
	    }

	  elf_section_data (sec)->relocs = relstart;

	  wptr = sec->contents;
	  rptr = sec->contents;
	  write_rel = relstart;
	  skip = false;
	  offset = 0;
	  for (rel = relstart; rel < relend; rel++)
	    {
	      if (rel->r_offset == offset)
		{
		  unsigned long r_symndx;
		  asection *sym_sec;
		  struct elf_link_hash_entry *h;
		  Elf_Internal_Sym *sym;

		  r_symndx = ELF64_R_SYM (rel->r_info);
		  sym_sec = NULL;
		  h = NULL;
		  sym = NULL;
		  if (r_symndx >= symtab_hdr->sh_info)
		    {
		      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;
		      if (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
			sym_sec = h->root.u.def.section;
		    }
		  else
		    {
		      sym = local_syms + r_symndx;
		      if ((sym->st_shndx != SHN_UNDEF
			   && sym->st_shndx < SHN_LORESERVE)
			  || sym->st_shndx > SHN_HIRESERVE)
			sym_sec = bfd_section_from_elf_index (ibfd,
							      sym->st_shndx);
		    }

		  skip = sym_sec->output_section == bfd_abs_section_ptr;
		  if (!skip)
		    {
		      /* We'll be keeping this opd entry.  */

		      if (h != NULL)
			{
			  /* Redefine the function descriptor symbol
			     to this location in the opd section.
			     We've checked above that opd relocs are
			     ordered.  */
			  struct elf_link_hash_entry *fdh;
			  struct ppc_link_hash_entry *fh;

			  fh = (struct ppc_link_hash_entry *) h;
			  BFD_ASSERT (fh->is_func);
			  fdh = fh->oh;
			  fdh->root.u.def.value = wptr - sec->contents;
			}
		      else
			{
			  /* Local syms are a bit tricky.  We could
			     tweak them as they can be cached, but
			     we'd need to look through the local syms
			     for the function descriptor sym which we
			     don't have at the moment.  So keep an
			     array of adjustments.  */ 
			  adjust[(rel->r_offset + wptr - rptr) / 24]
			    = wptr - rptr;
			}

		      if (wptr != rptr)
			memcpy (wptr, rptr, 24);
		      wptr += 24;
		    }
		  rptr += 24;
		  offset += 24;
		}

	      /* We need to adjust any reloc offsets to point to the
		 new opd entries.  While we're at it, we may as well
		 remove redundant relocs.  */
	      if (!skip)
		{
		  rel->r_offset += wptr - rptr;
		  if (write_rel != rel)
		    memcpy (write_rel, rel, sizeof (*rel));
		  ++write_rel;
		}
	    }

	  sec->_cooked_size = wptr - sec->contents;
	  sec->reloc_count = write_rel - relstart;
	}
      else if (elf_section_data (sec)->relocs != relstart)
	free (relstart);

      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (!info->keep_memory)
	    free (local_syms);
	  else
	    symtab_hdr->contents = (unsigned char *) local_syms;
	}
    }

  return true;
}
     
a3867 3
  if (!edit_opd (output_bfd, info))
    return false;

d4343 1
d4354 2
a4355 2
  /* Find the top input section id.  */
  for (input_bfd = info->input_bfds, top_id = 0;
d4359 1
d4368 1
d4513 95
d4626 1
d4648 7
d4671 1
a4671 1
	  Elf_Internal_Sym *local_syms = NULL;
d4678 2
d4685 2
d4688 1
d4702 13
a4714 5
	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf64_link_read_relocs (input_bfd, section, NULL,
					       (Elf_Internal_Rela *) NULL,
					       info->keep_memory);
d4716 27
a4742 1
		goto error_ret_free_local;
a4786 12
		      if (local_syms == NULL)
			{
			  local_syms
			    = (Elf_Internal_Sym *) symtab_hdr->contents;
			  if (local_syms == NULL)
			    local_syms
			      = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
						      symtab_hdr->sh_info, 0,
						      NULL, NULL, NULL);
			  if (local_syms == NULL)
			    goto error_ret_free_internal;
			}
d4858 1
a4858 9
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		    error_ret_free_local:
		      if (local_syms != NULL
			  && (symtab_hdr->contents
			      != (unsigned char *) local_syms))
			free (local_syms);
		      return false;
d4869 1
a4869 11
	      if (elf_section_data (section)->relocs != internal_relocs)
		free (internal_relocs);
	    }

	  if (local_syms != NULL
	      && symtab_hdr->contents != (unsigned char *) local_syms)
	    {
	      if (!info->keep_memory)
		free (local_syms);
	      else
		symtab_hdr->contents = (unsigned char *) local_syms;
d4899 9
a4907 1
  return true;
d5047 17
d5129 1
a5129 1
  is_opd = elf_section_data (input_section)->tdata != NULL;
a5179 9

	  if (elf_section_data (sec) != NULL)
	    {
	      long *opd_sym_adjust;

	      opd_sym_adjust = (long *) elf_section_data (sec)->tdata;
	      if (opd_sym_adjust != NULL && sym->st_value % 24 == 0)
		relocation += opd_sym_adjust[sym->st_value / 24];
	    }
d5628 2
a5629 1
			     entry in this lib.  */
d5781 4
a5784 3
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
d5786 2
a5787 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0
d6135 1
d6139 1
d6141 1
a6141 1
#define elf_backend_object_p		      ppc64_elf_object_p
d6151 1
@


1.45.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d33 3
d146 1
a146 1
	 0,			/* src_mask */
d177 1
a177 1
	 0,			/* src_mask */
d254 1
a254 1
	 0,			/* src_mask */
d271 1
a271 1
	 0,			/* src_mask */
d288 1
a288 1
	 0,			/* src_mask */
d303 1
a303 1
	 0,			/* src_mask */
d318 1
a318 1
	 0,			/* src_mask */
d335 1
a335 1
	 0,			/* src_mask */
d352 1
a352 1
	 0,			/* src_mask */
d685 1
a685 1
	 0,			/* src_mask */
d1001 1
a1001 1
	 0,			/* src_mask */
d1016 1
a1016 1
	 0,			/* src_mask */
d1031 1
a1031 1
	 0,			/* src_mask */
d1046 1
a1046 1
	 0,			/* src_mask */
d1061 1
a1061 1
	 0,			/* src_mask */
d1076 1
a1076 1
	 0,			/* src_mask */
d1091 1
a1091 1
	 0,			/* src_mask */
d1106 1
a1106 1
	 0,			/* src_mask */
d1121 1
a1121 1
	 0,			/* src_mask */
d1137 1
a1137 1
	 0,			/* src_mask */
d1153 1
a1153 1
	 0,			/* src_mask */
d3759 1
a3759 17
		  if (skip)
		    {
		      if (h != NULL)
			{
			  /* Arrange for the function descriptor sym
			     to be dropped.  */
			  struct elf_link_hash_entry *fdh;
			  struct ppc_link_hash_entry *fh;

			  fh = (struct ppc_link_hash_entry *) h;
			  BFD_ASSERT (fh->is_func);
			  fdh = fh->oh;
			  fdh->root.u.def.value = 0;
			  fdh->root.u.def.section = sym_sec;
			}
		    }
		  else
@


1.45.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1955 1
a1955 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d2443 1
a2443 2
ppc64_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d2489 1
a2489 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.45.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d4467 21
a5151 2
      unsigned int indx;

d5159 1
a5159 1
      while (p < htab->sglink->contents + GLINK_CALL_STUB_SIZE)
d5164 1
d5166 2
a5167 21
      /* Build the .glink lazy link call stubs.  */
      indx = 0;
      while (p < htab->sglink->contents + htab->sglink->_raw_size)
	{
	  if (indx < 0x8000)
	    {
	      bfd_put_32 (htab->sglink->owner, LI_R0_0 | indx, p);
	      p += 4;
	    }
	  else
	    {
	      bfd_put_32 (htab->sglink->owner, LIS_R0_0 | PPC_HI (indx), p);
	      p += 4;
	      bfd_put_32 (htab->sglink->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
	      p += 4;
	    }
	  bfd_put_32 (htab->sglink->owner,
		      B_DOT | ((htab->sglink->contents - p) & 0x3fffffc), p);
	  p += 4;
	}
      htab->sglink->_cooked_size = p - htab->sglink->contents;
d5180 1
@


1.45.2.6
log
@merge from mainline
@
text
@a3168 1
	  struct bfd_link_hash_entry *bh;
a3178 1
	  bh = &fdh->root;
d3181 2
a3182 1
		  newsym->section, newsym->value, NULL, false, false, &bh)))
a3185 1
	  fdh = (struct elf_link_hash_entry *) bh;
d3678 6
a3683 10
	  /* opd entries are always for functions defined in the
	     current input bfd.  If the symbol isn't defined in the
	     input bfd, then we won't be using the function in this
	     bfd;  It must be defined in a linkonce section in another
	     bfd, or is weak.  It's also possible that we are
	     discarding the function due to a linker script /DISCARD/,
	     which we test for via the output_section.  */
	  if (sym_sec->owner != ibfd
	      || sym_sec->output_section == bfd_abs_section_ptr)
	    need_edit = true;
d3757 1
a3757 2
		  skip = (sym_sec->owner != ibfd
			  || sym_sec->output_section == bfd_abs_section_ptr);
d3760 1
a3760 1
		      if (h != NULL && sym_sec->owner == ibfd)
d3800 2
a3801 1
			  adjust[rel->r_offset / 24] = wptr - rptr;
a5163 1
	  indx++;
@


1.44
log
@	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Don't copy is_func
	and is_func_descriptor.
	(func_desc_adjust): Hide function code sym in shared libs unless
	there is a matching exported function descriptor sym.
@
text
@d2586 2
a2587 5
  /* We don't need to copy is_func and is_func_descriptor;  They're
     never set when copy_indirect_symbol is called for indirect
     symbols at the add_symbols stage of linking, and they're not
     relevant when copy_indirect_symbol is called for weakdefs.
     weakdefs are only held for non-function syms.  */
a2771 5
		  /* Ensure the function descriptor symbol string is
		     part of the code symbol string.  We aren't
		     changing the name here, just allowing some tricks
		     in ppc64_elf_hide_symbol.  */
		  fdh->root.root.string = h->root.root.string + 1;
a3222 1
	  fdh->root.root.string = h->root.root.string + 1;
a3504 1
      const char *name;
a3505 1
      struct ppc_link_hash_table *htab;
a3506 2
      name = h->root.root.string - 1;
      htab = ppc_hash_table (info);
d3508 39
a3546 1
	fh = elf_link_hash_lookup (&htab->elf, name, false, false, false);
@


1.43
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): Don't strip .branch_lt.
	(ppc64_elf_relocate_section): Handle unresolved relocs in opd.
@
text
@d2586 5
a2590 2
  edir->is_func |= eind->is_func;
  edir->is_func_descriptor |= eind->is_func_descriptor;
d3242 8
a3249 2
      force_local = ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
		     && info->shared);
@


1.42
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Return false for
	unresolved relocs.
	(ppc64_elf_size_dynamic_sections): Check for splt NULL.
@
text
@d4837 4
a4840 6
  if (htab->sbrlt->_raw_size == 0)
    {
      _bfd_strip_section_from_output (info, htab->sbrlt);
      if (htab->srelbrlt != NULL)
	_bfd_strip_section_from_output (info, htab->srelbrlt);
    }
d5560 10
@


1.41
log
@	* elf64-ppc.c (ppc_build_one_stub): Point undefined function syms
	at the plt call stub.
@
text
@d3900 1
a3900 1
      if (htab->splt->_raw_size != 0)
d5719 9
a5727 6
	(*_bfd_error_handler)
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
	   (long) rel->r_offset,
	   h->root.root.string);
@


1.40
log
@	* elf64-ppc.c (ppc64_elf_info_to_howto): Formatting.
	(ppc64_elf_relocate_section): Don't warn about reloc overflow when
	we've already warned about an undefined symbol.  Report more
	detail on reloc errors.
@
text
@d4156 14
@


1.39
log
@	* elf64-ppc.c (RA_REGISTER_MASK, RA_REGISTER_SHIFT): Delete.
	(ppc64_elf_howto_raw <R_PPC64_RELATIVE>): Not pc_relative or
	pcrel_offset.
@
text
@d1362 1
a1363 1
    /* Initialize howto table if needed.  */
d5078 1
d5094 1
d5151 1
d5720 1
a5720 3
      if (r == bfd_reloc_ok)
	;
      else if (r == bfd_reloc_overflow)
d5751 18
a5768 4
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, name, ppc64_elf_howto_table[(int) r_type]->name,
		  (bfd_vma) 0, input_bfd, input_section, offset)))
	    return false;
a5769 2
      else
	ret = false;
@


1.39.2.1
log
@merge from trunk
@
text
@a57 2
static void ppc64_elf_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
d63 1
a63 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
d109 1
a109 1
/* .glink entries for the first 32k functions are two instructions.  */
d526 1
a526 1
	 /* FIXME: Verify.  Was complain_overflow_bitfield.  */
d799 1
a799 1
  /* 64-bit relocation to the symbol's procedure linkage table.  */
a1361 1
  /* Initialize howto table if needed.  */
d1363 1
d1389 1
a1389 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1420 1
a1420 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1429 1
a1429 1
    insn |= 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */
d1481 1
a1481 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1504 1
a1504 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1532 1
a1532 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1561 1
a1561 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1594 1
a1594 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
d1621 1
a1621 1
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
a1633 16
/* Return symbol info as per usual for ELF targets, except that
   symbols in .opd are given 'd' or 'D' for type.  */

static void
ppc64_elf_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
{
  _bfd_elf_get_symbol_info (abfd, symbol, ret);
  if (ret->type == '?'
      && (symbol->flags & (BSF_GLOBAL | BSF_LOCAL)) != 0
      && strcmp (symbol->section->name, ".opd") == 0)
    ret->type = (symbol->flags & BSF_GLOBAL) != 0 ? 'D' : 'd';
}

d1721 1
a1721 1
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
d1760 1
a1760 1
     const char *name;
d2693 4
a2696 4
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
d2700 1
a2700 1
		 table entry for a local symbol.  */
d2772 5
d3228 1
d3239 2
a3240 8
      force_local = (info->shared
		     && ((h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0
			 || fdh == NULL
			 || (fdh->elf_link_hash_flags
			     & ELF_LINK_HASH_DEF_REGULAR) == 0
			 || (fdh->elf_link_hash_flags
			     & ELF_LINK_FORCED_LOCAL) != 0));
d3505 1
d3507 1
d3509 2
d3512 1
a3512 39
	{
	  const char *p, *q;
	  struct ppc_link_hash_table *htab;
	  char save;

	  /* We aren't supposed to use alloca in BFD because on
	     systems which do not have alloca the version in libiberty
	     calls xmalloc, which might cause the program to crash
	     when it runs out of memory.  This function doesn't have a
	     return status, so there's no way to gracefully return an
	     error.  So cheat.  We know that string[-1] can be safely
	     dereferenced;  It's either a string in an ELF string
	     table, or allocated in an objalloc structure.  */

	  p = h->root.root.string - 1;
	  save = *p;
	  *(char *) p = '.';
	  htab = ppc_hash_table (info);
	  fh = elf_link_hash_lookup (&htab->elf, p, false, false, false);
	  *(char *) p = save;

	  /* Unfortunately, if it so happens that the string we were
	     looking for was allocated immediately before this string,
	     then we overwrote the string terminator.  That's the only
	     reason the lookup should fail.  */
	  if (fh == NULL)
	    {
	      q = h->root.root.string + strlen (h->root.root.string);
	      while (q >= h->root.root.string && *q == *p)
		--q, --p;
	      if (q < h->root.root.string && *p == '.')
		fh = elf_link_hash_lookup (&htab->elf, p, false, false, false);
	    }
	  if (fh != NULL)
	    {
	      ((struct ppc_link_hash_entry *) h)->oh = fh;
	      ((struct ppc_link_hash_entry *) fh)->oh = h;
	    }
	}
a3873 4
      /* .plt is in the bss section.  We don't initialise it.  */
      if ((s->flags & SEC_LOAD) == 0)
	continue;

d3900 1
a3900 1
      if (htab->splt != NULL && htab->splt->_raw_size != 0)
a4155 14
      /* Do the best we can for shared libraries built without
	 exporting ".foo" for each "foo".  This can happen when symbol
	 versioning scripts strip all bar a subset of symbols.  */
      if (stub_entry->h->oh->root.type != bfd_link_hash_defined
	  && stub_entry->h->oh->root.type != bfd_link_hash_defweak)
	{
	  /* Point the symbol at the stub.  There may be multiple stubs,
	     we don't really care;  The main thing is to make this sym
	     defined somewhere.  */
	  stub_entry->h->oh->root.type = bfd_link_hash_defined;
	  stub_entry->h->oh->root.u.def.section = stub_entry->stub_sec;
	  stub_entry->h->oh->root.u.def.value = stub_entry->stub_offset;
	}

d4265 1
a4265 1
   0 when no stubs will be needed, and 1 on success.  */
d4527 1
a4527 2
	bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				  (const PTR) shndx, isym);
d4823 6
a4828 4
  /* It would be nice to strip .branch_lt from the output if the
     section is empty, but it's too late.  If we strip sections here,
     the dynamic symbol table is corrupted since the section symbol
     for the stripped section isn't written.  */
a5077 1
      boolean warned;
a5092 1
      warned = false;
a5148 1
	      warned = true;
d5162 2
a5163 2
	  insn = 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field.  */
	  /* Fall thru.  */
a5544 15
		      if (is_opd && h != NULL)
			{
			  /* Lie about opd entries.  This case occurs
			     when building shared libraries and we
			     reference a function in another shared
			     lib.  The same thing happens for a weak
			     definition in an application that's
			     overridden by a strong definition in a
			     shared lib.  (I believe this is a generic
			     bug in binutils handling of weak syms.)
			     In these cases we won't use the opd
			     entry in this lib;  We ought to edit the
			     opd section to remove unused entries.  */
			  unresolved_reloc = false;
			}
d5702 6
a5707 9
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     h->root.root.string);
	  ret = false;
	}
d5717 3
a5719 1
      if (r != bfd_reloc_ok)
d5750 4
a5753 18
	  if (r == bfd_reloc_overflow)
	    {
	      if (warned)
		continue;
	      if (!((*info->callbacks->reloc_overflow)
		    (info, name, ppc64_elf_howto_table[(int) r_type]->name,
		     rel->r_addend, input_bfd, input_section, offset)))
		return false;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, name, (int) r);
	      ret = false;
	    }
d5755 2
d5785 1
a5785 1
	 it up.  */
d5812 1
a5812 1
	 up.  */
a6038 1
#define bfd_elf64_get_symbol_info	      ppc64_elf_get_symbol_info
@


1.38
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@a65 6
/* Mask to set RA in memory instructions.  */
#define RA_REGISTER_MASK 0x001f0000

/* Value to shift register by to insert RA.  */
#define RA_REGISTER_SHIFT 16

d479 1
a479 1
	 true,			/* pc_relative */
d487 1
a487 1
	 true),			/* pcrel_offset */
@


1.37
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Reinstate code
	reloading local sym addend mistakenly removed in 2002-05-01 change.

	* dwarf2.c (struct line_head): Make prologue_length a bfd_vma.
	(read_abbrevs): Change "offset" param to bfd_vma.
	(parse_comp_unit): Change "version" and addr_size to unsigned ints.
	Change "abbrev_offset" to bfd_vma.
	(read_indirect_string): Use correct conversion chars in error
	message format string, cast bfd_vma's to unsigned long.
	(read_abbrevs): Likewise.
	(read_attribute_value): Likewise.
	(decode_line_info): Likewise.
	(scan_unit_for_functions): Likewise.
	(parse_comp_unit): Likewise.
@
text
@d5054 3
a5090 21

      if (info->relocateable)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if ((unsigned) ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }
	  continue;
	}

      /* This is a final link.  */

d6038 1
@


1.36
log
@	* elf64-ppc.c (ppc64_elf_howto_raw <R_PPC64_SECTOFF>): Change to a
	16 bit reloc.
	<R_PPC64_SECTOFF_DS>: Likewise.
	(ppc64_elf_reloc_type_lookup): Map from BFD_RELOC_16_BASEREL to
	SECTOFF reloc.
	* elf32-ppc.c (ppc_elf_howto_raw <R_PPC_SECTOFF>): Correct.
	(ppc_elf_reloc_type_lookup): Map from BFD_RELOC_16_BASEREL to
	SECTOFF reloc.
@
text
@d5131 2
@


1.35
log
@	* elf64-ppc.c (ppc64_elf_addr16_ha_reloc): Delete.
	(ppc64_elf_ha_reloc): New function.
	(ppc64_elf_brtaken_reloc): New function.
	(ppc64_elf_sectoff_reloc): New function.
	(ppc64_elf_sectoff_ha_reloc): New function.
	(ppc64_elf_toc_reloc): New function.
	(ppc64_elf_toc_ha_reloc): New function.
	(ppc64_elf_toc64_reloc): New function.
	(ppc64_elf_unhandled_reloc): New function.
	(ppc64_elf_howto_raw): Use the above.
	<R_PPC64_RELATIVE>: Mark pc_relative, pcrel_offset.
	<R_PPC64_SECTOFF>: Not pc_relative or pcrel_offset.  Fix dst_mask.
	<R_PPC64_SECTOFF_DS>: Likewise.
	(IS_ABSOLUTE_RELOC): Update.
	(struct ppc_link_hash_table): Add have_undefweak.
	(ppc64_elf_link_hash_table_create): Init.
	(func_desc_adjust): Set have_undefweak.
	(ppc64_elf_func_desc_adjust): Call func_desc_adjust earlier.  Only
	add the .sfpr blr when have_undefweak.
	(ppc64_elf_setup_section_lists): Check hash table flavour.
	(ppc64_elf_next_input_section): Move output_section->owner test to
	ppc64elf.em.
	(ppc64_elf_set_toc): Rename to ppc64_elf_toc, remove info param
	and relocatable test.  Return TOCstart and don't set elf_gp.
	(ppc64_elf_relocate_section): Correct BRTAKEN/BRNTAKEN branch
	offset calculation.  Add assert on weak sym branch tweaks.
	* elf64-ppc.h (ppc64_elf_set_toc): Delete.
	(ppc64_elf_toc): Declare.
	(ppc64_elf_next_input_section): Update.

	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_after_allocation):
	Adjust for ppc64_elf_set_toc change.  #include libbfd.h.
	(build_section_lists): Do output_section tests here.
@
text
@d620 1
a620 1
  /* 32-bit section relative relocation.  */
d623 2
a624 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d632 1
a632 1
	 0xffffffff,		/* dst_mask */
d635 1
a635 1
  /* 16-bit lower half section relative relocation.  */
d1075 2
a1076 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d1084 1
a1084 1
	 0xfffffffc,		/* dst_mask */
d1283 1
a1283 1
    case BFD_RELOC_32_BASEREL:		 ppc_reloc = R_PPC64_SECTOFF;
@


1.34
log
@	* elf64-ppc.c (CROR_151515, CROR_313131): Define.
	(ppc64_elf_relocate_section): Use them.  Don't look for plt calls
	on R_PPC64_ADDR24 relocs.  Require a nop or no link reg on plt
	call branches.  Correct undefined weak destination.
	(ppc64_elf_func_desc_adjust): Always create at least one blr in
	.sfpr, and correct case where either only savef* or restf* is
	needed.

	Long branch stubs, multiple stub sections.
	* elf64-ppc.h (ppc64_elf_setup_section_lists): Declare.
	(ppc64_elf_next_input_section): Declare.
	* elf64-ppc.c: Move linker-only prototypes.
	(STUB_SUFFIX): Define.
	(enum ppc_stub_type): New.
	(struct ppc_stub_hash_entry): New.
	(struct ppc_branch_hash_entry): New.
	(struct ppc_link_hash_entry): Add stub_cache, oh.
	(struct ppc_link_hash_table): Add stub_hash_table etc.  Remove
	sstub.  Add sbrlt, srelbrlt, has_14bit_branch, stub_iteration.
	Rename plt_overflow to stub_error.
	(ppc_stub_hash_lookup): Define.
	(ppc_branch_hash_lookup): Define.
	(stub_hash_newfunc): New function.
	(branch_hash_newfunc): New function.
	(link_hash_newfunc): Init new fields.
	(ppc64_elf_link_hash_table_create): Likewise.
	(ppc64_elf_link_hash_table_free): New function.
	(ppc_stub_name): New function.
	(ppc_get_stub_entry): New function.
	(ppc_add_stub): New function.
	(create_linkage_sections): Use bfd_make_section_anyway.  Create
	.branch_lt and .rela.branch_lt sections.  Don't create .stub.
	(ppc64_elf_check_relocs): Set has_14bit_branch on R_PPC64_REL14*,
	and set up for plt call stubs.  Link func and func desc syms.
	(ppc64_elf_gc_sweep_hook): Handle REL14* as per REL24.
	(func_desc_adjust): Avoid hash lookup when func desc sym available
	via shortcut, and set links when processing.
	(ppc64_elf_hide_symbol): Likewise.
	(allocate_dynrelocs): Don't allocate stub section here.
	(ppc64_elf_size_dynamic_sections): Handle sbrlt and srelbrlt.
	Remove sstub code.
	(ppc_type_of_stub): New function.
	(build_one_stub): Delete.
	(ppc_build_one_stub): New function.
	(ppc_size_one_stub): New function.
	(ppc64_elf_setup_section_lists): New function.
	(ppc64_elf_next_input_section): New function.
	(group_sections): New function.
	(get_local_syms): New function.
	(ppc64_elf_size_stubs): Rewrite.
	(ppc64_elf_build_stubs): Rewrite.
	(ppc64_elf_relocate_section): Look up stub entry for REL24
	relocs.  Don't propagate REL14* to dynamic objects.  Look for long
	branch stubs if REL14* or REL24 relocs won't reach.
	(bfd_elf64_bfd_link_hash_table_free): Define.
@
text
@d42 15
a56 1
static bfd_reloc_status_type ppc64_elf_addr16_ha_reloc
d242 1
a242 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d275 1
a275 1
	 bfd_elf_generic_reloc,	/* special_function */
d292 1
a292 1
	 bfd_elf_generic_reloc,	/* special_function */
d339 1
a339 1
	 bfd_elf_generic_reloc,	/* special_function */
d356 1
a356 1
	 bfd_elf_generic_reloc,	/* special_function */
d372 1
a372 1
	 bfd_elf_generic_reloc,	/* special_function */
d388 1
a388 1
	 bfd_elf_generic_reloc,	/* special_function */
d404 1
a404 1
	 bfd_elf_generic_reloc,	/* special_function */
d420 1
a420 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d439 1
a439 1
	 bfd_elf_generic_reloc,	 /* special_function */
d455 1
a455 1
	 bfd_elf_generic_reloc,	 /* special_function */
d471 1
a471 1
	 bfd_elf_generic_reloc,	/* special_function */
d485 1
a485 1
	 false,			/* pc_relative */
d493 1
a493 1
	 false),		/* pcrel_offset */
d549 1
a549 1
	 bfd_elf_generic_reloc,	/* special_function */
d581 1
a581 1
	 bfd_elf_generic_reloc,	/* special_function */
d597 1
a597 1
	 bfd_elf_generic_reloc,	/* special_function */
d613 1
a613 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
a620 2
  /* FIXME: Verify R_PPC64_SECTOFF.  Seems strange with size=2 and
     dst_mask=0.  */
d625 1
a625 1
	 true,			/* pc_relative */
d628 1
a628 1
	 bfd_elf_generic_reloc,	/* special_function */
d632 2
a633 2
	 0,			/* dst_mask */
	 true),			/* pcrel_offset */
d643 1
a643 1
	 bfd_elf_generic_reloc,	/* special_function */
d658 1
a658 1
	 bfd_elf_generic_reloc,	/* special_function */
d673 1
a673 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d681 1
a681 2
     bits.  */
  /* FIXME: Verify R_PPC64_ADDR30.  */
d737 1
a737 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d768 1
a768 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d813 1
a813 1
	 bfd_elf_generic_reloc,	/* special_function */
d830 1
a830 1
	 bfd_elf_generic_reloc,	/* special_function */
d847 1
a847 1
	 bfd_elf_generic_reloc,	/* special_function */
d864 1
a864 1
	 bfd_elf_generic_reloc,	/* special_function */
d881 1
a881 1
	 bfd_elf_generic_reloc,	/* special_function */
d900 1
a900 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d917 1
a917 1
	 bfd_elf_generic_reloc,	/* special_function */
d940 1
a940 1
	 bfd_elf_generic_reloc,	/* special_function */
d956 1
a956 1
	 bfd_elf_generic_reloc,	/* special_function */
d972 1
a972 1
	 bfd_elf_generic_reloc,	/* special_function */
d990 1
a990 1
	 ppc64_elf_addr16_ha_reloc, /* special_function */
d1035 1
a1035 1
	 bfd_elf_generic_reloc,	/* special_function */
d1050 1
a1050 1
	 bfd_elf_generic_reloc,	/* special_function */
d1065 1
a1065 1
	 bfd_elf_generic_reloc,	/* special_function */
a1072 2
  /* FIXME: Verify R_PPC64_SECTOFF.  Seems strange with size=2 and
     dst_mask=0.  */
d1077 1
a1077 1
	 true,			/* pc_relative */
d1080 1
a1080 1
	 bfd_elf_generic_reloc,	/* special_function */
d1084 2
a1085 2
	 0,			/* dst_mask */
	 true),			/* pcrel_offset */
d1095 1
a1095 1
	 bfd_elf_generic_reloc,	/* special_function */
d1110 1
a1110 1
	 bfd_elf_generic_reloc,	/* special_function */
d1125 1
a1125 1
	 bfd_elf_generic_reloc,	/* special_function */
d1141 1
a1141 1
	 bfd_elf_generic_reloc,	/* special_function */
d1157 1
a1157 1
	 bfd_elf_generic_reloc,	/* special_function */
d1381 28
a1408 3
ppc64_elf_addr16_ha_reloc (abfd, reloc_entry, symbol, data, input_section,
			   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
d1411 1
a1411 1
     PTR data ATTRIBUTE_UNUSED;
d1414 1
a1414 1
     char **error_message ATTRIBUTE_UNUSED;
d1416 5
a1420 1
  bfd_vma relocation;
d1422 3
d1426 24
d1451 16
a1466 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d1468 21
d1490 4
a1493 2
  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;
d1495 74
a1568 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1570 3
a1572 3
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
d1574 2
a1575 1
  reloc_entry->addend += (relocation & 0x8000) << 1;
d1577 2
d1582 58
d1878 3
a1880 6
  ((RTYPE) != R_PPC64_REL14			\
   && (RTYPE) != R_PPC64_REL14_BRNTAKEN		\
   && (RTYPE) != R_PPC64_REL14_BRTAKEN		\
   && (RTYPE) != R_PPC64_REL24			\
   && (RTYPE) != R_PPC64_REL32			\
   && (RTYPE) != R_PPC64_REL64)
d2028 3
d2272 1
d3168 4
d3321 2
d3327 9
a3335 1
    htab->sfpr->_raw_size = 4;
a3367 1
  elf_link_hash_traverse (&htab->elf, func_desc_adjust, (PTR) info);
d4286 2
a4287 1
  if (htab->sbrlt == NULL)
d4353 1
a4353 2
ppc64_elf_next_input_section (output_bfd, info, isec)
     bfd *output_bfd;
d4359 1
a4359 3
  if (isec->output_section != NULL
      && isec->output_section->owner == output_bfd
      && isec->output_section->index <= htab->top_index)
d4848 1
a4848 2
   move, we'll be called again.  Provide a value for TOCstart, and
   store in the output bfd elf_gp.  */
d4850 2
a4851 2
boolean
ppc64_elf_set_toc (obfd, info)
a4852 1
     struct bfd_link_info *info;
d4854 2
a4855 4
  if (!info->relocateable)
    {
      asection *s;
      bfd_vma TOCstart;
d4857 25
a4881 3
      /* The TOC consists of sections .got, .toc, .tocbss, .plt in that
	 order.  The TOC starts where the first of these sections starts.  */
      s = bfd_get_section_by_name (obfd, ".got");
d4883 4
a4886 1
	s = bfd_get_section_by_name (obfd, ".toc");
d4888 3
a4890 1
	s = bfd_get_section_by_name (obfd, ".tocbss");
d4892 4
a4895 31
	s = bfd_get_section_by_name (obfd, ".plt");
      if (s == NULL)
	{
	  /* This may happen for
	     o  references to TOC base (SYM@@toc / TOC[tc0]) without a
	     .toc directive
	     o  bad linker script
	     o --gc-sections and empty TOC sections

	     FIXME: Warn user?  */

	  /* Look for a likely section.  We probably won't even be
	     using TOCstart.  */
	  for (s = obfd->sections; s != NULL; s = s->next)
	    if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_READONLY))
		== (SEC_ALLOC | SEC_SMALL_DATA))
	      break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA))
		  == (SEC_ALLOC | SEC_SMALL_DATA))
		break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & (SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
		break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & SEC_ALLOC) == SEC_ALLOC)
		break;
	}
d4897 3
a4899 3
      TOCstart = 0;
      if (s != NULL)
	TOCstart = s->output_section->vma + s->output_offset;
d4901 1
a4901 3
      elf_gp (obfd) = TOCstart;
    }
  return true;
d5205 4
d5210 1
a5210 1
	      if ((bfd_signed_vma) (relocation - offset) < 0)
d5271 1
d5278 1
d5281 2
a5282 1
	      if (relocation - from + (1 << 25) >= (1 << 26))
@


1.33
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@a49 52
static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *ppc64_elf_link_hash_table_create
  PARAMS ((bfd *));
static boolean create_linkage_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean ppc64_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static void ppc64_elf_copy_indirect_symbol
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
static boolean ppc64_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection * ppc64_elf_gc_mark_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, Elf_Internal_Rela *rel,
	   struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
static boolean ppc64_elf_gc_sweep_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   const Elf_Internal_Rela *relocs));
static boolean func_desc_adjust
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean ppc64_elf_func_desc_adjust
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean ppc64_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static void ppc64_elf_hide_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *, boolean));
static boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static enum elf_reloc_type_class ppc64_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static boolean ppc64_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_byte *build_plt_stub
  PARAMS ((bfd *, bfd_byte *, int, int));
static boolean build_one_stub
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean ppc64_elf_fake_sections
  PARAMS ((bfd *, Elf64_Internal_Shdr *, asection *));
static boolean ppc64_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *info, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	   asection **));
static boolean ppc64_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static boolean ppc64_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d97 4
d1652 73
a1724 1
/* ppc64 ELF linker hash entry.  */
d1730 4
d1737 3
d1751 28
a1785 1
  asection *sstub;
d1788 2
d1792 8
a1799 1
  int plt_overflow;
d1805 76
d1886 77
d1986 1
d1988 1
d2015 12
a2032 1
  htab->sstub = NULL;
d2035 5
a2039 1
  htab->plt_overflow = 0;
d2045 160
d2220 1
a2220 1
  htab->sfpr = bfd_make_section (dynobj, ".sfpr");
d2226 2
a2227 7
  /* Create .stub and .glink for global linkage functions.  */
  htab->sstub = bfd_make_section (dynobj, ".stub");
  if (htab->sstub == NULL
      || ! bfd_set_section_flags (dynobj, htab->sstub, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sstub, 2))
    return false;
  htab->sglink = bfd_make_section (dynobj, ".glink");
d2233 19
d2513 6
d2550 1
d2552 1
a2558 3
	case R_PPC64_REL14:
	case R_PPC64_REL14_BRTAKEN:
	case R_PPC64_REL14_BRNTAKEN:
d2826 3
a2837 3
	case R_PPC64_REL14:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL14_BRTAKEN:
d2938 1
a2938 1
      struct elf_link_hash_entry *fdh;
d2944 3
a2946 2
      fdh = elf_link_hash_lookup (&htab->elf, h->root.root.string + 1,
				  false, false, true);
d2995 1
d2997 1
d3032 1
d3087 8
d3096 4
a3099 1
      _bfd_strip_section_from_output (info, htab->sfpr);
d3101 1
a3101 1
  else
a3102 13
      bfd_byte *p = (bfd_byte *) bfd_alloc (htab->elf.dynobj,
					    htab->sfpr->_raw_size);
      if (p == NULL)
	return false;
      htab->sfpr->contents = p;

      for (i = lowest_savef; i <= MAX_SAVE_FPR; i++)
	{
	  unsigned int fpr = i << 21;
	  unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
	  bfd_put_32 (htab->elf.dynobj, STFD_FR0_0R1 + fpr + stackoff, p);
	  p += 4;
	}
d3105 1
d3107 10
a3116 7
      for (i = lowest_restf; i <= MAX_SAVE_FPR; i++)
	{
	  unsigned int fpr = i << 21;
	  unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
	  bfd_put_32 (htab->elf.dynobj, LFD_FR0_0R1 + fpr + stackoff, p);
	  p += 4;
	}
a3117 1
      p += 4;
d3265 1
a3265 1
      struct elf_link_hash_entry *fh;
d3270 2
a3271 1
      fh = elf_link_hash_lookup (&htab->elf, name, false, false, false);
d3330 1
a3330 4
	  /* Make room for the .stub and .glink code.  */
	  s = htab->sstub;
	  s->_raw_size += PLT_CALL_STUB_SIZE;

a3583 2
      bfd_vma size;

d3587 6
a3592 4
      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sstub
	  || s == htab->sglink)
d3638 1
a3638 7
      size = s->_raw_size;
      if (s == htab->sstub)
	{
	  /* .stub may grow.  Allocate enough for the maximum growth.  */
	  size += (size + 65536 + 65535) / 65536 * 4;
	}
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, size);
d3701 1
a3701 2
/* Called after we have seen all the input files/sections, but before
   final symbol resolution and section placement has been determined.
d3703 12
a3714 2
   We use this hook to provide a value for TOCstart, which we store in
   the output bfd elf_gp.  */
d3716 1
a3716 6
boolean
ppc64_elf_set_toc (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
{
  if (!info->relocateable)
d3718 3
a3720 13
      asection *s;
      bfd_vma TOCstart;

      /* The TOC consists of sections .got, .toc, .tocbss, .plt in that
	 order.  The TOC starts where the first of these sections starts.  */
      s = bfd_get_section_by_name (obfd, ".got");
      if (s == NULL)
	s = bfd_get_section_by_name (obfd, ".toc");
      if (s == NULL)
	s = bfd_get_section_by_name (obfd, ".tocbss");
      if (s == NULL)
	s = bfd_get_section_by_name (obfd, ".plt");
      if (s == NULL)
d3722 2
a3723 27
	  /* This may happen for
	     o  references to TOC base (SYM@@toc / TOC[tc0]) without a
	     .toc directive
	     o  bad linker script
	     o --gc-sections and empty TOC sections

	     FIXME: Warn user?  */

	  /* Look for a likely section.  We probably won't even be
	     using TOCstart.  */
	  for (s = obfd->sections; s != NULL; s = s->next)
	    if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_READONLY))
		== (SEC_ALLOC | SEC_SMALL_DATA))
	      break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA))
		  == (SEC_ALLOC | SEC_SMALL_DATA))
		break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & (SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
		break;
	  if (s == NULL)
	    for (s = obfd->sections; s != NULL; s = s->next)
	      if ((s->flags & SEC_ALLOC) == SEC_ALLOC)
		break;
d3726 3
a3728 5
      TOCstart = 0;
      if (s != NULL)
	TOCstart = s->output_section->vma + s->output_offset;

      elf_gp (obfd) = TOCstart;
a3729 2
  return true;
}
d3731 4
a3734 6
/* PowerPC64 .plt entries are 24 bytes long, which doesn't divide
   evenly into 64k.  Sometimes with a large enough .plt, we'll need to
   use offsets differing in the high 16 bits when accessing a .plt
   entry from a .plt call stub.  This function adjusts the size of
   .stub to accommodate the extra stub instruction needed in such
   cases.  */
d3736 2
a3737 9
boolean
ppc64_elf_size_stubs (obfd, info, changed)
     bfd *obfd;
     struct bfd_link_info *info;
     int *changed;
{
  struct ppc_link_hash_table *htab = ppc_hash_table (info);
  bfd_vma plt_offset, next_64k;
  long base, num, extra;
d3739 4
a3742 4
  /* .plt and .stub should be both present, or both absent.  */
  if ((htab->splt == NULL || htab->splt->_raw_size == 0)
      != (htab->sstub == NULL || htab->sstub->_raw_size == 0))
    abort ();
d3744 4
a3747 13
  /* If no .plt, then nothing to do.  */
  if (htab->splt == NULL || htab->splt->_raw_size == 0)
    return true;

  plt_offset = (htab->splt->output_section->vma
		+ htab->splt->output_offset
		- elf_gp (obfd));
  next_64k = (plt_offset + 65535) & -65536;

  /* If the .plt doesn't have any entries crossing a 64k boundary,
     then there is no need for bigger stubs.  */
  if (plt_offset + htab->splt->_raw_size <= next_64k)
    return true;
d3749 1
a3749 17
  /* OK, so we have at least one transition.  Since .plt entries are
     24 bytes long, we'll strike it lucky every 3*64k, with the 64k
     boundary between .plt entries.  */
  base = next_64k / 65536;
  num = (plt_offset + htab->splt->_raw_size - next_64k) / 65536;
  extra = (base % 3 + num + 1) * 2 / 3;

  /* Allow one extra instruction for each EXTRA.  The change in .stub
     may change the location of .toc and .plt.  .toc and .plt ought to
     move as a group, but someone might be playing with eg. .plt
     alignment, so don't allow .stub size to decrease.  */
  if (htab->sstub->_cooked_size < htab->sstub->_raw_size + extra * 4)
    {
      htab->sstub->_cooked_size = htab->sstub->_raw_size + extra * 4;
      *changed = true;
    }
  return true;
a3783 2
/* Build the stubs for one function call.  */

d3785 3
a3787 3
build_one_stub (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d3789 2
d3793 11
d3805 6
a3810 3
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
    return true;
d3812 1
a3812 2
  info = (struct bfd_link_info *) inf;
  htab = ppc_hash_table (info);
d3814 1
a3814 3
  if (htab->elf.dynamic_sections_created
      && h->plt.offset != (bfd_vma) -1
      && ((struct ppc_link_hash_entry *) h)->is_func_descriptor)
d3816 12
a3827 5
      struct elf_link_hash_entry *fh;
      asection *s;
      bfd_vma plt_r2;
      bfd_byte *p;
      unsigned int indx;
d3829 3
a3831 2
      fh = elf_link_hash_lookup (&htab->elf, h->root.root.string - 1,
				 false, false, true);
d3833 30
a3862 2
      if (fh == NULL)
	abort ();
d3864 4
a3867 1
      BFD_ASSERT (((struct ppc_link_hash_entry *) fh)->is_func);
d3869 5
a3873 6
      /* Build the .plt call stub.  */
      plt_r2 = (htab->splt->output_section->vma
		+ htab->splt->output_offset
		+ h->plt.offset
		- elf_gp (htab->splt->output_section->owner)
		- TOC_BASE_OFF);
d3875 1
a3875 2
      if (plt_r2 + 0x80000000 > 0xffffffff
	  || (plt_r2 & 3) != 0)
d3879 1
a3879 1
	     h->root.root.string);
d3881 1
a3881 1
	  htab->plt_overflow = true;
d3885 7
a3891 6
      s = htab->sstub;
      /* Steal plt.offset to store the stub offset.  */
      fh->plt.offset = s->_cooked_size;
      p = s->contents + s->_cooked_size;
      p = build_plt_stub (s->owner, p, (int) plt_r2, 0);
      s->_cooked_size = p - s->contents;
d3893 1
d3895 2
a3896 3
      s = htab->sglink;
      p = s->contents + s->_cooked_size;
      indx = s->reloc_count;
d3899 1
a3899 1
	  bfd_put_32 (s->owner, LI_R0_0 | indx, p);
d3904 1
a3904 1
	  bfd_put_32 (s->owner, LIS_R0_0 | PPC_HI (indx), p);
d3906 1
a3906 1
	  bfd_put_32 (s->owner, ORI_R0_R0_0 | PPC_LO (indx), p);
d3909 2
a3910 1
      bfd_put_32 (s->owner, B_DOT | ((s->contents - p) & 0x3fffffc), p);
d3912 381
a4292 2
      s->_cooked_size = p - s->contents;
      s->reloc_count += 1;
d4294 1
d4298 308
d4607 1
a4607 1
ppc64_elf_build_stubs (obfd, info)
d4611 62
d4674 1
a4674 1
  bfd_vma old_stub_size;
d4678 32
a4709 3
  /* If no .plt stubs, then nothing to do.  */
  if (htab->sstub == NULL || htab->sstub->_raw_size == 0)
    return true;
d4711 3
a4713 2
  old_stub_size = htab->sstub->_cooked_size;
  htab->sstub->_cooked_size = 0;
d4715 1
a4715 8
  /* Build the .glink plt call stub.  */
  plt_r2 = (htab->splt->output_section->vma
	    + htab->splt->output_offset
	    - elf_gp (obfd)
	    - TOC_BASE_OFF);
  p = htab->sglink->contents;
  p = build_plt_stub (htab->sglink->owner, p, (int) plt_r2, 1);
  while (p - htab->sglink->contents < GLINK_CALL_STUB_SIZE)
d4717 4
a4720 2
      bfd_put_32 (htab->sglink->owner, NOP, p);
      p += 4;
a4721 1
  htab->sglink->_cooked_size = p - htab->sglink->contents;
d4723 2
a4724 1
  /* Use reloc_count to count entries.  */
d4727 7
a4733 5
  elf_link_hash_traverse (&htab->elf, build_one_stub, (PTR) info);
  htab->sglink->reloc_count = 0;

  if (htab->plt_overflow)
    return false;
d4735 1
a4735 1
  if (old_stub_size != htab->sstub->_cooked_size
d4738 2
a4739 4
      (*_bfd_error_handler)
	(_("stub section size doesn't match calculated size"));
      bfd_set_error (bfd_error_bad_value);
      return false;
d4741 2
a4742 1
  return true;
d4837 1
a4841 1
      boolean has_nop;
d4843 3
a4891 1
	  addend = rel->r_addend;
d4975 5
a4979 7
	case R_PPC64_ADDR24:
	  /* An ADDR24 or REL24 branching to a linkage function may be
	     followed by a nop that we have to replace with a ld in
	     order to restore the TOC base pointer.  Only calls to
	     shared objects need to alter the TOC base.  These are
	     recognized by their need for a PLT entry.  */
	  has_nop = 0;
d4981 4
a4984 2
	      && h->plt.offset != (bfd_vma) -1
	      && htab->sstub != NULL)
d4986 1
a4986 5
	      /* plt.offset here is the offset into the stub section.  */
	      relocation = (htab->sstub->output_section->vma
			    + htab->sstub->output_offset
			    + h->plt.offset);
	      unresolved_reloc = false;
a4987 2
	      /* Make sure that there really is an instruction after
                 the branch that we can decode.  */
d4990 9
a4998 1
		  bfd_byte *pnext;
d5000 8
a5007 2
		  pnext = contents + offset + 4;
		  insn = bfd_get_32 (input_bfd, pnext);
d5009 7
a5015 9
		  if (insn == 0x60000000	 /* nop (ori  r0,r0,0) */
		      || insn == 0x4def7b82	 /* cror 15,15,15 */
		      || insn == 0x4ffffb82) /* cror 31,31,31 */
		    {
		      bfd_put_32 (input_bfd,
				  (bfd_vma) 0xe8410028, /* ld r2,40(r1) */
				  pnext);
		      has_nop = 1;
		    }
d5021 17
a5037 11
	      && r_type == R_PPC64_REL24
	      && addend == 0
	      && relocation == 0)
	    {
	      /* Tweak calls to undefined weak functions to behave as
		 if the "called" function immediately returns.  We can
		 thus call to a weak function without first checking
		 whether the function is defined.  */
	      relocation = 4;
	      if (has_nop)
		relocation = 8;
d5216 3
a5223 3
	case R_PPC64_REL14:
	case R_PPC64_REL14_BRNTAKEN:
	case R_PPC64_REL14_BRTAKEN:
d5440 28
d5813 1
@


1.32
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d1783 1
a1783 1
  htab = (struct ppc_link_hash_table *) bfd_alloc (abfd, amt);
d1789 1
a1789 1
      bfd_release (abfd, htab);
@


1.31
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Warning fix.
	(ppc64_elf_relocate_section): Don't generate power4 style branch
	hints for *_BRTAKEN and *_BRNTAKEN relocs.
@
text
@d2504 1
a2504 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d2507 3
d2880 1
a2880 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d2883 3
d3040 3
@


1.30
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2294 1
d3635 2
d3766 1
a3766 1
	  insn = 0x01 << 21; /* Set 't' bit, lowest bit of BO field. */
d3773 12
a3784 7
	  /* Set 'a' bit.  This is 0b00010 in BO field for branch on CR(BI)
	     insns (BO == 001at or 011at), and 0b01000 for branch on CTR
	     insns (BO == 1a00t or 1a01t).  */
	  if ((insn & (0x14 << 21)) == (0x04 << 21))
	    insn |= 0x02 << 21;
	  else if ((insn & (0x14 << 21)) == (0x10 << 21))
	    insn |= 0x08 << 21;
d3786 5
a3790 1
	    break;
@


1.29
log
@	* elf64-ppc.c (STFD_FR0_0R1, LFD_FR0_0R1, BLR): Define.
	(struct ppc_link_hash_table): Add sfpr.
	(ppc64_elf_link_hash_table_create): Init it.
	(ppc64_elf_create_dynamic_sections): Split creation of .stub and
	.glink out to..
	(create_linkage_sections): ..here.  Make .sfpr too.
	(ppc64_elf_check_relocs): Call create_linkage_sections, and set
	dynobj early.
	(MIN_SAVE_FPR, MAX_SAVE_FPR): Define.
	(ppc64_elf_func_desc_adjust): Look for missing ._savef* and
	._restf* functions, and create as needed.
	(func_desc_adjust): Only force_local for shared libs.

	* emulparams/elf64ppc.sh (OTHER_TEXT_SECTIONS): Define.
@
text
@d4085 1
d4092 2
a4093 1

d4099 1
a4099 4
		{
		  relocate = false;
		  memset (&outrel, 0, sizeof outrel);
		}
d4108 1
a4108 4
		{
		  relocate = false;
		  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
		}
@


1.28
log
@	* elf64-ppc.c (ppc64_elf_size_stubs): Correct test for crossing
	64k boundary.
@
text
@d54 2
d158 5
d1729 1
d1801 1
d1808 36
d1873 1
a1873 2
/* Create the .stub and .glink sections as well as the ordinary
   dynamic sections.  */
a1880 1
  flagword flags;
a1898 14
  /* Create .stub and .glink for global linkage functions.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->sstub = bfd_make_section (dynobj, ".stub");
  if (htab->sstub == NULL
      || ! bfd_set_section_flags (dynobj, htab->sstub, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sstub, 2))
    return false;
  htab->sglink = bfd_make_section (dynobj, ".glink");
  if (htab->sglink == NULL
      || ! bfd_set_section_flags (dynobj, htab->sglink, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sglink, 3))
    return false;

d1987 6
d2018 3
a2020 7
	  if (htab->sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return false;
	    }
a2230 3
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

d2585 2
a2586 1
      force_local = (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0;
d2593 3
d2597 3
a2599 3
   this hook to transfer dynamic linking information gathered so far
   on function code symbol entries, to their corresponding function
   descriptor symbol entries.  */
d2606 5
d2613 83
@


1.27
log
@Add DT_PPC64_OPD and DT_PPC64_OPDSZ dynamic tags
@
text
@d3258 1
a3258 1
  if (next_64k <= plt_offset + htab->splt->_raw_size)
@


1.26
log
@	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Check for relocs
	against section syms in readonly sections.  Don't do the global
	sym check if we find one.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_grok_prstatus): Add missing prototype.
@
text
@d159 2
a160 5
   relocate .opd without reloc entries.  FIXME: the dynamic linker
   will need to know where and how large .opd is via a couple of new
   DT_PPC64_* tags, or perhaps just with one reloc that specifies the
   start of .opd via its offset and the size via its addend.  Also,
   .opd should be trimmed of unused values.  */
d3128 7
d4361 1
d4373 12
@


1.26.2.1
log
@Add DT_PPC64_OPD and DT_PPC64_OPDSZ dynamic tags.

	* elf64-ppc.c (ppc64_elf_size_stubs): Correct test for crossing
	64k boundary.
@
text
@d159 5
a163 2
   relocate .opd without reloc entries.  FIXME: .opd should be trimmed
   of unused values.  */
a3130 7
      if (NO_OPD_RELOCS)
	{
	  if (!add_dynamic_entry (DT_PPC64_OPD, 0)
	      || !add_dynamic_entry (DT_PPC64_OPDSZ, 0))
	    return false;
	}

d3254 1
a3254 1
  if (plt_offset + htab->splt->_raw_size <= next_64k)
a4356 1
	  asection *s;
a4367 12
	      break;

	    case DT_PPC64_OPD:
	      s = bfd_get_section_by_name (output_bfd, ".opd");
	      if (s != NULL)
		dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_PPC64_OPDSZ:
	      s = bfd_get_section_by_name (output_bfd, ".opd");
	      if (s != NULL)
		dyn.d_un.d_val = s->_raw_size;
@


1.26.2.2
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a3964 1
	      relocate = false;
d3971 1
a3971 2
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = true, relocate = true;
d3977 4
a3980 1
		memset (&outrel, 0, sizeof outrel);
d3989 4
a3992 1
		outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
@


1.26.2.3
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Warning fix.
	(ppc64_elf_relocate_section): Don't generate power4 style branch
	hints for *_BRTAKEN and *_BRNTAKEN relocs.

	* elf64-ppc.c (STFD_FR0_0R1, LFD_FR0_0R1, BLR): Define.
	(struct ppc_link_hash_table): Add sfpr.
	(ppc64_elf_link_hash_table_create): Init it.
	(ppc64_elf_create_dynamic_sections): Split creation of .stub and
	.glink out to..
	(create_linkage_sections): ..here.  Make .sfpr too.
	(ppc64_elf_check_relocs): Call create_linkage_sections, and set
	dynobj early.
	(MIN_SAVE_FPR, MAX_SAVE_FPR): Define.
	(ppc64_elf_func_desc_adjust): Look for missing ._savef* and
	._restf* functions, and create as needed.
	(func_desc_adjust): Only force_local for shared libs.
@
text
@a53 2
static boolean create_linkage_sections
  PARAMS ((bfd *, struct bfd_link_info *));
a155 5
/* Instructions to save and restore floating point regs.  */
#define STFD_FR0_0R1	0xd8010000	/* stfd  %fr0,0(%r1)	*/
#define LFD_FR0_0R1	0xc8010000	/* lfd   %fr0,0(%r1)	*/
#define BLR		0x4e800020	/* blr			*/

a1721 1
  asection *sfpr;
a1792 1
  htab->sfpr = NULL;
a1798 36
/* Create sections for linker generated code.  */

static boolean
create_linkage_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct ppc_link_hash_table *htab;
  flagword flags;

  htab = ppc_hash_table (info);

  /* Create .sfpr for code to save and restore fp regs.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  htab->sfpr = bfd_make_section (dynobj, ".sfpr");
  if (htab->sfpr == NULL
      || ! bfd_set_section_flags (dynobj, htab->sfpr, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sfpr, 2))
    return false;

  /* Create .stub and .glink for global linkage functions.  */
  htab->sstub = bfd_make_section (dynobj, ".stub");
  if (htab->sstub == NULL
      || ! bfd_set_section_flags (dynobj, htab->sstub, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sstub, 2))
    return false;
  htab->sglink = bfd_make_section (dynobj, ".glink");
  if (htab->sglink == NULL
      || ! bfd_set_section_flags (dynobj, htab->sglink, flags)
      || ! bfd_set_section_alignment (dynobj, htab->sglink, 2))
    return false;

  return true;
}

d1828 2
a1829 1
/* Create the dynamic sections, and set up shortcuts.  */
d1837 1
d1856 14
a1957 6
  if (htab->elf.dynobj == NULL)
    htab->elf.dynobj = abfd;
  if (htab->sfpr == NULL
      && !create_linkage_sections (htab->elf.dynobj, info))
    return false;

d1983 7
a1989 3
	  if (htab->sgot == NULL
	      && !create_got_section (htab->elf.dynobj, info))
	    return false;
d2200 3
a2265 1
	  break;
d2557 1
a2557 2
      force_local = ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
		     && info->shared);
a2563 3
#define MIN_SAVE_FPR 14
#define MAX_SAVE_FPR 31

d2565 3
a2567 3
   this hook to a) provide some gcc support functions, and b) transfer
   dynamic linking information gathered so far on function code symbol
   entries, to their corresponding function descriptor symbol entries.  */
a2573 5
  unsigned int lowest_savef = MAX_SAVE_FPR + 2;
  unsigned int lowest_restf = MAX_SAVE_FPR + 2;
  unsigned int i;
  struct elf_link_hash_entry *h;
  char sym[10];
a2575 83

  if (htab->sfpr == NULL)
    /* We don't have any relocs.  */
    return true;

  /* First provide any missing ._savef* and ._restf* functions.  */
  memcpy (sym, "._savef14", 10);
  for (i = MIN_SAVE_FPR; i <= MAX_SAVE_FPR; i++)
    {
      sym[7] = i / 10 + '0';
      sym[8] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, false, false, true);
      if (h != NULL
	  && h->root.type == bfd_link_hash_undefined)
	{
	  if (lowest_savef > i)
	    lowest_savef = i;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = (i - lowest_savef) * 4;
	  h->type = STT_FUNC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  _bfd_elf_link_hash_hide_symbol (info, h, info->shared);
	}
    }

  memcpy (sym, "._restf14", 10);
  for (i = MIN_SAVE_FPR; i <= MAX_SAVE_FPR; i++)
    {
      sym[7] = i / 10 + '0';
      sym[8] = i % 10 + '0';
      h = elf_link_hash_lookup (&htab->elf, sym, false, false, true);
      if (h != NULL
	  && h->root.type == bfd_link_hash_undefined)
	{
	  if (lowest_restf > i)
	    lowest_restf = i;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = htab->sfpr;
	  h->root.u.def.value = ((MAX_SAVE_FPR + 2 - lowest_savef) * 4
				 + (i - lowest_restf) * 4);
	  h->type = STT_FUNC;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
	  _bfd_elf_link_hash_hide_symbol (info, h, info->shared);
	}
    }

  htab->sfpr->_raw_size = ((MAX_SAVE_FPR + 2 - lowest_savef) * 4
			   + (MAX_SAVE_FPR + 2 - lowest_restf) * 4);

  if (htab->sfpr->_raw_size == 0)
    {
      _bfd_strip_section_from_output (info, htab->sfpr);
    }
  else
    {
      bfd_byte *p = (bfd_byte *) bfd_alloc (htab->elf.dynobj,
					    htab->sfpr->_raw_size);
      if (p == NULL)
	return false;
      htab->sfpr->contents = p;

      for (i = lowest_savef; i <= MAX_SAVE_FPR; i++)
	{
	  unsigned int fpr = i << 21;
	  unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
	  bfd_put_32 (htab->elf.dynobj, STFD_FR0_0R1 + fpr + stackoff, p);
	  p += 4;
	}
      bfd_put_32 (htab->elf.dynobj, BLR, p);
      p += 4;

      for (i = lowest_restf; i <= MAX_SAVE_FPR; i++)
	{
	  unsigned int fpr = i << 21;
	  unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
	  bfd_put_32 (htab->elf.dynobj, LFD_FR0_0R1 + fpr + stackoff, p);
	  p += 4;
	}
      bfd_put_32 (htab->elf.dynobj, BLR, p);
      p += 4;
    }

a3513 2
  /* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
  boolean is_power4 = false;
d3643 1
a3643 1
	  insn = 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field. */
d3650 7
a3656 12
	  if (is_power4)
	    {
	      /* Set 'a' bit.  This is 0b00010 in BO field for branch
		 on CR(BI) insns (BO == 001at or 011at), and 0b01000
		 for branch on CTR insns (BO == 1a00t or 1a01t).  */
	      if ((insn & (0x14 << 21)) == (0x04 << 21))
		insn |= 0x02 << 21;
	      else if ((insn & (0x14 << 21)) == (0x10 << 21))
		insn |= 0x08 << 21;
	      else
		break;
	    }
d3658 1
a3658 5
	    {
	      /* Invert 'y' bit if not the default.  */
	      if ((bfd_signed_vma) (relocation - offset) < 0)
		insn ^= 0x01 << 21;
	    }
@


1.26.2.4
log
@Merge from mainline.
@
text
@d2504 2
a2505 1
  if (h->root.type == bfd_link_hash_indirect)
a2507 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

d2878 2
a2879 1
  if (h->root.type == bfd_link_hash_indirect)
a2881 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a3035 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.26.2.5
log
@Merge from mainline
@
text
@d42 1
a42 15
static bfd_reloc_status_type ppc64_elf_ha_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_brtaken_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_sectoff_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_sectoff_ha_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_toc_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_toc_ha_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_toc64_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type ppc64_elf_unhandled_reloc
d104 6
a148 4
/* Some other nops.  */
#define CROR_151515	0x4def7b82
#define CROR_313131	0x4ffffb82

d276 1
a276 1
	 ppc64_elf_ha_reloc,	/* special_function */
d309 1
a309 1
	 ppc64_elf_brtaken_reloc, /* special_function */
d326 1
a326 1
	 ppc64_elf_brtaken_reloc, /* special_function */
d373 1
a373 1
	 ppc64_elf_brtaken_reloc, /* special_function */
d390 1
a390 1
	 ppc64_elf_brtaken_reloc, /* special_function */
d406 1
a406 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d422 1
a422 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d438 1
a438 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d454 1
a454 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d473 1
a473 1
	 ppc64_elf_unhandled_reloc,  /* special_function */
d489 1
a489 1
	 ppc64_elf_unhandled_reloc,  /* special_function */
d505 1
a505 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d583 1
a583 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d615 1
a615 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d631 1
a631 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d647 1
a647 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d654 3
a656 1
  /* 16-bit section relative relocation.  */
d659 3
a661 3
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
d664 1
a664 1
	 ppc64_elf_sectoff_reloc, /* special_function */
d668 2
a669 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d671 1
a671 1
  /* Like R_PPC64_SECTOFF, but no overflow warning.  */
d679 1
a679 1
	 ppc64_elf_sectoff_reloc, /* special_function */
d694 1
a694 1
	 ppc64_elf_sectoff_reloc, /* special_function */
d709 1
a709 1
	 ppc64_elf_sectoff_ha_reloc, /* special_function */
d717 2
a718 1
     bits.  Should have been named R_PPC64_REL30!  */
d774 1
a774 1
	 ppc64_elf_ha_reloc,	/* special_function */
d805 1
a805 1
	 ppc64_elf_ha_reloc,	/* special_function */
d850 1
a850 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d867 1
a867 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d884 1
a884 1
	 ppc64_elf_toc_reloc,	/* special_function */
d901 1
a901 1
	 ppc64_elf_toc_reloc,	/* special_function */
d918 1
a918 1
	 ppc64_elf_toc_reloc,	/* special_function */
d937 1
a937 1
	 ppc64_elf_toc_ha_reloc, /* special_function */
d954 1
a954 1
	 ppc64_elf_toc64_reloc,	/* special_function */
d977 1
a977 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d993 1
a993 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1009 1
a1009 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1027 1
a1027 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1072 1
a1072 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1087 1
a1087 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1102 1
a1102 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1110 2
d1114 3
a1116 3
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
d1119 1
a1119 1
	 ppc64_elf_sectoff_reloc, /* special_function */
d1123 2
a1124 2
	 0xfffc,		/* dst_mask */
	 false),		/* pcrel_offset */
d1134 1
a1134 1
	 ppc64_elf_sectoff_reloc, /* special_function */
d1149 1
a1149 1
	 ppc64_elf_toc_reloc,	/* special_function */
d1164 1
a1164 1
	 ppc64_elf_toc_reloc,	/* special_function */
d1180 1
a1180 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1196 1
a1196 1
	 ppc64_elf_unhandled_reloc, /* special_function */
d1322 1
a1322 1
    case BFD_RELOC_16_BASEREL:		 ppc_reloc = R_PPC64_SECTOFF;
d1420 3
a1422 28
ppc64_elf_ha_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  /* Adjust the addend for sign extension of the low 16 bits.
     We won't actually be using the low 16 bits, so trashing them
     doesn't matter.  */
  reloc_entry->addend += 0x8000;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_brtaken_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
d1425 1
a1425 1
     PTR data;
d1428 1
a1428 1
     char **error_message;
d1430 1
a1430 5
  long insn;
  enum elf_ppc_reloc_type r_type;
  bfd_size_type octets;
  /* Disabled until we sort out how ld should choose 'y' vs 'at'.  */
  boolean is_power4 = false;
a1431 3
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
a1432 24
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  insn = bfd_get_32 (abfd, (bfd_byte *) data + octets);
  insn &= ~(0x01 << 21);
  r_type = (enum elf_ppc_reloc_type) reloc_entry->howto->type;
  if (r_type == R_PPC64_ADDR14_BRTAKEN
      || r_type == R_PPC64_REL14_BRTAKEN)
    insn |= 0x01 << 21; /* 'y' or 't' bit, lowest bit of BO field. */

  if (is_power4)
    {
      /* Set 'a' bit.  This is 0b00010 in BO field for branch
	 on CR(BI) insns (BO == 001at or 011at), and 0b01000
	 for branch on CTR insns (BO == 1a00t or 1a01t).  */
      if ((insn & (0x14 << 21)) == (0x04 << 21))
	insn |= 0x02 << 21;
      else if ((insn & (0x14 << 21)) == (0x10 << 21))
	insn |= 0x08 << 21;
      else
	return bfd_reloc_continue;
    }
  else
d1434 2
a1435 16
      bfd_vma target = 0;
      bfd_vma from;

      if (!bfd_is_com_section (symbol->section))
	target = symbol->value;
      target += symbol->section->output_section->vma;
      target += symbol->section->output_offset;
      target += reloc_entry->addend;

      from = (reloc_entry->address
	      + input_section->output_offset
	      + input_section->output_section->vma);

      /* Invert 'y' bit if not the default.  */
      if ((bfd_signed_vma) (target - from) < 0)
	insn ^= 0x01 << 21;
a1436 21
  bfd_put_32 (abfd, (bfd_vma) insn, (bfd_byte *) data + octets);
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_sectoff_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);
d1438 2
a1439 4
  /* Subtract the symbol section base address.  */
  reloc_entry->addend -= symbol->section->output_section->vma;
  return bfd_reloc_continue;
}
d1441 4
a1444 74
static bfd_reloc_status_type
ppc64_elf_sectoff_ha_reloc (abfd, reloc_entry, symbol, data,
			    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  /* Subtract the symbol section base address.  */
  reloc_entry->addend -= symbol->section->output_section->vma;

  /* Adjust the addend for sign extension of the low 16 bits.  */
  reloc_entry->addend += 0x8000;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_toc_reloc (abfd, reloc_entry, symbol, data,
		     input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_vma TOCstart;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);

  /* Subtract the TOC base address.  */
  reloc_entry->addend -= TOCstart + TOC_BASE_OFF;
  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc64_elf_toc_ha_reloc (abfd, reloc_entry, symbol, data,
			input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_vma TOCstart;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);
d1446 3
a1448 3
  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);
d1450 1
a1450 2
  /* Subtract the TOC base address.  */
  reloc_entry->addend -= TOCstart + TOC_BASE_OFF;
a1451 2
  /* Adjust the addend for sign extension of the low 16 bits.  */
  reloc_entry->addend += 0x8000;
a1454 58
static bfd_reloc_status_type
ppc64_elf_toc64_reloc (abfd, reloc_entry, symbol, data,
		       input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  bfd_vma TOCstart;
  bfd_size_type octets;

  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  TOCstart = _bfd_get_gp_value (input_section->output_section->owner);
  if (TOCstart == 0)
    TOCstart = ppc64_elf_toc (input_section->output_section->owner);

  octets = reloc_entry->address * bfd_octets_per_byte (abfd);
  bfd_put_64 (abfd, TOCstart + TOC_BASE_OFF, (bfd_byte *) data + octets);
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc64_elf_unhandled_reloc (abfd, reloc_entry, symbol, data,
			   input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,	
				  input_section, output_bfd, error_message);

  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, "generic linker can't handle %s",
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}

a1733 3
  /* Set if we detect a reference undefined weak symbol.  */
  unsigned int have_undefweak;

a1802 1
  htab->have_undefweak = 0;
a2517 4
  if (h->root.type == bfd_link_hash_undefweak
      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR))
    htab->have_undefweak = true;

a2612 1
  bfd_byte *p;
a2662 2
  elf_link_hash_traverse (&htab->elf, func_desc_adjust, (PTR) info);

d2668 11
a2678 1
      if (!htab->have_undefweak)
d2680 4
a2683 2
	  _bfd_strip_section_from_output (info, htab->sfpr);
	  return true;
a2684 18

      htab->sfpr->_raw_size = 4;
    }

  p = (bfd_byte *) bfd_alloc (htab->elf.dynobj, htab->sfpr->_raw_size);
  if (p == NULL)
    return false;
  htab->sfpr->contents = p;

  for (i = lowest_savef; i <= MAX_SAVE_FPR; i++)
    {
      unsigned int fpr = i << 21;
      unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
      bfd_put_32 (htab->elf.dynobj, STFD_FR0_0R1 + fpr + stackoff, p);
      p += 4;
    }
  if (lowest_savef <= MAX_SAVE_FPR)
    {
a2686 1
    }
d2688 8
a2695 5
  for (i = lowest_restf; i <= MAX_SAVE_FPR; i++)
    {
      unsigned int fpr = i << 21;
      unsigned int stackoff = (1 << 16) - (MAX_SAVE_FPR + 1 - i) * 8;
      bfd_put_32 (htab->elf.dynobj, LFD_FR0_0R1 + fpr + stackoff, p);
a2697 5
  if (lowest_restf <= MAX_SAVE_FPR
      || htab->sfpr->_raw_size == 4)
    {
      bfd_put_32 (htab->elf.dynobj, BLR, p);
    }
d3288 2
a3289 2
/* Called after we have determined section placement.  If sections
   move, we'll be called again.  Provide a value for TOCstart.  */
d3291 5
a3295 2
bfd_vma
ppc64_elf_toc (obfd)
d3297 1
d3299 4
a3302 2
  asection *s;
  bfd_vma TOCstart;
d3304 5
a3308 25
  /* The TOC consists of sections .got, .toc, .tocbss, .plt in that
     order.  The TOC starts where the first of these sections starts.  */
  s = bfd_get_section_by_name (obfd, ".got");
  if (s == NULL)
    s = bfd_get_section_by_name (obfd, ".toc");
  if (s == NULL)
    s = bfd_get_section_by_name (obfd, ".tocbss");
  if (s == NULL)
    s = bfd_get_section_by_name (obfd, ".plt");
  if (s == NULL)
    {
      /* This may happen for
	 o  references to TOC base (SYM@@toc / TOC[tc0]) without a
	 .toc directive
	 o  bad linker script
	 o --gc-sections and empty TOC sections

	 FIXME: Warn user?  */

      /* Look for a likely section.  We probably won't even be
	 using TOCstart.  */
      for (s = obfd->sections; s != NULL; s = s->next)
	if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA | SEC_READONLY))
	    == (SEC_ALLOC | SEC_SMALL_DATA))
	  break;
d3310 1
a3310 4
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & (SEC_ALLOC | SEC_SMALL_DATA))
	      == (SEC_ALLOC | SEC_SMALL_DATA))
	    break;
d3312 1
a3312 3
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & (SEC_ALLOC | SEC_READONLY)) == SEC_ALLOC)
	    break;
d3314 29
a3342 4
	for (s = obfd->sections; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) == SEC_ALLOC)
	    break;
    }
d3344 3
a3346 3
  TOCstart = 0;
  if (s != NULL)
    TOCstart = s->output_section->vma + s->output_offset;
d3348 3
a3350 1
  return TOCstart;
a3644 3
  if (info->relocateable)
    return true;

d3671 1
a3672 1
      bfd_vma from;
d3676 21
a3718 1
	  /* rel may have changed, update our copy of addend.  */
a3793 4
	      from = (offset
		      + input_section->output_offset
		      + input_section->output_section->vma);

d3795 1
a3795 1
	      if ((bfd_signed_vma) (relocation + addend - from) < 0)
d3803 7
a3809 5
	  /* A REL24 branching to a linkage function is followed by a
	     nop.  We replace the nop with a ld in order to restore
	     the TOC base pointer.  Only calls to shared objects need
	     to alter the TOC base.  These are recognized by their
	     need for a PLT entry.  */
d3814 5
a3818 1
	      boolean can_plt_call = 0;
d3820 2
d3824 8
a3831 3
		  insn = bfd_get_32 (input_bfd, contents + offset + 4);
		  if (insn == NOP
		      || insn == CROR_151515 || insn == CROR_313131)
d3833 4
a3836 3
		      bfd_put_32 (input_bfd, (bfd_vma) LD_R2_40R1,
				  contents + offset + 4);
		      can_plt_call = 1;
a3838 19

	      if (!can_plt_call)
		{
		  /* If this is a plain branch rather than a branch
		     and link, don't require a nop.  */
		  insn = bfd_get_32 (input_bfd, contents + offset);
		  if ((insn & 1) == 0)
		    can_plt_call = 1;
		}

	      if (can_plt_call)
		{
		  /* plt.offset here is the offset into the stub section.  */
		  relocation = (htab->sstub->output_section->vma
				+ htab->sstub->output_offset
				+ h->plt.offset);
		  addend = 0;
		  unresolved_reloc = false;
		}
d3843 3
a3845 2
	      && relocation == 0
	      && addend == 0)
d3847 7
a3853 17
	      /* Tweak calls to undefined weak functions to point at a
		 blr.  We can thus call a weak function without first
		 checking whether the function is defined.  We have a
		 blr at the end of .sfpr.  */
	      BFD_ASSERT (htab->sfpr->_raw_size != 0);
	      relocation = (htab->sfpr->_raw_size - 4
			    + htab->sfpr->output_offset
			    + htab->sfpr->output_section->vma);
	      from = (offset
		      + input_section->output_offset
		      + input_section->output_section->vma);

	      /* But let's not be silly about it.  If the blr isn't in
		 reach, just go to the next instruction.  */
	      if (relocation - from + (1 << 25) >= (1 << 26)
		  || htab->sfpr->_raw_size == 0)
		relocation = from + 4;
a4595 1
#define elf_backend_rela_normal 1
@


1.25
log
@	* elf64-ppc.c (func_desc_adjust): STV_PROTECTED functions should
	not go via the plt.
@
text
@d2998 1
a2998 1
	      else
d3002 2
d3140 3
a3142 1
	  elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, (PTR) info);
@


1.24
log
@	* elf64-ppc.c (func_desc_adjust): Only provide missing function
	descriptor symbols for undefined function code syms.  Clear
	ELF_LINK_NON_ELF so that they can stay weak.
@
text
@a2538 1
	  fdh->plt.refcount = h->plt.refcount;
d2544 5
a2548 1
	  fdh->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2559 1
a2559 1
	 linker dragging a definition in from a static library.  */
@


1.23
log
@Arrgh!  Revert last change.
@
text
@d2503 4
a2506 1
      if (fdh == NULL && info->shared)
d2511 1
a2511 9
	  /* Create it as undefined.  */
	  if (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak)
	    abfd = h->root.u.undef.abfd;
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    abfd = h->root.u.def.section->owner;
	  else
	    abort ();
d2527 1
@


1.22
log
@	* elf64-ppc.c (func_desc_adjust): Don't supply missing function
	descriptor symbols.
@
text
@d2497 2
a2498 1
      /* Find the corresponding function descriptor symbol.  */
d2502 31
@


1.21
log
@	* elf64-ppc.c: Remove stale part of ABI comment.
	(NO_OPD_RELOCS): Define.
	(ppc64_elf_check_relocs): Use it.
	(ppc64_elf_relocate_section): Here too.
	(build_one_stub): Don't point function syms at the stub.  Instead,
	hijack plt.offset.
	(ppc64_elf_relocate_section): Check whether REL24 relocs should
	really go to the stub.  Make all dynamic relocs in opd against
	locals.
	(ppc64_elf_finish_dynamic_symbol): Allow for non-standard use of
	plt.offset.
@
text
@d2497 1
a2497 2
      /* Find the corresponding function descriptor symbol.  Create it
	 as undefined if necessary.  */
a2500 31

      if (fdh == NULL && info->shared)
	{
	  bfd *abfd;
	  asymbol *newsym;

	  /* Create it as undefined.  */
	  if (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak)
	    abfd = h->root.u.undef.abfd;
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    abfd = h->root.u.def.section->owner;
	  else
	    abort ();
	  newsym = bfd_make_empty_symbol (abfd);
	  newsym->name = h->root.root.string + 1;
	  newsym->section = bfd_und_section_ptr;
	  newsym->value = 0;
	  newsym->flags = BSF_OBJECT;
	  if (h->root.type == bfd_link_hash_undefweak)
	    newsym->flags |= BSF_WEAK;

	  if ( !(_bfd_generic_link_add_one_symbol
		 (info, abfd, newsym->name, newsym->flags,
		  newsym->section, newsym->value, NULL, false, false,
		  (struct bfd_link_hash_entry **) &fdh)))
	    {
	      return false;
	    }
	}
@


1.20
log
@	* elf64-ppc.c (ppc64_elf_finish_dynamic_sections): Correct sign of
	TOC_BASE_OFF adjustment.
@
text
@d155 12
d1663 1
a1663 4
   definition from some other object, eg. a static library.  Thirdly, we'd
   like to use .foo as the stub symbol to avoid creating another symbol.
   We need to make sure that when .foo labels a stub in a shared library,
   it isn't exported.  */
d2135 2
a2136 3
#if 0
	      /* Don't propagate .opd relocs.  */
	  if (is_opd)
a2137 1
#endif
d3323 2
a3324 1
      && h->plt.offset != (bfd_vma) -1)
a3331 2
      BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);

a3339 8
      /* Point the function at the linkage stub.  This works because
	 the only references to the function code sym are calls.
	 Function pointer comparisons use the function descriptor.  */
      s = htab->sstub;
      fh->root.type = bfd_link_hash_defined;
      fh->root.u.def.section = s;
      fh->root.u.def.value = s->_cooked_size;

d3357 4
d3506 1
d3517 1
a3622 1
	      relocation = 0;
d3665 9
a3673 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0
d3676 3
a3678 3
	      && offset + 8 <= input_section->_cooked_size)
	    {
	      bfd_byte *pnext;
d3680 2
a3681 2
	      pnext = contents + offset + 4;
	      insn = bfd_get_32 (input_bfd, pnext);
d3683 9
a3691 8
	      if (insn == 0x60000000	 /* nop (ori  r0,r0,0) */
		  || insn == 0x4def7b82	 /* cror 15,15,15 */
		  || insn == 0x4ffffb82) /* cror 31,31,31 */
		{
		  bfd_put_32 (input_bfd,
			      (bfd_vma) 0xe8410028, /* ld r2,40(r1) */
			      pnext);
		  has_nop = 1;
d3927 3
a3952 6
#if 0
	      if (strcmp (bfd_get_section_name (output_bfd, input_section),
			  ".opd") == 0)
		break;
#endif

d3976 1
d3988 3
a3990 1
		  /* This symbol is local, or marked to become local.  */
d4001 1
a4001 1
		      if (r_type == R_PPC64_TOC || bfd_is_abs_section (sec))
d4200 2
a4201 1
  if (h->plt.offset != (bfd_vma) -1)
a4212 2

      BFD_ASSERT (((struct ppc_link_hash_entry *) h)->is_func_descriptor);
@


1.19
log
@	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_func and
	is_func_descriptor fields.
	(link_hash_newfunc): Init them.
	(ppc64_elf_check_relocs): Only R_PPC24_REL24 syms starting with a
	dot are candidates for plt entries.  When processing .opd relocs,
	set function descriptor strings to point inside function code
	string, and set new ppc_link_hash_entry fields.
	(ppc64_elf_gc_sweep_hook): Don't sweep R_PPC64_REL24 relocs.
	(ppc64_elf_adjust_dynamic_symbol): Remove most code dealing with
	function descriptors.  It's now done in..
	(func_desc_adjust): New.
	(ppc64_elf_func_desc_adjust): New.
	(define elf_backend_always_size_sections): Define.
	(ppc64_elf_hide_symbol): New.
	(define elf_backend_hide_symbol): Define.
	(allocate_dynrelocs): Remove code looking up function descriptors
	as that has been done earlier.
	(ppc64_elf_size_dynamic_sections): Use htab shortcut to elf hash
	table.
	(ppc64_elf_finish_dynamic_symbol): Likewise.  Remove code looking
	up function descriptor.
	(build_one_stub): Look up the function code sym.  Check for
	invalid plt offsets.
	(ppc64_elf_relocate_section): Tweak calls to undefined weak syms.
	Convert R_PPC64_TOC relocs to R_PPC64_RELATIVE in shared libs.
@
text
@d4387 1
a4387 1
		  elf_gp (output_bfd) - TOC_BASE_OFF,
@


1.18
log
@	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Test for a
	dynamic function descriptor symbol, not the associated function
	symbol.
@
text
@d69 4
d75 2
d1591 64
a1654 1
   called.  */
d1695 4
d1753 2
d1912 3
d1935 1
d1950 1
d2031 1
d2066 3
a2068 1
	  if (h != NULL)
d2074 1
d2078 23
a2121 1
	case R_PPC64_ADDR64:
d2126 6
a2170 6
#if 0
	      /* Don't propagate .opd relocs.  */
	      if (strcmp (bfd_get_section_name (abfd, sec), ".opd") == 0)
		break;
#endif

d2384 1
a2384 1
	  /* Fall thru.  */
d2460 3
a2462 6
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

d2464 1
a2464 2
ppc64_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
d2466 1
d2468 1
a2469 4
  struct ppc_link_hash_entry * eh;
  struct ppc_dyn_relocs *p;
  asection *s;
  unsigned int power_of_two;
d2471 5
d2478 8
a2485 4
  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later.  */
  if (h->type == STT_FUNC
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d2488 1
a2488 14

      /* If it's a function entry point, the name starts with a dot
         unless someone has written some poor assembly code.  The ABI
	 for .plt calls requires that there be a function descriptor
	 sym which has the name of the function minus the dot.  */

      if (h->plt.refcount <= 0
	  || h->root.root.string[0] != '.'
	  || h->root.root.string[1] == '\0')
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	  return true;
	}
d2491 1
a2491 2
	 as undefined if necessary.  ppc_elf64_finish_dynamic_symbol
	 will look it up again and create a JMP_SLOT reloc for it.  */
d2493 2
a2494 3
      fdh = elf_link_hash_lookup (elf_hash_table (info),
				  h->root.root.string + 1,
				  false, false, false);
d2496 1
a2496 1
      if (fdh == NULL)
d2498 1
d2502 9
a2510 1
	  newsym = bfd_make_empty_symbol (htab->elf.dynobj);
d2514 3
a2516 1
	  newsym->flags = BSF_DYNAMIC | BSF_OBJECT;
d2519 1
a2519 1
		 (info, htab->elf.dynobj, newsym->name, newsym->flags,
d2527 82
a2608 13
      while (fdh->root.type == bfd_link_hash_indirect
	     || fdh->root.type == bfd_link_hash_warning)
	fdh = (struct elf_link_hash_entry *) fdh->root.u.i.link;

      if (! info->shared
	  && (fdh->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (fdh->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	{
	  /* This case can occur if we saw a PLT reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table entry.  */
a2610 1
	  return true;
a2611 1

d2705 24
d2762 2
a2763 1
      && h->plt.refcount > 0)
d2765 1
a2765 11
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return false;
	}

      BFD_ASSERT (h->root.root.string[0] == '.'
		  && h->root.root.string[1] != '\0');
a2768 22
	  /* Make sure the corresponding function descriptor symbol is
	     dynamic too.  */

	  if (h->dynindx != -1)
	    {
	      struct elf_link_hash_entry *fdh;

	      fdh = elf_link_hash_lookup (elf_hash_table (info),
					  h->root.root.string + 1,
					  false, false, false);

	      if (fdh == NULL)
		abort ();

	      if (fdh->dynindx == -1
		  && (fdh->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
		{
		  if (! bfd_elf64_link_record_dynamic_symbol (info, fdh))
		    return false;
		}
	    }

a2775 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d3097 1
a3097 1
  if (elf_hash_table (info)->dynamic_sections_created)
d3318 1
d3324 10
d3338 3
a3340 3
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = s;
      h->root.u.def.value = s->_cooked_size;
d3349 2
a3350 1
      if (plt_r2 + 0x80000000 > 0xffffffff)
d3353 1
a3353 1
	    (_("linkage table overflow against `%s'"),
d3530 1
d3660 1
d3679 1
d3682 15
d3981 1
a3981 1
		  if (r_type == R_PPC64_ADDR64)
a4189 1
      struct elf_link_hash_entry *funcdesc_h;
d4198 1
a4198 3
	  || htab->sglink == NULL
	  || h->root.root.string[0] != '.'
	  || h->root.root.string[1] == '\0')
d4201 1
a4201 9
      /* Find its corresponding function descriptor.
	 ppc64_elf_adjust_dynamic_symbol has already set it up for us.  */

      funcdesc_h = elf_link_hash_lookup (elf_hash_table (info),
					 h->root.root.string + 1,
					 false, false, false);

      if (funcdesc_h == NULL || funcdesc_h->dynindx == -1)
	abort ();
d4209 1
a4209 1
      rela.r_info = ELF64_R_INFO (funcdesc_h->dynindx, R_PPC64_JMP_SLOT);
d4443 2
@


1.17
log
@	* elf64-ppc.c (ppc64_elf_howto_raw): Remove stale FIXMEs.
	(ppc64_elf_reloc_type_lookup): Use proper CTOR reloc.
	(ORI_R0_R0_0): Correct.
@
text
@d2387 1
a2387 4
	  || h->root.root.string[1] == '\0'
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0))
a2388 5
	  /* This case can occur if we saw a PLT reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table entry.  */
d2421 19
@


1.16
log
@	* elflink.c (_bfd_elf_create_dynamic_sections): Don't set SEC_CODE
	when plt_not_loaded.
	* elf64-ppc.c (ppc64_elf_create_dynamic_sections): No need to
	clear .plt SEC_CODE here.  Create .stub and correct .glink flags.
	(PLT_INITIAL_ENTRY_SIZE): Set to 24.
	(ppc64_elf_glink_code): Delete.
	(PPC64_ELF_GLINK_SIZE): Delete.
	(ADDIS_R12_R2, STD_R2_40R1, LD_R11_0R12, LD_R2_0R12, MTCTR_R11,
	BCTR, ADDIS_R12_R12_1, LD_R2_40R1, NOP, LI_R0_0, B_DOT, LIS_R0_0,
	ORI_R0_R0_0): Define.
	(PLT_CALL_STUB_SIZE, GLINK_CALL_STUB_SIZE): Define.
	(struct ppc_link_hash_table): Add sstub and plt_overflow.
	(ppc64_elf_link_hash_table_create): Init them.
	(ppc64_elf_check_relocs <R_PPC64_REL24>): Refcount .plt entry.
	Don't copy to shared lib.
	(ppc64_elf_check_relocs): Call bfd_set_error on errors.
	(ppc64_elf_gc_sweep_hook <R_PPC64_REL24>): Sweep plt refcount.
	(allocate_dynrelocs <plt>): Don't change function sym here.  Make
	room for .stub and .glink code.
	(ppc64_elf_size_dynamic_sections): Handle .stub.  Make entry for
	DT_PPC64_GLINK.
	(ppc64_elf_final_link): Rename to ppc64_elf_set_toc.  Don't call
	bfd_elf64_bfd_final_link.
	(bfd_elf64_bfd_final_link): Don't define.
	(ppc64_elf_size_stubs): New.
	(build_plt_stub): New.
	(build_one_stub): New.
	(ppc64_elf_build_stubs): New.
	(ppc64_elf_relocate_section <toc relocs>): Remove assert.
	(ppc64_elf_relocate_section): Don't copy R_PPC64_REL24 relocs.
	(ppc64_elf_finish_dynamic_symbol): Don't build stubs here.  Set
	DT_PPC64_GLINK entry.  Tweak DT_PLTGOT, DT_JMPREL, DT_PLTRELSZ in
	case output sections not separate.  Adjust DT_RELASZ to not
	include plt relocs.  Set reserved got entry.  Set got and plt
	entry size.
	(elf_backend_got_header_size): Set to 8.
	* elf64-ppc.h: New file.
@
text
@d148 1
a148 1
#define ORI_R0_R0_0	0x60008000	/* ori	 %r0,%r0,0	*/
d553 1
a553 2
  /* 32-bit relocation to the symbol's procedure linkage table.
     FIXME: R_PPC64_PLT32 not supported.  */
a820 1
  /* FIXME: R_PPC64_PLT64 not supported.  */
d1308 1
a1308 3
      /* FIXME: Is CTOR 32 or 64 bits?  Fix md_apply_fix3 in
	 gas/config/tc-ppc.c too.  */
    case BFD_RELOC_CTOR:		 ppc_reloc = R_PPC64_ADDR32;
@


1.15
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d31 1
d79 4
a82 2
static boolean ppc64_elf_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
d110 1
a110 1
#define PLT_INITIAL_ENTRY_SIZE 96
d115 34
a148 13
/* Global linkage stub.  The first instruction has its offset patched.  */
/* FIXME: Need traceback table?  */
static const unsigned int ppc64_elf_glink_code[] = {
  0xe9820000,			/* ld    %r12,0(%r2) */
  0xf8410028,			/* std   %r2,40(%r1) */
  0xe80c0000,			/* ld    %r0,0(%r12) */
  0xe84c0008,			/* ld    %r2,8(%r12) */
  0x7c0903a6,			/* mtctr %r0         */
  0x4e800420			/* bctr              */
};

#define PPC64_ELF_GLINK_SIZE \
  ((sizeof ppc64_elf_glink_code / sizeof ppc64_elf_glink_code[0]) * 4)
d1645 1
d1648 3
d1714 1
d1716 1
d1751 2
a1752 2
/* Create the .glink section as well as the ordinary dynamic
   sections.  */
d1779 7
a1785 4
  /* Our .plt just contains pointers, no code.  */
  flags = bfd_get_section_flags (dynobj, htab->splt);
  flags &= ~SEC_CODE;
  if (! bfd_set_section_flags (dynobj, htab->splt, flags))
a1786 4

  /* Create .glink for global linkage functions.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d1846 1
a1846 1
   linkage table, and dynamic reloc sections.  */ 
d1988 10
a1999 1
	case R_PPC64_REL24:
d2063 6
d2091 1
d2275 9
a2286 1
	case R_PPC64_REL24:
d2474 1
a2474 1
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */ 
d2604 1
d2609 4
a2612 3
	  /* Point the function at the linkage stub.  This works because
	     the only references to the function code sym are calls.
	     Function pointer comparisons use the function descriptor.  */
d2614 6
a2619 7
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;

	  /* Make room for global linkage code in .glink.  */
	  s->_raw_size += PPC64_ELF_GLINK_SIZE;
d2861 2
d2868 1
d2915 7
a2921 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2947 2
a2948 1
	      || !add_dynamic_entry (DT_JMPREL, 0))
d2979 1
a2979 2
   the output bfd elf_gp, then we call the generic ELF final link
   routine.  */
d2981 3
a2983 3
static boolean
ppc64_elf_final_link (abfd, info)
     bfd *abfd;
d2986 1
a2986 1
  if (! info->relocateable)
d2991 1
a2991 1
      /* The TOC consists of sections .got, .toc, .tocbss, .plt in this
d2993 1
a2993 1
      s = bfd_get_section_by_name (abfd, ".got");
d2995 1
a2995 1
	s = bfd_get_section_by_name (abfd, ".toc");
d2997 1
a2997 1
	s = bfd_get_section_by_name (abfd, ".tocbss");
d2999 1
a2999 1
	s = bfd_get_section_by_name (abfd, ".plt");
d3012 1
a3012 1
	  for (s = abfd->sections; s != NULL; s = s->next)
d3017 1
a3017 1
	    for (s = abfd->sections; s != NULL; s = s->next)
d3022 1
a3022 1
	    for (s = abfd->sections; s != NULL; s = s->next)
d3026 1
a3026 1
	    for (s = abfd->sections; s != NULL; s = s->next)
d3035 197
a3231 1
      elf_gp (abfd) = TOCstart;
d3233 4
d3238 15
a3252 2
  /* Invoke the regular ELF backend linker to do all the work.  */
  return bfd_elf64_bfd_final_link (abfd, info);
a3652 1

a3658 8
	  /* Only .got, .toc and *UND* symbols are allowed.  */
	  BFD_ASSERT (sec != (asection *) 0
		      && (bfd_is_und_section (sec)
			  || strcmp (bfd_get_section_name (abfd, sec),
				     ".toc") == 0
			  || strcmp (bfd_get_section_name (abfd, sec),
				     ".got") == 0));

d3673 3
a3680 1
	case R_PPC64_REL24:
a3702 1
	case R_PPC64_TOC:
d3706 6
a3711 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
d3737 6
d3996 1
a3996 2
      if (h->dynindx == -1
	  || htab->splt == NULL
d4004 1
a4004 1
	 ppc64_elf_adjust_dynamic_symbol has already set it up for us.  */ 
a4024 36

      /* We need to create a linkage function. */
      if (h->root.u.def.section == htab->sglink)
	{
	  bfd_byte *p;
	  bfd_vma pltoff;
	  const unsigned int *stub;

	  /* Where to write it.  */
	  p = h->root.u.def.section->contents + h->root.u.def.value;

	  /* The function descriptor is in the PLT.  */
	  pltoff = htab->splt->output_section->vma
	    + htab->splt->output_section->output_offset
	    + h->plt.offset
	    - elf_gp (output_bfd) - TOC_BASE_OFF;

	  if (pltoff + 0x8000 > 0xffff)
	    {
	      (*_bfd_error_handler)
		(_("linkage table overflow against `%s'"),
		 h->root.root.string);
	    }

	  /* Write it out.  */
	  stub = ppc64_elf_glink_code;
	  bfd_put_32 (output_bfd, *stub | (pltoff & 0xfffc), p);
	  while (p += 4, ++stub < (ppc64_elf_glink_code
				   + (sizeof (ppc64_elf_glink_code)
				      / sizeof (*ppc64_elf_glink_code))));
	    {
	      bfd_put_32 (output_bfd, (bfd_vma) *stub, p);
	    }
	}
      else
	abort ();
d4161 5
d4167 2
a4168 1
	      dyn.d_un.d_ptr = htab->splt->output_section->vma;
d4172 2
a4173 1
	      dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
d4177 8
a4184 4
	      if (htab->srelplt->output_section->_cooked_size != 0)
		dyn.d_un.d_val = htab->srelplt->output_section->_cooked_size;
	      else
		dyn.d_un.d_val = htab->srelplt->output_section->_raw_size;
d4192 19
d4236 2
a4237 1
#define elf_backend_got_header_size 0
a4240 2
#define elf_backend_plt_header_size PLT_INITIAL_ENTRY_SIZE

a4244 1
#define bfd_elf64_bfd_final_link	      ppc64_elf_final_link
@


1.14
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a44 2
static boolean ppc64_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
a1427 18
/* Copy backend specific data from one object module to another.  */
static boolean
ppc64_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a3972 1
#define bfd_elf64_bfd_copy_private_bfd_data   ppc64_elf_copy_private_bfd_data
@


1.13
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d2180 1
a2180 7
      if (! (elf_bad_symtab (abfd)
	     && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.12
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d3497 5
a3501 14
	      if (elf_section_data (input_section)->stab_info == NULL)
		outrel.r_offset = offset;
	      else
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, htab->elf.stab_info, input_section,
			  &elf_section_data (input_section)->stab_info,
			  offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}
@


1.11
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d3143 2
a3144 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.10
log
@	* elf64-ppc.c (ppc64_elf_relocate_section): Correct branch
	prediction bits.
@
text
@d1642 3
d1707 1
d2042 3
d2095 13
a2107 2
		  struct ppc_link_hash_entry *eh;
		  struct ppc_dyn_relocs *p;
d2109 3
a2111 16
		  eh = (struct ppc_link_hash_entry *) h;
		  p = eh->dyn_relocs;

		  if (p == NULL || p->sec != sec)
		    {
		      p = ((struct ppc_dyn_relocs *)
			   bfd_alloc (htab->elf.dynobj,
				      (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return false;
		      p->next = eh->dyn_relocs;
		      eh->dyn_relocs = p;
		      p->sec = sec;
		      p->count = 0;
		      p->pc_count = 0;
		    }
d2113 2
a2114 5
		  p->count += 1;
		  if (!IS_ABSOLUTE_RELOC (r_type))
		    p->pc_count += 1;
		}
	      else
d2116 10
a2125 2
		  /* Track dynamic relocs needed for local syms too.  */
		  elf_section_data (sec)->local_dynrel += 1;
d2127 4
d2207 2
d2679 1
a2679 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d2691 1
a2691 1
    keep:
d2778 1
a2778 1
	  bfd_size_type count = elf_section_data (s)->local_dynrel;
d2780 4
a2783 1
	  if (count != 0)
d2785 13
a2797 2
	      srel = elf_section_data (s)->sreloc;
	      srel->_raw_size += count * sizeof (Elf64_External_Rela);
d3462 7
a3469 1
	       && (input_section->flags & SEC_ALLOC) != 0
a3476 1
		  && (input_section->flags & SEC_ALLOC) != 0
@


1.9
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Test ind->root.type
	rather than ind->weakdef.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
@
text
@a94 3
/* Branch prediction bit for branch taken relocs.  */
#define BRANCH_PREDICT_BIT 0x200000

d3161 1
d3170 2
a3171 7
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn &= ~BRANCH_PREDICT_BIT;
	  else
	    insn |= BRANCH_PREDICT_BIT;
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
	  break;
d3173 1
a3173 1
	  /* Branch not taken predicition relocations.  */
d3176 8
a3183 3
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn |= BRANCH_PREDICT_BIT;
d3185 2
a3186 1
	    insn &= ~BRANCH_PREDICT_BIT;
@


1.8
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d1804 1
a1804 1
	  if (dir != ind->weakdef)
@


1.7
log
@	* elflink.h (elf_fix_symbol_flags): Copy flags to weakdef using
	elf_backend_copy_indirect_symbol so that backend has a chance to
	copy other necessary fields.
	* elf-bfd.h (struct elf_backend_data): Update description of
	elf_backend_copy_indirect_symbol.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Bail out after
	copying flags if this is a weakdef.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_link_hash_lookup rather
	than bfd_link_hash_lookup.
	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Don't do copy
	reloc processing for weakdefs.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1797 1
a1797 1
  if (edir->dyn_relocs == NULL)
d1799 28
a1829 2
  else if (eind->dyn_relocs != NULL)
    abort ();
d2395 2
@


1.6
log
@	* elf64-ppc.c (ppc64_elf_check_relocs): Use a local var and cast
	result of ELF64_R_TYPE to enum before using in a switch.
	(ppc64_elf_gc_mark_hook): Likewise.
	(ppc64_elf_gc_sweep_hook): Likewise.
	(ppc64_elf_reloc_type_class): Likewise.
@
text
@d2379 1
@


1.5
log
@	* elf64-ppc.c (struct ppc_dyn_relocs): New.
	(IS_ABSOLUTE_RELOC): Define.
	(struct ppc_link_hash_entry): New.
	(struct ppc_link_hash_table): New.
	(ppc_hash_table): Define.
	(link_hash_newfunc): New function.
	(ppc64_elf_link_hash_table_create): New function.
	(create_got_section): New function.
	(ppc64_elf_create_dynamic_sections): Call create_got_section.  Stash
	pointers to our dynamic sections in hash table.
	(ppc64_elf_copy_indirect_symbol): New function.
	(ppc64_elf_check_relocs): Remove DEBUG code.  Use short-cuts to
	dynamic sections.  Localise vars.  Modify code for refcounts
	starting from zero.  Don't allocate here, or force symbols dynamic.
	Don't copy all relocs if shared, select ones we need.  Add code
	to track possible copy relocs for non-shared link.
	(ppc64_elf_gc_mark_hook): Update comment.
	(ppc64_elf_gc_sweep_hook): Sweep dynrelocs too.
	(ppc64_elf_adjust_dynamic_symbol): Remove DEBUG code.  Rewrite .plt
	code for reference counting garbage collection.  Don't create .plt
	entries for functions that don't comply with ABI naming convention,
	and don't allocate .plt space here.  Use short-cuts to dynamic
	sections.  If possible, keep dynamic relocations instead of using
	copy relocs.  Remove confused comments.
	(ppc_adjust_dynindx): Delete.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(allocate_dynrelocs): New function.
	(readonly_dynrelocs): New function.
	(ppc64_elf_size_dynamic_sections): Rewrite.  Allocate local .got
	space here, and call allocate_dynrelocs to allocate space for
	global .plt, .got and reloc sections.  Use short-cuts to dynamic
	sections.  Call readonly_dynrelocs to determine whether we need
	DT_TEXTREL.  Don't generate section symbols here, the generic
	ELF linker code does it for us.
	(ppc64_elf_final_link): Call regular ELF backend linker rather than
	gc variety, since we do our own .got handling.
	(ppc64_elf_relocate_section): Remove DEBUG code.  Make use of
	dynamic section short-cuts.  Localise vars, and delay setting.
	Handle unknown relocs in main switch statement.  Replace ugly
	complicated tests for unresolvable relocs with a simple direct
	scheme using "unresolved_reloc" var.  Test ELF_ST_VISIBILITY
	before allowing an undefined sym in a shared lib.  Do R_*_DS tests
	after main switch, when we've set addend.  Do non-addend insn
	tweaks before main swithc.  Ignore input_section->vma when
	calculating reloc offsets as it's always zero.  Rewrite dynamic
	reloc handling.  Consolidate R_*_HA handling.  Handle more relocs.
	(ppc64_elf_finish_dynamic_symbol): Remove DEBUG code.  Make use
	of dynamic section short-cuts.  Reorganise .plt handling code.
	Remove confused comments.  Take note of ELF_LINK_FORCED_LOCAL.
	Move expressions out of swap_reloca_out function calls.
	(ppc64_elf_reloc_type_class): New function.
	(ppc64_elf_info_to_howto): Move common expression to local var.
	(ppc64_elf_finish_dynamic_sections): Remove DEBUG code.  Make use
	of dynamic section short-cuts.  Don't fiddle with section syms
	here as the ELF linker does it for us.
	(elf_backend_can_refcount): Define.
	(bfd_elf64_bfd_link_hash_table_create): Define.
	(elf_backend_copy_indirect_symbol): Define.
	(elf_backend_reloc_type_class): Define.
	(elf_backend_*, bfd_elf64_bfd_* defines): Sort.
@
text
@d1845 1
d1853 2
a1854 1
      switch (ELF64_R_TYPE (rel->r_info))
d2002 1
a2002 1
	       && (IS_ABSOLUTE_RELOC (ELF64_R_TYPE (rel->r_info))
d2086 1
a2086 1
		  if (!IS_ABSOLUTE_RELOC (ELF64_R_TYPE (rel->r_info)))
d2117 4
a2120 1
      switch (ELF64_R_TYPE (rel->r_info))
a2168 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
d2176 4
a2179 21
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_PPC64_GOT16:
      case R_PPC64_GOT16_DS:
      case R_PPC64_GOT16_HA:
      case R_PPC64_GOT16_HI:
      case R_PPC64_GOT16_LO:
      case R_PPC64_GOT16_LO_DS:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount--;
	  }
	else
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx]--;
	  }
        break;
d2181 22
a2202 13
      case R_PPC64_PLT16_HA:
      case R_PPC64_PLT16_HI:
      case R_PPC64_PLT16_LO:
      case R_PPC64_PLT32:
      case R_PPC64_PLT64:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount--;
	  }
	break;
d2204 12
a2215 12
      case R_PPC64_REL14:
      case R_PPC64_REL14_BRNTAKEN:
      case R_PPC64_REL14_BRTAKEN:
      case R_PPC64_REL24:
      case R_PPC64_REL32:
      case R_PPC64_REL64:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct ppc_link_hash_entry *eh;
	    struct ppc_dyn_relocs **pp;
	    struct ppc_dyn_relocs *p;
d2217 11
a2227 2
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    eh = (struct ppc_link_hash_entry *) h;
d2229 2
a2230 11
	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;
d2232 11
a2242 27
      case R_PPC64_ADDR14:
      case R_PPC64_ADDR14_BRNTAKEN:
      case R_PPC64_ADDR14_BRTAKEN:
      case R_PPC64_ADDR16:
      case R_PPC64_ADDR16_DS:
      case R_PPC64_ADDR16_HA:
      case R_PPC64_ADDR16_HI:
      case R_PPC64_ADDR16_HIGHER:
      case R_PPC64_ADDR16_HIGHERA:
      case R_PPC64_ADDR16_HIGHEST:
      case R_PPC64_ADDR16_HIGHESTA:
      case R_PPC64_ADDR16_LO:
      case R_PPC64_ADDR16_LO_DS:
      case R_PPC64_ADDR24:
      case R_PPC64_ADDR30:
      case R_PPC64_ADDR32:
      case R_PPC64_ADDR64:
      case R_PPC64_UADDR16:
      case R_PPC64_UADDR32:
      case R_PPC64_UADDR64:
      case R_PPC64_TOC:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct ppc_link_hash_entry *eh;
	    struct ppc_dyn_relocs **pp;
	    struct ppc_dyn_relocs *p;
d2244 26
a2269 2
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    eh = (struct ppc_link_hash_entry *) h;
d2271 2
a2272 10
	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;
d2274 10
a2283 3
      default:
	break;
      }
d2285 4
d3842 4
a3845 1
  switch ((int) ELF64_R_TYPE (rela->r_info))
@


1.4
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d51 6
d59 2
d72 3
a74 1
static boolean ppc_adjust_dynindx
d76 2
d1368 2
d1374 4
a1377 2
  BFD_ASSERT (ELF64_R_TYPE (dst->r_info) < (unsigned int) R_PPC_max);
  cache_ptr->howto = ppc64_elf_howto_table[ELF64_R_TYPE (dst->r_info)];
d1380 1
a1380 1
/* Handle the R_PPC_ADDR16_HA reloc.  */
d1582 157
a1738 6
/* The following routines are specific to the ELF linker, while
   routines above are used generally.  They appear in this file more
   or less in the order in which they are called from external
   routines.  eg. ppc64_elf_check_relocs is called early in the link
   process, ppc64_elf_finish_dynamic_sections is one of the last
   functions called.  */
d1744 2
a1745 2
ppc64_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
d1748 1
a1748 1
  asection *s;
d1751 2
a1752 1
  if (!_bfd_elf_create_dynamic_sections (abfd, info))
d1755 13
d1769 1
a1769 4
  s = bfd_get_section_by_name (abfd, ".plt");
  if (s == NULL)
    return false;
  flags = bfd_get_section_flags (abfd, s);
d1771 1
a1771 1
  if (! bfd_set_section_flags (abfd, s, flags))
d1777 4
a1780 4
  s = bfd_make_section (abfd, ".glink");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 3))
d1786 22
d1809 2
a1810 2
   allocate space in the global offset table or procedure linkage
   table.  */
d1819 1
a1819 1
  bfd *dynobj;
a1823 1
  bfd_signed_vma *local_got_refcounts;
a1824 2
  asection *sgot = NULL;
  asection *srelgot = NULL;
d1829 1
a1829 7
#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_check_relocs called for section %s in %s\n",
	   bfd_get_section_name (abfd, sec),
	   bfd_archive_filename (abfd));
#endif

  dynobj = elf_hash_table (info)->dynobj;
a1830 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d1856 3
a1859 3
	case R_PPC64_GOT16_HI:
	case R_PPC64_GOT16_HA:
	case R_PPC64_GOT16_DS:
d1861 1
d1863 1
a1863 2

	  if (sgot == NULL)
d1865 3
a1867 3
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
a1868 22
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return false;
		}
d1873 1
a1873 16
	      if (h->got.refcount == -1)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    if (!bfd_elf64_link_record_dynamic_symbol (info, h))
		      return false;

		  /* Allocate space in the .got.  */
		  sgot->_raw_size += 8;
		  /* Allocate relocation space.  */
		  srelgot->_raw_size += sizeof (Elf64_External_Rela);

		  h->got.refcount = 1;
		}
	      else
		h->got.refcount++;
d1877 2
d1880 1
d1888 1
a1888 1
					 bfd_alloc (abfd, size));
a1891 13
		  memset (local_got_refcounts, -1, (size_t) size);
		}
	      if (local_got_refcounts[r_symndx] == -1)
		{
		  sgot->_raw_size += 8;

		  /* If we are generating a shared object, we need to
                     output a R_PPC64_RELATIVE reloc so that the
                     dynamic linker can adjust this GOT entry.  */
		  if (info->shared)
		    srelgot->_raw_size += sizeof (Elf64_External_Rela);

		  local_got_refcounts[r_symndx] = 1;
d1893 1
a1893 2
	      else
		local_got_refcounts[r_symndx]++;
d1897 4
a1901 9
	case R_PPC64_PLT32:
	case R_PPC64_PLT16_LO:
	case R_PPC64_PLT16_HI:
	case R_PPC64_PLT16_HA:
	case R_PPC64_PLTGOT16_DS:
	case R_PPC64_PLTGOT16_LO_DS:
#ifdef DEBUG
	  fprintf (stderr, "Reloc requires a PLT entry\n");
#endif
a1906 1

d1915 2
a1916 13
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
		return false;
	    }
	  if (h->plt.refcount == -1)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount = 1;
	    }
	  else
	    h->plt.refcount++;
a1949 3
	  /* When creating a shared object, we must copy these
	     relocs into the output file.  We create a reloc
	     section in dynobj and make room for the reloc.  */
d1956 20
a1975 4
	  if (h == NULL)
	    break;
	  /* fall through */

d1977 39
a2015 11
	  /* fall through */

	default:
	  if (info->shared)
	    {
#ifdef DEBUG
	      fprintf (stderr, "ppc64_elf_check_relocs need to create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string
			: "<unknown>"));
#endif
d2019 1
d2028 11
a2038 3
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);
d2040 1
d2053 1
a2053 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
d2056 1
d2059 23
a2081 1
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
d2083 9
a2091 6
	      /* FIXME: We should here do what the m68k and i386
		 backends do: if the reloc is pc-relative, record it
		 in case it turns out that the reloc is unnecessary
		 because the symbol is forced local by versioning or
		 we are linking with -Bdynamic.  Fortunately this
		 case is not frequent.  */
d2093 1
d2095 1
a2095 1
	  break;
d2150 2
a2151 1
/* Update the got entry reference counts for the section being removed.  */
d2176 3
d2180 1
a2180 2
      case R_PPC64_GOT16_HI:
      case R_PPC64_GOT16_HA:
d2195 3
d2199 1
a2199 3
      case R_PPC64_PLT16_LO:
      case R_PPC64_PLT16_HI:
      case R_PPC64_PLT16_HA:
d2209 70
d2297 3
a2299 1
  bfd *dynobj = elf_hash_table (info)->dynobj;
a2301 1
  bfd_vma plt_offset;
d2303 1
a2303 4
#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_adjust_dynamic_symbol called for %s\n",
	   h->root.root.string);
#endif
d2305 2
a2306 14
  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this is a function, alter the symbol to refer to global
     linkage code, which will be generated by ppc64_elf_relocate_section.
     Also, allocate a slot in the PLT.  */
d2310 1
a2310 21
      asection *splt, *sglink;

      if (! elf_hash_table (info)->dynamic_sections_created
	  || ((!info->shared || info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_DEF_REGULAR) != 0))
	{
	  /* A PLT entry is not required/allowed when:

	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.

	     2. We know for certain that a symbol is defined in
	     this object, because this object is the application,
	     is linked with -Bsymbolic, or because the symbol is local.

	     We used to end up here for GC if
	     (info->shared && h->plt.refcount <= 0)
	     We can't use plt.refcount here since
	     ppc64_elf_check_relocs can't detect all needs for
	     PLT.  FIXME: Rewrite GC.  */
d2312 17
d2334 23
a2356 61
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sglink = bfd_get_section_by_name (dynobj, ".glink");
      BFD_ASSERT (splt != NULL && sglink != NULL);

      /* If it's a function entry point (the name starts with a dot)
         (FIXME: Could it ever be anything else?), find its
         corresponding function descriptor symbol and make sure it's
         output as a dynamic symbol.  Create it as undefined if
         necessary.  ppc64_elf_finish_dynamic_symbol will look it up
         again and create a JMP_SLOT reloc for it.  FIXME: The second
         lookup could be avoided by adding a new flag to
         elf_link_hash_entry->elf_link_hash_flags.  */

      if (h->root.root.string[0] == '.')
	{
	  struct elf_link_hash_entry *fdh;

	  /* FIXME: Follow bfd_link_hash_indirect?  */
	  fdh = elf_link_hash_lookup (elf_hash_table (info),
				      h->root.root.string + 1,
				      false, false, false);

	  if (fdh == (struct elf_link_hash_entry *) NULL)
	    {
	      asymbol *newsym;

	      /* Create it as undefined.  */
	      newsym = bfd_make_empty_symbol (dynobj);
	      BFD_ASSERT (newsym != NULL);
	      /* FIXME: Need own copy of name? */
	      newsym->name = h->root.root.string + 1;
	      newsym->section = bfd_und_section_ptr;
	      newsym->value = 0;
	      newsym->flags = BSF_DYNAMIC | BSF_OBJECT;

	      if ( ! (_bfd_generic_link_add_one_symbol
		      (info, dynobj, newsym->name, newsym->flags,
		       newsym->section, newsym->value,
		       NULL, /* string */
		       true, /* copy */
		       false, /*collect*/
		       (struct bfd_link_hash_entry **) &fdh)))
		{
		  /* FIXME: Print error message.  */
		  return false;
		}
	      fdh->root.type = bfd_link_hash_undefined;
#ifdef DEBUG
	      fprintf (stderr, "\tcreated %s", newsym->name);
#endif
	    }
#ifdef DEBUG
	  else
	    fprintf (stderr, "\tfound %s", fdh->root.root.string);
	  fprintf (stderr, "\n");
#endif

	  BFD_ASSERT (fdh != NULL);

	  /* Make sure it's output as a dynamic symbol.  */
	  if (fdh->dynindx == -1)
d2358 1
a2358 2
	      if (! bfd_elf64_link_record_dynamic_symbol (info, fdh))
		return false;
a2359 51
	  BFD_ASSERT (fdh->dynindx != -1);
	}

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (splt->_raw_size == 0)
	splt->_raw_size = PLT_INITIAL_ENTRY_SIZE;

      plt_offset = splt->_raw_size;

      /* FIXME: What about function pointer comparisons in 64-bit PPC?
	 We can't use the same trick as 32-bit PPC, since we set the
	 symbol to the linkage function. This will make function entry
	 point comparison work as expected within one object, but not
	 across object boundaries.  From the ABI:

 In this ABI, the address of a function is actually the address of a
 function descriptor.  A reference to a function, other than a function
 call, will normally load the address of the function descriptor from
 the global offset table.  The dynamic linker will ensure that for a
 given function, the same address is used for all references to the
 function from any global offset table.  Thus, function address
 comparisons will work as expected.

 When making a call to the function, the code may refer to the
 procedure linkage table entry, in order to permit lazy symbol
 resolution at run time.  In order to support correct function address
 comparisons, the compiler should be careful to only generate
 references to the procedure linkage table entry for function calls.
 For any other use of a function, the compiler should use the real
 address.

	 I don't see how this could ever work when passing a pointer to
	 a function across an object boundary.  The compiler has no
	 way of knowing how to find the function descriptor for a
	 function whose entrypoint is taken as an argument.

	 Or should the compiler arrange so that the function descriptor
	 address is passed and make the callee dig out the entry point
	 from that?  */
#if 0
      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = splt;
	  h->root.u.def.value = plt_offset;
a2360 22
#endif

      /* FIXME: How should a linkage symbol be defined?  It shouldn't
         be global, since it can't be used by any other object than
         this one.  Set ELF_LINK_FORCED_LOCAL?  */
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = sglink;
      h->root.u.def.value = sglink->_raw_size;
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
      h->plt.offset = plt_offset;

      /* Make room for global linkage code in .glink.  */
      sglink->_raw_size += PPC64_ELF_GLINK_SIZE;

      /* Make room for this entry in PLT.  */
      splt->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf64_External_Rela);

a2372 1
      return true;
d2385 21
a2414 2
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);
d2422 1
a2422 5
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela);
d2433 3
a2435 3
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d2437 1
a2437 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
d2451 13
a2463 2
/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */
d2466 1
a2466 1
ppc_adjust_dynindx (h, cparg)
d2468 1
a2468 1
     PTR cparg;
d2470 24
a2493 1
  int *cp = (int *) cparg;
d2495 11
a2505 6
#ifdef DEBUG
  fprintf (stderr,
	   "ppc_adjust_dynindx: h->dynindx = %ld, *cp = %d (%s)\n",
	   h->dynindx, *cp,
	   h->root.root.string ? h->root.root.string : "<unknown>");
#endif
d2507 3
a2509 2
  if (h->dynindx != -1)
    h->dynindx += *cp;
d2511 2
a2512 2
  return true;
}
d2514 7
a2520 1
/* Set the sizes of the dynamic sections.  */
d2522 5
a2526 10
static boolean
ppc64_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  boolean plt;
  boolean relocs;
  boolean reltext;
d2528 1
a2528 3
#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_size_dynamic_sections called\n");
#endif
d2530 2
a2531 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d2533 17
a2549 4
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
d2551 2
a2552 4
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d2557 2
a2558 8
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got
	 which will cause it to get stripped from the output file
	 below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
d2561 1
a2561 7
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = false;
  relocs = false;
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
d2563 1
a2563 2
      const char *name;
      boolean strip;
d2565 149
a2713 2
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;
d2715 9
a2723 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d2725 2
a2726 1
      strip = false;
d2728 1
a2728 1
      if (strcmp (name, ".plt") == 0)
d2730 3
a2732 1
	  if (s->_raw_size == 0)
d2734 22
a2755 3
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = true;
d2758 22
a2779 4
	    {
	      /* Remember whether there is a PLT.  */
	      plt = true;
	    }
d2781 1
a2781 1
      else if (strncmp (name, ".rela", 5) == 0)
a2793 1
	      strip = true;
d2797 2
a2798 15
	      asection *target;
	      const char *outname;

	      /* Remember whether there are any relocation sections. */
	      relocs = true;

	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;
d2805 1
a2805 3
      else if (strcmp (name, ".got") != 0
	       && strcmp (name, ".toc") != 0
	       && strcmp (name, ".glink") != 0)
d2811 1
a2811 1
      if (strip)
d2817 5
a2821 6
#ifdef DEBUG
      fprintf (stderr, "\tallocating %lu bytes for section %s\n",
	       (unsigned long) s->_raw_size, name);
#endif

      /* Allocate memory for the section contents.  */
d2823 1
a2823 1
      if (s->contents == NULL && s->_raw_size != 0)
d2843 1
a2843 1
      if (plt)
a2857 9
	}

      if (reltext)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
	}
    }
#undef add_dynamic_entry
d2859 3
a2861 13
  /* If we are generating a shared library, we generate a section
     symbol for each output section.  These are local symbols, which
     means that they must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.

     FIXME: We assume that there will never be relocations to
     locations in linker-created sections that do not have
     externally-visible names. Instead, we should work out precisely
     which sections relocations are targetted at.  */
  if (info->shared)
    {
      int c;
d2863 1
a2863 4
      for (c = 0, s = output_bfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LINKER_CREATED) != 0
	      || (s->flags & SEC_ALLOC) == 0)
d2865 2
a2866 2
	      elf_section_data (s)->dynindx = -1;
	      continue;
a2867 7

	  /* These symbols will have no names, so we don't need to
	     fiddle with dynstr_index.  */

	  elf_section_data (s)->dynindx = c + 1;

	  c++;
a2868 5

      elf_link_hash_traverse (elf_hash_table (info),
			      ppc_adjust_dynindx,
			      (PTR) &c);
      elf_hash_table (info)->dynsymcount += c;
d2870 1
d2939 2
a2940 2
  /* Invoke the regular gc ELF backend linker to do all the work.  */
  return _bfd_elf64_gc_common_final_link (abfd, info);
d3001 1
a3003 1
  bfd *dynobj;
a3005 3
  asection *sreloc;
  asection *splt;
  asection *sgot;
d3010 1
a3010 8
#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_relocate_section called for %s section %s, %ld relocations%s\n",
	   bfd_archive_filename (input_bfd),
	   bfd_section_name (input_bfd, input_section),
	   (long) input_section->reloc_count,
	   (info->relocateable) ? " (relocatable)" : "");
#endif

a3011 1
    /* Initialize howto table if needed.  */
d3014 1
a3015 10

  sreloc = NULL;
  splt = NULL;
  sgot = NULL;
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj != NULL)
    {
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got");
    }
a3016 1

d3019 1
a3031 1
      reloc_howto_type *howto;
d3034 1
a3037 21
      offset = rel->r_offset;
      addend = rel->r_addend;
      r = bfd_reloc_other;
      sym = (Elf_Internal_Sym *) 0;
      sec = (asection *) 0;
      h = (struct elf_link_hash_entry *) 0;
      sym_name = (const char *) 0;

      /* Unknown relocation handling.  */
      if ((unsigned) r_type >= (unsigned) R_PPC_max
	  || !ppc64_elf_howto_table[(int) r_type])
	{
	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
				 bfd_archive_filename (input_bfd),
				 (int) r_type);
	  bfd_set_error (bfd_error_bad_value);
	  ret = false;
	  continue;
	}

      howto = ppc64_elf_howto_table[(int) r_type];
d3052 1
a3052 1
		  addend = rel->r_addend += sec->output_offset + sym->st_value;
a3054 9

#ifdef DEBUG
	  fprintf (stderr, "\ttype = %s (%d), symbol index = %ld, offset = %ld, addend = %ld\n",
		   howto->name,
		   (int) r_type,
		   r_symndx,
		   (long) offset,
		   (long) addend);
#endif
d3060 9
a3068 1
      /* Set `relocation'.  */
d3093 1
d3098 6
a3103 46
	      if ((r_type == R_PPC64_PLT32
		   && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_PPC64_GOT16
		       || r_type == R_PPC64_GOT16_LO
		       || r_type == R_PPC64_GOT16_HI
		       || r_type == R_PPC64_GOT16_HA
		       || r_type == R_PPC64_GOT16_DS
		       || r_type == R_PPC64_GOT16_LO_DS)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && (input_section->flags & SEC_ALLOC) != 0
		      && (r_type == R_PPC64_ADDR64
			  || r_type == R_PPC64_ADDR32
			  || r_type == R_PPC64_ADDR24
			  || r_type == R_PPC64_ADDR16
			  || r_type == R_PPC64_ADDR16_LO
			  || r_type == R_PPC64_ADDR16_DS
			  || r_type == R_PPC64_ADDR16_LO_DS
			  || r_type == R_PPC64_ADDR16_HI
			  || r_type == R_PPC64_ADDR16_HA
			  || r_type == R_PPC64_ADDR16_HIGHER
			  || r_type == R_PPC64_ADDR16_HIGHERA
			  || r_type == R_PPC64_ADDR16_HIGHEST
			  || r_type == R_PPC64_ADDR16_HIGHESTA
			  || r_type == R_PPC64_ADDR14
			  || r_type == R_PPC64_ADDR14_BRTAKEN
			  || r_type == R_PPC64_ADDR14_BRNTAKEN
			  || r_type == R_PPC64_COPY
			  || r_type == R_PPC64_GLOB_DAT
			  || r_type == R_PPC64_JMP_SLOT
			  || r_type == R_PPC64_UADDR64
			  || r_type == R_PPC64_UADDR32
			  || r_type == R_PPC64_UADDR16)))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
d3110 1
a3110 1
	    relocation = 0;
d3112 4
a3115 3
	       && (!info->symbolic || info->allow_shlib_undefined)
	       && !info->no_undefined)
	    relocation = 0;
d3120 3
a3122 3
		      rel->r_offset, (!info->shared
				      || info->no_undefined
				      || ELF_ST_VISIBILITY (h->other)))))
d3128 2
a3129 1
      switch ((int) r_type)
d3131 2
a3132 21
	case (int) R_PPC64_ADDR16_DS:
	case (int) R_PPC64_ADDR16_LO_DS:
	case (int) R_PPC64_GOT16_DS:
	case (int) R_PPC64_GOT16_LO_DS:
	case (int) R_PPC64_PLT16_LO_DS:
	case (int) R_PPC64_SECTOFF_DS:
	case (int) R_PPC64_SECTOFF_LO_DS:
	case (int) R_PPC64_TOC16_DS:
	case (int) R_PPC64_TOC16_LO_DS:
	case (int) R_PPC64_PLTGOT16_DS:
	case (int) R_PPC64_PLTGOT16_LO_DS:
	  if (((relocation + addend) & 3) != 0)
	    {
	      (*_bfd_error_handler) (_("%s: error: relocation %s not a multiple of 4"),
				     bfd_archive_filename (input_bfd),
				     howto->name);
	      bfd_set_error (bfd_error_bad_value);
	      ret = false;
	      continue;
	    }
	}
d3134 10
a3143 7
      /* Set `addend'.  */
      switch ((int) r_type)
	{
	default:
	  (*_bfd_error_handler) (_("%s: unknown relocation type %d for symbol %s"),
				 bfd_archive_filename (input_bfd),
				 (int) r_type, sym_name);
d3145 10
a3154 3
	  bfd_set_error (bfd_error_bad_value);
	  ret = false;
	  continue;
d3156 2
a3157 4
	  /* Relocations that may need to be propagated if this is a shared
	     object.  */
	case (int) R_PPC64_REL24:
	case (int) R_PPC64_ADDR24:
d3159 1
a3159 1
	     followed by a nop that we have to replace with an ld in
d3167 1
a3167 2
	      && (rel->r_offset - input_section->vma + 8
		  <= input_section->_cooked_size))
d3171 1
a3171 1
	      pnext = contents + (rel->r_offset - input_section->vma) + 4;
a3180 4
#ifdef DEBUG
		  fprintf (stderr, "ppc64_elf_relocate_section: " \
			   "patched nop after call to %s\n", sym_name);
#endif
d3183 2
a3184 1
	  /* fall through */
d3186 7
a3192 8
	case (int) R_PPC64_REL64:
	case (int) R_PPC64_REL32:
	case (int) R_PPC64_REL14:
	  /* If these relocations are not to a named symbol, they can be
	     handled right here, no need to bother the dynamic linker.  */
	  if (h == NULL && r_type != R_PPC64_ADDR24)
	    break;
	  /* fall through */
d3194 3
a3196 24
	  /* Relocations that always need to be propagated if this is a shared
	     object.  */
	case (int) R_PPC64_NONE:
	case (int) R_PPC64_ADDR64:
	case (int) R_PPC64_ADDR32:
	case (int) R_PPC64_ADDR16:
	case (int) R_PPC64_ADDR16_LO:
	case (int) R_PPC64_ADDR16_DS:
	case (int) R_PPC64_ADDR16_LO_DS:
	case (int) R_PPC64_ADDR16_HI:
	case (int) R_PPC64_ADDR16_HA:
	case (int) R_PPC64_ADDR16_HIGHER:
	case (int) R_PPC64_ADDR16_HIGHERA:
	case (int) R_PPC64_ADDR16_HIGHEST:
	case (int) R_PPC64_ADDR16_HIGHESTA:
	case (int) R_PPC64_ADDR14:
	case (int) R_PPC64_UADDR64:
	case (int) R_PPC64_UADDR32:
	case (int) R_PPC64_UADDR16:
	case (int) R_PPC64_TOC:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      boolean skip;
d3198 4
a3201 6
#ifdef DEBUG
	      fprintf (stderr, "ppc64_elf_relocate_section need to create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string
			: "<unknown>"));
#endif
d3203 14
a3216 3
	      /* When generating a shared object, these relocations
                 are copied into the output file to be resolved at run
                 time.  */
d3218 2
a3219 3
	      if (sreloc == NULL)
		{
		  const char *name;
d3221 3
a3223 6
		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;
d3225 19
a3243 4
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);
d3245 19
a3263 3
		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}
d3265 163
a3427 1
	      skip = false;
d3430 1
a3430 1
		outrel.r_offset = rel->r_offset;
d3436 1
a3436 2
			 (output_bfd, &elf_hash_table (info)->stab_info,
			  input_section,
d3438 1
a3438 1
			  rel->r_offset));
d3446 1
d3449 4
a3452 3
		memset (&outrel, 0, sizeof outrel);
	      /* h->dynindx may be -1 if this symbol was marked to
                 become local.  */
d3454 4
a3457 1
		       && ((! info->symbolic && h->dynindx != -1)
d3461 1
a3461 1
		  BFD_ASSERT (h->dynindx != -1);
a3462 1
		  outrel.r_addend = rel->r_addend;
d3466 3
a3471 1
		      outrel.r_addend = relocation + rel->r_addend;
d3475 1
a3475 1
		      long indx;
d3477 2
a3478 15
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}

		      if (r_type == R_PPC64_TOC
			  || (sec != NULL && bfd_is_abs_section (sec)))
			{
			  indx = 0;
			}
d3490 7
a3496 9
			  BFD_ASSERT (indx > 0);
#ifdef DEBUG
			  if (indx <= 0)
			    {
			      printf ("indx=%ld section=%s flags=%08x name=%s\n",
				      indx, osec->name, osec->flags,
				      h->root.root.string);
			    }
#endif
a3499 1
		      outrel.r_addend = relocation + rel->r_addend;
d3503 12
a3514 12
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					 (((Elf64_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;

	      /* This reloc will be computed at runtime, so there's no
                 need to do anything now, unless this is a RELATIVE
                 reloc in an unallocated section.  */
	      if (skip
		  || (input_section->flags & SEC_ALLOC) != 0
		  || ELF64_R_TYPE (outrel.r_info) != R_PPC64_RELATIVE)
a3516 14

	  /* Arithmetic adjust relocations that aren't going into a
	     shared object.  */
	  if ((r_type == R_PPC64_ADDR16_HA
	       || r_type == R_PPC64_ADDR16_HIGHERA
	       || r_type == R_PPC64_ADDR16_HIGHESTA)
	      /* It's just possible that this symbol is a weak symbol
		 that's not actually defined anywhere. In that case,
		 'sec' would be NULL, and we should leave the symbol
		 alone (it will be set to zero elsewhere in the link).  */
	      && sec != NULL)
	    {
	      addend += ((relocation + addend) & 0x8000) << 1;
	    }
d3519 7
a3525 10
	  /* Branch taken prediction relocations.  */
	case (int) R_PPC64_ADDR14_BRTAKEN:
	case (int) R_PPC64_REL14_BRTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn &= ~BRANCH_PREDICT_BIT;
	  else
	    insn |= BRANCH_PREDICT_BIT;
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
	  break;
d3527 9
a3535 10
	  /* Branch not taken predicition relocations.  */
	case (int) R_PPC64_ADDR14_BRNTAKEN:
	case (int) R_PPC64_REL14_BRNTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn |= BRANCH_PREDICT_BIT;
	  else
	    insn &= ~BRANCH_PREDICT_BIT;
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
	  break;
d3537 4
d3542 4
a3545 19
	  /* GOT16 relocations.  Like an ADDR16 using the symbol's
	     address in the GOT as relocation value instead of the
	     symbols value itself.  Also, create a GOT entry for the
	     symbol and put the symbol value there.  */
	  /* FIXME: If the symbol is not in the .got section
	     (typically in the .toc section) we fail (h->got.offset is
	     0).  */
	  /* NOTE: Sets `relocation'.  */
	case (int) R_PPC64_GOT16:
	case (int) R_PPC64_GOT16_LO:
	case (int) R_PPC64_GOT16_HI:
	case (int) R_PPC64_GOT16_HA:
	case (int) R_PPC64_GOT16_DS:
	case (int) R_PPC64_GOT16_LO_DS:
	  {
	    /* Relocation is to the entry for this symbol in the global
	       offset table.  */
	    bfd_vma off;
	    BFD_ASSERT (sgot != NULL);
d3547 4
a3550 99
	    if (h != NULL)
	      {
		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) -1);

		if (! elf_hash_table (info)->dynamic_sections_created
		    || (info->shared
			&& (info->symbolic || h->dynindx == -1)
			&& (h->elf_link_hash_flags
			    & ELF_LINK_HASH_DEF_REGULAR)))
		  {
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally.  We must initialize this entry in the
		       global offset table.  Since the offset must
		       always be a multiple of 4, we use the least
		       significant bit to record whether we have
		       initialized it already.

		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			bfd_put_64 (output_bfd, relocation,
				    sgot->contents + off);
			h->got.offset |= 1;
		      }
		  }
	      }
	    else
	      {
		BFD_ASSERT (local_got_offsets != NULL
			    && local_got_offsets[r_symndx] != (bfd_vma) -1);

		off = local_got_offsets[r_symndx];

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already processed this entry.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    bfd_put_64 (output_bfd, relocation, sgot->contents + off);

		    if (info->shared)
		      {
			asection *srelgot;
			Elf_Internal_Rela outrel;

			/* We need to generate a R_PPC64_RELATIVE reloc
			   for the dynamic linker.  */
			srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (srelgot != NULL);

			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset
					   + off);
			outrel.r_info = ELF64_R_INFO (0, R_PPC64_RELATIVE);
			outrel.r_addend = relocation;
			bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						   (((Elf64_External_Rela *)
						     srelgot->contents)
						    + srelgot->reloc_count));
			++srelgot->reloc_count;
		      }

		    local_got_offsets[r_symndx] |= 1;
		  }
	      }

	    relocation = sgot->output_offset + off;
	    /* TOC base (r2) is TOC start plus 0x8000.  */
	    addend -= TOC_BASE_OFF;
	    break;
	  }

	  /* TOC16 relocs.  We want the offset relative to the TOC base,
	     which is the address of the start of the TOC plus 0x8000.
	     The TOC consists of sections .got, .toc, .tocbss, and .plt,
	     in this order.  */

	case (int) R_PPC64_TOC16:
	case (int) R_PPC64_TOC16_LO:
	case (int) R_PPC64_TOC16_HI:
	case (int) R_PPC64_TOC16_DS:
	case (int) R_PPC64_TOC16_LO_DS:
	  BFD_ASSERT (sec != (asection *) 0);
	  /* Only .got, .toc and *UND* symbols are allowed.  */
	  BFD_ASSERT (bfd_is_und_section (sec)
		      || strcmp (bfd_get_section_name (abfd, sec),
				 ".got") == 0
		      || strcmp (bfd_get_section_name (abfd, sec),
				 ".toc") == 0);

	  addend -= TOCstart + TOC_BASE_OFF;
d3553 13
a3565 11
	case (int) R_PPC64_TOC16_HA:
	  BFD_ASSERT (sec != (asection *) 0);
	  BFD_ASSERT (bfd_is_und_section (sec)
		      || strcmp (bfd_get_section_name (abfd, sec),
				 ".got") == 0
		      || strcmp (bfd_get_section_name (abfd, sec),
				 ".toc") == 0);

	  addend -= TOCstart + TOC_BASE_OFF;
	  /* Add 1 to 16-bit word 16:31 if sign bit in 0:15 is set.  */
	  addend += ((relocation + addend) & 0x8000) << 1;
d3568 21
a3588 14
	  /* Relocate against the beginning of the section.  */
	case (int) R_PPC64_SECTOFF:
	case (int) R_PPC64_SECTOFF_LO:
	case (int) R_PPC64_SECTOFF_HI:
	case (int) R_PPC64_SECTOFF_DS:
	case (int) R_PPC64_SECTOFF_LO_DS:
	  BFD_ASSERT (sec != (asection *) 0);
	  addend -= sec->output_section->vma;
	  break;

	case (int) R_PPC64_SECTOFF_HA:
	  BFD_ASSERT (sec != (asection *) 0);
	  addend -= sec->output_section->vma;
	  addend += ((relocation + addend) & 0x8000) << 1;
a3589 32

	case (int) R_PPC64_COPY:
	case (int) R_PPC64_GLOB_DAT:
	case (int) R_PPC64_JMP_SLOT:
	case (int) R_PPC64_RELATIVE:
	case (int) R_PPC64_PLT32:
	case (int) R_PPC64_PLTREL32:
	case (int) R_PPC64_PLT16_LO:
	case (int) R_PPC64_PLT16_LO_DS:
	case (int) R_PPC64_PLT16_HI:
	case (int) R_PPC64_PLT16_HA:
	case (int) R_PPC64_PLT64:
	case (int) R_PPC64_PLTREL64:
	case (int) R_PPC64_PLTGOT16:
	case (int) R_PPC64_PLTGOT16_LO:
	case (int) R_PPC64_PLTGOT16_DS:
	case (int) R_PPC64_PLTGOT16_LO_DS:
	case (int) R_PPC64_PLTGOT16_HI:
	case (int) R_PPC64_PLTGOT16_HA:
	  (*_bfd_error_handler) (_("%s: Relocation %s is not yet supported for symbol %s."),
				 bfd_archive_filename (input_bfd),
				 ppc64_elf_howto_table[(int) r_type]->name,
				 sym_name);

	  bfd_set_error (bfd_error_invalid_operation);
	  ret = false;
	  continue;

	case (int) R_PPC_GNU_VTINHERIT:
	case (int) R_PPC_GNU_VTENTRY:
	  /* These are no-ops in the end.  */
	  continue;
d3592 14
a3605 9
#ifdef DEBUG
      fprintf (stderr, "  type = %s (%d), name = %s, sym index = %ld, offset = %ld, addend = %ld\n",
	       howto->name,
	       (int) r_type,
	       sym_name,
	       r_symndx,
	       (long) offset,
	       (long) addend);
#endif
d3607 1
a3607 1
      r = _bfd_final_link_relocate (howto,
d3624 1
a3624 1
		  && howto->pc_relative)
d3648 3
a3650 7
	  if (! (*info->callbacks->reloc_overflow) (info,
						    name,
						    howto->name,
						    (bfd_vma) 0,
						    input_bfd,
						    input_section,
						    offset))
a3656 4
#ifdef DEBUG
  fprintf (stderr, "\n");
#endif

d3670 1
d3673 2
a3674 7
#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_finish_dynamic_symbol called for %s",
	   h->root.root.string);
#endif

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d3678 1
a3678 1
      asection *splt, *srela, *sglink;
d3680 1
a3680 6
      bfd_vma reloc_index, plt_offset;
      struct elf_link_hash_entry *funcdesc_h;

#ifdef DEBUG
      fprintf (stderr, ", plt_offset = 0x%lx", (unsigned long) h->plt.offset);
#endif
d3685 10
a3694 1
      BFD_ASSERT (h->dynindx != -1);
d3696 22
a3717 10
      splt = bfd_get_section_by_name (dynobj, ".plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && srela != NULL);

      /* We don't need to fill in the .plt.  The dynamic linker will
	 fill it in.  */

      /* We may need to create a linkage function. */
      sglink = bfd_get_section_by_name (dynobj, ".glink");
      if (sglink != NULL && h->root.u.def.section == sglink)
d3727 2
a3728 2
	  pltoff = splt->output_section->vma
	    + splt->output_section->output_offset
a3747 3
#ifdef DEBUG
	  fprintf (stderr, ", linkage function");
#endif
d3749 2
a3750 47

      /* Create a JMP_SLOT reloc to inform the dynamic linker to fix
         the PLT entry.  */

      /* Save the PLT offset, since `h' may be changed below.  */
      plt_offset = h->plt.offset;

      /* If it's a function entry point, find its corresponding
	 function descriptor.  ppc64_elf_adjust_dynamic_symbol have
	 already set it up for us.  */

      /* FIXME: Is it safe to assume that this symbol is a function?  */
      BFD_ASSERT (h->root.root.string[0] == '.');

      /* FIXME: Follow bfd_link_hash_indirect?  */
      funcdesc_h = elf_link_hash_lookup (elf_hash_table (info),
					 h->root.root.string + 1,
					 false, false, false);
      BFD_ASSERT (funcdesc_h != NULL);
      BFD_ASSERT (funcdesc_h->dynindx != -1);

      /* FIXME: Rename the symbol for the function entry point to
         `linkage_for_FUNC'?  */

      rela.r_offset = (splt->output_section->vma
		       + splt->output_offset
		       + plt_offset);
      rela.r_info = ELF64_R_INFO (funcdesc_h->dynindx, R_PPC64_JMP_SLOT);
      rela.r_addend = 0;

      reloc_index = (plt_offset - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE;
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + reloc_index));
#ifdef DEBUG
      fprintf (stderr, ", JMP_SLOT for %s", funcdesc_h->root.root.string);
#endif

#if 0
      /* FIXME: Really do this?  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
#endif
a3754 2
      asection *sgot;
      asection *srela;
d3756 1
a3756 4

#ifdef DEBUG
      fprintf (stderr, ", got.offset = %08lx", (unsigned long) h->got.offset);
#endif
d3761 2
a3762 3
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);
d3764 2
a3765 2
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
d3768 5
a3772 4
      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  The entry in
	 the global offset table will already have been initialized in
	 the relocate_section function.  */
d3774 3
a3776 1
	  && (info->symbolic || h->dynindx == -1)
d3779 1
d3788 2
a3789 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d3794 3
a3796 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
a3800 1
      asection *s;
d3802 1
d3804 1
a3804 1
      /* This symbols needs a copy reloc.  Set it up.  */
d3806 5
a3810 9
#ifdef DEBUG
      fprintf (stderr, ", copy");
#endif

      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
d3817 3
a3819 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
a3821 4
#ifdef DEBUG
  fprintf (stderr, "\n");
#endif

d3829 20
d3856 2
a3858 5
  bfd *dynobj = elf_hash_table (info)->dynobj;

#ifdef DEBUG
  fprintf (stderr, "ppc64_elf_finish_dynamic_sections called\n");
#endif
d3860 2
d3864 1
a3864 1
  if (elf_hash_table (info)->dynamic_sections_created)
a3865 1
      asection *splt;
d3868 2
a3869 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);
a3875 2
	  const char *name;
	  boolean size;
d3881 6
a3886 5
	    case DT_PLTGOT:   name = ".plt";	  size = false; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = true;  break;
	    case DT_JMPREL:   name = ".rela.plt"; size = false; break;
	    default:	      name = NULL;	  size = false; break;
	    }
d3888 3
a3890 3
	  if (name != NULL)
	    {
	      asection *s;
d3892 3
a3894 3
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s == NULL)
		dyn.d_un.d_val = 0;
d3896 2
a3897 12
		{
		  if (! size)
		    dyn.d_un.d_ptr = s->vma;
		  else
		    {
		      if (s->_cooked_size != 0)
			dyn.d_un.d_val = s->_cooked_size;
		      else
			dyn.d_un.d_val = s->_raw_size;
		    }
		}
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
a3898 19
	}
    }

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;
      int maxdindx = 0;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;
d3900 1
a3900 23
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx, dindx;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  dindx = elf_section_data (s)->dynindx;
	  if (dindx != -1)
	    {
	      BFD_ASSERT (indx > 0);
	      BFD_ASSERT (dindx > 0);

	      if (dindx > maxdindx)
		maxdindx = dindx;

	      sym.st_shndx = indx;

	      bfd_elf64_swap_symbol_out (output_bfd, &sym,
					 (PTR) (((Elf64_External_Sym *)
						 sdynsym->contents)
						+ dindx));
	    }
a3901 5

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	maxdindx + 1;
d3931 1
d3935 20
a3954 17
#define bfd_elf64_bfd_copy_private_bfd_data	ppc64_elf_copy_private_bfd_data
#define bfd_elf64_bfd_merge_private_bfd_data	ppc64_elf_merge_private_bfd_data
#define bfd_elf64_bfd_reloc_type_lookup		ppc64_elf_reloc_type_lookup
#define bfd_elf64_bfd_set_private_flags		ppc64_elf_set_private_flags
#define bfd_elf64_bfd_final_link		ppc64_elf_final_link

#define elf_backend_gc_mark_hook		ppc64_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook		ppc64_elf_gc_sweep_hook
#define elf_backend_section_from_shdr		ppc64_elf_section_from_shdr
#define elf_backend_relocate_section		ppc64_elf_relocate_section
#define elf_backend_create_dynamic_sections	ppc64_elf_create_dynamic_sections
#define elf_backend_check_relocs		ppc64_elf_check_relocs
#define elf_backend_adjust_dynamic_symbol	ppc64_elf_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections	ppc64_elf_size_dynamic_sections
#define elf_backend_finish_dynamic_symbol	ppc64_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections	ppc64_elf_finish_dynamic_sections
#define elf_backend_fake_sections		ppc64_elf_fake_sections
@


1.3
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1457 1
a1457 1
      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));
d1491 1
a1491 1
	     bfd_get_filename (ibfd));
d1499 1
a1499 1
	     bfd_get_filename (ibfd));
d1526 1
a1526 1
	     bfd_get_filename (ibfd), (long) new_flags, (long) old_flags);
d1635 1
a1635 1
	   bfd_get_filename (abfd));
d2673 1
a2673 1
	   bfd_get_filename (input_bfd),
d2729 1
a2729 1
				 bfd_get_filename (input_bfd),
d2882 1
a2882 1
				     bfd_get_filename (input_bfd),
d2895 1
a2895 1
				 bfd_get_filename (input_bfd),
d3312 1
a3312 1
				 bfd_get_filename (input_bfd),
@


1.2
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2850 3
a2852 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
@


1.1
log
@	* config.bfd: Add powerpc64 target.  Add powerpc64 vectors to
	targ64_selvecs for 32 bit powerpc targets.
	* Makefile.am (BFD64_BACKENDS): Add elf64-ppc.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-ppc.c.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in: Add elf64_powerpc vecs.
	* configure: Regenerate.
	* cpu-powerpc.c: Default to bfd_mach_ppc_620 entry for 64 bit.
	* elf.c (prep_headers): EM_PPC64 for 64 bit ppc elf target.
	* targets.c: Add bfd_elf64_powerpc_vec and bfd_elf64_powerpcle_vec.
	* elf64-ppc.c: New file.
	* reloc.c: Add powerpc64 relocs.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1727 1
a1727 1
		  size_t size;
d1729 4
a1732 3
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
		  local_got_refcounts = (bfd_signed_vma *)
		    bfd_alloc (abfd, size);
d1736 1
a1736 1
		  memset (local_got_refcounts, -1, size);
d2459 4
a2462 1
      if (! info->shared)
d2464 1
a2464 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d2470 4
a2473 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d2479 3
a2481 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf64_External_Rela)))
d2487 1
a2487 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d2491 1
a2669 1
  long insn;
d2713 1
a2916 1
	      unsigned long insn;
d2923 1
a2923 1
		  || insn == 0x4ffffb82)   /* cror 31,31,31 */
d2925 3
a2927 1
		  bfd_put_32 (input_bfd, 0xe8410028, pnext); /* ld r2,40(r1) */
d3126 1
a3126 1
	  bfd_put_32 (output_bfd, insn, contents + offset);
d3137 1
a3137 1
	  bfd_put_32 (output_bfd, insn, contents + offset);
d3469 1
a3469 1
	      bfd_put_32 (output_bfd, *stub, p);
d3543 1
a3543 1
		       + (h->got.offset &~ 1));
@

