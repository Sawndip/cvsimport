head	1.69;
access;
symbols
	sid-snapshot-20180601:1.69
	sid-snapshot-20180501:1.69
	sid-snapshot-20180401:1.69
	sid-snapshot-20180301:1.69
	sid-snapshot-20180201:1.69
	sid-snapshot-20180101:1.69
	sid-snapshot-20171201:1.69
	sid-snapshot-20171101:1.69
	sid-snapshot-20171001:1.69
	sid-snapshot-20170901:1.69
	sid-snapshot-20170801:1.69
	sid-snapshot-20170701:1.69
	sid-snapshot-20170601:1.69
	sid-snapshot-20170501:1.69
	sid-snapshot-20170401:1.69
	sid-snapshot-20170301:1.69
	sid-snapshot-20170201:1.69
	sid-snapshot-20170101:1.69
	sid-snapshot-20161201:1.69
	sid-snapshot-20161101:1.69
	sid-snapshot-20160901:1.69
	sid-snapshot-20160801:1.69
	sid-snapshot-20160701:1.69
	sid-snapshot-20160601:1.69
	sid-snapshot-20160501:1.69
	sid-snapshot-20160401:1.69
	sid-snapshot-20160301:1.69
	sid-snapshot-20160201:1.69
	sid-snapshot-20160101:1.69
	sid-snapshot-20151201:1.69
	sid-snapshot-20151101:1.69
	sid-snapshot-20151001:1.69
	sid-snapshot-20150901:1.69
	sid-snapshot-20150801:1.69
	sid-snapshot-20150701:1.69
	sid-snapshot-20150601:1.69
	sid-snapshot-20150501:1.69
	sid-snapshot-20150401:1.69
	sid-snapshot-20150301:1.69
	sid-snapshot-20150201:1.69
	sid-snapshot-20150101:1.69
	sid-snapshot-20141201:1.69
	sid-snapshot-20141101:1.69
	sid-snapshot-20141001:1.69
	sid-snapshot-20140901:1.69
	sid-snapshot-20140801:1.69
	sid-snapshot-20140701:1.69
	sid-snapshot-20140601:1.69
	sid-snapshot-20140501:1.69
	sid-snapshot-20140401:1.69
	sid-snapshot-20140301:1.69
	sid-snapshot-20140201:1.69
	sid-snapshot-20140101:1.69
	sid-snapshot-20131201:1.69
	sid-snapshot-20131101:1.69
	sid-snapshot-20131001:1.69
	binutils-2_24-branch:1.69.0.2
	binutils-2_24-branchpoint:1.69
	binutils-2_21_1:1.63
	sid-snapshot-20130901:1.69
	gdb_7_6_1-2013-08-30-release:1.68
	sid-snapshot-20130801:1.69
	sid-snapshot-20130701:1.69
	sid-snapshot-20130601:1.69
	sid-snapshot-20130501:1.69
	gdb_7_6-2013-04-26-release:1.68
	sid-snapshot-20130401:1.69
	binutils-2_23_2:1.68
	gdb_7_6-branch:1.68.0.6
	gdb_7_6-2013-03-12-branchpoint:1.68
	sid-snapshot-20130301:1.68
	sid-snapshot-20130201:1.68
	sid-snapshot-20130101:1.68
	sid-snapshot-20121201:1.68
	gdb_7_5_1-2012-11-29-release:1.68
	binutils-2_23_1:1.68
	sid-snapshot-20121101:1.68
	binutils-2_23:1.68
	sid-snapshot-20121001:1.68
	sid-snapshot-20120901:1.68
	gdb_7_5-2012-08-17-release:1.68
	sid-snapshot-20120801:1.68
	binutils-2_23-branch:1.68.0.4
	binutils-2_23-branchpoint:1.68
	gdb_7_5-branch:1.68.0.2
	gdb_7_5-2012-07-18-branchpoint:1.68
	sid-snapshot-20120701:1.67
	sid-snapshot-20120601:1.67
	sid-snapshot-20120501:1.65
	binutils-2_22_branch:1.64.0.6
	gdb_7_4_1-2012-04-26-release:1.64
	sid-snapshot-20120401:1.64
	sid-snapshot-20120301:1.64
	sid-snapshot-20120201:1.64
	gdb_7_4-2012-01-24-release:1.64
	sid-snapshot-20120101:1.64
	gdb_7_4-branch:1.64.0.4
	gdb_7_4-2011-12-13-branchpoint:1.64
	sid-snapshot-20111201:1.64
	binutils-2_22:1.64
	sid-snapshot-20111101:1.64
	sid-snapshot-20111001:1.64
	binutils-2_22-branch:1.64.0.2
	binutils-2_22-branchpoint:1.64
	gdb_7_3_1-2011-09-04-release:1.63
	sid-snapshot-20110901:1.64
	sid-snapshot-20110801:1.64
	gdb_7_3-2011-07-26-release:1.63
	sid-snapshot-20110701:1.63
	sid-snapshot-20110601:1.63
	sid-snapshot-20110501:1.63
	gdb_7_3-branch:1.63.0.4
	gdb_7_3-2011-04-01-branchpoint:1.63
	sid-snapshot-20110401:1.63
	sid-snapshot-20110301:1.63
	sid-snapshot-20110201:1.63
	sid-snapshot-20110101:1.63
	binutils-2_21:1.63
	sid-snapshot-20101201:1.63
	binutils-2_21-branch:1.63.0.2
	binutils-2_21-branchpoint:1.63
	sid-snapshot-20101101:1.63
	sid-snapshot-20101001:1.62
	binutils-2_20_1:1.61
	gdb_7_2-2010-09-02-release:1.62
	sid-snapshot-20100901:1.62
	sid-snapshot-20100801:1.62
	gdb_7_2-branch:1.62.0.2
	gdb_7_2-2010-07-07-branchpoint:1.62
	sid-snapshot-20100701:1.62
	sid-snapshot-20100601:1.61
	sid-snapshot-20100501:1.61
	sid-snapshot-20100401:1.61
	gdb_7_1-2010-03-18-release:1.61
	sid-snapshot-20100301:1.61
	gdb_7_1-branch:1.61.0.6
	gdb_7_1-2010-02-18-branchpoint:1.61
	sid-snapshot-20100201:1.61
	sid-snapshot-20100101:1.61
	gdb_7_0_1-2009-12-22-release:1.61
	sid-snapshot-20091201:1.61
	sid-snapshot-20091101:1.61
	binutils-2_20:1.61
	gdb_7_0-2009-10-06-release:1.61
	sid-snapshot-20091001:1.61
	gdb_7_0-branch:1.61.0.4
	gdb_7_0-2009-09-16-branchpoint:1.61
	arc-sim-20090309:1.57
	binutils-arc-20081103-branch:1.57.0.22
	binutils-arc-20081103-branchpoint:1.57
	binutils-2_20-branch:1.61.0.2
	binutils-2_20-branchpoint:1.61
	sid-snapshot-20090901:1.60
	sid-snapshot-20090801:1.60
	msnyder-checkpoint-072509-branch:1.59.0.4
	msnyder-checkpoint-072509-branchpoint:1.59
	sid-snapshot-20090701:1.59
	dje-cgen-play1-branch:1.59.0.2
	dje-cgen-play1-branchpoint:1.59
	sid-snapshot-20090601:1.59
	sid-snapshot-20090501:1.57
	sid-snapshot-20090401:1.57
	arc-20081103-branch:1.57.0.20
	arc-20081103-branchpoint:1.57
	arc-insight_6_8-branch:1.57.0.18
	arc-insight_6_8-branchpoint:1.57
	insight_6_8-branch:1.57.0.16
	insight_6_8-branchpoint:1.57
	sid-snapshot-20090301:1.57
	binutils-2_19_1:1.57
	sid-snapshot-20090201:1.57
	sid-snapshot-20090101:1.57
	reverse-20081226-branch:1.57.0.14
	reverse-20081226-branchpoint:1.57
	sid-snapshot-20081201:1.57
	multiprocess-20081120-branch:1.57.0.12
	multiprocess-20081120-branchpoint:1.57
	sid-snapshot-20081101:1.57
	binutils-2_19:1.57
	sid-snapshot-20081001:1.57
	reverse-20080930-branch:1.57.0.10
	reverse-20080930-branchpoint:1.57
	binutils-2_19-branch:1.57.0.8
	binutils-2_19-branchpoint:1.57
	sid-snapshot-20080901:1.57
	sid-snapshot-20080801:1.57
	reverse-20080717-branch:1.57.0.6
	reverse-20080717-branchpoint:1.57
	sid-snapshot-20080701:1.57
	msnyder-reverse-20080609-branch:1.57.0.4
	msnyder-reverse-20080609-branchpoint:1.57
	drow-reverse-20070409-branch:1.53.0.2
	drow-reverse-20070409-branchpoint:1.53
	sid-snapshot-20080601:1.57
	sid-snapshot-20080501:1.57
	sid-snapshot-20080403:1.57
	sid-snapshot-20080401:1.57
	gdb_6_8-2008-03-27-release:1.57
	sid-snapshot-20080301:1.57
	gdb_6_8-branch:1.57.0.2
	gdb_6_8-2008-02-26-branchpoint:1.57
	sid-snapshot-20080201:1.57
	sid-snapshot-20080101:1.57
	sid-snapshot-20071201:1.57
	sid-snapshot-20071101:1.57
	gdb_6_7_1-2007-10-29-release:1.55
	gdb_6_7-2007-10-10-release:1.55
	sid-snapshot-20071001:1.57
	gdb_6_7-branch:1.55.0.4
	gdb_6_7-2007-09-07-branchpoint:1.55
	binutils-2_18:1.55
	binutils-2_18-branch:1.55.0.2
	binutils-2_18-branchpoint:1.55
	insight_6_6-20070208-release:1.51
	binutils-csl-coldfire-4_1-32:1.47
	binutils-csl-sourcerygxx-4_1-32:1.47
	gdb_6_6-2006-12-18-release:1.51
	binutils-csl-innovasic-fido-3_4_4-33:1.47
	binutils-csl-sourcerygxx-3_4_4-32:1.41
	binutils-csl-coldfire-4_1-30:1.47
	binutils-csl-sourcerygxx-4_1-30:1.47
	binutils-csl-coldfire-4_1-28:1.47
	binutils-csl-sourcerygxx-4_1-29:1.47
	binutils-csl-sourcerygxx-4_1-28:1.47
	gdb_6_6-branch:1.51.0.2
	gdb_6_6-2006-11-15-branchpoint:1.51
	binutils-csl-arm-2006q3-27:1.47
	binutils-csl-sourcerygxx-4_1-27:1.47
	binutils-csl-arm-2006q3-26:1.47
	binutils-csl-sourcerygxx-4_1-26:1.47
	binutils-csl-sourcerygxx-4_1-25:1.47
	binutils-csl-sourcerygxx-4_1-24:1.47
	binutils-csl-sourcerygxx-4_1-23:1.47
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.47
	binutils-csl-sourcerygxx-4_1-21:1.47
	binutils-csl-arm-2006q3-21:1.47
	binutils-csl-sourcerygxx-4_1-22:1.47
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.47
	binutils-csl-sourcerygxx-4_1-20:1.47
	binutils-csl-arm-2006q3-19:1.47
	binutils-csl-sourcerygxx-4_1-19:1.47
	binutils-csl-sourcerygxx-4_1-18:1.47
	binutils-csl-renesas-4_1-9:1.47
	gdb-csl-sourcerygxx-3_4_4-25:1.47
	binutils-csl-sourcerygxx-3_4_4-25:1.41
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.47
	binutils-csl-renesas-4_1-8:1.47
	binutils-csl-renesas-4_1-7:1.47
	binutils-csl-renesas-4_1-6:1.47
	gdb-csl-sourcerygxx-4_1-17:1.47
	binutils-csl-sourcerygxx-4_1-17:1.47
	gdb-csl-20060226-branch-local-2:1.47
	gdb-csl-sourcerygxx-4_1-14:1.47
	binutils-csl-sourcerygxx-4_1-14:1.47
	binutils-csl-sourcerygxx-4_1-15:1.47
	gdb-csl-sourcerygxx-4_1-13:1.47
	binutils-csl-sourcerygxx-4_1-13:1.47
	binutils-2_17:1.47
	gdb-csl-sourcerygxx-4_1-12:1.47
	binutils-csl-sourcerygxx-4_1-12:1.47
	gdb-csl-sourcerygxx-3_4_4-21:1.47
	binutils-csl-sourcerygxx-3_4_4-21:1.47
	gdb_6_5-20060621-release:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.41
	binutils-csl-wrs-linux-3_4_4-23:1.41
	gdb-csl-sourcerygxx-4_1-9:1.47
	binutils-csl-sourcerygxx-4_1-9:1.47
	gdb-csl-sourcerygxx-4_1-8:1.47
	binutils-csl-sourcerygxx-4_1-8:1.47
	gdb-csl-sourcerygxx-4_1-7:1.47
	binutils-csl-sourcerygxx-4_1-7:1.47
	gdb-csl-arm-2006q1-6:1.47
	binutils-csl-arm-2006q1-6:1.47
	gdb-csl-sourcerygxx-4_1-6:1.47
	binutils-csl-sourcerygxx-4_1-6:1.47
	binutils-csl-wrs-linux-3_4_4-22:1.41
	gdb-csl-symbian-6_4_50_20060226-10:1.47
	gdb-csl-symbian-6_4_50_20060226-9:1.47
	gdb-csl-symbian-6_4_50_20060226-8:1.47
	gdb-csl-coldfire-4_1-11:1.47
	binutils-csl-coldfire-4_1-11:1.47
	gdb-csl-sourcerygxx-3_4_4-19:1.47
	binutils-csl-sourcerygxx-3_4_4-19:1.47
	gdb-csl-coldfire-4_1-10:1.47
	gdb_6_5-branch:1.48.0.4
	gdb_6_5-2006-05-14-branchpoint:1.48
	binutils-csl-coldfire-4_1-10:1.47
	gdb-csl-sourcerygxx-4_1-5:1.47
	binutils-csl-sourcerygxx-4_1-5:1.47
	nickrob-async-20060513-branch:1.48.0.2
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.47
	binutils-csl-sourcerygxx-4_1-4:1.47
	msnyder-reverse-20060502-branch:1.47.0.24
	msnyder-reverse-20060502-branchpoint:1.47
	binutils-csl-wrs-linux-3_4_4-21:1.41
	gdb-csl-morpho-4_1-4:1.47
	binutils-csl-morpho-4_1-4:1.47
	gdb-csl-sourcerygxx-3_4_4-17:1.47
	binutils-csl-sourcerygxx-3_4_4-17:1.47
	binutils-csl-wrs-linux-3_4_4-20:1.41
	readline_5_1-import-branch:1.47.0.22
	readline_5_1-import-branchpoint:1.47
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.47
	binutils-2_17-branch:1.47.0.20
	binutils-2_17-branchpoint:1.47
	gdb-csl-symbian-20060226-branch:1.47.0.18
	gdb-csl-symbian-20060226-branchpoint:1.47
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.47
	msnyder-reverse-20060331-branch:1.47.0.16
	msnyder-reverse-20060331-branchpoint:1.47
	binutils-csl-2_17-branch:1.47.0.14
	binutils-csl-2_17-branchpoint:1.47
	gdb-csl-available-20060303-branch:1.47.0.12
	gdb-csl-available-20060303-branchpoint:1.47
	gdb-csl-20060226-branch:1.47.0.10
	gdb-csl-20060226-branchpoint:1.47
	gdb_6_4-20051202-release:1.47
	msnyder-fork-checkpoint-branch:1.47.0.8
	msnyder-fork-checkpoint-branchpoint:1.47
	gdb-csl-gxxpro-6_3-branch:1.47.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.47
	gdb_6_4-branch:1.47.0.4
	gdb_6_4-2005-11-01-branchpoint:1.47
	gdb-csl-arm-20051020-branch:1.47.0.2
	gdb-csl-arm-20051020-branchpoint:1.47
	binutils-csl-gxxpro-3_4-branch:1.41.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.41
	binutils-2_16_1:1.41
	msnyder-tracepoint-checkpoint-branch:1.45.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.45
	gdb-csl-arm-20050325-2005-q1b:1.41
	binutils-csl-arm-2005q1b:1.41
	binutils-2_16:1.41
	gdb-csl-arm-20050325-2005-q1a:1.41
	binutils-csl-arm-2005q1a:1.41
	csl-arm-20050325-branch:1.41.0.6
	csl-arm-20050325-branchpoint:1.41
	binutils-csl-arm-2005q1-branch:1.41.0.4
	binutils-csl-arm-2005q1-branchpoint:1.41
	binutils-2_16-branch:1.41.0.2
	binutils-2_16-branchpoint:1.41
	csl-arm-2004-q3d:1.40
	gdb_6_3-20041109-release:1.39
	gdb_6_3-branch:1.39.0.2
	gdb_6_3-20041019-branchpoint:1.39
	csl-arm-2004-q3:1.39
	drow_intercu-merge-20040921:1.39
	drow_intercu-merge-20040915:1.39
	jimb-gdb_6_2-e500-branch:1.38.0.6
	jimb-gdb_6_2-e500-branchpoint:1.38
	gdb_6_2-20040730-release:1.38
	gdb_6_2-branch:1.38.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.38
	gdb_6_1_1-20040616-release:1.29
	binutils-2_15:1.29.6.1
	binutils-2_15-branchpoint:1.29
	csl-arm-2004-q1a:1.34
	csl-arm-2004-q1:1.34
	gdb_6_1-2004-04-05-release:1.29
	drow_intercu-merge-20040402:1.34
	drow_intercu-merge-20040327:1.32
	ezannoni_pie-20040323-branch:1.31.0.2
	ezannoni_pie-20040323-branchpoint:1.31
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.29.0.12
	cagney_tramp-20040309-branchpoint:1.29
	gdb_6_1-branch:1.29.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.29
	drow_intercu-20040221-branch:1.29.0.8
	drow_intercu-20040221-branchpoint:1.29
	binutils-2_15-branch:1.29.0.6
	cagney_bfdfile-20040213-branch:1.29.0.4
	cagney_bfdfile-20040213-branchpoint:1.29
	drow-cplus-merge-20040208:1.29
	carlton_dictionary-20040126-merge:1.29
	cagney_bigcore-20040122-branch:1.29.0.2
	cagney_bigcore-20040122-branchpoint:1.29
	drow-cplus-merge-20040113:1.29
	csl-arm-2003-q4:1.29
	drow-cplus-merge-20031224:1.29
	drow-cplus-merge-20031220:1.29
	carlton_dictionary-20031215-merge:1.29
	drow-cplus-merge-20031214:1.29
	carlton-dictionary-20031111-merge:1.27
	gdb_6_0-2003-10-04-release:1.24
	kettenis_sparc-20030918-branch:1.25.0.6
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.4
	cagney_x86i386-20030821-branch:1.25.0.2
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.24.0.14
	gdb_6_0-2003-06-23-branchpoint:1.24
	jimb-ppc64-linux-20030613-branch:1.24.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.24
	binutils-2_14:1.23
	cagney_convert-20030606-branch:1.24.0.10
	cagney_convert-20030606-branchpoint:1.24
	cagney_writestrings-20030508-branch:1.24.0.8
	cagney_writestrings-20030508-branchpoint:1.24
	jimb-ppc64-linux-20030528-branch:1.24.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.24
	carlton_dictionary-20030523-merge:1.24
	cagney_fileio-20030521-branch:1.24.0.4
	cagney_fileio-20030521-branchpoint:1.24
	kettenis_i386newframe-20030517-mergepoint:1.24
	jimb-ppc64-linux-20030509-branch:1.24.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.24
	kettenis_i386newframe-20030504-mergepoint:1.23
	carlton_dictionary-20030430-merge:1.23
	binutils-2_14-branch:1.23.0.18
	binutils-2_14-branchpoint:1.23
	kettenis_i386newframe-20030419-branch:1.23.0.16
	kettenis_i386newframe-20030419-branchpoint:1.23
	carlton_dictionary-20030416-merge:1.23
	cagney_frameaddr-20030409-mergepoint:1.23
	kettenis_i386newframe-20030406-branch:1.23.0.14
	kettenis_i386newframe-20030406-branchpoint:1.23
	cagney_frameaddr-20030403-branchpoint:1.23
	cagney_frameaddr-20030403-branch:1.23.0.12
	cagney_framebase-20030330-mergepoint:1.23
	cagney_framebase-20030326-branch:1.23.0.10
	cagney_framebase-20030326-branchpoint:1.23
	cagney_lazyid-20030317-branch:1.23.0.8
	cagney_lazyid-20030317-branchpoint:1.23
	kettenis-i386newframe-20030316-mergepoint:1.23
	offbyone-20030313-branch:1.23.0.6
	offbyone-20030313-branchpoint:1.23
	kettenis-i386newframe-20030308-branch:1.23.0.4
	kettenis-i386newframe-20030308-branchpoint:1.23
	carlton_dictionary-20030305-merge:1.23
	cagney_offbyone-20030303-branch:1.23.0.2
	cagney_offbyone-20030303-branchpoint:1.23
	carlton_dictionary-20030207-merge:1.23
	interps-20030202-branch:1.22.0.2
	interps-20030202-branchpoint:1.22
	cagney-unwind-20030108-branch:1.21.0.2
	cagney-unwind-20030108-branchpoint:1.21
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	carlton_dictionary-20021223-merge:1.21
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.18
	binutils-2_13_1:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.14
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.12
	carlton_dictionary-20020920-branchpoint:1.17
	sid-20020905-branchpoint:1.17
	sid-20020905-branch:1.17.0.10
	gdb_5_3-branch:1.17.0.8
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.17.0.6
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.17.0.4
	readline_4_3-import-branchpoint:1.17
	binutils-2_13:1.17
	gdb_5_2_1-2002-07-23-release:1.10
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	kseitz_interps-20020528-branch:1.11.0.6
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.4
	cagney_regbuf-20020515-branchpoint:1.11
	binutils-2_12_1:1.10.2.1
	jimb-macro-020506-branch:1.11.0.2
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.10
	binutils-2_12:1.10
	gdb_5_2-branch:1.10.0.4
	gdb_5_2-2002-03-03-branchpoint:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	cygnus_cvs_20020108_pre:1.5
	binutils_latest_snapshot:1.69;
locks; strict;
comment	@ * @;


1.69
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2012.07.13.14.22.47;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.16.16.38.29;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.65;

1.65
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.25.01.14.20;	author hp;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2010.10.25.15.54.15;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.28.23.45.22;	author hp;	state Exp;
branches;
next	1.59;

1.59
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.21.14.15.49;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.55;

1.55
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.17.13.29.55;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.20.18.12.08;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.05.14.33.55;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.04.15.53.24;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.03.01.05.01;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.21.15.28.25;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.16.00.25.14;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.29.14.13.44;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.29.13.46.33;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.15.01.24.22;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.27.10.16.19;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.20.23.16.42;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches
	1.29.6.1
	1.29.8.1
	1.29.12.1;
next	1.28;

1.28
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.18.15.42.40;	author hp;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.09.02.27.05;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches
	1.23.16.1;
next	1.22;

1.22
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.08.03.34.38;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.14.01.32.28;	author hp;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.17.12.1
	1.17.14.1;
next	1.16;

1.16
date	2002.07.01.08.06.45;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.16.20.48.46;	author hp;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.16.04.58.12;	author amodra;	state Exp;
branches
	1.11.4.1
	1.11.6.1;
next	1.10;

1.10
date	2002.02.09.05.04.27;	author hp;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.02.04.04.45.08;	author hp;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.01.08.18.56;	author hp;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.31.03.07.48;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2001.10.30.15.20.02;	author nickc;	state Exp;
branches;
next	;

1.64.2.1
date	2012.05.11.12.24.29;	author nickc;	state Exp;
branches;
next	;

1.29.6.1
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.29.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.29.8.2;

1.29.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.29.8.3;

1.29.8.3
date	2004.09.16.17.00.29;	author drow;	state Exp;
branches;
next	;

1.29.12.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.23.16.1
date	2003.05.18.09.43.45;	author kettenis;	state Exp;
branches;
next	;

1.17.12.1
date	2002.11.15.19.18.27;	author carlton;	state Exp;
branches;
next	1.17.12.2;

1.17.12.2
date	2002.12.23.19.37.48;	author carlton;	state Exp;
branches;
next	1.17.12.3;

1.17.12.3
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.17.12.4;

1.17.12.4
date	2003.05.23.18.40.26;	author carlton;	state Exp;
branches;
next	1.17.12.5;

1.17.12.5
date	2003.06.27.21.49.20;	author carlton;	state Exp;
branches;
next	1.17.12.6;

1.17.12.6
date	2003.11.11.23.50.22;	author carlton;	state Exp;
branches;
next	1.17.12.7;

1.17.12.7
date	2003.12.15.23.59.35;	author carlton;	state Exp;
branches;
next	;

1.17.14.1
date	2003.12.14.20.26.43;	author drow;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.06.21.15.56.24;	author cagney;	state Exp;
branches;
next	;

1.11.6.1
date	2002.06.20.01.30.35;	author kseitz;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	;

1.10.2.1
date	2002.04.27.08.30.12;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.69
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* MMIX-specific support for 64-bit ELF.
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2011,
   2012
   Free Software Foundation, Inc.
   Contributed by Hans-Peter Nilsson <hp@@bitrange.com>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* No specific ABI or "processor-specific supplement" defined.  */

/* TODO:
   - "Traditional" linker relaxation (shrinking whole sections).
   - Merge reloc stubs jumping to same location.
   - GETA stub relaxation (call a stub for out of range new
     R_MMIX_GETA_STUBBABLE).  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/mmix.h"
#include "opcode/mmix.h"

#define MINUS_ONE	(((bfd_vma) 0) - 1)

#define MAX_PUSHJ_STUB_SIZE (5 * 4)

/* Put these everywhere in new code.  */
#define FATAL_DEBUG						\
 _bfd_abort (__FILE__, __LINE__,				\
	     "Internal: Non-debugged code (test-case missing)")

#define BAD_CASE(x)				\
 _bfd_abort (__FILE__, __LINE__,		\
	     "bad case for " #x)

struct _mmix_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct bpo_reloc_section_info *reloc;
    struct bpo_greg_section_info *greg;
  } bpo;

  struct pushj_stub_info
  {
    /* Maximum number of stubs needed for this section.  */
    bfd_size_type n_pushj_relocs;

    /* Size of stubs after a mmix_elf_relax_section round.  */
    bfd_size_type stubs_size_sum;

    /* Per-reloc stubs_size_sum information.  The stubs_size_sum member is the sum
       of these.  Allocated in mmix_elf_check_common_relocs.  */
    bfd_size_type *stub_size;

    /* Offset of next stub during relocation.  Somewhat redundant with the
       above: error coverage is easier and we don't have to reset the
       stubs_size_sum for relocation.  */
    bfd_size_type stub_offset;
  } pjs;

  /* Whether there has been a warning that this section could not be
     linked due to a specific cause.  FIXME: a way to access the
     linker info or output section, then stuff the limiter guard
     there. */
  bfd_boolean has_warned_bpo;
  bfd_boolean has_warned_pushj;
};

#define mmix_elf_section_data(sec) \
  ((struct _mmix_elf_section_data *) elf_section_data (sec))

/* For each section containing a base-plus-offset (BPO) reloc, we attach
   this struct as mmix_elf_section_data (section)->bpo, which is otherwise
   NULL.  */
struct bpo_reloc_section_info
  {
    /* The base is 1; this is the first number in this section.  */
    size_t first_base_plus_offset_reloc;

    /* Number of BPO-relocs in this section.  */
    size_t n_bpo_relocs_this_section;

    /* Running index, used at relocation time.  */
    size_t bpo_index;

    /* We don't have access to the bfd_link_info struct in
       mmix_final_link_relocate.  What we really want to get at is the
       global single struct greg_relocation, so we stash it here.  */
    asection *bpo_greg_section;
  };

/* Helper struct (in global context) for the one below.
   There's one of these created for every BPO reloc.  */
struct bpo_reloc_request
  {
    bfd_vma value;

    /* Valid after relaxation.  The base is 0; the first register number
       must be added.  The offset is in range 0..255.  */
    size_t regindex;
    size_t offset;

    /* The order number for this BPO reloc, corresponding to the order in
       which BPO relocs were found.  Used to create an index after reloc
       requests are sorted.  */
    size_t bpo_reloc_no;

    /* Set when the value is computed.  Better than coding "guard values"
       into the other members.  Is FALSE only for BPO relocs in a GC:ed
       section.  */
    bfd_boolean valid;
  };

/* We attach this as mmix_elf_section_data (sec)->bpo in the linker-allocated
   greg contents section (MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME),
   which is linked into the register contents section
   (MMIX_REG_CONTENTS_SECTION_NAME).  This section is created by the
   linker; using the same hook as for usual with BPO relocs does not
   collide.  */
struct bpo_greg_section_info
  {
    /* After GC, this reflects the number of remaining, non-excluded
       BPO-relocs.  */
    size_t n_bpo_relocs;

    /* This is the number of allocated bpo_reloc_requests; the size of
       sorted_indexes.  Valid after the check.*relocs functions are called
       for all incoming sections.  It includes the number of BPO relocs in
       sections that were GC:ed.  */
    size_t n_max_bpo_relocs;

    /* A counter used to find out when to fold the BPO gregs, since we
       don't have a single "after-relaxation" hook.  */
    size_t n_remaining_bpo_relocs_this_relaxation_round;

    /* The number of linker-allocated GREGs resulting from BPO relocs.
       This is an approximation after _bfd_mmix_before_linker_allocation
       and supposedly accurate after mmix_elf_relax_section is called for
       all incoming non-collected sections.  */
    size_t n_allocated_bpo_gregs;

    /* Index into reloc_request[], sorted on increasing "value", secondary
       by increasing index for strict sorting order.  */
    size_t *bpo_reloc_indexes;

    /* An array of all relocations, with the "value" member filled in by
       the relaxation function.  */
    struct bpo_reloc_request *reloc_request;
  };


extern bfd_boolean mmix_elf_final_link (bfd *, struct bfd_link_info *);

extern void mmix_elf_symbol_processing (bfd *, asymbol *);

/* Only intended to be called from a debugger.  */
extern void mmix_dump_bpo_gregs
  (struct bfd_link_info *, bfd_error_handler_type);

static void
mmix_set_relaxable_size (bfd *, asection *, void *);
static bfd_reloc_status_type
mmix_elf_reloc (bfd *, arelent *, asymbol *, void *,
		asection *, bfd *, char **);
static bfd_reloc_status_type
mmix_final_link_relocate (reloc_howto_type *, asection *, bfd_byte *, bfd_vma,
			  bfd_signed_vma, bfd_vma, const char *, asection *,
			  char **);


/* Watch out: this currently needs to have elements with the same index as
   their R_MMIX_ number.  */
static reloc_howto_type elf_mmix_howto_table[] =
 {
  /* This reloc does nothing.  */
  HOWTO (R_MMIX_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit absolute relocation.  */
  HOWTO (R_MMIX_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 16 bit absolute relocation.  */
  HOWTO (R_MMIX_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 24 bit absolute relocation.  */
  HOWTO (R_MMIX_24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_24",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  */
  HOWTO (R_MMIX_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MMIX_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_64",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An 8 bit PC-relative relocation.  */
  HOWTO (R_MMIX_PC_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_PC_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An 16 bit PC-relative relocation.  */
  HOWTO (R_MMIX_PC_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_PC_16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* An 24 bit PC-relative relocation.  */
  HOWTO (R_MMIX_PC_24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_PC_24",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit absolute PC-relative relocation.  */
  HOWTO (R_MMIX_PC_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_PC_32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 64 bit PC-relative relocation.  */
  HOWTO (R_MMIX_PC_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MMIX_PC_64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_MMIX_GNU_VTINHERIT, /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MMIX_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_MMIX_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_MMIX_GNU_VTENTRY", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The GETA relocation is supposed to get any address that could
     possibly be reached by the GETA instruction.  It can silently expand
     to get a 64-bit operand, but will complain if any of the two least
     significant bits are set.  The howto members reflect a simple GETA.  */
  HOWTO (R_MMIX_GETA,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_GETA",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_GETA_1,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_GETA_1",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_GETA_2,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_GETA_2",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_GETA_3,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_GETA_3",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The conditional branches are supposed to reach any (code) address.
     It can silently expand to a 64-bit operand, but will emit an error if
     any of the two least significant bits are set.  The howto members
     reflect a simple branch.  */
  HOWTO (R_MMIX_CBRANCH,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_CBRANCH",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  HOWTO (R_MMIX_CBRANCH_J,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_CBRANCH_J",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_CBRANCH_1,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_CBRANCH_1",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_CBRANCH_2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_CBRANCH_2",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_CBRANCH_3,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_CBRANCH_3",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The PUSHJ instruction can reach any (code) address, as long as it's
     the beginning of a function (no usable restriction).  It can silently
     expand to a 64-bit operand, but will emit an error if any of the two
     least significant bits are set.  It can also expand into a call to a
     stub; see R_MMIX_PUSHJ_STUBBABLE.  The howto members reflect a simple
     PUSHJ.  */
  HOWTO (R_MMIX_PUSHJ,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_PUSHJ_1,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_1",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_PUSHJ_2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_2",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_PUSHJ_3,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_3",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A JMP is supposed to reach any (code) address.  By itself, it can
     reach +-64M; the expansion can reach all 64 bits.  Note that the 64M
     limit is soon reached if you link the program in wildly different
     memory segments.  The howto members reflect a trivial JMP.  */
  HOWTO (R_MMIX_JMP,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 27,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_JMP",		/* name */
	 FALSE,			/* partial_inplace */
	 ~0x1ffffff,		/* src_mask */
	 0x1ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_JMP_1,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 27,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_JMP_1",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x1ffffff,		/* src_mask */
	 0x1ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_JMP_2,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 27,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_JMP_2",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x1ffffff,		/* src_mask */
	 0x1ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MMIX_JMP_3,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 27,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_JMP_3",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x1ffffff,		/* src_mask */
	 0x1ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* When we don't emit link-time-relaxable code from the assembler, or
     when relaxation has done all it can do, these relocs are used.  For
     GETA/PUSHJ/branches.  */
  HOWTO (R_MMIX_ADDR19,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_ADDR19",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* For JMP.  */
  HOWTO (R_MMIX_ADDR27,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 27,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_ADDR27",	/* name */
	 FALSE,			/* partial_inplace */
	 ~0x1ffffff,		/* src_mask */
	 0x1ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A general register or the value 0..255.  If a value, then the
     instruction (offset -3) needs adjusting.  */
  HOWTO (R_MMIX_REG_OR_BYTE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_REG_OR_BYTE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A general register.  */
  HOWTO (R_MMIX_REG,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_REG",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A register plus an index, corresponding to the relocation expression.
     The sizes must correspond to the valid range of the expression, while
     the bitmasks correspond to what we store in the image.  */
  HOWTO (R_MMIX_BASE_PLUS_OFFSET,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_BASE_PLUS_OFFSET", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A "magic" relocation for a LOCAL expression, asserting that the
     expression is less than the number of global registers.  No actual
     modification of the contents is done.  Implementing this as a
     relocation was less intrusive than e.g. putting such expressions in a
     section to discard *after* relocation.  */
  HOWTO (R_MMIX_LOCAL,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_LOCAL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MMIX_PUSHJ_STUBBABLE, /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_STUBBABLE", /* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */
 };


/* Map BFD reloc types to MMIX ELF reloc types.  */

struct mmix_reloc_map
  {
    bfd_reloc_code_real_type bfd_reloc_val;
    enum elf_mmix_reloc_type elf_reloc_val;
  };


static const struct mmix_reloc_map mmix_reloc_map[] =
  {
    {BFD_RELOC_NONE, R_MMIX_NONE},
    {BFD_RELOC_8, R_MMIX_8},
    {BFD_RELOC_16, R_MMIX_16},
    {BFD_RELOC_24, R_MMIX_24},
    {BFD_RELOC_32, R_MMIX_32},
    {BFD_RELOC_64, R_MMIX_64},
    {BFD_RELOC_8_PCREL, R_MMIX_PC_8},
    {BFD_RELOC_16_PCREL, R_MMIX_PC_16},
    {BFD_RELOC_24_PCREL, R_MMIX_PC_24},
    {BFD_RELOC_32_PCREL, R_MMIX_PC_32},
    {BFD_RELOC_64_PCREL, R_MMIX_PC_64},
    {BFD_RELOC_VTABLE_INHERIT, R_MMIX_GNU_VTINHERIT},
    {BFD_RELOC_VTABLE_ENTRY, R_MMIX_GNU_VTENTRY},
    {BFD_RELOC_MMIX_GETA, R_MMIX_GETA},
    {BFD_RELOC_MMIX_CBRANCH, R_MMIX_CBRANCH},
    {BFD_RELOC_MMIX_PUSHJ, R_MMIX_PUSHJ},
    {BFD_RELOC_MMIX_JMP, R_MMIX_JMP},
    {BFD_RELOC_MMIX_ADDR19, R_MMIX_ADDR19},
    {BFD_RELOC_MMIX_ADDR27, R_MMIX_ADDR27},
    {BFD_RELOC_MMIX_REG_OR_BYTE, R_MMIX_REG_OR_BYTE},
    {BFD_RELOC_MMIX_REG, R_MMIX_REG},
    {BFD_RELOC_MMIX_BASE_PLUS_OFFSET, R_MMIX_BASE_PLUS_OFFSET},
    {BFD_RELOC_MMIX_LOCAL, R_MMIX_LOCAL},
    {BFD_RELOC_MMIX_PUSHJ_STUBBABLE, R_MMIX_PUSHJ_STUBBABLE}
  };

static reloc_howto_type *
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (mmix_reloc_map) / sizeof (mmix_reloc_map[0]);
       i++)
    {
      if (mmix_reloc_map[i].bfd_reloc_val == code)
	return &elf_mmix_howto_table[mmix_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

static reloc_howto_type *
bfd_elf64_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf_mmix_howto_table) / sizeof (elf_mmix_howto_table[0]);
       i++)
    if (elf_mmix_howto_table[i].name != NULL
	&& strcasecmp (elf_mmix_howto_table[i].name, r_name) == 0)
      return &elf_mmix_howto_table[i];

  return NULL;
}

static bfd_boolean
mmix_elf_new_section_hook (bfd *abfd, asection *sec)
{
  if (!sec->used_by_bfd)
    {
      struct _mmix_elf_section_data *sdata;
      bfd_size_type amt = sizeof (*sdata);

      sdata = bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  return _bfd_elf_new_section_hook (abfd, sec);
}


/* This function performs the actual bitfiddling and sanity check for a
   final relocation.  Each relocation gets its *worst*-case expansion
   in size when it arrives here; any reduction in size should have been
   caught in linker relaxation earlier.  When we get here, the relocation
   looks like the smallest instruction with SWYM:s (nop:s) appended to the
   max size.  We fill in those nop:s.

   R_MMIX_GETA: (FIXME: Relaxation should break this up in 1, 2, 3 tetra)
    GETA $N,foo
   ->
    SETL $N,foo & 0xffff
    INCML $N,(foo >> 16) & 0xffff
    INCMH $N,(foo >> 32) & 0xffff
    INCH $N,(foo >> 48) & 0xffff

   R_MMIX_CBRANCH: (FIXME: Relaxation should break this up, but
   condbranches needing relaxation might be rare enough to not be
   worthwhile.)
    [P]Bcc $N,foo
   ->
    [~P]B~cc $N,.+20
    SETL $255,foo & ...
    INCML ...
    INCMH ...
    INCH ...
    GO $255,$255,0

   R_MMIX_PUSHJ: (FIXME: Relaxation...)
    PUSHJ $N,foo
   ->
    SETL $255,foo & ...
    INCML ...
    INCMH ...
    INCH ...
    PUSHGO $N,$255,0

   R_MMIX_JMP: (FIXME: Relaxation...)
    JMP foo
   ->
    SETL $255,foo & ...
    INCML ...
    INCMH ...
    INCH ...
    GO $255,$255,0

   R_MMIX_ADDR19 and R_MMIX_ADDR27 are just filled in.  */

static bfd_reloc_status_type
mmix_elf_perform_relocation (asection *isec, reloc_howto_type *howto,
			     void *datap, bfd_vma addr, bfd_vma value,
			     char **error_message)
{
  bfd *abfd = isec->owner;
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_reloc_status_type r;
  int offs = 0;
  int reg = 255;

  /* The worst case bits are all similar SETL/INCML/INCMH/INCH sequences.
     We handle the differences here and the common sequence later.  */
  switch (howto->type)
    {
    case R_MMIX_GETA:
      offs = 0;
      reg = bfd_get_8 (abfd, (bfd_byte *) datap + 1);

      /* We change to an absolute value.  */
      value += addr;
      break;

    case R_MMIX_CBRANCH:
      {
	int in1 = bfd_get_16 (abfd, (bfd_byte *) datap) << 16;

	/* Invert the condition and prediction bit, and set the offset
	   to five instructions ahead.

	   We *can* do better if we want to.  If the branch is found to be
	   within limits, we could leave the branch as is; there'll just
	   be a bunch of NOP:s after it.  But we shouldn't see this
	   sequence often enough that it's worth doing it.  */

	bfd_put_32 (abfd,
		    (((in1 ^ ((PRED_INV_BIT | COND_INV_BIT) << 24)) & ~0xffff)
		     | (24/4)),
		    (bfd_byte *) datap);

	/* Put a "GO $255,$255,0" after the common sequence.  */
	bfd_put_32 (abfd,
		    ((GO_INSN_BYTE | IMM_OFFSET_BIT) << 24) | 0xffff00,
		    (bfd_byte *) datap + 20);

	/* Common sequence starts at offset 4.  */
	offs = 4;

	/* We change to an absolute value.  */
	value += addr;
      }
      break;

    case R_MMIX_PUSHJ_STUBBABLE:
      /* If the address fits, we're fine.  */
      if ((value & 3) == 0
	  /* Note rightshift 0; see R_MMIX_JMP case below.  */
	  && (r = bfd_check_overflow (complain_overflow_signed,
				      howto->bitsize,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      value)) == bfd_reloc_ok)
	goto pcrel_mmix_reloc_fits;
      else
	{
	  bfd_size_type size = isec->rawsize ? isec->rawsize : isec->size;

	  /* We have the bytes at the PUSHJ insn and need to get the
	     position for the stub.  There's supposed to be room allocated
	     for the stub.  */
	  bfd_byte *stubcontents
	    = ((bfd_byte *) datap
	       - (addr - (isec->output_section->vma + isec->output_offset))
	       + size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);
	  bfd_vma stubaddr;

	  if (mmix_elf_section_data (isec)->pjs.n_pushj_relocs == 0)
	    {
	      /* This shouldn't happen when linking to ELF or mmo, so
		 this is an attempt to link to "binary", right?  We
		 can't access the output bfd, so we can't verify that
		 assumption.  We only know that the critical
		 mmix_elf_check_common_relocs has not been called,
		 which happens when the output format is different
		 from the input format (and is not mmo).  */
	      if (! mmix_elf_section_data (isec)->has_warned_pushj)
		{
		  /* For the first such error per input section, produce
		     a verbose message.  */
		  *error_message
		    = _("invalid input relocation when producing"
			" non-ELF, non-mmo format output."
			"\n Please use the objcopy program to convert from"
			" ELF or mmo,"
			"\n or assemble using"
			" \"-no-expand\" (for gcc, \"-Wa,-no-expand\"");
		  mmix_elf_section_data (isec)->has_warned_pushj = TRUE;
		  return bfd_reloc_dangerous;
		}

	      /* For subsequent errors, return this one, which is
		 rate-limited but looks a little bit different,
		 hopefully without affecting user-friendliness.  */
	      return bfd_reloc_overflow;
	    }

	  /* The address doesn't fit, so redirect the PUSHJ to the
	     location of the stub.  */
	  r = mmix_elf_perform_relocation (isec,
					   &elf_mmix_howto_table
					   [R_MMIX_ADDR19],
					   datap,
					   addr,
					   isec->output_section->vma
					   + isec->output_offset
					   + size
					   + (mmix_elf_section_data (isec)
					      ->pjs.stub_offset)
					   - addr,
					   error_message);
	  if (r != bfd_reloc_ok)
	    return r;

	  stubaddr
	    = (isec->output_section->vma
	       + isec->output_offset
	       + size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);

	  /* We generate a simple JMP if that suffices, else the whole 5
	     insn stub.  */
	  if (bfd_check_overflow (complain_overflow_signed,
				  elf_mmix_howto_table[R_MMIX_ADDR27].bitsize,
				  0,
				  bfd_arch_bits_per_address (abfd),
				  addr + value - stubaddr) == bfd_reloc_ok)
	    {
	      bfd_put_32 (abfd, JMP_INSN_BYTE << 24, stubcontents);
	      r = mmix_elf_perform_relocation (isec,
					       &elf_mmix_howto_table
					       [R_MMIX_ADDR27],
					       stubcontents,
					       stubaddr,
					       value + addr - stubaddr,
					       error_message);
	      mmix_elf_section_data (isec)->pjs.stub_offset += 4;

	      if (size + mmix_elf_section_data (isec)->pjs.stub_offset
		  > isec->size)
		abort ();

	      return r;
	    }
	  else
	    {
	      /* Put a "GO $255,0" after the common sequence.  */
	      bfd_put_32 (abfd,
			  ((GO_INSN_BYTE | IMM_OFFSET_BIT) << 24)
			  | 0xff00, (bfd_byte *) stubcontents + 16);

	      /* Prepare for the general code to set the first part of the
		 linker stub, and */
	      value += addr;
	      datap = stubcontents;
	      mmix_elf_section_data (isec)->pjs.stub_offset
		+= MAX_PUSHJ_STUB_SIZE;
	    }
	}
      break;

    case R_MMIX_PUSHJ:
      {
	int inreg = bfd_get_8 (abfd, (bfd_byte *) datap + 1);

	/* Put a "PUSHGO $N,$255,0" after the common sequence.  */
	bfd_put_32 (abfd,
		    ((PUSHGO_INSN_BYTE | IMM_OFFSET_BIT) << 24)
		    | (inreg << 16)
		    | 0xff00,
		    (bfd_byte *) datap + 16);

	/* We change to an absolute value.  */
	value += addr;
      }
      break;

    case R_MMIX_JMP:
      /* This one is a little special.  If we get here on a non-relaxing
	 link, and the destination is actually in range, we don't need to
	 execute the nops.
	 If so, we fall through to the bit-fiddling relocs.

	 FIXME: bfd_check_overflow seems broken; the relocation is
	 rightshifted before testing, so supply a zero rightshift.  */

      if (! ((value & 3) == 0
	     && (r = bfd_check_overflow (complain_overflow_signed,
					 howto->bitsize,
					 0,
					 bfd_arch_bits_per_address (abfd),
					 value)) == bfd_reloc_ok))
	{
	  /* If the relocation doesn't fit in a JMP, we let the NOP:s be
	     modified below, and put a "GO $255,$255,0" after the
	     address-loading sequence.  */
	  bfd_put_32 (abfd,
		      ((GO_INSN_BYTE | IMM_OFFSET_BIT) << 24)
		      | 0xffff00,
		      (bfd_byte *) datap + 16);

	  /* We change to an absolute value.  */
	  value += addr;
	  break;
	}
      /* FALLTHROUGH.  */
    case R_MMIX_ADDR19:
    case R_MMIX_ADDR27:
    pcrel_mmix_reloc_fits:
      /* These must be in range, or else we emit an error.  */
      if ((value & 3) == 0
	  /* Note rightshift 0; see above.  */
	  && (r = bfd_check_overflow (complain_overflow_signed,
				      howto->bitsize,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      value)) == bfd_reloc_ok)
	{
	  bfd_vma in1
	    = bfd_get_32 (abfd, (bfd_byte *) datap);
	  bfd_vma highbit;

	  if ((bfd_signed_vma) value < 0)
	    {
	      highbit = 1 << 24;
	      value += (1 << (howto->bitsize - 1));
	    }
	  else
	    highbit = 0;

	  value >>= 2;

	  bfd_put_32 (abfd,
		      (in1 & howto->src_mask)
		      | highbit
		      | (value & howto->dst_mask),
		      (bfd_byte *) datap);

	  return bfd_reloc_ok;
	}
      else
	return bfd_reloc_overflow;

    case R_MMIX_BASE_PLUS_OFFSET:
      {
	struct bpo_reloc_section_info *bpodata
	  = mmix_elf_section_data (isec)->bpo.reloc;
	asection *bpo_greg_section;
	struct bpo_greg_section_info *gregdata;
	size_t bpo_index;

	if (bpodata == NULL)
	  {
	    /* This shouldn't happen when linking to ELF or mmo, so
	       this is an attempt to link to "binary", right?  We
	       can't access the output bfd, so we can't verify that
	       assumption.  We only know that the critical
	       mmix_elf_check_common_relocs has not been called, which
	       happens when the output format is different from the
	       input format (and is not mmo).  */
	    if (! mmix_elf_section_data (isec)->has_warned_bpo)
	      {
		/* For the first such error per input section, produce
		   a verbose message.  */
		*error_message
		  = _("invalid input relocation when producing"
		      " non-ELF, non-mmo format output."
		      "\n Please use the objcopy program to convert from"
		      " ELF or mmo,"
		      "\n or compile using the gcc-option"
		      " \"-mno-base-addresses\".");
		mmix_elf_section_data (isec)->has_warned_bpo = TRUE;
		return bfd_reloc_dangerous;
	      }

	    /* For subsequent errors, return this one, which is
	       rate-limited but looks a little bit different,
	       hopefully without affecting user-friendliness.  */
	    return bfd_reloc_overflow;
	  }

	bpo_greg_section = bpodata->bpo_greg_section;
	gregdata = mmix_elf_section_data (bpo_greg_section)->bpo.greg;
	bpo_index = gregdata->bpo_reloc_indexes[bpodata->bpo_index++];

	/* A consistency check: The value we now have in "relocation" must
	   be the same as the value we stored for that relocation.  It
	   doesn't cost much, so can be left in at all times.  */
	if (value != gregdata->reloc_request[bpo_index].value)
	  {
	    (*_bfd_error_handler)
	      (_("%s: Internal inconsistency error for value for\n\
 linker-allocated global register: linked: 0x%lx%08lx != relaxed: 0x%lx%08lx\n"),
	       bfd_get_filename (isec->owner),
	       (unsigned long) (value >> 32), (unsigned long) value,
	       (unsigned long) (gregdata->reloc_request[bpo_index].value
				>> 32),
	       (unsigned long) gregdata->reloc_request[bpo_index].value);
	    bfd_set_error (bfd_error_bad_value);
	    return bfd_reloc_overflow;
	  }

	/* Then store the register number and offset for that register
	   into datap and datap + 1 respectively.  */
	bfd_put_8 (abfd,
		   gregdata->reloc_request[bpo_index].regindex
		   + bpo_greg_section->output_section->vma / 8,
		   datap);
	bfd_put_8 (abfd,
		   gregdata->reloc_request[bpo_index].offset,
		   ((unsigned char *) datap) + 1);
	return bfd_reloc_ok;
      }

    case R_MMIX_REG_OR_BYTE:
    case R_MMIX_REG:
      if (value > 255)
	return bfd_reloc_overflow;
      bfd_put_8 (abfd, value, datap);
      return bfd_reloc_ok;

    default:
      BAD_CASE (howto->type);
    }

  /* This code adds the common SETL/INCML/INCMH/INCH worst-case
     sequence.  */

  /* Lowest two bits must be 0.  We return bfd_reloc_overflow for
     everything that looks strange.  */
  if (value & 3)
    flag = bfd_reloc_overflow;

  bfd_put_32 (abfd,
	      (SETL_INSN_BYTE << 24) | (value & 0xffff) | (reg << 16),
	      (bfd_byte *) datap + offs);
  bfd_put_32 (abfd,
	      (INCML_INSN_BYTE << 24) | ((value >> 16) & 0xffff) | (reg << 16),
	      (bfd_byte *) datap + offs + 4);
  bfd_put_32 (abfd,
	      (INCMH_INSN_BYTE << 24) | ((value >> 32) & 0xffff) | (reg << 16),
	      (bfd_byte *) datap + offs + 8);
  bfd_put_32 (abfd,
	      (INCH_INSN_BYTE << 24) | ((value >> 48) & 0xffff) | (reg << 16),
	      (bfd_byte *) datap + offs + 12);

  return flag;
}

/* Set the howto pointer for an MMIX ELF reloc (type RELA).  */

static void
mmix_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			 arelent *cache_ptr,
			 Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF64_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_MMIX_max);
  cache_ptr->howto = &elf_mmix_howto_table[r_type];
}

/* Any MMIX-specific relocation gets here at assembly time or when linking
   to other formats (such as mmo); this is the relocation function from
   the reloc_table.  We don't get here for final pure ELF linking.  */

static bfd_reloc_status_type
mmix_elf_reloc (bfd *abfd,
		arelent *reloc_entry,
		asymbol *symbol,
		void * data,
		asection *input_section,
		bfd *output_bfd,
		char **error_message)
{
  bfd_vma relocation;
  bfd_reloc_status_type r;
  asection *reloc_target_output_section;
  bfd_reloc_status_type flag = bfd_reloc_ok;
  bfd_vma output_base = 0;

  r = bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
			     input_section, output_bfd, error_message);

  /* If that was all that was needed (i.e. this isn't a final link, only
     some segment adjustments), we're done.  */
  if (r != bfd_reloc_continue)
    return r;

  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && output_bfd == (bfd *) NULL)
    return bfd_reloc_undefined;

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  reloc_target_output_section = bfd_get_output_section (symbol);

  /* Here the variable relocation holds the final address of the symbol we
     are relocating against, plus any addend.  */
  if (output_bfd)
    output_base = 0;
  else
    output_base = reloc_target_output_section->vma;

  relocation += output_base + symbol->section->output_offset;

  if (output_bfd != (bfd *) NULL)
    {
      /* Add in supplied addend.  */
      relocation += reloc_entry->addend;

      /* This is a partial relocation, and we want to apply the
	 relocation to the reloc entry rather than the raw data.
	 Modify the reloc inplace to reflect what we now know.  */
      reloc_entry->addend = relocation;
      reloc_entry->address += input_section->output_offset;
      return flag;
    }

  return mmix_final_link_relocate (reloc_entry->howto, input_section,
				   data, reloc_entry->address,
				   reloc_entry->addend, relocation,
				   bfd_asymbol_name (symbol),
				   reloc_target_output_section,
				   error_message);
}

/* Relocate an MMIX ELF section.  Modified from elf32-fr30.c; look to it
   for guidance if you're thinking of copying this.  */

static bfd_boolean
mmix_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  bfd_size_type size;
  size_t pjsno = 0;

  size = input_section->rawsize ? input_section->rawsize : input_section->size;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend = relocs + input_section->reloc_count;

  /* Zero the stub area before we start.  */
  if (input_section->rawsize != 0
      && input_section->size > input_section->rawsize)
    memset (contents + input_section->rawsize, 0,
	    input_section->size - input_section->rawsize);

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char *name = NULL;
      int r_type;
      bfd_boolean undefined_signalled = FALSE;

      r_type = ELF64_R_TYPE (rel->r_info);

      if (r_type == R_MMIX_GNU_VTINHERIT
	  || r_type == R_MMIX_GNU_VTENTRY)
	continue;

      r_symndx = ELF64_R_SYM (rel->r_info);

      howto = elf_mmix_howto_table + ELF64_R_TYPE (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section (input_bfd,
						  symtab_hdr->sh_link,
						  sym->st_name);
	  if (name == NULL)
	    name = bfd_section_name (input_bfd, sec);
	}
      else
	{
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, undefined_signalled);
	  name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	{
	  /* This is a relocatable link.  For most relocs we don't have to
	     change anything, unless the reloc is against a section
	     symbol, in which case we have to adjust according to where
	     the section symbol winds up in the output section.  */
	  if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    rel->r_addend += sec->output_offset;

	  /* For PUSHJ stub relocs however, we may need to change the
	     reloc and the section contents, if the reloc doesn't reach
	     beyond the end of the output section and previous stubs.
	     Then we change the section contents to be a PUSHJ to the end
	     of the input section plus stubs (we can do that without using
	     a reloc), and then we change the reloc to be a R_MMIX_PUSHJ
	     at the stub location.  */
	  if (r_type == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* We've already checked whether we need a stub; use that
		 knowledge.  */
	      if (mmix_elf_section_data (input_section)->pjs.stub_size[pjsno]
		  != 0)
		{
		  Elf_Internal_Rela relcpy;

		  if (mmix_elf_section_data (input_section)
		      ->pjs.stub_size[pjsno] != MAX_PUSHJ_STUB_SIZE)
		    abort ();

		  /* There's already a PUSHJ insn there, so just fill in
		     the offset bits to the stub.  */
		  if (mmix_final_link_relocate (elf_mmix_howto_table
						+ R_MMIX_ADDR19,
						input_section,
						contents,
						rel->r_offset,
						0,
						input_section
						->output_section->vma
						+ input_section->output_offset
						+ size
						+ mmix_elf_section_data (input_section)
						->pjs.stub_offset,
						NULL, NULL, NULL) != bfd_reloc_ok)
		    return FALSE;

		  /* Put a JMP insn at the stub; it goes with the
		     R_MMIX_JMP reloc.  */
		  bfd_put_32 (output_bfd, JMP_INSN_BYTE << 24,
			      contents
			      + size
			      + mmix_elf_section_data (input_section)
			      ->pjs.stub_offset);

		  /* Change the reloc to be at the stub, and to a full
		     R_MMIX_JMP reloc.  */
		  rel->r_info = ELF64_R_INFO (r_symndx, R_MMIX_JMP);
		  rel->r_offset
		    = (size
		       + mmix_elf_section_data (input_section)
		       ->pjs.stub_offset);

		  mmix_elf_section_data (input_section)->pjs.stub_offset
		    += MAX_PUSHJ_STUB_SIZE;

		  /* Shift this reloc to the end of the relocs to maintain
		     the r_offset sorted reloc order.  */
		  relcpy = *rel;
		  memmove (rel, rel + 1, (char *) relend - (char *) rel);
		  relend[-1] = relcpy;

		  /* Back up one reloc, or else we'd skip the next reloc
		   in turn.  */
		  rel--;
		}

	      pjsno++;
	    }
	  continue;
	}

      r = mmix_final_link_relocate (howto, input_section,
				    contents, rel->r_offset,
				    rel->r_addend, relocation, name, sec, NULL);

      if (r != bfd_reloc_ok)
	{
	  bfd_boolean check_ok = TRUE;
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      check_ok = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      /* We may have sent this message above.  */
	      if (! undefined_signalled)
		check_ok = info->callbacks->undefined_symbol
		  (info, name, input_bfd, input_section, rel->r_offset,
		   TRUE);
	      undefined_signalled = TRUE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    check_ok = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! check_ok)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines.  A few relocs we have to do ourselves.  */

static bfd_reloc_status_type
mmix_final_link_relocate (reloc_howto_type *howto, asection *input_section,
			  bfd_byte *contents, bfd_vma r_offset,
			  bfd_signed_vma r_addend, bfd_vma relocation,
			  const char *symname, asection *symsec,
			  char **error_message)
{
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma addr
    = (input_section->output_section->vma
       + input_section->output_offset
       + r_offset);
  bfd_signed_vma srel
    = (bfd_signed_vma) relocation + r_addend;

  switch (howto->type)
    {
      /* All these are PC-relative.  */
    case R_MMIX_PUSHJ_STUBBABLE:
    case R_MMIX_PUSHJ:
    case R_MMIX_CBRANCH:
    case R_MMIX_ADDR19:
    case R_MMIX_GETA:
    case R_MMIX_ADDR27:
    case R_MMIX_JMP:
      contents += r_offset;

      srel -= (input_section->output_section->vma
	       + input_section->output_offset
	       + r_offset);

      r = mmix_elf_perform_relocation (input_section, howto, contents,
				       addr, srel, error_message);
      break;

    case R_MMIX_BASE_PLUS_OFFSET:
      if (symsec == NULL)
	return bfd_reloc_undefined;

      /* Check that we're not relocating against a register symbol.  */
      if (strcmp (bfd_get_section_name (symsec->owner, symsec),
		  MMIX_REG_CONTENTS_SECTION_NAME) == 0
	  || strcmp (bfd_get_section_name (symsec->owner, symsec),
		     MMIX_REG_SECTION_NAME) == 0)
	{
	  /* Note: This is separated out into two messages in order
	     to ease the translation into other languages.  */
	  if (symname == NULL || *symname == 0)
	    (*_bfd_error_handler)
	      (_("%s: base-plus-offset relocation against register symbol: (unknown) in %s"),
	       bfd_get_filename (input_section->owner),
	       bfd_get_section_name (symsec->owner, symsec));
	  else
	    (*_bfd_error_handler)
	      (_("%s: base-plus-offset relocation against register symbol: %s in %s"),
	       bfd_get_filename (input_section->owner), symname,
	       bfd_get_section_name (symsec->owner, symsec));
	  return bfd_reloc_overflow;
	}
      goto do_mmix_reloc;

    case R_MMIX_REG_OR_BYTE:
    case R_MMIX_REG:
      /* For now, we handle these alike.  They must refer to an register
	 symbol, which is either relative to the register section and in
	 the range 0..255, or is in the register contents section with vma
	 regno * 8.  */

      /* FIXME: A better way to check for reg contents section?
	 FIXME: Postpone section->scaling to mmix_elf_perform_relocation? */
      if (symsec == NULL)
	return bfd_reloc_undefined;

      if (strcmp (bfd_get_section_name (symsec->owner, symsec),
		  MMIX_REG_CONTENTS_SECTION_NAME) == 0)
	{
	  if ((srel & 7) != 0 || srel < 32*8 || srel > 255*8)
	    {
	      /* The bfd_reloc_outofrange return value, though intuitively
		 a better value, will not get us an error.  */
	      return bfd_reloc_overflow;
	    }
	  srel /= 8;
	}
      else if (strcmp (bfd_get_section_name (symsec->owner, symsec),
		       MMIX_REG_SECTION_NAME) == 0)
	{
	  if (srel < 0 || srel > 255)
	    /* The bfd_reloc_outofrange return value, though intuitively a
	       better value, will not get us an error.  */
	    return bfd_reloc_overflow;
	}
      else
	{
	  /* Note: This is separated out into two messages in order
	     to ease the translation into other languages.  */
	  if (symname == NULL || *symname == 0)
	    (*_bfd_error_handler)
	      (_("%s: register relocation against non-register symbol: (unknown) in %s"),
	       bfd_get_filename (input_section->owner),
	       bfd_get_section_name (symsec->owner, symsec));
	  else
	    (*_bfd_error_handler)
	      (_("%s: register relocation against non-register symbol: %s in %s"),
	       bfd_get_filename (input_section->owner), symname,
	       bfd_get_section_name (symsec->owner, symsec));

	  /* The bfd_reloc_outofrange return value, though intuitively a
	     better value, will not get us an error.  */
	  return bfd_reloc_overflow;
	}
    do_mmix_reloc:
      contents += r_offset;
      r = mmix_elf_perform_relocation (input_section, howto, contents,
				       addr, srel, error_message);
      break;

    case R_MMIX_LOCAL:
      /* This isn't a real relocation, it's just an assertion that the
	 final relocation value corresponds to a local register.  We
	 ignore the actual relocation; nothing is changed.  */
      {
	asection *regsec
	  = bfd_get_section_by_name (input_section->output_section->owner,
				     MMIX_REG_CONTENTS_SECTION_NAME);
	bfd_vma first_global;

	/* Check that this is an absolute value, or a reference to the
	   register contents section or the register (symbol) section.
	   Absolute numbers can get here as undefined section.  Undefined
	   symbols are signalled elsewhere, so there's no conflict in us
	   accidentally handling it.  */
	if (!bfd_is_abs_section (symsec)
	    && !bfd_is_und_section (symsec)
	    && strcmp (bfd_get_section_name (symsec->owner, symsec),
		       MMIX_REG_CONTENTS_SECTION_NAME) != 0
	    && strcmp (bfd_get_section_name (symsec->owner, symsec),
		       MMIX_REG_SECTION_NAME) != 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: directive LOCAL valid only with a register or absolute value"),
	     bfd_get_filename (input_section->owner));

	  return bfd_reloc_overflow;
	}

      /* If we don't have a register contents section, then $255 is the
	 first global register.  */
      if (regsec == NULL)
	first_global = 255;
      else
	{
	  first_global
	    = bfd_get_section_vma (input_section->output_section->owner,
				   regsec) / 8;
	  if (strcmp (bfd_get_section_name (symsec->owner, symsec),
		      MMIX_REG_CONTENTS_SECTION_NAME) == 0)
	    {
	      if ((srel & 7) != 0 || srel < 32*8 || srel > 255*8)
		/* The bfd_reloc_outofrange return value, though
		   intuitively a better value, will not get us an error.  */
		return bfd_reloc_overflow;
	      srel /= 8;
	    }
	}

	if ((bfd_vma) srel >= first_global)
	  {
	    /* FIXME: Better error message.  */
	    (*_bfd_error_handler)
	      (_("%s: LOCAL directive: Register $%ld is not a local register.  First global register is $%ld."),
	       bfd_get_filename (input_section->owner), (long) srel, (long) first_global);

	    return bfd_reloc_overflow;
	  }
      }
      r = bfd_reloc_ok;
      break;

    default:
      r = _bfd_final_link_relocate (howto, input_section->owner, input_section,
				    contents, r_offset,
				    relocation, r_addend);
    }

  return r;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
mmix_elf_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_MMIX_GNU_VTINHERIT:
      case R_MMIX_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update relocation info for a GC-excluded section.  We could supposedly
   perform the allocation after GC, but there's no suitable hook between
   GC (or section merge) and the point when all input sections must be
   present.  Better to waste some memory and (perhaps) a little time.  */

static bfd_boolean
mmix_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  struct bpo_reloc_section_info *bpodata
    = mmix_elf_section_data (sec)->bpo.reloc;
  asection *allocated_gregs_section;

  /* If no bpodata here, we have nothing to do.  */
  if (bpodata == NULL)
    return TRUE;

  allocated_gregs_section = bpodata->bpo_greg_section;

  mmix_elf_section_data (allocated_gregs_section)->bpo.greg->n_bpo_relocs
    -= bpodata->n_bpo_relocs_this_section;

  return TRUE;
}

/* Sort register relocs to come before expanding relocs.  */

static int
mmix_elf_sort_relocs (const void * p1, const void * p2)
{
  const Elf_Internal_Rela *r1 = (const Elf_Internal_Rela *) p1;
  const Elf_Internal_Rela *r2 = (const Elf_Internal_Rela *) p2;
  int r1_is_reg, r2_is_reg;

  /* Sort primarily on r_offset & ~3, so relocs are done to consecutive
     insns.  */
  if ((r1->r_offset & ~(bfd_vma) 3) > (r2->r_offset & ~(bfd_vma) 3))
    return 1;
  else if ((r1->r_offset & ~(bfd_vma) 3) < (r2->r_offset & ~(bfd_vma) 3))
    return -1;

  r1_is_reg
    = (ELF64_R_TYPE (r1->r_info) == R_MMIX_REG_OR_BYTE
       || ELF64_R_TYPE (r1->r_info) == R_MMIX_REG);
  r2_is_reg
    = (ELF64_R_TYPE (r2->r_info) == R_MMIX_REG_OR_BYTE
       || ELF64_R_TYPE (r2->r_info) == R_MMIX_REG);
  if (r1_is_reg != r2_is_reg)
    return r2_is_reg - r1_is_reg;

  /* Neither or both are register relocs.  Then sort on full offset.  */
  if (r1->r_offset > r2->r_offset)
    return 1;
  else if (r1->r_offset < r2->r_offset)
    return -1;
  return 0;
}

/* Subset of mmix_elf_check_relocs, common to ELF and mmo linking.  */

static bfd_boolean
mmix_elf_check_common_relocs  (bfd *abfd,
			       struct bfd_link_info *info,
			       asection *sec,
			       const Elf_Internal_Rela *relocs)
{
  bfd *bpo_greg_owner = NULL;
  asection *allocated_gregs_section = NULL;
  struct bpo_greg_section_info *gregdata = NULL;
  struct bpo_reloc_section_info *bpodata = NULL;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  /* We currently have to abuse this COFF-specific member, since there's
     no target-machine-dedicated member.  There's no alternative outside
     the bfd_link_info struct; we can't specialize a hash-table since
     they're different between ELF and mmo.  */
  bpo_greg_owner = (bfd *) info->base_file;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      switch (ELF64_R_TYPE (rel->r_info))
        {
	  /* This relocation causes a GREG allocation.  We need to count
	     them, and we need to create a section for them, so we need an
	     object to fake as the owner of that section.  We can't use
	     the ELF dynobj for this, since the ELF bits assume lots of
	     DSO-related stuff if that member is non-NULL.  */
	case R_MMIX_BASE_PLUS_OFFSET:
	  /* We don't do anything with this reloc for a relocatable link.  */
	  if (info->relocatable)
	    break;

	  if (bpo_greg_owner == NULL)
	    {
	      bpo_greg_owner = abfd;
	      info->base_file = bpo_greg_owner;
	    }

	  if (allocated_gregs_section == NULL)
	    allocated_gregs_section
	      = bfd_get_section_by_name (bpo_greg_owner,
					 MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);

	  if (allocated_gregs_section == NULL)
	    {
	      allocated_gregs_section
		= bfd_make_section_with_flags (bpo_greg_owner,
					       MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME,
					       (SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED));
	      /* Setting both SEC_ALLOC and SEC_LOAD means the section is
		 treated like any other section, and we'd get errors for
		 address overlap with the text section.  Let's set none of
		 those flags, as that is what currently happens for usual
		 GREG allocations, and that works.  */
	      if (allocated_gregs_section == NULL
		  || !bfd_set_section_alignment (bpo_greg_owner,
						 allocated_gregs_section,
						 3))
		return FALSE;

	      gregdata = (struct bpo_greg_section_info *)
		bfd_zalloc (bpo_greg_owner, sizeof (struct bpo_greg_section_info));
	      if (gregdata == NULL)
		return FALSE;
	      mmix_elf_section_data (allocated_gregs_section)->bpo.greg
		= gregdata;
	    }
	  else if (gregdata == NULL)
	    gregdata
	      = mmix_elf_section_data (allocated_gregs_section)->bpo.greg;

	  /* Get ourselves some auxiliary info for the BPO-relocs.  */
	  if (bpodata == NULL)
	    {
	      /* No use doing a separate iteration pass to find the upper
		 limit - just use the number of relocs.  */
	      bpodata = (struct bpo_reloc_section_info *)
		bfd_alloc (bpo_greg_owner,
			   sizeof (struct bpo_reloc_section_info)
			   * (sec->reloc_count + 1));
	      if (bpodata == NULL)
		return FALSE;
	      mmix_elf_section_data (sec)->bpo.reloc = bpodata;
	      bpodata->first_base_plus_offset_reloc
		= bpodata->bpo_index
		= gregdata->n_max_bpo_relocs;
	      bpodata->bpo_greg_section
		= allocated_gregs_section;
	      bpodata->n_bpo_relocs_this_section = 0;
	    }

	  bpodata->n_bpo_relocs_this_section++;
	  gregdata->n_max_bpo_relocs++;

	  /* We don't get another chance to set this before GC; we've not
	     set up any hook that runs before GC.  */
	  gregdata->n_bpo_relocs
	    = gregdata->n_max_bpo_relocs;
	  break;

	case R_MMIX_PUSHJ_STUBBABLE:
	  mmix_elf_section_data (sec)->pjs.n_pushj_relocs++;
	  break;
	}
    }

  /* Allocate per-reloc stub storage and initialize it to the max stub
     size.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs != 0)
    {
      size_t i;

      mmix_elf_section_data (sec)->pjs.stub_size
	= bfd_alloc (abfd, mmix_elf_section_data (sec)->pjs.n_pushj_relocs
		     * sizeof (mmix_elf_section_data (sec)
			       ->pjs.stub_size[0]));
      if (mmix_elf_section_data (sec)->pjs.stub_size == NULL)
	return FALSE;

      for (i = 0; i < mmix_elf_section_data (sec)->pjs.n_pushj_relocs; i++)
	mmix_elf_section_data (sec)->pjs.stub_size[i] = MAX_PUSHJ_STUB_SIZE;
    }

  return TRUE;
}

/* Look through the relocs for a section during the first phase.  */

static bfd_boolean
mmix_elf_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  /* First we sort the relocs so that any register relocs come before
     expansion-relocs to the same insn.  FIXME: Not done for mmo.  */
  qsort ((void *) relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
	 mmix_elf_sort_relocs);

  /* Do the common part.  */
  if (!mmix_elf_check_common_relocs (abfd, info, sec, relocs))
    return FALSE;

  if (info->relocatable)
    return TRUE;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF64_R_TYPE (rel->r_info))
	{
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_MMIX_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_MMIX_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
	}
    }

  return TRUE;
}

/* Wrapper for mmix_elf_check_common_relocs, called when linking to mmo.
   Copied from elf_link_add_object_symbols.  */

bfd_boolean
_bfd_mmix_check_all_relocs (bfd *abfd, struct bfd_link_info *info)
{
  asection *o;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      Elf_Internal_Rela *internal_relocs;
      bfd_boolean ok;

      if ((o->flags & SEC_RELOC) == 0
	  || o->reloc_count == 0
	  || ((info->strip == strip_all || info->strip == strip_debugger)
	      && (o->flags & SEC_DEBUGGING) != 0)
	  || bfd_is_abs_section (o->output_section))
	continue;

      internal_relocs
	= _bfd_elf_link_read_relocs (abfd, o, NULL,
				     (Elf_Internal_Rela *) NULL,
				     info->keep_memory);
      if (internal_relocs == NULL)
	return FALSE;

      ok = mmix_elf_check_common_relocs (abfd, info, o, internal_relocs);

      if (! info->keep_memory)
	free (internal_relocs);

      if (! ok)
	return FALSE;
    }

  return TRUE;
}

/* Change symbols relative to the reg contents section to instead be to
   the register section, and scale them down to correspond to the register
   number.  */

static int
mmix_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  const char *name ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym,
				  asection *input_sec,
				  struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  if (input_sec != NULL
      && input_sec->name != NULL
      && ELF_ST_TYPE (sym->st_info) != STT_SECTION
      && strcmp (input_sec->name, MMIX_REG_CONTENTS_SECTION_NAME) == 0)
    {
      sym->st_value /= 8;
      sym->st_shndx = SHN_REGISTER;
    }

  return 1;
}

/* We fake a register section that holds values that are register numbers.
   Having a SHN_REGISTER and register section translates better to other
   formats (e.g. mmo) than for example a STT_REGISTER attribute.
   This section faking is based on a construct in elf32-mips.c.  */
static asection mmix_elf_reg_section;
static asymbol mmix_elf_reg_section_symbol;
static asymbol *mmix_elf_reg_section_symbol_ptr;

/* Handle the special section numbers that a symbol may use.  */

void
mmix_elf_symbol_processing (abfd, asym)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *asym;
{
  elf_symbol_type *elfsym;

  elfsym = (elf_symbol_type *) asym;
  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_REGISTER:
      if (mmix_elf_reg_section.name == NULL)
	{
	  /* Initialize the register section.  */
	  mmix_elf_reg_section.name = MMIX_REG_SECTION_NAME;
	  mmix_elf_reg_section.flags = SEC_NO_FLAGS;
	  mmix_elf_reg_section.output_section = &mmix_elf_reg_section;
	  mmix_elf_reg_section.symbol = &mmix_elf_reg_section_symbol;
	  mmix_elf_reg_section.symbol_ptr_ptr = &mmix_elf_reg_section_symbol_ptr;
	  mmix_elf_reg_section_symbol.name = MMIX_REG_SECTION_NAME;
	  mmix_elf_reg_section_symbol.flags = BSF_SECTION_SYM;
	  mmix_elf_reg_section_symbol.section = &mmix_elf_reg_section;
	  mmix_elf_reg_section_symbol_ptr = &mmix_elf_reg_section_symbol;
	}
      asym->section = &mmix_elf_reg_section;
      break;

    default:
      break;
    }
}

/* Given a BFD section, try to locate the corresponding ELF section
   index.  */

static bfd_boolean
mmix_elf_section_from_bfd_section (bfd *       abfd ATTRIBUTE_UNUSED,
				   asection *  sec,
				   int *       retval)
{
  if (strcmp (bfd_get_section_name (abfd, sec), MMIX_REG_SECTION_NAME) == 0)
    *retval = SHN_REGISTER;
  else
    return FALSE;

  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special SHN_REGISTER section number here.

   We also check that we only have *one* each of the section-start
   symbols, since otherwise having two with the same value would cause
   them to be "merged", but with the contents serialized.  */

static bfd_boolean
mmix_elf_add_symbol_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  Elf_Internal_Sym *sym,
			  const char **namep ATTRIBUTE_UNUSED,
			  flagword *flagsp ATTRIBUTE_UNUSED,
			  asection **secp,
			  bfd_vma *valp ATTRIBUTE_UNUSED)
{
  if (sym->st_shndx == SHN_REGISTER)
    {
      *secp = bfd_make_section_old_way (abfd, MMIX_REG_SECTION_NAME);
      (*secp)->flags |= SEC_LINKER_CREATED;
    }
  else if ((*namep)[0] == '_' && (*namep)[1] == '_' && (*namep)[2] == '.'
	   && CONST_STRNEQ (*namep, MMIX_LOC_SECTION_START_SYMBOL_PREFIX))
    {
      /* See if we have another one.  */
      struct bfd_link_hash_entry *h = bfd_link_hash_lookup (info->hash,
							    *namep,
							    FALSE,
							    FALSE,
							    FALSE);

      if (h != NULL && h->type != bfd_link_hash_undefined)
	{
	  /* How do we get the asymbol (or really: the filename) from h?
	     h->u.def.section->owner is NULL.  */
	  ((*_bfd_error_handler)
	   (_("%s: Error: multiple definition of `%s'; start of %s is set in a earlier linked file\n"),
	    bfd_get_filename (abfd), *namep,
	    *namep + strlen (MMIX_LOC_SECTION_START_SYMBOL_PREFIX)));
	   bfd_set_error (bfd_error_bad_value);
	   return FALSE;
	}
    }

  return TRUE;
}

/* We consider symbols matching "L.*:[0-9]+" to be local symbols.  */

static bfd_boolean
mmix_elf_is_local_label_name (bfd *abfd, const char *name)
{
  const char *colpos;
  int digits;

  /* Also include the default local-label definition.  */
  if (_bfd_elf_is_local_label_name (abfd, name))
    return TRUE;

  if (*name != 'L')
    return FALSE;

  /* If there's no ":", or more than one, it's not a local symbol.  */
  colpos = strchr (name, ':');
  if (colpos == NULL || strchr (colpos + 1, ':') != NULL)
    return FALSE;

  /* Check that there are remaining characters and that they are digits.  */
  if (colpos[1] == 0)
    return FALSE;

  digits = strspn (colpos + 1, "0123456789");
  return digits != 0 && colpos[1 + digits] == 0;
}

/* We get rid of the register section here.  */

bfd_boolean
mmix_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  /* We never output a register section, though we create one for
     temporary measures.  Check that nobody entered contents into it.  */
  asection *reg_section;

  reg_section = bfd_get_section_by_name (abfd, MMIX_REG_SECTION_NAME);

  if (reg_section != NULL)
    {
      /* FIXME: Pass error state gracefully.  */
      if (bfd_get_section_flags (abfd, reg_section) & SEC_HAS_CONTENTS)
	_bfd_abort (__FILE__, __LINE__, _("Register section has contents\n"));

      /* Really remove the section, if it hasn't already been done.  */
      if (!bfd_section_removed_from_list (abfd, reg_section))
	{
	  bfd_section_list_remove (abfd, reg_section);
	  --abfd->section_count;
	}
    }

  if (! bfd_elf_final_link (abfd, info))
    return FALSE;

  /* Since this section is marked SEC_LINKER_CREATED, it isn't output by
     the regular linker machinery.  We do it here, like other targets with
     special sections.  */
  if (info->base_file != NULL)
    {
      asection *greg_section
	= bfd_get_section_by_name ((bfd *) info->base_file,
				   MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);
      if (!bfd_set_section_contents (abfd,
				     greg_section->output_section,
				     greg_section->contents,
				     (file_ptr) greg_section->output_offset,
				     greg_section->size))
	return FALSE;
    }
  return TRUE;
}

/* We need to include the maximum size of PUSHJ-stubs in the initial
   section size.  This is expected to shrink during linker relaxation.  */

static void
mmix_set_relaxable_size (bfd *abfd ATTRIBUTE_UNUSED,
			 asection *sec,
			 void *ptr)
{
  struct bfd_link_info *info = ptr;

  /* Make sure we only do this for section where we know we want this,
     otherwise we might end up resetting the size of COMMONs.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0)
    return;

  sec->rawsize = sec->size;
  sec->size += (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
		* MAX_PUSHJ_STUB_SIZE);

  /* For use in relocatable link, we start with a max stubs size.  See
     mmix_elf_relax_section.  */
  if (info->relocatable && sec->output_section)
    mmix_elf_section_data (sec->output_section)->pjs.stubs_size_sum
      += (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
	  * MAX_PUSHJ_STUB_SIZE);
}

/* Initialize stuff for the linker-generated GREGs to match
   R_MMIX_BASE_PLUS_OFFSET relocs seen by the linker.  */

bfd_boolean
_bfd_mmix_before_linker_allocation (bfd *abfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info)
{
  asection *bpo_gregs_section;
  bfd *bpo_greg_owner;
  struct bpo_greg_section_info *gregdata;
  size_t n_gregs;
  bfd_vma gregs_size;
  size_t i;
  size_t *bpo_reloc_indexes;
  bfd *ibfd;

  /* Set the initial size of sections.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    bfd_map_over_sections (ibfd, mmix_set_relaxable_size, info);

  /* The bpo_greg_owner bfd is supposed to have been set by
     mmix_elf_check_relocs when the first R_MMIX_BASE_PLUS_OFFSET is seen.
     If there is no such object, there was no R_MMIX_BASE_PLUS_OFFSET.  */
  bpo_greg_owner = (bfd *) info->base_file;
  if (bpo_greg_owner == NULL)
    return TRUE;

  bpo_gregs_section
    = bfd_get_section_by_name (bpo_greg_owner,
			       MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);

  if (bpo_gregs_section == NULL)
    return TRUE;

  /* We use the target-data handle in the ELF section data.  */
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
  if (gregdata == NULL)
    return FALSE;

  n_gregs = gregdata->n_bpo_relocs;
  gregdata->n_allocated_bpo_gregs = n_gregs;

  /* When this reaches zero during relaxation, all entries have been
     filled in and the size of the linker gregs can be calculated.  */
  gregdata->n_remaining_bpo_relocs_this_relaxation_round = n_gregs;

  /* Set the zeroth-order estimate for the GREGs size.  */
  gregs_size = n_gregs * 8;

  if (!bfd_set_section_size (bpo_greg_owner, bpo_gregs_section, gregs_size))
    return FALSE;

  /* Allocate and set up the GREG arrays.  They're filled in at relaxation
     time.  Note that we must use the max number ever noted for the array,
     since the index numbers were created before GC.  */
  gregdata->reloc_request
    = bfd_zalloc (bpo_greg_owner,
		  sizeof (struct bpo_reloc_request)
		  * gregdata->n_max_bpo_relocs);

  gregdata->bpo_reloc_indexes
    = bpo_reloc_indexes
    = bfd_alloc (bpo_greg_owner,
		 gregdata->n_max_bpo_relocs
		 * sizeof (size_t));
  if (bpo_reloc_indexes == NULL)
    return FALSE;

  /* The default order is an identity mapping.  */
  for (i = 0; i < gregdata->n_max_bpo_relocs; i++)
    {
      bpo_reloc_indexes[i] = i;
      gregdata->reloc_request[i].bpo_reloc_no = i;
    }

  return TRUE;
}

/* Fill in contents in the linker allocated gregs.  Everything is
   calculated at this point; we just move the contents into place here.  */

bfd_boolean
_bfd_mmix_after_linker_allocation (bfd *abfd ATTRIBUTE_UNUSED,
				   struct bfd_link_info *link_info)
{
  asection *bpo_gregs_section;
  bfd *bpo_greg_owner;
  struct bpo_greg_section_info *gregdata;
  size_t n_gregs;
  size_t i, j;
  size_t lastreg;
  bfd_byte *contents;

  /* The bpo_greg_owner bfd is supposed to have been set by mmix_elf_check_relocs
     when the first R_MMIX_BASE_PLUS_OFFSET is seen.  If there is no such
     object, there was no R_MMIX_BASE_PLUS_OFFSET.  */
  bpo_greg_owner = (bfd *) link_info->base_file;
  if (bpo_greg_owner == NULL)
    return TRUE;

  bpo_gregs_section
    = bfd_get_section_by_name (bpo_greg_owner,
			       MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);

  /* This can't happen without DSO handling.  When DSOs are handled
     without any R_MMIX_BASE_PLUS_OFFSET seen, there will be no such
     section.  */
  if (bpo_gregs_section == NULL)
    return TRUE;

  /* We use the target-data handle in the ELF section data.  */

  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
  if (gregdata == NULL)
    return FALSE;

  n_gregs = gregdata->n_allocated_bpo_gregs;

  bpo_gregs_section->contents
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->size);
  if (contents == NULL)
    return FALSE;

  /* Sanity check: If these numbers mismatch, some relocation has not been
     accounted for and the rest of gregdata is probably inconsistent.
     It's a bug, but it's more helpful to identify it than segfaulting
     below.  */
  if (gregdata->n_remaining_bpo_relocs_this_relaxation_round
      != gregdata->n_bpo_relocs)
    {
      (*_bfd_error_handler)
	(_("Internal inconsistency: remaining %u != max %u.\n\
  Please report this bug."),
	 gregdata->n_remaining_bpo_relocs_this_relaxation_round,
	 gregdata->n_bpo_relocs);
      return FALSE;
    }

  for (lastreg = 255, i = 0, j = 0; j < n_gregs; i++)
    if (gregdata->reloc_request[i].regindex != lastreg)
      {
	bfd_put_64 (bpo_greg_owner, gregdata->reloc_request[i].value,
		    contents + j * 8);
	lastreg = gregdata->reloc_request[i].regindex;
	j++;
      }

  return TRUE;
}

/* Sort valid relocs to come before non-valid relocs, then on increasing
   value.  */

static int
bpo_reloc_request_sort_fn (const void * p1, const void * p2)
{
  const struct bpo_reloc_request *r1 = (const struct bpo_reloc_request *) p1;
  const struct bpo_reloc_request *r2 = (const struct bpo_reloc_request *) p2;

  /* Primary function is validity; non-valid relocs sorted after valid
     ones.  */
  if (r1->valid != r2->valid)
    return r2->valid - r1->valid;

  /* Then sort on value.  Don't simplify and return just the difference of
     the values: the upper bits of the 64-bit value would be truncated on
     a host with 32-bit ints.  */
  if (r1->value != r2->value)
    return r1->value > r2->value ? 1 : -1;

  /* As a last re-sort, use the relocation number, so we get a stable
     sort.  The *addresses* aren't stable since items are swapped during
     sorting.  It depends on the qsort implementation if this actually
     happens.  */
  return r1->bpo_reloc_no > r2->bpo_reloc_no
    ? 1 : (r1->bpo_reloc_no < r2->bpo_reloc_no ? -1 : 0);
}

/* For debug use only.  Dumps the global register allocations resulting
   from base-plus-offset relocs.  */

void
mmix_dump_bpo_gregs (link_info, pf)
     struct bfd_link_info *link_info;
     bfd_error_handler_type pf;
{
  bfd *bpo_greg_owner;
  asection *bpo_gregs_section;
  struct bpo_greg_section_info *gregdata;
  unsigned int i;

  if (link_info == NULL || link_info->base_file == NULL)
    return;

  bpo_greg_owner = (bfd *) link_info->base_file;

  bpo_gregs_section
    = bfd_get_section_by_name (bpo_greg_owner,
			       MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);

  if (bpo_gregs_section == NULL)
    return;

  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
  if (gregdata == NULL)
    return;

  if (pf == NULL)
    pf = _bfd_error_handler;

  /* These format strings are not translated.  They are for debug purposes
     only and never displayed to an end user.  Should they escape, we
     surely want them in original.  */
  (*pf) (" n_bpo_relocs: %u\n n_max_bpo_relocs: %u\n n_remain...round: %u\n\
 n_allocated_bpo_gregs: %u\n", gregdata->n_bpo_relocs,
     gregdata->n_max_bpo_relocs,
     gregdata->n_remaining_bpo_relocs_this_relaxation_round,
     gregdata->n_allocated_bpo_gregs);

  if (gregdata->reloc_request)
    for (i = 0; i < gregdata->n_max_bpo_relocs; i++)
      (*pf) ("%4u (%4u)/%4u#%u: 0x%08lx%08lx  r: %3u o: %3u\n",
	     i,
	     (gregdata->bpo_reloc_indexes != NULL
	      ? gregdata->bpo_reloc_indexes[i] : (size_t) -1),
	     gregdata->reloc_request[i].bpo_reloc_no,
	     gregdata->reloc_request[i].valid,

	     (unsigned long) (gregdata->reloc_request[i].value >> 32),
	     (unsigned long) gregdata->reloc_request[i].value,
	     gregdata->reloc_request[i].regindex,
	     gregdata->reloc_request[i].offset);
}

/* This links all R_MMIX_BASE_PLUS_OFFSET relocs into a special array, and
   when the last such reloc is done, an index-array is sorted according to
   the values and iterated over to produce register numbers (indexed by 0
   from the first allocated register number) and offsets for use in real
   relocation.  (N.B.: Relocatable runs are handled, not just punted.)

   PUSHJ stub accounting is also done here.

   Symbol- and reloc-reading infrastructure copied from elf-m10200.c.  */

static bfd_boolean
mmix_elf_relax_section (bfd *abfd,
			asection *sec,
			struct bfd_link_info *link_info,
			bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  asection *bpo_gregs_section = NULL;
  struct bpo_greg_section_info *gregdata;
  struct bpo_reloc_section_info *bpodata
    = mmix_elf_section_data (sec)->bpo.reloc;
  /* The initialization is to quiet compiler warnings.  The value is to
     spot a missing actual initialization.  */
  size_t bpono = (size_t) -1;
  size_t pjsno = 0;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_size_type size = sec->rawsize ? sec->rawsize : sec->size;

  mmix_elf_section_data (sec)->pjs.stubs_size_sum = 0;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything if this section does not have relocs, or
     if this is not a code section.  */
  if ((sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0
      || (sec->flags & SEC_LINKER_CREATED) != 0
      /* If no R_MMIX_BASE_PLUS_OFFSET relocs and no PUSHJ-stub relocs,
         then nothing to do.  */
      || (bpodata == NULL
	  && mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0))
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  if (bpodata != NULL)
    {
      bpo_gregs_section = bpodata->bpo_greg_section;
      gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
      bpono = bpodata->first_base_plus_offset_reloc;
    }
  else
    gregdata = NULL;

  /* Get a copy of the native relocations.  */
  internal_relocs
    = _bfd_elf_link_read_relocs (abfd, sec, NULL,
				 (Elf_Internal_Rela *) NULL,
				 link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      struct elf_link_hash_entry *h = NULL;

      /* We only process two relocs.  */
      if (ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_BASE_PLUS_OFFSET
	  && ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_PUSHJ_STUBBABLE)
	continue;

      /* We process relocs in a distinctly different way when this is a
	 relocatable link (for one, we don't look at symbols), so we avoid
	 mixing its code with that for the "normal" relaxation.  */
      if (link_info->relocatable)
	{
	  /* The only transformation in a relocatable link is to generate
	     a full stub at the location of the stub calculated for the
	     input section, if the relocated stub location, the end of the
	     output section plus earlier stubs, cannot be reached.  Thus
	     relocatable linking can only lead to worse code, but it still
	     works.  */
	  if (ELF64_R_TYPE (irel->r_info) == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* If we can reach the end of the output-section and beyond
		 any current stubs, then we don't need a stub for this
		 reloc.  The relaxed order of output stub allocation may
		 not exactly match the straightforward order, so we always
		 assume presence of output stubs, which will allow
		 relaxation only on relocations indifferent to the
		 presence of output stub allocations for other relocations
		 and thus the order of output stub allocation.  */
	      if (bfd_check_overflow (complain_overflow_signed,
				      19,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      /* Output-stub location.  */
				      sec->output_section->rawsize
				      + (mmix_elf_section_data (sec
							       ->output_section)
					 ->pjs.stubs_size_sum)
				      /* Location of this PUSHJ reloc.  */
				      - (sec->output_offset + irel->r_offset)
				      /* Don't count *this* stub twice.  */
				      - (mmix_elf_section_data (sec)
					 ->pjs.stub_size[pjsno]
					 + MAX_PUSHJ_STUB_SIZE))
		  == bfd_reloc_ok)
		mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;

	      mmix_elf_section_data (sec)->pjs.stubs_size_sum
		+= mmix_elf_section_data (sec)->pjs.stub_size[pjsno];

	      pjsno++;
	    }

	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF64_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
	  asection *sym_sec;

	  /* Read this BFD's local symbols if we haven't already.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }

	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    sym_sec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    sym_sec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    sym_sec = bfd_com_section_ptr;
	  else
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;

	  /* An external symbol.  */
	  indx = ELF64_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined symbol.  Just
		 ignore it--it will be caught by the regular reloc processing.
		 We need to keep BPO reloc accounting consistent, though
		 else we'll abort instead of emitting an error message.  */
	      if (ELF64_R_TYPE (irel->r_info) == R_MMIX_BASE_PLUS_OFFSET
		  && gregdata != NULL)
		{
		  gregdata->n_remaining_bpo_relocs_this_relaxation_round--;
		  bpono++;
		}
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      if (ELF64_R_TYPE (irel->r_info) == (int) R_MMIX_PUSHJ_STUBBABLE)
	{
	  bfd_vma value = symval + irel->r_addend;
	  bfd_vma dot
	    = (sec->output_section->vma
	       + sec->output_offset
	       + irel->r_offset);
	  bfd_vma stubaddr
	    = (sec->output_section->vma
	       + sec->output_offset
	       + size
	       + mmix_elf_section_data (sec)->pjs.stubs_size_sum);

	  if ((value & 3) == 0
	      && bfd_check_overflow (complain_overflow_signed,
				     19,
				     0,
				     bfd_arch_bits_per_address (abfd),
				     value - dot
				     - (value > dot
					? mmix_elf_section_data (sec)
					->pjs.stub_size[pjsno]
					: 0))
	      == bfd_reloc_ok)
	    /* If the reloc fits, no stub is needed.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;
	  else
	    /* Maybe we can get away with just a JMP insn?  */
	    if ((value & 3) == 0
		&& bfd_check_overflow (complain_overflow_signed,
				       27,
				       0,
				       bfd_arch_bits_per_address (abfd),
				       value - stubaddr
				       - (value > dot
					  ? mmix_elf_section_data (sec)
					  ->pjs.stub_size[pjsno] - 4
					  : 0))
		== bfd_reloc_ok)
	      /* Yep, account for a stub consisting of a single JMP insn.  */
	      mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 4;
	  else
	    /* Nope, go for the full insn stub.  It doesn't seem useful to
	       emit the intermediate sizes; those will only be useful for
	       a >64M program assuming contiguous code.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno]
	      = MAX_PUSHJ_STUB_SIZE;

	  mmix_elf_section_data (sec)->pjs.stubs_size_sum
	    += mmix_elf_section_data (sec)->pjs.stub_size[pjsno];
	  pjsno++;
	  continue;
	}

      /* We're looking at a R_MMIX_BASE_PLUS_OFFSET reloc.  */

      gregdata->reloc_request[gregdata->bpo_reloc_indexes[bpono]].value
	= symval + irel->r_addend;
      gregdata->reloc_request[gregdata->bpo_reloc_indexes[bpono++]].valid = TRUE;
      gregdata->n_remaining_bpo_relocs_this_relaxation_round--;
    }

  /* Check if that was the last BPO-reloc.  If so, sort the values and
     calculate how many registers we need to cover them.  Set the size of
     the linker gregs, and if the number of registers changed, indicate
     that we need to relax some more because we have more work to do.  */
  if (gregdata != NULL
      && gregdata->n_remaining_bpo_relocs_this_relaxation_round == 0)
    {
      size_t i;
      bfd_vma prev_base;
      size_t regindex;

      /* First, reset the remaining relocs for the next round.  */
      gregdata->n_remaining_bpo_relocs_this_relaxation_round
	= gregdata->n_bpo_relocs;

      qsort (gregdata->reloc_request,
	     gregdata->n_max_bpo_relocs,
	     sizeof (struct bpo_reloc_request),
	     bpo_reloc_request_sort_fn);

      /* Recalculate indexes.  When we find a change (however unlikely
	 after the initial iteration), we know we need to relax again,
	 since items in the GREG-array are sorted by increasing value and
	 stored in the relaxation phase.  */
      for (i = 0; i < gregdata->n_max_bpo_relocs; i++)
	if (gregdata->bpo_reloc_indexes[gregdata->reloc_request[i].bpo_reloc_no]
	    != i)
	  {
	    gregdata->bpo_reloc_indexes[gregdata->reloc_request[i].bpo_reloc_no]
	      = i;
	    *again = TRUE;
	  }

      /* Allocate register numbers (indexing from 0).  Stop at the first
	 non-valid reloc.  */
      for (i = 0, regindex = 0, prev_base = gregdata->reloc_request[0].value;
	   i < gregdata->n_bpo_relocs;
	   i++)
	{
	  if (gregdata->reloc_request[i].value > prev_base + 255)
	    {
	      regindex++;
	      prev_base = gregdata->reloc_request[i].value;
	    }
	  gregdata->reloc_request[i].regindex = regindex;
	  gregdata->reloc_request[i].offset
	    = gregdata->reloc_request[i].value - prev_base;
	}

      /* If it's not the same as the last time, we need to relax again,
	 because the size of the section has changed.  I'm not sure we
	 actually need to do any adjustments since the shrinking happens
	 at the start of this section, but better safe than sorry.  */
      if (gregdata->n_allocated_bpo_gregs != regindex + 1)
	{
	  gregdata->n_allocated_bpo_gregs = regindex + 1;
	  *again = TRUE;
	}

      bpo_gregs_section->size = (regindex + 1) * 8;
    }

  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  if (sec->size < size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    abort ();

  if (sec->size > size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    {
      sec->size = size + mmix_elf_section_data (sec)->pjs.stubs_size_sum;
      *again = TRUE;
    }

  return TRUE;

 error_return:
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

#define ELF_ARCH		bfd_arch_mmix
#define ELF_MACHINE_CODE 	EM_MMIX

/* According to mmix-doc page 36 (paragraph 45), this should be (1LL << 48LL).
   However, that's too much for something somewhere in the linker part of
   BFD; perhaps the start-address has to be a non-zero multiple of this
   number, or larger than this number.  The symptom is that the linker
   complains: "warning: allocated section `.text' not in segment".  We
   settle for 64k; the page-size used in examples is 8k.
   #define ELF_MAXPAGESIZE 0x10000

   Unfortunately, this causes excessive padding in the supposedly small
   for-education programs that are the expected usage (where people would
   inspect output).  We stick to 256 bytes just to have *some* default
   alignment.  */
#define ELF_MAXPAGESIZE 0x100

#define TARGET_BIG_SYM		bfd_elf64_mmix_vec
#define TARGET_BIG_NAME		"elf64-mmix"

#define elf_info_to_howto_rel		NULL
#define elf_info_to_howto		mmix_info_to_howto_rela
#define elf_backend_relocate_section	mmix_elf_relocate_section
#define elf_backend_gc_mark_hook	mmix_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	mmix_elf_gc_sweep_hook

#define elf_backend_link_output_symbol_hook \
	mmix_elf_link_output_symbol_hook
#define elf_backend_add_symbol_hook	mmix_elf_add_symbol_hook

#define elf_backend_check_relocs	mmix_elf_check_relocs
#define elf_backend_symbol_processing	mmix_elf_symbol_processing
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)

#define bfd_elf64_bfd_is_local_label_name \
	mmix_elf_is_local_label_name

#define elf_backend_may_use_rel_p	0
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1

#define elf_backend_can_gc_sections	1
#define elf_backend_section_from_bfd_section \
	mmix_elf_section_from_bfd_section

#define bfd_elf64_new_section_hook	mmix_elf_new_section_hook
#define bfd_elf64_bfd_final_link	mmix_elf_final_link
#define bfd_elf64_bfd_relax_section	mmix_elf_relax_section

#include "elf64-target.h"
@


1.68
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d2012 4
@


1.67
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@a169 3
static int mmix_elf_link_output_symbol_hook
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d171 1
a171 2
static bfd_reloc_status_type mmix_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d173 1
a173 49
static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));

static void mmix_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));

static int mmix_elf_sort_relocs PARAMS ((const PTR, const PTR));

static bfd_boolean mmix_elf_new_section_hook
  PARAMS ((bfd *, asection *));

static bfd_boolean mmix_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_boolean mmix_elf_check_common_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static bfd_boolean mmix_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));

static bfd_reloc_status_type mmix_final_link_relocate
  (reloc_howto_type *, asection *, bfd_byte *, bfd_vma, bfd_signed_vma,
   bfd_vma, const char *, asection *, char **);

static bfd_reloc_status_type mmix_elf_perform_relocation
  (asection *, reloc_howto_type *, void *, bfd_vma, bfd_vma, char **);

static bfd_boolean mmix_elf_section_from_bfd_section
  PARAMS ((bfd *, asection *, int *));

static bfd_boolean mmix_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));

static bfd_boolean mmix_elf_is_local_label_name
  PARAMS ((bfd *, const char *));

static int bpo_reloc_request_sort_fn PARAMS ((const PTR, const PTR));

static bfd_boolean mmix_elf_relax_section
  PARAMS ((bfd *abfd, asection *sec, struct bfd_link_info *link_info,
	   bfd_boolean *again));

extern bfd_boolean mmix_elf_final_link PARAMS ((bfd *, struct bfd_link_info *));

extern void mmix_elf_symbol_processing PARAMS ((bfd *, asymbol *));
d177 1
a177 1
  PARAMS ((struct bfd_link_info *, bfd_error_handler_type));
d180 8
a187 2
mmix_set_relaxable_size
  PARAMS ((bfd *, asection *, void *));
d798 2
a799 3
bfd_elf64_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d831 1
a831 3
mmix_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d1257 3
a1259 4
mmix_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1273 7
a1279 9
mmix_elf_reloc (abfd, reloc_entry, symbol, data, input_section,
		output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1349 8
a1356 10
mmix_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1807 1
a1807 3
mmix_elf_sort_relocs (p1, p2)
     const PTR p1;
     const PTR p2;
d1840 4
a1843 5
mmix_elf_check_common_relocs  (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1876 1
a1876 1
	      info->base_file = (PTR) bpo_greg_owner;
d1972 4
a1975 5
mmix_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1987 1
a1987 1
  qsort ((PTR) relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
d2041 1
a2041 3
_bfd_mmix_check_all_relocs (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2058 1
a2058 1
	= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
d2081 5
a2085 6
mmix_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
d2145 3
a2147 4
mmix_elf_section_from_bfd_section (abfd, sec, retval)
     bfd *                 abfd ATTRIBUTE_UNUSED;
     asection *            sec;
     int *                 retval;
d2164 8
a2171 9
bfd_boolean
mmix_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp ATTRIBUTE_UNUSED;
d2206 2
a2207 4
bfd_boolean
mmix_elf_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d2235 1
a2235 3
mmix_elf_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2282 3
a2284 4
mmix_set_relaxable_size (abfd, sec, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     void *ptr;
d2309 2
a2310 3
_bfd_mmix_before_linker_allocation (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d2387 2
a2388 3
_bfd_mmix_after_linker_allocation (abfd, link_info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *link_info;
d2459 1
a2459 3
bpo_reloc_request_sort_fn (p1, p2)
     const PTR p1;
     const PTR p2;
d2550 4
a2553 5
mmix_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d2599 1
a2599 1
    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
d2803 1
a2803 1
      qsort ((PTR) gregdata->reloc_request,
@


1.66
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1774 3
a1776 1
	  first_global = bfd_get_section_vma (abfd, regsec) / 8;
@


1.65
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1481 1
a1481 1
					 rel, relend, howto, contents);
@


1.64
log
@	PR ld/12815
	* elf64-mmix.c (struct _mmix_elf_section_data): New members
	has_warned_bpo and has_warned_pushj.
	(mmix_final_link_relocate): Remove PARAMS and PTR macros,
	converting to ISO C.  Add new parameter error_message.  All
	callers changed.
	(mmix_elf_perform_relocation): Ditto.
	<case R_MMIX_PUSHJ_STUBBABLE, case R_MMIX_BASE_PLUS_OFFSET>:
	Handle the case where mmix_elf_check_common_relocs has not been
	called, missing preparations for relocs of the respective type.
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d1479 1
a1479 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.64.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1478 1
a1478 1
      if (sec != NULL && discarded_section (sec))
@


1.63
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d78 7
d200 2
a201 2
  PARAMS ((reloc_howto_type *, asection *, bfd_byte *,
	   bfd_vma, bfd_signed_vma, bfd_vma, const char *, asection *));
d204 1
a204 1
  PARAMS ((asection *, reloc_howto_type *, PTR, bfd_vma, bfd_vma));
d944 3
a946 6
mmix_elf_perform_relocation (isec, howto, datap, addr, value)
     asection *isec;
     reloc_howto_type *howto;
     PTR datap;
     bfd_vma addr;
     bfd_vma value;
d1020 30
d1062 2
a1063 1
					   - addr);
d1087 2
a1088 1
					       value + addr - stubaddr);
d1200 37
a1236 6
	asection *bpo_greg_section
	  = bpodata->bpo_greg_section;
	struct bpo_greg_section_info *gregdata
	  = mmix_elf_section_data (bpo_greg_section)->bpo.greg;
	size_t bpo_index
	  = gregdata->bpo_reloc_indexes[bpodata->bpo_index++];
d1330 1
a1330 1
     char **error_message ATTRIBUTE_UNUSED;
d1392 2
a1393 1
				   reloc_target_output_section);
d1525 1
a1525 1
						NULL, NULL) != bfd_reloc_ok)
d1565 1
a1565 1
				    rel->r_addend, relocation, name, sec);
d1622 5
a1626 10
mmix_final_link_relocate (howto, input_section, contents,
			  r_offset, r_addend, relocation, symname, symsec)
     reloc_howto_type *howto;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma r_offset;
     bfd_signed_vma r_addend;
     bfd_vma relocation;
     const char *symname;
     asection *symsec;
d1653 1
a1653 1
				       addr, srel);
d1735 1
a1735 1
				       addr, srel);
@


1.62
log
@fix set but unused variable warnings
@
text
@d1411 2
a1412 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.61
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
a1269 1
  bfd_vma addr;
a1307 3
  /* Get position of relocation.  */
  addr = (reloc_entry->address + input_section->output_section->vma
	  + input_section->output_offset);
a2579 1
  bfd *bpo_greg_owner;
a2601 2
  bpo_greg_owner = (bfd *) link_info->base_file;

@


1.60
log
@	* elf64-mmix.c (mmix_elf_relax_section): Revert 2009-05-27
	change.  Add note to head comment.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.59
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d2560 1
a2560 1
   relocation.
a2592 4
  if (link_info->relocatable)
    (*link_info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

@


1.58
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d2593 4
@


1.57
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d162 1
a162 1
static bfd_boolean mmix_elf_link_output_symbol_hook
d2085 1
a2085 1
static bfd_boolean
d2102 1
a2102 1
  return TRUE;
@


1.56
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d1981 1
a1981 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a1986 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf64_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.55
log
@Switch sources over to use the GPL version 3
@
text
@d2032 3
a2034 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.54
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d6 16
a21 1
This file is part of BFD, the Binary File Descriptor library.
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.53
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d30 1
a31 1
#include "sysdep.h"
@


1.52
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d851 16
@


1.51
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004, 2005, 2006
d1368 39
d1413 2
a1414 10
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }
a1487 29
      /* This is a final link.  */
      howto = elf_mmix_howto_table + ELF64_R_TYPE (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section (input_bfd,
						  symtab_hdr->sh_link,
						  sym->st_name);
	  if (name == NULL)
	    name = bfd_section_name (input_bfd, sec);
	}
      else
	{
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, undefined_signalled);
	  name = h->root.root.string;
	}

@


1.50
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2919 2
@


1.49
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@a189 8
static asection * mmix_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean mmix_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

d1739 5
a1743 6
mmix_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1746 6
a1751 13
    {
      switch (ELF64_R_TYPE (rel->r_info))
	{
	case R_MMIX_GNU_VTINHERIT:
	case R_MMIX_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d1753 1
a1753 12
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
d1762 4
a1765 5
mmix_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
@


1.48
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d2196 1
a2196 2
	   && strncmp (*namep, MMIX_LOC_SECTION_START_SYMBOL_PREFIX,
		       strlen (MMIX_LOC_SECTION_START_SYMBOL_PREFIX)) == 0)
@


1.47
log
@	* elf64-mmix.c (mmix_elf_add_symbol_hook): Mark reg section
	SEC_LINKER_CREATED.
	(mmix_elf_final_link): Check that section hasn't already been
	removed before removing.
	* mmo.c (mmo_scan): Mark reg contents section SEC_LINKER_CREATED.
	(mmo_canonicalize_symtab): Likewise for reg section.
@
text
@d2 2
a3 1
   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d864 4
a867 2
  struct _mmix_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d869 5
a873 4
  sdata = (struct _mmix_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;
@


1.46
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d2187 4
a2190 1
    *secp = bfd_make_section_old_way (abfd, MMIX_REG_SECTION_NAME);
d2267 6
a2272 3
      /* Really remove the section.  */
      bfd_section_list_remove (abfd, reg_section);
      --abfd->section_count;
@


1.45
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d2017 6
a2022 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.44
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1893 5
a1897 2
		= bfd_make_section (bpo_greg_owner,
				    MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);
a1903 5
		  || !bfd_set_section_flags (bpo_greg_owner,
					     allocated_gregs_section,
					     (SEC_HAS_CONTENTS
					      | SEC_IN_MEMORY
					      | SEC_LINKER_CREATED))
@


1.43
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.42
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.41
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@a2251 1
  asection **secpp;
d2262 1
a2262 5
      for (secpp = &abfd->sections;
	   *secpp != reg_section;
	   secpp = &(*secpp)->next)
	;
      bfd_section_list_remove (abfd, secpp);
@


1.40
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d996 1
a996 1
	    = ((char *) datap
@


1.39
log
@	* pdp11.c (struct pdp11_aout_reloc_external): Delete.  Replace
	occurrences with bfd_btye * thoughout file.

	* coff-rs6000.c (do_shared_object_padding): Warning fix.
	(xcoff_write_armap_big): Likewise.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.

	* elf64-mmix.c (mmix_elf_get_section_contents): Delete declaration.
@
text
@d1503 2
a1504 2
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
@


1.38
log
@bfd/
	* elf64-mmix.c (mmix_set_relaxable_size): Save original size in
	rawsize.
	(mmix_elf_perform_relocation): Adjust for above change.
	(mmix_elf_relocate_section): Likewise.
	(mmix_elf_relax_section): Likewise.  Use output_section->rawsize.
	(mmix_elf_get_section_contents): Delete.
	(bfd_elf64_get_section_contents): Delete.
	(mmix_elf_relocate_section): Zero stub area.
	* linker.c (default_indirect_link_order): Alloc max of section size
	and rawsize.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.
	* section.c (bfd_malloc_and_get_section): Likewise.
	(struct bfd_section): Update rawsize comment.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (lang_reset_memory_regions): Save last relax pass section
	size in rawsize.
@
text
@a231 4
static bfd_boolean
mmix_elf_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));

@


1.37
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d994 1
a994 4
	  bfd_size_type size
	    = (isec->size
	       - (mmix_elf_section_data (isec)->pjs.n_pushj_relocs
		  * MAX_PUSHJ_STUB_SIZE));
d1341 1
a1341 4
  bfd_size_type size
    = (input_section->size
       - (mmix_elf_section_data (input_section)->pjs.n_pushj_relocs
	  * MAX_PUSHJ_STUB_SIZE));
d1344 1
d1349 6
d2312 1
d2592 1
a2592 3
  bfd_size_type size = (sec->size
			- (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
			   * MAX_PUSHJ_STUB_SIZE));
d2670 1
a2670 1
				      sec->output_section->size
a2910 46

/* Because we set size to include the max size of pushj stubs,
   i.e. larger than the actual section input size (see
   mmix_set_relaxablesize), we have to take care of that when reading
   the section.  */

static bfd_boolean
mmix_elf_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     void *location;
     file_ptr offset;
     bfd_size_type count;
{
  bfd_size_type size = (section->size
			- (mmix_elf_section_data (section)->pjs.n_pushj_relocs
			   * MAX_PUSHJ_STUB_SIZE));

  if (offset + count > section->size)
    {
      abort();
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Check bounds against the faked size.  */
  if (offset + count > size)
    {
      /* Clear the part in the faked area.  */
      memset (location + size - offset, 0, count - (size - offset));

      /* If there's no initial part within the "real" contents, we're
         done.  */
      if ((bfd_size_type) offset >= size)
	return TRUE;

      /* Else adjust the count and fall through to call the generic
         function.  */
      count = size - offset;
    }

  return
    _bfd_generic_get_section_contents (abfd, section, location, offset,
				       count);
}

a2958 1
#define bfd_elf64_get_section_contents	mmix_elf_get_section_contents
@


1.36
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1263 1
  bfd_size_type sz;
d1279 1
a1279 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.35
log
@	* section.c (struct sec): Remove usused flags.  Reorganize a little.
	(bfd_get_section_size_before_reloc): Delete.
	(bfd_get_section_size_after_reloc): Delete.
	(STD_SECTION): Update.
	(bfd_get_section_size_now): Delete.
	(bfd_set_section_contents): Don't referece reloc_done.
	(bfd_get_section_contents): Remove reloc_done comment.
	* bout.c (b_out_bfd_get_relocated_section_contents): Don't set
	reloc_done.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents): Likewise.
	* ecoff.c (bfd_debug_section): Update initializer.
	* elfxx-mips.c (_bfd_elf_mips_get_relocated_section_contents): Ditto.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* bfd-in.h (bfd_section_size): Expand.
	(bfd_get_section_size): New macro.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_write_object_contents): Replace
	bfd_get_section_size_before_reloc with bfd_get_section_size.
	* coffcode.h (coff_write_object_contents): Likewise.
	* coffgen.c (build_debug_section): Likewise.
	* dwarf1.c (parse_line_table): Likewise.
	(_bfd_dwarf1_find_nearest_line): Likewise.
	* ecoff.c (_bfd_ecoff_write_object_contents): Likewise.
	* i386msdos.c (msdos_write_object_contents): Likewise.
	* pdp11.c (squirt_out_relocs): Likewise.
	* elf32-sh64.c (sh64_find_section_for_address): Remove comment.
	* elf64-mmix.c (mmix_elf_final_link): Update comment.
@
text
@d994 4
a997 4
	  bfd_size_type raw_size
	    = (isec->_raw_size
	       - mmix_elf_section_data (isec)->pjs.n_pushj_relocs
	       * MAX_PUSHJ_STUB_SIZE);
d1005 1
a1005 1
	       + raw_size
d1018 1
a1018 1
					   + raw_size
d1028 1
a1028 1
	       + raw_size
d1048 2
a1049 3
	      if (raw_size
		  + mmix_elf_section_data (isec)->pjs.stub_offset
		  > isec->_cooked_size)
d1264 1
d1280 2
a1281 1
  if (reloc_entry->address > input_section->_cooked_size)
d1346 4
a1349 4
  bfd_size_type raw_size
    = (input_section->_raw_size
       - mmix_elf_section_data (input_section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
d1425 1
a1425 1
						+ raw_size
d1435 1
a1435 1
			      + raw_size
d1443 1
a1443 1
		    = (raw_size
d2291 1
a2291 1
				     greg_section->_cooked_size))
d2298 1
a2298 8
   section size.  This is expected to shrink during linker relaxation.

   You might think that we should set *only* _cooked_size, but that
   won't work: section contents allocation will be using _raw_size in
   mixed format linking and not enough storage will be allocated.
   FIXME: That's a major bug.  The relaxation functions set _cooked
   size.  Relaxation happens before relocation.  All functions
   *after relaxation* should be using _cooked size.  */
d2313 2
a2314 5
  sec->_cooked_size
    = (sec->_raw_size
       + mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
  sec->_raw_size = sec->_cooked_size;
a2443 3
  /* We need to have a _raw_size contents even though there's only
     _cooked_size worth of data, since the generic relocation machinery
     will allocate and copy that much temporarily.  */
d2445 1
a2445 1
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->_raw_size);
d2592 3
a2594 4
  bfd_size_type raw_size
    = (sec->_raw_size
       - mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
a2600 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0 && sec->_raw_size != 0)
    abort ();

d2672 1
a2672 1
				      sec->output_section->_cooked_size
d2765 1
a2765 1
	       + raw_size
d2876 1
a2876 1
      bpo_gregs_section->_cooked_size = (regindex + 1) * 8;
d2894 1
a2894 2
  if (sec->_cooked_size
      < raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
d2897 1
a2897 2
  if (sec->_cooked_size
      > raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
d2899 1
a2899 2
      sec->_cooked_size
	= raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum;
d2914 1
a2914 1
/* Because we set _raw_size to include the max size of pushj stubs,
d2916 1
a2916 1
   mmix_set_relaxable_raw_size), we have to take care of that when reading
d2927 3
a2929 4
  bfd_size_type raw_size
    = (section->_raw_size
       - mmix_elf_section_data (section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
d2931 1
a2931 1
  if (offset + count > section->_raw_size)
d2938 2
a2939 2
  /* Check bounds against the faked raw_size.  */
  if (offset + count > raw_size)
d2942 1
a2942 1
      memset (location + raw_size - offset, 0, count - (raw_size - offset));
d2946 1
a2946 1
      if ((bfd_size_type) offset >= raw_size)
d2951 1
a2951 1
      count = raw_size - offset;
@


1.34
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2299 5
a2303 6
   You might think that we should set *only* _cooked_size, but that won't
   work: section contents allocation will be using _raw_size in mixed
   format linking and not enough storage will be allocated.  FIXME: That's
   a major bug, including the name bfd_get_section_size_before_reloc; it
   should be bfd_get_section_size_before_relax.  The relaxation functions
   set _cooked size.  Relaxation happens before relocation.  All functions
@


1.33
log
@	* elf64-mmix.c (mmix_elf_relocate_section): Restore code setting
	"name" for global syms accidentally removed in 2004-03-20 change.
@
text
@d2030 1
a2030 1
          if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2037 1
a2037 1
          if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2275 1
a2275 1
  if (! bfd_elf64_bfd_final_link (abfd, info))
@


1.32
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d1477 5
a1481 3
	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
d1491 1
@


1.31
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d208 1
a208 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d2178 1
a2178 1
     const Elf_Internal_Sym *sym;
@


1.30
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d1485 4
a1488 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, undefined_signalled);
@


1.29
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d1483 1
a1483 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d1485 3
a1487 31
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      /* The test on undefined_signalled is redundant at the
		 moment, but kept for symmetry.  */
	      if (! undefined_signalled
		  && ! ((*info->callbacks->undefined_symbol)
			(info, h->root.root.string, input_bfd,
			 input_section, rel->r_offset, TRUE)))
		return FALSE;
	      undefined_signalled = TRUE;
	      relocation = 0;
	    }
@


1.29.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d208 1
a208 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1477 3
a1479 5
	  name = bfd_elf_string_from_elf_section (input_bfd,
						  symtab_hdr->sh_link,
						  sym->st_name);
	  if (name == NULL)
	    name = bfd_section_name (input_bfd, sec);
d1483 5
a1487 1
	  bfd_boolean unresolved_reloc;
a1488 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, undefined_signalled);
d1490 26
d2054 1
a2054 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2061 1
a2061 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2205 1
a2205 1
     Elf_Internal_Sym *sym;
d2299 1
a2299 1
  if (! bfd_elf_final_link (abfd, info))
@


1.29.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d208 1
a208 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1483 1
a1483 1
	  bfd_boolean unresolved_reloc;
d1485 31
a1515 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, undefined_signalled);
d2205 1
a2205 1
     Elf_Internal_Sym *sym;
@


1.29.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1477 3
a1479 5
	  name = bfd_elf_string_from_elf_section (input_bfd,
						  symtab_hdr->sh_link,
						  sym->st_name);
	  if (name == NULL)
	    name = bfd_section_name (input_bfd, sec);
a1488 1
	  name = h->root.root.string;
d2027 1
a2027 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2034 1
a2034 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2272 1
a2272 1
  if (! bfd_elf_final_link (abfd, info))
@


1.29.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d232 4
d994 4
a997 1
	  bfd_size_type size = isec->rawsize ? isec->rawsize : isec->size;
d1005 1
a1005 1
	       + size
d1018 1
a1018 1
					   + size
d1028 1
a1028 1
	       + size
d1048 3
a1050 2
	      if (size + mmix_elf_section_data (isec)->pjs.stub_offset
		  > isec->size)
d1280 1
a1280 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1345 4
a1348 1
  bfd_size_type size;
a1350 1
  size = input_section->rawsize ? input_section->rawsize : input_section->size;
a1354 6
  /* Zero the stub area before we start.  */
  if (input_section->rawsize != 0
      && input_section->size > input_section->rawsize)
    memset (contents + input_section->rawsize, 0,
	    input_section->size - input_section->rawsize);

d1424 1
a1424 1
						+ size
d1434 1
a1434 1
			      + size
d1442 1
a1442 1
		    = (size
d2290 1
a2290 1
				     greg_section->size))
d2297 9
a2305 1
   section size.  This is expected to shrink during linker relaxation.  */
d2320 5
a2324 3
  sec->rawsize = sec->size;
  sec->size += (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
		* MAX_PUSHJ_STUB_SIZE);
d2454 3
d2458 1
a2458 1
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->size);
d2605 4
a2608 1
  bfd_size_type size = sec->rawsize ? sec->rawsize : sec->size;
d2615 5
d2691 1
a2691 1
				      sec->output_section->rawsize
d2784 1
a2784 1
	       + size
d2895 1
a2895 1
      bpo_gregs_section->size = (regindex + 1) * 8;
d2913 2
a2914 1
  if (sec->size < size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
d2917 2
a2918 1
  if (sec->size > size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
d2920 2
a2921 1
      sec->size = size + mmix_elf_section_data (sec)->pjs.stubs_size_sum;
d2935 47
d3030 1
@


1.29.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1483 1
a1483 1
	  bfd_boolean unresolved_reloc;
d1485 31
a1515 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, undefined_signalled);
@


1.28
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d160 2
a161 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *));
d2116 1
a2116 2
mmix_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
d2121 1
@


1.27
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1283 1
a1283 1
  /* Work out which section the relocation is targetted at and the
@


1.26
log
@	Support linker relaxation of new R_MMIX_PUSHJ_STUBBABLE relocs.
	* elf64-mmix.c (MAX_PUSHJ_STUB_SIZE): New macro.
	(struct _mmix_elf_section_data): New member pjs.
	(mmix_set_relaxable_size, mmix_elf_get_section_contents): New
	functions.
	(elf_mmix_howto_table): New entry for R_MMIX_PUSHJ_STUBBABLE.
	(mmix_reloc_map): Ditto.
	(mmix_elf_relocate_section): Handle R_MMIX_PUSHJ_STUBBABLE.
	(mmix_final_link_relocate, mmix_elf_check_common_relocs): Ditto.
	(mmix_elf_perform_relocation): Ditto.  Don't mark parameter addr
	unused.
	(mmix_elf_check_relocs): Move early return to after
	mmix_elf_check_common_relocs call.
	(mmix_elf_symbol_processing): Fix cut-and-pasto in head comment.
	(_bfd_mmix_before_linker_allocation): Rename from
	_bfd_mmix_prepare_linker_allocated_gregs.  All referers changed.
	Arrange to set the initial relaxable size of sections.
	(_bfd_mmix_after_linker_allocation): Rename from
	_bfd_mmix_finalize_linker_allocated_gregs.
	(mmix_elf_relax_section): Relax a R_MMIX_PUSHJ_STUBBABLE reloc.
	(bfd_elf64_get_section_contents): Define.
	* reloc.c: Add ENUMX for BFD_RELOC_MMIX_PUSHJ_STUBBABLE.
	* libbfd.h, bfd-in2.h: Regenerate.
@
text
@d1475 1
a1475 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.25
log
@Correct spelling of "relocatable".
@
text
@d24 4
a27 1
   - Linker relaxation.  */
d38 2
d57 18
d145 3
a147 3
       This is an approximation after _bfd_mmix_allocated_gregs_init and
       supposedly accurate after mmix_elf_relax_section is called for all
       incoming non-collected sections.  */
d228 9
d573 2
a574 1
     least significant bits are set.  The howto members reflect a simple
d790 14
d840 2
a841 1
    {BFD_RELOC_MMIX_LOCAL, R_MMIX_LOCAL}
d931 1
a931 1
     bfd_vma addr ATTRIBUTE_UNUSED;
d982 90
d1119 1
d1135 1
a1135 1
	      highbit = (1 << 24);
d1345 5
d1378 4
a1381 4
	  /* This is a relocatable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
d1393 69
d1599 1
a1885 3
  if (info->relocatable)
    return TRUE;

d1903 4
d1974 1
a1974 1
	     set up set up any hook that runs before GC.  */
d1978 4
d1985 17
a2018 3
  if (info->relocatable)
    return TRUE;

d2034 3
d2143 1
a2143 2
/* Handle the special MIPS section numbers that a symbol may use.
   This is used for both the 32-bit and the 64-bit ABI.  */
d2320 38
d2362 1
a2362 1
_bfd_mmix_prepare_linker_allocated_gregs (abfd, info)
d2373 5
d2441 1
a2441 1
_bfd_mmix_finalize_linker_allocated_gregs (abfd, link_info)
d2605 2
d2623 4
a2626 1
  size_t bpono;
d2629 6
d2641 2
a2642 2
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;
d2644 3
a2646 5
  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
d2650 4
a2653 2
      /* If no R_MMIX_BASE_PLUS_OFFSET relocs, then nothing to do.  */
      || bpodata == NULL)
a2658 2
  bpo_gregs_section = bpodata->bpo_greg_section;
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2660 8
a2667 1
  bpono = bpodata->first_base_plus_offset_reloc;
d2682 1
d2684 3
a2686 1
      if (ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_BASE_PLUS_OFFSET)
d2689 48
a2771 1
	  struct elf_link_hash_entry *h;
d2780 10
a2789 6
	      /* This appears to be a reference to an undefined symbol.
		 Just ignore it--it will be caught by the regular reloc
		 processing.  We need to keep BPO reloc accounting
		 consistent, though.  */
	      gregdata->n_remaining_bpo_relocs_this_relaxation_round--;
	      bpono++;
d2798 56
d2864 2
a2865 1
  if (gregdata->n_remaining_bpo_relocs_this_relaxation_round == 0)
d2937 12
d2959 47
d3054 1
@


1.24
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1232 1
a1232 1
      if (info->relocateable)
d1234 1
a1234 1
	  /* This is a relocateable link.  We don't have to change
d1672 1
a1672 1
  if (info->relocateable)
d1783 1
a1783 1
  if (info->relocateable)
d2355 1
a2355 1
  /* We don't have to do anything for a relocateable link, if
d2358 1
a2358 1
  if (link_info->relocateable
@


1.23
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d1857 3
a1859 3
	= _bfd_elf64_link_read_relocs (abfd, o, (PTR) NULL,
				       (Elf_Internal_Rela *) NULL,
				       info->keep_memory);
d2377 3
a2379 3
    = _bfd_elf64_link_read_relocs (abfd, sec, (PTR) NULL,
				   (Elf_Internal_Rela *) NULL,
				   link_info->keep_memory);
@


1.23.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1857 3
a1859 3
	= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL,
				     info->keep_memory);
d2377 3
a2379 3
    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				 (Elf_Internal_Rela *) NULL,
				 link_info->keep_memory);
@


1.22
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d55 1
a55 1
  ((struct _mmix_elf_section_data *) (sec)->used_by_bfd)
@


1.21
log
@	* bfd-in.h: Comment typo fix.  Formatting.
	* bfd-in2.h: Regenerate.
	* coff64-rs6000.c (xcoff64_openr_next_archived_file): Warning fix.
	* elf32-m68hc12.c (m68hc12_elf_set_mach_from_flags): Prototype.
	* elf64-mmix.c (mmix_dump_bpo_gregs): Warning fix.
@
text
@d2 1
a2 1
   Copyright 2001, 2002 Free Software Foundation, Inc.
d44 13
d58 1
a58 1
   this struct as elf_section_data (section)->tdata, which is otherwise
d99 1
a99 1
/* We attach this as elf_section_data (sec)->tdata in the linker-allocated
d151 3
d814 16
d1018 1
a1018 2
	  = (struct bpo_reloc_section_info *)
	  elf_section_data (isec)->tdata;
d1022 1
a1022 2
	  = (struct bpo_greg_section_info *)
	  elf_section_data (bpo_greg_section)->tdata;
d1606 1
a1606 2
    = (struct bpo_reloc_section_info *)
    elf_section_data (sec)->tdata;
d1615 1
a1615 3
  ((struct bpo_greg_section_info *)
   elf_section_data (allocated_gregs_section)->tdata)
    ->n_bpo_relocs
d1728 2
a1729 1
	      elf_section_data (allocated_gregs_section)->tdata = gregdata;
d1732 2
a1733 1
	    gregdata = elf_section_data (allocated_gregs_section)->tdata;
d1746 1
a1746 1
	      elf_section_data (sec)->tdata = bpodata;
d2116 1
a2116 2
  gregdata = (struct bpo_greg_section_info *)
    elf_section_data (bpo_gregs_section)->tdata;
d2194 1
a2194 2
  gregdata = (struct bpo_greg_section_info *)
    elf_section_data (bpo_gregs_section)->tdata;
d2290 1
a2290 2
  gregdata = (struct bpo_greg_section_info *)
    elf_section_data (bpo_gregs_section)->tdata;
d2342 1
a2342 2
    = (struct bpo_reloc_section_info *)
    elf_section_data (sec)->tdata;
d2371 1
a2371 2
  gregdata = (struct bpo_greg_section_info *)
    elf_section_data (bpo_gregs_section)->tdata;
d2587 1
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2284 2
a2285 2
	     gregdata->bpo_reloc_indexes != NULL
	     ? gregdata->bpo_reloc_indexes[i] : -1,
@


1.19
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d81 1
a81 1
       into the other members.  Is false only for BPO relocs in a GC:ed
d83 1
a83 1
    boolean valid;
d123 1
a123 1
static boolean mmix_elf_link_output_symbol_hook
d138 1
a138 1
static boolean mmix_elf_check_relocs
d142 1
a142 1
static boolean mmix_elf_check_common_relocs
d146 1
a146 1
static boolean mmix_elf_relocate_section
d154 1
a154 1
static boolean mmix_elf_gc_sweep_hook
d165 1
a165 1
static boolean mmix_elf_section_from_bfd_section
d168 1
a168 1
static boolean mmix_elf_add_symbol_hook
d172 1
a172 1
static boolean mmix_elf_is_local_label_name
d177 1
a177 1
static boolean mmix_elf_relax_section
d179 1
a179 1
	   boolean *again));
d181 1
a181 1
extern boolean mmix_elf_final_link PARAMS ((bfd *, struct bfd_link_info *));
d198 1
a198 1
	 false,			/* pc_relative */
d203 1
a203 1
	 false,			/* partial_inplace */
d206 1
a206 1
	 false),		/* pcrel_offset */
d213 1
a213 1
	 false,			/* pc_relative */
d218 1
a218 1
	 false,			/* partial_inplace */
d221 1
a221 1
	 false),		/* pcrel_offset */
d228 1
a228 1
	 false,			/* pc_relative */
d233 1
a233 1
	 false,			/* partial_inplace */
d236 1
a236 1
	 false),		/* pcrel_offset */
d243 1
a243 1
	 false,			/* pc_relative */
d248 1
a248 1
	 false,			/* partial_inplace */
d251 1
a251 1
	 false),		/* pcrel_offset */
d258 1
a258 1
	 false,			/* pc_relative */
d263 1
a263 1
	 false,			/* partial_inplace */
d266 1
a266 1
	 false),		/* pcrel_offset */
d273 1
a273 1
	 false,			/* pc_relative */
d278 1
a278 1
	 false,			/* partial_inplace */
d281 1
a281 1
	 false),		/* pcrel_offset */
d288 1
a288 1
	 true,			/* pc_relative */
d293 1
a293 1
	 false,			/* partial_inplace */
d296 1
a296 1
	 true),			/* pcrel_offset */
d303 1
a303 1
	 true,			/* pc_relative */
d308 1
a308 1
	 false,			/* partial_inplace */
d311 1
a311 1
	 true),			/* pcrel_offset */
d318 1
a318 1
	 true,			/* pc_relative */
d323 1
a323 1
	 false,			/* partial_inplace */
d326 1
a326 1
	 true),			/* pcrel_offset */
d333 1
a333 1
	 true,			/* pc_relative */
d338 1
a338 1
	 false,			/* partial_inplace */
d341 1
a341 1
	 true),			/* pcrel_offset */
d348 1
a348 1
	 true,			/* pc_relative */
d353 1
a353 1
	 false,			/* partial_inplace */
d356 1
a356 1
	 true),			/* pcrel_offset */
d363 1
a363 1
	 false,			/* pc_relative */
d368 1
a368 1
	 false,			/* partial_inplace */
d371 1
a371 1
	 true),			/* pcrel_offset */
d378 1
a378 1
	 false,			/* pc_relative */
d383 1
a383 1
	 false,			/* partial_inplace */
d386 1
a386 1
	 false),		/* pcrel_offset */
d396 1
a396 1
	 true,			/* pc_relative */
d401 1
a401 1
	 false,			/* partial_inplace */
d404 1
a404 1
	 true),			/* pcrel_offset */
d410 1
a410 1
	 true,			/* pc_relative */
d415 1
a415 1
	 false,			/* partial_inplace */
d418 1
a418 1
	 true),			/* pcrel_offset */
d424 1
a424 1
	 true,			/* pc_relative */
d429 1
a429 1
	 false,			/* partial_inplace */
d432 1
a432 1
	 true),			/* pcrel_offset */
d438 1
a438 1
	 true,			/* pc_relative */
d443 1
a443 1
	 false,			/* partial_inplace */
d446 1
a446 1
	 true),			/* pcrel_offset */
d456 1
a456 1
	 true,			/* pc_relative */
d461 1
a461 1
	 false,			/* partial_inplace */
d464 1
a464 1
	 true),		       	/* pcrel_offset */
d470 1
a470 1
	 true,			/* pc_relative */
d475 1
a475 1
	 false,			/* partial_inplace */
d478 1
a478 1
	 true),			/* pcrel_offset */
d484 1
a484 1
	 true,			/* pc_relative */
d489 1
a489 1
	 false,			/* partial_inplace */
d492 1
a492 1
	 true),			/* pcrel_offset */
d498 1
a498 1
	 true,			/* pc_relative */
d503 1
a503 1
	 false,			/* partial_inplace */
d506 1
a506 1
	 true),			/* pcrel_offset */
d512 1
a512 1
	 true,			/* pc_relative */
d517 1
a517 1
	 false,			/* partial_inplace */
d520 1
a520 1
	 true),			/* pcrel_offset */
d531 1
a531 1
	 true,			/* pc_relative */
d536 1
a536 1
	 false,			/* partial_inplace */
d539 1
a539 1
	 true),			/* pcrel_offset */
d545 1
a545 1
	 true,			/* pc_relative */
d550 1
a550 1
	 false,			/* partial_inplace */
d553 1
a553 1
	 true),			/* pcrel_offset */
d559 1
a559 1
	 true,			/* pc_relative */
d564 1
a564 1
	 false,			/* partial_inplace */
d567 1
a567 1
	 true),			/* pcrel_offset */
d573 1
a573 1
	 true,			/* pc_relative */
d578 1
a578 1
	 false,			/* partial_inplace */
d581 1
a581 1
	 true),			/* pcrel_offset */
d591 1
a591 1
	 true,			/* pc_relative */
d596 1
a596 1
	 false,			/* partial_inplace */
d599 1
a599 1
	 true),			/* pcrel_offset */
d605 1
a605 1
	 true,			/* pc_relative */
d610 1
a610 1
	 false,			/* partial_inplace */
d613 1
a613 1
	 true),			/* pcrel_offset */
d619 1
a619 1
	 true,			/* pc_relative */
d624 1
a624 1
	 false,			/* partial_inplace */
d627 1
a627 1
	 true),			/* pcrel_offset */
d633 1
a633 1
	 true,			/* pc_relative */
d638 1
a638 1
	 false,			/* partial_inplace */
d641 1
a641 1
	 true),			/* pcrel_offset */
d650 1
a650 1
	 true,			/* pc_relative */
d655 1
a655 1
	 false,			/* partial_inplace */
d658 1
a658 1
	 true),			/* pcrel_offset */
d665 1
a665 1
	 true,			/* pc_relative */
d670 1
a670 1
	 false,			/* partial_inplace */
d673 1
a673 1
	 true),			/* pcrel_offset */
d681 1
a681 1
	 false,			/* pc_relative */
d686 1
a686 1
	 false,			/* partial_inplace */
d689 1
a689 1
	 false),		/* pcrel_offset */
d696 1
a696 1
	 false,			/* pc_relative */
d701 1
a701 1
	 false,			/* partial_inplace */
d704 1
a704 1
	 false),		/* pcrel_offset */
d713 1
a713 1
	 false,			/* pc_relative */
d718 1
a718 1
	 false,			/* partial_inplace */
d721 1
a721 1
	 false),		/* pcrel_offset */
d732 1
a732 1
	 false,			/* pc_relative */
d737 1
a737 1
	 false,			/* partial_inplace */
d740 1
a740 1
	 false),		/* pcrel_offset */
d1160 1
a1160 1
static boolean
d1192 1
a1192 1
      boolean undefined_signalled = false;
d1268 3
a1270 3
			 input_section, rel->r_offset, true)))
		return false;
	      undefined_signalled = true;
d1281 1
a1281 1
	  boolean check_ok = true;
d1297 2
a1298 2
		   true);
	      undefined_signalled = true;
d1323 1
a1323 1
	    return false;
d1327 1
a1327 1
  return true;
d1568 1
a1568 1
static boolean
d1582 1
a1582 1
    return true;
d1591 1
a1591 1
  return true;
d1631 1
a1631 1
static boolean
d1646 1
a1646 1
    return true;
d1695 1
a1695 1
		return false;
d1700 1
a1700 1
		return false;
d1716 1
a1716 1
		return false;
d1737 1
a1737 1
  return true;
d1742 1
a1742 1
static boolean
d1755 1
a1755 1
    return true;
d1770 1
a1770 1
    return false;
d1790 1
a1790 1
            return false;
d1797 1
a1797 1
            return false;
d1802 1
a1802 1
  return true;
d1808 1
a1808 1
boolean
d1818 1
a1818 1
      boolean ok;
d1832 1
a1832 1
	return false;
d1840 1
a1840 1
	return false;
d1843 1
a1843 1
  return true;
d1850 1
a1850 1
static boolean
d1867 1
a1867 1
  return true;
d1916 1
a1916 1
static boolean
d1925 1
a1925 1
    return false;
d1927 1
a1927 1
  return true;
d1937 1
a1937 1
boolean
d1956 3
a1958 3
							    false,
							    false,
							    false);
d1969 1
a1969 1
	   return false;
d1973 1
a1973 1
  return true;
d1978 1
a1978 1
boolean
d1988 1
a1988 1
    return true;
d1991 1
a1991 1
    return false;
d1996 1
a1996 1
    return false;
d2000 1
a2000 1
    return false;
d2008 1
a2008 1
boolean
d2036 1
a2036 1
    return false;
d2051 1
a2051 1
	return false;
d2053 1
a2053 1
  return true;
d2059 1
a2059 1
boolean
d2077 1
a2077 1
    return true;
d2084 1
a2084 1
    return true;
d2090 1
a2090 1
    return false;
d2103 1
a2103 1
    return false;
d2119 1
a2119 1
    return false;
d2128 1
a2128 1
  return true;
d2134 1
a2134 1
boolean
d2152 1
a2152 1
    return true;
d2162 1
a2162 1
    return true;
d2169 1
a2169 1
    return false;
d2179 1
a2179 1
    return false;
d2193 1
a2193 1
      return false;
d2205 1
a2205 1
  return true;
d2303 1
a2303 1
static boolean
d2308 1
a2308 1
     boolean *again;
d2323 1
a2323 1
  *again = false;
d2340 1
a2340 1
    return true;
d2428 1
a2428 1
      gregdata->reloc_request[gregdata->bpo_reloc_indexes[bpono++]].valid = true;
d2461 1
a2461 1
	    *again = true;
d2487 1
a2487 1
	  *again = true;
d2508 1
a2508 1
  return true;
d2516 1
a2516 1
  return false;
@


1.18
log
@	* elf64-mmix.c (_bfd_mmix_finalize_linker_allocated_gregs):
	For bpo_gregs_section->contents, allocate _raw_size, not
	_cooked_size.
@
text
@d134 1
a134 1
  PARAMS ((bfd *, arelent *, Elf64_Internal_Rela *));
d1066 1
a1066 1
     Elf64_Internal_Rela *dst;
@


1.17
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d2173 3
d2177 1
a2177 1
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->_cooked_size);
@


1.17.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
d24 1
a24 4
   - "Traditional" linker relaxation (shrinking whole sections).
   - Merge reloc stubs jumping to same location.
   - GETA stub relaxation (call a stub for out of range new
     R_MMIX_GETA_STUBBABLE).  */
a34 2
#define MAX_PUSHJ_STUB_SIZE (5 * 4)

a43 31
struct _mmix_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct bpo_reloc_section_info *reloc;
    struct bpo_greg_section_info *greg;
  } bpo;

  struct pushj_stub_info
  {
    /* Maximum number of stubs needed for this section.  */
    bfd_size_type n_pushj_relocs;

    /* Size of stubs after a mmix_elf_relax_section round.  */
    bfd_size_type stubs_size_sum;

    /* Per-reloc stubs_size_sum information.  The stubs_size_sum member is the sum
       of these.  Allocated in mmix_elf_check_common_relocs.  */
    bfd_size_type *stub_size;

    /* Offset of next stub during relocation.  Somewhat redundant with the
       above: error coverage is easier and we don't have to reset the
       stubs_size_sum for relocation.  */
    bfd_size_type stub_offset;
  } pjs;
};

#define mmix_elf_section_data(sec) \
  ((struct _mmix_elf_section_data *) elf_section_data (sec))

d45 1
a45 1
   this struct as mmix_elf_section_data (section)->bpo, which is otherwise
d81 1
a81 1
       into the other members.  Is FALSE only for BPO relocs in a GC:ed
d83 1
a83 1
    bfd_boolean valid;
d86 1
a86 1
/* We attach this as mmix_elf_section_data (sec)->bpo in the linker-allocated
d109 3
a111 3
       This is an approximation after _bfd_mmix_before_linker_allocation
       and supposedly accurate after mmix_elf_relax_section is called for
       all incoming non-collected sections.  */
d123 3
a125 3
static bfd_boolean mmix_elf_link_output_symbol_hook
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d134 1
a134 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d138 1
a138 4
static bfd_boolean mmix_elf_new_section_hook
  PARAMS ((bfd *, asection *));

static bfd_boolean mmix_elf_check_relocs
d142 1
a142 1
static bfd_boolean mmix_elf_check_common_relocs
d146 1
a146 1
static bfd_boolean mmix_elf_relocate_section
d154 1
a154 1
static bfd_boolean mmix_elf_gc_sweep_hook
d165 1
a165 1
static bfd_boolean mmix_elf_section_from_bfd_section
d168 1
a168 1
static bfd_boolean mmix_elf_add_symbol_hook
d172 1
a172 1
static bfd_boolean mmix_elf_is_local_label_name
d177 1
a177 1
static bfd_boolean mmix_elf_relax_section
d179 1
a179 1
	   bfd_boolean *again));
d181 1
a181 1
extern bfd_boolean mmix_elf_final_link PARAMS ((bfd *, struct bfd_link_info *));
a188 9
static void
mmix_set_relaxable_size
  PARAMS ((bfd *, asection *, void *));

static bfd_boolean
mmix_elf_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));


d198 1
a198 1
	 FALSE,			/* pc_relative */
d203 1
a203 1
	 FALSE,			/* partial_inplace */
d206 1
a206 1
	 FALSE),		/* pcrel_offset */
d213 1
a213 1
	 FALSE,			/* pc_relative */
d218 1
a218 1
	 FALSE,			/* partial_inplace */
d221 1
a221 1
	 FALSE),		/* pcrel_offset */
d228 1
a228 1
	 FALSE,			/* pc_relative */
d233 1
a233 1
	 FALSE,			/* partial_inplace */
d236 1
a236 1
	 FALSE),		/* pcrel_offset */
d243 1
a243 1
	 FALSE,			/* pc_relative */
d248 1
a248 1
	 FALSE,			/* partial_inplace */
d251 1
a251 1
	 FALSE),		/* pcrel_offset */
d258 1
a258 1
	 FALSE,			/* pc_relative */
d263 1
a263 1
	 FALSE,			/* partial_inplace */
d266 1
a266 1
	 FALSE),		/* pcrel_offset */
d273 1
a273 1
	 FALSE,			/* pc_relative */
d278 1
a278 1
	 FALSE,			/* partial_inplace */
d281 1
a281 1
	 FALSE),		/* pcrel_offset */
d288 1
a288 1
	 TRUE,			/* pc_relative */
d293 1
a293 1
	 FALSE,			/* partial_inplace */
d296 1
a296 1
	 TRUE),			/* pcrel_offset */
d303 1
a303 1
	 TRUE,			/* pc_relative */
d308 1
a308 1
	 FALSE,			/* partial_inplace */
d311 1
a311 1
	 TRUE),			/* pcrel_offset */
d318 1
a318 1
	 TRUE,			/* pc_relative */
d323 1
a323 1
	 FALSE,			/* partial_inplace */
d326 1
a326 1
	 TRUE),			/* pcrel_offset */
d333 1
a333 1
	 TRUE,			/* pc_relative */
d338 1
a338 1
	 FALSE,			/* partial_inplace */
d341 1
a341 1
	 TRUE),			/* pcrel_offset */
d348 1
a348 1
	 TRUE,			/* pc_relative */
d353 1
a353 1
	 FALSE,			/* partial_inplace */
d356 1
a356 1
	 TRUE),			/* pcrel_offset */
d363 1
a363 1
	 FALSE,			/* pc_relative */
d368 1
a368 1
	 FALSE,			/* partial_inplace */
d371 1
a371 1
	 TRUE),			/* pcrel_offset */
d378 1
a378 1
	 FALSE,			/* pc_relative */
d383 1
a383 1
	 FALSE,			/* partial_inplace */
d386 1
a386 1
	 FALSE),		/* pcrel_offset */
d396 1
a396 1
	 TRUE,			/* pc_relative */
d401 1
a401 1
	 FALSE,			/* partial_inplace */
d404 1
a404 1
	 TRUE),			/* pcrel_offset */
d410 1
a410 1
	 TRUE,			/* pc_relative */
d415 1
a415 1
	 FALSE,			/* partial_inplace */
d418 1
a418 1
	 TRUE),			/* pcrel_offset */
d424 1
a424 1
	 TRUE,			/* pc_relative */
d429 1
a429 1
	 FALSE,			/* partial_inplace */
d432 1
a432 1
	 TRUE),			/* pcrel_offset */
d438 1
a438 1
	 TRUE,			/* pc_relative */
d443 1
a443 1
	 FALSE,			/* partial_inplace */
d446 1
a446 1
	 TRUE),			/* pcrel_offset */
d456 1
a456 1
	 TRUE,			/* pc_relative */
d461 1
a461 1
	 FALSE,			/* partial_inplace */
d464 1
a464 1
	 TRUE),		       	/* pcrel_offset */
d470 1
a470 1
	 TRUE,			/* pc_relative */
d475 1
a475 1
	 FALSE,			/* partial_inplace */
d478 1
a478 1
	 TRUE),			/* pcrel_offset */
d484 1
a484 1
	 TRUE,			/* pc_relative */
d489 1
a489 1
	 FALSE,			/* partial_inplace */
d492 1
a492 1
	 TRUE),			/* pcrel_offset */
d498 1
a498 1
	 TRUE,			/* pc_relative */
d503 1
a503 1
	 FALSE,			/* partial_inplace */
d506 1
a506 1
	 TRUE),			/* pcrel_offset */
d512 1
a512 1
	 TRUE,			/* pc_relative */
d517 1
a517 1
	 FALSE,			/* partial_inplace */
d520 1
a520 1
	 TRUE),			/* pcrel_offset */
d525 1
a525 2
     least significant bits are set.  It can also expand into a call to a
     stub; see R_MMIX_PUSHJ_STUBBABLE.  The howto members reflect a simple
d531 1
a531 1
	 TRUE,			/* pc_relative */
d536 1
a536 1
	 FALSE,			/* partial_inplace */
d539 1
a539 1
	 TRUE),			/* pcrel_offset */
d545 1
a545 1
	 TRUE,			/* pc_relative */
d550 1
a550 1
	 FALSE,			/* partial_inplace */
d553 1
a553 1
	 TRUE),			/* pcrel_offset */
d559 1
a559 1
	 TRUE,			/* pc_relative */
d564 1
a564 1
	 FALSE,			/* partial_inplace */
d567 1
a567 1
	 TRUE),			/* pcrel_offset */
d573 1
a573 1
	 TRUE,			/* pc_relative */
d578 1
a578 1
	 FALSE,			/* partial_inplace */
d581 1
a581 1
	 TRUE),			/* pcrel_offset */
d591 1
a591 1
	 TRUE,			/* pc_relative */
d596 1
a596 1
	 FALSE,			/* partial_inplace */
d599 1
a599 1
	 TRUE),			/* pcrel_offset */
d605 1
a605 1
	 TRUE,			/* pc_relative */
d610 1
a610 1
	 FALSE,			/* partial_inplace */
d613 1
a613 1
	 TRUE),			/* pcrel_offset */
d619 1
a619 1
	 TRUE,			/* pc_relative */
d624 1
a624 1
	 FALSE,			/* partial_inplace */
d627 1
a627 1
	 TRUE),			/* pcrel_offset */
d633 1
a633 1
	 TRUE,			/* pc_relative */
d638 1
a638 1
	 FALSE,			/* partial_inplace */
d641 1
a641 1
	 TRUE),			/* pcrel_offset */
d650 1
a650 1
	 TRUE,			/* pc_relative */
d655 1
a655 1
	 FALSE,			/* partial_inplace */
d658 1
a658 1
	 TRUE),			/* pcrel_offset */
d665 1
a665 1
	 TRUE,			/* pc_relative */
d670 1
a670 1
	 FALSE,			/* partial_inplace */
d673 1
a673 1
	 TRUE),			/* pcrel_offset */
d681 1
a681 1
	 FALSE,			/* pc_relative */
d686 1
a686 1
	 FALSE,			/* partial_inplace */
d689 1
a689 1
	 FALSE),		/* pcrel_offset */
d696 1
a696 1
	 FALSE,			/* pc_relative */
d701 1
a701 1
	 FALSE,			/* partial_inplace */
d704 1
a704 1
	 FALSE),		/* pcrel_offset */
d713 1
a713 1
	 FALSE,			/* pc_relative */
d718 1
a718 1
	 FALSE,			/* partial_inplace */
d721 1
a721 1
	 FALSE),		/* pcrel_offset */
d732 1
a732 1
	 FALSE,			/* pc_relative */
d737 1
a737 1
	 FALSE,			/* partial_inplace */
d740 1
a740 15
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MMIX_PUSHJ_STUBBABLE, /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_STUBBABLE", /* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */
d777 1
a777 2
    {BFD_RELOC_MMIX_LOCAL, R_MMIX_LOCAL},
    {BFD_RELOC_MMIX_PUSHJ_STUBBABLE, R_MMIX_PUSHJ_STUBBABLE}
a797 16
static bfd_boolean
mmix_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct _mmix_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct _mmix_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}

d851 1
a851 1
     bfd_vma addr;
a901 90
    case R_MMIX_PUSHJ_STUBBABLE:
      /* If the address fits, we're fine.  */
      if ((value & 3) == 0
	  /* Note rightshift 0; see R_MMIX_JMP case below.  */
	  && (r = bfd_check_overflow (complain_overflow_signed,
				      howto->bitsize,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      value)) == bfd_reloc_ok)
	goto pcrel_mmix_reloc_fits;
      else
	{
	  bfd_size_type raw_size
	    = (isec->_raw_size
	       - mmix_elf_section_data (isec)->pjs.n_pushj_relocs
	       * MAX_PUSHJ_STUB_SIZE);

	  /* We have the bytes at the PUSHJ insn and need to get the
	     position for the stub.  There's supposed to be room allocated
	     for the stub.  */
	  bfd_byte *stubcontents
	    = ((char *) datap
	       - (addr - (isec->output_section->vma + isec->output_offset))
	       + raw_size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);
	  bfd_vma stubaddr;

	  /* The address doesn't fit, so redirect the PUSHJ to the
	     location of the stub.  */
	  r = mmix_elf_perform_relocation (isec,
					   &elf_mmix_howto_table
					   [R_MMIX_ADDR19],
					   datap,
					   addr,
					   isec->output_section->vma
					   + isec->output_offset
					   + raw_size
					   + (mmix_elf_section_data (isec)
					      ->pjs.stub_offset)
					   - addr);
	  if (r != bfd_reloc_ok)
	    return r;

	  stubaddr
	    = (isec->output_section->vma
	       + isec->output_offset
	       + raw_size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);

	  /* We generate a simple JMP if that suffices, else the whole 5
	     insn stub.  */
	  if (bfd_check_overflow (complain_overflow_signed,
				  elf_mmix_howto_table[R_MMIX_ADDR27].bitsize,
				  0,
				  bfd_arch_bits_per_address (abfd),
				  addr + value - stubaddr) == bfd_reloc_ok)
	    {
	      bfd_put_32 (abfd, JMP_INSN_BYTE << 24, stubcontents);
	      r = mmix_elf_perform_relocation (isec,
					       &elf_mmix_howto_table
					       [R_MMIX_ADDR27],
					       stubcontents,
					       stubaddr,
					       value + addr - stubaddr);
	      mmix_elf_section_data (isec)->pjs.stub_offset += 4;

	      if (raw_size
		  + mmix_elf_section_data (isec)->pjs.stub_offset
		  > isec->_cooked_size)
		abort ();

	      return r;
	    }
	  else
	    {
	      /* Put a "GO $255,0" after the common sequence.  */
	      bfd_put_32 (abfd,
			  ((GO_INSN_BYTE | IMM_OFFSET_BIT) << 24)
			  | 0xff00, (bfd_byte *) stubcontents + 16);

	      /* Prepare for the general code to set the first part of the
		 linker stub, and */
	      value += addr;
	      datap = stubcontents;
	      mmix_elf_section_data (isec)->pjs.stub_offset
		+= MAX_PUSHJ_STUB_SIZE;
	    }
	}
      break;

a948 1
    pcrel_mmix_reloc_fits:
d964 1
a964 1
	      highbit = 1 << 24;
d986 2
a987 1
	  = mmix_elf_section_data (isec)->bpo.reloc;
d991 2
a992 1
	  = mmix_elf_section_data (bpo_greg_section)->bpo.greg;
d1066 1
a1066 1
     Elf_Internal_Rela *dst;
d1114 1
a1114 1
  /* Work out which section the relocation is targeted at and the
d1160 1
a1160 1
static bfd_boolean
a1175 5
  bfd_size_type raw_size
    = (input_section->_raw_size
       - mmix_elf_section_data (input_section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
  size_t pjsno = 0;
d1192 1
a1192 1
      bfd_boolean undefined_signalled = FALSE;
d1202 1
a1202 1
      if (info->relocatable)
d1204 4
a1207 4
	  /* This is a relocatable link.  For most relocs we don't have to
	     change anything, unless the reloc is against a section
	     symbol, in which case we have to adjust according to where
	     the section symbol winds up in the output section.  */
a1218 69
	  /* For PUSHJ stub relocs however, we may need to change the
	     reloc and the section contents, if the reloc doesn't reach
	     beyond the end of the output section and previous stubs.
	     Then we change the section contents to be a PUSHJ to the end
	     of the input section plus stubs (we can do that without using
	     a reloc), and then we change the reloc to be a R_MMIX_PUSHJ
	     at the stub location.  */
	  if (r_type == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* We've already checked whether we need a stub; use that
		 knowledge.  */
	      if (mmix_elf_section_data (input_section)->pjs.stub_size[pjsno]
		  != 0)
		{
		  Elf_Internal_Rela relcpy;

		  if (mmix_elf_section_data (input_section)
		      ->pjs.stub_size[pjsno] != MAX_PUSHJ_STUB_SIZE)
		    abort ();

		  /* There's already a PUSHJ insn there, so just fill in
		     the offset bits to the stub.  */
		  if (mmix_final_link_relocate (elf_mmix_howto_table
						+ R_MMIX_ADDR19,
						input_section,
						contents,
						rel->r_offset,
						0,
						input_section
						->output_section->vma
						+ input_section->output_offset
						+ raw_size
						+ mmix_elf_section_data (input_section)
						->pjs.stub_offset,
						NULL, NULL) != bfd_reloc_ok)
		    return FALSE;

		  /* Put a JMP insn at the stub; it goes with the
		     R_MMIX_JMP reloc.  */
		  bfd_put_32 (output_bfd, JMP_INSN_BYTE << 24,
			      contents
			      + raw_size
			      + mmix_elf_section_data (input_section)
			      ->pjs.stub_offset);

		  /* Change the reloc to be at the stub, and to a full
		     R_MMIX_JMP reloc.  */
		  rel->r_info = ELF64_R_INFO (r_symndx, R_MMIX_JMP);
		  rel->r_offset
		    = (raw_size
		       + mmix_elf_section_data (input_section)
		       ->pjs.stub_offset);

		  mmix_elf_section_data (input_section)->pjs.stub_offset
		    += MAX_PUSHJ_STUB_SIZE;

		  /* Shift this reloc to the end of the relocs to maintain
		     the r_offset sorted reloc order.  */
		  relcpy = *rel;
		  memmove (rel, rel + 1, (char *) relend - (char *) rel);
		  relend[-1] = relcpy;

		  /* Back up one reloc, or else we'd skip the next reloc
		   in turn.  */
		  rel--;
		}

	      pjsno++;
	    }
d1232 1
a1232 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1268 3
a1270 3
			 input_section, rel->r_offset, TRUE)))
		return FALSE;
	      undefined_signalled = TRUE;
d1281 1
a1281 1
	  bfd_boolean check_ok = TRUE;
d1297 2
a1298 2
		   TRUE);
	      undefined_signalled = TRUE;
d1323 1
a1323 1
	    return FALSE;
d1327 1
a1327 1
  return TRUE;
a1355 1
    case R_MMIX_PUSHJ_STUBBABLE:
d1568 1
a1568 1
static bfd_boolean
d1576 2
a1577 1
    = mmix_elf_section_data (sec)->bpo.reloc;
d1582 1
a1582 1
    return TRUE;
d1586 3
a1588 1
  mmix_elf_section_data (allocated_gregs_section)->bpo.greg->n_bpo_relocs
d1591 1
a1591 1
  return TRUE;
d1631 1
a1631 1
static bfd_boolean
d1645 3
a1664 4
	  /* We don't do anything with this reloc for a relocatable link.  */
	  if (info->relocatable)
	    break;

d1695 1
a1695 1
		return FALSE;
d1700 2
a1701 3
		return FALSE;
	      mmix_elf_section_data (allocated_gregs_section)->bpo.greg
		= gregdata;
d1704 1
a1704 2
	    gregdata
	      = mmix_elf_section_data (allocated_gregs_section)->bpo.greg;
d1716 2
a1717 2
		return FALSE;
	      mmix_elf_section_data (sec)->bpo.reloc = bpodata;
d1730 1
a1730 1
	     set up any hook that runs before GC.  */
a1733 4

	case R_MMIX_PUSHJ_STUBBABLE:
	  mmix_elf_section_data (sec)->pjs.n_pushj_relocs++;
	  break;
d1737 1
a1737 18
  /* Allocate per-reloc stub storage and initialize it to the max stub
     size.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs != 0)
    {
      size_t i;

      mmix_elf_section_data (sec)->pjs.stub_size
	= bfd_alloc (abfd, mmix_elf_section_data (sec)->pjs.n_pushj_relocs
		     * sizeof (mmix_elf_section_data (sec)
			       ->pjs.stub_size[0]));
      if (mmix_elf_section_data (sec)->pjs.stub_size == NULL)
	return FALSE;

      for (i = 0; i < mmix_elf_section_data (sec)->pjs.n_pushj_relocs; i++)
	mmix_elf_section_data (sec)->pjs.stub_size[i] = MAX_PUSHJ_STUB_SIZE;
    }

  return TRUE;
d1742 1
a1742 1
static bfd_boolean
d1754 3
d1770 1
a1770 4
    return FALSE;

  if (info->relocatable)
    return TRUE;
d1790 1
a1790 1
            return FALSE;
d1797 1
a1797 1
            return FALSE;
d1802 1
a1802 1
  return TRUE;
d1808 1
a1808 1
bfd_boolean
d1818 1
a1818 1
      bfd_boolean ok;
d1828 3
a1830 3
	= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL,
				     info->keep_memory);
d1832 1
a1832 1
	return FALSE;
d1840 1
a1840 1
	return FALSE;
d1843 1
a1843 1
  return TRUE;
d1850 3
a1852 2
static bfd_boolean
mmix_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
a1856 1
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
d1867 1
a1867 1
  return TRUE;
d1878 2
a1879 1
/* Handle the special section numbers that a symbol may use.  */
d1916 1
a1916 1
static bfd_boolean
d1925 1
a1925 1
    return FALSE;
d1927 1
a1927 1
  return TRUE;
d1937 1
a1937 1
bfd_boolean
d1956 3
a1958 3
							    FALSE,
							    FALSE,
							    FALSE);
d1969 1
a1969 1
	   return FALSE;
d1973 1
a1973 1
  return TRUE;
d1978 1
a1978 1
bfd_boolean
d1988 1
a1988 1
    return TRUE;
d1991 1
a1991 1
    return FALSE;
d1996 1
a1996 1
    return FALSE;
d2000 1
a2000 1
    return FALSE;
d2008 1
a2008 1
bfd_boolean
d2036 1
a2036 1
    return FALSE;
d2051 1
a2051 1
	return FALSE;
d2053 1
a2053 39
  return TRUE;
}

/* We need to include the maximum size of PUSHJ-stubs in the initial
   section size.  This is expected to shrink during linker relaxation.

   You might think that we should set *only* _cooked_size, but that won't
   work: section contents allocation will be using _raw_size in mixed
   format linking and not enough storage will be allocated.  FIXME: That's
   a major bug, including the name bfd_get_section_size_before_reloc; it
   should be bfd_get_section_size_before_relax.  The relaxation functions
   set _cooked size.  Relaxation happens before relocation.  All functions
   *after relaxation* should be using _cooked size.  */

static void
mmix_set_relaxable_size (abfd, sec, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     void *ptr;
{
  struct bfd_link_info *info = ptr;

  /* Make sure we only do this for section where we know we want this,
     otherwise we might end up resetting the size of COMMONs.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0)
    return;

  sec->_cooked_size
    = (sec->_raw_size
       + mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
  sec->_raw_size = sec->_cooked_size;

  /* For use in relocatable link, we start with a max stubs size.  See
     mmix_elf_relax_section.  */
  if (info->relocatable && sec->output_section)
    mmix_elf_section_data (sec->output_section)->pjs.stubs_size_sum
      += (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
	  * MAX_PUSHJ_STUB_SIZE);
d2059 2
a2060 2
bfd_boolean
_bfd_mmix_before_linker_allocation (abfd, info)
a2070 5
  bfd *ibfd;

  /* Set the initial size of sections.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    bfd_map_over_sections (ibfd, mmix_set_relaxable_size, info);
d2077 1
a2077 1
    return TRUE;
d2084 1
a2084 1
    return TRUE;
d2087 2
a2088 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2090 1
a2090 1
    return FALSE;
d2103 1
a2103 1
    return FALSE;
d2119 1
a2119 1
    return FALSE;
d2128 1
a2128 1
  return TRUE;
d2134 2
a2135 2
bfd_boolean
_bfd_mmix_after_linker_allocation (abfd, link_info)
d2152 1
a2152 1
    return TRUE;
d2162 1
a2162 1
    return TRUE;
d2166 2
a2167 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2169 1
a2169 1
    return FALSE;
a2172 3
  /* We need to have a _raw_size contents even though there's only
     _cooked_size worth of data, since the generic relocation machinery
     will allocate and copy that much temporarily.  */
d2174 1
a2174 1
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->_raw_size);
d2176 1
a2176 1
    return FALSE;
d2190 1
a2190 1
      return FALSE;
d2202 1
a2202 1
  return TRUE;
d2260 2
a2261 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2281 2
a2282 2
	     (gregdata->bpo_reloc_indexes != NULL
	      ? gregdata->bpo_reloc_indexes[i] : (size_t) -1),
a2297 2
   PUSHJ stub accounting is also done here.

d2300 1
a2300 1
static bfd_boolean
d2305 1
a2305 1
     bfd_boolean *again;
d2313 3
a2315 5
    = mmix_elf_section_data (sec)->bpo.reloc;
  /* The initialization is to quiet compiler warnings.  The value is to
     spot a missing actual initialization.  */
  size_t bpono = (size_t) -1;
  size_t pjsno = 0;
a2317 6
  bfd_size_type raw_size
    = (sec->_raw_size
       - mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);

  mmix_elf_section_data (sec)->pjs.stubs_size_sum = 0;
d2320 1
a2320 1
  *again = FALSE;
d2324 2
a2325 2
  if (sec->_cooked_size == 0 && sec->_raw_size != 0)
    abort ();
d2327 5
a2331 3
  /* We don't have to do anything if this section does not have relocs, or
     if this is not a code section.  */
  if ((sec->flags & SEC_RELOC) == 0
d2335 3
a2337 5
      /* If no R_MMIX_BASE_PLUS_OFFSET relocs and no PUSHJ-stub relocs,
         then nothing to do.  */
      || (bpodata == NULL
	  && mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0))
    return TRUE;
d2342 3
d2346 1
a2346 8
  if (bpodata != NULL)
    {
      bpo_gregs_section = bpodata->bpo_greg_section;
      gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
      bpono = bpodata->first_base_plus_offset_reloc;
    }
  else
    gregdata = NULL;
d2350 3
a2352 3
    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				 (Elf_Internal_Rela *) NULL,
				 link_info->keep_memory);
a2360 1
      struct elf_link_hash_entry *h = NULL;
d2362 1
a2362 3
      /* We only process two relocs.  */
      if (ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_BASE_PLUS_OFFSET
	  && ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_PUSHJ_STUBBABLE)
a2364 48
      /* We process relocs in a distinctly different way when this is a
	 relocatable link (for one, we don't look at symbols), so we avoid
	 mixing its code with that for the "normal" relaxation.  */
      if (link_info->relocatable)
	{
	  /* The only transformation in a relocatable link is to generate
	     a full stub at the location of the stub calculated for the
	     input section, if the relocated stub location, the end of the
	     output section plus earlier stubs, cannot be reached.  Thus
	     relocatable linking can only lead to worse code, but it still
	     works.  */
	  if (ELF64_R_TYPE (irel->r_info) == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* If we can reach the end of the output-section and beyond
		 any current stubs, then we don't need a stub for this
		 reloc.  The relaxed order of output stub allocation may
		 not exactly match the straightforward order, so we always
		 assume presence of output stubs, which will allow
		 relaxation only on relocations indifferent to the
		 presence of output stub allocations for other relocations
		 and thus the order of output stub allocation.  */
	      if (bfd_check_overflow (complain_overflow_signed,
				      19,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      /* Output-stub location.  */
				      sec->output_section->_cooked_size
				      + (mmix_elf_section_data (sec
							       ->output_section)
					 ->pjs.stubs_size_sum)
				      /* Location of this PUSHJ reloc.  */
				      - (sec->output_offset + irel->r_offset)
				      /* Don't count *this* stub twice.  */
				      - (mmix_elf_section_data (sec)
					 ->pjs.stub_size[pjsno]
					 + MAX_PUSHJ_STUB_SIZE))
		  == bfd_reloc_ok)
		mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;

	      mmix_elf_section_data (sec)->pjs.stubs_size_sum
		+= mmix_elf_section_data (sec)->pjs.stub_size[pjsno];

	      pjsno++;
	    }

	  continue;
	}

d2400 1
d2409 6
a2414 10
	      /* This appears to be a reference to an undefined symbol.  Just
		 ignore it--it will be caught by the regular reloc processing.
		 We need to keep BPO reloc accounting consistent, though
		 else we'll abort instead of emitting an error message.  */
	      if (ELF64_R_TYPE (irel->r_info) == R_MMIX_BASE_PLUS_OFFSET
		  && gregdata != NULL)
		{
		  gregdata->n_remaining_bpo_relocs_this_relaxation_round--;
		  bpono++;
		}
a2422 56
      if (ELF64_R_TYPE (irel->r_info) == (int) R_MMIX_PUSHJ_STUBBABLE)
	{
	  bfd_vma value = symval + irel->r_addend;
	  bfd_vma dot
	    = (sec->output_section->vma
	       + sec->output_offset
	       + irel->r_offset);
	  bfd_vma stubaddr
	    = (sec->output_section->vma
	       + sec->output_offset
	       + raw_size
	       + mmix_elf_section_data (sec)->pjs.stubs_size_sum);

	  if ((value & 3) == 0
	      && bfd_check_overflow (complain_overflow_signed,
				     19,
				     0,
				     bfd_arch_bits_per_address (abfd),
				     value - dot
				     - (value > dot
					? mmix_elf_section_data (sec)
					->pjs.stub_size[pjsno]
					: 0))
	      == bfd_reloc_ok)
	    /* If the reloc fits, no stub is needed.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;
	  else
	    /* Maybe we can get away with just a JMP insn?  */
	    if ((value & 3) == 0
		&& bfd_check_overflow (complain_overflow_signed,
				       27,
				       0,
				       bfd_arch_bits_per_address (abfd),
				       value - stubaddr
				       - (value > dot
					  ? mmix_elf_section_data (sec)
					  ->pjs.stub_size[pjsno] - 4
					  : 0))
		== bfd_reloc_ok)
	      /* Yep, account for a stub consisting of a single JMP insn.  */
	      mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 4;
	  else
	    /* Nope, go for the full insn stub.  It doesn't seem useful to
	       emit the intermediate sizes; those will only be useful for
	       a >64M program assuming contiguous code.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno]
	      = MAX_PUSHJ_STUB_SIZE;

	  mmix_elf_section_data (sec)->pjs.stubs_size_sum
	    += mmix_elf_section_data (sec)->pjs.stub_size[pjsno];
	  pjsno++;
	  continue;
	}

      /* We're looking at a R_MMIX_BASE_PLUS_OFFSET reloc.  */

d2425 1
a2425 1
      gregdata->reloc_request[gregdata->bpo_reloc_indexes[bpono++]].valid = TRUE;
d2433 1
a2433 2
  if (gregdata != NULL
      && gregdata->n_remaining_bpo_relocs_this_relaxation_round == 0)
d2458 1
a2458 1
	    *again = TRUE;
d2484 1
a2484 1
	  *again = TRUE;
d2505 1
a2505 13
  if (sec->_cooked_size
      < raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    abort ();

  if (sec->_cooked_size
      > raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    {
      sec->_cooked_size
	= raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum;
      *again = TRUE;
    }

  return TRUE;
d2513 1
a2513 47
  return FALSE;
}

/* Because we set _raw_size to include the max size of pushj stubs,
   i.e. larger than the actual section input size (see
   mmix_set_relaxable_raw_size), we have to take care of that when reading
   the section.  */

static bfd_boolean
mmix_elf_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     void *location;
     file_ptr offset;
     bfd_size_type count;
{
  bfd_size_type raw_size
    = (section->_raw_size
       - mmix_elf_section_data (section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);

  if (offset + count > section->_raw_size)
    {
      abort();
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Check bounds against the faked raw_size.  */
  if (offset + count > raw_size)
    {
      /* Clear the part in the faked area.  */
      memset (location + raw_size - offset, 0, count - (raw_size - offset));

      /* If there's no initial part within the "real" contents, we're
         done.  */
      if ((bfd_size_type) offset >= raw_size)
	return TRUE;

      /* Else adjust the count and fall through to call the generic
         function.  */
      count = raw_size - offset;
    }

  return
    _bfd_generic_get_section_contents (abfd, section, location, offset,
				       count);
a2514 1

a2559 1
#define bfd_elf64_new_section_hook	mmix_elf_new_section_hook
a2561 1
#define bfd_elf64_get_section_contents	mmix_elf_get_section_contents
@


1.17.12.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@a2172 3
  /* We need to have a _raw_size contents even though there's only
     _cooked_size worth of data, since the generic relocation machinery
     will allocate and copy that much temporarily.  */
d2174 1
a2174 1
    = contents = bfd_alloc (bpo_greg_owner, bpo_gregs_section->_raw_size);
@


1.17.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d81 1
a81 1
       into the other members.  Is FALSE only for BPO relocs in a GC:ed
d83 1
a83 1
    bfd_boolean valid;
d123 1
a123 1
static bfd_boolean mmix_elf_link_output_symbol_hook
d134 1
a134 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d138 1
a138 1
static bfd_boolean mmix_elf_check_relocs
d142 1
a142 1
static bfd_boolean mmix_elf_check_common_relocs
d146 1
a146 1
static bfd_boolean mmix_elf_relocate_section
d154 1
a154 1
static bfd_boolean mmix_elf_gc_sweep_hook
d165 1
a165 1
static bfd_boolean mmix_elf_section_from_bfd_section
d168 1
a168 1
static bfd_boolean mmix_elf_add_symbol_hook
d172 1
a172 1
static bfd_boolean mmix_elf_is_local_label_name
d177 1
a177 1
static bfd_boolean mmix_elf_relax_section
d179 1
a179 1
	   bfd_boolean *again));
d181 1
a181 1
extern bfd_boolean mmix_elf_final_link PARAMS ((bfd *, struct bfd_link_info *));
d198 1
a198 1
	 FALSE,			/* pc_relative */
d203 1
a203 1
	 FALSE,			/* partial_inplace */
d206 1
a206 1
	 FALSE),		/* pcrel_offset */
d213 1
a213 1
	 FALSE,			/* pc_relative */
d218 1
a218 1
	 FALSE,			/* partial_inplace */
d221 1
a221 1
	 FALSE),		/* pcrel_offset */
d228 1
a228 1
	 FALSE,			/* pc_relative */
d233 1
a233 1
	 FALSE,			/* partial_inplace */
d236 1
a236 1
	 FALSE),		/* pcrel_offset */
d243 1
a243 1
	 FALSE,			/* pc_relative */
d248 1
a248 1
	 FALSE,			/* partial_inplace */
d251 1
a251 1
	 FALSE),		/* pcrel_offset */
d258 1
a258 1
	 FALSE,			/* pc_relative */
d263 1
a263 1
	 FALSE,			/* partial_inplace */
d266 1
a266 1
	 FALSE),		/* pcrel_offset */
d273 1
a273 1
	 FALSE,			/* pc_relative */
d278 1
a278 1
	 FALSE,			/* partial_inplace */
d281 1
a281 1
	 FALSE),		/* pcrel_offset */
d288 1
a288 1
	 TRUE,			/* pc_relative */
d293 1
a293 1
	 FALSE,			/* partial_inplace */
d296 1
a296 1
	 TRUE),			/* pcrel_offset */
d303 1
a303 1
	 TRUE,			/* pc_relative */
d308 1
a308 1
	 FALSE,			/* partial_inplace */
d311 1
a311 1
	 TRUE),			/* pcrel_offset */
d318 1
a318 1
	 TRUE,			/* pc_relative */
d323 1
a323 1
	 FALSE,			/* partial_inplace */
d326 1
a326 1
	 TRUE),			/* pcrel_offset */
d333 1
a333 1
	 TRUE,			/* pc_relative */
d338 1
a338 1
	 FALSE,			/* partial_inplace */
d341 1
a341 1
	 TRUE),			/* pcrel_offset */
d348 1
a348 1
	 TRUE,			/* pc_relative */
d353 1
a353 1
	 FALSE,			/* partial_inplace */
d356 1
a356 1
	 TRUE),			/* pcrel_offset */
d363 1
a363 1
	 FALSE,			/* pc_relative */
d368 1
a368 1
	 FALSE,			/* partial_inplace */
d371 1
a371 1
	 TRUE),			/* pcrel_offset */
d378 1
a378 1
	 FALSE,			/* pc_relative */
d383 1
a383 1
	 FALSE,			/* partial_inplace */
d386 1
a386 1
	 FALSE),		/* pcrel_offset */
d396 1
a396 1
	 TRUE,			/* pc_relative */
d401 1
a401 1
	 FALSE,			/* partial_inplace */
d404 1
a404 1
	 TRUE),			/* pcrel_offset */
d410 1
a410 1
	 TRUE,			/* pc_relative */
d415 1
a415 1
	 FALSE,			/* partial_inplace */
d418 1
a418 1
	 TRUE),			/* pcrel_offset */
d424 1
a424 1
	 TRUE,			/* pc_relative */
d429 1
a429 1
	 FALSE,			/* partial_inplace */
d432 1
a432 1
	 TRUE),			/* pcrel_offset */
d438 1
a438 1
	 TRUE,			/* pc_relative */
d443 1
a443 1
	 FALSE,			/* partial_inplace */
d446 1
a446 1
	 TRUE),			/* pcrel_offset */
d456 1
a456 1
	 TRUE,			/* pc_relative */
d461 1
a461 1
	 FALSE,			/* partial_inplace */
d464 1
a464 1
	 TRUE),		       	/* pcrel_offset */
d470 1
a470 1
	 TRUE,			/* pc_relative */
d475 1
a475 1
	 FALSE,			/* partial_inplace */
d478 1
a478 1
	 TRUE),			/* pcrel_offset */
d484 1
a484 1
	 TRUE,			/* pc_relative */
d489 1
a489 1
	 FALSE,			/* partial_inplace */
d492 1
a492 1
	 TRUE),			/* pcrel_offset */
d498 1
a498 1
	 TRUE,			/* pc_relative */
d503 1
a503 1
	 FALSE,			/* partial_inplace */
d506 1
a506 1
	 TRUE),			/* pcrel_offset */
d512 1
a512 1
	 TRUE,			/* pc_relative */
d517 1
a517 1
	 FALSE,			/* partial_inplace */
d520 1
a520 1
	 TRUE),			/* pcrel_offset */
d531 1
a531 1
	 TRUE,			/* pc_relative */
d536 1
a536 1
	 FALSE,			/* partial_inplace */
d539 1
a539 1
	 TRUE),			/* pcrel_offset */
d545 1
a545 1
	 TRUE,			/* pc_relative */
d550 1
a550 1
	 FALSE,			/* partial_inplace */
d553 1
a553 1
	 TRUE),			/* pcrel_offset */
d559 1
a559 1
	 TRUE,			/* pc_relative */
d564 1
a564 1
	 FALSE,			/* partial_inplace */
d567 1
a567 1
	 TRUE),			/* pcrel_offset */
d573 1
a573 1
	 TRUE,			/* pc_relative */
d578 1
a578 1
	 FALSE,			/* partial_inplace */
d581 1
a581 1
	 TRUE),			/* pcrel_offset */
d591 1
a591 1
	 TRUE,			/* pc_relative */
d596 1
a596 1
	 FALSE,			/* partial_inplace */
d599 1
a599 1
	 TRUE),			/* pcrel_offset */
d605 1
a605 1
	 TRUE,			/* pc_relative */
d610 1
a610 1
	 FALSE,			/* partial_inplace */
d613 1
a613 1
	 TRUE),			/* pcrel_offset */
d619 1
a619 1
	 TRUE,			/* pc_relative */
d624 1
a624 1
	 FALSE,			/* partial_inplace */
d627 1
a627 1
	 TRUE),			/* pcrel_offset */
d633 1
a633 1
	 TRUE,			/* pc_relative */
d638 1
a638 1
	 FALSE,			/* partial_inplace */
d641 1
a641 1
	 TRUE),			/* pcrel_offset */
d650 1
a650 1
	 TRUE,			/* pc_relative */
d655 1
a655 1
	 FALSE,			/* partial_inplace */
d658 1
a658 1
	 TRUE),			/* pcrel_offset */
d665 1
a665 1
	 TRUE,			/* pc_relative */
d670 1
a670 1
	 FALSE,			/* partial_inplace */
d673 1
a673 1
	 TRUE),			/* pcrel_offset */
d681 1
a681 1
	 FALSE,			/* pc_relative */
d686 1
a686 1
	 FALSE,			/* partial_inplace */
d689 1
a689 1
	 FALSE),		/* pcrel_offset */
d696 1
a696 1
	 FALSE,			/* pc_relative */
d701 1
a701 1
	 FALSE,			/* partial_inplace */
d704 1
a704 1
	 FALSE),		/* pcrel_offset */
d713 1
a713 1
	 FALSE,			/* pc_relative */
d718 1
a718 1
	 FALSE,			/* partial_inplace */
d721 1
a721 1
	 FALSE),		/* pcrel_offset */
d732 1
a732 1
	 FALSE,			/* pc_relative */
d737 1
a737 1
	 FALSE,			/* partial_inplace */
d740 1
a740 1
	 FALSE),		/* pcrel_offset */
d1066 1
a1066 1
     Elf_Internal_Rela *dst;
d1160 1
a1160 1
static bfd_boolean
d1192 1
a1192 1
      bfd_boolean undefined_signalled = FALSE;
d1268 3
a1270 3
			 input_section, rel->r_offset, TRUE)))
		return FALSE;
	      undefined_signalled = TRUE;
d1281 1
a1281 1
	  bfd_boolean check_ok = TRUE;
d1297 2
a1298 2
		   TRUE);
	      undefined_signalled = TRUE;
d1323 1
a1323 1
	    return FALSE;
d1327 1
a1327 1
  return TRUE;
d1568 1
a1568 1
static bfd_boolean
d1582 1
a1582 1
    return TRUE;
d1591 1
a1591 1
  return TRUE;
d1631 1
a1631 1
static bfd_boolean
d1646 1
a1646 1
    return TRUE;
d1695 1
a1695 1
		return FALSE;
d1700 1
a1700 1
		return FALSE;
d1716 1
a1716 1
		return FALSE;
d1737 1
a1737 1
  return TRUE;
d1742 1
a1742 1
static bfd_boolean
d1755 1
a1755 1
    return TRUE;
d1770 1
a1770 1
    return FALSE;
d1790 1
a1790 1
            return FALSE;
d1797 1
a1797 1
            return FALSE;
d1802 1
a1802 1
  return TRUE;
d1808 1
a1808 1
bfd_boolean
d1818 1
a1818 1
      bfd_boolean ok;
d1832 1
a1832 1
	return FALSE;
d1840 1
a1840 1
	return FALSE;
d1843 1
a1843 1
  return TRUE;
d1850 1
a1850 1
static bfd_boolean
d1867 1
a1867 1
  return TRUE;
d1916 1
a1916 1
static bfd_boolean
d1925 1
a1925 1
    return FALSE;
d1927 1
a1927 1
  return TRUE;
d1937 1
a1937 1
bfd_boolean
d1956 3
a1958 3
							    FALSE,
							    FALSE,
							    FALSE);
d1969 1
a1969 1
	   return FALSE;
d1973 1
a1973 1
  return TRUE;
d1978 1
a1978 1
bfd_boolean
d1988 1
a1988 1
    return TRUE;
d1991 1
a1991 1
    return FALSE;
d1996 1
a1996 1
    return FALSE;
d2000 1
a2000 1
    return FALSE;
d2008 1
a2008 1
bfd_boolean
d2036 1
a2036 1
    return FALSE;
d2051 1
a2051 1
	return FALSE;
d2053 1
a2053 1
  return TRUE;
d2059 1
a2059 1
bfd_boolean
d2077 1
a2077 1
    return TRUE;
d2084 1
a2084 1
    return TRUE;
d2090 1
a2090 1
    return FALSE;
d2103 1
a2103 1
    return FALSE;
d2119 1
a2119 1
    return FALSE;
d2128 1
a2128 1
  return TRUE;
d2134 1
a2134 1
bfd_boolean
d2152 1
a2152 1
    return TRUE;
d2162 1
a2162 1
    return TRUE;
d2169 1
a2169 1
    return FALSE;
d2179 1
a2179 1
    return FALSE;
d2193 1
a2193 1
      return FALSE;
d2205 1
a2205 1
  return TRUE;
d2284 2
a2285 2
	     (gregdata->bpo_reloc_indexes != NULL
	      ? gregdata->bpo_reloc_indexes[i] : (size_t) -1),
d2303 1
a2303 1
static bfd_boolean
d2308 1
a2308 1
     bfd_boolean *again;
d2323 1
a2323 1
  *again = FALSE;
d2340 1
a2340 1
    return TRUE;
d2428 1
a2428 1
      gregdata->reloc_request[gregdata->bpo_reloc_indexes[bpono++]].valid = TRUE;
d2461 1
a2461 1
	    *again = TRUE;
d2487 1
a2487 1
	  *again = TRUE;
d2508 1
a2508 1
  return TRUE;
d2516 1
a2516 1
  return FALSE;
@


1.17.12.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.
a43 13
struct _mmix_elf_section_data
{
  struct bfd_elf_section_data elf;
  union
  {
    struct bpo_reloc_section_info *reloc;
    struct bpo_greg_section_info *greg;
  } bpo;
};

#define mmix_elf_section_data(sec) \
  ((struct _mmix_elf_section_data *) elf_section_data (sec))

d45 1
a45 1
   this struct as mmix_elf_section_data (section)->bpo, which is otherwise
d86 1
a86 1
/* We attach this as mmix_elf_section_data (sec)->bpo in the linker-allocated
a137 3
static bfd_boolean mmix_elf_new_section_hook
  PARAMS ((bfd *, asection *));

a797 16
static bfd_boolean
mmix_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct _mmix_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);

  sdata = (struct _mmix_elf_section_data *) bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;

  return _bfd_elf_new_section_hook (abfd, sec);
}

d986 2
a987 1
	  = mmix_elf_section_data (isec)->bpo.reloc;
d991 2
a992 1
	  = mmix_elf_section_data (bpo_greg_section)->bpo.greg;
d1576 2
a1577 1
    = mmix_elf_section_data (sec)->bpo.reloc;
d1586 3
a1588 1
  mmix_elf_section_data (allocated_gregs_section)->bpo.greg->n_bpo_relocs
d1701 1
a1701 2
	      mmix_elf_section_data (allocated_gregs_section)->bpo.greg
		= gregdata;
d1704 1
a1704 2
	    gregdata
	      = mmix_elf_section_data (allocated_gregs_section)->bpo.greg;
d1717 1
a1717 1
	      mmix_elf_section_data (sec)->bpo.reloc = bpodata;
d2087 2
a2088 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2166 2
a2167 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2263 2
a2264 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
d2316 2
a2317 1
    = mmix_elf_section_data (sec)->bpo.reloc;
d2346 2
a2347 1
  gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
a2562 1
#define bfd_elf64_new_section_hook	mmix_elf_new_section_hook
@


1.17.12.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1857 3
a1859 3
	= _bfd_elf_link_read_relocs (abfd, o, (PTR) NULL,
				     (Elf_Internal_Rela *) NULL,
				     info->keep_memory);
d2377 3
a2379 3
    = _bfd_elf_link_read_relocs (abfd, sec, (PTR) NULL,
				 (Elf_Internal_Rela *) NULL,
				 link_info->keep_memory);
@


1.17.12.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1232 1
a1232 1
      if (info->relocatable)
d1234 1
a1234 1
	  /* This is a relocatable link.  We don't have to change
d1672 1
a1672 1
  if (info->relocatable)
d1783 1
a1783 1
  if (info->relocatable)
d2355 1
a2355 1
  /* We don't have to do anything for a relocatable link, if
d2358 1
a2358 1
  if (link_info->relocatable
@


1.17.12.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d24 1
a24 4
   - "Traditional" linker relaxation (shrinking whole sections).
   - Merge reloc stubs jumping to same location.
   - GETA stub relaxation (call a stub for out of range new
     R_MMIX_GETA_STUBBABLE).  */
a34 2
#define MAX_PUSHJ_STUB_SIZE (5 * 4)

a51 18

  struct pushj_stub_info
  {
    /* Maximum number of stubs needed for this section.  */
    bfd_size_type n_pushj_relocs;

    /* Size of stubs after a mmix_elf_relax_section round.  */
    bfd_size_type stubs_size_sum;

    /* Per-reloc stubs_size_sum information.  The stubs_size_sum member is the sum
       of these.  Allocated in mmix_elf_check_common_relocs.  */
    bfd_size_type *stub_size;

    /* Offset of next stub during relocation.  Somewhat redundant with the
       above: error coverage is easier and we don't have to reset the
       stubs_size_sum for relocation.  */
    bfd_size_type stub_offset;
  } pjs;
d122 3
a124 3
       This is an approximation after _bfd_mmix_before_linker_allocation
       and supposedly accurate after mmix_elf_relax_section is called for
       all incoming non-collected sections.  */
a204 9
static void
mmix_set_relaxable_size
  PARAMS ((bfd *, asection *, void *));

static bfd_boolean
mmix_elf_get_section_contents
  PARAMS ((bfd *, sec_ptr, void *, file_ptr, bfd_size_type));


d541 1
a541 2
     least significant bits are set.  It can also expand into a call to a
     stub; see R_MMIX_PUSHJ_STUBBABLE.  The howto members reflect a simple
a756 14

  HOWTO (R_MMIX_PUSHJ_STUBBABLE, /* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mmix_elf_reloc,	/* special_function */
	 "R_MMIX_PUSHJ_STUBBABLE", /* name */
	 FALSE,			/* partial_inplace */
	 ~0x0100ffff,		/* src_mask */
	 0x0100ffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */
d793 1
a793 2
    {BFD_RELOC_MMIX_LOCAL, R_MMIX_LOCAL},
    {BFD_RELOC_MMIX_PUSHJ_STUBBABLE, R_MMIX_PUSHJ_STUBBABLE}
d883 1
a883 1
     bfd_vma addr;
a933 90
    case R_MMIX_PUSHJ_STUBBABLE:
      /* If the address fits, we're fine.  */
      if ((value & 3) == 0
	  /* Note rightshift 0; see R_MMIX_JMP case below.  */
	  && (r = bfd_check_overflow (complain_overflow_signed,
				      howto->bitsize,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      value)) == bfd_reloc_ok)
	goto pcrel_mmix_reloc_fits;
      else
	{
	  bfd_size_type raw_size
	    = (isec->_raw_size
	       - mmix_elf_section_data (isec)->pjs.n_pushj_relocs
	       * MAX_PUSHJ_STUB_SIZE);

	  /* We have the bytes at the PUSHJ insn and need to get the
	     position for the stub.  There's supposed to be room allocated
	     for the stub.  */
	  bfd_byte *stubcontents
	    = ((char *) datap
	       - (addr - (isec->output_section->vma + isec->output_offset))
	       + raw_size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);
	  bfd_vma stubaddr;

	  /* The address doesn't fit, so redirect the PUSHJ to the
	     location of the stub.  */
	  r = mmix_elf_perform_relocation (isec,
					   &elf_mmix_howto_table
					   [R_MMIX_ADDR19],
					   datap,
					   addr,
					   isec->output_section->vma
					   + isec->output_offset
					   + raw_size
					   + (mmix_elf_section_data (isec)
					      ->pjs.stub_offset)
					   - addr);
	  if (r != bfd_reloc_ok)
	    return r;

	  stubaddr
	    = (isec->output_section->vma
	       + isec->output_offset
	       + raw_size
	       + mmix_elf_section_data (isec)->pjs.stub_offset);

	  /* We generate a simple JMP if that suffices, else the whole 5
	     insn stub.  */
	  if (bfd_check_overflow (complain_overflow_signed,
				  elf_mmix_howto_table[R_MMIX_ADDR27].bitsize,
				  0,
				  bfd_arch_bits_per_address (abfd),
				  addr + value - stubaddr) == bfd_reloc_ok)
	    {
	      bfd_put_32 (abfd, JMP_INSN_BYTE << 24, stubcontents);
	      r = mmix_elf_perform_relocation (isec,
					       &elf_mmix_howto_table
					       [R_MMIX_ADDR27],
					       stubcontents,
					       stubaddr,
					       value + addr - stubaddr);
	      mmix_elf_section_data (isec)->pjs.stub_offset += 4;

	      if (raw_size
		  + mmix_elf_section_data (isec)->pjs.stub_offset
		  > isec->_cooked_size)
		abort ();

	      return r;
	    }
	  else
	    {
	      /* Put a "GO $255,0" after the common sequence.  */
	      bfd_put_32 (abfd,
			  ((GO_INSN_BYTE | IMM_OFFSET_BIT) << 24)
			  | 0xff00, (bfd_byte *) stubcontents + 16);

	      /* Prepare for the general code to set the first part of the
		 linker stub, and */
	      value += addr;
	      datap = stubcontents;
	      mmix_elf_section_data (isec)->pjs.stub_offset
		+= MAX_PUSHJ_STUB_SIZE;
	    }
	}
      break;

a980 1
    pcrel_mmix_reloc_fits:
d996 1
a996 1
	      highbit = 1 << 24;
a1205 5
  bfd_size_type raw_size
    = (input_section->_raw_size
       - mmix_elf_section_data (input_section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
  size_t pjsno = 0;
d1234 4
a1237 4
	  /* This is a relocatable link.  For most relocs we don't have to
	     change anything, unless the reloc is against a section
	     symbol, in which case we have to adjust according to where
	     the section symbol winds up in the output section.  */
a1248 69
	  /* For PUSHJ stub relocs however, we may need to change the
	     reloc and the section contents, if the reloc doesn't reach
	     beyond the end of the output section and previous stubs.
	     Then we change the section contents to be a PUSHJ to the end
	     of the input section plus stubs (we can do that without using
	     a reloc), and then we change the reloc to be a R_MMIX_PUSHJ
	     at the stub location.  */
	  if (r_type == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* We've already checked whether we need a stub; use that
		 knowledge.  */
	      if (mmix_elf_section_data (input_section)->pjs.stub_size[pjsno]
		  != 0)
		{
		  Elf_Internal_Rela relcpy;

		  if (mmix_elf_section_data (input_section)
		      ->pjs.stub_size[pjsno] != MAX_PUSHJ_STUB_SIZE)
		    abort ();

		  /* There's already a PUSHJ insn there, so just fill in
		     the offset bits to the stub.  */
		  if (mmix_final_link_relocate (elf_mmix_howto_table
						+ R_MMIX_ADDR19,
						input_section,
						contents,
						rel->r_offset,
						0,
						input_section
						->output_section->vma
						+ input_section->output_offset
						+ raw_size
						+ mmix_elf_section_data (input_section)
						->pjs.stub_offset,
						NULL, NULL) != bfd_reloc_ok)
		    return FALSE;

		  /* Put a JMP insn at the stub; it goes with the
		     R_MMIX_JMP reloc.  */
		  bfd_put_32 (output_bfd, JMP_INSN_BYTE << 24,
			      contents
			      + raw_size
			      + mmix_elf_section_data (input_section)
			      ->pjs.stub_offset);

		  /* Change the reloc to be at the stub, and to a full
		     R_MMIX_JMP reloc.  */
		  rel->r_info = ELF64_R_INFO (r_symndx, R_MMIX_JMP);
		  rel->r_offset
		    = (raw_size
		       + mmix_elf_section_data (input_section)
		       ->pjs.stub_offset);

		  mmix_elf_section_data (input_section)->pjs.stub_offset
		    += MAX_PUSHJ_STUB_SIZE;

		  /* Shift this reloc to the end of the relocs to maintain
		     the r_offset sorted reloc order.  */
		  relcpy = *rel;
		  memmove (rel, rel + 1, (char *) relend - (char *) rel);
		  relend[-1] = relcpy;

		  /* Back up one reloc, or else we'd skip the next reloc
		   in turn.  */
		  rel--;
		}

	      pjsno++;
	    }
d1262 1
a1262 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
a1385 1
    case R_MMIX_PUSHJ_STUBBABLE:
d1672 3
a1691 4
	  /* We don't do anything with this reloc for a relocatable link.  */
	  if (info->relocatable)
	    break;

d1759 1
a1759 1
	     set up any hook that runs before GC.  */
a1762 4

	case R_MMIX_PUSHJ_STUBBABLE:
	  mmix_elf_section_data (sec)->pjs.n_pushj_relocs++;
	  break;
a1765 17
  /* Allocate per-reloc stub storage and initialize it to the max stub
     size.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs != 0)
    {
      size_t i;

      mmix_elf_section_data (sec)->pjs.stub_size
	= bfd_alloc (abfd, mmix_elf_section_data (sec)->pjs.n_pushj_relocs
		     * sizeof (mmix_elf_section_data (sec)
			       ->pjs.stub_size[0]));
      if (mmix_elf_section_data (sec)->pjs.stub_size == NULL)
	return FALSE;

      for (i = 0; i < mmix_elf_section_data (sec)->pjs.n_pushj_relocs; i++)
	mmix_elf_section_data (sec)->pjs.stub_size[i] = MAX_PUSHJ_STUB_SIZE;
    }

d1783 3
a1800 3
  if (info->relocatable)
    return TRUE;

d1907 2
a1908 1
/* Handle the special section numbers that a symbol may use.  */
a2084 38
/* We need to include the maximum size of PUSHJ-stubs in the initial
   section size.  This is expected to shrink during linker relaxation.

   You might think that we should set *only* _cooked_size, but that won't
   work: section contents allocation will be using _raw_size in mixed
   format linking and not enough storage will be allocated.  FIXME: That's
   a major bug, including the name bfd_get_section_size_before_reloc; it
   should be bfd_get_section_size_before_relax.  The relaxation functions
   set _cooked size.  Relaxation happens before relocation.  All functions
   *after relaxation* should be using _cooked size.  */

static void
mmix_set_relaxable_size (abfd, sec, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     void *ptr;
{
  struct bfd_link_info *info = ptr;

  /* Make sure we only do this for section where we know we want this,
     otherwise we might end up resetting the size of COMMONs.  */
  if (mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0)
    return;

  sec->_cooked_size
    = (sec->_raw_size
       + mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);
  sec->_raw_size = sec->_cooked_size;

  /* For use in relocatable link, we start with a max stubs size.  See
     mmix_elf_relax_section.  */
  if (info->relocatable && sec->output_section)
    mmix_elf_section_data (sec->output_section)->pjs.stubs_size_sum
      += (mmix_elf_section_data (sec)->pjs.n_pushj_relocs
	  * MAX_PUSHJ_STUB_SIZE);
}

d2089 1
a2089 1
_bfd_mmix_before_linker_allocation (abfd, info)
a2099 5
  bfd *ibfd;

  /* Set the initial size of sections.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    bfd_map_over_sections (ibfd, mmix_set_relaxable_size, info);
d2163 1
a2163 1
_bfd_mmix_after_linker_allocation (abfd, link_info)
a2326 2
   PUSHJ stub accounting is also done here.

d2343 1
a2343 4
  /* The initialization is to quiet compiler warnings.  The value is to
     spot a missing actual initialization.  */
  size_t bpono = (size_t) -1;
  size_t pjsno = 0;
a2345 6
  bfd_size_type raw_size
    = (sec->_raw_size
       - mmix_elf_section_data (sec)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);

  mmix_elf_section_data (sec)->pjs.stubs_size_sum = 0;
d2352 2
a2353 2
  if (sec->_cooked_size == 0 && sec->_raw_size != 0)
    abort ();
d2355 5
a2359 3
  /* We don't have to do anything if this section does not have relocs, or
     if this is not a code section.  */
  if ((sec->flags & SEC_RELOC) == 0
d2363 2
a2364 4
      /* If no R_MMIX_BASE_PLUS_OFFSET relocs and no PUSHJ-stub relocs,
         then nothing to do.  */
      || (bpodata == NULL
	  && mmix_elf_section_data (sec)->pjs.n_pushj_relocs == 0))
d2370 2
d2373 1
a2373 8
  if (bpodata != NULL)
    {
      bpo_gregs_section = bpodata->bpo_greg_section;
      gregdata = mmix_elf_section_data (bpo_gregs_section)->bpo.greg;
      bpono = bpodata->first_base_plus_offset_reloc;
    }
  else
    gregdata = NULL;
a2387 1
      struct elf_link_hash_entry *h = NULL;
d2389 1
a2389 3
      /* We only process two relocs.  */
      if (ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_BASE_PLUS_OFFSET
	  && ELF64_R_TYPE (irel->r_info) != (int) R_MMIX_PUSHJ_STUBBABLE)
a2391 48
      /* We process relocs in a distinctly different way when this is a
	 relocatable link (for one, we don't look at symbols), so we avoid
	 mixing its code with that for the "normal" relaxation.  */
      if (link_info->relocatable)
	{
	  /* The only transformation in a relocatable link is to generate
	     a full stub at the location of the stub calculated for the
	     input section, if the relocated stub location, the end of the
	     output section plus earlier stubs, cannot be reached.  Thus
	     relocatable linking can only lead to worse code, but it still
	     works.  */
	  if (ELF64_R_TYPE (irel->r_info) == R_MMIX_PUSHJ_STUBBABLE)
	    {
	      /* If we can reach the end of the output-section and beyond
		 any current stubs, then we don't need a stub for this
		 reloc.  The relaxed order of output stub allocation may
		 not exactly match the straightforward order, so we always
		 assume presence of output stubs, which will allow
		 relaxation only on relocations indifferent to the
		 presence of output stub allocations for other relocations
		 and thus the order of output stub allocation.  */
	      if (bfd_check_overflow (complain_overflow_signed,
				      19,
				      0,
				      bfd_arch_bits_per_address (abfd),
				      /* Output-stub location.  */
				      sec->output_section->_cooked_size
				      + (mmix_elf_section_data (sec
							       ->output_section)
					 ->pjs.stubs_size_sum)
				      /* Location of this PUSHJ reloc.  */
				      - (sec->output_offset + irel->r_offset)
				      /* Don't count *this* stub twice.  */
				      - (mmix_elf_section_data (sec)
					 ->pjs.stub_size[pjsno]
					 + MAX_PUSHJ_STUB_SIZE))
		  == bfd_reloc_ok)
		mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;

	      mmix_elf_section_data (sec)->pjs.stubs_size_sum
		+= mmix_elf_section_data (sec)->pjs.stub_size[pjsno];

	      pjsno++;
	    }

	  continue;
	}

d2427 1
d2436 6
a2441 10
	      /* This appears to be a reference to an undefined symbol.  Just
		 ignore it--it will be caught by the regular reloc processing.
		 We need to keep BPO reloc accounting consistent, though
		 else we'll abort instead of emitting an error message.  */
	      if (ELF64_R_TYPE (irel->r_info) == R_MMIX_BASE_PLUS_OFFSET
		  && gregdata != NULL)
		{
		  gregdata->n_remaining_bpo_relocs_this_relaxation_round--;
		  bpono++;
		}
a2449 56
      if (ELF64_R_TYPE (irel->r_info) == (int) R_MMIX_PUSHJ_STUBBABLE)
	{
	  bfd_vma value = symval + irel->r_addend;
	  bfd_vma dot
	    = (sec->output_section->vma
	       + sec->output_offset
	       + irel->r_offset);
	  bfd_vma stubaddr
	    = (sec->output_section->vma
	       + sec->output_offset
	       + raw_size
	       + mmix_elf_section_data (sec)->pjs.stubs_size_sum);

	  if ((value & 3) == 0
	      && bfd_check_overflow (complain_overflow_signed,
				     19,
				     0,
				     bfd_arch_bits_per_address (abfd),
				     value - dot
				     - (value > dot
					? mmix_elf_section_data (sec)
					->pjs.stub_size[pjsno]
					: 0))
	      == bfd_reloc_ok)
	    /* If the reloc fits, no stub is needed.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 0;
	  else
	    /* Maybe we can get away with just a JMP insn?  */
	    if ((value & 3) == 0
		&& bfd_check_overflow (complain_overflow_signed,
				       27,
				       0,
				       bfd_arch_bits_per_address (abfd),
				       value - stubaddr
				       - (value > dot
					  ? mmix_elf_section_data (sec)
					  ->pjs.stub_size[pjsno] - 4
					  : 0))
		== bfd_reloc_ok)
	      /* Yep, account for a stub consisting of a single JMP insn.  */
	      mmix_elf_section_data (sec)->pjs.stub_size[pjsno] = 4;
	  else
	    /* Nope, go for the full insn stub.  It doesn't seem useful to
	       emit the intermediate sizes; those will only be useful for
	       a >64M program assuming contiguous code.  */
	    mmix_elf_section_data (sec)->pjs.stub_size[pjsno]
	      = MAX_PUSHJ_STUB_SIZE;

	  mmix_elf_section_data (sec)->pjs.stubs_size_sum
	    += mmix_elf_section_data (sec)->pjs.stub_size[pjsno];
	  pjsno++;
	  continue;
	}

      /* We're looking at a R_MMIX_BASE_PLUS_OFFSET reloc.  */

d2460 1
a2460 2
  if (gregdata != NULL
      && gregdata->n_remaining_bpo_relocs_this_relaxation_round == 0)
a2531 12
  if (sec->_cooked_size
      < raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    abort ();

  if (sec->_cooked_size
      > raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum)
    {
      sec->_cooked_size
	= raw_size + mmix_elf_section_data (sec)->pjs.stubs_size_sum;
      *again = TRUE;
    }

a2541 47

/* Because we set _raw_size to include the max size of pushj stubs,
   i.e. larger than the actual section input size (see
   mmix_set_relaxable_raw_size), we have to take care of that when reading
   the section.  */

static bfd_boolean
mmix_elf_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     void *location;
     file_ptr offset;
     bfd_size_type count;
{
  bfd_size_type raw_size
    = (section->_raw_size
       - mmix_elf_section_data (section)->pjs.n_pushj_relocs
       * MAX_PUSHJ_STUB_SIZE);

  if (offset + count > section->_raw_size)
    {
      abort();
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Check bounds against the faked raw_size.  */
  if (offset + count > raw_size)
    {
      /* Clear the part in the faked area.  */
      memset (location + raw_size - offset, 0, count - (raw_size - offset));

      /* If there's no initial part within the "real" contents, we're
         done.  */
      if ((bfd_size_type) offset >= raw_size)
	return TRUE;

      /* Else adjust the count and fall through to call the generic
         function.  */
      count = raw_size - offset;
    }

  return
    _bfd_generic_get_section_contents (abfd, section, location, offset,
				       count);
}

a2589 1
#define bfd_elf64_get_section_contents	mmix_elf_get_section_contents
@


1.17.12.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d160 2
a161 2
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d1283 1
a1283 1
  /* Work out which section the relocation is targeted at and the
d2116 2
a2117 1
mmix_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
a2121 1
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
@


1.16
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a2307 1
  Elf_Internal_Shdr *shndx_hdr;
a2308 1
  Elf_Internal_Rela *free_relocs = NULL;
d2317 1
a2317 3
  Elf64_External_Sym *extsyms = NULL;
  Elf64_External_Sym *free_extsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
a2339 1
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
a2354 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a2364 40
      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf64_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      /* Go get them off disk.  */
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf64_External_Sym);
	      extsyms = (Elf64_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	      symtab_hdr->contents = (bfd_byte *) extsyms;
	    }

	  /* If >64k sections, this presumable happens.  No test-case.  */
	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (bfd_byte *) shndx_buf;
	    }
	}

d2369 1
a2369 3
	  Elf64_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  Elf_Internal_Sym isym;
d2372 11
a2382 5
	  esym = extsyms + ELF64_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf
			       ? ELF64_R_SYM (irel->r_info) : 0);
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
d2384 2
a2385 1
	  if (isym.st_shndx == SHN_UNDEF)
d2387 1
a2387 1
	  else if (isym.st_shndx == SHN_ABS)
d2389 1
a2389 1
	  else if (isym.st_shndx == SHN_COMMON)
d2392 2
a2393 2
	    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
d2490 1
a2490 10
  if (free_relocs != NULL)
    free (free_relocs);

  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }

  if (free_extsyms != NULL)
d2493 2
d2496 2
a2497 2
	  symtab_hdr->contents = NULL;
	  free (free_extsyms);
d2501 4
d2508 5
a2512 13
  if (free_relocs != NULL)
    free (free_relocs);
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }
  if (free_extsyms != NULL)
    {
      symtab_hdr->contents = NULL;
      free (free_extsyms);
    }

@


1.15
log
@	* elf64-mmix.c (bpo_reloc_request_sort_fn): Use member
	bpo_reloc_no to break sort order ties, not address of items.
@
text
@d151 1
a151 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d1527 2
a1528 2
mmix_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d1558 1
a1558 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.14
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d2229 6
a2234 2
  /* As a last re-sort, use the address so we get a stable sort.  */
  return r1 > r2 ? 1 : (r1 < r2 ? -1 : 0);
@


1.13
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2422 2
a2423 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, &isym);
@


1.12
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2422 2
a2423 1
	  bfd_elf64_swap_symbol_in (abfd, esym, shndx, &isym);
@


1.11
log
@	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.
@
text
@d946 1
a946 1
      /* FALLTHROUGH. */
@


1.11.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d946 1
a946 1
      /* FALLTHROUGH.  */
d2229 2
a2230 6
  /* As a last re-sort, use the relocation number, so we get a stable
     sort.  The *addresses* aren't stable since items are swapped during
     sorting.  It depends on the qsort implementation if this actually
     happens.  */
  return r1->bpo_reloc_no > r2->bpo_reloc_no
    ? 1 : (r1->bpo_reloc_no < r2->bpo_reloc_no ? -1 : 0);
d2422 1
a2422 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
@


1.11.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d151 1
a151 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d1527 2
a1528 2
mmix_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d1558 3
a1560 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d2310 1
d2312 1
d2321 3
a2323 1
  Elf_Internal_Sym *isymbuf = NULL;
d2346 1
d2362 2
d2374 40
d2418 3
a2420 1
	  Elf_Internal_Sym *isym;
d2423 5
a2427 11
	  /* Read this BFD's local symbols if we haven't already.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }
d2429 1
a2429 2
	  isym = isymbuf + ELF64_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
d2431 1
a2431 1
	  else if (isym->st_shndx == SHN_ABS)
d2433 1
a2433 1
	  else if (isym->st_shndx == SHN_COMMON)
d2436 2
a2437 2
	    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
d2534 10
a2543 1
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
a2545 2
	free (isymbuf);
      else
d2547 2
a2548 2
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
a2551 4
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

d2555 13
a2567 5
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
@


1.11.4.1
log
@merge from trunk
@
text
@d946 1
a946 1
      /* FALLTHROUGH.  */
d2422 1
a2422 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    &isym);
@


1.11.4.2
log
@Merge with trunk.
@
text
@d2229 2
a2230 6
  /* As a last re-sort, use the relocation number, so we get a stable
     sort.  The *addresses* aren't stable since items are swapped during
     sorting.  It depends on the qsort implementation if this actually
     happens.  */
  return r1->bpo_reloc_no > r2->bpo_reloc_no
    ? 1 : (r1->bpo_reloc_no < r2->bpo_reloc_no ? -1 : 0);
@


1.10
log
@	* elf64-mmix.c (_bfd_mmix_finalize_linker_allocated_gregs): Check
	that base-plus-offset reloc accounting is consistent.
	(mmix_elf_relax_section): Keep base-plus-offset reloc accounting
	up to date for undefined symbols.
@
text
@d1956 5
a1960 5
      struct elf_link_hash_entry *h
	= (struct elf_link_hash_entry *) bfd_link_hash_lookup (info->hash,
							       *namep,
							       false,
							       false, false);
d1962 1
a1962 1
      if (h != NULL && h->root.type != bfd_link_hash_undefined)
d1965 1
a1965 1
	     h->root.u.def.section->owner is NULL.  */
@


1.10.2.1
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d1956 5
a1960 5
      struct bfd_link_hash_entry *h = bfd_link_hash_lookup (info->hash,
							    *namep,
							    false,
							    false,
							    false);
d1962 1
a1962 1
      if (h != NULL && h->type != bfd_link_hash_undefined)
d1965 1
a1965 1
	     h->u.def.section->owner is NULL.  */
@


1.9
log
@	* elf64-mmix.c (mmix_dump_bpo_gregs): New function.
	(mmix_elf_check_common_relocs) <case R_MMIX_BASE_PLUS_OFFSET>:
	Call bfd_get_section_by_name only once.  Initialize
	bpodata->n_bpo_relocs_this_section.
	(_bfd_mmix_prepare_linker_allocated_gregs): Remove comment
	referring to DSOs.
	(bpo_reloc_request_sort_fn): Don't use difference of values as
	return-value.
@
text
@d2180 15
a2304 1

d2448 6
a2453 3
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
@


1.8
log
@	Perform on-demand global register allocation from
	R_MMIX_BASE_PLUS_OFFSET relocs.
	* elf64-mmix.c (struct bpo_reloc_section_info, struct
	bpo_reloc_request, struct bpo_greg_section_info): New.
	(mmix_elf_check_common_relocs, mmix_elf_gc_sweep_hook,
	bpo_reloc_request_sort_fn, mmix_elf_relax_section,
	_bfd_mmix_check_all_relocs,
	_bfd_mmix_prepare_linker_allocated_gregs,
	_bfd_mmix_finalize_linker_allocated_gregs): New functions.
	(elf_mmix_howto_table): Correct src_mask for most relocs.
	(mmix_elf_perform_relocation) <case R_MMIX_BASE_PLUS_OFFSET>: New
	case.
	(mmix_final_link_relocate) <case R_MMIX_BASE_PLUS_OFFSET>: New
	case.  Fix typo in comment.  New label do_mmix_reloc.
	(mmix_elf_check_relocs): Abuse bfd_link_info member base_file to
	store first object file with a base-plus-offset reloc.  Call
	mmix_elf_check_common_relocs for the part common with mmo.
	(mmix_elf_final_link): Write out linker-allocated register
	contents section.
	(elf_backend_gc_sweep_hook): Define.
	(bfd_elf64_bfd_relax_section): Define.

	* mmo.c: Don't include <ctype.h>
	(mmo_init): Correct init-once logic.
@
text
@d185 4
d1673 5
a1677 3
	  allocated_gregs_section
	    = bfd_get_section_by_name (bpo_greg_owner,
				       MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME);
d1725 1
a2084 3
  /* This can't happen without DSO handling.  When DSOs are handled
     without any R_MMIX_BASE_PLUS_OFFSET seen, there will be no such
     section.  */
d2208 3
a2210 1
  /* Then sort on value.  */
d2212 1
a2212 1
    return r1->value - r2->value;
d2216 57
@


1.7
log
@Fixes for better translation into other languages
@
text
@d24 1
a24 2
   - Linker relaxation.
   - On-demand register allocation (from R_MMIX_BASE_PLUS_OFFSET).  */
d44 79
d142 4
d154 4
d175 6
d215 1
a215 1
	 0xff,			/* src_mask */
d230 1
a230 1
	 0xffff,		/* src_mask */
d245 1
a245 1
	 0xffffff,		/* src_mask */
d260 1
a260 1
	 0xffffffff,		/* src_mask */
d275 1
a275 1
	 MINUS_ONE,		/* src_mask */
d290 1
a290 1
	 0xff,			/* src_mask */
d305 1
a305 1
	 0xffff,		/* src_mask */
d320 1
a320 1
	 0xffffff,		/* src_mask */
d335 1
a335 1
	 0xffffffff,		/* src_mask */
d350 1
a350 1
	 MINUS_ONE,		/* src_mask */
d398 1
a398 1
	 0x0100ffff,		/* src_mask */
d412 1
a412 1
	 0x0100ffff,		/* src_mask */
d426 1
a426 1
	 0x0100ffff,		/* src_mask */
d440 1
a440 1
	 0x0100ffff,		/* src_mask */
d458 1
a458 1
	 0x0100ffff,		/* src_mask */
d472 1
a472 1
	 0x0100ffff,		/* src_mask */
d486 1
a486 1
	 0x0100ffff,		/* src_mask */
d500 1
a500 1
	 0x0100ffff,		/* src_mask */
d514 1
a514 1
	 0x0100ffff,		/* src_mask */
d533 1
a533 1
	 0x0100ffff,		/* src_mask */
d547 1
a547 1
	 0x0100ffff,		/* src_mask */
d561 1
a561 1
	 0x0100ffff,		/* src_mask */
d575 1
a575 1
	 0x0100ffff,		/* src_mask */
d593 1
a593 1
	 0x1ffffff,		/* src_mask */
d607 1
a607 1
	 0x1ffffff,		/* src_mask */
d621 1
a621 1
	 0x1ffffff,		/* src_mask */
d635 1
a635 1
	 0x1ffffff,		/* src_mask */
d652 1
a652 1
	 0x0100ffff,		/* src_mask */
d667 1
a667 1
	 0x1ffffff,		/* src_mask */
d683 1
a683 1
	 0xff,			/* src_mask */
d698 1
a698 1
	 0xff,			/* src_mask */
d715 1
a715 1
	 0xffff,		/* src_mask */
d969 1
a969 1
		      (in1 & ~howto->src_mask)
d979 42
d1368 26
d1427 1
a1427 1
	  /* Note: This is seperated out into two messages in order
d1444 1
d1560 31
d1627 108
d1763 4
d1780 1
a1780 1
        {
d1794 42
a1835 1
        }
d2033 434
d2468 16
d2510 2
d2531 1
@


1.6
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d1267 12
a1278 5
	  (*_bfd_error_handler)
	    (_("%s: register relocation against non-register symbol: %s in %s"),
	     bfd_get_filename (input_section->owner),
	     symname == NULL || *symname == 0 ? _("(unknown)") : symname,
	     bfd_get_section_name (symsec->owner, symsec));
@


1.5
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d80 1
a80 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, asection *, int *));
d1560 1
a1560 1
mmix_elf_section_from_bfd_section (abfd, hdr, sec, retval)
a1561 1
     Elf64_Internal_Shdr * hdr ATTRIBUTE_UNUSED;
@


1.4
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2001 Free Software Foundation, Inc.
a1669 2
      /* FIXME: This does not seem like the proper way to kill a section,
	 but it's the way it's done elsewhere, like elf64-alpha.c.  */
d1675 1
a1675 1
      *secpp = (*secpp)->next;
@


1.3
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1387 1
a1387 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.2
log
@Split file by ^L:s as in original submitted patch
@
text
@d1094 1
a1094 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.1
log
@Add MMIX support
@
text
@d1018 1
a1018 1

d1193 1
a1193 1

d1352 1
a1352 1

d1400 1
a1400 1

d1496 1
a1496 1

d1694 1
a1694 1

@

