head	1.42;
access;
symbols
	sid-snapshot-20180601:1.42
	sid-snapshot-20180501:1.42
	sid-snapshot-20180401:1.42
	sid-snapshot-20180301:1.42
	sid-snapshot-20180201:1.42
	sid-snapshot-20180101:1.42
	sid-snapshot-20171201:1.42
	sid-snapshot-20171101:1.42
	sid-snapshot-20171001:1.42
	sid-snapshot-20170901:1.42
	sid-snapshot-20170801:1.42
	sid-snapshot-20170701:1.42
	sid-snapshot-20170601:1.42
	sid-snapshot-20170501:1.42
	sid-snapshot-20170401:1.42
	sid-snapshot-20170301:1.42
	sid-snapshot-20170201:1.42
	sid-snapshot-20170101:1.42
	sid-snapshot-20161201:1.42
	sid-snapshot-20161101:1.42
	sid-snapshot-20160901:1.42
	sid-snapshot-20160801:1.42
	sid-snapshot-20160701:1.42
	sid-snapshot-20160601:1.42
	sid-snapshot-20160501:1.42
	sid-snapshot-20160401:1.42
	sid-snapshot-20160301:1.42
	sid-snapshot-20160201:1.42
	sid-snapshot-20160101:1.42
	sid-snapshot-20151201:1.42
	sid-snapshot-20151101:1.42
	sid-snapshot-20151001:1.42
	sid-snapshot-20150901:1.42
	sid-snapshot-20150801:1.42
	sid-snapshot-20150701:1.42
	sid-snapshot-20150601:1.42
	sid-snapshot-20150501:1.42
	sid-snapshot-20150401:1.42
	sid-snapshot-20150301:1.42
	sid-snapshot-20150201:1.42
	sid-snapshot-20150101:1.42
	sid-snapshot-20141201:1.42
	sid-snapshot-20141101:1.42
	sid-snapshot-20141001:1.42
	sid-snapshot-20140901:1.42
	sid-snapshot-20140801:1.42
	sid-snapshot-20140701:1.42
	sid-snapshot-20140601:1.42
	sid-snapshot-20140501:1.42
	sid-snapshot-20140401:1.42
	sid-snapshot-20140301:1.42
	sid-snapshot-20140201:1.42
	sid-snapshot-20140101:1.42
	sid-snapshot-20131201:1.42
	sid-snapshot-20131101:1.42
	sid-snapshot-20131001:1.42
	binutils-2_24-branch:1.42.0.8
	binutils-2_24-branchpoint:1.42
	binutils-2_21_1:1.40
	sid-snapshot-20130901:1.42
	gdb_7_6_1-2013-08-30-release:1.42
	sid-snapshot-20130801:1.42
	sid-snapshot-20130701:1.42
	sid-snapshot-20130601:1.42
	sid-snapshot-20130501:1.42
	gdb_7_6-2013-04-26-release:1.42
	sid-snapshot-20130401:1.42
	binutils-2_23_2:1.42
	gdb_7_6-branch:1.42.0.6
	gdb_7_6-2013-03-12-branchpoint:1.42
	sid-snapshot-20130301:1.42
	sid-snapshot-20130201:1.42
	sid-snapshot-20130101:1.42
	sid-snapshot-20121201:1.42
	gdb_7_5_1-2012-11-29-release:1.42
	binutils-2_23_1:1.42
	sid-snapshot-20121101:1.42
	binutils-2_23:1.42
	sid-snapshot-20121001:1.42
	sid-snapshot-20120901:1.42
	gdb_7_5-2012-08-17-release:1.42
	sid-snapshot-20120801:1.42
	binutils-2_23-branch:1.42.0.4
	binutils-2_23-branchpoint:1.42
	gdb_7_5-branch:1.42.0.2
	gdb_7_5-2012-07-18-branchpoint:1.42
	sid-snapshot-20120701:1.41
	sid-snapshot-20120601:1.41
	sid-snapshot-20120501:1.41
	binutils-2_22_branch:1.40.0.10
	gdb_7_4_1-2012-04-26-release:1.40
	sid-snapshot-20120401:1.41
	sid-snapshot-20120301:1.41
	sid-snapshot-20120201:1.40
	gdb_7_4-2012-01-24-release:1.40
	sid-snapshot-20120101:1.40
	gdb_7_4-branch:1.40.0.8
	gdb_7_4-2011-12-13-branchpoint:1.40
	sid-snapshot-20111201:1.40
	binutils-2_22:1.40
	sid-snapshot-20111101:1.40
	sid-snapshot-20111001:1.40
	binutils-2_22-branch:1.40.0.6
	binutils-2_22-branchpoint:1.40
	gdb_7_3_1-2011-09-04-release:1.40
	sid-snapshot-20110901:1.40
	sid-snapshot-20110801:1.40
	gdb_7_3-2011-07-26-release:1.40
	sid-snapshot-20110701:1.40
	sid-snapshot-20110601:1.40
	sid-snapshot-20110501:1.40
	gdb_7_3-branch:1.40.0.4
	gdb_7_3-2011-04-01-branchpoint:1.40
	sid-snapshot-20110401:1.40
	sid-snapshot-20110301:1.40
	sid-snapshot-20110201:1.40
	sid-snapshot-20110101:1.40
	binutils-2_21:1.40
	sid-snapshot-20101201:1.40
	binutils-2_21-branch:1.40.0.2
	binutils-2_21-branchpoint:1.40
	sid-snapshot-20101101:1.40
	sid-snapshot-20101001:1.40
	binutils-2_20_1:1.37
	gdb_7_2-2010-09-02-release:1.39
	sid-snapshot-20100901:1.40
	sid-snapshot-20100801:1.39
	gdb_7_2-branch:1.39.0.2
	gdb_7_2-2010-07-07-branchpoint:1.39
	sid-snapshot-20100701:1.39
	sid-snapshot-20100601:1.38
	sid-snapshot-20100501:1.38
	sid-snapshot-20100401:1.38
	gdb_7_1-2010-03-18-release:1.38
	sid-snapshot-20100301:1.38
	gdb_7_1-branch:1.38.0.2
	gdb_7_1-2010-02-18-branchpoint:1.38
	sid-snapshot-20100201:1.37
	sid-snapshot-20100101:1.37
	gdb_7_0_1-2009-12-22-release:1.37
	sid-snapshot-20091201:1.37
	sid-snapshot-20091101:1.37
	binutils-2_20:1.37
	gdb_7_0-2009-10-06-release:1.37
	sid-snapshot-20091001:1.37
	gdb_7_0-branch:1.37.0.34
	gdb_7_0-2009-09-16-branchpoint:1.37
	arc-sim-20090309:1.37
	binutils-arc-20081103-branch:1.37.0.32
	binutils-arc-20081103-branchpoint:1.37
	binutils-2_20-branch:1.37.0.30
	binutils-2_20-branchpoint:1.37
	sid-snapshot-20090901:1.37
	sid-snapshot-20090801:1.37
	msnyder-checkpoint-072509-branch:1.37.0.28
	msnyder-checkpoint-072509-branchpoint:1.37
	sid-snapshot-20090701:1.37
	dje-cgen-play1-branch:1.37.0.26
	dje-cgen-play1-branchpoint:1.37
	sid-snapshot-20090601:1.37
	sid-snapshot-20090501:1.37
	sid-snapshot-20090401:1.37
	arc-20081103-branch:1.37.0.24
	arc-20081103-branchpoint:1.37
	arc-insight_6_8-branch:1.37.0.22
	arc-insight_6_8-branchpoint:1.37
	insight_6_8-branch:1.37.0.20
	insight_6_8-branchpoint:1.37
	sid-snapshot-20090301:1.37
	binutils-2_19_1:1.37
	sid-snapshot-20090201:1.37
	sid-snapshot-20090101:1.37
	reverse-20081226-branch:1.37.0.18
	reverse-20081226-branchpoint:1.37
	sid-snapshot-20081201:1.37
	multiprocess-20081120-branch:1.37.0.16
	multiprocess-20081120-branchpoint:1.37
	sid-snapshot-20081101:1.37
	binutils-2_19:1.37
	sid-snapshot-20081001:1.37
	reverse-20080930-branch:1.37.0.14
	reverse-20080930-branchpoint:1.37
	binutils-2_19-branch:1.37.0.12
	binutils-2_19-branchpoint:1.37
	sid-snapshot-20080901:1.37
	sid-snapshot-20080801:1.37
	reverse-20080717-branch:1.37.0.10
	reverse-20080717-branchpoint:1.37
	sid-snapshot-20080701:1.37
	msnyder-reverse-20080609-branch:1.37.0.8
	msnyder-reverse-20080609-branchpoint:1.37
	drow-reverse-20070409-branch:1.35.0.2
	drow-reverse-20070409-branchpoint:1.35
	sid-snapshot-20080601:1.37
	sid-snapshot-20080501:1.37
	sid-snapshot-20080403:1.37
	sid-snapshot-20080401:1.37
	gdb_6_8-2008-03-27-release:1.37
	sid-snapshot-20080301:1.37
	gdb_6_8-branch:1.37.0.6
	gdb_6_8-2008-02-26-branchpoint:1.37
	sid-snapshot-20080201:1.37
	sid-snapshot-20080101:1.37
	sid-snapshot-20071201:1.37
	sid-snapshot-20071101:1.37
	gdb_6_7_1-2007-10-29-release:1.37
	gdb_6_7-2007-10-10-release:1.37
	sid-snapshot-20071001:1.37
	gdb_6_7-branch:1.37.0.4
	gdb_6_7-2007-09-07-branchpoint:1.37
	binutils-2_18:1.37
	binutils-2_18-branch:1.37.0.2
	binutils-2_18-branchpoint:1.37
	insight_6_6-20070208-release:1.34
	binutils-csl-coldfire-4_1-32:1.32
	binutils-csl-sourcerygxx-4_1-32:1.32
	gdb_6_6-2006-12-18-release:1.34
	binutils-csl-innovasic-fido-3_4_4-33:1.32
	binutils-csl-sourcerygxx-3_4_4-32:1.26
	binutils-csl-coldfire-4_1-30:1.32
	binutils-csl-sourcerygxx-4_1-30:1.32
	binutils-csl-coldfire-4_1-28:1.32
	binutils-csl-sourcerygxx-4_1-29:1.32
	binutils-csl-sourcerygxx-4_1-28:1.32
	gdb_6_6-branch:1.34.0.2
	gdb_6_6-2006-11-15-branchpoint:1.34
	binutils-csl-arm-2006q3-27:1.32
	binutils-csl-sourcerygxx-4_1-27:1.32
	binutils-csl-arm-2006q3-26:1.32
	binutils-csl-sourcerygxx-4_1-26:1.32
	binutils-csl-sourcerygxx-4_1-25:1.32
	binutils-csl-sourcerygxx-4_1-24:1.32
	binutils-csl-sourcerygxx-4_1-23:1.32
	insight_6_5-20061003-release:1.32
	gdb-csl-symbian-6_4_50_20060226-12:1.32
	binutils-csl-sourcerygxx-4_1-21:1.32
	binutils-csl-arm-2006q3-21:1.32
	binutils-csl-sourcerygxx-4_1-22:1.32
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.32
	binutils-csl-sourcerygxx-4_1-20:1.32
	binutils-csl-arm-2006q3-19:1.32
	binutils-csl-sourcerygxx-4_1-19:1.32
	binutils-csl-sourcerygxx-4_1-18:1.32
	binutils-csl-renesas-4_1-9:1.32
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	binutils-csl-sourcerygxx-3_4_4-25:1.26
	nickrob-async-20060828-mergepoint:1.32
	gdb-csl-symbian-6_4_50_20060226-11:1.32
	binutils-csl-renesas-4_1-8:1.32
	binutils-csl-renesas-4_1-7:1.32
	binutils-csl-renesas-4_1-6:1.32
	gdb-csl-sourcerygxx-4_1-17:1.32
	binutils-csl-sourcerygxx-4_1-17:1.32
	gdb-csl-20060226-branch-local-2:1.32
	gdb-csl-sourcerygxx-4_1-14:1.32
	binutils-csl-sourcerygxx-4_1-14:1.32
	binutils-csl-sourcerygxx-4_1-15:1.32
	gdb-csl-sourcerygxx-4_1-13:1.32
	binutils-csl-sourcerygxx-4_1-13:1.32
	binutils-2_17:1.32
	gdb-csl-sourcerygxx-4_1-12:1.32
	binutils-csl-sourcerygxx-4_1-12:1.32
	gdb-csl-sourcerygxx-3_4_4-21:1.32
	binutils-csl-sourcerygxx-3_4_4-21:1.32
	gdb_6_5-20060621-release:1.32
	binutils-csl-wrs-linux-3_4_4-24:1.26
	binutils-csl-wrs-linux-3_4_4-23:1.26
	gdb-csl-sourcerygxx-4_1-9:1.32
	binutils-csl-sourcerygxx-4_1-9:1.32
	gdb-csl-sourcerygxx-4_1-8:1.32
	binutils-csl-sourcerygxx-4_1-8:1.32
	gdb-csl-sourcerygxx-4_1-7:1.32
	binutils-csl-sourcerygxx-4_1-7:1.32
	gdb-csl-arm-2006q1-6:1.32
	binutils-csl-arm-2006q1-6:1.32
	gdb-csl-sourcerygxx-4_1-6:1.32
	binutils-csl-sourcerygxx-4_1-6:1.32
	binutils-csl-wrs-linux-3_4_4-22:1.26
	gdb-csl-symbian-6_4_50_20060226-10:1.32
	gdb-csl-symbian-6_4_50_20060226-9:1.32
	gdb-csl-symbian-6_4_50_20060226-8:1.32
	gdb-csl-coldfire-4_1-11:1.32
	binutils-csl-coldfire-4_1-11:1.32
	gdb-csl-sourcerygxx-3_4_4-19:1.32
	binutils-csl-sourcerygxx-3_4_4-19:1.32
	gdb-csl-coldfire-4_1-10:1.32
	gdb_6_5-branch:1.32.0.28
	gdb_6_5-2006-05-14-branchpoint:1.32
	binutils-csl-coldfire-4_1-10:1.32
	gdb-csl-sourcerygxx-4_1-5:1.32
	binutils-csl-sourcerygxx-4_1-5:1.32
	nickrob-async-20060513-branch:1.32.0.26
	nickrob-async-20060513-branchpoint:1.32
	gdb-csl-sourcerygxx-4_1-4:1.32
	binutils-csl-sourcerygxx-4_1-4:1.32
	msnyder-reverse-20060502-branch:1.32.0.24
	msnyder-reverse-20060502-branchpoint:1.32
	binutils-csl-wrs-linux-3_4_4-21:1.26
	gdb-csl-morpho-4_1-4:1.32
	binutils-csl-morpho-4_1-4:1.32
	gdb-csl-sourcerygxx-3_4_4-17:1.32
	binutils-csl-sourcerygxx-3_4_4-17:1.32
	binutils-csl-wrs-linux-3_4_4-20:1.26
	readline_5_1-import-branch:1.32.0.22
	readline_5_1-import-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.32
	binutils-2_17-branch:1.32.0.20
	binutils-2_17-branchpoint:1.32
	gdb-csl-symbian-20060226-branch:1.32.0.18
	gdb-csl-symbian-20060226-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.32
	msnyder-reverse-20060331-branch:1.32.0.16
	msnyder-reverse-20060331-branchpoint:1.32
	binutils-csl-2_17-branch:1.32.0.14
	binutils-csl-2_17-branchpoint:1.32
	gdb-csl-available-20060303-branch:1.32.0.12
	gdb-csl-available-20060303-branchpoint:1.32
	gdb-csl-20060226-branch:1.32.0.10
	gdb-csl-20060226-branchpoint:1.32
	gdb_6_4-20051202-release:1.32
	msnyder-fork-checkpoint-branch:1.32.0.8
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.32.0.4
	gdb_6_4-2005-11-01-branchpoint:1.32
	gdb-csl-arm-20051020-branch:1.32.0.2
	gdb-csl-arm-20051020-branchpoint:1.32
	binutils-csl-gxxpro-3_4-branch:1.26.0.14
	binutils-csl-gxxpro-3_4-branchpoint:1.26
	binutils-2_16_1:1.26
	msnyder-tracepoint-checkpoint-branch:1.29.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.29
	gdb-csl-arm-20050325-2005-q1b:1.26
	binutils-csl-arm-2005q1b:1.26
	binutils-2_16:1.26
	gdb-csl-arm-20050325-2005-q1a:1.26
	binutils-csl-arm-2005q1a:1.26
	csl-arm-20050325-branch:1.26.0.12
	csl-arm-20050325-branchpoint:1.26
	binutils-csl-arm-2005q1-branch:1.26.0.10
	binutils-csl-arm-2005q1-branchpoint:1.26
	binutils-2_16-branch:1.26.0.8
	binutils-2_16-branchpoint:1.26
	csl-arm-2004-q3d:1.26
	gdb_6_3-20041109-release:1.26
	gdb_6_3-branch:1.26.0.4
	gdb_6_3-20041019-branchpoint:1.26
	csl-arm-2004-q3:1.26
	drow_intercu-merge-20040921:1.26
	drow_intercu-merge-20040915:1.26
	jimb-gdb_6_2-e500-branch:1.26.0.6
	jimb-gdb_6_2-e500-branchpoint:1.26
	gdb_6_2-20040730-release:1.26
	gdb_6_2-branch:1.26.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.26
	gdb_6_1_1-20040616-release:1.25
	binutils-2_15:1.25
	binutils-2_15-branchpoint:1.25
	csl-arm-2004-q1a:1.25
	csl-arm-2004-q1:1.25
	gdb_6_1-2004-04-05-release:1.25
	drow_intercu-merge-20040402:1.25
	drow_intercu-merge-20040327:1.25
	ezannoni_pie-20040323-branch:1.25.0.14
	ezannoni_pie-20040323-branchpoint:1.25
	cagney_tramp-20040321-mergepoint:1.25
	cagney_tramp-20040309-branch:1.25.0.12
	cagney_tramp-20040309-branchpoint:1.25
	gdb_6_1-branch:1.25.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	drow_intercu-20040221-branch:1.25.0.8
	drow_intercu-20040221-branchpoint:1.25
	binutils-2_15-branch:1.25.0.6
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	drow-cplus-merge-20040208:1.25
	carlton_dictionary-20040126-merge:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	drow-cplus-merge-20040113:1.25
	csl-arm-2003-q4:1.25
	drow-cplus-merge-20031224:1.25
	drow-cplus-merge-20031220:1.25
	carlton_dictionary-20031215-merge:1.25
	drow-cplus-merge-20031214:1.25
	carlton-dictionary-20031111-merge:1.24
	gdb_6_0-2003-10-04-release:1.19
	kettenis_sparc-20030918-branch:1.22.0.4
	kettenis_sparc-20030918-branchpoint:1.22
	carlton_dictionary-20030917-merge:1.22
	ezannoni_pie-20030916-branchpoint:1.22
	ezannoni_pie-20030916-branch:1.22.0.2
	cagney_x86i386-20030821-branch:1.21.0.2
	cagney_x86i386-20030821-branchpoint:1.21
	carlton_dictionary-20030805-merge:1.21
	carlton_dictionary-20030627-merge:1.20
	gdb_6_0-branch:1.19.0.14
	gdb_6_0-2003-06-23-branchpoint:1.19
	jimb-ppc64-linux-20030613-branch:1.19.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.19
	binutils-2_14:1.18
	cagney_convert-20030606-branch:1.19.0.10
	cagney_convert-20030606-branchpoint:1.19
	cagney_writestrings-20030508-branch:1.19.0.8
	cagney_writestrings-20030508-branchpoint:1.19
	jimb-ppc64-linux-20030528-branch:1.19.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.19
	carlton_dictionary-20030523-merge:1.19
	cagney_fileio-20030521-branch:1.19.0.4
	cagney_fileio-20030521-branchpoint:1.19
	kettenis_i386newframe-20030517-mergepoint:1.19
	jimb-ppc64-linux-20030509-branch:1.19.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.19
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	binutils-2_14-branch:1.18.0.2
	binutils-2_14-branchpoint:1.18
	kettenis_i386newframe-20030419-branch:1.16.0.4
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.2
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.16
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.14
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.12
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.10
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.8
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.6
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.15
	interps-20030202-branch:1.15.0.4
	interps-20030202-branchpoint:1.15
	cagney-unwind-20030108-branch:1.15.0.2
	cagney-unwind-20030108-branchpoint:1.15
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.15
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.12
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.12
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.10
	carlton_dictionary-20020920-branchpoint:1.9
	sid-20020905-branchpoint:1.9
	sid-20020905-branch:1.9.0.8
	gdb_5_3-branch:1.9.0.6
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.4
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.2
	readline_4_3-import-branchpoint:1.9
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.18
	kseitz_interps-20020528-branch:1.3.0.16
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.14
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.12
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.10
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.8
	binutils-2_12-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	binutils-2_11_2:1.2.2.1
	binutils-2_11_1:1.2.2.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.2
	insight-precleanup-2001-01-01:1.2
	binutils_latest_snapshot:1.42;
locks; strict;
comment	@ * @;


1.42
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2012.02.13.02.29.51;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.25.14.53.42;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.08.00.26.44;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.07.13.22.48;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.04.15.53.16;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.24.04.46.20;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches
	1.25.8.1;
next	1.24;

1.24
date	2003.10.04.21.02.53;	author ciceron;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.06.20.55.50;	author ciceron;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.25.14.35.55;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.26.11.53.36;	author ciceron;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.21.13.22.14;	author ciceron;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.04.21.17.06;	author ciceron;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2002.12.01.13.24.03;	author ciceron;	state Exp;
branches
	1.15.16.1;
next	1.14;

1.14
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.17.02.59.15;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.12.14.00.55;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.12.13.35.25;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.22.05.41.53;	author amodra;	state Exp;
branches
	1.9.10.1
	1.9.12.1;
next	1.8;

1.8
date	2002.08.14.08.14.30;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.13.21.15.47;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.13.21.04.21;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.13.20.56.59;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.13.20.43.01;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.08.21.03.59;	author nickc;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	2000.12.06.18.59.48;	author kazu;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	;

1.25.8.1
date	2004.09.16.17.00.24;	author drow;	state Exp;
branches;
next	;

1.16.4.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2003.05.18.09.43.41;	author kettenis;	state Exp;
branches;
next	;

1.15.16.1
date	2003.04.10.21.33.44;	author cagney;	state Exp;
branches;
next	;

1.9.10.1
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.12.23.19.37.42;	author carlton;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2003.05.01.00.46.40;	author carlton;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2003.05.23.18.40.23;	author carlton;	state Exp;
branches;
next	1.9.10.6;

1.9.10.6
date	2003.06.27.21.49.15;	author carlton;	state Exp;
branches;
next	1.9.10.7;

1.9.10.7
date	2003.08.05.17.12.46;	author carlton;	state Exp;
branches;
next	1.9.10.8;

1.9.10.8
date	2003.09.17.21.27.51;	author carlton;	state Exp;
branches;
next	1.9.10.9;

1.9.10.9
date	2003.11.11.23.50.17;	author carlton;	state Exp;
branches;
next	1.9.10.10;

1.9.10.10
date	2003.12.15.23.59.25;	author carlton;	state Exp;
branches;
next	;

1.9.12.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.9.12.2;

1.9.12.2
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	;

1.3.16.1
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.2.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.42
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@/* Motorola 68HC11-specific support for 32-bit ELF
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010, 2012
   Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@nerim.fr)
   (Heavily copied from the D10V port by Martin Hunt (hunt@@cygnus.com))

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf32-m68hc1x.h"
#include "elf/m68hc11.h"
#include "opcode/m68hc11.h"

/* Relocation functions.  */
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void m68hc11_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);

/* Trampoline generation.  */
static bfd_boolean m68hc11_elf_size_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static bfd_boolean m68hc11_elf_build_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static struct bfd_link_hash_table* m68hc11_elf_bfd_link_hash_table_create
  (bfd* abfd);

/* Linker relaxation.  */
static bfd_boolean m68hc11_elf_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
static void m68hc11_elf_relax_delete_bytes
  (bfd *, asection *, bfd_vma, int);
static void m68hc11_relax_group
  (bfd *, asection *, bfd_byte *, unsigned, unsigned long, unsigned long);
static int compare_reloc (const void *, const void *);

/* Use REL instead of RELA to save space */
#define USE_REL	1

/* The Motorola 68HC11 microcontroller only addresses 64Kb but we also
   support a memory bank switching mechanism similar to 68HC12.
   We must handle 8 and 16-bit relocations.  The 32-bit relocation
   are used for debugging sections (DWARF2) to represent a virtual
   address.
   The 3-bit and 16-bit PC rel relocation is only used by 68HC12.  */
static reloc_howto_type elf_m68hc11_howto_table[] = {
  /* This reloc does nothing.  */
  HOWTO (R_M68HC11_NONE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_NONE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation */
  HOWTO (R_M68HC11_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation (upper address) */
  HOWTO (R_M68HC11_HI8,		/* type */
	 8,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_HI8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit absolute relocation (upper address) */
  HOWTO (R_M68HC11_LO8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_LO8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 8 bit PC-rel relocation */
  HOWTO (R_M68HC11_PCREL_8,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_PCREL_8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* A 16 bit absolute relocation */
  HOWTO (R_M68HC11_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont /*bitfield */ ,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit absolute relocation.  This one is never used for the
     code relocation.  It's used by gas for -gstabs generation.  */
  HOWTO (R_M68HC11_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 3 bit absolute relocation */
  HOWTO (R_M68HC11_3B,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 3,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_4B",	/* name */
	 FALSE,			/* partial_inplace */
	 0x003,			/* src_mask */
	 0x003,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit PC-rel relocation */
  HOWTO (R_M68HC11_PCREL_16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_PCREL_16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_M68HC11_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_M68HC11_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_M68HC11_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,	/* special_function */
	 "R_M68HC11_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 24 bit relocation */
  HOWTO (R_M68HC11_24,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_24",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16-bit low relocation */
  HOWTO (R_M68HC11_LO16,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A page relocation */
  HOWTO (R_M68HC11_PAGE,        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_PAGE",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),

  /* Mark beginning of a jump instruction (any form).  */
  HOWTO (R_M68HC11_RL_JUMP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC11_RL_JUMP",	/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* Mark beginning of Gcc relaxation group instruction.  */
  HOWTO (R_M68HC11_RL_GROUP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC11_RL_GROUP",	/* name */
	 TRUE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),                 /* pcrel_offset */
};

/* Map BFD reloc types to M68HC11 ELF reloc types.  */

struct m68hc11_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct m68hc11_reloc_map m68hc11_reloc_map[] = {
  {BFD_RELOC_NONE, R_M68HC11_NONE,},
  {BFD_RELOC_8, R_M68HC11_8},
  {BFD_RELOC_M68HC11_HI8, R_M68HC11_HI8},
  {BFD_RELOC_M68HC11_LO8, R_M68HC11_LO8},
  {BFD_RELOC_8_PCREL, R_M68HC11_PCREL_8},
  {BFD_RELOC_16_PCREL, R_M68HC11_PCREL_16},
  {BFD_RELOC_16, R_M68HC11_16},
  {BFD_RELOC_32, R_M68HC11_32},
  {BFD_RELOC_M68HC11_3B, R_M68HC11_3B},

  {BFD_RELOC_VTABLE_INHERIT, R_M68HC11_GNU_VTINHERIT},
  {BFD_RELOC_VTABLE_ENTRY, R_M68HC11_GNU_VTENTRY},

  {BFD_RELOC_M68HC11_LO16, R_M68HC11_LO16},
  {BFD_RELOC_M68HC11_PAGE, R_M68HC11_PAGE},
  {BFD_RELOC_M68HC11_24, R_M68HC11_24},

  {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
  {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
};

static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (m68hc11_reloc_map) / sizeof (struct m68hc11_reloc_map);
       i++)
    {
      if (m68hc11_reloc_map[i].bfd_reloc_val == code)
	return &elf_m68hc11_howto_table[m68hc11_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (elf_m68hc11_howto_table)
	    / sizeof (elf_m68hc11_howto_table[0]));
       i++)
    if (elf_m68hc11_howto_table[i].name != NULL
	&& strcasecmp (elf_m68hc11_howto_table[i].name, r_name) == 0)
      return &elf_m68hc11_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an M68HC11 ELF reloc.  */

static void
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_M68HC11_max);
  cache_ptr->howto = &elf_m68hc11_howto_table[r_type];
}


/* Far trampoline generation.  */

/* Build a 68HC11 trampoline stub.  */
static bfd_boolean
m68hc11_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->size;
  stub_sec->size += 10;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     pshb
     ldab #%page(symbol)
     ldy #%addr(symbol)
     jmp __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* pshb; ldab #%page(sym) */
  bfd_put_8 (stub_bfd, 0x37, loc);
  bfd_put_8 (stub_bfd, 0xC6, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 2);
  loc += 3;

  /* ldy #%addr(sym)  */
  bfd_put_8 (stub_bfd, 0x18, loc);
  bfd_put_8 (stub_bfd, 0xCE, loc + 1);
  bfd_put_16 (stub_bfd, phys_addr, loc + 2);
  loc += 4;

  /* jmp __trampoline  */
  bfd_put_8 (stub_bfd, 0x7E, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);

  return TRUE;
}

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
m68hc11_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->size += 10;
  return TRUE;
}

/* Create a 68HC11 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc11_elf_bfd_link_hash_table_create (bfd *abfd)
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc11_elf_size_one_stub;
  ret->build_one_stub = m68hc11_elf_build_one_stub;

  return &ret->root.root;
}


/* 68HC11 Linker Relaxation.  */

struct m68hc11_direct_relax
{
  const char *name;
  unsigned char code;
  unsigned char direct_code;
} m68hc11_direct_relax_table[] = {
  { "adca", 0xB9, 0x99 },
  { "adcb", 0xF9, 0xD9 },
  { "adda", 0xBB, 0x9B },
  { "addb", 0xFB, 0xDB },
  { "addd", 0xF3, 0xD3 },
  { "anda", 0xB4, 0x94 },
  { "andb", 0xF4, 0xD4 },
  { "cmpa", 0xB1, 0x91 },
  { "cmpb", 0xF1, 0xD1 },
  { "cpd",  0xB3, 0x93 },
  { "cpxy", 0xBC, 0x9C },
/* { "cpy",  0xBC, 0x9C }, */
  { "eora", 0xB8, 0x98 },
  { "eorb", 0xF8, 0xD8 },
  { "jsr",  0xBD, 0x9D },
  { "ldaa", 0xB6, 0x96 },
  { "ldab", 0xF6, 0xD6 },
  { "ldd",  0xFC, 0xDC },
  { "lds",  0xBE, 0x9E },
  { "ldxy", 0xFE, 0xDE },
  /*  { "ldy",  0xFE, 0xDE },*/
  { "oraa", 0xBA, 0x9A },
  { "orab", 0xFA, 0xDA },
  { "sbca", 0xB2, 0x92 },
  { "sbcb", 0xF2, 0xD2 },
  { "staa", 0xB7, 0x97 },
  { "stab", 0xF7, 0xD7 },
  { "std",  0xFD, 0xDD },
  { "sts",  0xBF, 0x9F },
  { "stxy", 0xFF, 0xDF },
  /*  { "sty",  0xFF, 0xDF },*/
  { "suba", 0xB0, 0x90 },
  { "subb", 0xF0, 0xD0 },
  { "subd", 0xB3, 0x93 },
  { 0, 0, 0 }
};

static struct m68hc11_direct_relax *
find_relaxable_insn (unsigned char code)
{
  int i;

  for (i = 0; m68hc11_direct_relax_table[i].name; i++)
    if (m68hc11_direct_relax_table[i].code == code)
      return &m68hc11_direct_relax_table[i];

  return 0;
}

static int
compare_reloc (const void *e1, const void *e2)
{
  const Elf_Internal_Rela *i1 = (const Elf_Internal_Rela *) e1;
  const Elf_Internal_Rela *i2 = (const Elf_Internal_Rela *) e2;

  if (i1->r_offset == i2->r_offset)
    return 0;
  else
    return i1->r_offset < i2->r_offset ? -1 : 1;
}

#define M6811_OP_LDX_IMMEDIATE (0xCE)

static void
m68hc11_relax_group (bfd *abfd, asection *sec, bfd_byte *contents,
                     unsigned value, unsigned long offset,
                     unsigned long end_group)
{
  unsigned char code;
  unsigned long start_offset;
  unsigned long ldx_offset = offset;
  unsigned long ldx_size;
  int can_delete_ldx;
  int relax_ldy = 0;

  /* First instruction of the relax group must be a
     LDX #value or LDY #value.  If this is not the case,
     ignore the relax group.  */
  code = bfd_get_8 (abfd, contents + offset);
  if (code == 0x18)
    {
      relax_ldy++;
      offset++;
      code = bfd_get_8 (abfd, contents + offset);
    }
  ldx_size = offset - ldx_offset + 3;
  offset += 3;
  if (code != M6811_OP_LDX_IMMEDIATE || offset >= end_group)
    return;


  /* We can remove the LDX/LDY only when all bset/brclr instructions
     of the relax group have been converted to use direct addressing
     mode.  */
  can_delete_ldx = 1;
  while (offset < end_group)
    {
      unsigned isize;
      unsigned new_value;
      int bset_use_y;

      bset_use_y = 0;
      start_offset = offset;
      code = bfd_get_8 (abfd, contents + offset);
      if (code == 0x18)
        {
          bset_use_y++;
          offset++;
          code = bfd_get_8 (abfd, contents + offset);
        }

      /* Check the instruction and translate to use direct addressing mode.  */
      switch (code)
        {
          /* bset */
        case 0x1C:
          code = 0x14;
          isize = 3;
          break;

          /* brclr */
        case 0x1F:
          code = 0x13;
          isize = 4;
          break;

          /* brset */
        case 0x1E:
          code = 0x12;
          isize = 4;
          break;

          /* bclr */
        case 0x1D:
          code = 0x15;
          isize = 3;
          break;

          /* This instruction is not recognized and we are not
             at end of the relax group.  Ignore and don't remove
             the first LDX (we don't know what it is used for...).  */
        default:
          return;
        }
      new_value = (unsigned) bfd_get_8 (abfd, contents + offset + 1);
      new_value += value;
      if ((new_value & 0xff00) == 0 && bset_use_y == relax_ldy)
        {
          bfd_put_8 (abfd, code, contents + offset);
          bfd_put_8 (abfd, new_value, contents + offset + 1);
          if (start_offset != offset)
            {
              m68hc11_elf_relax_delete_bytes (abfd, sec, start_offset,
                                              offset - start_offset);
              end_group--;
            }
        }
      else
        {
          can_delete_ldx = 0;
        }
      offset = start_offset + isize;
    }
  if (can_delete_ldx)
    {
      /* Remove the move instruction (3 or 4 bytes win).  */
      m68hc11_elf_relax_delete_bytes (abfd, sec, ldx_offset, ldx_size);
    }
}

/* This function handles relaxing for the 68HC11.


	and somewhat more difficult to support.  */

static bfd_boolean
m68hc11_elf_relax_section (bfd *abfd, asection *sec,
                           struct bfd_link_info *link_info, bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_Internal_Rela *prev_insn_branch = NULL;
  Elf_Internal_Rela *prev_insn_group = NULL;
  unsigned insn_group_value = 0;
  Elf_Internal_Sym *isymbuf = NULL;

  /* Assume nothing changes.  */
  *again = FALSE;

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  /* Checking for branch relaxation relies on the relocations to
     be sorted on 'r_offset'.  This is not guaranteed so we must sort.  */
  qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
         compare_reloc);

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_vma value;
      Elf_Internal_Sym *isym;
      asection *sym_sec;
      int is_far = 0;

      /* If this isn't something that can be relaxed, then ignore
	 this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_16
          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_JUMP
          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_GROUP)
        {
          prev_insn_branch = 0;
          prev_insn_group = 0;
          continue;
        }

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
		goto error_return;
	    }
	}

      /* Try to eliminate an unconditional 8 bit pc-relative branch
	 which immediately follows a conditional 8 bit pc-relative
	 branch around the unconditional branch.

	    original:		new:
	    bCC lab1		bCC' lab2
	    bra lab2
	   lab1:	       lab1:

	 This happens when the bCC can't reach lab2 at assembly time,
	 but due to other relaxations it can reach at link time.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_JUMP)
	{
	  Elf_Internal_Rela *nrel;
	  unsigned char code;
          unsigned char roffset;

          prev_insn_branch = 0;
          prev_insn_group = 0;

	  /* Do nothing if this reloc is the last byte in the section.  */
	  if (irel->r_offset + 2 >= sec->size)
	    continue;

	  /* See if the next instruction is an unconditional pc-relative
	     branch, more often than not this test will fail, so we
	     test it first to speed things up.  */
	  code = bfd_get_8 (abfd, contents + irel->r_offset + 2);
	  if (code != 0x7e)
	    continue;

	  /* Also make sure the next relocation applies to the next
	     instruction and that it's a pc-relative 8 bit branch.  */
	  nrel = irel + 1;
	  if (nrel == irelend
	      || irel->r_offset + 3 != nrel->r_offset
	      || ELF32_R_TYPE (nrel->r_info) != (int) R_M68HC11_16)
	    continue;

	  /* Make sure our destination immediately follows the
	     unconditional branch.  */
          roffset = bfd_get_8 (abfd, contents + irel->r_offset + 1);
          if (roffset != 3)
            continue;

          prev_insn_branch = irel;
          prev_insn_group = 0;
          continue;
        }

      /* Read this BFD's symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
          is_far = isym->st_other & STO_M68HC12_FAR;
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
              prev_insn_branch = 0;
              prev_insn_group = 0;
	      continue;
	    }

          is_far = h->other & STO_M68HC12_FAR;
          isym = 0;
          sym_sec = h->root.u.def.section;
	  symval = (h->root.u.def.value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}

      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_GROUP)
	{
          prev_insn_branch = 0;
          prev_insn_group = 0;

	  /* Do nothing if this reloc is the last byte in the section.  */
	  if (irel->r_offset == sec->size)
	    continue;

          prev_insn_group = irel;
          insn_group_value = isym->st_value;
          continue;
        }

      /* When we relax some bytes, the size of our section changes.
         This affects the layout of next input sections that go in our
         output section.  When the symbol is part of another section that
         will go in the same output section as the current one, it's
         final address may now be incorrect (too far).  We must let the
         linker re-compute all section offsets before processing this
         reloc.  Code example:

                                Initial             Final
         .sect .text            section size = 6    section size = 4
         jmp foo
         jmp bar
         .sect .text.foo_bar    output_offset = 6   output_offset = 4
         foo: rts
         bar: rts

         If we process the reloc now, the jmp bar is replaced by a
         relative branch to the initial bar address (output_offset 6).  */
      if (*again && sym_sec != sec
          && sym_sec->output_section == sec->output_section)
        {
          prev_insn_group = 0;
          prev_insn_branch = 0;
          continue;
        }

      value = symval;
      /* Try to turn a far branch to a near branch.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
          && prev_insn_branch)
        {
          bfd_vma offset;
          unsigned char code;

          offset = value - (prev_insn_branch->r_offset
                            + sec->output_section->vma
                            + sec->output_offset + 2);

          /* If the offset is still out of -128..+127 range,
             leave that far branch unchanged.  */
          if ((offset & 0xff80) != 0 && (offset & 0xff80) != 0xff80)
            {
              prev_insn_branch = 0;
              continue;
            }

          /* Shrink the branch.  */
          code = bfd_get_8 (abfd, contents + prev_insn_branch->r_offset);
          if (code == 0x7e)
            {
              code = 0x20;
              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
              bfd_put_8 (abfd, 0xff,
                         contents + prev_insn_branch->r_offset + 1);
              irel->r_offset = prev_insn_branch->r_offset + 1;
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_PCREL_8);
              m68hc11_elf_relax_delete_bytes (abfd, sec,
                                              irel->r_offset + 1, 1);
            }
          else
            {
              code ^= 0x1;
              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
              bfd_put_8 (abfd, 0xff,
                         contents + prev_insn_branch->r_offset + 1);
              irel->r_offset = prev_insn_branch->r_offset + 1;
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_PCREL_8);
              m68hc11_elf_relax_delete_bytes (abfd, sec,
                                              irel->r_offset + 1, 3);
            }
          prev_insn_branch = 0;
          *again = TRUE;
        }

      /* Try to turn a 16 bit address into a 8 bit page0 address.  */
      else if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
               && (value & 0xff00) == 0)
	{
          unsigned char code;
          unsigned short offset;
          struct m68hc11_direct_relax *rinfo;

          prev_insn_branch = 0;
          offset = bfd_get_16 (abfd, contents + irel->r_offset);
          offset += value;
          if ((offset & 0xff00) != 0)
            {
              prev_insn_group = 0;
              continue;
            }

          if (prev_insn_group)
            {
              unsigned long old_sec_size = sec->size;

              /* Note that we've changed the relocation contents, etc.  */
              elf_section_data (sec)->relocs = internal_relocs;
              free_relocs = NULL;

              elf_section_data (sec)->this_hdr.contents = contents;
              free_contents = NULL;

              symtab_hdr->contents = (bfd_byte *) isymbuf;
              free_extsyms = NULL;

              m68hc11_relax_group (abfd, sec, contents, offset,
                                   prev_insn_group->r_offset,
                                   insn_group_value);
              irel = prev_insn_group;
              prev_insn_group = 0;
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_NONE);
              if (sec->size != old_sec_size)
                *again = TRUE;
              continue;
            }

          /* Get the opcode.  */
          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
          rinfo = find_relaxable_insn (code);
          if (rinfo == 0)
            {
              prev_insn_group = 0;
              continue;
            }

          /* Note that we've changed the relocation contents, etc.  */
          elf_section_data (sec)->relocs = internal_relocs;
          free_relocs = NULL;

          elf_section_data (sec)->this_hdr.contents = contents;
          free_contents = NULL;

          symtab_hdr->contents = (bfd_byte *) isymbuf;
          free_extsyms = NULL;

          /* Fix the opcode.  */
          /* printf ("A relaxable case : 0x%02x (%s)\n",
             code, rinfo->name); */
          bfd_put_8 (abfd, rinfo->direct_code,
                     contents + irel->r_offset - 1);

          /* Delete one byte of data (upper byte of address).  */
          m68hc11_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 1);

          /* Fix the relocation's type.  */
          irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                       R_M68HC11_8);

          /* That will change things, so, we should relax again.  */
          *again = TRUE;
        }
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16 && !is_far)
        {
          unsigned char code;
          bfd_vma offset;

          prev_insn_branch = 0;
          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
          if (code == 0x7e || code == 0xbd)
            {
              offset = value - (irel->r_offset
                                + sec->output_section->vma
                                + sec->output_offset + 1);
              offset += bfd_get_16 (abfd, contents + irel->r_offset);

              /* If the offset is still out of -128..+127 range,
                 leave that far branch unchanged.  */
              if ((offset & 0xff80) == 0 || (offset & 0xff80) == 0xff80)
                {

                  /* Note that we've changed the relocation contents, etc.  */
                  elf_section_data (sec)->relocs = internal_relocs;
                  free_relocs = NULL;

                  elf_section_data (sec)->this_hdr.contents = contents;
                  free_contents = NULL;

                  symtab_hdr->contents = (bfd_byte *) isymbuf;
                  free_extsyms = NULL;

                  /* Shrink the branch.  */
                  code = (code == 0x7e) ? 0x20 : 0x8d;
                  bfd_put_8 (abfd, code,
                             contents + irel->r_offset - 1);
                  bfd_put_8 (abfd, 0xff,
                             contents + irel->r_offset);
                  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                               R_M68HC11_PCREL_8);
                  m68hc11_elf_relax_delete_bytes (abfd, sec,
                                                  irel->r_offset + 1, 1);
                  /* That will change things, so, we should relax again.  */
                  *again = TRUE;
                }
            }
        }
      prev_insn_branch = 0;
      prev_insn_group = 0;
    }

  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
      free_contents = NULL;
    }

  if (free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (free_extsyms);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
      free_extsyms = NULL;
    }

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static void
m68hc11_elf_relax_delete_bytes (bfd *abfd, asection *sec,
                                bfd_vma addr, int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  bfd_vma toaddr;
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));

  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      unsigned char code;
      unsigned char offset;
      unsigned short raddr;
      unsigned long old_offset;
      int branch_pos;

      old_offset = irel->r_offset;

      /* See if this reloc was for the bytes we have deleted, in which
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
      if (ELF32_R_TYPE (irel->r_info) != R_M68HC11_RL_JUMP
          && irel->r_offset >= addr && irel->r_offset < addr + count)
        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                     R_M68HC11_NONE);

      if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_NONE)
        continue;

      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr))
	irel->r_offset -= count;

      /* If this is a PC relative reloc, see if the range it covers
         includes the bytes we have deleted.  */
      switch (ELF32_R_TYPE (irel->r_info))
	{
	default:
	  break;

	case R_M68HC11_RL_JUMP:
          code = bfd_get_8 (abfd, contents + irel->r_offset);
          switch (code)
            {
              /* jsr and jmp instruction are also marked with RL_JUMP
                 relocs but no adjustment must be made.  */
            case 0x7e:
            case 0x9d:
            case 0xbd:
              continue;

            case 0x12:
            case 0x13:
              branch_pos = 3;
              raddr = 4;

              /* Special case when we translate a brclr N,y into brclr *<addr>
                 In this case, the 0x18 page2 prefix is removed.
                 The reloc offset is not modified but the instruction
                 size is reduced by 1.  */
              if (old_offset == addr)
                raddr++;
              break;

            case 0x1e:
            case 0x1f:
              branch_pos = 3;
              raddr = 4;
              break;

            case 0x18:
              branch_pos = 4;
              raddr = 5;
              break;

            default:
              branch_pos = 1;
              raddr = 2;
              break;
            }
          offset = bfd_get_8 (abfd, contents + irel->r_offset + branch_pos);
          raddr += old_offset;
          raddr += ((unsigned short) offset | ((offset & 0x80) ? 0xff00 : 0));
          if (irel->r_offset < addr && raddr > addr)
            {
              offset -= count;
              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
            }
          else if (irel->r_offset >= addr && raddr <= addr)
            {
              offset += count;
              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
            }
          else
            {
              /*printf ("Not adjusted 0x%04x [0x%4x 0x%4x]\n", raddr,
                irel->r_offset, addr);*/
            }

          break;
	}
    }

  /* Adjust the local symbols defined in this section.  */
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value <= toaddr)
	isym->st_value -= count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value <= toaddr)
	{
	  sym_hash->root.u.def.value -= count;
	}
    }
}

/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC11. Soft registers used by GCC-m6811
     are located in .page0.
   - The .vectors is the section that represents the interrupt
     vectors.  */
static const struct bfd_elf_special_section elf32_m68hc11_special_sections[] =
{
  { STRING_COMMA_LEN (".eeprom"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".page0"),    0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".softregs"), 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".vectors"),  0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,                       0,  0, 0,            0 }
};

#define ELF_ARCH		bfd_arch_m68hc11
#define ELF_TARGET_ID		M68HC11_ELF_DATA
#define ELF_MACHINE_CODE	EM_68HC11
#define ELF_MAXPAGESIZE		0x1000

#define TARGET_BIG_SYM          bfd_elf32_m68hc11_vec
#define TARGET_BIG_NAME		"elf32-m68hc11"

#define elf_info_to_howto	0
#define elf_info_to_howto_rel	m68hc11_info_to_howto_rel
#define bfd_elf32_bfd_relax_section  m68hc11_elf_relax_section
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook
#define elf_backend_object_p	0
#define elf_backend_final_write_processing	0
#define elf_backend_can_gc_sections		1
#define elf_backend_special_sections  elf32_m68hc11_special_sections
#define elf_backend_merge_symbol_attribute elf32_m68hc11_merge_symbol_attribute

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc11_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_m68hc11_elf_print_private_bfd_data

#include "elf32-target.h"
@


1.41
log
@	* elf32-m68hc1x.c (elf32_m68hc11_merge_symbol_attribute): New function.
	* elf32-m68hc1x.h (elf32_m68hc11_merge_symbol_attribute): Declare.
	* elf32-m68hc11.c (elf_backend_merge_symbol_attribute): Define.
	* elf32-m68hc12.c (elf_backend_merge_symbol_attribute): Define.
@
text
@d706 1
a706 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
@


1.40
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010
d1305 1
@


1.39
log
@fix set but unused variable warnings
@
text
@d1288 1
@


1.38
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a678 1
  Elf_Internal_Shdr *shndx_hdr;
a702 1
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
@


1.37
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d412 2
@


1.36
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.35
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.34
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d361 17
@


1.33
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006
a1278 2
#define elf_backend_gc_mark_hook     elf32_m68hc11_gc_mark_hook
#define elf_backend_gc_sweep_hook    elf32_m68hc11_gc_sweep_hook
@


1.32
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
d1262 5
a1266 5
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
@


1.31
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a1267 18

static const struct bfd_elf_special_section *
elf32_m68hc11_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf32_m68hc11_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}
d1287 1
a1287 1
#define elf_backend_get_sec_type_attr elf32_m68hc11_get_sec_type_attr
@


1.30
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d1260 1
a1260 1
static struct bfd_elf_special_section const elf32_m68hc11_special_sections[] =
d1272 1
a1272 1
  const struct bfd_elf_special_section const *ssect;
@


1.29
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d1260 1
a1260 2
static struct bfd_elf_special_section const
  m68hc11_special_sections_e[] =
d1263 1
a1263 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  m68hc11_special_sections_s[]=
{
d1265 1
d1269 2
a1270 2
static struct bfd_elf_special_section const
  m68hc11_special_sections_p[]=
d1272 1
a1272 3
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,        0, 0, 0,            0 }
};
d1274 9
a1282 6
static struct bfd_elf_special_section const
  m68hc11_special_sections_v[]=
{
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
};
d1284 2
a1285 31
static struct bfd_elf_special_section const *
  elf32_m68hc11_special_sections[27] =
{
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  m68hc11_special_sections_e,	/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  m68hc11_special_sections_p,	/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  m68hc11_special_sections_s,	/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  m68hc11_special_sections_v,	/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d1305 1
a1305 1
#define elf_backend_special_sections elf32_m68hc11_special_sections
@


1.28
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1260 2
a1261 1
static struct bfd_elf_special_section const elf32_m68hc11_special_sections[]=
d1264 6
d1271 6
d1278 6
d1287 32
@


1.27
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.26
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.25
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d398 2
a399 2
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 10;
d449 1
a449 1
  stub_entry->stub_sec->_raw_size += 10;
a682 5
  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d730 1
a730 7
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
d756 1
a756 1
	  if (irel->r_offset + 2 >= sec->_cooked_size)
d842 1
a842 1
	  if (irel->r_offset == sec->_cooked_size)
d945 1
a945 1
              unsigned long old_sec_size = sec->_cooked_size;
d964 1
a964 1
              if (sec->_cooked_size != old_sec_size)
d1117 1
a1117 1
  toaddr = sec->_cooked_size;
d1126 1
a1126 1
  sec->_cooked_size -= count;
@


1.25.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d397 2
a398 2
  stub_entry->stub_offset = stub_sec->size;
  stub_sec->size += 10;
d448 1
a448 1
  stub_entry->stub_sec->size += 10;
d682 5
d734 7
a740 1
	      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d766 1
a766 1
	  if (irel->r_offset + 2 >= sec->size)
d852 1
a852 1
	  if (irel->r_offset == sec->size)
d955 1
a955 1
              unsigned long old_sec_size = sec->size;
d974 1
a974 1
              if (sec->size != old_sec_size)
d1127 1
a1127 1
  toaddr = sec->size;
d1136 1
a1136 1
  sec->size -= count;
@


1.24
log
@	* elf32-m68hc1x.c: Update to ISO C90; replace PTR with void*.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
@
text
@d957 1
a957 1
              /* Note that we've changed the reldection contents, etc.  */
d988 1
a988 1
          /* Note that we've changed the reldection contents, etc.  */
d1033 1
a1033 1
                  /* Note that we've changed the reldection contents, etc.  */
@


1.23
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d33 1
a33 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d35 1
a35 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d39 1
a39 1
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
d41 1
a41 1
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
d43 1
a43 1
  PARAMS ((bfd* abfd));
d47 1
a47 1
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d49 1
a49 1
  PARAMS ((bfd *, asection *, bfd_vma, int));
d51 2
a52 3
  PARAMS ((bfd *, asection *, bfd_byte *, unsigned,
	   unsigned long, unsigned long));
static int compare_reloc PARAMS ((const void *, const void *));
d344 2
a345 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d363 2
a364 4
m68hc11_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d378 1
a378 3
m68hc11_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
d440 2
a441 3
m68hc11_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d455 1
a455 2
m68hc11_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
d528 1
a528 3
compare_reloc (e1, e2)
     const void *e1;
     const void *e2;
d542 3
a544 7
m68hc11_relax_group (abfd, sec, contents, value, offset, end_group)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     unsigned value;
     unsigned long offset;
     unsigned long end_group;
d654 2
a655 5
m68hc11_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d1107 2
a1108 5
m68hc11_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
@


1.22
log
@	* elf32-m68hc12.c (elf32_m68hc12_special_sections): New for hc11.
	(elf_backend_special_sections): Define.a

	PR savannah/4950:
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): The .vectors
	section is read-only.
@
text
@d1292 5
a1296 10
  { ".eeprom",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".softregs",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { ".page0",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".vectors",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.21
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d1288 1
a1288 1
   - The .vectors is the data section that represents the interrupt
d1299 1
a1299 1
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
@


1.20
log
@Correct spelling of "relocatable".
@
text
@d1284 19
d1322 1
@


1.19
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d690 1
a690 1
  /* We don't have to do anything for a relocateable link, if
d693 1
a693 1
  if (link_info->relocateable
@


1.18
log
@	PR savannah/3331:
	* elf32-m68hc11.c (m68hc11_elf_relax_section): Clear prev_insn_group
	when we couldn't relax something.
	* ld-m68hc11/bug-3331.d: New test.
	* ld-m68hc11/bug-3331.s: New file.
@
text
@d708 1
a708 1
  internal_relocs = (_bfd_elf32_link_read_relocs
@


1.17
log
@	* elf32-m68hc1x.c: New file (from elf32-m68hc11.c and elf32-m68hc12.c)
	(m68hc11_elf_hash_table_create): New function.
	(elf32_m68hc11_link_hash_table_free): New function.
	(stub_hash_newfunc): New function.
	(m68hc11_add_stub): New function.
	(elf32_m68hc11_add_symbol_hook): New function.
	(elf32_m68hc11_setup_section_lists): New function.
	(elf32_m68hc11_next_input_section): New function.
	(elf32_m68hc11_size_stubs): New function.
	(elf32_m68hc11_build_stubs): New function.
	(m68hc11_get_relocation_value): New function.
	(elf32_m68hc11_relocate_section): Call the above to redirect
	some relocations to the trampoline code.
	(m68hc11_elf_export_one_stub): New function.
	(m68hc11_elf_set_symbol): New function.
	(elf32_m68hc11_build_stubs): Call it via bfd_hash_traverse.
	(m68hc11_elf_get_bank_parameters): Get parameters only when the info
	is not yet initialized.

	* elf32-m68hc1x.h: New file (from elf32-m68hc11.c and elf32-m68hc12.c)
	(elf32_m68hc11_stub_hash_entry): New struct.
	(m68hc11_page_info): Add trampoline handler address.
	(m68hc11_elf_link_hash_table): Add stubs generation members.
	(elf32_m68hc11_add_symbol_hook): Declare.
	(elf32_m68hc11_setup_section_lists): Declare.
	(elf32_m68hc11_size_stubs): Declare.
	(elf32_m68hc11_build_stubs): Declare.

	* elf32-m68hc11.c (m68hc11_elf_ignore_reloc): Move to elf32-m68hc1x.c.
	(elf32_m68hc11_gc_mark_hook, elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf32_m68hc11_check_relocs, elf32_m68hc11_relocate_section): Ditto.
	(_bfd_m68hc11_elf_set_private_flags): Ditto.
	(_bfd_m68hc11_elf_merge_private_bfd_data): Ditto.
	(_bfd_m68hc11_elf_print_private_bfd_data): Ditto.
	(bfd_elf32_bfd_link_hash_table_create): Define.
	(elf_backend_add_symbol_hook): Define.
	(m68hc11_elf_bfd_link_hash_table_create): New function.
	(m68hc11_elf_build_one_stub): New function.
	(m68hc11_elf_size_one_stub): New function.
	(m68hc11_elf_bfd_link_hash_table_create): Install the above.
	(bfd_elf32_bfd_link_hash_table_create): Define.

	* elf32-m68hc12.c (m68hc11_elf_ignore_reloc): Remove.
	(m68hc12_addr_is_banked): Remove, use m68hc11_addr_is_banked.
	(m68hc12_phys_addr): Ditto.
	(m68hc12_phys_page): Ditto.
	(m68hc12_elf_special_reloc): Move to elf32-m68hc1x.c.
	(elf32_m68hc11_gc_mark_hook): Likewise.
	(elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf32_m68hc11_check_relocs): Likewise.
	(elf32_m68hc11_relocate_section): Likewise.
	(_bfd_m68hc12_elf_set_private_flags): Likewise.
	(_bfd_m68hc12_elf_merge_private_bfd_data): Likewise.
	(_bfd_m68hc12_elf_print_private_bfd_data): Likewise.
	(m68hc12_elf_build_one_stub): New function.
	(m68hc12_elf_size_one_stub): New function.
	(m68hc12_elf_bfd_link_hash_table_create): New function, use the above.
	(elf_backend_add_symbol_hook): Define.
	(elf_m68hc11_howto_table): Use TRUE for pcrel relocs; fix masks.
@
text
@d1076 1
@


1.16
log
@	* elf32-m68hc11.c (m68hc11_elf_relax_delete_bytes): Also adjust
	symbols that mark the end of the section.
	(m68hc11_elf_relax_section): Use R_M68HC11_PCREL_8 relocs when
	converting to a relative branch so that the offset is computed after
	the relaxation; also relocate a jsr into a bsr if possible but don't
	relax them if they are to a far symbol as we need to call the
	trampoline code.
	(elf_m68hc11_howto_table): Set pcrel_offset to true.
@
text
@d27 1
d29 1
d31 1
d37 7
a43 2
static bfd_reloc_status_type m68hc11_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d45 1
a45 13
/* GC mark and sweep.  */
static asection *elf32_m68hc11_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_m68hc11_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_m68hc11_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_m68hc11_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
a54 5

bfd_boolean _bfd_m68hc11_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
bfd_boolean _bfd_m68hc11_elf_set_private_flags PARAMS ((bfd *, flagword));
bfd_boolean _bfd_m68hc11_elf_print_private_bfd_data PARAMS ((bfd *, PTR));

d58 2
a59 1
/* The Motorola 68HC11 microcontroler only addresses 64Kb.
d61 2
a62 2
   is defined but not used except by gas when -gstabs is used (which
   is wrong).
a361 19
/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
m68hc11_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                          output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

d377 8
a384 7
static asection *
elf32_m68hc11_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d386 58
a443 10
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d445 6
a450 2
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
d452 2
a453 7
	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d455 2
a456 1
  return NULL;
d459 5
a463 6
static bfd_boolean
elf32_m68hc11_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d465 10
a474 2
  /* We don't use got and plt entries for 68hc11/68hc12.  */
  return TRUE;
a1282 225
/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
elf32_m68hc11_check_relocs (abfd, info, sec, relocs)
     bfd * abfd;
     struct bfd_link_info * info;
     asection * sec;
     const Elf_Internal_Rela * relocs;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  struct elf_link_hash_entry ** sym_hashes_end;
  const Elf_Internal_Rela *     rel;
  const Elf_Internal_Rela *     rel_end;

  if (info->relocateable)
    return TRUE;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;

  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry * h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes [r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
        {
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_M68HC11_GNU_VTINHERIT:
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_M68HC11_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
        }
    }

  return TRUE;
}

/* Relocate a 68hc11/68hc12 ELF section.  */
static bfd_boolean
elf32_m68hc11_relocate_section (output_bfd, info, input_bfd, input_section,
                                contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;
  const char *name;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_type == R_M68HC11_GNU_VTENTRY
          || r_type == R_M68HC11_GNU_VTINHERIT )
        continue;

      howto = elf_m68hc11_howto_table + r_type;

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                    contents, rel->r_offset,
                                    relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) 0;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      if (!((*info->callbacks->reloc_overflow)
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, name, input_bfd, input_section,
		     rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _ ("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _ ("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _ ("internal error: dangerous error");
	      goto common_error;

	    default:
	      msg = _ ("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}


a1283 133
/* Set and control ELF flags in ELF header.  */

bfd_boolean
_bfd_m68hc11_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

bfd_boolean
_bfd_m68hc11_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean ok = TRUE;

  /* Check if we have the same endianess */
  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_M68HC11_ABI;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return FALSE;
	}

      return TRUE;
    }

  /* Check ABI compatibility.  */
  if ((new_flags & E_M68HC11_I32) != (old_flags & E_M68HC11_I32))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 16-bit integers (-mshort) "
           "and others for 32-bit integers"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
  if ((new_flags & E_M68HC11_F64) != (old_flags & E_M68HC11_F64))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 32-bit double (-fshort-double) "
           "and others for 64-bit double"),
	 bfd_archive_filename (ibfd));
      ok = FALSE;
    }
  new_flags &= ~EF_M68HC11_ABI;
  old_flags &= ~EF_M68HC11_ABI;

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = FALSE;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  return TRUE;
}

bfd_boolean
_bfd_m68hc11_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_I32)
    fprintf (file, _("[abi=32-bit int,"));
  else
    fprintf (file, _("[abi=16-bit int,"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_F64)
    fprintf (file, _(" 64-bit double]"));
  else
    fprintf (file, _(" 32-bit double]"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC12_BANKS)
    fprintf (file, _(" [memory=bank-model]"));
  else
    fprintf (file, _(" [memory=flat]"));

  fputc ('\n', file);

  return TRUE;
}

/* Below is the only difference between elf32-m68hc12.c and elf32-m68hc11.c.
   The Motorola spec says to use a different Elf machine code.  */
d1298 1
d1302 5
@


1.16.4.1
log
@Merge from mainline.
@
text
@a26 1
#include "elf32-m68hc1x.h"
a27 1
#include "opcode/m68hc11.h"
a28 1
/* Relocation functions.  */
d34 2
a35 7
/* Trampoline generation.  */
static bfd_boolean m68hc11_elf_size_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static bfd_boolean m68hc11_elf_build_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static struct bfd_link_hash_table* m68hc11_elf_bfd_link_hash_table_create
  PARAMS ((bfd* abfd));
d37 13
a49 1
/* Linker relaxation.  */
d59 5
d67 1
a67 2
/* The Motorola 68HC11 microcontroller only addresses 64Kb but we also
   support a memory bank switching mechanism similar to 68HC12.
d69 2
a70 2
   are used for debugging sections (DWARF2) to represent a virtual
   address.
d370 19
d404 21
a424 2

/* Far trampoline generation.  */
d426 7
a432 58
/* Build a 68HC11 trampoline stub.  */
static bfd_boolean
m68hc11_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 10;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     pshb
     ldab #%page(symbol)
     ldy #%addr(symbol)
     jmp __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* pshb; ldab #%page(sym) */
  bfd_put_8 (stub_bfd, 0x37, loc);
  bfd_put_8 (stub_bfd, 0xC6, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 2);
  loc += 3;

  /* ldy #%addr(sym)  */
  bfd_put_8 (stub_bfd, 0x18, loc);
  bfd_put_8 (stub_bfd, 0xCE, loc + 1);
  bfd_put_16 (stub_bfd, phys_addr, loc + 2);
  loc += 4;

  /* jmp __trampoline  */
  bfd_put_8 (stub_bfd, 0x7E, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
d434 1
a434 1
  return TRUE;
a436 3
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

d438 5
a442 3
m68hc11_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d444 1
a444 6
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->_raw_size += 10;
a447 18
/* Create a 68HC11 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc11_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc11_elf_size_one_stub;
  ret->build_one_stub = m68hc11_elf_build_one_stub;

  return &ret->root.root;
}

a1046 1
      prev_insn_group = 0;
d1254 225
d1480 133
a1626 1
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook
a1629 5

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc11_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
@


1.16.4.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d708 1
a708 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.15
log
@	Fix PR savannah/1417:
	* elf32-m68hc11.c (m68hc11_elf_relax_delete_bytes): Don't adjust
	branch if it goes to the start of the deleted region.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d146 1
a146 1
	 FALSE),		/* pcrel_offset */
d207 1
a207 1
	 FALSE),		/* pcrel_offset */
d250 2
a251 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d448 3
d700 1
d754 1
a754 1
	  if (irel->r_offset == sec->_cooked_size)
d800 1
d826 1
d900 1
a900 1
              bfd_put_8 (abfd, offset,
d902 1
d904 1
a904 1
                                           R_M68HC11_NONE);
d906 1
a906 1
                                              irel->r_offset, 1);
d912 1
a912 1
              bfd_put_8 (abfd, offset,
d914 1
d916 1
a916 1
                                           R_M68HC11_NONE);
d918 1
a918 1
                                              irel->r_offset - 1, 3);
d1002 1
a1002 1
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16)
d1009 1
a1009 1
          if (code == 0x7e)
d1032 1
a1032 1
                  code = 0x20;
d1035 1
a1035 1
                  bfd_put_8 (abfd, offset,
d1038 1
a1038 1
                                               R_M68HC11_NONE);
d1231 1
a1231 1
	  && isym->st_value < toaddr)
d1247 1
a1247 1
	  && sym_hash->root.u.def.value < toaddr)
@


1.15.16.1
log
@Merge with mainline.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d146 1
a146 1
	 TRUE),                 /* pcrel_offset */
d207 1
a207 1
	 TRUE),                 /* pcrel_offset */
d250 2
a251 2
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
a447 3

/* 68HC11 Linker Relaxation.  */

a696 1
      int is_far = 0;
d750 1
a750 1
	  if (irel->r_offset + 2 >= sec->_cooked_size)
a795 1
          is_far = isym->st_other & STO_M68HC12_FAR;
a820 1
          is_far = h->other & STO_M68HC12_FAR;
d894 1
a894 1
              bfd_put_8 (abfd, 0xff,
a895 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d897 1
a897 1
                                           R_M68HC11_PCREL_8);
d899 1
a899 1
                                              irel->r_offset + 1, 1);
d905 1
a905 1
              bfd_put_8 (abfd, 0xff,
a906 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d908 1
a908 1
                                           R_M68HC11_PCREL_8);
d910 1
a910 1
                                              irel->r_offset + 1, 3);
d994 1
a994 1
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16 && !is_far)
d1001 1
a1001 1
          if (code == 0x7e || code == 0xbd)
d1024 1
a1024 1
                  code = (code == 0x7e) ? 0x20 : 0x8d;
d1027 1
a1027 1
                  bfd_put_8 (abfd, 0xff,
d1030 1
a1030 1
                                               R_M68HC11_PCREL_8);
d1223 1
a1223 1
	  && isym->st_value <= toaddr)
d1239 1
a1239 1
	  && sym_hash->root.u.def.value <= toaddr)
@


1.14
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1197 1
a1197 1
          if (irel->r_offset < addr && raddr >= addr)
@


1.13
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d41 1
a41 1
static boolean elf32_m68hc11_gc_sweep_hook
d44 1
a44 1
static boolean elf32_m68hc11_check_relocs
d47 1
a47 1
static boolean elf32_m68hc11_relocate_section
d50 2
a51 2
static boolean m68hc11_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
d60 3
a62 3
boolean _bfd_m68hc11_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
boolean _bfd_m68hc11_elf_set_private_flags PARAMS ((bfd *, flagword));
boolean _bfd_m68hc11_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d78 1
a78 1
	 false,			/* pc_relative */
d83 1
a83 1
	 false,			/* partial_inplace */
d86 1
a86 1
	 false),		/* pcrel_offset */
d93 1
a93 1
	 false,			/* pc_relative */
d98 1
a98 1
	 false,			/* partial_inplace */
d101 1
a101 1
	 false),		/* pcrel_offset */
d108 1
a108 1
	 false,			/* pc_relative */
d113 1
a113 1
	 false,			/* partial_inplace */
d116 1
a116 1
	 false),		/* pcrel_offset */
d123 1
a123 1
	 false,			/* pc_relative */
d128 1
a128 1
	 false,			/* partial_inplace */
d131 1
a131 1
	 false),		/* pcrel_offset */
d138 1
a138 1
	 true,			/* pc_relative */
d143 1
a143 1
	 false,			/* partial_inplace */
d146 1
a146 1
	 false),		/* pcrel_offset */
d153 1
a153 1
	 false,			/* pc_relative */
d158 1
a158 1
	 false,			/* partial_inplace */
d161 1
a161 1
	 false),		/* pcrel_offset */
d169 1
a169 1
	 false,			/* pc_relative */
d174 1
a174 1
	 false,			/* partial_inplace */
d177 1
a177 1
	 false),		/* pcrel_offset */
d184 1
a184 1
	 false,			/* pc_relative */
d189 1
a189 1
	 false,			/* partial_inplace */
d192 1
a192 1
	 false),		/* pcrel_offset */
d199 1
a199 1
	 true,			/* pc_relative */
d204 1
a204 1
	 false,			/* partial_inplace */
d207 1
a207 1
	 false),		/* pcrel_offset */
d214 1
a214 1
	 false,			/* pc_relative */
d219 1
a219 1
	 false,			/* partial_inplace */
d222 1
a222 1
	 false),		/* pcrel_offset */
d229 1
a229 1
	 false,			/* pc_relative */
d234 1
a234 1
	 false,			/* partial_inplace */
d237 1
a237 1
	 false),		/* pcrel_offset */
d244 1
a244 1
	 false,			/* pc_relative */
d249 1
a249 1
	 false,			/* partial_inplace */
d252 2
a253 2
	 false),		/* pcrel_offset */
  
d259 1
a259 1
	 false,			/* pc_relative */
d264 1
a264 1
	 false,			/* partial_inplace */
d267 1
a267 1
	 false),		/* pcrel_offset */
d274 1
a274 1
	 false,			/* pc_relative */
d279 1
a279 1
	 false,			/* partial_inplace */
d282 1
a282 1
	 false),		/* pcrel_offset */
d290 1
a290 1
  
d296 1
a296 1
	 false,			/* pc_relative */
d301 1
a301 1
	 true,			/* partial_inplace */
d304 1
a304 1
	 true),                 /* pcrel_offset */
d311 1
a311 1
	 false,			/* pc_relative */
d316 1
a316 1
	 true,			/* partial_inplace */
d319 1
a319 1
	 true),                 /* pcrel_offset */
d437 1
a437 1
static boolean
d445 1
a445 1
  return true;
d448 1
a448 1
struct m68hc11_direct_relax 
d632 1
a632 1
   
d635 1
a635 1
static boolean
d640 1
a640 1
     boolean *again;
d656 1
a656 1
  *again = false;
d665 1
a665 1
    return true;
d748 1
a748 1
          
d832 1
a832 1
          
d867 1
a867 1
      
d913 1
a913 1
          *again = true;
d936 1
a936 1
              
d955 1
a955 1
                *again = true;
d958 1
a958 1
          
d992 1
a992 1
          *again = true;
d1016 1
a1016 1
                  
d1019 1
a1019 1
                  
d1034 1
a1034 1
                  *again = true;
d1071 1
a1071 1
  return true;
d1080 1
a1080 1
  return false;
d1119 1
a1119 1
  
d1212 1
a1212 1
          
d1250 1
a1250 1
static boolean
d1264 1
a1264 1
    return true;
d1292 1
a1292 1
            return false;
d1299 1
a1299 1
            return false;
d1304 1
a1304 1
  return true;
d1308 1
a1308 1
static boolean
d1401 2
a1402 2
		     input_section, rel->r_offset, true)))
		return false;
d1431 1
a1431 1
		return false;
d1437 2
a1438 2
		     rel->r_offset, true)))
		return false;
d1461 1
a1461 1
		return false;
d1467 1
a1467 1
  return true;
d1474 1
a1474 1
boolean
d1483 2
a1484 2
  elf_flags_init (abfd) = true;
  return true;
d1490 1
a1490 1
boolean
d1497 1
a1497 1
  boolean ok = true;
d1500 2
a1501 2
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;
d1505 1
a1505 1
    return true;
d1513 1
a1513 1
      elf_flags_init (obfd) = true;
d1523 1
a1523 1
	    return false;
d1526 1
a1526 1
      return true;
d1536 1
a1536 1
      ok = false;
d1544 1
a1544 1
      ok = false;
d1556 1
a1556 1
      ok = false;
d1562 1
a1562 1
      return false;
d1565 1
a1565 1
  return true;
d1568 1
a1568 1
boolean
d1600 1
a1600 1
  return true;
@


1.12
log
@	* elfxx-target.h (USE_REL): Don't define as 1.
	* elf32-arm.h (USE_REL): Provide a default define of 0.
	Use #if rather than #ifdef when testing USE_REL.
	* elf32-m32r.c: Likewise.

	* elf32-arc.c (USE_REL): Define as 1.
	* elf32-d10v.c (USE_REL): Likewise.
	* elf32-m32r.c (USE_REL): Likewise.
	* elf32-m68hc11.c (USE_REL): Likewise.
	* elf32-m68hc12.c (USE_REL): Likewise.
	* elf32-or32.c (USE_REL): Likewise.
	* elfarm-nabi.c (USE_REL): Likewise.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d395 1
a395 1
     Elf32_Internal_Rel *dst;
@


1.11
log
@	* elf32-m68hc11.c (m68hc11_elf_relax_section): Don't treat relocs
	with symbols in other sections if we relaxed something;  the sections
	output offsets must be re-computed before.
@
text
@d65 1
a65 1
#define USE_REL
@


1.10
log
@	* elf32-m68hc11.c (m68hc11_elf_relax_section): Update symbols
	handling to use Elf_Internal_Sym.
	(m68hc11_elf_relax_delete_bytes): Likewise.
@
text
@d696 1
a794 2
          asection *sym_sec;

d821 2
d824 2
a825 2
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
d842 26
d913 1
d935 2
d954 2
d991 1
a991 2
          /* That will change things, so, we should relax again.
             Note that this is not required, and it may be slow.  */
d1033 2
@


1.9
log
@	* elf32-m68hc11.c: Formatting fixes.
	(elf32_m68hc11_gc_mark_hook): Correct params.  Remove unnecessary test.
	* elf32-m68hc12.c: Formatting fixes.
	(elf32_m68hc11_gc_mark_hook): Correct params.  Remove unnecessary test.
@
text
@a648 1
  Elf32_External_Sym *extsyms = NULL;
d653 1
a653 1
  Elf_External_Sym_Shndx *shndx_buf = NULL;
d695 1
a695 1
      Elf_Internal_Sym isym;
d779 1
a779 1
      if (extsyms == NULL)
d781 7
a787 29
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      /* Go get them off disk.  */
	      bfd_size_type amt = symtab_hdr->sh_size;
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	    }

	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (PTR) shndx_buf;
	    }
a792 4
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  asection *sym_sec;

d794 1
a794 3
	  esym = extsyms + ELF32_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d796 3
a798 2
	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
d837 1
a837 1
          insn_group_value = isym.st_value;
d914 1
a914 1
              symtab_hdr->contents = (bfd_byte *) extsyms;
d943 1
a943 1
          symtab_hdr->contents = (bfd_byte *) extsyms;
d989 1
a989 1
                  symtab_hdr->contents = (bfd_byte *) extsyms;
d1033 1
a1033 1
	  symtab_hdr->contents = (unsigned char *) extsyms;
a1059 2
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
a1060 1
  Elf_External_Sym_Shndx *shndx;
d1064 1
a1064 1
  Elf32_External_Sym *esym, *esymend;
d1070 1
a1070 1
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
d1084 1
d1086 1
a1086 1

d1185 2
a1186 5
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
d1188 4
a1191 12
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym, &dummy);
	}
@


1.9.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d65 1
a65 1
#define USE_REL	1
d649 1
d654 1
a654 1
  Elf_Internal_Sym *isymbuf = NULL;
d696 1
a696 2
      Elf_Internal_Sym *isym;
      asection *sym_sec;
d780 1
a780 1
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d782 29
a810 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d816 4
d821 6
a826 3
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
a849 2
          isym = 0;
          sym_sec = h->root.u.def.section;
d851 2
a852 2
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
d865 1
a865 1
          insn_group_value = isym->st_value;
a868 26
      /* When we relax some bytes, the size of our section changes.
         This affects the layout of next input sections that go in our
         output section.  When the symbol is part of another section that
         will go in the same output section as the current one, it's
         final address may now be incorrect (too far).  We must let the
         linker re-compute all section offsets before processing this
         reloc.  Code example:

                                Initial             Final
         .sect .text            section size = 6    section size = 4
         jmp foo
         jmp bar
         .sect .text.foo_bar    output_offset = 6   output_offset = 4
         foo: rts
         bar: rts

         If we process the reloc now, the jmp bar is replaced by a
         relative branch to the initial bar address (output_offset 6).  */
      if (*again && sym_sec != sec
          && sym_sec->output_section == sec->output_section)
        {
          prev_insn_group = 0;
          prev_insn_branch = 0;
          continue;
        }
      
a913 1
          *again = true;
a934 2
              unsigned long old_sec_size = sec->_cooked_size;
              
d942 1
a942 1
              symtab_hdr->contents = (bfd_byte *) isymbuf;
a951 2
              if (sec->_cooked_size != old_sec_size)
                *again = true;
d971 1
a971 1
          symtab_hdr->contents = (bfd_byte *) isymbuf;
d987 2
a988 1
          /* That will change things, so, we should relax again.  */
d1017 1
a1017 1
                  symtab_hdr->contents = (bfd_byte *) isymbuf;
a1029 2
                  /* That will change things, so, we should relax again.  */
                  *again = true;
d1061 1
a1061 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1088 2
d1091 1
d1095 1
a1095 1
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
d1101 1
a1101 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1115 1
a1116 2
  sec->_cooked_size -= count;
  
d1215 5
a1219 2
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
d1221 12
a1232 4
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
@


1.9.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a26 1
#include "elf32-m68hc1x.h"
a27 1
#include "opcode/m68hc11.h"
a28 1
/* Relocation functions.  */
d30 1
a30 1
  (bfd *, bfd_reloc_code_real_type);
d32 1
a32 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d34 18
a51 11
/* Trampoline generation.  */
static bfd_boolean m68hc11_elf_size_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static bfd_boolean m68hc11_elf_build_one_stub
  (struct bfd_hash_entry *gen_entry, void *in_arg);
static struct bfd_link_hash_table* m68hc11_elf_bfd_link_hash_table_create
  (bfd* abfd);

/* Linker relaxation.  */
static bfd_boolean m68hc11_elf_relax_section
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
d53 1
a53 1
  (bfd *, asection *, bfd_vma, int);
d55 8
a62 2
  (bfd *, asection *, bfd_byte *, unsigned, unsigned long, unsigned long);
static int compare_reloc (const void *, const void *);
d67 1
a67 2
/* The Motorola 68HC11 microcontroller only addresses 64Kb but we also
   support a memory bank switching mechanism similar to 68HC12.
d69 2
a70 2
   are used for debugging sections (DWARF2) to represent a virtual
   address.
d78 1
a78 1
	 FALSE,			/* pc_relative */
d83 1
a83 1
	 FALSE,			/* partial_inplace */
d86 1
a86 1
	 FALSE),		/* pcrel_offset */
d93 1
a93 1
	 FALSE,			/* pc_relative */
d98 1
a98 1
	 FALSE,			/* partial_inplace */
d101 1
a101 1
	 FALSE),		/* pcrel_offset */
d108 1
a108 1
	 FALSE,			/* pc_relative */
d113 1
a113 1
	 FALSE,			/* partial_inplace */
d116 1
a116 1
	 FALSE),		/* pcrel_offset */
d123 1
a123 1
	 FALSE,			/* pc_relative */
d128 1
a128 1
	 FALSE,			/* partial_inplace */
d131 1
a131 1
	 FALSE),		/* pcrel_offset */
d138 1
a138 1
	 TRUE,			/* pc_relative */
d143 1
a143 1
	 FALSE,			/* partial_inplace */
d146 1
a146 1
	 TRUE),                 /* pcrel_offset */
d153 1
a153 1
	 FALSE,			/* pc_relative */
d158 1
a158 1
	 FALSE,			/* partial_inplace */
d161 1
a161 1
	 FALSE),		/* pcrel_offset */
d169 1
a169 1
	 FALSE,			/* pc_relative */
d174 1
a174 1
	 FALSE,			/* partial_inplace */
d177 1
a177 1
	 FALSE),		/* pcrel_offset */
d184 1
a184 1
	 FALSE,			/* pc_relative */
d189 1
a189 1
	 FALSE,			/* partial_inplace */
d192 1
a192 1
	 FALSE),		/* pcrel_offset */
d199 1
a199 1
	 TRUE,			/* pc_relative */
d204 1
a204 1
	 FALSE,			/* partial_inplace */
d207 1
a207 1
	 TRUE),                 /* pcrel_offset */
d214 1
a214 1
	 FALSE,			/* pc_relative */
d219 1
a219 1
	 FALSE,			/* partial_inplace */
d222 1
a222 1
	 FALSE),		/* pcrel_offset */
d229 1
a229 1
	 FALSE,			/* pc_relative */
d234 1
a234 1
	 FALSE,			/* partial_inplace */
d237 1
a237 1
	 FALSE),		/* pcrel_offset */
d244 1
a244 1
	 FALSE,			/* pc_relative */
d249 5
a253 5
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

d259 1
a259 1
	 FALSE,			/* pc_relative */
d264 1
a264 1
	 FALSE,			/* partial_inplace */
d267 1
a267 1
	 FALSE),		/* pcrel_offset */
d274 1
a274 1
	 FALSE,			/* pc_relative */
d279 1
a279 1
	 FALSE,			/* partial_inplace */
d282 1
a282 1
	 FALSE),		/* pcrel_offset */
d290 1
a290 1

d296 1
a296 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 TRUE,			/* partial_inplace */
d304 1
a304 1
	 TRUE),                 /* pcrel_offset */
d311 1
a311 1
	 FALSE,			/* pc_relative */
d316 1
a316 1
	 TRUE,			/* partial_inplace */
d319 1
a319 1
	 TRUE),                 /* pcrel_offset */
d353 3
a355 2
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
d370 19
d392 4
a395 2
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
d404 7
a410 6

/* Far trampoline generation.  */

/* Build a 68HC11 trampoline stub.  */
static bfd_boolean
m68hc11_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d412 10
a421 52
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 10;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     pshb
     ldab #%page(symbol)
     ldy #%addr(symbol)
     jmp __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* pshb; ldab #%page(sym) */
  bfd_put_8 (stub_bfd, 0x37, loc);
  bfd_put_8 (stub_bfd, 0xC6, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 2);
  loc += 3;

  /* ldy #%addr(sym)  */
  bfd_put_8 (stub_bfd, 0x18, loc);
  bfd_put_8 (stub_bfd, 0xCE, loc + 1);
  bfd_put_16 (stub_bfd, phys_addr, loc + 2);
  loc += 4;

  /* jmp __trampoline  */
  bfd_put_8 (stub_bfd, 0x7E, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
d423 2
a424 2
  return TRUE;
}
d426 7
a432 2
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */
d434 1
a434 11
static bfd_boolean
m68hc11_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->_raw_size += 10;
  return TRUE;
d437 6
a442 4
/* Create a 68HC11 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc11_elf_bfd_link_hash_table_create (bfd *abfd)
d444 2
a445 10
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc11_elf_size_one_stub;
  ret->build_one_stub = m68hc11_elf_build_one_stub;

  return &ret->root.root;
d448 1
a448 4

/* 68HC11 Linker Relaxation.  */

struct m68hc11_direct_relax
d504 3
a506 1
compare_reloc (const void *e1, const void *e2)
d520 7
a526 3
m68hc11_relax_group (bfd *abfd, asection *sec, bfd_byte *contents,
                     unsigned value, unsigned long offset,
                     unsigned long end_group)
d632 1
a632 1

d635 6
a640 3
static bfd_boolean
m68hc11_elf_relax_section (bfd *abfd, asection *sec,
                           struct bfd_link_info *link_info, bfd_boolean *again)
d656 1
a656 1
  *again = FALSE;
d658 1
a658 1
  /* We don't have to do anything for a relocatable link, if
d661 1
a661 1
  if (link_info->relocatable
d665 1
a665 1
    return TRUE;
d676 1
a676 1
  internal_relocs = (_bfd_elf_link_read_relocs
a696 1
      int is_far = 0;
d748 1
a748 1

d750 1
a750 1
	  if (irel->r_offset + 2 >= sec->_cooked_size)
a795 1
          is_far = isym->st_other & STO_M68HC12_FAR;
a820 1
          is_far = h->other & STO_M68HC12_FAR;
d832 1
a832 1

d867 1
a867 1

d894 1
a894 1
              bfd_put_8 (abfd, 0xff,
a895 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d897 1
a897 1
                                           R_M68HC11_PCREL_8);
d899 1
a899 1
                                              irel->r_offset + 1, 1);
d905 1
a905 1
              bfd_put_8 (abfd, 0xff,
a906 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d908 1
a908 1
                                           R_M68HC11_PCREL_8);
d910 1
a910 1
                                              irel->r_offset + 1, 3);
d913 1
a913 1
          *again = TRUE;
d936 2
a937 2

              /* Note that we've changed the relocation contents, etc.  */
d955 1
a955 1
                *again = TRUE;
d958 1
a958 1

d968 1
a968 1
          /* Note that we've changed the relocation contents, etc.  */
d992 1
a992 1
          *again = TRUE;
d994 1
a994 1
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16 && !is_far)
d1001 1
a1001 1
          if (code == 0x7e || code == 0xbd)
d1013 1
a1013 1
                  /* Note that we've changed the relocation contents, etc.  */
d1016 1
a1016 1

d1019 1
a1019 1

d1024 1
a1024 1
                  code = (code == 0x7e) ? 0x20 : 0x8d;
d1027 1
a1027 1
                  bfd_put_8 (abfd, 0xff,
d1030 1
a1030 1
                                               R_M68HC11_PCREL_8);
d1034 1
a1034 1
                  *again = TRUE;
a1038 1
      prev_insn_group = 0;
d1071 1
a1071 1
  return TRUE;
d1080 1
a1080 1
  return FALSE;
d1086 5
a1090 2
m68hc11_elf_relax_delete_bytes (bfd *abfd, asection *sec,
                                bfd_vma addr, int count)
d1119 1
a1119 1

d1197 1
a1197 1
          if (irel->r_offset < addr && raddr > addr)
d1212 1
a1212 1

d1223 1
a1223 1
	  && isym->st_value <= toaddr)
d1239 1
a1239 1
	  && sym_hash->root.u.def.value <= toaddr)
d1246 73
a1318 7
/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC11. Soft registers used by GCC-m6811
     are located in .page0.
   - The .vectors is the section that represents the interrupt
     vectors.  */
static struct bfd_elf_special_section const elf32_m68hc11_special_sections[]=
d1320 151
a1470 6
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
};
d1472 133
a1618 1
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook
a1621 6
#define elf_backend_special_sections elf32_m68hc11_special_sections

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc11_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
@


1.9.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d65 1
a65 1
#define USE_REL	1
d649 1
d654 1
a654 1
  Elf_Internal_Sym *isymbuf = NULL;
d696 1
a696 2
      Elf_Internal_Sym *isym;
      asection *sym_sec;
d780 1
a780 1
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d782 29
a810 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d816 4
d821 6
a826 3
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
a849 2
          isym = 0;
          sym_sec = h->root.u.def.section;
d851 2
a852 2
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
d865 1
a865 1
          insn_group_value = isym->st_value;
a868 26
      /* When we relax some bytes, the size of our section changes.
         This affects the layout of next input sections that go in our
         output section.  When the symbol is part of another section that
         will go in the same output section as the current one, it's
         final address may now be incorrect (too far).  We must let the
         linker re-compute all section offsets before processing this
         reloc.  Code example:

                                Initial             Final
         .sect .text            section size = 6    section size = 4
         jmp foo
         jmp bar
         .sect .text.foo_bar    output_offset = 6   output_offset = 4
         foo: rts
         bar: rts

         If we process the reloc now, the jmp bar is replaced by a
         relative branch to the initial bar address (output_offset 6).  */
      if (*again && sym_sec != sec
          && sym_sec->output_section == sec->output_section)
        {
          prev_insn_group = 0;
          prev_insn_branch = 0;
          continue;
        }
      
a913 1
          *again = true;
a934 2
              unsigned long old_sec_size = sec->_cooked_size;
              
d942 1
a942 1
              symtab_hdr->contents = (bfd_byte *) isymbuf;
a951 2
              if (sec->_cooked_size != old_sec_size)
                *again = true;
d971 1
a971 1
          symtab_hdr->contents = (bfd_byte *) isymbuf;
d987 2
a988 1
          /* That will change things, so, we should relax again.  */
d1017 1
a1017 1
                  symtab_hdr->contents = (bfd_byte *) isymbuf;
a1029 2
                  /* That will change things, so, we should relax again.  */
                  *again = true;
d1061 1
a1061 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1088 2
d1091 1
d1095 1
a1095 1
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
d1101 1
a1101 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1115 1
a1116 2
  sec->_cooked_size -= count;
  
d1215 5
a1219 2
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
d1221 12
a1232 4
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
@


1.9.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d41 1
a41 1
static bfd_boolean elf32_m68hc11_gc_sweep_hook
d44 1
a44 1
static bfd_boolean elf32_m68hc11_check_relocs
d47 1
a47 1
static bfd_boolean elf32_m68hc11_relocate_section
d50 2
a51 2
static bfd_boolean m68hc11_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d60 3
a62 3
bfd_boolean _bfd_m68hc11_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
bfd_boolean _bfd_m68hc11_elf_set_private_flags PARAMS ((bfd *, flagword));
bfd_boolean _bfd_m68hc11_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d78 1
a78 1
	 FALSE,			/* pc_relative */
d83 1
a83 1
	 FALSE,			/* partial_inplace */
d86 1
a86 1
	 FALSE),		/* pcrel_offset */
d93 1
a93 1
	 FALSE,			/* pc_relative */
d98 1
a98 1
	 FALSE,			/* partial_inplace */
d101 1
a101 1
	 FALSE),		/* pcrel_offset */
d108 1
a108 1
	 FALSE,			/* pc_relative */
d113 1
a113 1
	 FALSE,			/* partial_inplace */
d116 1
a116 1
	 FALSE),		/* pcrel_offset */
d123 1
a123 1
	 FALSE,			/* pc_relative */
d128 1
a128 1
	 FALSE,			/* partial_inplace */
d131 1
a131 1
	 FALSE),		/* pcrel_offset */
d138 1
a138 1
	 TRUE,			/* pc_relative */
d143 1
a143 1
	 FALSE,			/* partial_inplace */
d146 1
a146 1
	 FALSE),		/* pcrel_offset */
d153 1
a153 1
	 FALSE,			/* pc_relative */
d158 1
a158 1
	 FALSE,			/* partial_inplace */
d161 1
a161 1
	 FALSE),		/* pcrel_offset */
d169 1
a169 1
	 FALSE,			/* pc_relative */
d174 1
a174 1
	 FALSE,			/* partial_inplace */
d177 1
a177 1
	 FALSE),		/* pcrel_offset */
d184 1
a184 1
	 FALSE,			/* pc_relative */
d189 1
a189 1
	 FALSE,			/* partial_inplace */
d192 1
a192 1
	 FALSE),		/* pcrel_offset */
d199 1
a199 1
	 TRUE,			/* pc_relative */
d204 1
a204 1
	 FALSE,			/* partial_inplace */
d207 1
a207 1
	 FALSE),		/* pcrel_offset */
d214 1
a214 1
	 FALSE,			/* pc_relative */
d219 1
a219 1
	 FALSE,			/* partial_inplace */
d222 1
a222 1
	 FALSE),		/* pcrel_offset */
d229 1
a229 1
	 FALSE,			/* pc_relative */
d234 1
a234 1
	 FALSE,			/* partial_inplace */
d237 1
a237 1
	 FALSE),		/* pcrel_offset */
d244 1
a244 1
	 FALSE,			/* pc_relative */
d249 1
a249 1
	 FALSE,			/* partial_inplace */
d252 2
a253 2
	 FALSE),		/* pcrel_offset */

d259 1
a259 1
	 FALSE,			/* pc_relative */
d264 1
a264 1
	 FALSE,			/* partial_inplace */
d267 1
a267 1
	 FALSE),		/* pcrel_offset */
d274 1
a274 1
	 FALSE,			/* pc_relative */
d279 1
a279 1
	 FALSE,			/* partial_inplace */
d282 1
a282 1
	 FALSE),		/* pcrel_offset */
d290 1
a290 1

d296 1
a296 1
	 FALSE,			/* pc_relative */
d301 1
a301 1
	 TRUE,			/* partial_inplace */
d304 1
a304 1
	 TRUE),                 /* pcrel_offset */
d311 1
a311 1
	 FALSE,			/* pc_relative */
d316 1
a316 1
	 TRUE,			/* partial_inplace */
d319 1
a319 1
	 TRUE),                 /* pcrel_offset */
d395 1
a395 1
     Elf_Internal_Rela *dst;
d437 1
a437 1
static bfd_boolean
d445 1
a445 1
  return TRUE;
d448 1
a448 1
struct m68hc11_direct_relax
d632 1
a632 1

d635 1
a635 1
static bfd_boolean
d640 1
a640 1
     bfd_boolean *again;
d656 1
a656 1
  *again = FALSE;
d665 1
a665 1
    return TRUE;
d748 1
a748 1

d832 1
a832 1

d867 1
a867 1

d913 1
a913 1
          *again = TRUE;
d936 1
a936 1

d955 1
a955 1
                *again = TRUE;
d958 1
a958 1

d992 1
a992 1
          *again = TRUE;
d1016 1
a1016 1

d1019 1
a1019 1

d1034 1
a1034 1
                  *again = TRUE;
d1071 1
a1071 1
  return TRUE;
d1080 1
a1080 1
  return FALSE;
d1119 1
a1119 1

d1197 1
a1197 1
          if (irel->r_offset < addr && raddr > addr)
d1212 1
a1212 1

d1250 1
a1250 1
static bfd_boolean
d1264 1
a1264 1
    return TRUE;
d1292 1
a1292 1
            return FALSE;
d1299 1
a1299 1
            return FALSE;
d1304 1
a1304 1
  return TRUE;
d1308 1
a1308 1
static bfd_boolean
d1401 2
a1402 2
		     input_section, rel->r_offset, TRUE)))
		return FALSE;
d1431 1
a1431 1
		return FALSE;
d1437 2
a1438 2
		     rel->r_offset, TRUE)))
		return FALSE;
d1461 1
a1461 1
		return FALSE;
d1467 1
a1467 1
  return TRUE;
d1474 1
a1474 1
bfd_boolean
d1483 2
a1484 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1490 1
a1490 1
bfd_boolean
d1497 1
a1497 1
  bfd_boolean ok = TRUE;
d1500 2
a1501 2
  if (!_bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;
d1505 1
a1505 1
    return TRUE;
d1513 1
a1513 1
      elf_flags_init (obfd) = TRUE;
d1523 1
a1523 1
	    return FALSE;
d1526 1
a1526 1
      return TRUE;
d1536 1
a1536 1
      ok = FALSE;
d1544 1
a1544 1
      ok = FALSE;
d1556 1
a1556 1
      ok = FALSE;
d1562 1
a1562 1
      return FALSE;
d1565 1
a1565 1
  return TRUE;
d1568 1
a1568 1
bfd_boolean
d1600 1
a1600 1
  return TRUE;
@


1.9.10.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d146 1
a146 1
	 TRUE),                 /* pcrel_offset */
d207 1
a207 1
	 TRUE),                 /* pcrel_offset */
d250 2
a251 2
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
a447 3

/* 68HC11 Linker Relaxation.  */

a696 1
      int is_far = 0;
d750 1
a750 1
	  if (irel->r_offset + 2 >= sec->_cooked_size)
a795 1
          is_far = isym->st_other & STO_M68HC12_FAR;
a820 1
          is_far = h->other & STO_M68HC12_FAR;
d894 1
a894 1
              bfd_put_8 (abfd, 0xff,
a895 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d897 1
a897 1
                                           R_M68HC11_PCREL_8);
d899 1
a899 1
                                              irel->r_offset + 1, 1);
d905 1
a905 1
              bfd_put_8 (abfd, 0xff,
a906 1
              irel->r_offset = prev_insn_branch->r_offset + 1;
d908 1
a908 1
                                           R_M68HC11_PCREL_8);
d910 1
a910 1
                                              irel->r_offset + 1, 3);
d994 1
a994 1
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16 && !is_far)
d1001 1
a1001 1
          if (code == 0x7e || code == 0xbd)
d1024 1
a1024 1
                  code = (code == 0x7e) ? 0x20 : 0x8d;
d1027 1
a1027 1
                  bfd_put_8 (abfd, 0xff,
d1030 1
a1030 1
                                               R_M68HC11_PCREL_8);
d1223 1
a1223 1
	  && isym->st_value <= toaddr)
d1239 1
a1239 1
	  && sym_hash->root.u.def.value <= toaddr)
@


1.9.10.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a26 1
#include "elf32-m68hc1x.h"
a27 1
#include "opcode/m68hc11.h"
a28 1
/* Relocation functions.  */
d34 2
a35 7
/* Trampoline generation.  */
static bfd_boolean m68hc11_elf_size_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static bfd_boolean m68hc11_elf_build_one_stub
  PARAMS((struct bfd_hash_entry *gen_entry, PTR in_arg));
static struct bfd_link_hash_table* m68hc11_elf_bfd_link_hash_table_create
  PARAMS ((bfd* abfd));
d37 13
a49 1
/* Linker relaxation.  */
d59 5
d67 1
a67 2
/* The Motorola 68HC11 microcontroller only addresses 64Kb but we also
   support a memory bank switching mechanism similar to 68HC12.
d69 2
a70 2
   are used for debugging sections (DWARF2) to represent a virtual
   address.
d370 19
d404 21
a424 2

/* Far trampoline generation.  */
d426 7
a432 58
/* Build a 68HC11 trampoline stub.  */
static bfd_boolean
m68hc11_elf_build_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg;
{
  struct elf32_m68hc11_stub_hash_entry *stub_entry;
  struct bfd_link_info *info;
  struct m68hc11_elf_link_hash_table *htab;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value, phys_page, phys_addr;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  htab = m68hc11_elf_hash_table (info);

  stub_sec = stub_entry->stub_sec;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->_raw_size;
  stub_sec->_raw_size += 10;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* Create the trampoline call stub:

     pshb
     ldab #%page(symbol)
     ldy #%addr(symbol)
     jmp __trampoline

  */
  sym_value = (stub_entry->target_value
               + stub_entry->target_section->output_offset
               + stub_entry->target_section->output_section->vma);
  phys_addr = m68hc11_phys_addr (&htab->pinfo, sym_value);
  phys_page = m68hc11_phys_page (&htab->pinfo, sym_value);

  /* pshb; ldab #%page(sym) */
  bfd_put_8 (stub_bfd, 0x37, loc);
  bfd_put_8 (stub_bfd, 0xC6, loc + 1);
  bfd_put_8 (stub_bfd, phys_page, loc + 2);
  loc += 3;

  /* ldy #%addr(sym)  */
  bfd_put_8 (stub_bfd, 0x18, loc);
  bfd_put_8 (stub_bfd, 0xCE, loc + 1);
  bfd_put_16 (stub_bfd, phys_addr, loc + 2);
  loc += 4;

  /* jmp __trampoline  */
  bfd_put_8 (stub_bfd, 0x7E, loc);
  bfd_put_16 (stub_bfd, htab->pinfo.trampoline_addr, loc + 1);
d434 1
a434 1
  return TRUE;
a436 3
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

d438 5
a442 3
m68hc11_elf_size_one_stub (gen_entry, in_arg)
     struct bfd_hash_entry *gen_entry;
     PTR in_arg ATTRIBUTE_UNUSED;
d444 1
a444 6
  struct elf32_m68hc11_stub_hash_entry *stub_entry;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_m68hc11_stub_hash_entry *) gen_entry;

  stub_entry->stub_sec->_raw_size += 10;
a447 18
/* Create a 68HC11 ELF linker hash table.  */

static struct bfd_link_hash_table *
m68hc11_elf_bfd_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct m68hc11_elf_link_hash_table *ret;

  ret = m68hc11_elf_hash_table_create (abfd);
  if (ret == (struct m68hc11_elf_link_hash_table *) NULL)
    return NULL;

  ret->size_one_stub = m68hc11_elf_size_one_stub;
  ret->build_one_stub = m68hc11_elf_build_one_stub;

  return &ret->root.root;
}

a1046 1
      prev_insn_group = 0;
d1254 225
d1480 133
a1626 1
#define elf_backend_add_symbol_hook  elf32_m68hc11_add_symbol_hook
a1629 5

#define bfd_elf32_bfd_link_hash_table_create \
                                m68hc11_elf_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
				m68hc11_elf_bfd_link_hash_table_free
@


1.9.10.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d708 1
a708 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.9.10.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d690 1
a690 1
  /* We don't have to do anything for a relocatable link, if
d693 1
a693 1
  if (link_info->relocatable
@


1.9.10.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a1283 19
/* Specific sections:
   - The .page0 is a data section that is mapped in [0x0000..0x00FF].
     Page0 accesses are faster on the M68HC11. Soft registers used by GCC-m6811
     are located in .page0.
   - The .vectors is the data section that represents the interrupt
     vectors.  */
static struct bfd_elf_special_section const elf32_m68hc11_special_sections[]=
{
  { ".eeprom",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".softregs",	0,	NULL,	0,
    SHT_NOBITS,	SHF_ALLOC + SHF_WRITE },
  { ".page0",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".vectors",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
};
a1302 1
#define elf_backend_special_sections elf32_m68hc11_special_sections
@


1.9.10.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1288 1
a1288 1
   - The .vectors is the section that represents the interrupt
d1299 1
a1299 1
    SHT_PROGBITS,	SHF_ALLOC },
@


1.9.10.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d33 1
a33 1
  (bfd *, bfd_reloc_code_real_type);
d35 1
a35 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d39 1
a39 1
  (struct bfd_hash_entry *gen_entry, void *in_arg);
d41 1
a41 1
  (struct bfd_hash_entry *gen_entry, void *in_arg);
d43 1
a43 1
  (bfd* abfd);
d47 1
a47 1
  (bfd *, asection *, struct bfd_link_info *, bfd_boolean *);
d49 1
a49 1
  (bfd *, asection *, bfd_vma, int);
d51 3
a53 2
  (bfd *, asection *, bfd_byte *, unsigned, unsigned long, unsigned long);
static int compare_reloc (const void *, const void *);
d345 3
a347 2
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
                                 bfd_reloc_code_real_type code)
d365 4
a368 2
m68hc11_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
                           arelent *cache_ptr, Elf_Internal_Rela *dst)
d382 3
a384 1
m68hc11_elf_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)
d446 3
a448 2
m68hc11_elf_size_one_stub (struct bfd_hash_entry *gen_entry,
                           void *in_arg ATTRIBUTE_UNUSED)
d462 2
a463 1
m68hc11_elf_bfd_link_hash_table_create (bfd *abfd)
d536 3
a538 1
compare_reloc (const void *e1, const void *e2)
d552 7
a558 3
m68hc11_relax_group (bfd *abfd, asection *sec, bfd_byte *contents,
                     unsigned value, unsigned long offset,
                     unsigned long end_group)
d668 5
a672 2
m68hc11_elf_relax_section (bfd *abfd, asection *sec,
                           struct bfd_link_info *link_info, bfd_boolean *again)
d1124 5
a1128 2
m68hc11_elf_relax_delete_bytes (bfd *abfd, asection *sec,
                                bfd_vma addr, int count)
d1292 10
a1301 5
  { ".eeprom",   7, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".softregs", 9, 0, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".page0",    6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".vectors",  8, 0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
@


1.9.10.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d957 1
a957 1
              /* Note that we've changed the relocation contents, etc.  */
d988 1
a988 1
          /* Note that we've changed the relocation contents, etc.  */
d1033 1
a1033 1
                  /* Note that we've changed the relocation contents, etc.  */
@


1.8
log
@	* elf32-m68hc11.c (m68hc11_relax_group): New to relax group of
	instructions.
	(m68hc11_direct_relax): New to define table of relaxable instructions.
	(find_relaxable_insn): New, find a relaxable insn.
	(compare_reloc): New to compare two relocs.
	(m68hc11_elf_relax_section): New, relax text sections.
	(m68hc11_elf_relax_delete_bytes): New, delete bytes and adjust branchs.
	(elf32_m68hc11_check_relocs): New function for GC support.
	(elf32_m68hc11_relocate_section): New function for GC support.
	(bfd_elf32_bfd_relax_section): Define to support linker relaxation.
	(elf_backend_check_relocs): Likewise.
	(elf_backend_relocate_section): Likewise.
@
text
@d30 1
a30 1
PARAMS ((bfd * abfd, bfd_reloc_code_real_type code));
d32 1
a32 1
PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d35 1
a35 3
PARAMS ((bfd *abfd, arelent *reloc_entry,
         asymbol *symbol, PTR data, asection *input_section,
         bfd *output_bfd, char **error_message));
d39 2
a40 3
PARAMS ((bfd *abfd, struct bfd_link_info *info,
         Elf_Internal_Rela *rel, struct elf_link_hash_entry *h,
         Elf_Internal_Sym *sym));
d42 2
a43 2
PARAMS ((bfd *abfd, struct bfd_link_info *info,
         asection *sec, const Elf_Internal_Rela *relocs));
d45 2
a46 2
PARAMS ((bfd * abfd, struct bfd_link_info * info,
         asection * sec, const Elf_Internal_Rela * relocs));
d48 2
a49 4
PARAMS ((bfd *output_bfd, struct bfd_link_info *info,
         bfd *input_bfd, asection *input_section,
         bfd_byte *contents, Elf_Internal_Rela *relocs,
         Elf_Internal_Sym *local_syms, asection **local_sections));
d53 1
a53 1
PARAMS ((bfd *abfd, asection *sec, bfd_vma addr, int count));
d55 3
a57 3
PARAMS ((bfd *abfd, asection *sec, bfd_byte *contents,
         unsigned value, unsigned long offset, unsigned long end_group));
static int compare_reloc PARAMS ((const void*, const void*));
d60 3
a62 3
boolean _bfd_m68hc11_elf_merge_private_bfd_data PARAMS ((bfd*, bfd*));
boolean _bfd_m68hc11_elf_set_private_flags PARAMS ((bfd*, flagword));
boolean _bfd_m68hc11_elf_print_private_bfd_data PARAMS ((bfd*, PTR));
d405 2
a406 2
elf32_m68hc11_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d432 2
a433 9
    {
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && !((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
	       && sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
    }
@


1.7
log
@	* elf32-m68hc11.c (elf32_m68hc11_gc_mark_hook): New for section GC.
	(elf32_m68hc11_gc_sweep_hook): Likewise.
	(elf_backend_gc_mark_hook): Define for GC section support.
	(elf_backend_gc_sweep_hook): Likewise.
	(elf_backend_can_gc_sections): Likewise.

	* elf32-m68hc12.c: Likewise.
@
text
@d24 1
d47 17
d460 1031
d1634 1
d1637 2
@


1.6
log
@Fix integration pb for:
    * elf32-m68hc11.c (elf_m68hc11_howto_table): Add the new relocs;
    fix masks for PC-rel relocs.
    (m68hc11_elf_ignore_reloc): New function.
@
text
@d38 9
d391 51
d585 2
d589 1
a589 1

@


1.5
log
@	* elf32-m68hc11.c (_bfd_m68hc11_elf_print_private_bfd_data): New.
	(_bfd_m68hc11_elf_merge_private_bfd_data): New function.
	(_bfd_m68hc11_elf_set_private_flags): New function.
	Use them to set/check/print ELF flags specific to 68HC11.

	* elf32-m68hc12.c (_bfd_m68hc12_elf_print_private_bfd_data): New.
	(_bfd_m68hc12_elf_merge_private_bfd_data): New function.
	(_bfd_m68hc12_elf_set_private_flags): New function.
	Use them to set/check/print ELF flags specific to 68HC12.
@
text
@d58 1
a58 1
	 complain_overflow_bitfield,	/* complain_on_overflow */
d217 45
a261 3
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
d321 4
@


1.4
log
@	* elf32-m68hc11.c (elf_m68hc11_howto_table): Add the new relocs;
	fix masks for PC-rel relocs.
	(m68hc11_elf_ignore_reloc): New function.

	* elf32-m68hc12.c (m68hc12_elf_special_reloc): New to handle specific
	68HC12 banked addressing relocs.
	(m68hc12_phys_addr): New to compute physical address of banked memory.
	(m68hc12_phys_page): Likewise for page.
	(m68hc12_addr_is_banked): New to see if address is in banked area.
	(elf_m68hc12_howto_table): Add new relocs and rename to xx12.
@
text
@d38 4
d336 132
d481 6
@


1.3
log
@Update copyright notices
@
text
@d2 2
a3 2
   Copyright 1999, 2000 Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@worldnet.fr)
d33 5
d118 1
a118 1
	 0x0,			/* src_mask */
d179 1
a179 1
	 0x0,			/* src_mask */
d212 40
a272 1
  /* The following relocs are defined but they probably don't work yet.  */
d275 3
d296 19
@


1.3.16.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
   Contributed by Stephane Carrez (stcarrez@@nerim.fr)
a23 1
#include "bfdlink.h"
d29 1
a29 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d31 1
a31 31
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));

static bfd_reloc_status_type m68hc11_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

/* GC mark and sweep.  */
static asection *elf32_m68hc11_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static boolean elf32_m68hc11_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean elf32_m68hc11_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean elf32_m68hc11_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static boolean m68hc11_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static void m68hc11_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
static void m68hc11_relax_group
  PARAMS ((bfd *, asection *, bfd_byte *, unsigned,
	   unsigned long, unsigned long));
static int compare_reloc PARAMS ((const void *, const void *));


boolean _bfd_m68hc11_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
boolean _bfd_m68hc11_elf_set_private_flags PARAMS ((bfd *, flagword));
boolean _bfd_m68hc11_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
d49 1
a49 1
	 complain_overflow_dont,/* complain_on_overflow */
d113 1
a113 1
	 0x00ff,		/* src_mask */
d174 1
a174 1
	 0xffff,		/* src_mask */
a206 82

  /* A 24 bit relocation */
  HOWTO (R_M68HC11_24,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_24",	/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
  
  /* A 16-bit low relocation */
  HOWTO (R_M68HC11_LO16,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_LO16",	/* name */
	 false,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* A page relocation */
  HOWTO (R_M68HC11_PAGE,        /* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M68HC11_PAGE",	/* name */
	 false,			/* partial_inplace */
	 0x00ff,		/* src_mask */
	 0x00ff,		/* dst_mask */
	 false),		/* pcrel_offset */

  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  
  /* Mark beginning of a jump instruction (any form).  */
  HOWTO (R_M68HC11_RL_JUMP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC11_RL_JUMP",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),                 /* pcrel_offset */

  /* Mark beginning of Gcc relaxation group instruction.  */
  HOWTO (R_M68HC11_RL_GROUP,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 m68hc11_elf_ignore_reloc,	/* special_function */
	 "R_M68HC11_RL_GROUP",	/* name */
	 true,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 true),                 /* pcrel_offset */
d228 1
a230 7

  {BFD_RELOC_M68HC11_LO16, R_M68HC11_LO16},
  {BFD_RELOC_M68HC11_PAGE, R_M68HC11_PAGE},
  {BFD_RELOC_M68HC11_24, R_M68HC11_24},

  {BFD_RELOC_M68HC11_RL_JUMP, R_M68HC11_RL_JUMP},
  {BFD_RELOC_M68HC11_RL_GROUP, R_M68HC11_RL_GROUP},
a250 19
/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
m68hc11_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                          output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

a265 1207
static asection *
elf32_m68hc11_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

static boolean
elf32_m68hc11_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
  /* We don't use got and plt entries for 68hc11/68hc12.  */
  return true;
}

struct m68hc11_direct_relax 
{
  const char *name;
  unsigned char code;
  unsigned char direct_code;
} m68hc11_direct_relax_table[] = {
  { "adca", 0xB9, 0x99 },
  { "adcb", 0xF9, 0xD9 },
  { "adda", 0xBB, 0x9B },
  { "addb", 0xFB, 0xDB },
  { "addd", 0xF3, 0xD3 },
  { "anda", 0xB4, 0x94 },
  { "andb", 0xF4, 0xD4 },
  { "cmpa", 0xB1, 0x91 },
  { "cmpb", 0xF1, 0xD1 },
  { "cpd",  0xB3, 0x93 },
  { "cpxy", 0xBC, 0x9C },
/* { "cpy",  0xBC, 0x9C }, */
  { "eora", 0xB8, 0x98 },
  { "eorb", 0xF8, 0xD8 },
  { "jsr",  0xBD, 0x9D },
  { "ldaa", 0xB6, 0x96 },
  { "ldab", 0xF6, 0xD6 },
  { "ldd",  0xFC, 0xDC },
  { "lds",  0xBE, 0x9E },
  { "ldxy", 0xFE, 0xDE },
  /*  { "ldy",  0xFE, 0xDE },*/
  { "oraa", 0xBA, 0x9A },
  { "orab", 0xFA, 0xDA },
  { "sbca", 0xB2, 0x92 },
  { "sbcb", 0xF2, 0xD2 },
  { "staa", 0xB7, 0x97 },
  { "stab", 0xF7, 0xD7 },
  { "std",  0xFD, 0xDD },
  { "sts",  0xBF, 0x9F },
  { "stxy", 0xFF, 0xDF },
  /*  { "sty",  0xFF, 0xDF },*/
  { "suba", 0xB0, 0x90 },
  { "subb", 0xF0, 0xD0 },
  { "subd", 0xB3, 0x93 },
  { 0, 0, 0 }
};

static struct m68hc11_direct_relax *
find_relaxable_insn (unsigned char code)
{
  int i;

  for (i = 0; m68hc11_direct_relax_table[i].name; i++)
    if (m68hc11_direct_relax_table[i].code == code)
      return &m68hc11_direct_relax_table[i];

  return 0;
}

static int
compare_reloc (e1, e2)
     const void *e1;
     const void *e2;
{
  const Elf_Internal_Rela *i1 = (const Elf_Internal_Rela *) e1;
  const Elf_Internal_Rela *i2 = (const Elf_Internal_Rela *) e2;

  if (i1->r_offset == i2->r_offset)
    return 0;
  else
    return i1->r_offset < i2->r_offset ? -1 : 1;
}

#define M6811_OP_LDX_IMMEDIATE (0xCE)

static void
m68hc11_relax_group (abfd, sec, contents, value, offset, end_group)
     bfd *abfd;
     asection *sec;
     bfd_byte *contents;
     unsigned value;
     unsigned long offset;
     unsigned long end_group;
{
  unsigned char code;
  unsigned long start_offset;
  unsigned long ldx_offset = offset;
  unsigned long ldx_size;
  int can_delete_ldx;
  int relax_ldy = 0;

  /* First instruction of the relax group must be a
     LDX #value or LDY #value.  If this is not the case,
     ignore the relax group.  */
  code = bfd_get_8 (abfd, contents + offset);
  if (code == 0x18)
    {
      relax_ldy++;
      offset++;
      code = bfd_get_8 (abfd, contents + offset);
    }
  ldx_size = offset - ldx_offset + 3;
  offset += 3;
  if (code != M6811_OP_LDX_IMMEDIATE || offset >= end_group)
    return;


  /* We can remove the LDX/LDY only when all bset/brclr instructions
     of the relax group have been converted to use direct addressing
     mode.  */
  can_delete_ldx = 1;
  while (offset < end_group)
    {
      unsigned isize;
      unsigned new_value;
      int bset_use_y;

      bset_use_y = 0;
      start_offset = offset;
      code = bfd_get_8 (abfd, contents + offset);
      if (code == 0x18)
        {
          bset_use_y++;
          offset++;
          code = bfd_get_8 (abfd, contents + offset);
        }

      /* Check the instruction and translate to use direct addressing mode.  */
      switch (code)
        {
          /* bset */
        case 0x1C:
          code = 0x14;
          isize = 3;
          break;

          /* brclr */
        case 0x1F:
          code = 0x13;
          isize = 4;
          break;

          /* brset */
        case 0x1E:
          code = 0x12;
          isize = 4;
          break;

          /* bclr */
        case 0x1D:
          code = 0x15;
          isize = 3;
          break;

          /* This instruction is not recognized and we are not
             at end of the relax group.  Ignore and don't remove
             the first LDX (we don't know what it is used for...).  */
        default:
          return;
        }
      new_value = (unsigned) bfd_get_8 (abfd, contents + offset + 1);
      new_value += value;
      if ((new_value & 0xff00) == 0 && bset_use_y == relax_ldy)
        {
          bfd_put_8 (abfd, code, contents + offset);
          bfd_put_8 (abfd, new_value, contents + offset + 1);
          if (start_offset != offset)
            {
              m68hc11_elf_relax_delete_bytes (abfd, sec, start_offset,
                                              offset - start_offset);
              end_group--;
            }
        }
      else
        {
          can_delete_ldx = 0;
        }
      offset = start_offset + isize;
    }
  if (can_delete_ldx)
    {
      /* Remove the move instruction (3 or 4 bytes win).  */
      m68hc11_elf_relax_delete_bytes (abfd, sec, ldx_offset, ldx_size);
    }
}

/* This function handles relaxing for the 68HC11.

   
	and somewhat more difficult to support.  */

static boolean
m68hc11_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  bfd_byte *free_contents = NULL;
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
  Elf_Internal_Rela *prev_insn_branch = NULL;
  Elf_Internal_Rela *prev_insn_group = NULL;
  unsigned insn_group_value = 0;
  Elf_External_Sym_Shndx *shndx_buf = NULL;

  /* Assume nothing changes.  */
  *again = false;

  /* We don't have to do anything for a relocateable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return true;

  /* If this is the first time we have been called for this section,
     initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf32_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  /* Checking for branch relaxation relies on the relocations to
     be sorted on 'r_offset'.  This is not guaranteed so we must sort.  */
  qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
         compare_reloc);

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_vma value;
      Elf_Internal_Sym isym;

      /* If this isn't something that can be relaxed, then ignore
	 this reloc.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_16
          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_JUMP
          && ELF32_R_TYPE (irel->r_info) != (int) R_M68HC11_RL_GROUP)
        {
          prev_insn_branch = 0;
          prev_insn_group = 0;
          continue;
        }

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	      if (contents == NULL)
		goto error_return;
	      free_contents = contents;

	      if (! bfd_get_section_contents (abfd, sec, contents,
					      (file_ptr) 0, sec->_raw_size))
		goto error_return;
	    }
	}

      /* Try to eliminate an unconditional 8 bit pc-relative branch
	 which immediately follows a conditional 8 bit pc-relative
	 branch around the unconditional branch.

	    original:		new:
	    bCC lab1		bCC' lab2
	    bra lab2
	   lab1:	       lab1:

	 This happens when the bCC can't reach lab2 at assembly time,
	 but due to other relaxations it can reach at link time.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_JUMP)
	{
	  Elf_Internal_Rela *nrel;
	  unsigned char code;
          unsigned char roffset;

          prev_insn_branch = 0;
          prev_insn_group = 0;
          
	  /* Do nothing if this reloc is the last byte in the section.  */
	  if (irel->r_offset == sec->_cooked_size)
	    continue;

	  /* See if the next instruction is an unconditional pc-relative
	     branch, more often than not this test will fail, so we
	     test it first to speed things up.  */
	  code = bfd_get_8 (abfd, contents + irel->r_offset + 2);
	  if (code != 0x7e)
	    continue;

	  /* Also make sure the next relocation applies to the next
	     instruction and that it's a pc-relative 8 bit branch.  */
	  nrel = irel + 1;
	  if (nrel == irelend
	      || irel->r_offset + 3 != nrel->r_offset
	      || ELF32_R_TYPE (nrel->r_info) != (int) R_M68HC11_16)
	    continue;

	  /* Make sure our destination immediately follows the
	     unconditional branch.  */
          roffset = bfd_get_8 (abfd, contents + irel->r_offset + 1);
          if (roffset != 3)
            continue;

          prev_insn_branch = irel;
          prev_insn_group = 0;
          continue;
        }

      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
	    {
	      /* Go get them off disk.  */
	      bfd_size_type amt = symtab_hdr->sh_size;
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		goto error_return;
	    }

	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;

	      amt = symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (PTR) shndx_buf;
	    }
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  asection *sym_sec;

	  /* A local symbol.  */
	  esym = extsyms + ELF32_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);

	  sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
	  symval = (isym.st_value
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    {
	      /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
              prev_insn_branch = 0;
              prev_insn_group = 0;
	      continue;
	    }

	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}

      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_RL_GROUP)
	{
          prev_insn_branch = 0;
          prev_insn_group = 0;
          
	  /* Do nothing if this reloc is the last byte in the section.  */
	  if (irel->r_offset == sec->_cooked_size)
	    continue;

          prev_insn_group = irel;
          insn_group_value = isym.st_value;
          continue;
        }

      value = symval;
      /* Try to turn a far branch to a near branch.  */
      if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
          && prev_insn_branch)
        {
          bfd_vma offset;
          unsigned char code;

          offset = value - (prev_insn_branch->r_offset
                            + sec->output_section->vma
                            + sec->output_offset + 2);

          /* If the offset is still out of -128..+127 range,
             leave that far branch unchanged.  */
          if ((offset & 0xff80) != 0 && (offset & 0xff80) != 0xff80)
            {
              prev_insn_branch = 0;
              continue;
            }

          /* Shrink the branch.  */
          code = bfd_get_8 (abfd, contents + prev_insn_branch->r_offset);
          if (code == 0x7e)
            {
              code = 0x20;
              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
              bfd_put_8 (abfd, offset,
                         contents + prev_insn_branch->r_offset + 1);
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_NONE);
              m68hc11_elf_relax_delete_bytes (abfd, sec,
                                              irel->r_offset, 1);
            }
          else
            {
              code ^= 0x1;
              bfd_put_8 (abfd, code, contents + prev_insn_branch->r_offset);
              bfd_put_8 (abfd, offset,
                         contents + prev_insn_branch->r_offset + 1);
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_NONE);
              m68hc11_elf_relax_delete_bytes (abfd, sec,
                                              irel->r_offset - 1, 3);
            }
          prev_insn_branch = 0;
        }

      /* Try to turn a 16 bit address into a 8 bit page0 address.  */
      else if (ELF32_R_TYPE (irel->r_info) == (int) R_M68HC11_16
               && (value & 0xff00) == 0)
	{
          unsigned char code;
          unsigned short offset;
          struct m68hc11_direct_relax *rinfo;

          prev_insn_branch = 0;
          offset = bfd_get_16 (abfd, contents + irel->r_offset);
          offset += value;
          if ((offset & 0xff00) != 0)
            {
              prev_insn_group = 0;
              continue;
            }

          if (prev_insn_group)
            {
              /* Note that we've changed the reldection contents, etc.  */
              elf_section_data (sec)->relocs = internal_relocs;
              free_relocs = NULL;

              elf_section_data (sec)->this_hdr.contents = contents;
              free_contents = NULL;

              symtab_hdr->contents = (bfd_byte *) extsyms;
              free_extsyms = NULL;

              m68hc11_relax_group (abfd, sec, contents, offset,
                                   prev_insn_group->r_offset,
                                   insn_group_value);
              irel = prev_insn_group;
              prev_insn_group = 0;
              irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                           R_M68HC11_NONE);
              continue;
            }
          
          /* Get the opcode.  */
          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
          rinfo = find_relaxable_insn (code);
          if (rinfo == 0)
            {
              prev_insn_group = 0;
              continue;
            }

          /* Note that we've changed the reldection contents, etc.  */
          elf_section_data (sec)->relocs = internal_relocs;
          free_relocs = NULL;

          elf_section_data (sec)->this_hdr.contents = contents;
          free_contents = NULL;

          symtab_hdr->contents = (bfd_byte *) extsyms;
          free_extsyms = NULL;

          /* Fix the opcode.  */
          /* printf ("A relaxable case : 0x%02x (%s)\n",
             code, rinfo->name); */
          bfd_put_8 (abfd, rinfo->direct_code,
                     contents + irel->r_offset - 1);

          /* Delete one byte of data (upper byte of address).  */
          m68hc11_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 1);

          /* Fix the relocation's type.  */
          irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                       R_M68HC11_8);

          /* That will change things, so, we should relax again.
             Note that this is not required, and it may be slow.  */
          *again = true;
        }
      else if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_16)
        {
          unsigned char code;
          bfd_vma offset;

          prev_insn_branch = 0;
          code = bfd_get_8 (abfd, contents + irel->r_offset - 1);
          if (code == 0x7e)
            {
              offset = value - (irel->r_offset
                                + sec->output_section->vma
                                + sec->output_offset + 1);
              offset += bfd_get_16 (abfd, contents + irel->r_offset);

              /* If the offset is still out of -128..+127 range,
                 leave that far branch unchanged.  */
              if ((offset & 0xff80) == 0 || (offset & 0xff80) == 0xff80)
                {

                  /* Note that we've changed the reldection contents, etc.  */
                  elf_section_data (sec)->relocs = internal_relocs;
                  free_relocs = NULL;
                  
                  elf_section_data (sec)->this_hdr.contents = contents;
                  free_contents = NULL;
                  
                  symtab_hdr->contents = (bfd_byte *) extsyms;
                  free_extsyms = NULL;

                  /* Shrink the branch.  */
                  code = 0x20;
                  bfd_put_8 (abfd, code,
                             contents + irel->r_offset - 1);
                  bfd_put_8 (abfd, offset,
                             contents + irel->r_offset);
                  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                               R_M68HC11_NONE);
                  m68hc11_elf_relax_delete_bytes (abfd, sec,
                                                  irel->r_offset + 1, 1);
                }
            }
        }
      prev_insn_branch = 0;
    }

  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
      free_contents = NULL;
    }

  if (free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (free_extsyms);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) extsyms;
	}
      free_extsyms = NULL;
    }

  return true;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (free_extsyms != NULL)
    free (free_extsyms);
  return false;
}

/* Delete some bytes from a section while relaxing.  */

static void
m68hc11_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  Elf32_External_Sym *extsyms;
  unsigned int sec_shndx;
  Elf_External_Sym_Shndx *shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  bfd_vma toaddr;
  Elf32_External_Sym *esym, *esymend;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->_cooked_size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   (size_t) (toaddr - addr - count));
  sec->_cooked_size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      unsigned char code;
      unsigned char offset;
      unsigned short raddr;
      unsigned long old_offset;
      int branch_pos;

      old_offset = irel->r_offset;

      /* See if this reloc was for the bytes we have deleted, in which
	 case we no longer care about it.  Don't delete relocs which
	 represent addresses, though.  */
      if (ELF32_R_TYPE (irel->r_info) != R_M68HC11_RL_JUMP
          && irel->r_offset >= addr && irel->r_offset < addr + count)
        irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                     R_M68HC11_NONE);

      if (ELF32_R_TYPE (irel->r_info) == R_M68HC11_NONE)
        continue;

      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
	   && irel->r_offset < toaddr))
	irel->r_offset -= count;

      /* If this is a PC relative reloc, see if the range it covers
         includes the bytes we have deleted.  */
      switch (ELF32_R_TYPE (irel->r_info))
	{
	default:
	  break;

	case R_M68HC11_RL_JUMP:
          code = bfd_get_8 (abfd, contents + irel->r_offset);
          switch (code)
            {
              /* jsr and jmp instruction are also marked with RL_JUMP
                 relocs but no adjustment must be made.  */
            case 0x7e:
            case 0x9d:
            case 0xbd:
              continue;

            case 0x12:
            case 0x13:
              branch_pos = 3;
              raddr = 4;

              /* Special case when we translate a brclr N,y into brclr *<addr>
                 In this case, the 0x18 page2 prefix is removed.
                 The reloc offset is not modified but the instruction
                 size is reduced by 1.  */
              if (old_offset == addr)
                raddr++;
              break;

            case 0x1e:
            case 0x1f:
              branch_pos = 3;
              raddr = 4;
              break;

            case 0x18:
              branch_pos = 4;
              raddr = 5;
              break;

            default:
              branch_pos = 1;
              raddr = 2;
              break;
            }
          offset = bfd_get_8 (abfd, contents + irel->r_offset + branch_pos);
          raddr += old_offset;
          raddr += ((unsigned short) offset | ((offset & 0x80) ? 0xff00 : 0));
          if (irel->r_offset < addr && raddr >= addr)
            {
              offset -= count;
              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
            }
          else if (irel->r_offset >= addr && raddr <= addr)
            {
              offset += count;
              bfd_put_8 (abfd, offset, contents + irel->r_offset + branch_pos);
            }
          else
            {
              /*printf ("Not adjusted 0x%04x [0x%4x 0x%4x]\n", raddr,
                irel->r_offset, addr);*/
            }
          
          break;
	}
    }

  /* Adjust the local symbols defined in this section.  */
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, esym, &dummy);
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
	{
	  sym_hash->root.u.def.value -= count;
	}
    }
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static boolean
elf32_m68hc11_check_relocs (abfd, info, sec, relocs)
     bfd * abfd;
     struct bfd_link_info * info;
     asection * sec;
     const Elf_Internal_Rela * relocs;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  struct elf_link_hash_entry ** sym_hashes_end;
  const Elf_Internal_Rela *     rel;
  const Elf_Internal_Rela *     rel_end;

  if (info->relocateable)
    return true;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;

  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry * h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes [r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
        {
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_M68HC11_GNU_VTINHERIT:
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return false;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_M68HC11_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return false;
          break;
        }
    }

  return true;
}

/* Relocate a 68hc11/68hc12 ELF section.  */
static boolean
elf32_m68hc11_relocate_section (output_bfd, info, input_bfd, input_section,
                                contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;
  const char *name;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_type == R_M68HC11_GNU_VTENTRY
          || r_type == R_M68HC11_GNU_VTINHERIT )
        continue;

      howto = elf_m68hc11_howto_table + r_type;

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else
	    {
	      if (!((*info->callbacks->undefined_symbol)
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset, true)))
		return false;
	      relocation = 0;
	    }
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                    contents, rel->r_offset,
                                    relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) 0;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      if (!((*info->callbacks->reloc_overflow)
		    (info, name, howto->name, (bfd_vma) 0,
		     input_bfd, input_section, rel->r_offset)))
		return false;
	      break;

	    case bfd_reloc_undefined:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, name, input_bfd, input_section,
		     rel->r_offset, true)))
		return false;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _ ("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _ ("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _ ("internal error: dangerous error");
	      goto common_error;

	    default:
	      msg = _ ("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return false;
	      break;
	    }
	}
    }

  return true;
}



/* Set and control ELF flags in ELF header.  */

boolean
_bfd_m68hc11_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = true;
  return true;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

boolean
_bfd_m68hc11_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  flagword old_flags;
  flagword new_flags;
  boolean ok = true;

  /* Check if we have the same endianess */
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
    return false;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  new_flags = elf_elfheader (ibfd)->e_flags;
  elf_elfheader (obfd)->e_flags |= new_flags & EF_M68HC11_ABI;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = true;
      elf_elfheader (obfd)->e_flags = new_flags;
      elf_elfheader (obfd)->e_ident[EI_CLASS]
	= elf_elfheader (ibfd)->e_ident[EI_CLASS];

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	{
	  if (! bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
				   bfd_get_mach (ibfd)))
	    return false;
	}

      return true;
    }

  /* Check ABI compatibility.  */
  if ((new_flags & E_M68HC11_I32) != (old_flags & E_M68HC11_I32))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 16-bit integers (-mshort) "
           "and others for 32-bit integers"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }
  if ((new_flags & E_M68HC11_F64) != (old_flags & E_M68HC11_F64))
    {
      (*_bfd_error_handler)
	(_("%s: linking files compiled for 32-bit double (-fshort-double) "
           "and others for 64-bit double"),
	 bfd_archive_filename (ibfd));
      ok = false;
    }
  new_flags &= ~EF_M68HC11_ABI;
  old_flags &= ~EF_M68HC11_ABI;

  /* Warn about any other mismatches */
  if (new_flags != old_flags)
    {
      (*_bfd_error_handler)
	(_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	 bfd_archive_filename (ibfd), (unsigned long) new_flags,
	 (unsigned long) old_flags);
      ok = false;
    }

  if (! ok)
    {
      bfd_set_error (bfd_error_bad_value);
      return false;
    }

  return true;
}

boolean
_bfd_m68hc11_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_I32)
    fprintf (file, _("[abi=32-bit int,"));
  else
    fprintf (file, _("[abi=16-bit int,"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC11_F64)
    fprintf (file, _(" 64-bit double]"));
  else
    fprintf (file, _(" 32-bit double]"));

  if (elf_elfheader (abfd)->e_flags & E_M68HC12_BANKS)
    fprintf (file, _(" [memory=bank-model]"));
  else
    fprintf (file, _(" [memory=flat]"));

  fputc ('\n', file);

  return true;
}

a276 5
#define bfd_elf32_bfd_relax_section  m68hc11_elf_relax_section
#define elf_backend_gc_mark_hook     elf32_m68hc11_gc_mark_hook
#define elf_backend_gc_sweep_hook    elf32_m68hc11_gc_sweep_hook
#define elf_backend_check_relocs     elf32_m68hc11_check_relocs
#define elf_backend_relocate_section elf32_m68hc11_relocate_section
a278 6
#define elf_backend_can_gc_sections		1
#define bfd_elf32_bfd_merge_private_bfd_data \
					_bfd_m68hc11_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags	_bfd_m68hc11_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
					_bfd_m68hc11_elf_print_private_bfd_data
@


1.3.16.2
log
@merge from mainline
@
text
@d65 1
a65 1
#define USE_REL	1
d649 1
d654 1
a654 1
  Elf_Internal_Sym *isymbuf = NULL;
d696 1
a696 2
      Elf_Internal_Sym *isym;
      asection *sym_sec;
d780 1
a780 1
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d782 29
a810 7
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
d816 4
d821 6
a826 3
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	  symval = (isym->st_value
a849 2
          isym = 0;
          sym_sec = h->root.u.def.section;
d851 2
a852 2
		    + sym_sec->output_section->vma
		    + sym_sec->output_offset);
d865 1
a865 1
          insn_group_value = isym->st_value;
a868 26
      /* When we relax some bytes, the size of our section changes.
         This affects the layout of next input sections that go in our
         output section.  When the symbol is part of another section that
         will go in the same output section as the current one, it's
         final address may now be incorrect (too far).  We must let the
         linker re-compute all section offsets before processing this
         reloc.  Code example:

                                Initial             Final
         .sect .text            section size = 6    section size = 4
         jmp foo
         jmp bar
         .sect .text.foo_bar    output_offset = 6   output_offset = 4
         foo: rts
         bar: rts

         If we process the reloc now, the jmp bar is replaced by a
         relative branch to the initial bar address (output_offset 6).  */
      if (*again && sym_sec != sec
          && sym_sec->output_section == sec->output_section)
        {
          prev_insn_group = 0;
          prev_insn_branch = 0;
          continue;
        }
      
a913 1
          *again = true;
a934 2
              unsigned long old_sec_size = sec->_cooked_size;
              
d942 1
a942 1
              symtab_hdr->contents = (bfd_byte *) isymbuf;
a951 2
              if (sec->_cooked_size != old_sec_size)
                *again = true;
d971 1
a971 1
          symtab_hdr->contents = (bfd_byte *) isymbuf;
d987 2
a988 1
          /* That will change things, so, we should relax again.  */
d1017 1
a1017 1
                  symtab_hdr->contents = (bfd_byte *) isymbuf;
a1029 2
                  /* That will change things, so, we should relax again.  */
                  *again = true;
d1061 1
a1061 1
	  symtab_hdr->contents = (unsigned char *) isymbuf;
d1088 2
d1091 1
d1095 1
a1095 1
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
d1101 1
a1101 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1115 1
a1116 2
  sec->_cooked_size -= count;
  
d1215 5
a1219 2
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
d1221 12
a1232 4
      if (isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	isym->st_value -= count;
@


1.2
log
@2000-12-06  Kazu Hirata  <kazu@@hxi.com>

	* elf32-m32r.c: Fix formatting.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.2.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.1
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@a32 1

@

