head	1.29;
access;
symbols
	sid-snapshot-20180601:1.29
	sid-snapshot-20180501:1.29
	sid-snapshot-20180401:1.29
	sid-snapshot-20180301:1.29
	sid-snapshot-20180201:1.29
	sid-snapshot-20180101:1.29
	sid-snapshot-20171201:1.29
	sid-snapshot-20171101:1.29
	sid-snapshot-20171001:1.29
	sid-snapshot-20170901:1.29
	sid-snapshot-20170801:1.29
	sid-snapshot-20170701:1.29
	sid-snapshot-20170601:1.29
	sid-snapshot-20170501:1.29
	sid-snapshot-20170401:1.29
	sid-snapshot-20170301:1.29
	sid-snapshot-20170201:1.29
	sid-snapshot-20170101:1.29
	sid-snapshot-20161201:1.29
	sid-snapshot-20161101:1.29
	sid-snapshot-20160901:1.29
	sid-snapshot-20160801:1.29
	sid-snapshot-20160701:1.29
	sid-snapshot-20160601:1.29
	sid-snapshot-20160501:1.29
	sid-snapshot-20160401:1.29
	sid-snapshot-20160301:1.29
	sid-snapshot-20160201:1.29
	sid-snapshot-20160101:1.29
	sid-snapshot-20151201:1.29
	sid-snapshot-20151101:1.29
	sid-snapshot-20151001:1.29
	sid-snapshot-20150901:1.29
	sid-snapshot-20150801:1.29
	sid-snapshot-20150701:1.29
	sid-snapshot-20150601:1.29
	sid-snapshot-20150501:1.29
	sid-snapshot-20150401:1.29
	sid-snapshot-20150301:1.29
	sid-snapshot-20150201:1.29
	sid-snapshot-20150101:1.29
	sid-snapshot-20141201:1.29
	sid-snapshot-20141101:1.29
	sid-snapshot-20141001:1.29
	sid-snapshot-20140901:1.29
	sid-snapshot-20140801:1.29
	sid-snapshot-20140701:1.29
	sid-snapshot-20140601:1.29
	sid-snapshot-20140501:1.29
	sid-snapshot-20140401:1.29
	sid-snapshot-20140301:1.29
	sid-snapshot-20140201:1.29
	sid-snapshot-20140101:1.29
	sid-snapshot-20131201:1.29
	sid-snapshot-20131101:1.29
	sid-snapshot-20131001:1.29
	binutils-2_24-branch:1.29.0.4
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.25
	sid-snapshot-20130901:1.29
	gdb_7_6_1-2013-08-30-release:1.29
	sid-snapshot-20130801:1.29
	sid-snapshot-20130701:1.29
	sid-snapshot-20130601:1.29
	sid-snapshot-20130501:1.29
	gdb_7_6-2013-04-26-release:1.29
	sid-snapshot-20130401:1.29
	binutils-2_23_2:1.28
	gdb_7_6-branch:1.29.0.2
	gdb_7_6-2013-03-12-branchpoint:1.29
	sid-snapshot-20130301:1.29
	sid-snapshot-20130201:1.28
	sid-snapshot-20130101:1.28
	sid-snapshot-20121201:1.28
	gdb_7_5_1-2012-11-29-release:1.28
	binutils-2_23_1:1.28
	sid-snapshot-20121101:1.28
	binutils-2_23:1.28
	sid-snapshot-20121001:1.28
	sid-snapshot-20120901:1.28
	gdb_7_5-2012-08-17-release:1.28
	sid-snapshot-20120801:1.28
	binutils-2_23-branch:1.28.0.4
	binutils-2_23-branchpoint:1.28
	gdb_7_5-branch:1.28.0.2
	gdb_7_5-2012-07-18-branchpoint:1.28
	sid-snapshot-20120701:1.27
	sid-snapshot-20120601:1.27
	sid-snapshot-20120501:1.26
	binutils-2_22_branch:1.26.0.6
	gdb_7_4_1-2012-04-26-release:1.26
	sid-snapshot-20120401:1.26
	sid-snapshot-20120301:1.26
	sid-snapshot-20120201:1.26
	gdb_7_4-2012-01-24-release:1.26
	sid-snapshot-20120101:1.26
	gdb_7_4-branch:1.26.0.4
	gdb_7_4-2011-12-13-branchpoint:1.26
	sid-snapshot-20111201:1.26
	binutils-2_22:1.26
	sid-snapshot-20111101:1.26
	sid-snapshot-20111001:1.26
	binutils-2_22-branch:1.26.0.2
	binutils-2_22-branchpoint:1.26
	gdb_7_3_1-2011-09-04-release:1.25
	sid-snapshot-20110901:1.26
	sid-snapshot-20110801:1.26
	gdb_7_3-2011-07-26-release:1.25
	sid-snapshot-20110701:1.26
	sid-snapshot-20110601:1.25
	sid-snapshot-20110501:1.25
	gdb_7_3-branch:1.25.0.38
	gdb_7_3-2011-04-01-branchpoint:1.25
	sid-snapshot-20110401:1.25
	sid-snapshot-20110301:1.25
	sid-snapshot-20110201:1.25
	sid-snapshot-20110101:1.25
	binutils-2_21:1.25
	sid-snapshot-20101201:1.25
	binutils-2_21-branch:1.25.0.36
	binutils-2_21-branchpoint:1.25
	sid-snapshot-20101101:1.25
	sid-snapshot-20101001:1.25
	binutils-2_20_1:1.25
	gdb_7_2-2010-09-02-release:1.25
	sid-snapshot-20100901:1.25
	sid-snapshot-20100801:1.25
	gdb_7_2-branch:1.25.0.34
	gdb_7_2-2010-07-07-branchpoint:1.25
	sid-snapshot-20100701:1.25
	sid-snapshot-20100601:1.25
	sid-snapshot-20100501:1.25
	sid-snapshot-20100401:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.32
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.25
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.25
	gdb_7_0-2009-10-06-release:1.25
	sid-snapshot-20091001:1.25
	gdb_7_0-branch:1.25.0.30
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.25
	binutils-arc-20081103-branch:1.25.0.28
	binutils-arc-20081103-branchpoint:1.25
	binutils-2_20-branch:1.25.0.26
	binutils-2_20-branchpoint:1.25
	sid-snapshot-20090901:1.25
	sid-snapshot-20090801:1.25
	msnyder-checkpoint-072509-branch:1.25.0.24
	msnyder-checkpoint-072509-branchpoint:1.25
	sid-snapshot-20090701:1.25
	dje-cgen-play1-branch:1.25.0.22
	dje-cgen-play1-branchpoint:1.25
	sid-snapshot-20090601:1.25
	sid-snapshot-20090501:1.25
	sid-snapshot-20090401:1.25
	arc-20081103-branch:1.25.0.20
	arc-20081103-branchpoint:1.25
	arc-insight_6_8-branch:1.25.0.18
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.16
	insight_6_8-branchpoint:1.25
	sid-snapshot-20090301:1.25
	binutils-2_19_1:1.25
	sid-snapshot-20090201:1.25
	sid-snapshot-20090101:1.25
	reverse-20081226-branch:1.25.0.14
	reverse-20081226-branchpoint:1.25
	sid-snapshot-20081201:1.25
	multiprocess-20081120-branch:1.25.0.12
	multiprocess-20081120-branchpoint:1.25
	sid-snapshot-20081101:1.25
	binutils-2_19:1.25
	sid-snapshot-20081001:1.25
	reverse-20080930-branch:1.25.0.10
	reverse-20080930-branchpoint:1.25
	binutils-2_19-branch:1.25.0.8
	binutils-2_19-branchpoint:1.25
	sid-snapshot-20080901:1.25
	sid-snapshot-20080801:1.25
	reverse-20080717-branch:1.25.0.6
	reverse-20080717-branchpoint:1.25
	sid-snapshot-20080701:1.25
	msnyder-reverse-20080609-branch:1.25.0.4
	msnyder-reverse-20080609-branchpoint:1.25
	drow-reverse-20070409-branch:1.23.0.4
	drow-reverse-20070409-branchpoint:1.23
	sid-snapshot-20080601:1.25
	sid-snapshot-20080501:1.25
	sid-snapshot-20080403:1.25
	sid-snapshot-20080401:1.25
	gdb_6_8-2008-03-27-release:1.25
	sid-snapshot-20080301:1.25
	gdb_6_8-branch:1.25.0.2
	gdb_6_8-2008-02-26-branchpoint:1.25
	sid-snapshot-20080201:1.24
	sid-snapshot-20080101:1.24
	sid-snapshot-20071201:1.24
	sid-snapshot-20071101:1.24
	gdb_6_7_1-2007-10-29-release:1.24
	gdb_6_7-2007-10-10-release:1.24
	sid-snapshot-20071001:1.24
	gdb_6_7-branch:1.24.0.4
	gdb_6_7-2007-09-07-branchpoint:1.24
	binutils-2_18:1.24
	binutils-2_18-branch:1.24.0.2
	binutils-2_18-branchpoint:1.24
	insight_6_6-20070208-release:1.23
	binutils-csl-coldfire-4_1-32:1.22
	binutils-csl-sourcerygxx-4_1-32:1.22
	gdb_6_6-2006-12-18-release:1.23
	binutils-csl-innovasic-fido-3_4_4-33:1.22
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.22
	binutils-csl-sourcerygxx-4_1-30:1.22
	binutils-csl-coldfire-4_1-28:1.22
	binutils-csl-sourcerygxx-4_1-29:1.22
	binutils-csl-sourcerygxx-4_1-28:1.22
	gdb_6_6-branch:1.23.0.2
	gdb_6_6-2006-11-15-branchpoint:1.23
	binutils-csl-arm-2006q3-27:1.22
	binutils-csl-sourcerygxx-4_1-27:1.22
	binutils-csl-arm-2006q3-26:1.22
	binutils-csl-sourcerygxx-4_1-26:1.22
	binutils-csl-sourcerygxx-4_1-25:1.22
	binutils-csl-sourcerygxx-4_1-24:1.22
	binutils-csl-sourcerygxx-4_1-23:1.22
	insight_6_5-20061003-release:1.22
	gdb-csl-symbian-6_4_50_20060226-12:1.21
	binutils-csl-sourcerygxx-4_1-21:1.22
	binutils-csl-arm-2006q3-21:1.22
	binutils-csl-sourcerygxx-4_1-22:1.22
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.22
	binutils-csl-sourcerygxx-4_1-20:1.22
	binutils-csl-arm-2006q3-19:1.22
	binutils-csl-sourcerygxx-4_1-19:1.22
	binutils-csl-sourcerygxx-4_1-18:1.22
	binutils-csl-renesas-4_1-9:1.22
	gdb-csl-sourcerygxx-3_4_4-25:1.21
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.23
	gdb-csl-symbian-6_4_50_20060226-11:1.21
	binutils-csl-renesas-4_1-8:1.22
	binutils-csl-renesas-4_1-7:1.22
	binutils-csl-renesas-4_1-6:1.22
	gdb-csl-sourcerygxx-4_1-17:1.21
	binutils-csl-sourcerygxx-4_1-17:1.22
	gdb-csl-20060226-branch-local-2:1.21
	gdb-csl-sourcerygxx-4_1-14:1.21
	binutils-csl-sourcerygxx-4_1-14:1.22
	binutils-csl-sourcerygxx-4_1-15:1.22
	gdb-csl-sourcerygxx-4_1-13:1.21
	binutils-csl-sourcerygxx-4_1-13:1.22
	binutils-2_17:1.22
	gdb-csl-sourcerygxx-4_1-12:1.21
	binutils-csl-sourcerygxx-4_1-12:1.22
	gdb-csl-sourcerygxx-3_4_4-21:1.21
	binutils-csl-sourcerygxx-3_4_4-21:1.22
	gdb_6_5-20060621-release:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	gdb-csl-sourcerygxx-4_1-9:1.21
	binutils-csl-sourcerygxx-4_1-9:1.22
	gdb-csl-sourcerygxx-4_1-8:1.21
	binutils-csl-sourcerygxx-4_1-8:1.22
	gdb-csl-sourcerygxx-4_1-7:1.21
	binutils-csl-sourcerygxx-4_1-7:1.22
	gdb-csl-arm-2006q1-6:1.21
	binutils-csl-arm-2006q1-6:1.22
	gdb-csl-sourcerygxx-4_1-6:1.21
	binutils-csl-sourcerygxx-4_1-6:1.22
	binutils-csl-wrs-linux-3_4_4-22:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.21
	gdb-csl-symbian-6_4_50_20060226-9:1.21
	gdb-csl-symbian-6_4_50_20060226-8:1.21
	gdb-csl-coldfire-4_1-11:1.21
	binutils-csl-coldfire-4_1-11:1.22
	gdb-csl-sourcerygxx-3_4_4-19:1.21
	binutils-csl-sourcerygxx-3_4_4-19:1.22
	gdb-csl-coldfire-4_1-10:1.21
	gdb_6_5-branch:1.22.0.14
	gdb_6_5-2006-05-14-branchpoint:1.22
	binutils-csl-coldfire-4_1-10:1.22
	gdb-csl-sourcerygxx-4_1-5:1.21
	binutils-csl-sourcerygxx-4_1-5:1.22
	nickrob-async-20060513-branch:1.22.0.12
	nickrob-async-20060513-branchpoint:1.22
	gdb-csl-sourcerygxx-4_1-4:1.21
	binutils-csl-sourcerygxx-4_1-4:1.22
	msnyder-reverse-20060502-branch:1.22.0.10
	msnyder-reverse-20060502-branchpoint:1.22
	binutils-csl-wrs-linux-3_4_4-21:1.16
	gdb-csl-morpho-4_1-4:1.21
	binutils-csl-morpho-4_1-4:1.22
	gdb-csl-sourcerygxx-3_4_4-17:1.21
	binutils-csl-sourcerygxx-3_4_4-17:1.22
	binutils-csl-wrs-linux-3_4_4-20:1.16
	readline_5_1-import-branch:1.22.0.8
	readline_5_1-import-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.21
	binutils-2_17-branch:1.22.0.6
	binutils-2_17-branchpoint:1.22
	gdb-csl-symbian-20060226-branch:1.21.0.16
	gdb-csl-symbian-20060226-branchpoint:1.21
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.21
	msnyder-reverse-20060331-branch:1.22.0.4
	msnyder-reverse-20060331-branchpoint:1.22
	binutils-csl-2_17-branch:1.22.0.2
	binutils-csl-2_17-branchpoint:1.22
	gdb-csl-available-20060303-branch:1.21.0.14
	gdb-csl-available-20060303-branchpoint:1.21
	gdb-csl-20060226-branch:1.21.0.12
	gdb-csl-20060226-branchpoint:1.21
	gdb_6_4-20051202-release:1.21
	msnyder-fork-checkpoint-branch:1.21.0.10
	msnyder-fork-checkpoint-branchpoint:1.21
	gdb-csl-gxxpro-6_3-branch:1.21.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.21
	gdb_6_4-branch:1.21.0.6
	gdb_6_4-2005-11-01-branchpoint:1.21
	gdb-csl-arm-20051020-branch:1.21.0.4
	gdb-csl-arm-20051020-branchpoint:1.21
	binutils-csl-gxxpro-3_4-branch:1.16.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	msnyder-tracepoint-checkpoint-branch:1.21.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.21
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.16
	csl-arm-20050325-branch:1.16.0.6
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.15
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.4
	gdb_6_3-20041019-branchpoint:1.15
	csl-arm-2004-q3:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.6
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.14
	csl-arm-2004-q1:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.14
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.12
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.8
	drow_intercu-20040221-branchpoint:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	csl-arm-2003-q4:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.12.0.6
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.4
	cagney_x86i386-20030821-branch:1.12.0.2
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.12
	gdb_6_0-branch:1.11.0.36
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.32
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.30
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.26
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.22
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.20
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.18
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.16
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.14
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.12
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.10
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.8
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.6
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.4
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.14
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.12
	carlton_dictionary-20020920-branchpoint:1.10
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.6
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.4
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.7.2.1
	jimb-macro-020506-branch:1.9.0.2
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.29
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.02.03.02.45;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2012.05.16.14.26.46;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2011.06.13.00.59.15;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.04.15.53.39;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.04.07.19.36;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.03.17.05.50;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.03.01.05.03;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.11.08.23.04;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.01.06.33.01;	author kazu;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.15.04.48;	author amodra;	state Exp;
branches
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2002.04.04.19.53.38;	author drow;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2002.03.28.03.27.46;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.10.02.05.58.41;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.20.00.21.57;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.12.10.30.07;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.13.8.1
date	2004.09.16.17.00.37;	author drow;	state Exp;
branches;
next	;

1.10.12.1
date	2002.12.23.19.38.00;	author carlton;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2003.06.27.21.49.30;	author carlton;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2003.12.15.23.59.53;	author carlton;	state Exp;
branches;
next	;

1.10.14.1
date	2003.12.14.20.26.52;	author drow;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.15.16.42.41;	author cagney;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.20.01.31.12;	author kseitz;	state Exp;
branches;
next	;

1.7.2.1
date	2002.04.04.14.53.01;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.29
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@/* BFD backend for SunOS binaries.
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011, 2012
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGETNAME "a.out-sunos-big"

/* Do not "beautify" the CONCAT* macro args.  Traditional C will not
   remove whitespace added here, and thus will fail to concatenate
   the tokens.  */
#define MY(OP) CONCAT2 (sunos_big_,OP)

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libaout.h"

/* ??? Where should this go?  */
#define MACHTYPE_OK(mtype) \
  (((mtype) == M_SPARC && bfd_lookup_arch (bfd_arch_sparc, 0) != NULL) \
   || ((mtype) == M_SPARCLET \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
   || ((mtype) == M_SPARCLITE_LE \
       && bfd_lookup_arch (bfd_arch_sparc, bfd_mach_sparc_sparclet) != NULL) \
   || (((mtype) == M_UNKNOWN || (mtype) == M_68010 || (mtype) == M_68020) \
       && bfd_lookup_arch (bfd_arch_m68k, 0) != NULL))

#define MY_get_dynamic_symtab_upper_bound  sunos_get_dynamic_symtab_upper_bound
#define MY_canonicalize_dynamic_symtab     sunos_canonicalize_dynamic_symtab
#define MY_get_synthetic_symtab            _bfd_nodynamic_get_synthetic_symtab
#define MY_get_dynamic_reloc_upper_bound   sunos_get_dynamic_reloc_upper_bound
#define MY_canonicalize_dynamic_reloc      sunos_canonicalize_dynamic_reloc
#define MY_bfd_link_hash_table_create      sunos_link_hash_table_create
#define MY_add_dynamic_symbols             sunos_add_dynamic_symbols
#define MY_add_one_symbol                  sunos_add_one_symbol
#define MY_link_dynamic_object             sunos_link_dynamic_object
#define MY_write_dynamic_symbol            sunos_write_dynamic_symbol
#define MY_check_dynamic_reloc             sunos_check_dynamic_reloc
#define MY_finish_dynamic_link             sunos_finish_dynamic_link

static bfd_boolean sunos_add_dynamic_symbols            (bfd *, struct bfd_link_info *, struct external_nlist **, bfd_size_type *, char **);
static bfd_boolean sunos_add_one_symbol                 (struct bfd_link_info *, bfd *, const char *, flagword, asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean, struct bfd_link_hash_entry **);
static bfd_boolean sunos_link_dynamic_object            (struct bfd_link_info *, bfd *);
static bfd_boolean sunos_write_dynamic_symbol           (bfd *, struct bfd_link_info *, struct aout_link_hash_entry *);
static bfd_boolean sunos_check_dynamic_reloc            (struct bfd_link_info *, bfd *, asection *, struct aout_link_hash_entry *, void *, bfd_byte *, bfd_boolean *, bfd_vma *);
static bfd_boolean sunos_finish_dynamic_link            (bfd *, struct bfd_link_info *);
static struct bfd_link_hash_table *sunos_link_hash_table_create  (bfd *);
static long        sunos_get_dynamic_symtab_upper_bound (bfd *);
static long        sunos_canonicalize_dynamic_symtab    (bfd *, asymbol **);
static long        sunos_get_dynamic_reloc_upper_bound  (bfd *);
static long        sunos_canonicalize_dynamic_reloc     (bfd *, arelent **, asymbol **);

/* Include the usual a.out support.  */
#include "aoutf1.h"

/* The SunOS 4.1.4 /usr/include/locale.h defines valid as a macro.  */
#undef valid

/* SunOS shared library support.  We store a pointer to this structure
   in obj_aout_dynamic_info (abfd).  */

struct sunos_dynamic_info
{
  /* Whether we found any dynamic information.  */
  bfd_boolean valid;
  /* Dynamic information.  */
  struct internal_sun4_dynamic_link dyninfo;
  /* Number of dynamic symbols.  */
  unsigned long dynsym_count;
  /* Read in nlists for dynamic symbols.  */
  struct external_nlist *dynsym;
  /* asymbol structures for dynamic symbols.  */
  aout_symbol_type *canonical_dynsym;
  /* Read in dynamic string table.  */
  char *dynstr;
  /* Number of dynamic relocs.  */
  unsigned long dynrel_count;
  /* Read in dynamic relocs.  This may be reloc_std_external or
     reloc_ext_external.  */
  void * dynrel;
  /* arelent structures for dynamic relocs.  */
  arelent *canonical_dynrel;
};

/* The hash table of dynamic symbols is composed of two word entries.
   See include/aout/sun4.h for details.  */

#define HASH_ENTRY_SIZE (2 * BYTES_IN_WORD)

/* Read in the basic dynamic information.  This locates the __DYNAMIC
   structure and uses it to find the dynamic_link structure.  It
   creates and saves a sunos_dynamic_info structure.  If it can't find
   __DYNAMIC, it sets the valid field of the sunos_dynamic_info
   structure to FALSE to avoid doing this work again.  */

static bfd_boolean
sunos_read_dynamic_info (bfd *abfd)
{
  struct sunos_dynamic_info *info;
  asection *dynsec;
  bfd_vma dynoff;
  struct external_sun4_dynamic dyninfo;
  unsigned long dynver;
  struct external_sun4_dynamic_link linkinfo;
  bfd_size_type amt;

  if (obj_aout_dynamic_info (abfd) != NULL)
    return TRUE;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  amt = sizeof (struct sunos_dynamic_info);
  info = bfd_zalloc (abfd, amt);
  if (!info)
    return FALSE;
  info->valid = FALSE;
  info->dynsym = NULL;
  info->dynstr = NULL;
  info->canonical_dynsym = NULL;
  info->dynrel = NULL;
  info->canonical_dynrel = NULL;
  obj_aout_dynamic_info (abfd) = (void *) info;

  /* This code used to look for the __DYNAMIC symbol to locate the dynamic
     linking information.
     However this inhibits recovering the dynamic symbols from a
     stripped object file, so blindly assume that the dynamic linking
     information is located at the start of the data section.
     We could verify this assumption later by looking through the dynamic
     symbols for the __DYNAMIC symbol.  */
  if ((abfd->flags & DYNAMIC) == 0)
    return TRUE;
  if (! bfd_get_section_contents (abfd, obj_datasec (abfd), (void *) &dyninfo,
				  (file_ptr) 0,
				  (bfd_size_type) sizeof dyninfo))
    return TRUE;

  dynver = GET_WORD (abfd, dyninfo.ld_version);
  if (dynver != 2 && dynver != 3)
    return TRUE;

  dynoff = GET_WORD (abfd, dyninfo.ld);

  /* dynoff is a virtual address.  It is probably always in the .data
     section, but this code should work even if it moves.  */
  if (dynoff < bfd_get_section_vma (abfd, obj_datasec (abfd)))
    dynsec = obj_textsec (abfd);
  else
    dynsec = obj_datasec (abfd);
  dynoff -= bfd_get_section_vma (abfd, dynsec);
  if (dynoff > dynsec->size)
    return TRUE;

  /* This executable appears to be dynamically linked in a way that we
     can understand.  */
  if (! bfd_get_section_contents (abfd, dynsec, (void *) &linkinfo,
				  (file_ptr) dynoff,
				  (bfd_size_type) sizeof linkinfo))
    return TRUE;

  /* Swap in the dynamic link information.  */
  info->dyninfo.ld_loaded = GET_WORD (abfd, linkinfo.ld_loaded);
  info->dyninfo.ld_need = GET_WORD (abfd, linkinfo.ld_need);
  info->dyninfo.ld_rules = GET_WORD (abfd, linkinfo.ld_rules);
  info->dyninfo.ld_got = GET_WORD (abfd, linkinfo.ld_got);
  info->dyninfo.ld_plt = GET_WORD (abfd, linkinfo.ld_plt);
  info->dyninfo.ld_rel = GET_WORD (abfd, linkinfo.ld_rel);
  info->dyninfo.ld_hash = GET_WORD (abfd, linkinfo.ld_hash);
  info->dyninfo.ld_stab = GET_WORD (abfd, linkinfo.ld_stab);
  info->dyninfo.ld_stab_hash = GET_WORD (abfd, linkinfo.ld_stab_hash);
  info->dyninfo.ld_buckets = GET_WORD (abfd, linkinfo.ld_buckets);
  info->dyninfo.ld_symbols = GET_WORD (abfd, linkinfo.ld_symbols);
  info->dyninfo.ld_symb_size = GET_WORD (abfd, linkinfo.ld_symb_size);
  info->dyninfo.ld_text = GET_WORD (abfd, linkinfo.ld_text);
  info->dyninfo.ld_plt_sz = GET_WORD (abfd, linkinfo.ld_plt_sz);

  /* Reportedly the addresses need to be offset by the size of the
     exec header in an NMAGIC file.  */
  if (adata (abfd).magic == n_magic)
    {
      unsigned long exec_bytes_size = adata (abfd).exec_bytes_size;

      info->dyninfo.ld_need += exec_bytes_size;
      info->dyninfo.ld_rules += exec_bytes_size;
      info->dyninfo.ld_rel += exec_bytes_size;
      info->dyninfo.ld_hash += exec_bytes_size;
      info->dyninfo.ld_stab += exec_bytes_size;
      info->dyninfo.ld_symbols += exec_bytes_size;
    }

  /* The only way to get the size of the symbol information appears to
     be to determine the distance between it and the string table.  */
  info->dynsym_count = ((info->dyninfo.ld_symbols - info->dyninfo.ld_stab)
			/ EXTERNAL_NLIST_SIZE);
  BFD_ASSERT (info->dynsym_count * EXTERNAL_NLIST_SIZE
	      == (unsigned long) (info->dyninfo.ld_symbols
				  - info->dyninfo.ld_stab));

  /* Similarly, the relocs end at the hash table.  */
  info->dynrel_count = ((info->dyninfo.ld_hash - info->dyninfo.ld_rel)
			/ obj_reloc_entry_size (abfd));
  BFD_ASSERT (info->dynrel_count * obj_reloc_entry_size (abfd)
	      == (unsigned long) (info->dyninfo.ld_hash
				  - info->dyninfo.ld_rel));

  info->valid = TRUE;

  return TRUE;
}

/* Return the amount of memory required for the dynamic symbols.  */

static long
sunos_get_dynamic_symtab_upper_bound (bfd *abfd)
{
  struct sunos_dynamic_info *info;

  if (! sunos_read_dynamic_info (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  return (info->dynsym_count + 1) * sizeof (asymbol *);
}

/* Read the external dynamic symbols.  */

static bfd_boolean
sunos_slurp_dynamic_symtab (bfd *abfd)
{
  struct sunos_dynamic_info *info;
  bfd_size_type amt;

  /* Get the general dynamic information.  */
  if (obj_aout_dynamic_info (abfd) == NULL)
    {
      if (! sunos_read_dynamic_info (abfd))
	  return FALSE;
    }

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  /* Get the dynamic nlist structures.  */
  if (info->dynsym == NULL)
    {
      amt = (bfd_size_type) info->dynsym_count * EXTERNAL_NLIST_SIZE;
      info->dynsym = bfd_alloc (abfd, amt);
      if (info->dynsym == NULL && info->dynsym_count != 0)
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_stab, SEEK_SET) != 0
	  || bfd_bread ((void *) info->dynsym, amt, abfd) != amt)
	{
	  if (info->dynsym != NULL)
	    {
	      bfd_release (abfd, info->dynsym);
	      info->dynsym = NULL;
	    }
	  return FALSE;
	}
    }

  /* Get the dynamic strings.  */
  if (info->dynstr == NULL)
    {
      amt = info->dyninfo.ld_symb_size;
      info->dynstr = bfd_alloc (abfd, amt);
      if (info->dynstr == NULL && info->dyninfo.ld_symb_size != 0)
	return FALSE;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_symbols, SEEK_SET) != 0
	  || bfd_bread ((void *) info->dynstr, amt, abfd) != amt)
	{
	  if (info->dynstr != NULL)
	    {
	      bfd_release (abfd, info->dynstr);
	      info->dynstr = NULL;
	    }
	  return FALSE;
	}
    }

  return TRUE;
}

/* Read in the dynamic symbols.  */

static long
sunos_canonicalize_dynamic_symtab (bfd *abfd, asymbol **storage)
{
  struct sunos_dynamic_info *info;
  unsigned long i;

  if (! sunos_slurp_dynamic_symtab (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);

#ifdef CHECK_DYNAMIC_HASH
  /* Check my understanding of the dynamic hash table by making sure
     that each symbol can be located in the hash table.  */
  {
    bfd_size_type table_size;
    bfd_byte *table;
    bfd_size_type i;

    if (info->dyninfo.ld_buckets > info->dynsym_count)
      abort ();
    table_size = info->dyninfo.ld_stab - info->dyninfo.ld_hash;
    table = bfd_malloc (table_size);
    if (table == NULL && table_size != 0)
      abort ();
    if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_hash, SEEK_SET) != 0
	|| bfd_bread ((void *) table, table_size, abfd) != table_size)
      abort ();
    for (i = 0; i < info->dynsym_count; i++)
      {
	unsigned char *name;
	unsigned long hash;

	name = ((unsigned char *) info->dynstr
		+ GET_WORD (abfd, info->dynsym[i].e_strx));
	hash = 0;
	while (*name != '\0')
	  hash = (hash << 1) + *name++;
	hash &= 0x7fffffff;
	hash %= info->dyninfo.ld_buckets;
	while (GET_WORD (abfd, table + hash * HASH_ENTRY_SIZE) != i)
	  {
	    hash = GET_WORD (abfd,
			     table + hash * HASH_ENTRY_SIZE + BYTES_IN_WORD);
	    if (hash == 0 || hash >= table_size / HASH_ENTRY_SIZE)
	      abort ();
	  }
      }
    free (table);
  }
#endif /* CHECK_DYNAMIC_HASH */

  /* Get the asymbol structures corresponding to the dynamic nlist
     structures.  */
  if (info->canonical_dynsym == NULL)
    {
      bfd_size_type size;
      bfd_size_type strsize = info->dyninfo.ld_symb_size;

      size = (bfd_size_type) info->dynsym_count * sizeof (aout_symbol_type);
      info->canonical_dynsym = bfd_alloc (abfd, size);
      if (info->canonical_dynsym == NULL && info->dynsym_count != 0)
	return -1;

      if (! aout_32_translate_symbol_table (abfd, info->canonical_dynsym,
					    info->dynsym,
					    (bfd_size_type) info->dynsym_count,
					    info->dynstr, strsize, TRUE))
	{
	  if (info->canonical_dynsym != NULL)
	    {
	      bfd_release (abfd, info->canonical_dynsym);
	      info->canonical_dynsym = NULL;
	    }
	  return -1;
	}
    }

  /* Return pointers to the dynamic asymbol structures.  */
  for (i = 0; i < info->dynsym_count; i++)
    *storage++ = (asymbol *) (info->canonical_dynsym + i);
  *storage = NULL;

  return info->dynsym_count;
}

/* Return the amount of memory required for the dynamic relocs.  */

static long
sunos_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  struct sunos_dynamic_info *info;

  if (! sunos_read_dynamic_info (abfd))
    return -1;

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  return (info->dynrel_count + 1) * sizeof (arelent *);
}

/* Read in the dynamic relocs.  */

static long
sunos_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage, asymbol **syms)
{
  struct sunos_dynamic_info *info;
  unsigned long i;
  bfd_size_type size;

  /* Get the general dynamic information.  */
  if (obj_aout_dynamic_info (abfd) == NULL)
    {
      if (! sunos_read_dynamic_info (abfd))
	return -1;
    }

  info = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  if (! info->valid)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  /* Get the dynamic reloc information.  */
  if (info->dynrel == NULL)
    {
      size = (bfd_size_type) info->dynrel_count * obj_reloc_entry_size (abfd);
      info->dynrel = bfd_alloc (abfd, size);
      if (info->dynrel == NULL && size != 0)
	return -1;
      if (bfd_seek (abfd, (file_ptr) info->dyninfo.ld_rel, SEEK_SET) != 0
	  || bfd_bread ((void *) info->dynrel, size, abfd) != size)
	{
	  if (info->dynrel != NULL)
	    {
	      bfd_release (abfd, info->dynrel);
	      info->dynrel = NULL;
	    }
	  return -1;
	}
    }

  /* Get the arelent structures corresponding to the dynamic reloc
     information.  */
  if (info->canonical_dynrel == NULL)
    {
      arelent *to;

      size = (bfd_size_type) info->dynrel_count * sizeof (arelent);
      info->canonical_dynrel = bfd_alloc (abfd, size);
      if (info->canonical_dynrel == NULL && info->dynrel_count != 0)
	return -1;

      to = info->canonical_dynrel;

      if (obj_reloc_entry_size (abfd) == RELOC_EXT_SIZE)
	{
	  struct reloc_ext_external *p;
	  struct reloc_ext_external *pend;

	  p = (struct reloc_ext_external *) info->dynrel;
	  pend = p + info->dynrel_count;
	  for (; p < pend; p++, to++)
	    NAME (aout, swap_ext_reloc_in) (abfd, p, to, syms,
					    (bfd_size_type) info->dynsym_count);
	}
      else
	{
	  struct reloc_std_external *p;
	  struct reloc_std_external *pend;

	  p = (struct reloc_std_external *) info->dynrel;
	  pend = p + info->dynrel_count;
	  for (; p < pend; p++, to++)
	    NAME (aout, swap_std_reloc_in) (abfd, p, to, syms,
					    (bfd_size_type) info->dynsym_count);
	}
    }

  /* Return pointers to the dynamic arelent structures.  */
  for (i = 0; i < info->dynrel_count; i++)
    *storage++ = info->canonical_dynrel + i;
  *storage = NULL;

  return info->dynrel_count;
}

/* Code to handle linking of SunOS shared libraries.  */

/* A SPARC procedure linkage table entry is 12 bytes.  The first entry
   in the table is a jump which is filled in by the runtime linker.
   The remaining entries are branches back to the first entry,
   followed by an index into the relocation table encoded to look like
   a sethi of %g0.  */

#define SPARC_PLT_ENTRY_SIZE (12)

static const bfd_byte sparc_plt_first_entry[SPARC_PLT_ENTRY_SIZE] =
{
  /* sethi %hi(0),%g1; address filled in by runtime linker.  */
  0x3, 0, 0, 0,
  /* jmp %g1; offset filled in by runtime linker.  */
  0x81, 0xc0, 0x60, 0,
  /* nop */
  0x1, 0, 0, 0
};

/* save %sp, -96, %sp */
#define SPARC_PLT_ENTRY_WORD0 ((bfd_vma) 0x9de3bfa0)
/* call; address filled in later.  */
#define SPARC_PLT_ENTRY_WORD1 ((bfd_vma) 0x40000000)
/* sethi; reloc index filled in later.  */
#define SPARC_PLT_ENTRY_WORD2 ((bfd_vma) 0x01000000)

/* This sequence is used when for the jump table entry to a defined
   symbol in a complete executable.  It is used when linking PIC
   compiled code which is not being put into a shared library.  */
/* sethi <address to be filled in later>, %g1 */
#define SPARC_PLT_PIC_WORD0 ((bfd_vma) 0x03000000)
/* jmp %g1 + <address to be filled in later> */
#define SPARC_PLT_PIC_WORD1 ((bfd_vma) 0x81c06000)
/* nop */
#define SPARC_PLT_PIC_WORD2 ((bfd_vma) 0x01000000)

/* An m68k procedure linkage table entry is 8 bytes.  The first entry
   in the table is a jump which is filled in the by the runtime
   linker.  The remaining entries are branches back to the first
   entry, followed by a two byte index into the relocation table.  */

#define M68K_PLT_ENTRY_SIZE (8)

static const bfd_byte m68k_plt_first_entry[M68K_PLT_ENTRY_SIZE] =
{
  /* jmps @@# */
  0x4e, 0xf9,
  /* Filled in by runtime linker with a magic address.  */
  0, 0, 0, 0,
  /* Not used?  */
  0, 0
};

/* bsrl */
#define M68K_PLT_ENTRY_WORD0 ((bfd_vma) 0x61ff)
/* Remaining words filled in later.  */

/* An entry in the SunOS linker hash table.  */

struct sunos_link_hash_entry
{
  struct aout_link_hash_entry root;

  /* If this is a dynamic symbol, this is its index into the dynamic
     symbol table.  This is initialized to -1.  As the linker looks at
     the input files, it changes this to -2 if it will be added to the
     dynamic symbol table.  After all the input files have been seen,
     the linker will know whether to build a dynamic symbol table; if
     it does build one, this becomes the index into the table.  */
  long dynindx;

  /* If this is a dynamic symbol, this is the index of the name in the
     dynamic symbol string table.  */
  long dynstr_index;

  /* The offset into the global offset table used for this symbol.  If
     the symbol does not require a GOT entry, this is 0.  */
  bfd_vma got_offset;

  /* The offset into the procedure linkage table used for this symbol.
     If the symbol does not require a PLT entry, this is 0.  */
  bfd_vma plt_offset;

  /* Some linker flags.  */
  unsigned char flags;
  /* Symbol is referenced by a regular object.  */
#define SUNOS_REF_REGULAR 01
  /* Symbol is defined by a regular object.  */
#define SUNOS_DEF_REGULAR 02
  /* Symbol is referenced by a dynamic object.  */
#define SUNOS_REF_DYNAMIC 04
  /* Symbol is defined by a dynamic object.  */
#define SUNOS_DEF_DYNAMIC 010
  /* Symbol is a constructor symbol in a regular object.  */
#define SUNOS_CONSTRUCTOR 020
};

/* The SunOS linker hash table.  */

struct sunos_link_hash_table
{
  struct aout_link_hash_table root;

  /* The object which holds the dynamic sections.  */
  bfd *dynobj;

  /* Whether we have created the dynamic sections.  */
  bfd_boolean dynamic_sections_created;

  /* Whether we need the dynamic sections.  */
  bfd_boolean dynamic_sections_needed;

  /* Whether we need the .got table.  */
  bfd_boolean got_needed;

  /* The number of dynamic symbols.  */
  size_t dynsymcount;

  /* The number of buckets in the hash table.  */
  size_t bucketcount;

  /* The list of dynamic objects needed by dynamic objects included in
     the link.  */
  struct bfd_link_needed_list *needed;

  /* The offset of __GLOBAL_OFFSET_TABLE_ into the .got section.  */
  bfd_vma got_base;
};

/* Routine to create an entry in an SunOS link hash table.  */

static struct bfd_hash_entry *
sunos_link_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  struct sunos_link_hash_entry *ret = (struct sunos_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret ==  NULL)
    ret = bfd_hash_allocate (table, sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct sunos_link_hash_entry *)
	 NAME (aout, link_hash_newfunc) ((struct bfd_hash_entry *) ret,
					 table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      ret->dynindx = -1;
      ret->dynstr_index = -1;
      ret->got_offset = 0;
      ret->plt_offset = 0;
      ret->flags = 0;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a SunOS link hash table.  */

static struct bfd_link_hash_table *
sunos_link_hash_table_create (bfd *abfd)
{
  struct sunos_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct sunos_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret ==  NULL)
    return NULL;
  if (!NAME (aout, link_hash_table_init) (&ret->root, abfd,
					  sunos_link_hash_newfunc,
					  sizeof (struct sunos_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Look up an entry in an SunOS link hash table.  */

#define sunos_link_hash_lookup(table, string, create, copy, follow) \
  ((struct sunos_link_hash_entry *) \
   aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			  (follow)))

/* Traverse a SunOS link hash table.  */

#define sunos_link_hash_traverse(table, func, info)			\
  (aout_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct aout_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the SunOS link hash table from the info structure.  This is
   just a cast.  */

#define sunos_hash_table(p) ((struct sunos_link_hash_table *) ((p)->hash))

/* Create the dynamic sections needed if we are linking against a
   dynamic object, or if we are linking PIC compiled code.  ABFD is a
   bfd we can attach the dynamic sections to.  The linker script will
   look for these special sections names and put them in the right
   place in the output file.  See include/aout/sun4.h for more details
   of the dynamic linking information.  */

static bfd_boolean
sunos_create_dynamic_sections (bfd *abfd,
			       struct bfd_link_info *info,
			       bfd_boolean needed)
{
  asection *s;

  if (! sunos_hash_table (info)->dynamic_sections_created)
    {
      flagword flags;

      sunos_hash_table (info)->dynobj = abfd;

      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED);

      /* The .dynamic section holds the basic dynamic information: the
	 sun4_dynamic structure, the dynamic debugger information, and
	 the sun4_dynamic_link structure.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynamic", flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .got section holds the global offset table.  The address
	 is put in the ld_got field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .plt section holds the procedure linkage table.  The
	 address is put in the ld_plt field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".plt", flags | SEC_CODE);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynrel section holds the dynamic relocs.  The address is
	 put in the ld_rel field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynrel",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .hash section holds the dynamic hash table.  The address
	 is put in the ld_hash field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".hash",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynsym section holds the dynamic symbols.  The address
	 is put in the ld_stab field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynsym",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      /* The .dynstr section holds the dynamic symbol string table.
	 The address is put in the ld_symbols field.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynstr",
					      flags | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      sunos_hash_table (info)->dynamic_sections_created = TRUE;
    }

  if ((needed && ! sunos_hash_table (info)->dynamic_sections_needed)
      || info->shared)
    {
      bfd *dynobj;

      dynobj = sunos_hash_table (info)->dynobj;

      s = bfd_get_linker_section (dynobj, ".got");
      if (s->size == 0)
	s->size = BYTES_IN_WORD;

      sunos_hash_table (info)->dynamic_sections_needed = TRUE;
      sunos_hash_table (info)->got_needed = TRUE;
    }

  return TRUE;
}

/* Add dynamic symbols during a link.  This is called by the a.out
   backend linker for each object it encounters.  */

static bfd_boolean
sunos_add_dynamic_symbols (bfd *abfd,
			   struct bfd_link_info *info,
			   struct external_nlist **symsp,
			   bfd_size_type *sym_countp,
			   char **stringsp)
{
  bfd *dynobj;
  struct sunos_dynamic_info *dinfo;
  unsigned long need;

  /* Make sure we have all the required sections.  */
  if (info->output_bfd->xvec == abfd->xvec)
    {
      if (! sunos_create_dynamic_sections (abfd, info,
					   ((abfd->flags & DYNAMIC) != 0
					    && !info->relocatable)))
	return FALSE;
    }

  /* There is nothing else to do for a normal object.  */
  if ((abfd->flags & DYNAMIC) == 0)
    return TRUE;

  dynobj = sunos_hash_table (info)->dynobj;

  /* We do not want to include the sections in a dynamic object in the
     output file.  We hack by simply clobbering the list of sections
     in the BFD.  This could be handled more cleanly by, say, a new
     section flag; the existing SEC_NEVER_LOAD flag is not the one we
     want, because that one still implies that the section takes up
     space in the output file.  If this is the first object we have
     seen, we must preserve the dynamic sections we just created.  */
  if (abfd != dynobj)
    abfd->sections = NULL;
  else
    {
      asection *s;

      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LINKER_CREATED) == 0)
	    bfd_section_list_remove (abfd, s);
	}
    }

  /* The native linker seems to just ignore dynamic objects when -r is
     used.  */
  if (info->relocatable)
    return TRUE;

  /* There's no hope of using a dynamic object which does not exactly
     match the format of the output file.  */
  if (info->output_bfd->xvec != abfd->xvec)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Make sure we have a .need and a .rules sections.  These are only
     needed if there really is a dynamic object in the link, so they
     are not added by sunos_create_dynamic_sections.  */
  if (bfd_get_section_by_name (dynobj, ".need") == NULL)
    {
      /* The .need section holds the list of names of shared objets
	 which must be included at runtime.  The address of this
	 section is put in the ld_need field.  */
      flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY | SEC_READONLY);
      asection *s = bfd_make_section_with_flags (dynobj, ".need", flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;
    }

  if (bfd_get_section_by_name (dynobj, ".rules") == NULL)
    {
      /* The .rules section holds the path to search for shared
	 objects.  The address of this section is put in the ld_rules
	 field.  */
      flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY | SEC_READONLY);
      asection *s = bfd_make_section_with_flags (dynobj, ".rules", flags);
      if (s == NULL
	  || ! bfd_set_section_alignment (dynobj, s, 2))
	return FALSE;
    }

  /* Pick up the dynamic symbols and return them to the caller.  */
  if (! sunos_slurp_dynamic_symtab (abfd))
    return FALSE;

  dinfo = (struct sunos_dynamic_info *) obj_aout_dynamic_info (abfd);
  *symsp = dinfo->dynsym;
  *sym_countp = dinfo->dynsym_count;
  *stringsp = dinfo->dynstr;

  /* Record information about any other objects needed by this one.  */
  need = dinfo->dyninfo.ld_need;
  while (need != 0)
    {
      bfd_byte buf[16];
      unsigned long name, flags;
      unsigned short major_vno, minor_vno;
      struct bfd_link_needed_list *needed, **pp;
      char *namebuf, *p;
      bfd_size_type alc;
      bfd_byte b;
      char *namecopy;

      if (bfd_seek (abfd, (file_ptr) need, SEEK_SET) != 0
	  || bfd_bread (buf, (bfd_size_type) 16, abfd) != 16)
	return FALSE;

      /* For the format of an ld_need entry, see aout/sun4.h.  We
	 should probably define structs for this manipulation.  */
      name = bfd_get_32 (abfd, buf);
      flags = bfd_get_32 (abfd, buf + 4);
      major_vno = (unsigned short) bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short) bfd_get_16 (abfd, buf + 10);
      need = bfd_get_32 (abfd, buf + 12);

      alc = sizeof (struct bfd_link_needed_list);
      needed = bfd_alloc (abfd, alc);
      if (needed == NULL)
	return FALSE;
      needed->by = abfd;

      /* We return the name as [-l]name[.maj][.min].  */
      alc = 30;
      namebuf = bfd_malloc (alc + 1);
      if (namebuf == NULL)
	return FALSE;
      p = namebuf;

      if ((flags & 0x80000000) != 0)
	{
	  *p++ = '-';
	  *p++ = 'l';
	}
      if (bfd_seek (abfd, (file_ptr) name, SEEK_SET) != 0)
	{
	  free (namebuf);
	  return FALSE;
	}

      do
	{
	  if (bfd_bread (&b, (bfd_size_type) 1, abfd) != 1)
	    {
	      free (namebuf);
	      return FALSE;
	    }

	  if ((bfd_size_type) (p - namebuf) >= alc)
	    {
	      char *n;

	      alc *= 2;
	      n = bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return FALSE;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
	    }

	  *p++ = b;
	}
      while (b != '\0');

      if (major_vno == 0)
	*p = '\0';
      else
	{
	  char majbuf[30];
	  char minbuf[30];

	  sprintf (majbuf, ".%d", major_vno);
	  if (minor_vno == 0)
	    minbuf[0] = '\0';
	  else
	    sprintf (minbuf, ".%d", minor_vno);

	  if ((p - namebuf) + strlen (majbuf) + strlen (minbuf) >= alc)
	    {
	      char *n;

	      alc = (p - namebuf) + strlen (majbuf) + strlen (minbuf);
	      n = bfd_realloc (namebuf, alc + 1);
	      if (n == NULL)
		{
		  free (namebuf);
		  return FALSE;
		}
	      p = n + (p - namebuf);
	      namebuf = n;
	    }

	  strcpy (p, majbuf);
	  strcat (p, minbuf);
	}

      namecopy = bfd_alloc (abfd, (bfd_size_type) strlen (namebuf) + 1);
      if (namecopy == NULL)
	{
	  free (namebuf);
	  return FALSE;
	}
      strcpy (namecopy, namebuf);
      free (namebuf);
      needed->name = namecopy;

      needed->next = NULL;

      for (pp = &sunos_hash_table (info)->needed;
	   *pp != NULL;
	   pp = &(*pp)->next)
	;
      *pp = needed;
    }

  return TRUE;
}

/* Function to add a single symbol to the linker hash table.  This is
   a wrapper around _bfd_generic_link_add_one_symbol which handles the
   tweaking needed for dynamic linking support.  */

static bfd_boolean
sunos_add_one_symbol (struct bfd_link_info *info,
		      bfd *abfd,
		      const char *name,
		      flagword flags,
		      asection *section,
		      bfd_vma value,
		      const char *string,
		      bfd_boolean copy,
		      bfd_boolean collect,
		      struct bfd_link_hash_entry **hashp)
{
  struct sunos_link_hash_entry *h;
  int new_flag;

  if ((flags & (BSF_INDIRECT | BSF_WARNING | BSF_CONSTRUCTOR)) != 0
      || ! bfd_is_und_section (section))
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, TRUE, copy,
				FALSE);
  else
    h = ((struct sunos_link_hash_entry *)
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
  if (h == NULL)
    return FALSE;

  if (hashp != NULL)
    *hashp = (struct bfd_link_hash_entry *) h;

  /* Treat a common symbol in a dynamic object as defined in the .bss
     section of the dynamic object.  We don't want to allocate space
     for it in our process image.  */
  if ((abfd->flags & DYNAMIC) != 0
      && bfd_is_com_section (section))
    section = obj_bsssec (abfd);

  if (! bfd_is_und_section (section)
      && h->root.root.type != bfd_link_hash_new
      && h->root.root.type != bfd_link_hash_undefined
      && h->root.root.type != bfd_link_hash_defweak)
    {
      /* We are defining the symbol, and it is already defined.  This
	 is a potential multiple definition error.  */
      if ((abfd->flags & DYNAMIC) != 0)
	{
	  /* The definition we are adding is from a dynamic object.
	     We do not want this new definition to override the
	     existing definition, so we pretend it is just a
	     reference.  */
	  section = bfd_und_section_ptr;
	}
      else if (h->root.root.type == bfd_link_hash_defined
	       && h->root.root.u.def.section->owner != NULL
	       && (h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
	{
	  /* The existing definition is from a dynamic object.  We
	     want to override it with the definition we just found.
	     Clobber the existing definition.  */
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = h->root.root.u.def.section->owner;
	}
      else if (h->root.root.type == bfd_link_hash_common
	       && (h->root.root.u.c.p->section->owner->flags & DYNAMIC) != 0)
	{
	  /* The existing definition is from a dynamic object.  We
	     want to override it with the definition we just found.
	     Clobber the existing definition.  We can't set it to new,
	     because it is on the undefined list.  */
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = h->root.root.u.c.p->section->owner;
	}
    }

  if ((abfd->flags & DYNAMIC) != 0
      && abfd->xvec == info->output_bfd->xvec
      && (h->flags & SUNOS_CONSTRUCTOR) != 0)
    /* The existing symbol is a constructor symbol, and this symbol
       is from a dynamic object.  A constructor symbol is actually a
       definition, although the type will be bfd_link_hash_undefined
       at this point.  We want to ignore the definition from the
       dynamic object.  */
    section = bfd_und_section_ptr;
  else if ((flags & BSF_CONSTRUCTOR) != 0
	   && (abfd->flags & DYNAMIC) == 0
	   && h->root.root.type == bfd_link_hash_defined
	   && h->root.root.u.def.section->owner != NULL
	   && (h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
    /* The existing symbol is defined by a dynamic object, and this
       is a constructor symbol.  As above, we want to force the use
       of the constructor symbol from the regular object.  */
    h->root.root.type = bfd_link_hash_new;

  /* Do the usual procedure for adding a symbol.  */
  if (! _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,
					  value, string, copy, collect,
					  hashp))
    return FALSE;

  if (abfd->xvec == info->output_bfd->xvec)
    {
      /* Set a flag in the hash table entry indicating the type of
	 reference or definition we just found.  Keep a count of the
	 number of dynamic symbols we find.  A dynamic symbol is one
	 which is referenced or defined by both a regular object and a
	 shared object.  */
      if ((abfd->flags & DYNAMIC) == 0)
	{
	  if (bfd_is_und_section (section))
	    new_flag = SUNOS_REF_REGULAR;
	  else
	    new_flag = SUNOS_DEF_REGULAR;
	}
      else
	{
	  if (bfd_is_und_section (section))
	    new_flag = SUNOS_REF_DYNAMIC;
	  else
	    new_flag = SUNOS_DEF_DYNAMIC;
	}
      h->flags |= new_flag;

      if (h->dynindx == -1
	  && (h->flags & (SUNOS_DEF_REGULAR | SUNOS_REF_REGULAR)) != 0)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}

      if ((flags & BSF_CONSTRUCTOR) != 0
	  && (abfd->flags & DYNAMIC) == 0)
	h->flags |= SUNOS_CONSTRUCTOR;
    }

  return TRUE;
}

extern const bfd_target MY (vec);

/* Return the list of objects needed by BFD.  */

struct bfd_link_needed_list *
bfd_sunos_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info)
{
  if (info->output_bfd->xvec != &MY (vec))
    return NULL;
  return sunos_hash_table (info)->needed;
}

/* Record an assignment made to a symbol by a linker script.  We need
   this in case some dynamic object refers to this symbol.  */

bfd_boolean
bfd_sunos_record_link_assignment (bfd *output_bfd,
				  struct bfd_link_info *info,
				  const char *name)
{
  struct sunos_link_hash_entry *h;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* This is called after we have examined all the input objects.  If
     the symbol does not exist, it merely means that no object refers
     to it, and we can just ignore it at this point.  */
  h = sunos_link_hash_lookup (sunos_hash_table (info), name,
			      FALSE, FALSE, FALSE);
  if (h == NULL)
    return TRUE;

  /* In a shared library, the __DYNAMIC symbol does not appear in the
     dynamic symbol table.  */
  if (! info->shared || strcmp (name, "__DYNAMIC") != 0)
    {
      h->flags |= SUNOS_DEF_REGULAR;

      if (h->dynindx == -1)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}
    }

  return TRUE;
}

/* Scan the relocs for an input section using standard relocs.  We
   need to figure out what to do for each reloc against a dynamic
   symbol.  If the symbol is in the .text section, an entry is made in
   the procedure linkage table.  Note that this will do the wrong
   thing if the symbol is actually data; I don't think the Sun 3
   native linker handles this case correctly either.  If the symbol is
   not in the .text section, we must preserve the reloc as a dynamic
   reloc.  FIXME: We should also handle the PIC relocs here by
   building global offset table entries.  */

static bfd_boolean
sunos_scan_std_relocs (struct bfd_link_info *info,
		       bfd *abfd,
		       asection *sec ATTRIBUTE_UNUSED,
		       const struct reloc_std_external *relocs,
		       bfd_size_type rel_size)
{
  bfd *dynobj;
  asection *splt = NULL;
  asection *srel = NULL;
  struct sunos_link_hash_entry **sym_hashes;
  const struct reloc_std_external *rel, *relend;

  /* We only know how to handle m68k plt entries.  */
  if (bfd_get_arch (abfd) != bfd_arch_m68k)
    {
      bfd_set_error (bfd_error_invalid_target);
      return FALSE;
    }

  dynobj = NULL;

  sym_hashes = (struct sunos_link_hash_entry **) obj_aout_sym_hashes (abfd);

  relend = relocs + rel_size / RELOC_STD_SIZE;
  for (rel = relocs; rel < relend; rel++)
    {
      int r_index;
      struct sunos_link_hash_entry *h;

      /* We only want relocs against external symbols.  */
      if (bfd_header_big_endian (abfd))
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG) == 0)
	    continue;
	}
      else
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE) == 0)
	    continue;
	}

      /* Get the symbol index.  */
      if (bfd_header_big_endian (abfd))
	r_index = ((rel->r_index[0] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[2]);
      else
	r_index = ((rel->r_index[2] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[0]);

      /* Get the hash table entry.  */
      h = sym_hashes[r_index];
      if (h == NULL)
	/* This should not normally happen, but it will in any case
	   be caught in the relocation phase.  */
	continue;

      /* At this point common symbols have already been allocated, so
	 we don't have to worry about them.  We need to consider that
	 we may have already seen this symbol and marked it undefined;
	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC
	 will be zero.  */
      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak
	  && h->root.root.type != bfd_link_hash_undefined)
	continue;

      if ((h->flags & SUNOS_DEF_DYNAMIC) == 0
	  || (h->flags & SUNOS_DEF_REGULAR) != 0)
	continue;

      if (dynobj == NULL)
	{
	  asection *sgot;

	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
	  dynobj = sunos_hash_table (info)->dynobj;
	  splt = bfd_get_linker_section (dynobj, ".plt");
	  srel = bfd_get_linker_section (dynobj, ".dynrel");
	  BFD_ASSERT (splt != NULL && srel != NULL);

	  sgot = bfd_get_linker_section (dynobj, ".got");
	  BFD_ASSERT (sgot != NULL);
	  if (sgot->size == 0)
	    sgot->size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = TRUE;
	}

      BFD_ASSERT ((h->flags & SUNOS_REF_REGULAR) != 0);
      BFD_ASSERT (h->plt_offset != 0
		  || ((h->root.root.type == bfd_link_hash_defined
		       || h->root.root.type == bfd_link_hash_defweak)
		      ? (h->root.root.u.def.section->owner->flags
			 & DYNAMIC) != 0
		      : (h->root.root.u.undef.abfd->flags & DYNAMIC) != 0));

      /* This reloc is against a symbol defined only by a dynamic
	 object.  */
      if (h->root.root.type == bfd_link_hash_undefined)
	/* Presumably this symbol was marked as being undefined by
	   an earlier reloc.  */
	srel->size += RELOC_STD_SIZE;
      else if ((h->root.root.u.def.section->flags & SEC_CODE) == 0)
	{
	  bfd *sub;

	  /* This reloc is not in the .text section.  It must be
	     copied into the dynamic relocs.  We mark the symbol as
	     being undefined.  */
	  srel->size += RELOC_STD_SIZE;
	  sub = h->root.root.u.def.section->owner;
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = sub;
	}
      else
	{
	  /* This symbol is in the .text section.  We must give it an
	     entry in the procedure linkage table, if we have not
	     already done so.  We change the definition of the symbol
	     to the .plt section; this will cause relocs against it to
	     be handled correctly.  */
	  if (h->plt_offset == 0)
	    {
	      if (splt->size == 0)
		splt->size = M68K_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->size;

	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		{
		  h->root.root.u.def.section = splt;
		  h->root.root.u.def.value = splt->size;
		}

	      splt->size += M68K_PLT_ENTRY_SIZE;

	      /* We may also need a dynamic reloc entry.  */
	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		srel->size += RELOC_STD_SIZE;
	    }
	}
    }

  return TRUE;
}

/* Scan the relocs for an input section using extended relocs.  We
   need to figure out what to do for each reloc against a dynamic
   symbol.  If the reloc is a WDISP30, and the symbol is in the .text
   section, an entry is made in the procedure linkage table.
   Otherwise, we must preserve the reloc as a dynamic reloc.  */

static bfd_boolean
sunos_scan_ext_relocs (struct bfd_link_info *info,
		       bfd *abfd,
		       asection *sec ATTRIBUTE_UNUSED,
		       const struct reloc_ext_external *relocs,
		       bfd_size_type rel_size)
{
  bfd *dynobj;
  struct sunos_link_hash_entry **sym_hashes;
  const struct reloc_ext_external *rel, *relend;
  asection *splt = NULL;
  asection *sgot = NULL;
  asection *srel = NULL;
  bfd_size_type amt;

  /* We only know how to handle SPARC plt entries.  */
  if (bfd_get_arch (abfd) != bfd_arch_sparc)
    {
      bfd_set_error (bfd_error_invalid_target);
      return FALSE;
    }

  dynobj = NULL;

  sym_hashes = (struct sunos_link_hash_entry **) obj_aout_sym_hashes (abfd);

  relend = relocs + rel_size / RELOC_EXT_SIZE;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned int r_index;
      int r_extern;
      int r_type;
      struct sunos_link_hash_entry *h = NULL;

      /* Swap in the reloc information.  */
      if (bfd_header_big_endian (abfd))
	{
	  r_index = ((rel->r_index[0] << 16)
		     | (rel->r_index[1] << 8)
		     | rel->r_index[2]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
	  r_type = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		    >> RELOC_EXT_BITS_TYPE_SH_BIG);
	}
      else
	{
	  r_index = ((rel->r_index[2] << 16)
		     | (rel->r_index[1] << 8)
		     | rel->r_index[0]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
	  r_type = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		    >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}

      if (r_extern)
	{
	  h = sym_hashes[r_index];
	  if (h == NULL)
	    {
	      /* This should not normally happen, but it will in any
		 case be caught in the relocation phase.  */
	      continue;
	    }
	}

      /* If this is a base relative reloc, we need to make an entry in
	 the .got section.  */
      if (r_type == RELOC_BASE10
	  || r_type == RELOC_BASE13
	  || r_type == RELOC_BASE22)
	{
	  if (dynobj == NULL)
	    {
	      if (! sunos_create_dynamic_sections (abfd, info, FALSE))
		return FALSE;
	      dynobj = sunos_hash_table (info)->dynobj;
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      srel = bfd_get_linker_section (dynobj, ".dynrel");
	      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

	      /* Make sure we have an initial entry in the .got table.  */
	      if (sgot->size == 0)
		sgot->size = BYTES_IN_WORD;
	      sunos_hash_table (info)->got_needed = TRUE;
	    }

	  if (r_extern)
	    {
	      if (h->got_offset != 0)
		continue;

	      h->got_offset = sgot->size;
	    }
	  else
	    {
	      if (r_index >= bfd_get_symcount (abfd))
		/* This is abnormal, but should be caught in the
		   relocation phase.  */
		continue;

	      if (adata (abfd).local_got_offsets == NULL)
		{
		  amt = bfd_get_symcount (abfd);
		  amt *= sizeof (bfd_vma);
		  adata (abfd).local_got_offsets = bfd_zalloc (abfd, amt);
		  if (adata (abfd).local_got_offsets == NULL)
		    return FALSE;
		}

	      if (adata (abfd).local_got_offsets[r_index] != 0)
		continue;

	      adata (abfd).local_got_offsets[r_index] = sgot->size;
	    }

	  sgot->size += BYTES_IN_WORD;

	  /* If we are making a shared library, or if the symbol is
	     defined by a dynamic object, we will need a dynamic reloc
	     entry.  */
	  if (info->shared
	      || (h != NULL
		  && (h->flags & SUNOS_DEF_DYNAMIC) != 0
		  && (h->flags & SUNOS_DEF_REGULAR) == 0))
	    srel->size += RELOC_EXT_SIZE;

	  continue;
	}

      /* Otherwise, we are only interested in relocs against symbols
	 defined in dynamic objects but not in regular objects.  We
	 only need to consider relocs against external symbols.  */
      if (! r_extern)
	{
	  /* But, if we are creating a shared library, we need to
	     generate an absolute reloc.  */
	  if (info->shared)
	    {
	      if (dynobj == NULL)
		{
		  if (! sunos_create_dynamic_sections (abfd, info, TRUE))
		    return FALSE;
		  dynobj = sunos_hash_table (info)->dynobj;
		  splt = bfd_get_linker_section (dynobj, ".plt");
		  sgot = bfd_get_linker_section (dynobj, ".got");
		  srel = bfd_get_linker_section (dynobj, ".dynrel");
		  BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);
		}

	      srel->size += RELOC_EXT_SIZE;
	    }

	  continue;
	}

      /* At this point common symbols have already been allocated, so
	 we don't have to worry about them.  We need to consider that
	 we may have already seen this symbol and marked it undefined;
	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC
	 will be zero.  */
      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak
	  && h->root.root.type != bfd_link_hash_undefined)
	continue;

      if (r_type != RELOC_JMP_TBL
	  && ! info->shared
	  && ((h->flags & SUNOS_DEF_DYNAMIC) == 0
	      || (h->flags & SUNOS_DEF_REGULAR) != 0))
	continue;

      if (r_type == RELOC_JMP_TBL
	  && ! info->shared
	  && (h->flags & SUNOS_DEF_DYNAMIC) == 0
	  && (h->flags & SUNOS_DEF_REGULAR) == 0)
	{
	  /* This symbol is apparently undefined.  Don't do anything
	     here; just let the relocation routine report an undefined
	     symbol.  */
	  continue;
	}

      if (strcmp (h->root.root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	continue;

      if (dynobj == NULL)
	{
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
	  dynobj = sunos_hash_table (info)->dynobj;
	  splt = bfd_get_linker_section (dynobj, ".plt");
	  sgot = bfd_get_linker_section (dynobj, ".got");
	  srel = bfd_get_linker_section (dynobj, ".dynrel");
	  BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

	  /* Make sure we have an initial entry in the .got table.  */
	  if (sgot->size == 0)
	    sgot->size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = TRUE;
	}

      BFD_ASSERT (r_type == RELOC_JMP_TBL
		  || info->shared
		  || (h->flags & SUNOS_REF_REGULAR) != 0);
      BFD_ASSERT (r_type == RELOC_JMP_TBL
		  || info->shared
		  || h->plt_offset != 0
		  || ((h->root.root.type == bfd_link_hash_defined
		       || h->root.root.type == bfd_link_hash_defweak)
		      ? (h->root.root.u.def.section->owner->flags
			 & DYNAMIC) != 0
		      : (h->root.root.u.undef.abfd->flags & DYNAMIC) != 0));

      /* This reloc is against a symbol defined only by a dynamic
	 object, or it is a jump table reloc from PIC compiled code.  */

      if (r_type != RELOC_JMP_TBL
	  && h->root.root.type == bfd_link_hash_undefined)
	/* Presumably this symbol was marked as being undefined by
	   an earlier reloc.  */
	srel->size += RELOC_EXT_SIZE;

      else if (r_type != RELOC_JMP_TBL
	       && (h->root.root.u.def.section->flags & SEC_CODE) == 0)
	{
	  bfd *sub;

	  /* This reloc is not in the .text section.  It must be
	     copied into the dynamic relocs.  We mark the symbol as
	     being undefined.  */
	  srel->size += RELOC_EXT_SIZE;
	  if ((h->flags & SUNOS_DEF_REGULAR) == 0)
	    {
	      sub = h->root.root.u.def.section->owner;
	      h->root.root.type = bfd_link_hash_undefined;
	      h->root.root.u.undef.abfd = sub;
	    }
	}
      else
	{
	  /* This symbol is in the .text section.  We must give it an
	     entry in the procedure linkage table, if we have not
	     already done so.  We change the definition of the symbol
	     to the .plt section; this will cause relocs against it to
	     be handled correctly.  */
	  if (h->plt_offset == 0)
	    {
	      if (splt->size == 0)
		splt->size = SPARC_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->size;

	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		{
		  if (h->root.root.type == bfd_link_hash_undefined)
		    h->root.root.type = bfd_link_hash_defined;
		  h->root.root.u.def.section = splt;
		  h->root.root.u.def.value = splt->size;
		}

	      splt->size += SPARC_PLT_ENTRY_SIZE;

	      /* We will also need a dynamic reloc entry, unless this
		 is a JMP_TBL reloc produced by linking PIC compiled
		 code, and we are not making a shared library.  */
	      if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
		srel->size += RELOC_EXT_SIZE;
	    }

	  /* If we are creating a shared library, we need to copy over
	     any reloc other than a jump table reloc.  */
	  if (info->shared && r_type != RELOC_JMP_TBL)
	    srel->size += RELOC_EXT_SIZE;
	}
    }

  return TRUE;
}

/* Scan the relocs for an input section.  */

static bfd_boolean
sunos_scan_relocs (struct bfd_link_info *info,
		   bfd *abfd,
		   asection *sec,
		   bfd_size_type rel_size)
{
  void * relocs;
  void * free_relocs = NULL;

  if (rel_size == 0)
    return TRUE;

  if (! info->keep_memory)
    relocs = free_relocs = bfd_malloc (rel_size);
  else
    {
      struct aout_section_data_struct *n;
      bfd_size_type amt = sizeof (struct aout_section_data_struct);

      n = bfd_alloc (abfd, amt);
      if (n == NULL)
	relocs = NULL;
      else
	{
	  set_aout_section_data (sec, n);
	  relocs = bfd_malloc (rel_size);
	  aout_section_data (sec)->relocs = relocs;
	}
    }
  if (relocs == NULL)
    return FALSE;

  if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
      || bfd_bread (relocs, rel_size, abfd) != rel_size)
    goto error_return;

  if (obj_reloc_entry_size (abfd) == RELOC_STD_SIZE)
    {
      if (! sunos_scan_std_relocs (info, abfd, sec,
				   (struct reloc_std_external *) relocs,
				   rel_size))
	goto error_return;
    }
  else
    {
      if (! sunos_scan_ext_relocs (info, abfd, sec,
				   (struct reloc_ext_external *) relocs,
				   rel_size))
	goto error_return;
    }

  if (free_relocs != NULL)
    free (free_relocs);

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  return FALSE;
}

/* Build the hash table of dynamic symbols, and to mark as written all
   symbols from dynamic objects which we do not plan to write out.  */

static bfd_boolean
sunos_scan_dynamic_symbol (struct sunos_link_hash_entry *h, void * data)
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;

  /* Set the written flag for symbols we do not want to write out as
     part of the regular symbol table.  This is all symbols which are
     not defined in a regular object file.  For some reason symbols
     which are referenced by a regular object and defined by a dynamic
     object do not seem to show up in the regular symbol table.  It is
     possible for a symbol to have only SUNOS_REF_REGULAR set here, it
     is an undefined symbol which was turned into a common symbol
     because it was found in an archive object which was not included
     in the link.  */
  if ((h->flags & SUNOS_DEF_REGULAR) == 0
      && (h->flags & SUNOS_DEF_DYNAMIC) != 0
      && strcmp (h->root.root.root.string, "__DYNAMIC") != 0)
    h->root.written = TRUE;

  /* If this symbol is defined by a dynamic object and referenced by a
     regular object, see whether we gave it a reasonable value while
     scanning the relocs.  */
  if ((h->flags & SUNOS_DEF_REGULAR) == 0
      && (h->flags & SUNOS_DEF_DYNAMIC) != 0
      && (h->flags & SUNOS_REF_REGULAR) != 0)
    {
      if ((h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
	  && ((h->root.root.u.def.section->owner->flags & DYNAMIC) != 0)
	  && h->root.root.u.def.section->output_section == NULL)
	{
	  bfd *sub;

	  /* This symbol is currently defined in a dynamic section
	     which is not being put into the output file.  This
	     implies that there is no reloc against the symbol.  I'm
	     not sure why this case would ever occur.  In any case, we
	     change the symbol to be undefined.  */
	  sub = h->root.root.u.def.section->owner;
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = sub;
	}
    }

  /* If this symbol is defined or referenced by a regular file, add it
     to the dynamic symbols.  */
  if ((h->flags & (SUNOS_DEF_REGULAR | SUNOS_REF_REGULAR)) != 0)
    {
      asection *s;
      size_t len;
      bfd_byte *contents;
      unsigned char *name;
      unsigned long hash;
      bfd *dynobj;

      BFD_ASSERT (h->dynindx == -2);

      dynobj = sunos_hash_table (info)->dynobj;

      h->dynindx = sunos_hash_table (info)->dynsymcount;
      ++sunos_hash_table (info)->dynsymcount;

      len = strlen (h->root.root.root.string);

      /* We don't bother to construct a BFD hash table for the strings
	 which are the names of the dynamic symbols.  Using a hash
	 table for the regular symbols is beneficial, because the
	 regular symbols includes the debugging symbols, which have
	 long names and are often duplicated in several object files.
	 There are no debugging symbols in the dynamic symbols.  */
      s = bfd_get_linker_section (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      contents = bfd_realloc (s->contents, s->size + len + 1);
      if (contents == NULL)
	return FALSE;
      s->contents = contents;

      h->dynstr_index = s->size;
      strcpy ((char *) contents + s->size, h->root.root.root.string);
      s->size += len + 1;

      /* Add it to the dynamic hash table.  */
      name = (unsigned char *) h->root.root.root.string;
      hash = 0;
      while (*name != '\0')
	hash = (hash << 1) + *name++;
      hash &= 0x7fffffff;
      hash %= sunos_hash_table (info)->bucketcount;

      s = bfd_get_linker_section (dynobj, ".hash");
      BFD_ASSERT (s != NULL);

      if (GET_SWORD (dynobj, s->contents + hash * HASH_ENTRY_SIZE) == -1)
	PUT_WORD (dynobj, h->dynindx, s->contents + hash * HASH_ENTRY_SIZE);
      else
	{
	  bfd_vma next;

	  next = GET_WORD (dynobj,
			   (s->contents
			    + hash * HASH_ENTRY_SIZE
			    + BYTES_IN_WORD));
	  PUT_WORD (dynobj, s->size / HASH_ENTRY_SIZE,
		    s->contents + hash * HASH_ENTRY_SIZE + BYTES_IN_WORD);
	  PUT_WORD (dynobj, h->dynindx, s->contents + s->size);
	  PUT_WORD (dynobj, next, s->contents + s->size + BYTES_IN_WORD);
	  s->size += HASH_ENTRY_SIZE;
	}
    }

  return TRUE;
}

/* Set up the sizes and contents of the dynamic sections created in
   sunos_add_dynamic_symbols.  This is called by the SunOS linker
   emulation before_allocation routine.  We must set the sizes of the
   sections before the linker sets the addresses of the various
   sections.  This unfortunately requires reading all the relocs so
   that we can work out which ones need to become dynamic relocs.  If
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
   we discard them, and will read them again later.  */

bfd_boolean
bfd_sunos_size_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info,
				 asection **sdynptr,
				 asection **sneedptr,
				 asection **srulesptr)
{
  bfd *dynobj;
  bfd_size_type dynsymcount;
  struct sunos_link_hash_entry *h;
  asection *s;
  size_t bucketcount;
  bfd_size_type hashalloc;
  size_t i;
  bfd *sub;

  *sdynptr = NULL;
  *sneedptr = NULL;
  *srulesptr = NULL;

  if (info->relocatable)
    return TRUE;

  if (output_bfd->xvec != &MY(vec))
    return TRUE;

  /* Look through all the input BFD's and read their relocs.  It would
     be better if we didn't have to do this, but there is no other way
     to determine the number of dynamic relocs we need, and, more
     importantly, there is no other way to know which symbols should
     get an entry in the procedure linkage table.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      if ((sub->flags & DYNAMIC) == 0
	  && sub->xvec == output_bfd->xvec)
	{
	  if (! sunos_scan_relocs (info, sub, obj_textsec (sub),
				   exec_hdr (sub)->a_trsize)
	      || ! sunos_scan_relocs (info, sub, obj_datasec (sub),
				      exec_hdr (sub)->a_drsize))
	    return FALSE;
	}
    }

  dynobj = sunos_hash_table (info)->dynobj;
  dynsymcount = sunos_hash_table (info)->dynsymcount;

  /* If there were no dynamic objects in the link, and we don't need
     to build a global offset table, there is nothing to do here.  */
  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
    return TRUE;

  /* If __GLOBAL_OFFSET_TABLE_ was mentioned, define it.  */
  h = sunos_link_hash_lookup (sunos_hash_table (info),
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
  if (h != NULL && (h->flags & SUNOS_REF_REGULAR) != 0)
    {
      h->flags |= SUNOS_DEF_REGULAR;
      if (h->dynindx == -1)
	{
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
	}
      s = bfd_get_linker_section (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      h->root.root.type = bfd_link_hash_defined;
      h->root.root.u.def.section = s;

      /* If the .got section is more than 0x1000 bytes, we set
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
      if (s->size >= 0x1000)
	h->root.root.u.def.value = 0x1000;
      else
	h->root.root.u.def.value = 0;

      sunos_hash_table (info)->got_base = h->root.root.u.def.value;
    }

  /* If there are any shared objects in the link, then we need to set
     up the dynamic linking information.  */
  if (sunos_hash_table (info)->dynamic_sections_needed)
    {
      *sdynptr = bfd_get_linker_section (dynobj, ".dynamic");

      /* The .dynamic section is always the same size.  */
      s = *sdynptr;
      BFD_ASSERT (s != NULL);
      s->size = (sizeof (struct external_sun4_dynamic)
		      + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
		      + sizeof (struct external_sun4_dynamic_link));

      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols as we read the input files.  We
	 will build the dynamic symbol table (.dynsym) and the hash
	 table (.hash) when we build the final symbol table, because
	 until then we do not know the correct value to give the
	 symbols.  We build the dynamic symbol string table (.dynstr)
	 in a traversal of the symbol table using
	 sunos_scan_dynamic_symbol.  */
      s = bfd_get_linker_section (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->size = dynsymcount * sizeof (struct external_nlist);
      s->contents = bfd_alloc (output_bfd, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;

      /* The number of buckets is just the number of symbols divided
	 by four.  To compute the final size of the hash table, we
	 must actually compute the hash table.  Normally we need
	 exactly as many entries in the hash table as there are
	 dynamic symbols, but if some of the buckets are not used we
	 will need additional entries.  In the worst case, every
	 symbol will hash to the same bucket, and we will need
	 BUCKETCOUNT - 1 extra entries.  */
      if (dynsymcount >= 4)
	bucketcount = dynsymcount / 4;
      else if (dynsymcount > 0)
	bucketcount = dynsymcount;
      else
	bucketcount = 1;
      s = bfd_get_linker_section (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hashalloc = (dynsymcount + bucketcount - 1) * HASH_ENTRY_SIZE;
      s->contents = bfd_zalloc (dynobj, hashalloc);
      if (s->contents == NULL && dynsymcount > 0)
	return FALSE;
      for (i = 0; i < bucketcount; i++)
	PUT_WORD (output_bfd, (bfd_vma) -1, s->contents + i * HASH_ENTRY_SIZE);
      s->size = bucketcount * HASH_ENTRY_SIZE;

      sunos_hash_table (info)->bucketcount = bucketcount;

      /* Scan all the symbols, place them in the dynamic symbol table,
	 and build the dynamic hash table.  We reuse dynsymcount as a
	 counter for the number of symbols we have added so far.  */
      sunos_hash_table (info)->dynsymcount = 0;
      sunos_link_hash_traverse (sunos_hash_table (info),
				sunos_scan_dynamic_symbol,
				(void *) info);
      BFD_ASSERT (sunos_hash_table (info)->dynsymcount == dynsymcount);

      /* The SunOS native linker seems to align the total size of the
	 symbol strings to a multiple of 8.  I don't know if this is
	 important, but it can't hurt much.  */
      s = bfd_get_linker_section (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      if ((s->size & 7) != 0)
	{
	  bfd_size_type add;
	  bfd_byte *contents;

	  add = 8 - (s->size & 7);
	  contents = bfd_realloc (s->contents, s->size + add);
	  if (contents == NULL)
	    return FALSE;
	  memset (contents + s->size, 0, (size_t) add);
	  s->contents = contents;
	  s->size += add;
	}
    }

  /* Now that we have worked out the sizes of the procedure linkage
     table and the dynamic relocs, allocate storage for them.  */
  s = bfd_get_linker_section (dynobj, ".plt");
  BFD_ASSERT (s != NULL);
  if (s->size != 0)
    {
      s->contents = bfd_alloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;

      /* Fill in the first entry in the table.  */
      switch (bfd_get_arch (dynobj))
	{
	case bfd_arch_sparc:
	  memcpy (s->contents, sparc_plt_first_entry, SPARC_PLT_ENTRY_SIZE);
	  break;

	case bfd_arch_m68k:
	  memcpy (s->contents, m68k_plt_first_entry, M68K_PLT_ENTRY_SIZE);
	  break;

	default:
	  abort ();
	}
    }

  s = bfd_get_linker_section (dynobj, ".dynrel");
  if (s->size != 0)
    {
      s->contents = bfd_alloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }
  /* We use the reloc_count field to keep track of how many of the
     relocs we have output so far.  */
  s->reloc_count = 0;

  /* Make space for the global offset table.  */
  s = bfd_get_linker_section (dynobj, ".got");
  s->contents = bfd_alloc (dynobj, s->size);
  if (s->contents == NULL)
    return FALSE;

  *sneedptr = bfd_get_section_by_name (dynobj, ".need");
  *srulesptr = bfd_get_section_by_name (dynobj, ".rules");

  return TRUE;
}

/* Link a dynamic object.  We actually don't have anything to do at
   this point.  This entry point exists to prevent the regular linker
   code from doing anything with the object.  */

static bfd_boolean
sunos_link_dynamic_object (struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   bfd *abfd ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Write out a dynamic symbol.  This is called by the final traversal
   over the symbol table.  */

static bfd_boolean
sunos_write_dynamic_symbol (bfd *output_bfd,
			    struct bfd_link_info *info,
			    struct aout_link_hash_entry *harg)
{
  struct sunos_link_hash_entry *h = (struct sunos_link_hash_entry *) harg;
  int type;
  bfd_vma val;
  asection *s;
  struct external_nlist *outsym;

  /* If this symbol is in the procedure linkage table, fill in the
     table entry.  */
  if (h->plt_offset != 0)
    {
      bfd *dynobj;
      asection *splt;
      bfd_byte *p;
      bfd_vma r_address;

      dynobj = sunos_hash_table (info)->dynobj;
      splt = bfd_get_linker_section (dynobj, ".plt");
      p = splt->contents + h->plt_offset;

      s = bfd_get_linker_section (dynobj, ".dynrel");

      r_address = (splt->output_section->vma
		   + splt->output_offset
		   + h->plt_offset);

      switch (bfd_get_arch (output_bfd))
	{
	case bfd_arch_sparc:
	  if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
	    {
	      bfd_put_32 (output_bfd, SPARC_PLT_ENTRY_WORD0, p);
	      bfd_put_32 (output_bfd,
			  (SPARC_PLT_ENTRY_WORD1
			   + (((- (h->plt_offset + 4) >> 2)
			       & 0x3fffffff))),
			  p + 4);
	      bfd_put_32 (output_bfd, SPARC_PLT_ENTRY_WORD2 + s->reloc_count,
			  p + 8);
	    }
	  else
	    {
	      val = (h->root.root.u.def.section->output_section->vma
		     + h->root.root.u.def.section->output_offset
		     + h->root.root.u.def.value);
	      bfd_put_32 (output_bfd,
			  SPARC_PLT_PIC_WORD0 + ((val >> 10) & 0x3fffff),
			  p);
	      bfd_put_32 (output_bfd,
			  SPARC_PLT_PIC_WORD1 + (val & 0x3ff),
			  p + 4);
	      bfd_put_32 (output_bfd, SPARC_PLT_PIC_WORD2, p + 8);
	    }
	  break;

	case bfd_arch_m68k:
	  if (! info->shared && (h->flags & SUNOS_DEF_REGULAR) != 0)
	    abort ();
	  bfd_put_16 (output_bfd, M68K_PLT_ENTRY_WORD0, p);
	  bfd_put_32 (output_bfd, (- (h->plt_offset + 2)), p + 2);
	  bfd_put_16 (output_bfd, (bfd_vma) s->reloc_count, p + 6);
	  r_address += 2;
	  break;

	default:
	  abort ();
	}

      /* We also need to add a jump table reloc, unless this is the
	 result of a JMP_TBL reloc from PIC compiled code.  */
      if (info->shared || (h->flags & SUNOS_DEF_REGULAR) == 0)
	{
	  BFD_ASSERT (h->dynindx >= 0);
	  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
		      < s->size);
	  p = s->contents + s->reloc_count * obj_reloc_entry_size (output_bfd);
	  if (obj_reloc_entry_size (output_bfd) == RELOC_STD_SIZE)
	    {
	      struct reloc_std_external *srel;

	      srel = (struct reloc_std_external *) p;
	      PUT_WORD (output_bfd, r_address, srel->r_address);
	      if (bfd_header_big_endian (output_bfd))
		{
		  srel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte) (h->dynindx);
		  srel->r_type[0] = (RELOC_STD_BITS_EXTERN_BIG
				     | RELOC_STD_BITS_JMPTABLE_BIG);
		}
	      else
		{
		  srel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  srel->r_index[0] = (bfd_byte)h->dynindx;
		  srel->r_type[0] = (RELOC_STD_BITS_EXTERN_LITTLE
				     | RELOC_STD_BITS_JMPTABLE_LITTLE);
		}
	    }
	  else
	    {
	      struct reloc_ext_external *erel;

	      erel = (struct reloc_ext_external *) p;
	      PUT_WORD (output_bfd, r_address, erel->r_address);
	      if (bfd_header_big_endian (output_bfd))
		{
		  erel->r_index[0] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  erel->r_index[2] = (bfd_byte)h->dynindx;
		  erel->r_type[0] =
		    (RELOC_EXT_BITS_EXTERN_BIG
		     | (RELOC_JMP_SLOT << RELOC_EXT_BITS_TYPE_SH_BIG));
		}
	      else
		{
		  erel->r_index[2] = (bfd_byte) (h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte) (h->dynindx >> 8);
		  erel->r_index[0] = (bfd_byte)h->dynindx;
		  erel->r_type[0] =
		    (RELOC_EXT_BITS_EXTERN_LITTLE
		     | (RELOC_JMP_SLOT << RELOC_EXT_BITS_TYPE_SH_LITTLE));
		}
	      PUT_WORD (output_bfd, (bfd_vma) 0, erel->r_addend);
	    }

	  ++s->reloc_count;
	}
    }

  /* If this is not a dynamic symbol, we don't have to do anything
     else.  We only check this after handling the PLT entry, because
     we can have a PLT entry for a nondynamic symbol when linking PIC
     compiled code from a regular object.  */
  if (h->dynindx < 0)
    return TRUE;

  switch (h->root.root.type)
    {
    default:
    case bfd_link_hash_new:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return TRUE;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;
	asection *output_section;

	sec = h->root.root.u.def.section;
	output_section = sec->output_section;
	BFD_ASSERT (bfd_is_abs_section (output_section)
		    || output_section->owner == output_bfd);
	if (h->plt_offset != 0
	    && (h->flags & SUNOS_DEF_REGULAR) == 0)
	  {
	    type = N_UNDF | N_EXT;
	    val = 0;
	  }
	else
	  {
	    if (output_section == obj_textsec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_TEXT
		      : N_WEAKT);
	    else if (output_section == obj_datasec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_DATA
		      : N_WEAKD);
	    else if (output_section == obj_bsssec (output_bfd))
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_BSS
		      : N_WEAKB);
	    else
	      type = (h->root.root.type == bfd_link_hash_defined
		      ? N_ABS
		      : N_WEAKA);
	    type |= N_EXT;
	    val = (h->root.root.u.def.value
		   + output_section->vma
		   + sec->output_offset);
	  }
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
      break;
    case bfd_link_hash_indirect:
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
      return TRUE;
    }

  s = bfd_get_linker_section (sunos_hash_table (info)->dynobj, ".dynsym");
  BFD_ASSERT (s != NULL);
  outsym = ((struct external_nlist *)
	    (s->contents + h->dynindx * EXTERNAL_NLIST_SIZE));

  H_PUT_8 (output_bfd, type, outsym->e_type);
  H_PUT_8 (output_bfd, 0, outsym->e_other);

  /* FIXME: The native linker doesn't use 0 for desc.  It seems to use
     one less than the desc value in the shared library, although that
     seems unlikely.  */
  H_PUT_16 (output_bfd, 0, outsym->e_desc);

  PUT_WORD (output_bfd, h->dynstr_index, outsym->e_strx);
  PUT_WORD (output_bfd, val, outsym->e_value);

  return TRUE;
}

/* This is called for each reloc against an external symbol.  If this
   is a reloc which are are going to copy as a dynamic reloc, then
   copy it over, and tell the caller to not bother processing this
   reloc.  */

static bfd_boolean
sunos_check_dynamic_reloc (struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   struct aout_link_hash_entry *harg,
			   void * reloc,
			   bfd_byte *contents ATTRIBUTE_UNUSED,
			   bfd_boolean *skip,
			   bfd_vma *relocationp)
{
  struct sunos_link_hash_entry *h = (struct sunos_link_hash_entry *) harg;
  bfd *dynobj;
  bfd_boolean baserel;
  bfd_boolean jmptbl;
  bfd_boolean pcrel;
  asection *s;
  bfd_byte *p;
  long indx;

  *skip = FALSE;

  dynobj = sunos_hash_table (info)->dynobj;

  if (h != NULL
      && h->plt_offset != 0
      && (info->shared
	  || (h->flags & SUNOS_DEF_REGULAR) == 0))
    {
      asection *splt;

      /* Redirect the relocation to the PLT entry.  */
      splt = bfd_get_linker_section (dynobj, ".plt");
      *relocationp = (splt->output_section->vma
		      + splt->output_offset
		      + h->plt_offset);
    }

  if (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE)
    {
      struct reloc_std_external *srel;

      srel = (struct reloc_std_external *) reloc;
      if (bfd_header_big_endian (input_bfd))
	{
	  baserel = (0 != (srel->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
	  jmptbl = (0 != (srel->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
	}
      else
	{
	  baserel = (0 != (srel->r_type[0] & RELOC_STD_BITS_BASEREL_LITTLE));
	  jmptbl = (0 != (srel->r_type[0] & RELOC_STD_BITS_JMPTABLE_LITTLE));
	  pcrel = (0 != (srel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
	}
    }
  else
    {
      struct reloc_ext_external *erel;
      int r_type;

      erel = (struct reloc_ext_external *) reloc;
      if (bfd_header_big_endian (input_bfd))
	r_type = ((erel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		  >> RELOC_EXT_BITS_TYPE_SH_BIG);
      else
	r_type = ((erel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		  >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
      baserel = (r_type == RELOC_BASE10
		 || r_type == RELOC_BASE13
		 || r_type == RELOC_BASE22);
      jmptbl = r_type == RELOC_JMP_TBL;
      pcrel = (r_type == RELOC_DISP8
	       || r_type == RELOC_DISP16
	       || r_type == RELOC_DISP32
	       || r_type == RELOC_WDISP30
	       || r_type == RELOC_WDISP22);
      /* We don't consider the PC10 and PC22 types to be PC relative,
	 because they are pcrel_offset.  */
    }

  if (baserel)
    {
      bfd_vma *got_offsetp;
      asection *sgot;

      if (h != NULL)
	got_offsetp = &h->got_offset;
      else if (adata (input_bfd).local_got_offsets == NULL)
	got_offsetp = NULL;
      else
	{
	  struct reloc_std_external *srel;
	  int r_index;

	  srel = (struct reloc_std_external *) reloc;
	  if (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE)
	    {
	      if (bfd_header_big_endian (input_bfd))
		r_index = ((srel->r_index[0] << 16)
			   | (srel->r_index[1] << 8)
			   | srel->r_index[2]);
	      else
		r_index = ((srel->r_index[2] << 16)
			   | (srel->r_index[1] << 8)
			   | srel->r_index[0]);
	    }
	  else
	    {
	      struct reloc_ext_external *erel;

	      erel = (struct reloc_ext_external *) reloc;
	      if (bfd_header_big_endian (input_bfd))
		r_index = ((erel->r_index[0] << 16)
			   | (erel->r_index[1] << 8)
			   | erel->r_index[2]);
	      else
		r_index = ((erel->r_index[2] << 16)
			   | (erel->r_index[1] << 8)
			   | erel->r_index[0]);
	    }

	  got_offsetp = adata (input_bfd).local_got_offsets + r_index;
	}

      BFD_ASSERT (got_offsetp != NULL && *got_offsetp != 0);

      sgot = bfd_get_linker_section (dynobj, ".got");

      /* We set the least significant bit to indicate whether we have
	 already initialized the GOT entry.  */
      if ((*got_offsetp & 1) == 0)
	{
	  if (h == NULL
	      || (! info->shared
		  && ((h->flags & SUNOS_DEF_DYNAMIC) == 0
		      || (h->flags & SUNOS_DEF_REGULAR) != 0)))
	    PUT_WORD (dynobj, *relocationp, sgot->contents + *got_offsetp);
	  else
	    PUT_WORD (dynobj, 0, sgot->contents + *got_offsetp);

	  if (info->shared
	      || (h != NULL
		  && (h->flags & SUNOS_DEF_DYNAMIC) != 0
		  && (h->flags & SUNOS_DEF_REGULAR) == 0))
	    {
	      /* We need to create a GLOB_DAT or 32 reloc to tell the
		 dynamic linker to fill in this entry in the table.  */

	      s = bfd_get_linker_section (dynobj, ".dynrel");
	      BFD_ASSERT (s != NULL);
	      BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
			  < s->size);

	      p = (s->contents
		   + s->reloc_count * obj_reloc_entry_size (dynobj));

	      if (h != NULL)
		indx = h->dynindx;
	      else
		indx = 0;

	      if (obj_reloc_entry_size (dynobj) == RELOC_STD_SIZE)
		{
		  struct reloc_std_external *srel;

		  srel = (struct reloc_std_external *) p;
		  PUT_WORD (dynobj,
			    (*got_offsetp
			     + sgot->output_section->vma
			     + sgot->output_offset),
			    srel->r_address);
		  if (bfd_header_big_endian (dynobj))
		    {
		      srel->r_index[0] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
		      srel->r_index[2] = (bfd_byte)indx;
		      if (h == NULL)
			srel->r_type[0] = 2 << RELOC_STD_BITS_LENGTH_SH_BIG;
		      else
			srel->r_type[0] =
			  (RELOC_STD_BITS_EXTERN_BIG
			   | RELOC_STD_BITS_BASEREL_BIG
			   | RELOC_STD_BITS_RELATIVE_BIG
			   | (2 << RELOC_STD_BITS_LENGTH_SH_BIG));
		    }
		  else
		    {
		      srel->r_index[2] = (bfd_byte) (indx >> 16);
		      srel->r_index[1] = (bfd_byte) (indx >> 8);
		      srel->r_index[0] = (bfd_byte)indx;
		      if (h == NULL)
			srel->r_type[0] = 2 << RELOC_STD_BITS_LENGTH_SH_LITTLE;
		      else
			srel->r_type[0] =
			  (RELOC_STD_BITS_EXTERN_LITTLE
			   | RELOC_STD_BITS_BASEREL_LITTLE
			   | RELOC_STD_BITS_RELATIVE_LITTLE
			   | (2 << RELOC_STD_BITS_LENGTH_SH_LITTLE));
		    }
		}
	      else
		{
		  struct reloc_ext_external *erel;

		  erel = (struct reloc_ext_external *) p;
		  PUT_WORD (dynobj,
			    (*got_offsetp
			     + sgot->output_section->vma
			     + sgot->output_offset),
			    erel->r_address);
		  if (bfd_header_big_endian (dynobj))
		    {
		      erel->r_index[0] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
		      erel->r_index[2] = (bfd_byte)indx;
		      if (h == NULL)
			erel->r_type[0] =
			  RELOC_32 << RELOC_EXT_BITS_TYPE_SH_BIG;
		      else
			erel->r_type[0] =
			  (RELOC_EXT_BITS_EXTERN_BIG
			   | (RELOC_GLOB_DAT << RELOC_EXT_BITS_TYPE_SH_BIG));
		    }
		  else
		    {
		      erel->r_index[2] = (bfd_byte) (indx >> 16);
		      erel->r_index[1] = (bfd_byte) (indx >> 8);
		      erel->r_index[0] = (bfd_byte)indx;
		      if (h == NULL)
			erel->r_type[0] =
			  RELOC_32 << RELOC_EXT_BITS_TYPE_SH_LITTLE;
		      else
			erel->r_type[0] =
			  (RELOC_EXT_BITS_EXTERN_LITTLE
			   | (RELOC_GLOB_DAT
			      << RELOC_EXT_BITS_TYPE_SH_LITTLE));
		    }
		  PUT_WORD (dynobj, 0, erel->r_addend);
		}

	      ++s->reloc_count;
	    }

	  *got_offsetp |= 1;
	}

      *relocationp = (sgot->vma
		      + (*got_offsetp &~ (bfd_vma) 1)
		      - sunos_hash_table (info)->got_base);

      /* There is nothing else to do for a base relative reloc.  */
      return TRUE;
    }

  if (! sunos_hash_table (info)->dynamic_sections_needed)
    return TRUE;
  if (! info->shared)
    {
      if (h == NULL
	  || h->dynindx == -1
	  || h->root.root.type != bfd_link_hash_undefined
	  || (h->flags & SUNOS_DEF_REGULAR) != 0
	  || (h->flags & SUNOS_DEF_DYNAMIC) == 0
	  || (h->root.root.u.undef.abfd->flags & DYNAMIC) == 0)
	return TRUE;
    }
  else
    {
      if (h != NULL
	  && (h->dynindx == -1
	      || jmptbl
	      || strcmp (h->root.root.root.string,
			 "__GLOBAL_OFFSET_TABLE_") == 0))
	return TRUE;
    }

  /* It looks like this is a reloc we are supposed to copy.  */

  s = bfd_get_linker_section (dynobj, ".dynrel");
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj) < s->size);

  p = s->contents + s->reloc_count * obj_reloc_entry_size (dynobj);

  /* Copy the reloc over.  */
  memcpy (p, reloc, obj_reloc_entry_size (dynobj));

  if (h != NULL)
    indx = h->dynindx;
  else
    indx = 0;

  /* Adjust the address and symbol index.  */
  if (obj_reloc_entry_size (dynobj) == RELOC_STD_SIZE)
    {
      struct reloc_std_external *srel;

      srel = (struct reloc_std_external *) p;
      PUT_WORD (dynobj,
		(GET_WORD (dynobj, srel->r_address)
		 + input_section->output_section->vma
		 + input_section->output_offset),
		srel->r_address);
      if (bfd_header_big_endian (dynobj))
	{
	  srel->r_index[0] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
	  srel->r_index[2] = (bfd_byte)indx;
	}
      else
	{
	  srel->r_index[2] = (bfd_byte) (indx >> 16);
	  srel->r_index[1] = (bfd_byte) (indx >> 8);
	  srel->r_index[0] = (bfd_byte)indx;
	}
      /* FIXME: We may have to change the addend for a PC relative
	 reloc.  */
    }
  else
    {
      struct reloc_ext_external *erel;

      erel = (struct reloc_ext_external *) p;
      PUT_WORD (dynobj,
		(GET_WORD (dynobj, erel->r_address)
		 + input_section->output_section->vma
		 + input_section->output_offset),
		erel->r_address);
      if (bfd_header_big_endian (dynobj))
	{
	  erel->r_index[0] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
	  erel->r_index[2] = (bfd_byte)indx;
	}
      else
	{
	  erel->r_index[2] = (bfd_byte) (indx >> 16);
	  erel->r_index[1] = (bfd_byte) (indx >> 8);
	  erel->r_index[0] = (bfd_byte)indx;
	}
      if (pcrel && h != NULL)
	{
	  /* Adjust the addend for the change in address.  */
	  PUT_WORD (dynobj,
		    (GET_WORD (dynobj, erel->r_addend)
		     - (input_section->output_section->vma
			+ input_section->output_offset
			- input_section->vma)),
		    erel->r_addend);
	}
    }

  ++s->reloc_count;

  if (h != NULL)
    *skip = TRUE;

  return TRUE;
}

/* Finish up the dynamic linking information.  */

static bfd_boolean
sunos_finish_dynamic_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *o;
  asection *s;
  asection *sdyn;

  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
    return TRUE;

  dynobj = sunos_hash_table (info)->dynobj;

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
  BFD_ASSERT (sdyn != NULL);

  /* Finish up the .need section.  The linker emulation code filled it
     in, but with offsets from the start of the section instead of
     real addresses.  Now that we know the section location, we can
     fill in the final values.  */
  s = bfd_get_section_by_name (dynobj, ".need");
  if (s != NULL && s->size != 0)
    {
      file_ptr filepos;
      bfd_byte *p;

      filepos = s->output_section->filepos + s->output_offset;
      p = s->contents;
      while (1)
	{
	  bfd_vma val;

	  PUT_WORD (dynobj, GET_WORD (dynobj, p) + filepos, p);
	  val = GET_WORD (dynobj, p + 12);
	  if (val == 0)
	    break;
	  PUT_WORD (dynobj, val + filepos, p + 12);
	  p += 16;
	}
    }

  /* The first entry in the .got section is the address of the
     dynamic information, unless this is a shared library.  */
  s = bfd_get_linker_section (dynobj, ".got");
  BFD_ASSERT (s != NULL);
  if (info->shared || sdyn->size == 0)
    PUT_WORD (dynobj, 0, s->contents);
  else
    PUT_WORD (dynobj, sdyn->output_section->vma + sdyn->output_offset,
	      s->contents);

  for (o = dynobj->sections; o != NULL; o = o->next)
    {
      if ((o->flags & SEC_HAS_CONTENTS) != 0
	  && o->contents != NULL)
	{
	  BFD_ASSERT (o->output_section != NULL
		      && o->output_section->owner == abfd);
	  if (! bfd_set_section_contents (abfd, o->output_section,
					  o->contents,
					  (file_ptr) o->output_offset,
					  o->size))
	    return FALSE;
	}
    }

  if (sdyn->size > 0)
    {
      struct external_sun4_dynamic esd;
      struct external_sun4_dynamic_link esdl;
      file_ptr pos;

      /* Finish up the dynamic link information.  */
      PUT_WORD (dynobj, (bfd_vma) 3, esd.ld_version);
      PUT_WORD (dynobj,
		sdyn->output_section->vma + sdyn->output_offset + sizeof esd,
		esd.ldd);
      PUT_WORD (dynobj,
		(sdyn->output_section->vma
		 + sdyn->output_offset
		 + sizeof esd
		 + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
		esd.ld);

      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esd,
				      (file_ptr) sdyn->output_offset,
				      (bfd_size_type) sizeof esd))
	return FALSE;

      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_loaded);

      s = bfd_get_section_by_name (dynobj, ".need");
      if (s == NULL || s->size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_need);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_need);

      s = bfd_get_section_by_name (dynobj, ".rules");
      if (s == NULL || s->size == 0)
	PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_rules);
      else
	PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		  esdl.ld_rules);

      s = bfd_get_linker_section (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_got);

      s = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->vma + s->output_offset,
		esdl.ld_plt);
      PUT_WORD (dynobj, s->size, esdl.ld_plt_sz);

      s = bfd_get_linker_section (dynobj, ".dynrel");
      BFD_ASSERT (s != NULL);
      BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj)
		  == s->size);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_rel);

      s = bfd_get_linker_section (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_hash);

      s = bfd_get_linker_section (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_stab);

      PUT_WORD (dynobj, (bfd_vma) 0, esdl.ld_stab_hash);

      PUT_WORD (dynobj, (bfd_vma) sunos_hash_table (info)->bucketcount,
		esdl.ld_buckets);

      s = bfd_get_linker_section (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      PUT_WORD (dynobj, s->output_section->filepos + s->output_offset,
		esdl.ld_symbols);
      PUT_WORD (dynobj, s->size, esdl.ld_symb_size);

      /* The size of the text area is the size of the .text section
	 rounded up to a page boundary.  FIXME: Should the page size be
	 conditional on something?  */
      PUT_WORD (dynobj,
		BFD_ALIGN (obj_textsec (abfd)->size, 0x2000),
		esdl.ld_text);

      pos = sdyn->output_offset;
      pos += sizeof esd + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE;
      if (! bfd_set_section_contents (abfd, sdyn->output_section, &esdl,
				      pos, (bfd_size_type) sizeof esdl))
	return FALSE;

      abfd->flags |= DYNAMIC;
    }

  return TRUE;
}
@


1.28
log
@	* elf32-m32c.c (m32c_elf_check_relocs): Use bfd_make_section
	"anyway" variant when creating .plt.
	(m32c_elf_relax_plt_section): Remove redundant test and unused param.
	(m32c_elf_relax_section): Test SEC_LINKER_CREATED before calling
	m32c_elf_relax_plt_section.
	* elfxx-mips.c (mips_elf_create_got_section): Use make anyway variant
	when creating .got and .got.plt.
	(_bfd_mips_elf_final_link): Likewise for .rtproc, and use
	bfd_get_linker_section.
	* sunos.c: Similarly throughout.
@
text
@d682 1
a682 1
  ret = bfd_malloc (amt);
a692 9
  ret->dynobj = NULL;
  ret->dynamic_sections_created = FALSE;
  ret->dynamic_sections_needed = FALSE;
  ret->got_needed = FALSE;
  ret->dynsymcount = 0;
  ret->bucketcount = 0;
  ret->needed = NULL;
  ret->got_base = 0;

@


1.27
log
@	PR binutils/13558
	* bfd/aout-cris.c: Include sysdep.h before bfd.h.
	* bfd/aout-ns32k.c: Likewise.
	* bfd/aout-sparcle.c: Likewise.
	* bfd/aout0.c: Likewise.
	* bfd/bfd-in2.h: Likewise.
	* bfd/coff-stgo32.c: Likewise.
	* bfd/cpu-lm32.c: Likewise.
	* bfd/cpu-microblaze.c: Likewise.
	* bfd/cpu-score.c: Likewise.
	* bfd/cpu-tilegx.c: Likewise.
	* bfd/cpu-tilepro.c: Likewise.
	* bfd/elf32-lm32.c: Likewise.
	* bfd/elf32-microblaze.c: Likewise.
	* bfd/elf32-score7.c: Likewise.
	* bfd/elf32-tilepro.c: Likewise.
	* bfd/elfxx-tilegx.c: Likewise.
	* bfd/mach-o.h: Likewise.
	* bfd/nlm32-ppc.c: Likewise.
	* bfd/ns32knetbsd.c: Likewise.
	* bfd/pef.h: Likewise.
	* bfd/plugin.c: Likewise.
	* bfd/stab-syms.c: Likewise.
	* bfd/sunos.c: Likewise.
	* bfd/syms.c: Likewise.
	* bfd/xsym.h: Likewise.

	* Makefile.am (CFILES): Add syslex_wrap.c.
	(sysinfo): Depend upon syslex_wrap.o.
	(syslex_wrap.o): New rule.
	(syslex.o): Delete rule.
	* syslex_wrap.c: New file.
	* Makefile.in: Regenerate.
@
text
@d751 1
a751 1
      s = bfd_make_section_with_flags (abfd, ".dynamic", flags);
d758 1
a758 1
      s = bfd_make_section_with_flags (abfd, ".got", flags);
d765 1
a765 1
      s = bfd_make_section_with_flags (abfd, ".plt", flags | SEC_CODE);
d772 2
a773 1
      s = bfd_make_section_with_flags (abfd, ".dynrel", flags | SEC_READONLY);
d780 2
a781 1
      s = bfd_make_section_with_flags (abfd, ".hash", flags | SEC_READONLY);
d788 2
a789 1
      s = bfd_make_section_with_flags (abfd, ".dynsym", flags | SEC_READONLY);
d796 2
a797 1
      s = bfd_make_section_with_flags (abfd, ".dynstr", flags | SEC_READONLY);
d812 1
a812 1
      s = bfd_get_section_by_name (dynobj, ".got");
d1332 2
a1333 2
	  splt = bfd_get_section_by_name (dynobj, ".plt");
	  srel = bfd_get_section_by_name (dynobj, ".dynrel");
d1336 1
a1336 1
	  sgot = bfd_get_section_by_name (dynobj, ".got");
d1482 3
a1484 3
	      splt = bfd_get_section_by_name (dynobj, ".plt");
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      srel = bfd_get_section_by_name (dynobj, ".dynrel");
d1550 3
a1552 3
		  splt = bfd_get_section_by_name (dynobj, ".plt");
		  sgot = bfd_get_section_by_name (dynobj, ".got");
		  srel = bfd_get_section_by_name (dynobj, ".dynrel");
d1597 3
a1599 3
	  splt = bfd_get_section_by_name (dynobj, ".plt");
	  sgot = bfd_get_section_by_name (dynobj, ".got");
	  srel = bfd_get_section_by_name (dynobj, ".dynrel");
d1822 1
a1822 1
      s = bfd_get_section_by_name (dynobj, ".dynstr");
d1841 1
a1841 1
      s = bfd_get_section_by_name (dynobj, ".hash");
d1938 2
d1941 1
a1941 1
      h->root.root.u.def.section = bfd_get_section_by_name (dynobj, ".got");
a1945 2
      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
d1958 1
a1958 1
      *sdynptr = bfd_get_section_by_name (dynobj, ".dynamic");
d1975 1
a1975 1
      s = bfd_get_section_by_name (dynobj, ".dynsym");
d1996 1
a1996 1
      s = bfd_get_section_by_name (dynobj, ".hash");
d2020 1
a2020 1
      s = bfd_get_section_by_name (dynobj, ".dynstr");
d2039 1
a2039 1
  s = bfd_get_section_by_name (dynobj, ".plt");
d2063 1
a2063 1
  s = bfd_get_section_by_name (dynobj, ".dynrel");
d2075 1
a2075 1
  s = bfd_get_section_by_name (dynobj, ".got");
d2121 1
a2121 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
d2124 1
a2124 1
      s = bfd_get_section_by_name (dynobj, ".dynrel");
d2308 1
a2308 1
  s = bfd_get_section_by_name (sunos_hash_table (info)->dynobj, ".dynsym");
d2363 1
a2363 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
d2458 1
a2458 1
      sgot = bfd_get_section_by_name (dynobj, ".got");
d2480 1
a2480 1
	      s = bfd_get_section_by_name (dynobj, ".dynrel");
d2610 1
a2610 1
  s = bfd_get_section_by_name (dynobj, ".dynrel");
d2708 1
a2708 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d2738 1
a2738 1
  s = bfd_get_section_by_name (dynobj, ".got");
d2800 1
a2800 1
      s = bfd_get_section_by_name (dynobj, ".got");
d2805 1
a2805 1
      s = bfd_get_section_by_name (dynobj, ".plt");
d2811 1
a2811 1
      s = bfd_get_section_by_name (dynobj, ".dynrel");
d2818 1
a2818 1
      s = bfd_get_section_by_name (dynobj, ".hash");
d2823 1
a2823 1
      s = bfd_get_section_by_name (dynobj, ".dynsym");
d2833 1
a2833 1
      s = bfd_get_section_by_name (dynobj, ".dynstr");
@


1.26
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011
d31 1
@


1.25
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
a1751 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct sunos_link_hash_entry *) h->root.root.u.i.link;

@


1.24
log
@Switch sources over to use the GPL version 3
@
text
@d3 2
a4 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d833 1
a833 1
  if (info->hash->creator == abfd->xvec)
d874 1
a874 1
  if (info->hash->creator != abfd->xvec)
d1125 1
a1125 1
      && abfd->xvec == info->hash->creator
d1149 1
a1149 1
  if (abfd->xvec == info->hash->creator)
d1195 1
a1195 1
  if (info->hash->creator != &MY (vec))
@


1.23
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.22
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d748 1
a748 1
      s = bfd_make_section (abfd, ".dynamic");
a749 1
	  || ! bfd_set_section_flags (abfd, s, flags)
d755 1
a755 1
      s = bfd_make_section (abfd, ".got");
a756 1
	  || ! bfd_set_section_flags (abfd, s, flags)
d762 1
a762 1
      s = bfd_make_section (abfd, ".plt");
a763 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
d769 1
a769 1
      s = bfd_make_section (abfd, ".dynrel");
a770 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d776 1
a776 1
      s = bfd_make_section (abfd, ".hash");
a777 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d783 1
a783 1
      s = bfd_make_section (abfd, ".dynsym");
a784 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d790 1
a790 1
      s = bfd_make_section (abfd, ".dynstr");
a791 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d886 3
a888 1
      asection *s = bfd_make_section (dynobj, ".need");
a889 6
	  || ! bfd_set_section_flags (dynobj, s,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_READONLY))
d899 3
a901 1
      asection *s = bfd_make_section (dynobj, ".rules");
a902 6
	  || ! bfd_set_section_flags (dynobj, s,
				      (SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS
				       | SEC_IN_MEMORY
				       | SEC_READONLY))
@


1.21
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d682 3
a684 2
  if (! NAME (aout, link_hash_table_init) (&ret->root, abfd,
					   sunos_link_hash_newfunc))
@


1.20
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.19
log
@	* section.c (bfd_section_list_remove): Don't clear s->next.
	(bfd_section_list_append): Always init s->prev.
	(bfd_section_list_prepend): Define.
	(bfd_section_list_insert_after): Minor optimization.
	(bfd_section_removed_from_list): Rewrite.
	* elf.c (assign_section_numbers): Simplify list traversal now that
	bfd_section_list_remove doesn't destroy removed section next ptr.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Use bfd_section_list_prepend.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Simplify list traversal.
	* bfd-in2.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.18
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d862 1
a862 1
      asection *s, *n;
d864 1
a864 1
      for (s = abfd->sections; s != NULL; s = n)
a865 1
	  n = s->next;
@


1.17
log
@Convert to ISO C90 formatting
@
text
@a834 1
  asection **ps;
d858 3
a860 1
  for (ps = &abfd->sections; *ps != NULL; )
d862 8
a869 4
      if (abfd != dynobj || ((*ps)->flags & SEC_LINKER_CREATED) == 0)
	bfd_section_list_remove (abfd, ps);
      else
	ps = &(*ps)->next;
@


1.16
log
@update copyright dates
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a32 54
/* Static routines defined in this file.  */

static bfd_boolean sunos_read_dynamic_info PARAMS ((bfd *));
static long sunos_get_dynamic_symtab_upper_bound PARAMS ((bfd *));
static bfd_boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
static long sunos_canonicalize_dynamic_symtab PARAMS ((bfd *, asymbol **));
static long sunos_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
static long sunos_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
static struct bfd_hash_entry *sunos_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *sunos_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
static bfd_boolean sunos_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *, struct external_nlist **,
	   bfd_size_type *, char **));
static bfd_boolean sunos_add_one_symbol
  PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
	   struct bfd_link_hash_entry **));
static bfd_boolean sunos_scan_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *, bfd_size_type));
static bfd_boolean sunos_scan_std_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   const struct reloc_std_external *, bfd_size_type));
static bfd_boolean sunos_scan_ext_relocs
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   const struct reloc_ext_external *, bfd_size_type));
static bfd_boolean sunos_link_dynamic_object
  PARAMS ((struct bfd_link_info *, bfd *));
static bfd_boolean sunos_write_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct aout_link_hash_entry *));
static bfd_boolean sunos_check_dynamic_reloc
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	   bfd_vma *));
static bfd_boolean sunos_finish_dynamic_link
  PARAMS ((bfd *, struct bfd_link_info *));

#define MY_get_dynamic_symtab_upper_bound sunos_get_dynamic_symtab_upper_bound
#define MY_canonicalize_dynamic_symtab sunos_canonicalize_dynamic_symtab
#define MY_get_synthetic_symtab _bfd_nodynamic_get_synthetic_symtab
#define MY_get_dynamic_reloc_upper_bound sunos_get_dynamic_reloc_upper_bound
#define MY_canonicalize_dynamic_reloc sunos_canonicalize_dynamic_reloc
#define MY_bfd_link_hash_table_create sunos_link_hash_table_create
#define MY_add_dynamic_symbols sunos_add_dynamic_symbols
#define MY_add_one_symbol sunos_add_one_symbol
#define MY_link_dynamic_object sunos_link_dynamic_object
#define MY_write_dynamic_symbol sunos_write_dynamic_symbol
#define MY_check_dynamic_reloc sunos_check_dynamic_reloc
#define MY_finish_dynamic_link sunos_finish_dynamic_link

d43 25
d95 1
a95 1
  PTR dynrel;
d112 1
a112 2
sunos_read_dynamic_info (abfd)
     bfd *abfd;
d122 1
a122 1
  if (obj_aout_dynamic_info (abfd) != (PTR) NULL)
d132 1
a132 1
  info = (struct sunos_dynamic_info *) bfd_zalloc (abfd, amt);
d141 1
a141 1
  obj_aout_dynamic_info (abfd) = (PTR) info;
d152 1
a152 1
  if (! bfd_get_section_contents (abfd, obj_datasec (abfd), (PTR) &dyninfo,
d175 1
a175 1
  if (! bfd_get_section_contents (abfd, dynsec, (PTR) &linkinfo,
d233 1
a233 2
sunos_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
d253 1
a253 2
sunos_slurp_dynamic_symtab (abfd)
     bfd *abfd;
d273 1
a273 1
  if (info->dynsym == (struct external_nlist *) NULL)
d276 1
a276 1
      info->dynsym = (struct external_nlist *) bfd_alloc (abfd, amt);
d280 1
a280 1
	  || bfd_bread ((PTR) info->dynsym, amt, abfd) != amt)
d292 1
a292 1
  if (info->dynstr == (char *) NULL)
d295 1
a295 1
      info->dynstr = (char *) bfd_alloc (abfd, amt);
d299 1
a299 1
	  || bfd_bread ((PTR) info->dynstr, amt, abfd) != amt)
d316 1
a316 3
sunos_canonicalize_dynamic_symtab (abfd, storage)
     bfd *abfd;
     asymbol **storage;
d337 1
a337 1
    table = (bfd_byte *) bfd_malloc (table_size);
d341 1
a341 1
	|| bfd_bread ((PTR) table, table_size, abfd) != table_size)
d369 1
a369 1
  if (info->canonical_dynsym == (aout_symbol_type *) NULL)
d375 1
a375 1
      info->canonical_dynsym = (aout_symbol_type *) bfd_alloc (abfd, size);
d404 1
a404 2
sunos_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d424 1
a424 4
sunos_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d431 1
a431 1
  if (obj_aout_dynamic_info (abfd) == (PTR) NULL)
d448 1
a448 1
      info->dynrel = (PTR) bfd_alloc (abfd, size);
d452 1
a452 1
	  || bfd_bread ((PTR) info->dynrel, size, abfd) != size)
d465 1
a465 1
  if (info->canonical_dynrel == (arelent *) NULL)
d470 1
a470 1
      info->canonical_dynrel = (arelent *) bfd_alloc (abfd, size);
d478 1
a478 1
	  register struct reloc_ext_external *p;
d484 2
a485 2
	    NAME(aout,swap_ext_reloc_in) (abfd, p, to, syms,
					  (bfd_size_type) info->dynsym_count);
d489 1
a489 1
	  register struct reloc_std_external *p;
d495 2
a496 2
	    NAME(aout,swap_std_reloc_in) (abfd, p, to, syms,
					  (bfd_size_type) info->dynsym_count);
d641 3
a643 4
sunos_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d649 4
a652 5
  if (ret == (struct sunos_link_hash_entry *) NULL)
    ret = ((struct sunos_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct sunos_link_hash_entry)));
  if (ret == (struct sunos_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d656 2
a657 2
	 NAME(aout,link_hash_newfunc) ((struct bfd_hash_entry *) ret,
				       table, string));
d674 1
a674 2
sunos_link_hash_table_create (abfd)
     bfd *abfd;
d679 5
a683 5
  ret = (struct sunos_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct sunos_link_hash_table *) NULL)
    return (struct bfd_link_hash_table *) NULL;
  if (! NAME(aout,link_hash_table_init) (&ret->root, abfd,
					 sunos_link_hash_newfunc))
d686 1
a686 1
      return (struct bfd_link_hash_table *) NULL;
d713 1
a713 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
a720 3
static bfd_boolean sunos_scan_dynamic_symbol
  PARAMS ((struct sunos_link_hash_entry *, PTR));

d729 3
a731 4
sunos_create_dynamic_sections (abfd, info, needed)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean needed;
d826 5
a830 6
sunos_add_dynamic_symbols (abfd, info, symsp, sym_countp, stringsp)
     bfd *abfd;
     struct bfd_link_info *info;
     struct external_nlist **symsp;
     bfd_size_type *sym_countp;
     char **stringsp;
a944 1

d952 1
a952 1
      needed = (struct bfd_link_needed_list *) bfd_alloc (abfd, alc);
d959 1
a959 1
      namebuf = (char *) bfd_malloc (alc + 1);
d988 1
a988 1
	      n = (char *) bfd_realloc (namebuf, alc + 1);
d1020 1
a1020 1
	      n = (char *) bfd_realloc (namebuf, alc + 1);
d1061 10
a1070 12
sunos_add_one_symbol (info, abfd, name, flags, section, value, string,
		      copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
d1135 6
a1140 8
    {
      /* The existing symbol is a constructor symbol, and this symbol
	 is from a dynamic object.  A constructor symbol is actually a
	 definition, although the type will be bfd_link_hash_undefined
	 at this point.  We want to ignore the definition from the
	 dynamic object.  */
      section = bfd_und_section_ptr;
    }
d1146 4
a1149 6
    {
      /* The existing symbol is defined by a dynamic object, and this
	 is a constructor symbol.  As above, we want to force the use
	 of the constructor symbol from the regular object.  */
      h->root.root.type = bfd_link_hash_new;
    }
d1195 2
d1200 2
a1201 3
bfd_sunos_get_needed_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1203 1
a1203 1
  if (info->hash->creator != &MY(vec))
d1212 3
a1214 4
bfd_sunos_record_link_assignment (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
d1245 9
a1253 8
/* Set up the sizes and contents of the dynamic sections created in
   sunos_add_dynamic_symbols.  This is called by the SunOS linker
   emulation before_allocation routine.  We must set the sizes of the
   sections before the linker sets the addresses of the various
   sections.  This unfortunately requires reading all the relocs so
   that we can work out which ones need to become dynamic relocs.  If
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
   we discard them, and will read them again later.  */
d1255 6
a1260 8
bfd_boolean
bfd_sunos_size_dynamic_sections (output_bfd, info, sdynptr, sneedptr,
				 srulesptr)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection **sdynptr;
     asection **sneedptr;
     asection **srulesptr;
d1263 4
a1266 7
  bfd_size_type dynsymcount;
  struct sunos_link_hash_entry *h;
  asection *s;
  size_t bucketcount;
  bfd_size_type hashalloc;
  size_t i;
  bfd *sub;
d1268 6
a1273 3
  *sdynptr = NULL;
  *sneedptr = NULL;
  *srulesptr = NULL;
d1275 1
a1275 2
  if (info->relocatable)
    return TRUE;
d1277 1
a1277 2
  if (output_bfd->xvec != &MY(vec))
    return TRUE;
d1279 2
a1280 6
  /* Look through all the input BFD's and read their relocs.  It would
     be better if we didn't have to do this, but there is no other way
     to determine the number of dynamic relocs we need, and, more
     importantly, there is no other way to know which symbols should
     get an entry in the procedure linkage table.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
d1282 5
a1286 2
      if ((sub->flags & DYNAMIC) == 0
	  && sub->xvec == output_bfd->xvec)
d1288 2
a1289 5
	  if (! sunos_scan_relocs (info, sub, obj_textsec (sub),
				   exec_hdr (sub)->a_trsize)
	      || ! sunos_scan_relocs (info, sub, obj_datasec (sub),
				      exec_hdr (sub)->a_drsize))
	    return FALSE;
d1291 1
a1291 18
    }

  dynobj = sunos_hash_table (info)->dynobj;
  dynsymcount = sunos_hash_table (info)->dynsymcount;

  /* If there were no dynamic objects in the link, and we don't need
     to build a global offset table, there is nothing to do here.  */
  if (! sunos_hash_table (info)->dynamic_sections_needed
      && ! sunos_hash_table (info)->got_needed)
    return TRUE;

  /* If __GLOBAL_OFFSET_TABLE_ was mentioned, define it.  */
  h = sunos_link_hash_lookup (sunos_hash_table (info),
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
  if (h != NULL && (h->flags & SUNOS_REF_REGULAR) != 0)
    {
      h->flags |= SUNOS_DEF_REGULAR;
      if (h->dynindx == -1)
d1293 2
a1294 2
	  ++sunos_hash_table (info)->dynsymcount;
	  h->dynindx = -2;
a1295 2
      h->root.root.type = bfd_link_hash_defined;
      h->root.root.u.def.section = bfd_get_section_by_name (dynobj, ".got");
d1297 5
a1301 7
      /* If the .got section is more than 0x1000 bytes, we set
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
      s = bfd_get_section_by_name (dynobj, ".got");
      BFD_ASSERT (s != NULL);
      if (s->size >= 0x1000)
	h->root.root.u.def.value = 0x1000;
d1303 3
a1305 1
	h->root.root.u.def.value = 0;
d1307 6
a1312 2
      sunos_hash_table (info)->got_base = h->root.root.u.def.value;
    }
d1314 9
a1322 5
  /* If there are any shared objects in the link, then we need to set
     up the dynamic linking information.  */
  if (sunos_hash_table (info)->dynamic_sections_needed)
    {
      *sdynptr = bfd_get_section_by_name (dynobj, ".dynamic");
d1324 3
a1326 6
      /* The .dynamic section is always the same size.  */
      s = *sdynptr;
      BFD_ASSERT (s != NULL);
      s->size = (sizeof (struct external_sun4_dynamic)
		      + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE
		      + sizeof (struct external_sun4_dynamic_link));
d1328 3
a1330 14
      /* Set the size of the .dynsym and .hash sections.  We counted
	 the number of dynamic symbols as we read the input files.  We
	 will build the dynamic symbol table (.dynsym) and the hash
	 table (.hash) when we build the final symbol table, because
	 until then we do not know the correct value to give the
	 symbols.  We build the dynamic symbol string table (.dynstr)
	 in a traversal of the symbol table using
	 sunos_scan_dynamic_symbol.  */
      s = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (s != NULL);
      s->size = dynsymcount * sizeof (struct external_nlist);
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
d1332 6
a1337 23
      /* The number of buckets is just the number of symbols divided
	 by four.  To compute the final size of the hash table, we
	 must actually compute the hash table.  Normally we need
	 exactly as many entries in the hash table as there are
	 dynamic symbols, but if some of the buckets are not used we
	 will need additional entries.  In the worst case, every
	 symbol will hash to the same bucket, and we will need
	 BUCKETCOUNT - 1 extra entries.  */
      if (dynsymcount >= 4)
	bucketcount = dynsymcount / 4;
      else if (dynsymcount > 0)
	bucketcount = dynsymcount;
      else
	bucketcount = 1;
      s = bfd_get_section_by_name (dynobj, ".hash");
      BFD_ASSERT (s != NULL);
      hashalloc = (dynsymcount + bucketcount - 1) * HASH_ENTRY_SIZE;
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, hashalloc);
      if (s->contents == NULL && dynsymcount > 0)
	return FALSE;
      for (i = 0; i < bucketcount; i++)
	PUT_WORD (output_bfd, (bfd_vma) -1, s->contents + i * HASH_ENTRY_SIZE);
      s->size = bucketcount * HASH_ENTRY_SIZE;
d1339 6
a1344 1
      sunos_hash_table (info)->bucketcount = bucketcount;
d1346 7
a1352 8
      /* Scan all the symbols, place them in the dynamic symbol table,
	 and build the dynamic hash table.  We reuse dynsymcount as a
	 counter for the number of symbols we have added so far.  */
      sunos_hash_table (info)->dynsymcount = 0;
      sunos_link_hash_traverse (sunos_hash_table (info),
				sunos_scan_dynamic_symbol,
				(PTR) info);
      BFD_ASSERT (sunos_hash_table (info)->dynsymcount == dynsymcount);
d1354 7
a1360 6
      /* The SunOS native linker seems to align the total size of the
	 symbol strings to a multiple of 8.  I don't know if this is
	 important, but it can't hurt much.  */
      s = bfd_get_section_by_name (dynobj, ".dynstr");
      BFD_ASSERT (s != NULL);
      if ((s->size & 7) != 0)
d1362 1
a1362 2
	  bfd_size_type add;
	  bfd_byte *contents;
d1364 7
a1370 8
	  add = 8 - (s->size & 7);
	  contents = (bfd_byte *) bfd_realloc (s->contents,
					       s->size + add);
	  if (contents == NULL)
	    return FALSE;
	  memset (contents + s->size, 0, (size_t) add);
	  s->contents = contents;
	  s->size += add;
d1372 12
a1383 1
    }
d1385 2
a1386 262
  /* Now that we have worked out the sizes of the procedure linkage
     table and the dynamic relocs, allocate storage for them.  */
  s = bfd_get_section_by_name (dynobj, ".plt");
  BFD_ASSERT (s != NULL);
  if (s->size != 0)
    {
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;

      /* Fill in the first entry in the table.  */
      switch (bfd_get_arch (dynobj))
	{
	case bfd_arch_sparc:
	  memcpy (s->contents, sparc_plt_first_entry, SPARC_PLT_ENTRY_SIZE);
	  break;

	case bfd_arch_m68k:
	  memcpy (s->contents, m68k_plt_first_entry, M68K_PLT_ENTRY_SIZE);
	  break;

	default:
	  abort ();
	}
    }

  s = bfd_get_section_by_name (dynobj, ".dynrel");
  if (s->size != 0)
    {
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }
  /* We use the reloc_count field to keep track of how many of the
     relocs we have output so far.  */
  s->reloc_count = 0;

  /* Make space for the global offset table.  */
  s = bfd_get_section_by_name (dynobj, ".got");
  s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
  if (s->contents == NULL)
    return FALSE;

  *sneedptr = bfd_get_section_by_name (dynobj, ".need");
  *srulesptr = bfd_get_section_by_name (dynobj, ".rules");

  return TRUE;
}

/* Scan the relocs for an input section.  */

static bfd_boolean
sunos_scan_relocs (info, abfd, sec, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec;
     bfd_size_type rel_size;
{
  PTR relocs;
  PTR free_relocs = NULL;

  if (rel_size == 0)
    return TRUE;

  if (! info->keep_memory)
    relocs = free_relocs = bfd_malloc (rel_size);
  else
    {
      struct aout_section_data_struct *n;
      bfd_size_type amt = sizeof (struct aout_section_data_struct);

      n = (struct aout_section_data_struct *) bfd_alloc (abfd, amt);
      if (n == NULL)
	relocs = NULL;
      else
	{
	  set_aout_section_data (sec, n);
	  relocs = bfd_malloc (rel_size);
	  aout_section_data (sec)->relocs = relocs;
	}
    }
  if (relocs == NULL)
    return FALSE;

  if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
      || bfd_bread (relocs, rel_size, abfd) != rel_size)
    goto error_return;

  if (obj_reloc_entry_size (abfd) == RELOC_STD_SIZE)
    {
      if (! sunos_scan_std_relocs (info, abfd, sec,
				   (struct reloc_std_external *) relocs,
				   rel_size))
	goto error_return;
    }
  else
    {
      if (! sunos_scan_ext_relocs (info, abfd, sec,
				   (struct reloc_ext_external *) relocs,
				   rel_size))
	goto error_return;
    }

  if (free_relocs != NULL)
    free (free_relocs);

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  return FALSE;
}

/* Scan the relocs for an input section using standard relocs.  We
   need to figure out what to do for each reloc against a dynamic
   symbol.  If the symbol is in the .text section, an entry is made in
   the procedure linkage table.  Note that this will do the wrong
   thing if the symbol is actually data; I don't think the Sun 3
   native linker handles this case correctly either.  If the symbol is
   not in the .text section, we must preserve the reloc as a dynamic
   reloc.  FIXME: We should also handle the PIC relocs here by
   building global offset table entries.  */

static bfd_boolean
sunos_scan_std_relocs (info, abfd, sec, relocs, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec ATTRIBUTE_UNUSED;
     const struct reloc_std_external *relocs;
     bfd_size_type rel_size;
{
  bfd *dynobj;
  asection *splt = NULL;
  asection *srel = NULL;
  struct sunos_link_hash_entry **sym_hashes;
  const struct reloc_std_external *rel, *relend;

  /* We only know how to handle m68k plt entries.  */
  if (bfd_get_arch (abfd) != bfd_arch_m68k)
    {
      bfd_set_error (bfd_error_invalid_target);
      return FALSE;
    }

  dynobj = NULL;

  sym_hashes = (struct sunos_link_hash_entry **) obj_aout_sym_hashes (abfd);

  relend = relocs + rel_size / RELOC_STD_SIZE;
  for (rel = relocs; rel < relend; rel++)
    {
      int r_index;
      struct sunos_link_hash_entry *h;

      /* We only want relocs against external symbols.  */
      if (bfd_header_big_endian (abfd))
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG) == 0)
	    continue;
	}
      else
	{
	  if ((rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE) == 0)
	    continue;
	}

      /* Get the symbol index.  */
      if (bfd_header_big_endian (abfd))
	r_index = ((rel->r_index[0] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[2]);
      else
	r_index = ((rel->r_index[2] << 16)
		   | (rel->r_index[1] << 8)
		   | rel->r_index[0]);

      /* Get the hash table entry.  */
      h = sym_hashes[r_index];
      if (h == NULL)
	{
	  /* This should not normally happen, but it will in any case
	     be caught in the relocation phase.  */
	  continue;
	}

      /* At this point common symbols have already been allocated, so
	 we don't have to worry about them.  We need to consider that
	 we may have already seen this symbol and marked it undefined;
	 if the symbol is really undefined, then SUNOS_DEF_DYNAMIC
	 will be zero.  */
      if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak
	  && h->root.root.type != bfd_link_hash_undefined)
	continue;

      if ((h->flags & SUNOS_DEF_DYNAMIC) == 0
	  || (h->flags & SUNOS_DEF_REGULAR) != 0)
	continue;

      if (dynobj == NULL)
	{
	  asection *sgot;

	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
	  dynobj = sunos_hash_table (info)->dynobj;
	  splt = bfd_get_section_by_name (dynobj, ".plt");
	  srel = bfd_get_section_by_name (dynobj, ".dynrel");
	  BFD_ASSERT (splt != NULL && srel != NULL);

	  sgot = bfd_get_section_by_name (dynobj, ".got");
	  BFD_ASSERT (sgot != NULL);
	  if (sgot->size == 0)
	    sgot->size = BYTES_IN_WORD;
	  sunos_hash_table (info)->got_needed = TRUE;
	}

      BFD_ASSERT ((h->flags & SUNOS_REF_REGULAR) != 0);
      BFD_ASSERT (h->plt_offset != 0
		  || ((h->root.root.type == bfd_link_hash_defined
		       || h->root.root.type == bfd_link_hash_defweak)
		      ? (h->root.root.u.def.section->owner->flags
			 & DYNAMIC) != 0
		      : (h->root.root.u.undef.abfd->flags & DYNAMIC) != 0));

      /* This reloc is against a symbol defined only by a dynamic
	 object.  */

      if (h->root.root.type == bfd_link_hash_undefined)
	{
	  /* Presumably this symbol was marked as being undefined by
	     an earlier reloc.  */
	  srel->size += RELOC_STD_SIZE;
	}
      else if ((h->root.root.u.def.section->flags & SEC_CODE) == 0)
	{
	  bfd *sub;

	  /* This reloc is not in the .text section.  It must be
	     copied into the dynamic relocs.  We mark the symbol as
	     being undefined.  */
	  srel->size += RELOC_STD_SIZE;
	  sub = h->root.root.u.def.section->owner;
	  h->root.root.type = bfd_link_hash_undefined;
	  h->root.root.u.undef.abfd = sub;
	}
      else
	{
	  /* This symbol is in the .text section.  We must give it an
	     entry in the procedure linkage table, if we have not
	     already done so.  We change the definition of the symbol
	     to the .plt section; this will cause relocs against it to
	     be handled correctly.  */
	  if (h->plt_offset == 0)
	    {
	      if (splt->size == 0)
		splt->size = M68K_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->size;

	      if ((h->flags & SUNOS_DEF_REGULAR) == 0)
		{
d1410 5
a1414 6
sunos_scan_ext_relocs (info, abfd, sec, relocs, rel_size)
     struct bfd_link_info *info;
     bfd *abfd;
     asection *sec ATTRIBUTE_UNUSED;
     const struct reloc_ext_external *relocs;
     bfd_size_type rel_size;
d1506 3
a1508 5
		{
		  /* This is abnormal, but should be caught in the
		     relocation phase.  */
		  continue;
		}
d1514 1
a1514 2
		  adata (abfd).local_got_offsets =
		    (bfd_vma *) bfd_zalloc (abfd, amt);
d1628 4
a1631 5
	{
	  /* Presumably this symbol was marked as being undefined by
	     an earlier reloc.  */
	  srel->size += RELOC_EXT_SIZE;
	}
d1688 1
a1688 2
/* Build the hash table of dynamic symbols, and to mark as written all
   symbols from dynamic objects which we do not plan to write out.  */
d1691 4
a1694 3
sunos_scan_dynamic_symbol (h, data)
     struct sunos_link_hash_entry *h;
     PTR data;
d1696 2
a1697 1
  struct bfd_link_info *info = (struct bfd_link_info *) data;
d1699 63
a1761 2
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct sunos_link_hash_entry *) h->root.root.u.i.link;
a1779 1

d1830 1
a1830 2
      contents = (bfd_byte *) bfd_realloc (s->contents,
					   s->size + len + 1);
d1871 221
d2097 2
a2098 3
sunos_link_dynamic_object (info, abfd)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *abfd ATTRIBUTE_UNUSED;
d2107 3
a2109 4
sunos_write_dynamic_symbol (output_bfd, info, harg)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct aout_link_hash_entry *harg;
d2339 8
a2346 10
sunos_check_dynamic_reloc (info, input_bfd, input_section, harg, reloc,
			   contents, skip, relocationp)
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     struct aout_link_hash_entry *harg;
     PTR reloc;
     bfd_byte *contents ATTRIBUTE_UNUSED;
     bfd_boolean *skip;
     bfd_vma *relocationp;
d2701 1
a2701 3
sunos_finish_dynamic_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
@


1.15
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
@


1.14
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d200 1
a200 1
  if (dynoff > bfd_section_size (abfd, dynsec))
d857 2
a858 2
      if (s->_raw_size == 0)
	s->_raw_size = BYTES_IN_WORD;
d1381 1
a1381 1
      if (s->_raw_size >= 0x1000)
d1398 1
a1398 1
      s->_raw_size = (sizeof (struct external_sun4_dynamic)
d1412 3
a1414 3
      s->_raw_size = dynsymcount * sizeof (struct external_nlist);
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1439 1
a1439 1
      s->_raw_size = bucketcount * HASH_ENTRY_SIZE;
d1457 1
a1457 1
      if ((s->_raw_size & 7) != 0)
d1462 1
a1462 1
	  add = 8 - (s->_raw_size & 7);
d1464 1
a1464 1
					       s->_raw_size + add);
d1467 1
a1467 1
	  memset (contents + s->_raw_size, 0, (size_t) add);
d1469 1
a1469 1
	  s->_raw_size += add;
d1477 1
a1477 1
  if (s->_raw_size != 0)
d1479 1
a1479 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
d1500 1
a1500 1
  if (s->_raw_size != 0)
d1502 1
a1502 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
d1512 1
a1512 1
  s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
d1686 2
a1687 2
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
d1706 1
a1706 1
	  srel->_raw_size += RELOC_STD_SIZE;
d1715 1
a1715 1
	  srel->_raw_size += RELOC_STD_SIZE;
d1729 3
a1731 3
	      if (splt->_raw_size == 0)
		splt->_raw_size = M68K_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->_raw_size;
d1736 1
a1736 1
		  h->root.root.u.def.value = splt->_raw_size;
d1739 1
a1739 1
	      splt->_raw_size += M68K_PLT_ENTRY_SIZE;
d1743 1
a1743 1
		srel->_raw_size += RELOC_STD_SIZE;
d1840 2
a1841 2
	      if (sgot->_raw_size == 0)
		sgot->_raw_size = BYTES_IN_WORD;
d1850 1
a1850 1
	      h->got_offset = sgot->_raw_size;
d1874 1
a1874 1
	      adata (abfd).local_got_offsets[r_index] = sgot->_raw_size;
d1877 1
a1877 1
	  sgot->_raw_size += BYTES_IN_WORD;
d1886 1
a1886 1
	    srel->_raw_size += RELOC_EXT_SIZE;
d1911 1
a1911 1
	      srel->_raw_size += RELOC_EXT_SIZE;
d1958 2
a1959 2
	  if (sgot->_raw_size == 0)
	    sgot->_raw_size = BYTES_IN_WORD;
d1983 1
a1983 1
	  srel->_raw_size += RELOC_EXT_SIZE;
d1993 1
a1993 1
	  srel->_raw_size += RELOC_EXT_SIZE;
d2010 3
a2012 3
	      if (splt->_raw_size == 0)
		splt->_raw_size = SPARC_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->_raw_size;
d2019 1
a2019 1
		  h->root.root.u.def.value = splt->_raw_size;
d2022 1
a2022 1
	      splt->_raw_size += SPARC_PLT_ENTRY_SIZE;
d2028 1
a2028 1
		srel->_raw_size += RELOC_EXT_SIZE;
d2034 1
a2034 1
	    srel->_raw_size += RELOC_EXT_SIZE;
d2123 1
a2123 1
					   s->_raw_size + len + 1);
d2128 3
a2130 3
      h->dynstr_index = s->_raw_size;
      strcpy ((char *) contents + s->_raw_size, h->root.root.root.string);
      s->_raw_size += len + 1;
d2153 1
a2153 1
	  PUT_WORD (dynobj, s->_raw_size / HASH_ENTRY_SIZE,
d2155 3
a2157 3
	  PUT_WORD (dynobj, h->dynindx, s->contents + s->_raw_size);
	  PUT_WORD (dynobj, next, s->contents + s->_raw_size + BYTES_IN_WORD);
	  s->_raw_size += HASH_ENTRY_SIZE;
d2258 1
a2258 1
		      < s->_raw_size);
d2565 1
a2565 1
			  < s->_raw_size);
d2694 1
a2694 1
  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj) < s->_raw_size);
d2800 1
a2800 1
  if (s != NULL && s->_raw_size != 0)
d2824 1
a2824 1
  if (info->shared || sdyn->_raw_size == 0)
d2840 1
a2840 1
					  o->_raw_size))
d2845 1
a2845 1
  if (sdyn->_raw_size > 0)
d2871 1
a2871 1
      if (s == NULL || s->_raw_size == 0)
d2878 1
a2878 1
      if (s == NULL || s->_raw_size == 0)
d2893 1
a2893 1
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_plt_sz);
d2898 1
a2898 1
		  == s->_raw_size);
d2921 1
a2921 1
      PUT_WORD (dynobj, s->_raw_size, esdl.ld_symb_size);
d2927 1
a2927 1
		BFD_ALIGN (obj_textsec (abfd)->_raw_size, 0x2000),
@


1.13
log
@	* coff-rs6000.c: Remove ARGSUSED and VARARGS.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* elf32-vax.c: Likewise.
	* hash.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* ihex.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* pdp11.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* section.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
@
text
@d76 1
@


1.13.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2002, 2003, 2004 Free Software Foundation, Inc.
a75 1
#define MY_get_synthetic_symtab _bfd_nodynamic_get_synthetic_symtab
d199 1
a199 1
  if (dynoff > dynsec->size)
d856 2
a857 2
      if (s->size == 0)
	s->size = BYTES_IN_WORD;
d1380 1
a1380 1
      if (s->size >= 0x1000)
d1397 1
a1397 1
      s->size = (sizeof (struct external_sun4_dynamic)
d1411 3
a1413 3
      s->size = dynsymcount * sizeof (struct external_nlist);
      s->contents = (bfd_byte *) bfd_alloc (output_bfd, s->size);
      if (s->contents == NULL && s->size != 0)
d1438 1
a1438 1
      s->size = bucketcount * HASH_ENTRY_SIZE;
d1456 1
a1456 1
      if ((s->size & 7) != 0)
d1461 1
a1461 1
	  add = 8 - (s->size & 7);
d1463 1
a1463 1
					       s->size + add);
d1466 1
a1466 1
	  memset (contents + s->size, 0, (size_t) add);
d1468 1
a1468 1
	  s->size += add;
d1476 1
a1476 1
  if (s->size != 0)
d1478 1
a1478 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
d1499 1
a1499 1
  if (s->size != 0)
d1501 1
a1501 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
d1511 1
a1511 1
  s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
d1685 2
a1686 2
	  if (sgot->size == 0)
	    sgot->size = BYTES_IN_WORD;
d1705 1
a1705 1
	  srel->size += RELOC_STD_SIZE;
d1714 1
a1714 1
	  srel->size += RELOC_STD_SIZE;
d1728 3
a1730 3
	      if (splt->size == 0)
		splt->size = M68K_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->size;
d1735 1
a1735 1
		  h->root.root.u.def.value = splt->size;
d1738 1
a1738 1
	      splt->size += M68K_PLT_ENTRY_SIZE;
d1742 1
a1742 1
		srel->size += RELOC_STD_SIZE;
d1839 2
a1840 2
	      if (sgot->size == 0)
		sgot->size = BYTES_IN_WORD;
d1849 1
a1849 1
	      h->got_offset = sgot->size;
d1873 1
a1873 1
	      adata (abfd).local_got_offsets[r_index] = sgot->size;
d1876 1
a1876 1
	  sgot->size += BYTES_IN_WORD;
d1885 1
a1885 1
	    srel->size += RELOC_EXT_SIZE;
d1910 1
a1910 1
	      srel->size += RELOC_EXT_SIZE;
d1957 2
a1958 2
	  if (sgot->size == 0)
	    sgot->size = BYTES_IN_WORD;
d1982 1
a1982 1
	  srel->size += RELOC_EXT_SIZE;
d1992 1
a1992 1
	  srel->size += RELOC_EXT_SIZE;
d2009 3
a2011 3
	      if (splt->size == 0)
		splt->size = SPARC_PLT_ENTRY_SIZE;
	      h->plt_offset = splt->size;
d2018 1
a2018 1
		  h->root.root.u.def.value = splt->size;
d2021 1
a2021 1
	      splt->size += SPARC_PLT_ENTRY_SIZE;
d2027 1
a2027 1
		srel->size += RELOC_EXT_SIZE;
d2033 1
a2033 1
	    srel->size += RELOC_EXT_SIZE;
d2122 1
a2122 1
					   s->size + len + 1);
d2127 3
a2129 3
      h->dynstr_index = s->size;
      strcpy ((char *) contents + s->size, h->root.root.root.string);
      s->size += len + 1;
d2152 1
a2152 1
	  PUT_WORD (dynobj, s->size / HASH_ENTRY_SIZE,
d2154 3
a2156 3
	  PUT_WORD (dynobj, h->dynindx, s->contents + s->size);
	  PUT_WORD (dynobj, next, s->contents + s->size + BYTES_IN_WORD);
	  s->size += HASH_ENTRY_SIZE;
d2257 1
a2257 1
		      < s->size);
d2564 1
a2564 1
			  < s->size);
d2693 1
a2693 1
  BFD_ASSERT (s->reloc_count * obj_reloc_entry_size (dynobj) < s->size);
d2799 1
a2799 1
  if (s != NULL && s->size != 0)
d2823 1
a2823 1
  if (info->shared || sdyn->size == 0)
d2839 1
a2839 1
					  o->size))
d2844 1
a2844 1
  if (sdyn->size > 0)
d2870 1
a2870 1
      if (s == NULL || s->size == 0)
d2877 1
a2877 1
      if (s == NULL || s->size == 0)
d2892 1
a2892 1
      PUT_WORD (dynobj, s->size, esdl.ld_plt_sz);
d2897 1
a2897 1
		  == s->size);
d2920 1
a2920 1
      PUT_WORD (dynobj, s->size, esdl.ld_symb_size);
d2926 1
a2926 1
		BFD_ALIGN (obj_textsec (abfd)->size, 0x2000),
@


1.12
log
@Correct spelling of "relocatable".
@
text
@a1248 1
/*ARGSUSED*/
a2166 1
/*ARGSUSED*/
a2410 1
/*ARGSUSED*/
@


1.11
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2002 Free Software Foundation, Inc.
d887 1
a887 1
					    && !info->relocateable)))
d914 1
a914 1
  if (info->relocateable)
d1329 1
a1329 1
  if (info->relocateable)
@


1.10
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d3 1
a3 2
   2002
   Free Software Foundation, Inc.
d35 1
a35 1
static boolean sunos_read_dynamic_info PARAMS ((bfd *));
d37 1
a37 1
static boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
d46 3
a48 3
static boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, boolean));
static boolean sunos_add_dynamic_symbols
d51 1
a51 1
static boolean sunos_add_one_symbol
d53 1
a53 1
	   bfd_vma, const char *, boolean, boolean,
d55 1
a55 1
static boolean sunos_scan_relocs
d57 1
a57 1
static boolean sunos_scan_std_relocs
d60 1
a60 1
static boolean sunos_scan_ext_relocs
d63 1
a63 1
static boolean sunos_link_dynamic_object
d65 1
a65 1
static boolean sunos_write_dynamic_symbol
d67 1
a67 1
static boolean sunos_check_dynamic_reloc
d69 1
a69 1
	   struct aout_link_hash_entry *, PTR, bfd_byte *, boolean *,
d71 1
a71 1
static boolean sunos_finish_dynamic_link
d108 1
a108 1
  boolean valid;
d137 1
a137 1
   structure to false to avoid doing this work again.  */
d139 1
a139 1
static boolean
d152 1
a152 1
    return true;
d157 1
a157 1
      return false;
d163 2
a164 2
    return false;
  info->valid = false;
d180 1
a180 1
    return true;
d184 1
a184 1
    return true;
d188 1
a188 1
    return true;
d200 1
a200 1
    return true;
d207 1
a207 1
    return true;
d254 1
a254 1
  info->valid = true;
d256 1
a256 1
  return true;
d282 1
a282 1
static boolean
d293 1
a293 1
	  return false;
d300 1
a300 1
      return false;
d309 1
a309 1
	return false;
d318 1
a318 1
	  return false;
d328 1
a328 1
	return false;
d337 1
a337 1
	  return false;
d341 1
a341 1
  return true;
d415 1
a415 1
					    info->dynstr, strsize, true))
d653 1
a653 1
  boolean dynamic_sections_created;
d656 1
a656 1
  boolean dynamic_sections_needed;
d659 1
a659 1
  boolean got_needed;
d730 3
a732 3
  ret->dynamic_sections_created = false;
  ret->dynamic_sections_needed = false;
  ret->got_needed = false;
d753 1
a753 1
    (boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\
d761 1
a761 1
static boolean sunos_scan_dynamic_symbol
d771 1
a771 1
static boolean
d775 1
a775 1
     boolean needed;
d795 1
a795 1
	return false;
d803 1
a803 1
	return false;
d811 1
a811 1
	return false;
d819 1
a819 1
	return false;
d827 1
a827 1
	return false;
d835 1
a835 1
	return false;
d843 1
a843 1
	return false;
d845 1
a845 1
      sunos_hash_table (info)->dynamic_sections_created = true;
d859 2
a860 2
      sunos_hash_table (info)->dynamic_sections_needed = true;
      sunos_hash_table (info)->got_needed = true;
d863 1
a863 1
  return true;
d869 1
a869 1
static boolean
d886 3
a888 5
					   (((abfd->flags & DYNAMIC) != 0
					     && ! info->relocateable)
					    ? true
					    : false)))
	return false;
d893 1
a893 1
    return true;
d915 1
a915 1
    return true;
d922 1
a922 1
      return false;
d942 1
a942 1
	return false;
d959 1
a959 1
	return false;
d964 1
a964 1
    return false;
d986 1
a986 1
	return false;
d989 1
a989 1
         should probably define structs for this manipulation.  */
d1000 1
a1000 1
	return false;
d1007 1
a1007 1
	return false;
d1018 1
a1018 1
	  return false;
d1026 1
a1026 1
	      return false;
d1038 1
a1038 1
		  return false;
d1070 1
a1070 1
		  return false;
d1084 1
a1084 1
	  return false;
d1099 1
a1099 1
  return true;
d1106 1
a1106 1
static boolean
d1116 2
a1117 2
     boolean copy;
     boolean collect;
d1125 2
a1126 2
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, true, copy,
				false);
d1129 1
a1129 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, true, copy, false));
d1131 1
a1131 1
    return false;
d1185 4
a1188 4
         is from a dynamic object.  A constructor symbol is actually a
         definition, although the type will be bfd_link_hash_undefined
         at this point.  We want to ignore the definition from the
         dynamic object.  */
d1198 2
a1199 2
         is a constructor symbol.  As above, we want to force the use
         of the constructor symbol from the regular object.  */
d1207 1
a1207 1
    return false;
d1244 1
a1244 1
  return true;
d1263 1
a1263 1
boolean
d1272 1
a1272 1
    return true;
d1278 1
a1278 1
			      false, false, false);
d1280 1
a1280 1
    return true;
d1295 1
a1295 1
  return true;
d1304 1
a1304 1
   info->keep_memory is true, we keep the relocs in memory; otherwise,
d1307 1
a1307 1
boolean
d1330 1
a1330 1
    return true;
d1333 1
a1333 1
    return true;
d1349 1
a1349 1
	    return false;
d1360 1
a1360 1
    return true;
d1364 1
a1364 1
			      "__GLOBAL_OFFSET_TABLE_", false, false, false);
d1377 2
a1378 2
         __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
         so that 13 bit relocations have a greater chance of working.  */
d1415 1
a1415 1
	return false;
d1436 1
a1436 1
	return false;
d1466 1
a1466 1
	    return false;
d1481 1
a1481 1
	return false;
d1504 1
a1504 1
	return false;
d1514 1
a1514 1
    return false;
d1519 1
a1519 1
  return true;
d1524 1
a1524 1
static boolean
d1535 1
a1535 1
    return true;
d1555 1
a1555 1
    return false;
d1579 1
a1579 1
  return true;
d1584 1
a1584 1
  return false;
d1597 1
a1597 1
static boolean
d1615 1
a1615 1
      return false;
d1677 2
a1678 2
	  if (! sunos_create_dynamic_sections (abfd, info, false))
	    return false;
d1688 1
a1688 1
	  sunos_hash_table (info)->got_needed = true;
d1748 1
a1748 1
  return true;
d1757 1
a1757 1
static boolean
d1777 1
a1777 1
      return false;
d1824 1
a1824 1
         the .got section.  */
d1831 2
a1832 2
	      if (! sunos_create_dynamic_sections (abfd, info, false))
		return false;
d1842 1
a1842 1
	      sunos_hash_table (info)->got_needed = true;
d1868 1
a1868 1
		    return false;
d1892 2
a1893 2
         defined in dynamic objects but not in regular objects.  We
         only need to consider relocs against external symbols.  */
d1897 1
a1897 1
             generate an absolute reloc.  */
d1902 2
a1903 2
		  if (! sunos_create_dynamic_sections (abfd, info, true))
		    return false;
d1939 2
a1940 2
             here; just let the relocation routine report an undefined
             symbol.  */
d1949 2
a1950 2
	  if (! sunos_create_dynamic_sections (abfd, info, false))
	    return false;
d1960 1
a1960 1
	  sunos_hash_table (info)->got_needed = true;
d2025 2
a2026 2
                 is a JMP_TBL reloc produced by linking PIC compiled
                 code, and we are not making a shared library.  */
d2032 1
a2032 1
             any reloc other than a jump table reloc.  */
d2038 1
a2038 1
  return true;
d2044 1
a2044 1
static boolean
d2066 1
a2066 1
    h->root.written = true;
d2125 1
a2125 1
	return false;
d2161 1
a2161 1
  return true;
d2169 1
a2169 1
static boolean
d2174 1
a2174 1
  return true;
d2180 1
a2180 1
static boolean
d2254 1
a2254 1
         result of a JMP_TBL reloc from PIC compiled code.  */
d2320 1
a2320 1
    return true;
d2328 1
a2328 1
      return true;
d2386 1
a2386 1
      return true;
d2405 1
a2405 1
  return true;
d2414 1
a2414 1
static boolean
d2423 1
a2423 1
     boolean *skip;
d2428 3
a2430 3
  boolean baserel;
  boolean jmptbl;
  boolean pcrel;
d2435 1
a2435 1
  *skip = false;
d2493 1
a2493 1
         because they are pcrel_offset.  */
d2562 1
a2562 1
                 dynamic linker to fill in this entry in the table.  */
d2667 1
a2667 1
      return true;
d2671 1
a2671 1
    return true;
d2680 1
a2680 1
	return true;
d2689 1
a2689 1
	return true;
d2732 1
a2732 1
         reloc.  */
d2771 1
a2771 1
    *skip = true;
d2773 1
a2773 1
  return true;
d2778 1
a2778 1
static boolean
d2790 1
a2790 1
    return true;
d2843 1
a2843 1
	    return false;
d2868 1
a2868 1
	return false;
d2936 1
a2936 1
	return false;
d2941 1
a2941 1
  return true;
@


1.10.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 2
a4 1
   2002, 2003 Free Software Foundation, Inc.
d36 1
a36 1
static bfd_boolean sunos_read_dynamic_info PARAMS ((bfd *));
d38 1
a38 1
static bfd_boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
d47 3
a49 3
static bfd_boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
static bfd_boolean sunos_add_dynamic_symbols
d52 1
a52 1
static bfd_boolean sunos_add_one_symbol
d54 1
a54 1
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
d56 1
a56 1
static bfd_boolean sunos_scan_relocs
d58 1
a58 1
static bfd_boolean sunos_scan_std_relocs
d61 1
a61 1
static bfd_boolean sunos_scan_ext_relocs
d64 1
a64 1
static bfd_boolean sunos_link_dynamic_object
d66 1
a66 1
static bfd_boolean sunos_write_dynamic_symbol
d68 1
a68 1
static bfd_boolean sunos_check_dynamic_reloc
d70 1
a70 1
	   struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
d72 1
a72 1
static bfd_boolean sunos_finish_dynamic_link
d109 1
a109 1
  bfd_boolean valid;
d138 1
a138 1
   structure to FALSE to avoid doing this work again.  */
d140 1
a140 1
static bfd_boolean
d153 1
a153 1
    return TRUE;
d158 1
a158 1
      return FALSE;
d164 2
a165 2
    return FALSE;
  info->valid = FALSE;
d181 1
a181 1
    return TRUE;
d185 1
a185 1
    return TRUE;
d189 1
a189 1
    return TRUE;
d201 1
a201 1
    return TRUE;
d208 1
a208 1
    return TRUE;
d255 1
a255 1
  info->valid = TRUE;
d257 1
a257 1
  return TRUE;
d283 1
a283 1
static bfd_boolean
d294 1
a294 1
	  return FALSE;
d301 1
a301 1
      return FALSE;
d310 1
a310 1
	return FALSE;
d319 1
a319 1
	  return FALSE;
d329 1
a329 1
	return FALSE;
d338 1
a338 1
	  return FALSE;
d342 1
a342 1
  return TRUE;
d416 1
a416 1
					    info->dynstr, strsize, TRUE))
d654 1
a654 1
  bfd_boolean dynamic_sections_created;
d657 1
a657 1
  bfd_boolean dynamic_sections_needed;
d660 1
a660 1
  bfd_boolean got_needed;
d731 3
a733 3
  ret->dynamic_sections_created = FALSE;
  ret->dynamic_sections_needed = FALSE;
  ret->got_needed = FALSE;
d754 1
a754 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d762 1
a762 1
static bfd_boolean sunos_scan_dynamic_symbol
d772 1
a772 1
static bfd_boolean
d776 1
a776 1
     bfd_boolean needed;
d796 1
a796 1
	return FALSE;
d804 1
a804 1
	return FALSE;
d812 1
a812 1
	return FALSE;
d820 1
a820 1
	return FALSE;
d828 1
a828 1
	return FALSE;
d836 1
a836 1
	return FALSE;
d844 1
a844 1
	return FALSE;
d846 1
a846 1
      sunos_hash_table (info)->dynamic_sections_created = TRUE;
d860 2
a861 2
      sunos_hash_table (info)->dynamic_sections_needed = TRUE;
      sunos_hash_table (info)->got_needed = TRUE;
d864 1
a864 1
  return TRUE;
d870 1
a870 1
static bfd_boolean
d887 5
a891 3
					   ((abfd->flags & DYNAMIC) != 0
					    && !info->relocatable)))
	return FALSE;
d896 1
a896 1
    return TRUE;
d917 2
a918 2
  if (info->relocatable)
    return TRUE;
d925 1
a925 1
      return FALSE;
d945 1
a945 1
	return FALSE;
d962 1
a962 1
	return FALSE;
d967 1
a967 1
    return FALSE;
d989 1
a989 1
	return FALSE;
d992 1
a992 1
	 should probably define structs for this manipulation.  */
d1003 1
a1003 1
	return FALSE;
d1010 1
a1010 1
	return FALSE;
d1021 1
a1021 1
	  return FALSE;
d1029 1
a1029 1
	      return FALSE;
d1041 1
a1041 1
		  return FALSE;
d1073 1
a1073 1
		  return FALSE;
d1087 1
a1087 1
	  return FALSE;
d1102 1
a1102 1
  return TRUE;
d1109 1
a1109 1
static bfd_boolean
d1119 2
a1120 2
     bfd_boolean copy;
     bfd_boolean collect;
d1128 2
a1129 2
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, TRUE, copy,
				FALSE);
d1132 1
a1132 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
d1134 1
a1134 1
    return FALSE;
d1188 4
a1191 4
	 is from a dynamic object.  A constructor symbol is actually a
	 definition, although the type will be bfd_link_hash_undefined
	 at this point.  We want to ignore the definition from the
	 dynamic object.  */
d1201 2
a1202 2
	 is a constructor symbol.  As above, we want to force the use
	 of the constructor symbol from the regular object.  */
d1210 1
a1210 1
    return FALSE;
d1247 1
a1247 1
  return TRUE;
d1252 1
d1266 1
a1266 1
bfd_boolean
d1275 1
a1275 1
    return TRUE;
d1281 1
a1281 1
			      FALSE, FALSE, FALSE);
d1283 1
a1283 1
    return TRUE;
d1298 1
a1298 1
  return TRUE;
d1307 1
a1307 1
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
d1310 1
a1310 1
bfd_boolean
d1332 2
a1333 2
  if (info->relocatable)
    return TRUE;
d1336 1
a1336 1
    return TRUE;
d1352 1
a1352 1
	    return FALSE;
d1363 1
a1363 1
    return TRUE;
d1367 1
a1367 1
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
d1380 2
a1381 2
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
d1418 1
a1418 1
	return FALSE;
d1439 1
a1439 1
	return FALSE;
d1469 1
a1469 1
	    return FALSE;
d1484 1
a1484 1
	return FALSE;
d1507 1
a1507 1
	return FALSE;
d1517 1
a1517 1
    return FALSE;
d1522 1
a1522 1
  return TRUE;
d1527 1
a1527 1
static bfd_boolean
d1538 1
a1538 1
    return TRUE;
d1558 1
a1558 1
    return FALSE;
d1582 1
a1582 1
  return TRUE;
d1587 1
a1587 1
  return FALSE;
d1600 1
a1600 1
static bfd_boolean
d1618 1
a1618 1
      return FALSE;
d1680 2
a1681 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1691 1
a1691 1
	  sunos_hash_table (info)->got_needed = TRUE;
d1751 1
a1751 1
  return TRUE;
d1760 1
a1760 1
static bfd_boolean
d1780 1
a1780 1
      return FALSE;
d1827 1
a1827 1
	 the .got section.  */
d1834 2
a1835 2
	      if (! sunos_create_dynamic_sections (abfd, info, FALSE))
		return FALSE;
d1845 1
a1845 1
	      sunos_hash_table (info)->got_needed = TRUE;
d1871 1
a1871 1
		    return FALSE;
d1895 2
a1896 2
	 defined in dynamic objects but not in regular objects.  We
	 only need to consider relocs against external symbols.  */
d1900 1
a1900 1
	     generate an absolute reloc.  */
d1905 2
a1906 2
		  if (! sunos_create_dynamic_sections (abfd, info, TRUE))
		    return FALSE;
d1942 2
a1943 2
	     here; just let the relocation routine report an undefined
	     symbol.  */
d1952 2
a1953 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1963 1
a1963 1
	  sunos_hash_table (info)->got_needed = TRUE;
d2028 2
a2029 2
		 is a JMP_TBL reloc produced by linking PIC compiled
		 code, and we are not making a shared library.  */
d2035 1
a2035 1
	     any reloc other than a jump table reloc.  */
d2041 1
a2041 1
  return TRUE;
d2047 1
a2047 1
static bfd_boolean
d2069 1
a2069 1
    h->root.written = TRUE;
d2128 1
a2128 1
	return FALSE;
d2164 1
a2164 1
  return TRUE;
d2171 2
a2172 1
static bfd_boolean
d2177 1
a2177 1
  return TRUE;
d2183 1
a2183 1
static bfd_boolean
d2257 1
a2257 1
	 result of a JMP_TBL reloc from PIC compiled code.  */
d2323 1
a2323 1
    return TRUE;
d2331 1
a2331 1
      return TRUE;
d2389 1
a2389 1
      return TRUE;
d2408 1
a2408 1
  return TRUE;
d2416 2
a2417 1
static bfd_boolean
d2426 1
a2426 1
     bfd_boolean *skip;
d2431 3
a2433 3
  bfd_boolean baserel;
  bfd_boolean jmptbl;
  bfd_boolean pcrel;
d2438 1
a2438 1
  *skip = FALSE;
d2496 1
a2496 1
	 because they are pcrel_offset.  */
d2565 1
a2565 1
		 dynamic linker to fill in this entry in the table.  */
d2670 1
a2670 1
      return TRUE;
d2674 1
a2674 1
    return TRUE;
d2683 1
a2683 1
	return TRUE;
d2692 1
a2692 1
	return TRUE;
d2735 1
a2735 1
	 reloc.  */
d2774 1
a2774 1
    *skip = TRUE;
d2776 1
a2776 1
  return TRUE;
d2781 1
a2781 1
static bfd_boolean
d2793 1
a2793 1
    return TRUE;
d2846 1
a2846 1
	    return FALSE;
d2871 1
a2871 1
	return FALSE;
d2939 1
a2939 1
	return FALSE;
d2944 1
a2944 1
  return TRUE;
@


1.10.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d3 2
a4 1
   2002 Free Software Foundation, Inc.
d36 1
a36 1
static bfd_boolean sunos_read_dynamic_info PARAMS ((bfd *));
d38 1
a38 1
static bfd_boolean sunos_slurp_dynamic_symtab PARAMS ((bfd *));
d47 3
a49 3
static bfd_boolean sunos_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean));
static bfd_boolean sunos_add_dynamic_symbols
d52 1
a52 1
static bfd_boolean sunos_add_one_symbol
d54 1
a54 1
	   bfd_vma, const char *, bfd_boolean, bfd_boolean,
d56 1
a56 1
static bfd_boolean sunos_scan_relocs
d58 1
a58 1
static bfd_boolean sunos_scan_std_relocs
d61 1
a61 1
static bfd_boolean sunos_scan_ext_relocs
d64 1
a64 1
static bfd_boolean sunos_link_dynamic_object
d66 1
a66 1
static bfd_boolean sunos_write_dynamic_symbol
d68 1
a68 1
static bfd_boolean sunos_check_dynamic_reloc
d70 1
a70 1
	   struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
d72 1
a72 1
static bfd_boolean sunos_finish_dynamic_link
d109 1
a109 1
  bfd_boolean valid;
d138 1
a138 1
   structure to FALSE to avoid doing this work again.  */
d140 1
a140 1
static bfd_boolean
d153 1
a153 1
    return TRUE;
d158 1
a158 1
      return FALSE;
d164 2
a165 2
    return FALSE;
  info->valid = FALSE;
d181 1
a181 1
    return TRUE;
d185 1
a185 1
    return TRUE;
d189 1
a189 1
    return TRUE;
d201 1
a201 1
    return TRUE;
d208 1
a208 1
    return TRUE;
d255 1
a255 1
  info->valid = TRUE;
d257 1
a257 1
  return TRUE;
d283 1
a283 1
static bfd_boolean
d294 1
a294 1
	  return FALSE;
d301 1
a301 1
      return FALSE;
d310 1
a310 1
	return FALSE;
d319 1
a319 1
	  return FALSE;
d329 1
a329 1
	return FALSE;
d338 1
a338 1
	  return FALSE;
d342 1
a342 1
  return TRUE;
d416 1
a416 1
					    info->dynstr, strsize, TRUE))
d654 1
a654 1
  bfd_boolean dynamic_sections_created;
d657 1
a657 1
  bfd_boolean dynamic_sections_needed;
d660 1
a660 1
  bfd_boolean got_needed;
d731 3
a733 3
  ret->dynamic_sections_created = FALSE;
  ret->dynamic_sections_needed = FALSE;
  ret->got_needed = FALSE;
d754 1
a754 1
    (bfd_boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func), \
d762 1
a762 1
static bfd_boolean sunos_scan_dynamic_symbol
d772 1
a772 1
static bfd_boolean
d776 1
a776 1
     bfd_boolean needed;
d796 1
a796 1
	return FALSE;
d804 1
a804 1
	return FALSE;
d812 1
a812 1
	return FALSE;
d820 1
a820 1
	return FALSE;
d828 1
a828 1
	return FALSE;
d836 1
a836 1
	return FALSE;
d844 1
a844 1
	return FALSE;
d846 1
a846 1
      sunos_hash_table (info)->dynamic_sections_created = TRUE;
d860 2
a861 2
      sunos_hash_table (info)->dynamic_sections_needed = TRUE;
      sunos_hash_table (info)->got_needed = TRUE;
d864 1
a864 1
  return TRUE;
d870 1
a870 1
static bfd_boolean
d887 5
a891 3
					   ((abfd->flags & DYNAMIC) != 0
					    && !info->relocateable)))
	return FALSE;
d896 1
a896 1
    return TRUE;
d918 1
a918 1
    return TRUE;
d925 1
a925 1
      return FALSE;
d945 1
a945 1
	return FALSE;
d962 1
a962 1
	return FALSE;
d967 1
a967 1
    return FALSE;
d989 1
a989 1
	return FALSE;
d992 1
a992 1
	 should probably define structs for this manipulation.  */
d1003 1
a1003 1
	return FALSE;
d1010 1
a1010 1
	return FALSE;
d1021 1
a1021 1
	  return FALSE;
d1029 1
a1029 1
	      return FALSE;
d1041 1
a1041 1
		  return FALSE;
d1073 1
a1073 1
		  return FALSE;
d1087 1
a1087 1
	  return FALSE;
d1102 1
a1102 1
  return TRUE;
d1109 1
a1109 1
static bfd_boolean
d1119 2
a1120 2
     bfd_boolean copy;
     bfd_boolean collect;
d1128 2
a1129 2
    h = sunos_link_hash_lookup (sunos_hash_table (info), name, TRUE, copy,
				FALSE);
d1132 1
a1132 1
	 bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE));
d1134 1
a1134 1
    return FALSE;
d1188 4
a1191 4
	 is from a dynamic object.  A constructor symbol is actually a
	 definition, although the type will be bfd_link_hash_undefined
	 at this point.  We want to ignore the definition from the
	 dynamic object.  */
d1201 2
a1202 2
	 is a constructor symbol.  As above, we want to force the use
	 of the constructor symbol from the regular object.  */
d1210 1
a1210 1
    return FALSE;
d1247 1
a1247 1
  return TRUE;
d1266 1
a1266 1
bfd_boolean
d1275 1
a1275 1
    return TRUE;
d1281 1
a1281 1
			      FALSE, FALSE, FALSE);
d1283 1
a1283 1
    return TRUE;
d1298 1
a1298 1
  return TRUE;
d1307 1
a1307 1
   info->keep_memory is TRUE, we keep the relocs in memory; otherwise,
d1310 1
a1310 1
bfd_boolean
d1333 1
a1333 1
    return TRUE;
d1336 1
a1336 1
    return TRUE;
d1352 1
a1352 1
	    return FALSE;
d1363 1
a1363 1
    return TRUE;
d1367 1
a1367 1
			      "__GLOBAL_OFFSET_TABLE_", FALSE, FALSE, FALSE);
d1380 2
a1381 2
	 __GLOBAL_OFFSET_TABLE_ to be 0x1000 bytes into the section,
	 so that 13 bit relocations have a greater chance of working.  */
d1418 1
a1418 1
	return FALSE;
d1439 1
a1439 1
	return FALSE;
d1469 1
a1469 1
	    return FALSE;
d1484 1
a1484 1
	return FALSE;
d1507 1
a1507 1
	return FALSE;
d1517 1
a1517 1
    return FALSE;
d1522 1
a1522 1
  return TRUE;
d1527 1
a1527 1
static bfd_boolean
d1538 1
a1538 1
    return TRUE;
d1558 1
a1558 1
    return FALSE;
d1582 1
a1582 1
  return TRUE;
d1587 1
a1587 1
  return FALSE;
d1600 1
a1600 1
static bfd_boolean
d1618 1
a1618 1
      return FALSE;
d1680 2
a1681 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1691 1
a1691 1
	  sunos_hash_table (info)->got_needed = TRUE;
d1751 1
a1751 1
  return TRUE;
d1760 1
a1760 1
static bfd_boolean
d1780 1
a1780 1
      return FALSE;
d1827 1
a1827 1
	 the .got section.  */
d1834 2
a1835 2
	      if (! sunos_create_dynamic_sections (abfd, info, FALSE))
		return FALSE;
d1845 1
a1845 1
	      sunos_hash_table (info)->got_needed = TRUE;
d1871 1
a1871 1
		    return FALSE;
d1895 2
a1896 2
	 defined in dynamic objects but not in regular objects.  We
	 only need to consider relocs against external symbols.  */
d1900 1
a1900 1
	     generate an absolute reloc.  */
d1905 2
a1906 2
		  if (! sunos_create_dynamic_sections (abfd, info, TRUE))
		    return FALSE;
d1942 2
a1943 2
	     here; just let the relocation routine report an undefined
	     symbol.  */
d1952 2
a1953 2
	  if (! sunos_create_dynamic_sections (abfd, info, FALSE))
	    return FALSE;
d1963 1
a1963 1
	  sunos_hash_table (info)->got_needed = TRUE;
d2028 2
a2029 2
		 is a JMP_TBL reloc produced by linking PIC compiled
		 code, and we are not making a shared library.  */
d2035 1
a2035 1
	     any reloc other than a jump table reloc.  */
d2041 1
a2041 1
  return TRUE;
d2047 1
a2047 1
static bfd_boolean
d2069 1
a2069 1
    h->root.written = TRUE;
d2128 1
a2128 1
	return FALSE;
d2164 1
a2164 1
  return TRUE;
d2172 1
a2172 1
static bfd_boolean
d2177 1
a2177 1
  return TRUE;
d2183 1
a2183 1
static bfd_boolean
d2257 1
a2257 1
	 result of a JMP_TBL reloc from PIC compiled code.  */
d2323 1
a2323 1
    return TRUE;
d2331 1
a2331 1
      return TRUE;
d2389 1
a2389 1
      return TRUE;
d2408 1
a2408 1
  return TRUE;
d2417 1
a2417 1
static bfd_boolean
d2426 1
a2426 1
     bfd_boolean *skip;
d2431 3
a2433 3
  bfd_boolean baserel;
  bfd_boolean jmptbl;
  bfd_boolean pcrel;
d2438 1
a2438 1
  *skip = FALSE;
d2496 1
a2496 1
	 because they are pcrel_offset.  */
d2565 1
a2565 1
		 dynamic linker to fill in this entry in the table.  */
d2670 1
a2670 1
      return TRUE;
d2674 1
a2674 1
    return TRUE;
d2683 1
a2683 1
	return TRUE;
d2692 1
a2692 1
	return TRUE;
d2735 1
a2735 1
	 reloc.  */
d2774 1
a2774 1
    *skip = TRUE;
d2776 1
a2776 1
  return TRUE;
d2781 1
a2781 1
static bfd_boolean
d2793 1
a2793 1
    return TRUE;
d2846 1
a2846 1
	    return FALSE;
d2871 1
a2871 1
	return FALSE;
d2939 1
a2939 1
	return FALSE;
d2944 1
a2944 1
  return TRUE;
@


1.10.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   2002, 2003 Free Software Foundation, Inc.
d887 1
a887 1
					    && !info->relocatable)))
d914 1
a914 1
  if (info->relocatable)
d1329 1
a1329 1
  if (info->relocatable)
@


1.10.12.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1249 1
d2168 1
d2413 1
@


1.9
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1437 1
a1437 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, hashalloc);
a1439 1
      memset (s->contents, 0, (size_t) hashalloc);
@


1.9.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1437 1
a1437 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, hashalloc);
d1440 1
@


1.9.4.1
log
@merge from trunk
@
text
@d1437 1
a1437 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, hashalloc);
d1440 1
@


1.8
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d720 1
a720 1
  ret = (struct sunos_link_hash_table *) bfd_alloc (abfd, amt);
d726 1
a726 1
      bfd_release (abfd, ret);
@


1.7
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d2055 3
@


1.7.2.1
log
@Merge from mainline.
@
text
@a2054 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct sunos_link_hash_entry *) h->root.root.u.i.link;

@


1.6
log
@	* version.h: New file.
	* bfd-in.h: (BFD_VERSION): Substitute bfd_version.
	(BFD_VERSION_DATE): Define.
	(BFD_VERSION_STRING): Define.
	* configure.in: AC_SUBST bfd_version, bfd_version_date and
	bfd_version_string.
	(AC_OUTPUT <bfd-in3.h>): Depend on version.h.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.

	* bfd-in.h: Include "symcat.h".
	(CONCAT4): Redefine as for old CAT4.
	* aout-arm.c: Use equivalent CONCAT* macro in place of CAT* macros.
	Add warning regarding whitespace.
	* aout-cris.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aout-sparcle.c: Likewise.
	* aout-tic30.c: Likewise.
	* aout0.c: Likewise.
	* armnetbsd.c: Likewise.
	* demo64.c: Likewise.
	* elf-bfd.h: Likewise.
	* gen-aout.c: Likewise.
	* host-aout.c: Likewise.
	* hp300bsd.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386aout.c: Likewise.
	* i386bsd.c: Likewise.
	* i386dynix.c: Likewise.
	* i386freebsd.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386netbsd.c: Likewise.
	* libaout.h: Likewise.
	* m68k4knetbsd.c: Likewise.
	* m68klinux.c: Likewise.
	* m68klynx.c: Likewise.
	* m68knetbsd.c: Likewise.
	* m88kmach3.c: Likewise.
	* mipsbsd.c: Likewise.
	* newsos3.c: Likewise.
	* ns32knetbsd.c: Likewise.
	* pc532-mach.c: Likewise.
	* pdp11.c: Likewise.
	* riscix.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* sunos.c: Likewise.
	* targets.c: Likewise.
	* vaxnetbsd.c: Likewise.
	* vms-hdr.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000, 2001
d881 1
d907 1
a907 3
  if (abfd != dynobj)
    abfd->sections = NULL;
  else
d909 4
a912 7
      asection *s;

      for (s = abfd->sections;
	   (s->flags & SEC_LINKER_CREATED) == 0;
	   s = s->next)
	;
      abfd->sections = s;
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d23 5
a27 1
#define MY(OP) CAT(sunos_big_,OP)
@


1.4
log
@Update copyright notices
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000
d145 1
d156 2
a157 2
  info = ((struct sunos_dynamic_info *)
	  bfd_zalloc (abfd, sizeof (struct sunos_dynamic_info)));
d178 2
a179 1
				  (file_ptr) 0, sizeof dyninfo))
d200 2
a201 1
  if (! bfd_get_section_contents (abfd, dynsec, (PTR) &linkinfo, dynoff,
d283 1
d302 2
a303 4
      info->dynsym = ((struct external_nlist *)
		      bfd_alloc (abfd,
				 (info->dynsym_count
				  * EXTERNAL_NLIST_SIZE)));
d306 2
a307 4
      if (bfd_seek (abfd, info->dyninfo.ld_stab, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynsym, info->dynsym_count,
			EXTERNAL_NLIST_SIZE, abfd)
	      != info->dynsym_count * EXTERNAL_NLIST_SIZE))
d321 2
a322 1
      info->dynstr = (char *) bfd_alloc (abfd, info->dyninfo.ld_symb_size);
d325 2
a326 4
      if (bfd_seek (abfd, info->dyninfo.ld_symbols, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynstr, 1, info->dyninfo.ld_symb_size,
			abfd)
	      != info->dyninfo.ld_symb_size))
d369 2
a370 2
    if (bfd_seek (abfd, info->dyninfo.ld_hash, SEEK_SET) != 0
	|| bfd_read ((PTR) table, 1, table_size, abfd) != table_size)
d400 5
a404 4
      info->canonical_dynsym = ((aout_symbol_type *)
				bfd_alloc (abfd,
					   (info->dynsym_count
					    * sizeof (aout_symbol_type))));
d409 3
a411 4
					    info->dynsym, info->dynsym_count,
					    info->dynstr,
					    info->dyninfo.ld_symb_size,
					    true))
d461 1
d480 3
a482 4
      info->dynrel = (PTR) bfd_alloc (abfd,
				      (info->dynrel_count
				       * obj_reloc_entry_size (abfd)));
      if (info->dynrel == NULL && info->dynrel_count != 0)
d484 2
a485 4
      if (bfd_seek (abfd, info->dyninfo.ld_rel, SEEK_SET) != 0
	  || (bfd_read ((PTR) info->dynrel, info->dynrel_count,
			obj_reloc_entry_size (abfd), abfd)
	      != info->dynrel_count * obj_reloc_entry_size (abfd)))
d502 2
a503 4
      info->canonical_dynrel = ((arelent *)
				bfd_alloc (abfd,
					   (info->dynrel_count
					    * sizeof (arelent))));
d518 1
a518 1
					  info->dynsym_count);
d529 1
a529 1
					  info->dynsym_count);
d562 1
a562 1
#define SPARC_PLT_ENTRY_WORD0 0x9de3bfa0
d564 1
a564 1
#define SPARC_PLT_ENTRY_WORD1 0x40000000
d566 1
a566 1
#define SPARC_PLT_ENTRY_WORD2 0x01000000
d572 1
a572 1
#define SPARC_PLT_PIC_WORD0 0x03000000
d574 1
a574 1
#define SPARC_PLT_PIC_WORD1 0x81c06000
d576 1
a576 1
#define SPARC_PLT_PIC_WORD2 0x01000000
d596 1
a596 1
#define M68K_PLT_ENTRY_WORD0 (0x61ff)
d713 1
d715 1
a715 2
  ret = ((struct sunos_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct sunos_link_hash_table)));
a872 1
  asection *s;
d935 1
a935 1
      s = bfd_make_section (dynobj, ".need");
d952 1
a952 1
      s = bfd_make_section (dynobj, ".rules");
d982 1
a982 1
      size_t alc;
d986 2
a987 2
      if (bfd_seek (abfd, need, SEEK_SET) != 0
	  || bfd_read (buf, 1, 16, abfd) != 16)
d995 2
a996 2
      major_vno = (unsigned short)bfd_get_16 (abfd, buf + 8);
      minor_vno = (unsigned short)bfd_get_16 (abfd, buf + 10);
d999 2
a1000 2
      needed = ((struct bfd_link_needed_list *)
		bfd_alloc (abfd, sizeof (struct bfd_link_needed_list)));
d1017 1
a1017 1
      if (bfd_seek (abfd, name, SEEK_SET) != 0)
d1025 1
a1025 1
	  if (bfd_read (&b, 1, 1, abfd) != 1)
d1031 1
a1031 1
	  if ((size_t) (p - namebuf) >= alc)
d1082 1
a1082 1
      namecopy = bfd_alloc (abfd, strlen (namebuf) + 1);
d1319 1
a1319 1
  size_t dynsymcount;
d1323 1
a1323 1
  size_t hashalloc;
d1439 1
a1439 1
      memset (s->contents, 0, hashalloc);
d1467 1
a1467 1
					       (size_t) (s->_raw_size + add));
d1541 1
a1541 1
    relocs = free_relocs = bfd_malloc ((size_t) rel_size);
d1545 1
d1547 1
a1547 2
      n = ((struct aout_section_data_struct *)
	   bfd_alloc (abfd, sizeof (struct aout_section_data_struct)));
d1553 1
a1553 1
	  relocs = bfd_malloc ((size_t) rel_size);
d1561 1
a1561 1
      || bfd_read (relocs, 1, rel_size, abfd) != rel_size)
d1774 1
d1866 2
d1869 1
a1869 3
		    (bfd_vma *) bfd_zalloc (abfd,
					    (bfd_get_symcount (abfd)
					     * sizeof (bfd_vma)));
a2198 1
      asection *s;
a2226 2
	      bfd_vma val;

d2245 1
a2245 1
	  bfd_put_16 (output_bfd, s->reloc_count, p + 6);
d2394 2
a2395 2
  bfd_h_put_8 (output_bfd, type, outsym->e_type);
  bfd_h_put_8 (output_bfd, 0, outsym->e_other);
d2400 1
a2400 1
  bfd_h_put_16 (output_bfd, 0, outsym->e_desc);
d2663 1
a2663 1
		      + (*got_offsetp &~ 1)
d2840 2
a2841 1
					  o->contents, o->output_offset,
d2851 1
d2866 2
a2867 1
				      sdyn->output_offset, sizeof esd))
d2932 2
d2935 1
a2935 4
				      (sdyn->output_offset
				       + sizeof esd
				       + EXTERNAL_SUN4_DYNAMIC_DEBUGGER_SIZE),
				      sizeof esdl))
@


1.3
log
@2000-12-19  Kazu Hirata  <kazu@@hxi.com>

	* sco5-core.c: Fix formatting.
	* section.c: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* sparcnetbsd.c: Likewise.
	* srec.c: Likewise.
	* stabs.c: Likewise.
	* stab-syms.c: Likewise.
	* sunos.c: Likewise.
	* syms.c: Likewise.
	* sysdep.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1994, 1995, 1996, 1997, 1998, 2000
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d511 1
a511 1
      
d1424 1
a1424 1
      
d2277 3
a2279 3
		  srel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
		  srel->r_index[2] = (bfd_byte)(h->dynindx);
d2285 2
a2286 2
		  srel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  srel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2300 2
a2301 2
		  erel->r_index[0] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2309 2
a2310 2
		  erel->r_index[2] = (bfd_byte)(h->dynindx >> 16);
		  erel->r_index[1] = (bfd_byte)(h->dynindx >> 8);
d2597 2
a2598 2
		      srel->r_index[0] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
d2611 2
a2612 2
		      srel->r_index[2] = (bfd_byte)(indx >> 16);
		      srel->r_index[1] = (bfd_byte)(indx >> 8);
d2636 2
a2637 2
		      erel->r_index[0] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
d2649 2
a2650 2
		      erel->r_index[2] = (bfd_byte)(indx >> 16);
		      erel->r_index[1] = (bfd_byte)(indx >> 8);
d2729 2
a2730 2
	  srel->r_index[0] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
d2735 2
a2736 2
	  srel->r_index[2] = (bfd_byte)(indx >> 16);
	  srel->r_index[1] = (bfd_byte)(indx >> 8);
d2754 2
a2755 2
	  erel->r_index[0] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
d2760 2
a2761 2
	  erel->r_index[2] = (bfd_byte)(indx >> 16);
	  erel->r_index[1] = (bfd_byte)(indx >> 8);
d2936 1
a2936 1
  
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d1260 1
a1260 1
     bfd *abfd;
d1610 1
a1610 1
     asection *sec;
d1770 1
a1770 1
     asection *sec;
d2176 2
a2177 2
     struct bfd_link_info *info;
     bfd *abfd;
d2430 1
a2430 1
     bfd_byte *contents;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

