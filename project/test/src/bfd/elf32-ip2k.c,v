head	1.31;
access;
symbols
	sid-snapshot-20180601:1.31
	sid-snapshot-20180501:1.31
	sid-snapshot-20180401:1.31
	sid-snapshot-20180301:1.31
	sid-snapshot-20180201:1.31
	sid-snapshot-20180101:1.31
	sid-snapshot-20171201:1.31
	sid-snapshot-20171101:1.31
	sid-snapshot-20171001:1.31
	sid-snapshot-20170901:1.31
	sid-snapshot-20170801:1.31
	sid-snapshot-20170701:1.31
	sid-snapshot-20170601:1.31
	sid-snapshot-20170501:1.31
	sid-snapshot-20170401:1.31
	sid-snapshot-20170301:1.31
	sid-snapshot-20170201:1.31
	sid-snapshot-20170101:1.31
	sid-snapshot-20161201:1.31
	sid-snapshot-20161101:1.31
	sid-snapshot-20160901:1.31
	sid-snapshot-20160801:1.31
	sid-snapshot-20160701:1.31
	sid-snapshot-20160601:1.31
	sid-snapshot-20160501:1.31
	sid-snapshot-20160401:1.31
	sid-snapshot-20160301:1.31
	sid-snapshot-20160201:1.31
	sid-snapshot-20160101:1.31
	sid-snapshot-20151201:1.31
	sid-snapshot-20151101:1.31
	sid-snapshot-20151001:1.31
	sid-snapshot-20150901:1.31
	sid-snapshot-20150801:1.31
	sid-snapshot-20150701:1.31
	sid-snapshot-20150601:1.31
	sid-snapshot-20150501:1.31
	sid-snapshot-20150401:1.31
	sid-snapshot-20150301:1.31
	sid-snapshot-20150201:1.31
	sid-snapshot-20150101:1.31
	sid-snapshot-20141201:1.31
	sid-snapshot-20141101:1.31
	sid-snapshot-20141001:1.31
	sid-snapshot-20140901:1.31
	sid-snapshot-20140801:1.31
	sid-snapshot-20140701:1.31
	sid-snapshot-20140601:1.31
	sid-snapshot-20140501:1.31
	sid-snapshot-20140401:1.31
	sid-snapshot-20140301:1.31
	sid-snapshot-20140201:1.31
	sid-snapshot-20140101:1.31
	sid-snapshot-20131201:1.31
	sid-snapshot-20131101:1.31
	sid-snapshot-20131001:1.31
	binutils-2_24-branch:1.31.0.4
	binutils-2_24-branchpoint:1.31
	binutils-2_21_1:1.28
	sid-snapshot-20130901:1.31
	gdb_7_6_1-2013-08-30-release:1.31
	sid-snapshot-20130801:1.31
	sid-snapshot-20130701:1.31
	sid-snapshot-20130601:1.31
	sid-snapshot-20130501:1.31
	gdb_7_6-2013-04-26-release:1.31
	sid-snapshot-20130401:1.31
	binutils-2_23_2:1.30
	gdb_7_6-branch:1.31.0.2
	gdb_7_6-2013-03-12-branchpoint:1.31
	sid-snapshot-20130301:1.31
	sid-snapshot-20130201:1.31
	sid-snapshot-20130101:1.30
	sid-snapshot-20121201:1.30
	gdb_7_5_1-2012-11-29-release:1.30
	binutils-2_23_1:1.30
	sid-snapshot-20121101:1.30
	binutils-2_23:1.30
	sid-snapshot-20121001:1.30
	sid-snapshot-20120901:1.30
	gdb_7_5-2012-08-17-release:1.30
	sid-snapshot-20120801:1.30
	binutils-2_23-branch:1.30.0.4
	binutils-2_23-branchpoint:1.30
	gdb_7_5-branch:1.30.0.2
	gdb_7_5-2012-07-18-branchpoint:1.30
	sid-snapshot-20120701:1.30
	sid-snapshot-20120601:1.30
	sid-snapshot-20120501:1.29
	binutils-2_22_branch:1.28.0.10
	gdb_7_4_1-2012-04-26-release:1.28
	sid-snapshot-20120401:1.28
	sid-snapshot-20120301:1.28
	sid-snapshot-20120201:1.28
	gdb_7_4-2012-01-24-release:1.28
	sid-snapshot-20120101:1.28
	gdb_7_4-branch:1.28.0.8
	gdb_7_4-2011-12-13-branchpoint:1.28
	sid-snapshot-20111201:1.28
	binutils-2_22:1.28
	sid-snapshot-20111101:1.28
	sid-snapshot-20111001:1.28
	binutils-2_22-branch:1.28.0.6
	binutils-2_22-branchpoint:1.28
	gdb_7_3_1-2011-09-04-release:1.28
	sid-snapshot-20110901:1.28
	sid-snapshot-20110801:1.28
	gdb_7_3-2011-07-26-release:1.28
	sid-snapshot-20110701:1.28
	sid-snapshot-20110601:1.28
	sid-snapshot-20110501:1.28
	gdb_7_3-branch:1.28.0.4
	gdb_7_3-2011-04-01-branchpoint:1.28
	sid-snapshot-20110401:1.28
	sid-snapshot-20110301:1.28
	sid-snapshot-20110201:1.28
	sid-snapshot-20110101:1.28
	binutils-2_21:1.28
	sid-snapshot-20101201:1.28
	binutils-2_21-branch:1.28.0.2
	binutils-2_21-branchpoint:1.28
	sid-snapshot-20101101:1.28
	sid-snapshot-20101001:1.27
	binutils-2_20_1:1.25
	gdb_7_2-2010-09-02-release:1.27
	sid-snapshot-20100901:1.27
	sid-snapshot-20100801:1.27
	gdb_7_2-branch:1.27.0.2
	gdb_7_2-2010-07-07-branchpoint:1.27
	sid-snapshot-20100701:1.27
	sid-snapshot-20100601:1.26
	sid-snapshot-20100501:1.26
	sid-snapshot-20100401:1.26
	gdb_7_1-2010-03-18-release:1.26
	sid-snapshot-20100301:1.26
	gdb_7_1-branch:1.26.0.2
	gdb_7_1-2010-02-18-branchpoint:1.26
	sid-snapshot-20100201:1.26
	sid-snapshot-20100101:1.26
	gdb_7_0_1-2009-12-22-release:1.25
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.25
	gdb_7_0-2009-10-06-release:1.25
	sid-snapshot-20091001:1.25
	gdb_7_0-branch:1.25.0.34
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.25
	binutils-arc-20081103-branch:1.25.0.32
	binutils-arc-20081103-branchpoint:1.25
	binutils-2_20-branch:1.25.0.30
	binutils-2_20-branchpoint:1.25
	sid-snapshot-20090901:1.25
	sid-snapshot-20090801:1.25
	msnyder-checkpoint-072509-branch:1.25.0.28
	msnyder-checkpoint-072509-branchpoint:1.25
	sid-snapshot-20090701:1.25
	dje-cgen-play1-branch:1.25.0.26
	dje-cgen-play1-branchpoint:1.25
	sid-snapshot-20090601:1.25
	sid-snapshot-20090501:1.25
	sid-snapshot-20090401:1.25
	arc-20081103-branch:1.25.0.24
	arc-20081103-branchpoint:1.25
	arc-insight_6_8-branch:1.25.0.22
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.20
	insight_6_8-branchpoint:1.25
	sid-snapshot-20090301:1.25
	binutils-2_19_1:1.25
	sid-snapshot-20090201:1.25
	sid-snapshot-20090101:1.25
	reverse-20081226-branch:1.25.0.18
	reverse-20081226-branchpoint:1.25
	sid-snapshot-20081201:1.25
	multiprocess-20081120-branch:1.25.0.16
	multiprocess-20081120-branchpoint:1.25
	sid-snapshot-20081101:1.25
	binutils-2_19:1.25
	sid-snapshot-20081001:1.25
	reverse-20080930-branch:1.25.0.14
	reverse-20080930-branchpoint:1.25
	binutils-2_19-branch:1.25.0.12
	binutils-2_19-branchpoint:1.25
	sid-snapshot-20080901:1.25
	sid-snapshot-20080801:1.25
	reverse-20080717-branch:1.25.0.10
	reverse-20080717-branchpoint:1.25
	sid-snapshot-20080701:1.25
	msnyder-reverse-20080609-branch:1.25.0.8
	msnyder-reverse-20080609-branchpoint:1.25
	drow-reverse-20070409-branch:1.23.0.2
	drow-reverse-20070409-branchpoint:1.23
	sid-snapshot-20080601:1.25
	sid-snapshot-20080501:1.25
	sid-snapshot-20080403:1.25
	sid-snapshot-20080401:1.25
	gdb_6_8-2008-03-27-release:1.25
	sid-snapshot-20080301:1.25
	gdb_6_8-branch:1.25.0.6
	gdb_6_8-2008-02-26-branchpoint:1.25
	sid-snapshot-20080201:1.25
	sid-snapshot-20080101:1.25
	sid-snapshot-20071201:1.25
	sid-snapshot-20071101:1.25
	gdb_6_7_1-2007-10-29-release:1.25
	gdb_6_7-2007-10-10-release:1.25
	sid-snapshot-20071001:1.25
	gdb_6_7-branch:1.25.0.4
	gdb_6_7-2007-09-07-branchpoint:1.25
	binutils-2_18:1.25
	binutils-2_18-branch:1.25.0.2
	binutils-2_18-branchpoint:1.25
	insight_6_6-20070208-release:1.21
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	gdb_6_6-2006-12-18-release:1.21
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.17
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	gdb_6_6-branch:1.21.0.2
	gdb_6_6-2006-11-15-branchpoint:1.21
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.20
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.17
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.20
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	gdb-csl-sourcerygxx-4_1-17:1.20
	binutils-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.20
	gdb-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	gdb-csl-sourcerygxx-4_1-13:1.20
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	gdb-csl-sourcerygxx-4_1-12:1.20
	binutils-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.20
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.17
	binutils-csl-wrs-linux-3_4_4-23:1.17
	gdb-csl-sourcerygxx-4_1-9:1.20
	binutils-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.20
	binutils-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.20
	binutils-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.20
	binutils-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.20
	gdb-csl-symbian-6_4_50_20060226-9:1.20
	gdb-csl-symbian-6_4_50_20060226-8:1.20
	gdb-csl-coldfire-4_1-11:1.20
	binutils-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.20
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.20
	gdb_6_5-branch:1.20.0.28
	gdb_6_5-2006-05-14-branchpoint:1.20
	binutils-csl-coldfire-4_1-10:1.20
	gdb-csl-sourcerygxx-4_1-5:1.20
	binutils-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.20.0.26
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.20
	binutils-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.24
	msnyder-reverse-20060502-branchpoint:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.17
	gdb-csl-morpho-4_1-4:1.20
	binutils-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.17
	readline_5_1-import-branch:1.20.0.22
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.20
	binutils-2_17-branch:1.20.0.20
	binutils-2_17-branchpoint:1.20
	gdb-csl-symbian-20060226-branch:1.20.0.18
	gdb-csl-symbian-20060226-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.20
	msnyder-reverse-20060331-branch:1.20.0.16
	msnyder-reverse-20060331-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.14
	binutils-csl-2_17-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.20.0.12
	gdb-csl-available-20060303-branchpoint:1.20
	gdb-csl-20060226-branch:1.20.0.10
	gdb-csl-20060226-branchpoint:1.20
	gdb_6_4-20051202-release:1.20
	msnyder-fork-checkpoint-branch:1.20.0.8
	msnyder-fork-checkpoint-branchpoint:1.20
	gdb-csl-gxxpro-6_3-branch:1.20.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.20
	gdb_6_4-branch:1.20.0.4
	gdb_6_4-2005-11-01-branchpoint:1.20
	gdb-csl-arm-20051020-branch:1.20.0.2
	gdb-csl-arm-20051020-branchpoint:1.20
	binutils-csl-gxxpro-3_4-branch:1.17.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.17
	binutils-2_16_1:1.17
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.17
	binutils-csl-arm-2005q1b:1.17
	binutils-2_16:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	binutils-csl-arm-2005q1a:1.17
	csl-arm-20050325-branch:1.17.0.6
	csl-arm-20050325-branchpoint:1.17
	binutils-csl-arm-2005q1-branch:1.17.0.4
	binutils-csl-arm-2005q1-branchpoint:1.17
	binutils-2_16-branch:1.17.0.2
	binutils-2_16-branchpoint:1.17
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.4
	gdb_6_3-20041019-branchpoint:1.13
	csl-arm-2004-q3:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11.6.1
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.2
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.12
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.8
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.10.0.6
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.4
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.8.0.14
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.8
	binutils-2_14:1.7
	cagney_convert-20030606-branch:1.8.0.10
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.8
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.4
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	binutils-2_14-branch:1.7.0.22
	binutils-2_14-branchpoint:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.20
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.18
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.16
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.14
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.12
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.10
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.8
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.6
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.4
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.2
	cagney-unwind-20030108-branchpoint:1.7
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.12
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.10
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.8
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	kseitz_interps-20020528-branch:1.1.0.2
	binutils_latest_snapshot:1.31;
locks; strict;
comment	@ * @;


1.31
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.29;

1.29
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches
	1.28.6.1;
next	1.27;

1.27
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.01.11.16.29;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.15.53.15;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.03.11.40.59;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.11.17.13.02;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.31.23.13.21;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.21.15.28.23;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.04.46.19;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches
	1.11.6.1
	1.11.8.1;
next	1.10;

1.10
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.06.40.25;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.09.02.27.03;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.03.08.21.43;	author nickc;	state Exp;
branches
	1.7.20.1;
next	1.6;

1.6
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.17.18.27.01;	author denisc;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.01.18.29.09;	author denisc;	state Exp;
branches
	1.3.10.1
	1.3.12.1;
next	1.2;

1.2
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.17.14.15.49;	author nickc;	state Exp;
branches
	1.1.2.1;
next	;

1.28.6.1
date	2012.05.11.12.24.24;	author nickc;	state Exp;
branches;
next	;

1.11.6.1
date	2004.04.08.12.41.41;	author amodra;	state Exp;
branches;
next	;

1.11.8.1
date	2004.03.27.17.37.33;	author drow;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2004.09.16.17.00.23;	author drow;	state Exp;
branches;
next	;

1.7.20.1
date	2003.05.18.09.43.41;	author kettenis;	state Exp;
branches;
next	;

1.3.10.1
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2002.12.23.19.37.42;	author carlton;	state Exp;
branches;
next	1.3.10.3;

1.3.10.3
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.3.10.4;

1.3.10.4
date	2003.05.23.18.40.23;	author carlton;	state Exp;
branches;
next	1.3.10.5;

1.3.10.5
date	2003.06.27.21.49.14;	author carlton;	state Exp;
branches;
next	1.3.10.6;

1.3.10.6
date	2003.09.17.21.27.51;	author carlton;	state Exp;
branches;
next	1.3.10.7;

1.3.10.7
date	2003.12.15.23.59.25;	author carlton;	state Exp;
branches;
next	;

1.3.12.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2003.12.14.20.26.39;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.07.22.21.46.43;	author kseitz;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* Ubicom IP2xxx specific support for 32-bit ELF
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/ip2k.h"

/* Struct used to pass miscellaneous paramaters which
   helps to avoid overly long parameter lists.  */
struct misc
{
  Elf_Internal_Shdr *  symtab_hdr;
  Elf_Internal_Rela *  irelbase;
  bfd_byte *           contents;
  Elf_Internal_Sym *   isymbuf;
};

struct ip2k_opcode
{
  unsigned short opcode;
  unsigned short mask;
};

static bfd_boolean ip2k_relaxed = FALSE;

static const struct ip2k_opcode ip2k_page_opcode[] =
{
  {0x0010, 0xFFF8},	/* Page.  */
  {0x0000, 0x0000},
};

#define IS_PAGE_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_page_opcode)

static const struct ip2k_opcode ip2k_jmp_opcode[] =
{
  {0xE000, 0xE000},	/* Jmp.  */
  {0x0000, 0x0000},
};

#define IS_JMP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_jmp_opcode)

static const struct ip2k_opcode ip2k_snc_opcode[] =
{
  {0xA00B, 0xFFFF},	/* Snc.  */
  {0x0000, 0x0000},
};

#define IS_SNC_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_snc_opcode)

static const struct ip2k_opcode ip2k_inc_1sp_opcode[] =
{
  {0x2B81, 0xFFFF},	/* Inc 1(SP).  */
  {0x0000, 0x0000},
};

#define IS_INC_1SP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_inc_1sp_opcode)

static const struct ip2k_opcode ip2k_add_2sp_w_opcode[] =
{
  {0x1F82, 0xFFFF},	/* Add 2(SP),w.  */
  {0x0000, 0x0000},
};

#define IS_ADD_2SP_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_2sp_w_opcode)

static const struct ip2k_opcode ip2k_add_w_wreg_opcode[] =
{
  {0x1C0A, 0xFFFF},	/* Add w,wreg.  */
  {0x1E0A, 0xFFFF},	/* Add wreg,w.  */
  {0x0000, 0x0000},
};

#define IS_ADD_W_WREG_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_w_wreg_opcode)

static const struct ip2k_opcode ip2k_add_pcl_w_opcode[] =
{
  {0x1E09, 0xFFFF},	/* Add pcl,w.  */
  {0x0000, 0x0000},
};

#define IS_ADD_PCL_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_pcl_w_opcode)

static const struct ip2k_opcode ip2k_skip_opcodes[] =
{
  {0xB000, 0xF000},	/* sb */
  {0xA000, 0xF000},	/* snb */
  {0x7600, 0xFE00},	/* cse/csne #lit */
  {0x5800, 0xFC00},	/* incsnz */
  {0x4C00, 0xFC00},	/* decsnz */
  {0x4000, 0xFC00},	/* cse/csne */
  {0x3C00, 0xFC00},	/* incsz */
  {0x2C00, 0xFC00},	/* decsz */
  {0x0000, 0x0000},
};

#define IS_SKIP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_skip_opcodes)

/* Relocation tables.  */
static reloc_howto_type ip2k_elf_howto_table [] =
{
#define IP2K_HOWTO(t,rs,s,bs,pr,bp,name,sm,dm) \
    HOWTO(t,                    /* type */ \
          rs,                   /* rightshift */ \
          s,                    /* size (0 = byte, 1 = short, 2 = long) */ \
          bs,                   /* bitsize */ \
          pr,                   /* pc_relative */ \
          bp,                   /* bitpos */ \
          complain_overflow_dont,/* complain_on_overflow */ \
          bfd_elf_generic_reloc,/* special_function */ \
          name,                 /* name */ \
          FALSE,                /* partial_inplace */ \
          sm,                   /* src_mask */ \
          dm,                   /* dst_mask */ \
          pr)                   /* pcrel_offset */

  /* This reloc does nothing.  */
  IP2K_HOWTO (R_IP2K_NONE, 0,2,32, FALSE, 0, "R_IP2K_NONE", 0, 0),
  /* A 16 bit absolute relocation.  */
  IP2K_HOWTO (R_IP2K_16, 0,1,16, FALSE, 0, "R_IP2K_16", 0, 0xffff),
  /* A 32 bit absolute relocation.  */
  IP2K_HOWTO (R_IP2K_32, 0,2,32, FALSE, 0, "R_IP2K_32", 0, 0xffffffff),
  /* A 8-bit data relocation for the FR9 field.  Ninth bit is computed specially.  */
  IP2K_HOWTO (R_IP2K_FR9, 0,1,9, FALSE, 0, "R_IP2K_FR9", 0, 0x00ff),
  /* A 4-bit data relocation.  */
  IP2K_HOWTO (R_IP2K_BANK, 8,1,4, FALSE, 0, "R_IP2K_BANK", 0, 0x000f),
  /* A 13-bit insn relocation - word address => right-shift 1 bit extra.  */
  IP2K_HOWTO (R_IP2K_ADDR16CJP, 1,1,13, FALSE, 0, "R_IP2K_ADDR16CJP", 0, 0x1fff),
  /* A 3-bit insn relocation - word address => right-shift 1 bit extra.  */
  IP2K_HOWTO (R_IP2K_PAGE3, 14,1,3, FALSE, 0, "R_IP2K_PAGE3", 0, 0x0007),
  /* Two 8-bit data relocations.  */
  IP2K_HOWTO (R_IP2K_LO8DATA, 0,1,8, FALSE, 0, "R_IP2K_LO8DATA", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8DATA, 8,1,8, FALSE, 0, "R_IP2K_HI8DATA", 0, 0x00ff),
  /* Two 8-bit insn relocations.  word address => right-shift 1 bit extra.  */
  IP2K_HOWTO (R_IP2K_LO8INSN, 1,1,8, FALSE, 0, "R_IP2K_LO8INSN", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8INSN, 9,1,8, FALSE, 0, "R_IP2K_HI8INSN", 0, 0x00ff),

  /* Special 1 bit relocation for SKIP instructions.  */
  IP2K_HOWTO (R_IP2K_PC_SKIP, 1,1,1, FALSE, 12, "R_IP2K_PC_SKIP", 0xfffe, 0x1000),
  /* 16 bit word address.  */
  IP2K_HOWTO (R_IP2K_TEXT, 1,1,16, FALSE, 0, "R_IP2K_TEXT", 0, 0xffff),
  /* A 7-bit offset relocation for the FR9 field.  Eigth and ninth bit comes from insn.  */
  IP2K_HOWTO (R_IP2K_FR_OFFSET, 0,1,9, FALSE, 0, "R_IP2K_FR_OFFSET", 0x180, 0x007f),
  /* Bits 23:16 of an address.  */
  IP2K_HOWTO (R_IP2K_EX8DATA, 16,1,8, FALSE, 0, "R_IP2K_EX8DATA", 0, 0x00ff),
};


/* Map BFD reloc types to IP2K ELF reloc types.  */

static reloc_howto_type *
ip2k_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
			bfd_reloc_code_real_type code)
{
  /* Note that the ip2k_elf_howto_table is indxed by the R_
     constants.  Thus, the order that the howto records appear in the
     table *must* match the order of the relocation types defined in
     include/elf/ip2k.h.  */

  switch (code)
    {
    case BFD_RELOC_NONE:
      return &ip2k_elf_howto_table[ (int) R_IP2K_NONE];
    case BFD_RELOC_16:
      return &ip2k_elf_howto_table[ (int) R_IP2K_16];
    case BFD_RELOC_32:
      return &ip2k_elf_howto_table[ (int) R_IP2K_32];
    case BFD_RELOC_IP2K_FR9:
      return &ip2k_elf_howto_table[ (int) R_IP2K_FR9];
    case BFD_RELOC_IP2K_BANK:
      return &ip2k_elf_howto_table[ (int) R_IP2K_BANK];
    case BFD_RELOC_IP2K_ADDR16CJP:
      return &ip2k_elf_howto_table[ (int) R_IP2K_ADDR16CJP];
    case BFD_RELOC_IP2K_PAGE3:
      return &ip2k_elf_howto_table[ (int) R_IP2K_PAGE3];
    case BFD_RELOC_IP2K_LO8DATA:
      return &ip2k_elf_howto_table[ (int) R_IP2K_LO8DATA];
    case BFD_RELOC_IP2K_HI8DATA:
      return &ip2k_elf_howto_table[ (int) R_IP2K_HI8DATA];
    case BFD_RELOC_IP2K_LO8INSN:
      return &ip2k_elf_howto_table[ (int) R_IP2K_LO8INSN];
    case BFD_RELOC_IP2K_HI8INSN:
      return &ip2k_elf_howto_table[ (int) R_IP2K_HI8INSN];
    case BFD_RELOC_IP2K_PC_SKIP:
      return &ip2k_elf_howto_table[ (int) R_IP2K_PC_SKIP];
    case BFD_RELOC_IP2K_TEXT:
      return &ip2k_elf_howto_table[ (int) R_IP2K_TEXT];
    case BFD_RELOC_IP2K_FR_OFFSET:
      return &ip2k_elf_howto_table[ (int) R_IP2K_FR_OFFSET];
    case BFD_RELOC_IP2K_EX8DATA:
      return &ip2k_elf_howto_table[ (int) R_IP2K_EX8DATA];
    default:
      /* Pacify gcc -Wall.  */
      return NULL;
    }
  return NULL;
}

static reloc_howto_type *
ip2k_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (ip2k_elf_howto_table) / sizeof (ip2k_elf_howto_table[0]);
       i++)
    if (ip2k_elf_howto_table[i].name != NULL
	&& strcasecmp (ip2k_elf_howto_table[i].name, r_name) == 0)
      return &ip2k_elf_howto_table[i];

  return NULL;
}

static void
ip2k_get_mem (bfd *abfd ATTRIBUTE_UNUSED,
	      bfd_byte *addr,
	      int length,
	      bfd_byte *ptr)
{
  while (length --)
    * ptr ++ = bfd_get_8 (abfd, addr ++);
}

static bfd_boolean
ip2k_is_opcode (bfd_byte *code, const struct ip2k_opcode *opcodes)
{
  unsigned short insn = (code[0] << 8) | code[1];

  while (opcodes->mask != 0)
    {
      if ((insn & opcodes->mask) == opcodes->opcode)
	return TRUE;

      opcodes ++;
    }

  return FALSE;
}

#define PAGENO(ABSADDR) ((ABSADDR) & 0xFFFFC000)
#define BASEADDR(SEC)	((SEC)->output_section->vma + (SEC)->output_offset)

#define UNDEFINED_SYMBOL (~(bfd_vma)0)

/* Return the value of the symbol associated with the relocation IREL.  */

static bfd_vma
symbol_value (bfd *abfd,
	      Elf_Internal_Shdr *symtab_hdr,
	      Elf_Internal_Sym *isymbuf,
	      Elf_Internal_Rela *irel)
{
  if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
    {
      Elf_Internal_Sym *isym;
      asection *sym_sec;

      isym = isymbuf + ELF32_R_SYM (irel->r_info);
      if (isym->st_shndx == SHN_UNDEF)
	sym_sec = bfd_und_section_ptr;
      else if (isym->st_shndx == SHN_ABS)
	sym_sec = bfd_abs_section_ptr;
      else if (isym->st_shndx == SHN_COMMON)
	sym_sec = bfd_com_section_ptr;
      else
	sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);

      return isym->st_value + BASEADDR (sym_sec);
    }
  else
    {
      unsigned long indx;
      struct elf_link_hash_entry *h;

      indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
      h = elf_sym_hashes (abfd)[indx];
      BFD_ASSERT (h != NULL);

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	return UNDEFINED_SYMBOL;

      return (h->root.u.def.value + BASEADDR (h->root.u.def.section));
    }
}

/* Determine if the instruction sequence matches that for
   the prologue of a switch dispatch table with fewer than
   128 entries.

          sc
          page    $nnn0
          jmp     $nnn0
          add     w,wreg
          add     pcl,w
  addr=>
          page    $nnn1
          jmp     $nnn1
 	   page    $nnn2
 	   jmp     $nnn2
 	   ...
 	   page    $nnnN
 	   jmp     $nnnN

  After relaxation.
  	   sc
 	   page    $nnn0
  	   jmp     $nnn0
 	   add     pcl,w
  addr=>
  	   jmp     $nnn1
 	   jmp     $nnn2
 	   ...
          jmp     $nnnN  */

static int
ip2k_is_switch_table_128 (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *sec,
			  bfd_vma addr,
			  bfd_byte *contents)
{
  bfd_byte code[4];
  int table_index = 0;

  /* Check current page-jmp.  */
  if (addr + 4 > sec->size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);

  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;

  /* Search back.  */
  while (1)
    {
      if (addr < 4)
	return -1;

      /* Check previous 2 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 4, 4, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_ADD_PCL_W_OPCODE (code + 2)))
	return table_index;

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;

      table_index++;
      addr -= 4;
    }
}

/* Determine if the instruction sequence matches that for
   the prologue switch dispatch table with fewer than
   256 entries but more than 127.

   Before relaxation.
          push    %lo8insn(label) ; Push address of table
          push    %hi8insn(label)
          add     w,wreg          ; index*2 => offset
          snc                     ; CARRY SET?
          inc     1(sp)           ; Propagate MSB into table address
          add     2(sp),w         ; Add low bits of offset to table address
          snc                     ; and handle any carry-out
          inc     1(sp)
   addr=>
          page    __indjmp        ; Do an indirect jump to that location
          jmp     __indjmp
   label:                         ; case dispatch table starts here
 	   page    $nnn1
 	   jmp	   $nnn1
 	   page	   $nnn2
 	   jmp     $nnn2
 	   ...
 	   page    $nnnN
 	   jmp	   $nnnN

  After relaxation.
          push    %lo8insn(label) ; Push address of table
          push    %hi8insn(label)
          add     2(sp),w         ; Add low bits of offset to table address
          snc                     ; and handle any carry-out
          inc     1(sp)
  addr=>
          page    __indjmp        ; Do an indirect jump to that location
          jmp     __indjmp
   label:                         ; case dispatch table starts here
          jmp     $nnn1
          jmp     $nnn2
          ...
          jmp     $nnnN  */

static int
ip2k_is_switch_table_256 (bfd *abfd ATTRIBUTE_UNUSED,
			  asection *sec,
			  bfd_vma addr,
			  bfd_byte *contents)
{
  bfd_byte code[16];
  int table_index = 0;

  /* Check current page-jmp.  */
  if (addr + 4 > sec->size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);
  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;

  /* Search back.  */
  while (1)
    {
      if (addr < 16)
	return -1;

      /* Check previous 8 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 16, 16, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_SNC_OPCODE (code + 2))
	  && (IS_INC_1SP_OPCODE (code + 4))
	  && (IS_ADD_2SP_W_OPCODE (code + 6))
	  && (IS_SNC_OPCODE (code + 8))
	  && (IS_INC_1SP_OPCODE (code + 10))
	  && (IS_PAGE_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return table_index;

      if ((IS_ADD_W_WREG_OPCODE (code + 2))
	  && (IS_SNC_OPCODE (code + 4))
	  && (IS_INC_1SP_OPCODE (code + 6))
	  && (IS_ADD_2SP_W_OPCODE (code + 8))
	  && (IS_SNC_OPCODE (code + 10))
	  && (IS_INC_1SP_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return table_index;

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;

      table_index++;
      addr -= 4;
    }
}

/* Returns the expected page state for the given instruction not including
   the effect of page instructions.  */

static bfd_vma
ip2k_nominal_page_bits (bfd *abfd ATTRIBUTE_UNUSED,
			asection *sec,
			bfd_vma addr,
			bfd_byte *contents)
{
  bfd_vma page = PAGENO (BASEADDR (sec) + addr);

  /* Check if section flows into this page. If not then the page
     bits are assumed to match the PC. This will be true unless
     the user has a page instruction without a call/jump, in which
     case they are on their own.  */
  if (PAGENO (BASEADDR (sec)) == page)
    return page;

  /* Section flows across page boundary. The page bits should match
     the PC unless there is a possible flow from the previous page,
     in which case it is not possible to determine the value of the
     page bits.  */
  while (PAGENO (BASEADDR (sec) + addr - 2) == page)
    {
      bfd_byte code[2];

      addr -= 2;
      ip2k_get_mem (abfd, contents + addr, 2, code);
      if (!IS_PAGE_OPCODE (code))
	continue;

      /* Found a page instruction, check if jump table.  */
      if (ip2k_is_switch_table_128 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      if (ip2k_is_switch_table_256 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      /* Found a page instruction, check if conditional.  */
      if (addr >= 2)
        {
	  ip2k_get_mem (abfd, contents + addr - 2, 2, code);
          if (IS_SKIP_OPCODE (code))
	    /* Page is conditional.  */
	    continue;
        }

      /* Unconditional page instruction => page bits should be correct.  */
      return page;
    }

  /* Flow from previous page => page bits are impossible to determine.  */
  return 0;
}

static bfd_boolean
ip2k_test_page_insn (bfd *abfd ATTRIBUTE_UNUSED,
		     asection *sec,
		     Elf_Internal_Rela *irel,
		     struct misc *misc)
{
  bfd_vma symval;

  /* Get the value of the symbol referred to by the reloc.  */
  symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf, irel);
  if (symval == UNDEFINED_SYMBOL)
    /* This appears to be a reference to an undefined
       symbol.  Just ignore it--it will be caught by the
       regular reloc processing.  */
    return FALSE;

  /* Test if we can delete this page instruction.  */
  if (PAGENO (symval + irel->r_addend) !=
      ip2k_nominal_page_bits (abfd, sec, irel->r_offset, misc->contents))
    return FALSE;

  return TRUE;
}

/* Parts of a Stabs entry.  */

#define STRDXOFF   0
#define TYPEOFF    4
#define OTHEROFF   5
#define DESCOFF    6
#define VALOFF     8
#define STABSIZE   12

/* Adjust all the relocations entries after adding or inserting instructions.  */

static void
adjust_all_relocations (bfd *abfd,
			asection *sec,
			bfd_vma addr,
			bfd_vma endaddr,
			int count,
			int noadj)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
  unsigned int shndx;
  Elf_Internal_Rela *irel, *irelend, *irelbase;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
  asection *stab;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;

  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  irelbase = elf_section_data (sec)->relocs;
  irelend = irelbase + sec->reloc_count;

  for (irel = irelbase; irel < irelend; irel++)
    {
      if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
        {
          /* Get the value of the symbol referred to by the reloc.  */
          if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
            {
              asection *sym_sec;

              /* A local symbol.  */
	      isym = isymbuf + ELF32_R_SYM (irel->r_info);
              sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);

              if (isym->st_shndx == shndx)
                {
                  bfd_vma baseaddr = BASEADDR (sec);
                  bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
                                   + irel->r_addend;

                  if ((baseaddr + addr + noadj) <= symval
                      && symval < (baseaddr + endaddr))
                    irel->r_addend += count;
                }
            }
        }

      /* Do this only for PC space relocations.  */
      if (addr <= irel->r_offset && irel->r_offset < endaddr)
        irel->r_offset += count;
    }

  /* Now fix the stab relocations.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
  if (stab)
    {
      bfd_byte *stabcontents, *stabend, *stabp;
      bfd_size_type stab_size = stab->rawsize ? stab->rawsize : stab->size;

      irelbase = elf_section_data (stab)->relocs;
      irelend = irelbase + stab->reloc_count;

      /* Pull out the contents of the stab section.  */
      if (elf_section_data (stab)->this_hdr.contents != NULL)
	stabcontents = elf_section_data (stab)->this_hdr.contents;
      else
	{
	  if (!bfd_malloc_and_get_section (abfd, stab, &stabcontents))
	    {
	      if (stabcontents != NULL)
		free (stabcontents);
	      return;
	    }

	  /* We need to remember this.  */
	  elf_section_data (stab)->this_hdr.contents = stabcontents;
	}

      stabend = stabcontents + stab_size;

      for (irel = irelbase; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
	    {
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
		{
		  asection *sym_sec;

		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);
		  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);

		  if (sym_sec == sec)
		    {
		      const char *name;
		      unsigned char type;
		      bfd_vma value;
		      bfd_vma baseaddr = BASEADDR (sec);
		      bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
			+ irel->r_addend;

		      if ((baseaddr + addr) <= symval
			  && symval <= (baseaddr + endaddr))
			irel->r_addend += count;

		      /* Go hunt up a function and fix its line info if needed.  */
		      stabp = stabcontents + irel->r_offset - 8;

		      /* Go pullout the stab entry.  */
		      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
		      value = bfd_h_get_32 (abfd, stabp + VALOFF);

		      name = bfd_get_stab_name (type);

		      if (strcmp (name, "FUN") == 0)
			{
			  int function_adjusted = 0;

			  if (symval > (baseaddr + addr))
			    /* Not in this function.  */
			    continue;

			  /* Hey we got a function hit.  */
			  stabp += STABSIZE;
			  for (;stabp < stabend; stabp += STABSIZE)
			    {
			      /* Go pullout the stab entry.  */
			      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
			      value = bfd_h_get_32 (abfd, stabp + VALOFF);

			      name = bfd_get_stab_name (type);

			      if (strcmp (name, "FUN") == 0)
				{
				  /* Hit another function entry.  */
				  if (function_adjusted)
				    {
				      /* Adjust the value.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				    }

				  /* And then bale out.  */
				  break;
				}

			      if (strcmp (name, "SLINE") == 0)
				{
				  /* Got a line entry.  */
				  if ((baseaddr + addr) <= (symval + value))
				    {
				      /* Adjust the line entry.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				      function_adjusted = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

  /* When adding an instruction back it is sometimes necessary to move any
     global or local symbol that was referencing the first instruction of
     the moved block to refer to the first instruction of the inserted block.

     For example adding a PAGE instruction before a CALL or JMP requires
     that any label on the CALL or JMP is moved to the PAGE insn.  */
  addr += noadj;

  /* Adjust the local symbols defined in this section.  */
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
    {
      if (isym->st_shndx == shndx
	  && addr <= isym->st_value
	  && isym->st_value < endaddr)
	isym->st_value += count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
	{
          if (addr <= sym_hash->root.u.def.value
              && sym_hash->root.u.def.value < endaddr)
	    sym_hash->root.u.def.value += count;
	}
    }

  return;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
ip2k_elf_relax_delete_bytes (bfd *abfd,
			     asection *sec,
			     bfd_vma addr,
			     int count)
{
  bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;
  bfd_vma endaddr = sec->size;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   endaddr - addr - count);

  sec->size -= count;

  adjust_all_relocations (abfd, sec, addr + count, endaddr, -count, 0);
  return TRUE;
}

static bfd_boolean
ip2k_delete_page_insn (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *sec,
		       Elf_Internal_Rela *irel,
		       bfd_boolean *again,
		       struct misc *misc)
{
  /* Note that we've changed the relocs, section contents, etc.  */
  elf_section_data (sec)->relocs = misc->irelbase;
  elf_section_data (sec)->this_hdr.contents = misc->contents;
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

  /* Fix the relocation's type.  */
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_IP2K_NONE);

  /* Delete the PAGE insn.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
    return FALSE;

  /* Modified => will need to iterate relaxation again.  */
  *again = TRUE;

  return TRUE;
}

static bfd_boolean
ip2k_relax_switch_table_128 (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *sec,
			     Elf_Internal_Rela *irel,
			     bfd_boolean *again,
			     struct misc *misc)
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[4];
  bfd_vma addr;

  /* Test all page instructions.  */
  addr = irel->r_offset;
  while (1)
    {
      if (addr + 4 > sec->size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (ireltest->r_offset != addr)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (! ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
    }

  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 4, code);
  if ((! IS_ADD_W_WREG_OPCODE (code + 0))
      || (! IS_ADD_PCL_W_OPCODE (code + 2)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }

  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset - 4, 2))
    return FALSE;

  *again = TRUE;

  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
    }

  return TRUE;
}

static bfd_boolean
ip2k_relax_switch_table_256 (bfd *abfd ATTRIBUTE_UNUSED,
			     asection *sec,
			     Elf_Internal_Rela *irel,
			     bfd_boolean *again,
			     struct misc *misc)
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[12];
  bfd_vma addr;

  /* Test all page instructions.  */
  addr = irel->r_offset;

  while (1)
    {
      if (addr + 4 > sec->size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (ireltest->r_offset != addr)
        {
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (!ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
    }

  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 2, code);
  if (IS_PAGE_OPCODE (code))
    addr = irel->r_offset - 16;
  else
    addr = irel->r_offset - 14;

  ip2k_get_mem (abfd, misc->contents + addr, 12, code);
  if ((!IS_ADD_W_WREG_OPCODE (code + 0))
      || (!IS_SNC_OPCODE (code + 2))
      || (!IS_INC_1SP_OPCODE (code + 4))
      || (!IS_ADD_2SP_W_OPCODE (code + 6))
      || (!IS_SNC_OPCODE (code + 8))
      || (!IS_INC_1SP_OPCODE (code + 10)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }

  /* Delete first 3 opcodes.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, addr + 0, 6))
    return FALSE;

  *again = TRUE;

  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
    }

  return TRUE;
}

/* This function handles relaxation of a section in a specific page.  */

static bfd_boolean
ip2k_elf_relax_section_page (bfd *abfd,
			     asection *sec,
			     bfd_boolean *again,
			     struct misc *misc,
			     unsigned long page_start,
			     unsigned long page_end)
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *irel;
  int switch_table_128;
  int switch_table_256;

  /* Walk thru the section looking for relaxation opportunities.  */
  for (irel = misc->irelbase; irel < irelend; irel++)
    {
      if (ELF32_R_TYPE (irel->r_info) != (int) R_IP2K_PAGE3)
	/* Ignore non page instructions.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset < page_start)
	/* Ignore page instructions on earlier page - they have
	   already been processed. Remember that there is code flow
	   that crosses a page boundary.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset > page_end)
	/* Flow beyond end of page => nothing more to do for this page.  */
	return TRUE;

      /* Detect switch tables.  */
      switch_table_128 = ip2k_is_switch_table_128 (abfd, sec, irel->r_offset, misc->contents);
      switch_table_256 = ip2k_is_switch_table_256 (abfd, sec, irel->r_offset, misc->contents);

      if ((switch_table_128 > 0) || (switch_table_256 > 0))
	/* If the index is greater than 0 then it has already been processed.  */
	continue;

      if (switch_table_128 == 0)
	{
	  if (!ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc))
	    return FALSE;

	  continue;
	}

      if (switch_table_256 == 0)
	{
	  if (!ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc))
	    return FALSE;

	  continue;
	}

      /* Simple relax.  */
      if (ip2k_test_page_insn (abfd, sec, irel, misc))
	{
	  if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	    return FALSE;

	  continue;
	}
    }

  return TRUE;
}

/* This function handles relaxing for the ip2k.

   Principle: Start with the first page and remove page instructions that
   are not require on this first page. By removing page instructions more
   code will fit into this page - repeat until nothing more can be achieved
   for this page. Move on to the next page.

   Processing the pages one at a time from the lowest page allows a removal
   only policy to be used - pages can be removed but are never reinserted.  */

static bfd_boolean
ip2k_elf_relax_section (bfd *abfd,
			asection *sec,
			struct bfd_link_info *link_info,
			bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  static asection * first_section = NULL;
  static unsigned long search_addr;
  static unsigned long page_start = 0;
  static unsigned long page_end = 0;
  static unsigned int pass = 0;
  static bfd_boolean new_pass = FALSE;
  static bfd_boolean changed = FALSE;
  struct misc misc;

  /* Assume nothing changes.  */
  *again = FALSE;

  if (first_section == NULL)
    {
      ip2k_relaxed = TRUE;
      first_section = sec;
    }

  if (first_section == sec)
    {
      pass++;
      new_pass = TRUE;
    }

  /* We don't have to do anything for a relocatable link,
     if this section does not have relocs, or if this is
     not a code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  /* Get section contents cached copy if it exists.  */
  if (contents == NULL)
    {
      /* Get cached copy if it exists.  */
      if (elf_section_data (sec)->this_hdr.contents != NULL)
	contents = elf_section_data (sec)->this_hdr.contents;
      else
	{
	  /* Go get them off disk.  */
	  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}
    }

  /* Read this BFD's symbols cached copy if it exists.  */
  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
    {
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
    }

  misc.symtab_hdr = symtab_hdr;
  misc.isymbuf = isymbuf;
  misc.irelbase = internal_relocs;
  misc.contents = contents;

  /* This is where all the relaxation actually get done.  */
  if ((pass == 1) || (new_pass && !changed))
    {
      /* On the first pass we simply search for the lowest page that
         we havn't relaxed yet. Note that the pass count is reset
         each time a page is complete in order to move on to the next page.
         If we can't find any more pages then we are finished.  */
      if (new_pass)
	{
	  pass = 1;
	  new_pass = FALSE;
	  changed = TRUE; /* Pre-initialize to break out of pass 1.  */
	  search_addr = 0xFFFFFFFF;
	}

      if ((BASEADDR (sec) + sec->size < search_addr)
	  && (BASEADDR (sec) + sec->size > page_end))
	{
	  if (BASEADDR (sec) <= page_end)
	    search_addr = page_end + 1;
	  else
	    search_addr = BASEADDR (sec);

	  /* Found a page => more work to do.  */
	  *again = TRUE;
	}
    }
  else
    {
      if (new_pass)
	{
	  new_pass = FALSE;
	  changed = FALSE;
	  page_start = PAGENO (search_addr);
	  page_end = page_start | 0x00003FFF;
	}

      /* Only process sections in range.  */
      if ((BASEADDR (sec) + sec->size >= page_start)
	  && (BASEADDR (sec) <= page_end))
	{
          if (!ip2k_elf_relax_section_page (abfd, sec, &changed, &misc, page_start, page_end))
	    return FALSE;
	}
      *again = TRUE;
    }

  /* Perform some house keeping after relaxing the section.  */

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	symtab_hdr->contents = (unsigned char *) isymbuf;
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* Set the howto pointer for a IP2K ELF reloc.  */

static void
ip2k_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
			 arelent * cache_ptr,
			 Elf_Internal_Rela * dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  cache_ptr->howto = & ip2k_elf_howto_table [r_type];
}

/* Perform a single relocation.
   By default we use the standard BFD routines.  */

static bfd_reloc_status_type
ip2k_final_link_relocate (reloc_howto_type *  howto,
			  bfd *               input_bfd,
			  asection *          input_section,
			  bfd_byte *          contents,
			  Elf_Internal_Rela * rel,
			  bfd_vma             relocation)
{
  static bfd_vma page_addr = 0;

  bfd_reloc_status_type r = bfd_reloc_ok;
  switch (howto->type)
    {
      /* Handle data space relocations.  */
    case R_IP2K_FR9:
    case R_IP2K_BANK:
      if ((relocation & IP2K_DATA_MASK) == IP2K_DATA_VALUE)
	relocation &= ~IP2K_DATA_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_LO8DATA:
    case R_IP2K_HI8DATA:
    case R_IP2K_EX8DATA:
      break;

      /* Handle insn space relocations.  */
    case R_IP2K_PAGE3:
      page_addr = BASEADDR (input_section) + rel->r_offset;
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_ADDR16CJP:
      if (BASEADDR (input_section) + rel->r_offset != page_addr + 2)
	{
	  /* No preceding page instruction, verify that it isn't needed.  */
	  if (PAGENO (relocation + rel->r_addend) !=
	      ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset, contents))
	    _bfd_error_handler (_("ip2k linker: missing page instruction at 0x%08lx (dest = 0x%08lx)."),
				BASEADDR (input_section) + rel->r_offset,
				relocation + rel->r_addend);
        }
      else if (ip2k_relaxed)
        {
          /* Preceding page instruction. Verify that the page instruction is
             really needed. One reason for the relaxation to miss a page is if
             the section is not marked as executable.  */
	  if (!ip2k_is_switch_table_128 (input_bfd, input_section,
					 rel->r_offset - 2, contents)
	      && !ip2k_is_switch_table_256 (input_bfd, input_section,
					    rel->r_offset - 2, contents)
	      && (PAGENO (relocation + rel->r_addend) ==
		  ip2k_nominal_page_bits (input_bfd, input_section,
					  rel->r_offset - 2, contents)))
	    _bfd_error_handler (_("ip2k linker: redundant page instruction at 0x%08lx (dest = 0x%08lx)."),
				page_addr,
				relocation + rel->r_addend);
        }
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_LO8INSN:
    case R_IP2K_HI8INSN:
    case R_IP2K_PC_SKIP:
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_16:
      /* If this is a relocation involving a TEXT
	 symbol, reduce it to a word address.  */
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	howto = &ip2k_elf_howto_table[ (int) R_IP2K_TEXT];
      break;

      /* Pass others through.  */
    default:
      break;
    }

  /* Only install relocation if above tests did not disqualify it.  */
  if (r == bfd_reloc_ok)
    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				  contents, rel->r_offset,
				  relocation, rel->r_addend);

  return r;
}

/* Relocate a IP2K ELF section.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
ip2k_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;

      r_type = ELF32_R_TYPE (rel->r_info);
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto  = ip2k_elf_howto_table + r_type;
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = BASEADDR (sec) + sym->st_value;

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      /* Finally, the sole IP2K-specific part.  */
      r = ip2k_final_link_relocate (howto, input_bfd, input_section,
				     contents, rel, relocation);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	      /* This is how ip2k_final_link_relocate tells us of a non-kosher
                 reference between insn & data address spaces.  */
	    case bfd_reloc_notsupported:
              if (sym != NULL) /* Only if it's not an unresolved symbol.  */
	         msg = _("unsupported relocation between data/insn address spaces");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

#define TARGET_BIG_SYM	 bfd_elf32_ip2k_vec
#define TARGET_BIG_NAME  "elf32-ip2k"

#define ELF_ARCH	 bfd_arch_ip2k
#define ELF_MACHINE_CODE EM_IP2K
#define ELF_MACHINE_ALT1 EM_IP2K_OLD
#define ELF_MAXPAGESIZE  1 /* No pages on the IP2K.  */

#define elf_info_to_howto_rel			NULL
#define elf_info_to_howto			ip2k_info_to_howto_rela

#define elf_backend_can_gc_sections     	1
#define elf_backend_rela_normal			1
#define elf_backend_relocate_section		ip2k_elf_relocate_section

#define elf_symbol_leading_char			'_'
#define bfd_elf32_bfd_reloc_type_lookup		ip2k_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup	ip2k_reloc_name_lookup
#define bfd_elf32_bfd_relax_section		ip2k_elf_relax_section

#include "elf32-target.h"
@


1.30
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d351 1
a351 1
  
d361 1
a361 1
  
d431 1
a431 1
  
d440 1
a440 1
  
d467 1
a467 1
      
d661 1
a661 1
		  
d665 1
a665 1
		  
d674 1
a674 1
		      
d680 1
a680 1
		      stabp = stabcontents + irel->r_offset - 8; 
d685 1
a685 1
		      
d687 1
a687 1
		      
d713 1
a713 1
				  
d822 1
a822 1
	
d825 1
a825 1
  
d840 1
a840 1
  
d911 1
a911 1
  
d998 1
a998 1
  
@


1.29
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1441 1
a1441 1
					 rel, relend, howto, contents);
@


1.28
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010
d1439 1
a1439 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.28.6.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1439 1
a1439 1
      if (sec != NULL && discarded_section (sec))
@


1.27
log
@fix set but unused variable warnings
@
text
@d1440 2
a1441 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.26
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
a579 1
  bfd_byte *contents;
a590 2
  contents = elf_section_data (sec)->this_hdr.contents;

d669 1
a669 3
		      unsigned long strx;
		      unsigned char type, other;
		      unsigned short desc;
a682 1
		      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
a683 2
		      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
		      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
a700 1
			      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
a701 2
			      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
			      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
a1080 1
  asection *stab;
a1112 12
  /* Make sure the stac.rela stuff gets read in.  */
  stab = bfd_get_section_by_name (abfd, ".stab");

  if (stab)
    {
      /* So stab does exits.  */
      Elf_Internal_Rela * irelbase;

      irelbase = _bfd_elf_link_read_relocs (abfd, stab, NULL, NULL,
					    link_info->keep_memory);
    }

d1411 1
a1411 1
      howto  = ip2k_elf_howto_table + ELF32_R_TYPE (rel->r_info);
@


1.25
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d350 1
a350 1
  int index = 0;
d372 1
a372 1
	return index;
d378 1
a378 1
      index++;
d430 1
a430 1
  int index = 0;
d457 1
a457 1
	return index;
d466 1
a466 1
	return index;
d472 1
a472 1
      index++;
@


1.24
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.23
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.22
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d226 15
d1547 1
@


1.21
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
a1401 3
  if (info->relocatable)
    return TRUE;

a1417 1
      /* This is a final link.  */
d1448 14
@


1.20
log
@Update function declarations to ISO C90 formatting
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
a1504 47
static asection *
ip2k_elf_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
      {
      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

          default:
            break;
          }
       }
     }
   else
     {
       if (!(elf_bad_symtab (sec->owner)
	     && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	   && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		 && sym->st_shndx != SHN_COMMON))
	 return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
      }
  return NULL;
}

static bfd_boolean
ip2k_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* We don't use got and plt entries for ip2k.  */
  return TRUE;
}

a1517 2
#define elf_backend_gc_mark_hook                ip2k_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook               ip2k_elf_gc_sweep_hook
@


1.19
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a42 47
  
/* Prototypes.  */
static reloc_howto_type *ip2k_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static int ip2k_is_opcode
  PARAMS ((bfd_byte *, const struct ip2k_opcode *));
static bfd_vma symbol_value
  PARAMS ((bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *,
	   Elf_Internal_Rela *));
static void ip2k_get_mem
  PARAMS ((bfd *, bfd_byte *, int, bfd_byte *));
static bfd_vma ip2k_nominal_page_bits
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_test_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static bfd_boolean ip2k_delete_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_128
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_128
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_256
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_256
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static bfd_boolean ip2k_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean ip2k_elf_relax_section_page
  PARAMS ((bfd *, asection *, bfd_boolean *, struct misc *, unsigned long, unsigned long));
static void adjust_all_relocations
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int, int));
static bfd_boolean ip2k_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
static void ip2k_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_reloc_status_type ip2k_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean ip2k_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static asection *ip2k_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ip2k_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d48 1
a48 1
  {0x0010, 0xFFF8},	/* page */
d57 1
a57 1
  {0xE000, 0xE000},	/* jmp */
d66 1
a66 1
  {0xA00B, 0xFFFF},	/* snc */
d75 1
a75 1
  {0x2B81, 0xFFFF},	/* inc 1(SP) */
d84 1
a84 1
  {0x1F82, 0xFFFF},	/* add 2(SP),w */
d93 2
a94 2
  {0x1C0A, 0xFFFF},	/* add w,wreg */
  {0x1E0A, 0xFFFF},	/* add wreg,w */
d103 1
a103 1
  {0x1E09, 0xFFFF},	/* add pcl,w */
d177 1
d179 2
a180 3
ip2k_reloc_type_lookup (abfd, code)
     bfd * abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d227 4
a230 5
ip2k_get_mem (abfd, addr, length, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_byte *addr;
     int length;
     bfd_byte *ptr;
d237 1
a237 3
ip2k_is_opcode (code, opcodes)
     bfd_byte *code;
     const struct ip2k_opcode *opcodes;
d260 4
a263 5
symbol_value (abfd, symtab_hdr, isymbuf, irel)
     bfd *abfd;
     Elf_Internal_Shdr *symtab_hdr;
     Elf_Internal_Sym *isymbuf;
     Elf_Internal_Rela *irel;
a298 109
/* Returns the expected page state for the given instruction not including
   the effect of page instructions.  */

static bfd_vma
ip2k_nominal_page_bits (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma addr;
     bfd_byte *contents;
{
  bfd_vma page = PAGENO (BASEADDR (sec) + addr);

  /* Check if section flows into this page. If not then the page
     bits are assumed to match the PC. This will be true unless
     the user has a page instruction without a call/jump, in which
     case they are on their own.  */
  if (PAGENO (BASEADDR (sec)) == page)
    return page;

  /* Section flows across page boundary. The page bits should match
     the PC unless there is a possible flow from the previous page,
     in which case it is not possible to determine the value of the
     page bits.  */
  while (PAGENO (BASEADDR (sec) + addr - 2) == page)
    {
      bfd_byte code[2];

      addr -= 2;
      ip2k_get_mem (abfd, contents + addr, 2, code);
      if (!IS_PAGE_OPCODE (code))
	continue;

      /* Found a page instruction, check if jump table.  */
      if (ip2k_is_switch_table_128 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      if (ip2k_is_switch_table_256 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      /* Found a page instruction, check if conditional.  */
      if (addr >= 2)
        {
	  ip2k_get_mem (abfd, contents + addr - 2, 2, code);
          if (IS_SKIP_OPCODE (code))
	    /* Page is conditional.  */
	    continue;
        }

      /* Unconditional page instruction => page bits should be correct.  */
      return page;
    }

  /* Flow from previous page => page bits are impossible to determine.  */
  return 0;
}

static bfd_boolean
ip2k_test_page_insn (abfd, sec, irel, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     struct misc *misc;
{
  bfd_vma symval;

  /* Get the value of the symbol referred to by the reloc.  */
  symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf, irel);
  if (symval == UNDEFINED_SYMBOL)
    /* This appears to be a reference to an undefined
       symbol.  Just ignore it--it will be caught by the
       regular reloc processing.  */
    return FALSE;

  /* Test if we can delete this page instruction.  */
  if (PAGENO (symval + irel->r_addend) !=
      ip2k_nominal_page_bits (abfd, sec, irel->r_offset, misc->contents))
    return FALSE;

  return TRUE;
}

static bfd_boolean
ip2k_delete_page_insn (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  /* Note that we've changed the relocs, section contents, etc.  */
  elf_section_data (sec)->relocs = misc->irelbase;
  elf_section_data (sec)->this_hdr.contents = misc->contents;
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

  /* Fix the relocation's type.  */
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_IP2K_NONE);

  /* Delete the PAGE insn.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
    return FALSE;
	
  /* Modified => will need to iterate relaxation again.  */
  *again = TRUE;
  
  return TRUE;
}

d329 4
a332 5
ip2k_is_switch_table_128 (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma addr;
     bfd_byte *contents;
a367 72
static bfd_boolean
ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[4];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;
  while (1)
    {
      if (addr + 4 > sec->size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (ireltest->r_offset != addr)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (! ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
    }

  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 4, code);
  if ((! IS_ADD_W_WREG_OPCODE (code + 0))
      || (! IS_ADD_PCL_W_OPCODE (code + 2)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }

  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset - 4, 2))
    return FALSE;

  *again = TRUE;

  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
    }

  return TRUE;
}

d409 4
a412 5
ip2k_is_switch_table_256 (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma addr;
     bfd_byte *contents;
d462 8
a469 7
static bfd_boolean
ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
d471 8
a478 7
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[12];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;
d480 5
a484 1
  while (1)
d486 1
a486 2
      if (addr + 4 > sec->size)
	break;
d488 4
a491 1
      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
d493 4
a496 3
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;
d498 3
a500 7
      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d502 2
a503 1
      if (ireltest->r_offset != addr)
d505 4
a508 2
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
d511 2
a512 6
      if (!ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
d515 3
a517 6
  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 2, code);
  if (IS_PAGE_OPCODE (code))
    addr = irel->r_offset - 16;
  else
    addr = irel->r_offset - 14;
d519 7
a525 11
  ip2k_get_mem (abfd, misc->contents + addr, 12, code);
  if ((!IS_ADD_W_WREG_OPCODE (code + 0))
      || (!IS_SNC_OPCODE (code + 2))
      || (!IS_INC_1SP_OPCODE (code + 4))
      || (!IS_ADD_2SP_W_OPCODE (code + 6))
      || (!IS_SNC_OPCODE (code + 8))
      || (!IS_INC_1SP_OPCODE (code + 10)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }
d527 6
a532 2
  /* Delete first 3 opcodes.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, addr + 0, 6))
d535 4
a538 9
  *again = TRUE;

  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
    }
d543 1
a543 1
/* This function handles relaxing for the ip2k.
d545 6
a550 4
   Principle: Start with the first page and remove page instructions that
   are not require on this first page. By removing page instructions more
   code will fit into this page - repeat until nothing more can be achieved
   for this page. Move on to the next page.
d552 1
a552 2
   Processing the pages one at a time from the lowest page allows a removal
   only policy to be used - pages can be removed but are never reinserted.  */
d554 7
a560 6
static bfd_boolean
ip2k_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d563 7
a569 11
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  static asection * first_section = NULL;
  static unsigned long search_addr;
  static unsigned long page_start = 0;
  static unsigned long page_end = 0;
  static unsigned int pass = 0;
  static bfd_boolean new_pass = FALSE;
  static bfd_boolean changed = FALSE;
  struct misc misc;
d572 174
a745 2
  /* Assume nothing changes.  */
  *again = FALSE;
d747 3
a749 1
  if (first_section == NULL)
d751 4
a754 2
      ip2k_relaxed = TRUE;
      first_section = sec;
d757 6
a762 1
  if (first_section == sec)
d764 10
a773 2
      pass++;
      new_pass = TRUE;
d776 23
a798 8
  /* We don't have to do anything for a relocatable link,
     if this section does not have relocs, or if this is
     not a code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;
d800 11
a810 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d812 2
a813 5
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL,
					       (Elf_Internal_Rela *)NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;
d815 9
a823 2
  /* Make sure the stac.rela stuff gets read in.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
d825 15
a839 1
  if (stab)
d841 25
a865 2
      /* So stab does exits.  */
      Elf_Internal_Rela * irelbase;
d867 2
a868 3
      irelbase = _bfd_elf_link_read_relocs (abfd, stab, NULL,
					    (Elf_Internal_Rela *)NULL,
					    link_info->keep_memory);
d871 4
a874 2
  /* Get section contents cached copy if it exists.  */
  if (contents == NULL)
d876 2
a877 9
      /* Get cached copy if it exists.  */
      if (elf_section_data (sec)->this_hdr.contents != NULL)
	contents = elf_section_data (sec)->this_hdr.contents;
      else
	{
	  /* Go get them off disk.  */
	  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}
d880 7
a886 2
  /* Read this BFD's symbols cached copy if it exists.  */
  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d888 3
a890 7
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
d893 17
a909 4
  misc.symtab_hdr = symtab_hdr;
  misc.isymbuf = isymbuf;
  misc.irelbase = internal_relocs;
  misc.contents = contents;
d911 1
a911 2
  /* This is where all the relaxation actually get done.  */
  if ((pass == 1) || (new_pass && !changed))
d913 22
a934 11
      /* On the first pass we simply search for the lowest page that
         we havn't relaxed yet. Note that the pass count is reset
         each time a page is complete in order to move on to the next page.
         If we can't find any more pages then we are finished.  */
      if (new_pass)
	{
	  pass = 1;
	  new_pass = FALSE;
	  changed = TRUE; /* Pre-initialize to break out of pass 1.  */
	  search_addr = 0xFFFFFFFF;
	}
d936 3
a938 7
      if ((BASEADDR (sec) + sec->size < search_addr)
	  && (BASEADDR (sec) + sec->size > page_end))
	{
	  if (BASEADDR (sec) <= page_end)
	    search_addr = page_end + 1;
	  else
	    search_addr = BASEADDR (sec);
d940 2
a941 3
	  /* Found a page => more work to do.  */
	  *again = TRUE;
	}
d943 5
d949 9
d959 2
a960 16
      if (new_pass)
	{
	  new_pass = FALSE;
	  changed = FALSE;
	  page_start = PAGENO (search_addr);
	  page_end = page_start | 0x00003FFF;
	}

      /* Only process sections in range.  */
      if ((BASEADDR (sec) + sec->size >= page_start)
	  && (BASEADDR (sec) <= page_end))
	{
          if (!ip2k_elf_relax_section_page (abfd, sec, &changed, &misc, page_start, page_end))
	    return FALSE;
	}
      *again = TRUE;
d963 3
a965 1
  /* Perform some house keeping after relaxing the section.  */
d967 1
a967 8
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	symtab_hdr->contents = (unsigned char *) isymbuf;
    }
d969 2
a970 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d972 3
a974 7
      if (! link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
a976 4
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

a977 12

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
d983 6
a988 7
ip2k_elf_relax_section_page (abfd, sec, again, misc, page_start, page_end)
     bfd *abfd;
     asection *sec;
     bfd_boolean *again;
     struct misc *misc;
     unsigned long page_start;
     unsigned long page_end;
d1049 1
a1049 1
/* Parts of a Stabs entry.  */
d1051 4
a1054 6
#define STRDXOFF  (0)
#define TYPEOFF   (4)
#define OTHEROFF  (5)
#define DESCOFF   (6)
#define VALOFF    (8)
#define STABSIZE  (12)
d1056 2
a1057 1
/* Adjust all the relocations entries after adding or inserting instructions.  */
d1059 5
a1063 8
static void
adjust_all_relocations (abfd, sec, addr, endaddr, count, noadj)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     bfd_vma endaddr;
     int count;
     int noadj;
d1066 11
a1076 7
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
  unsigned int shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend, *irelbase;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
d1079 2
a1080 2
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1082 5
a1086 1
  shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
d1088 1
a1088 6
  contents = elf_section_data (sec)->this_hdr.contents;

  irelbase = elf_section_data (sec)->relocs;
  irelend = irelbase + sec->reloc_count;

  for (irel = irelbase; irel < irelend; irel++)
d1090 3
a1092 6
      if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
        {
          /* Get the value of the symbol referred to by the reloc.  */
          if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
            {
              asection *sym_sec;
d1094 8
a1101 3
              /* A local symbol.  */
	      isym = isymbuf + ELF32_R_SYM (irel->r_info);
              sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1103 1
a1103 5
              if (isym->st_shndx == shndx)
                {
                  bfd_vma baseaddr = BASEADDR (sec);
                  bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
                                   + irel->r_addend;
d1105 4
a1108 6
                  if ((baseaddr + addr + noadj) <= symval
                      && symval < (baseaddr + endaddr))
                    irel->r_addend += count;
                }
            }
        }
d1110 2
a1111 4
      /* Do this only for PC space relocations.  */
      if (addr <= irel->r_offset && irel->r_offset < endaddr)
        irel->r_offset += count;
    }
a1112 2
  /* Now fix the stab relocations.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
d1115 2
a1116 2
      bfd_byte *stabcontents, *stabend, *stabp;
      bfd_size_type stab_size = stab->rawsize ? stab->rawsize : stab->size;
d1118 3
a1120 2
      irelbase = elf_section_data (stab)->relocs;
      irelend = irelbase + stab->reloc_count;
d1122 6
a1127 3
      /* Pull out the contents of the stab section.  */
      if (elf_section_data (stab)->this_hdr.contents != NULL)
	stabcontents = elf_section_data (stab)->this_hdr.contents;
d1130 5
a1134 6
	  if (!bfd_malloc_and_get_section (abfd, stab, &stabcontents))
	    {
	      if (stabcontents != NULL)
		free (stabcontents);
	      return;
	    }
d1136 11
a1146 3
	  /* We need to remember this.  */
	  elf_section_data (stab)->this_hdr.contents = stabcontents;
	}
d1148 4
a1151 1
      stabend = stabcontents + stab_size;
d1153 8
a1160 1
      for (irel = irelbase; irel < irelend; irel++)
d1162 5
a1166 25
	  if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
	    {
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
		{
		  asection *sym_sec;
		  
		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);
		  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  
		  if (sym_sec == sec)
		    {
		      const char *name;
		      unsigned long strx;
		      unsigned char type, other;
		      unsigned short desc;
		      bfd_vma value;
		      bfd_vma baseaddr = BASEADDR (sec);
		      bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
			+ irel->r_addend;
		      
		      if ((baseaddr + addr) <= symval
			  && symval <= (baseaddr + endaddr))
			irel->r_addend += count;
d1168 7
a1174 2
		      /* Go hunt up a function and fix its line info if needed.  */
		      stabp = stabcontents + irel->r_offset - 8; 
d1176 13
a1188 12
		      /* Go pullout the stab entry.  */
		      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
		      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
		      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
		      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
		      value = bfd_h_get_32 (abfd, stabp + VALOFF);
		      
		      name = bfd_get_stab_name (type);
		      
		      if (strcmp (name, "FUN") == 0)
			{
			  int function_adjusted = 0;
d1190 6
a1195 51
			  if (symval > (baseaddr + addr))
			    /* Not in this function.  */
			    continue;

			  /* Hey we got a function hit.  */
			  stabp += STABSIZE;
			  for (;stabp < stabend; stabp += STABSIZE)
			    {
			      /* Go pullout the stab entry.  */
			      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
			      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
			      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
			      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
			      value = bfd_h_get_32 (abfd, stabp + VALOFF);

			      name = bfd_get_stab_name (type);

			      if (strcmp (name, "FUN") == 0)
				{
				  /* Hit another function entry.  */
				  if (function_adjusted)
				    {
				      /* Adjust the value.  */
				      value += count;
				  
				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				    }

				  /* And then bale out.  */
				  break;
				}

			      if (strcmp (name, "SLINE") == 0)
				{
				  /* Got a line entry.  */
				  if ((baseaddr + addr) <= (symval + value))
				    {
				      /* Adjust the line entry.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				      function_adjusted = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
d1197 1
d1200 1
a1200 3
  /* When adding an instruction back it is sometimes necessary to move any
     global or local symbol that was referencing the first instruction of
     the moved block to refer to the first instruction of the inserted block.
d1202 2
a1203 7
     For example adding a PAGE instruction before a CALL or JMP requires
     that any label on the CALL or JMP is moved to the PAGE insn.  */
  addr += noadj;

  /* Adjust the local symbols defined in this section.  */
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
d1205 4
a1208 4
      if (isym->st_shndx == shndx
	  && addr <= isym->st_value
	  && isym->st_value < endaddr)
	isym->st_value += count;
d1211 2
a1212 6
    /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
d1214 3
a1216 5
      struct elf_link_hash_entry *sym_hash = *sym_hashes;

      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
d1218 2
a1219 3
          if (addr <= sym_hash->root.u.def.value
              && sym_hash->root.u.def.value < endaddr)
	    sym_hash->root.u.def.value += count;
d1223 3
a1225 2
  return;
}
d1227 1
a1227 1
/* Delete some bytes from a section while relaxing.  */
d1229 11
a1239 18
static bfd_boolean
ip2k_elf_relax_delete_bytes (abfd, sec, addr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     int count;
{
  bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;
  bfd_vma endaddr = sec->size;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count,
	   endaddr - addr - count);

  sec->size -= count;

  adjust_all_relocations (abfd, sec, addr + count, endaddr, -count, 0);
  return TRUE;
a1241 5
/* -------------------------------------------------------------------- */

/* XXX: The following code is the result of a cut&paste.  This unfortunate
   practice is very widespread in the various target back-end files.  */

d1245 3
a1247 4
ip2k_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd * abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf_Internal_Rela * dst;
d1252 1
a1252 6
  switch (r_type)
    {
    default:
      cache_ptr->howto = & ip2k_elf_howto_table [r_type];
      break;
    }
d1259 6
a1264 8
ip2k_final_link_relocate (howto, input_bfd, input_section, contents, rel,
			  relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
d1310 7
a1316 5
	  if (!ip2k_is_switch_table_128 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      !ip2k_is_switch_table_256 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      (PAGENO (relocation + rel->r_addend) ==
	       ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset - 2, contents)))
d1388 8
a1395 10
ip2k_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1458 1
a1458 1
	  const char * msg = (const char *) NULL;
d1506 5
a1510 6
ip2k_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1543 4
a1546 5
ip2k_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
@


1.18
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.17
log
@update copyright dates
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@(ip2k_call_opcode, IS_CALL_OPCODE): Remove unused structure and macro.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.15
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@a108 9
static const struct ip2k_opcode ip2k_call_opcode[] =
{
  {0xC000, 0xE000},	/* call */
  {0x0000, 0x0000},
};

#define IS_CALL_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_call_opcode)

@


1.14
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a1600 6
#if 0
      case R_IP2K_GNU_VTINHERIT:
      case R_IP2K_GNU_VTENTRY:
        break;
#endif

@


1.13
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1548 2
a1549 2
		(info, name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
@


1.12
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d506 1
a506 1
  if (addr + 4 > sec->_cooked_size)
d553 1
a553 1
      if (addr + 4 > sec->_cooked_size)
d659 1
a659 1
  if (addr + 4 > sec->_cooked_size)
d721 1
a721 1
      if (addr + 4 > sec->_cooked_size)
a842 5
  /* If this is the first time we have been called
      for this section, initialise the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d873 1
a873 6
	  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	  if (contents == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, sec, contents,
					  (file_ptr) 0, sec->_raw_size))
d910 2
a911 2
      if ((BASEADDR (sec) + sec->_cooked_size < search_addr)
	  && (BASEADDR (sec) + sec->_cooked_size > page_end))
d933 1
a933 1
      if ((BASEADDR (sec) + sec->_cooked_size >= page_start)
d1130 1
d1140 6
a1145 7
	  stabcontents = (bfd_byte *) bfd_alloc (abfd, stab->_raw_size);
	  if (stabcontents == NULL)
	    return;

	  if (! bfd_get_section_contents (abfd, stab, stabcontents,
					  (file_ptr) 0, stab->_raw_size))
	    return;
d1151 1
a1151 1
      stabend = stabcontents + stab->_raw_size;
d1301 1
a1301 1
  bfd_vma endaddr = sec->_cooked_size;
d1307 1
a1307 1
  sec->_cooked_size -= count;
@


1.11
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1538 4
a1541 1
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
@


1.11.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1538 1
a1538 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.11.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1538 1
a1538 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.11.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d506 1
a506 1
  if (addr + 4 > sec->size)
d553 1
a553 1
      if (addr + 4 > sec->size)
d659 1
a659 1
  if (addr + 4 > sec->size)
d721 1
a721 1
      if (addr + 4 > sec->size)
d843 5
d878 6
a883 1
	  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d920 2
a921 2
      if ((BASEADDR (sec) + sec->size < search_addr)
	  && (BASEADDR (sec) + sec->size > page_end))
d943 1
a943 1
      if ((BASEADDR (sec) + sec->size >= page_start)
a1139 1
      bfd_size_type stab_size = stab->rawsize ? stab->rawsize : stab->size;
d1149 7
a1155 6
	  if (!bfd_malloc_and_get_section (abfd, stab, &stabcontents))
	    {
	      if (stabcontents != NULL)
		free (stabcontents);
	      return;
	    }
d1161 1
a1161 1
      stabend = stabcontents + stab_size;
d1311 1
a1311 1
  bfd_vma endaddr = sec->size;
d1317 1
a1317 1
  sec->size -= count;
@


1.10
log
@Better handking for unresolved symbols
@
text
@d1010 1
a1010 1
  /* Walk thru the section looking for relaxation opertunities.  */
d1391 1
a1391 1
	  /* No preceeding page instruction, verify that it isn't needed.  */
d1401 1
a1401 1
          /* Preceeding page instruction. Verify that the page instruction is
@


1.9
log
@Correct spelling of "relocatable".
@
text
@d1535 2
a1536 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d1538 1
a1538 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a1540 20

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = h->root.u.def.value + BASEADDR (sec);
	    }

	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;

	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		     (! info->shared || info->no_undefined))))
		return FALSE;
	      relocation = 0;
	    }
@


1.8
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d837 1
a837 1
  if (link_info->relocateable
d1459 1
a1459 1
   necessary, and (if using Rela relocs and generating a relocateable
d1473 1
a1473 1
   When generating relocateable output, this function must handle
d1496 1
a1496 1
  if (info->relocateable)
@


1.7
log
@oops - omitted from previous delta - a reworking of the linker relaxation code.
@
text
@d850 3
a852 3
  internal_relocs = _bfd_elf32_link_read_relocs (abfd, sec, NULL,
						 (Elf_Internal_Rela *)NULL,
						 link_info->keep_memory);
d864 3
a866 3
      irelbase = _bfd_elf32_link_read_relocs (abfd, stab, NULL,
					      (Elf_Internal_Rela *)NULL,
					      link_info->keep_memory);
@


1.7.20.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d850 3
a852 3
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL,
					       (Elf_Internal_Rela *)NULL,
					       link_info->keep_memory);
d864 3
a866 3
      irelbase = _bfd_elf_link_read_relocs (abfd, stab, NULL,
					    (Elf_Internal_Rela *)NULL,
					    link_info->keep_memory);
@


1.6
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d36 6
d45 2
a46 8
static void ip2k_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static asection * ip2k_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ip2k_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d50 20
d74 2
a75 20
static bfd_boolean ip2k_elf_relax_add_bytes
  PARAMS ((bfd *, asection *, bfd_vma, const bfd_byte *, int, int));
static bfd_boolean add_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static bfd_boolean ip2k_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean relax_switch_dispatch_tables_pass1
  PARAMS ((bfd *, asection *, bfd_vma, struct misc *));
static bfd_boolean unrelax_dispatch_table_entries
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, bfd_boolean *, struct misc *));
static bfd_boolean unrelax_switch_dispatch_tables_passN
  PARAMS ((bfd *, asection *, bfd_vma, bfd_boolean *, struct misc *));
static bfd_boolean is_switch_128_dispatch_table_p
  PARAMS ((bfd *, bfd_vma, bfd_boolean, struct misc *));
static bfd_boolean is_switch_256_dispatch_table_p
  PARAMS ((bfd *, bfd_vma, bfd_boolean, struct misc *));
static bfd_boolean ip2k_elf_relax_section_pass1
  PARAMS ((bfd *, asection *, bfd_boolean *, struct misc *));
static bfd_boolean ip2k_elf_relax_section_passN
  PARAMS ((bfd *, asection *, bfd_boolean *, bfd_boolean *, struct misc *));
d82 6
d89 1
a89 2
#define IS_OPCODE(CODE0,CODE1,OPCODE) \
  ((CODE0) == (OPCODE)[0] && (CODE1) == (OPCODE)[1])
d91 5
a95 2
#define PAGE_INSN_0		0x00
#define PAGE_INSN_1		0x10
d97 4
a100 1
static const bfd_byte page_opcode[] =
d102 2
a103 1
   PAGE_INSN_0, PAGE_INSN_1
d106 2
a107 5
#define IS_PAGE_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, page_opcode)

#define JMP_INSN_0		0xE0
#define JMP_INSN_1		0x00
d109 1
a109 1
static const bfd_byte jmp_opcode[] =
d111 2
a112 1
   JMP_INSN_0, JMP_INSN_1
d115 2
a116 5
#define IS_JMP_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, jmp_opcode)

#define CALL_INSN_0		0xC0
#define CALL_INSN_1		0x00
d118 1
a118 1
static const bfd_byte call_opcode[] =
d120 2
a121 1
  CALL_INSN_0, CALL_INSN_1
d124 2
a125 2
#define IS_CALL_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, call_opcode)
d127 1
a127 4
#define ADD_PCL_W_INSN_0	0x1E
#define ADD_PCL_W_INSN_1	0x09

static const bfd_byte add_pcl_w_opcode[] =
d129 2
a130 1
  ADD_PCL_W_INSN_0, ADD_PCL_W_INSN_1
d133 2
a134 5
#define IS_ADD_PCL_W_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, add_pcl_w_opcode)

#define ADD_W_WREG_INSN_0	0x1C
#define ADD_W_WREG_INSN_1	0x0A
d136 1
a136 1
static const bfd_byte add_w_wreg_opcode[] =
d138 2
a139 1
  ADD_W_WREG_INSN_0, ADD_W_WREG_INSN_1
d142 2
a143 5
#define IS_ADD_W_WREG_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, add_w_wreg_opcode)

#define SNC_INSN_0		0xA0
#define SNC_INSN_1		0x0B
d145 1
a145 1
static const bfd_byte snc_opcode[] =
d147 3
a149 1
   SNC_INSN_0, SNC_INSN_1
d152 2
a153 2
#define IS_SNC_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, snc_opcode)
d155 1
a155 4
#define INC_1_SP_INSN_0		0x2B
#define INC_1_SP_INSN_1		0x81

static const bfd_byte inc_1_sp_opcode[] =
d157 2
a158 1
   INC_1_SP_INSN_0, INC_1_SP_INSN_1
d161 2
a162 5
#define IS_INC_1_SP_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, inc_1_sp_opcode)

#define ADD_2_SP_W_INSN_0	0x1F
#define ADD_2_SP_W_INSN_1	0x82
d164 1
a164 1
static const bfd_byte add_2_sp_w_opcode[] =
d166 9
a174 1
   ADD_2_SP_W_INSN_0, ADD_2_SP_W_INSN_1
d177 2
a178 2
#define IS_ADD_2_SP_W_OPCODE(CODE0,CODE1) \
  IS_OPCODE (CODE0, CODE1, add_2_sp_w_opcode)
d180 1
a180 1
/* Relocation tables. */
d198 1
a198 1
  /* This reloc does nothing. */
d230 1
a230 1
/* Map BFD reloc types to IP2K ELF reloc types. */
d239 1
a239 1
     include/elf/ip2k.h. */
d274 1
a274 1
      /* Pacify gcc -Wall. */
d280 30
a309 1
#define PAGENO(ABSADDR) ((ABSADDR) & 0x1C000)
d357 109
d495 41
d537 1
a537 1
is_switch_128_dispatch_table_p (abfd, addr, relaxed, misc)
d539 3
a541 2
     bfd_vma addr;
     bfd_boolean relaxed;
d544 30
a573 1
  bfd_byte code0, code1;
d575 3
a577 2
  if (addr < (3 * 2))
    return FALSE;
d579 3
a581 2
  code0 = bfd_get_8 (abfd, misc->contents + addr - 2);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 1);
d583 10
a592 2
  /* Is it ADD PCL,W */
  if (! IS_ADD_PCL_W_OPCODE (code0, code1))
d595 1
a595 6
  code0 = bfd_get_8 (abfd, misc->contents + addr - 4);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 3);

  if (relaxed)
    /* Is it ADD W,WREG  */
    return ! IS_ADD_W_WREG_OPCODE (code0, code1);
d597 2
a598 1
  else
d600 1
a600 2
      /* Is it ADD W,WREG  */
      if (! IS_ADD_W_WREG_OPCODE (code0, code1))
d602 1
a602 7

      code0 = bfd_get_8 (abfd, misc->contents + addr - 6);
      code1 = bfd_get_8 (abfd, misc->contents + addr - 5);

      /* Is it JMP $nnnn  */
      if (! IS_JMP_OPCODE (code0, code1))
        return FALSE;
a604 2
  /* It looks like we've found the prologue for
     a 1-127 entry switch dispatch table.  */
d648 2
a649 2
static bfd_boolean
is_switch_256_dispatch_table_p (abfd, addr, relaxed,  misc)
a650 66
     bfd_vma addr;
     bfd_boolean relaxed;
     struct misc *misc;
{
  bfd_byte code0, code1;

  if (addr < (8 * 2))
    return FALSE;

  code0 = bfd_get_8 (abfd, misc->contents + addr - 2);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 1);

  /* Is it INC 1(SP).  */
  if (! IS_INC_1_SP_OPCODE (code0, code1))
    return FALSE;

  code0 = bfd_get_8 (abfd, misc->contents + addr - 4);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 3);

  /* Is it SNC.  */
  if (! IS_SNC_OPCODE (code0, code1))
    return FALSE;

  code0 = bfd_get_8 (abfd, misc->contents + addr - 6);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 5);

  /* Is it ADD 2(SP),W.  */
  if (! IS_ADD_2_SP_W_OPCODE (code0, code1))
    return FALSE;

  code0 = bfd_get_8 (abfd, misc->contents + addr - 8);
  code1 = bfd_get_8 (abfd, misc->contents + addr - 7);

  if (relaxed)
    /* Is it INC 1(SP).  */
    return ! IS_INC_1_SP_OPCODE (code0, code1);

  else
    {
      /* Is it INC 1(SP).  */
      if (! IS_INC_1_SP_OPCODE (code0, code1))
	return FALSE;

      code0 = bfd_get_8 (abfd, misc->contents + addr - 10);
      code1 = bfd_get_8 (abfd, misc->contents + addr - 9);

      /* Is it SNC.  */
      if (! IS_SNC_OPCODE (code0, code1))
        return FALSE;

      code0 = bfd_get_8 (abfd, misc->contents + addr - 12);
      code1 = bfd_get_8 (abfd, misc->contents + addr - 11);

      /* Is it ADD W,WREG.  */
      if (! IS_ADD_W_WREG_OPCODE (code0, code1))
	return FALSE;
    }

  /* It looks like we've found the prologue for
     a 128-255 entry switch dispatch table.  */
  return TRUE;
}

static bfd_boolean
relax_switch_dispatch_tables_pass1 (abfd, sec, addr, misc)
     bfd *abfd;
d653 1
a653 35
     struct misc *misc;
{
  if (addr + 3 < sec->_cooked_size)
    {
      bfd_byte code0 = bfd_get_8 (abfd, misc->contents + addr + 2);
      bfd_byte code1 = bfd_get_8 (abfd, misc->contents + addr + 3);

      if (IS_JMP_OPCODE (code0, code1)
	  && is_switch_128_dispatch_table_p (abfd, addr, FALSE, misc))
	{
	  /* Delete ADD W,WREG from prologue.  */
	  ip2k_elf_relax_delete_bytes (abfd, sec, addr - (2 * 2), (1 * 2));
	  return TRUE;
	}

      if (IS_JMP_OPCODE (code0, code1)
	  && is_switch_256_dispatch_table_p (abfd, addr, FALSE, misc))
	{
	  /* Delete ADD W,WREG; SNC ; INC 1(SP) from prologue.  */
	  ip2k_elf_relax_delete_bytes (abfd, sec, addr - 6 * 2, 3 * 2);
	  return TRUE;
	}
    }

  return TRUE;
}

static bfd_boolean
unrelax_dispatch_table_entries (abfd, sec, first, last, changed, misc)
     bfd *abfd;
     asection *sec;
     bfd_vma first;
     bfd_vma last;
     bfd_boolean *changed;
     struct misc *misc;
d655 42
a696 1
  bfd_vma addr = first;
d698 2
a699 47
  while (addr < last)
    {
      bfd_byte code0 = bfd_get_8 (abfd, misc->contents + addr);
      bfd_byte code1 = bfd_get_8 (abfd, misc->contents + addr + 1);

      /* We are only expecting to find PAGE or JMP insns
         in the dispatch table. If we find anything else
         something has gone wrong failed the relaxation
         which will cause the link to be aborted.  */

      if (IS_PAGE_OPCODE (code0, code1))
	/* Skip the PAGE and JMP insns.  */
        addr += 4;
      else if (IS_JMP_OPCODE (code0, code1))
         {
            Elf_Internal_Rela * irelend = misc->irelbase
					  + sec->reloc_count;
            Elf_Internal_Rela * irel;

            /* Find the relocation entry.  */
            for (irel = misc->irelbase; irel < irelend; irel++)
               {
                  if (irel->r_offset == addr
                      && ELF32_R_TYPE (irel->r_info) == R_IP2K_ADDR16CJP)
                    {
                      if (! add_page_insn (abfd, sec, irel, misc))
			/* Something has gone wrong.  */
                        return FALSE;

		      *changed = TRUE;
		      break;
                    }
               }

	    /* If we fell off the end something has gone wrong.  */
	    if (irel >= irelend)
	      /* Something has gone wrong.  */
	      return FALSE;

	    /* Skip the PAGE and JMP isns.  */
	    addr += 4;
	    /* Acount for the new PAGE insn.  */
            last += 2;
          }
       else
	 /* Something has gone wrong.  */
	 return FALSE;
a700 2

  return TRUE;
d704 2
a705 2
unrelax_switch_dispatch_tables_passN (abfd, sec, addr, changed, misc)
     bfd *abfd;
d707 2
a708 2
     bfd_vma addr;
     bfd_boolean *changed;
d711 22
a732 19
  if (2 <= addr && (addr + 3) < sec->_cooked_size)
    {
      bfd_byte code0 = bfd_get_8 (abfd, misc->contents + addr - 2);
      bfd_byte code1 = bfd_get_8 (abfd, misc->contents + addr - 1);

      if (IS_PAGE_OPCODE (code0, code1))
	{
	  addr -= 2;
	  code0 = bfd_get_8 (abfd, misc->contents + addr + 2);
          code1 = bfd_get_8 (abfd, misc->contents + addr + 3);
	}
      else
	{
	  code0 = bfd_get_8 (abfd, misc->contents + addr);
	  code1 = bfd_get_8 (abfd, misc->contents + addr + 1);
	}

      if (IS_JMP_OPCODE (code0, code1)
          && is_switch_128_dispatch_table_p (abfd, addr, TRUE, misc))
d734 2
a735 57
	  bfd_vma first = addr;
	  bfd_vma last  = first;
	  bfd_boolean relaxed = TRUE;

	  /* On the final pass we must check if *all* entries in the
	     dispatch table are relaxed. If *any* are not relaxed
	     then we must unrelax *all* the entries in the dispach
	     table and also unrelax the dispatch table prologue.  */

	  /* Find the last entry in the dispach table.  */
	  while (last < sec->_cooked_size)
	     {
	        code0 = bfd_get_8 (abfd, misc->contents + last);
	        code1 = bfd_get_8 (abfd, misc->contents + last + 1);

		if (IS_PAGE_OPCODE (code0, code1))
		  relaxed = FALSE;
		else if (! IS_JMP_OPCODE (code0, code1))
		    break;

	        last += 2;
	     }

	  /* We should have found the end of the dispatch table
	     before reaching the end of the section. If we've have
	     reached the end then fail the relaxation which will
	     cause the link to be aborted.  */
	  if (last >= sec->_cooked_size)
	    /* Something has gone wrong.  */
	    return FALSE;

	  /* If we found an unrelaxed entry then
	     unlrelax all the switch table entries.  */
	  if (! relaxed )
	    {
	      if (! unrelax_dispatch_table_entries (abfd, sec, first,
						    last, changed, misc))
		/* Something has gone wrong.  */
	        return FALSE;

	      if (! is_switch_128_dispatch_table_p (abfd, addr, TRUE, misc))
		/* Something has gone wrong.  */
		return FALSE;

              /* Unrelax the prologue.  */

              /* Insert an ADD W,WREG insnstruction.  */
              if (! ip2k_elf_relax_add_bytes (abfd, sec,
					      addr - 2,
					      add_w_wreg_opcode,
					      sizeof (add_w_wreg_opcode),
					      0))
		/* Something has gone wrong.  */
                return FALSE;
	    }

          return TRUE;
d738 1
a738 2
      if (IS_JMP_OPCODE (code0, code1)
          && is_switch_256_dispatch_table_p (abfd, addr, TRUE, misc))
d740 3
a742 8
          bfd_vma first = addr;
          bfd_vma last;
          bfd_boolean relaxed = TRUE;

          /* On the final pass we must check if *all* entries in the
             dispatch table are relaxed. If *any* are not relaxed
             then we must unrelax *all* the entries in the dispach
             table and also unrelax the dispatch table prologue.  */
d744 7
a750 2
	  /* Note the 1st PAGE/JMP instructions are part of the
	     prologue and can safely be relaxed.  */
d752 6
a757 2
          code0 = bfd_get_8 (abfd, misc->contents + first);
          code1 = bfd_get_8 (abfd, misc->contents + first + 1);
d759 11
a769 6
	  if (IS_PAGE_OPCODE (code0, code1))
	    {
	      first += 2;
              code0 = bfd_get_8 (abfd, misc->contents + first);
              code1 = bfd_get_8 (abfd, misc->contents + first + 1);
	    }
d771 3
a773 3
          if (! IS_JMP_OPCODE (code0, code1))
	    /* Something has gone wrong.  */
	    return FALSE;
d775 1
a775 2
          first += 2;
	  last = first;
d777 6
a782 61
          /* Find the last entry in the dispach table.  */
          while (last < sec->_cooked_size)
             {
                code0 = bfd_get_8 (abfd, misc->contents + last);
                code1 = bfd_get_8 (abfd, misc->contents + last + 1);

                if (IS_PAGE_OPCODE (code0, code1))
                  relaxed = FALSE;
                else if (! IS_JMP_OPCODE (code0, code1))
                    break;

                last += 2;
             }

          /* We should have found the end of the dispatch table
             before reaching the end of the section. If we have
             reached the end of the section then fail the
	     relaxation.  */
          if (last >= sec->_cooked_size)
            return FALSE;

          /* If we found an unrelaxed entry then
              unrelax all the switch table entries.  */
          if (! relaxed)
	    {
	      if (! unrelax_dispatch_table_entries (abfd, sec, first,
						    last, changed, misc))
		return FALSE;

              if (! is_switch_256_dispatch_table_p (abfd, addr, TRUE, misc))
		return FALSE;

              /* Unrelax the prologue.  */

              /* Insert an INC 1(SP) insnstruction.  */
              if (! ip2k_elf_relax_add_bytes (abfd, sec,
                                              addr - 6,
                                              inc_1_sp_opcode,
                                              sizeof (inc_1_sp_opcode),
					      0))
		return FALSE;

              /* Insert an SNC insnstruction.  */
              if (! ip2k_elf_relax_add_bytes (abfd, sec,
					      addr - 6,
					      snc_opcode,
					      sizeof (snc_opcode),
					      0))
		return FALSE;

	      /* Insert an ADD W,WREG insnstruction.  */
              if (! ip2k_elf_relax_add_bytes (abfd, sec,
					     addr - 6,
				 	     add_w_wreg_opcode,
					     sizeof (add_w_wreg_opcode),
					     0))
		return FALSE;
	    }

          return TRUE;
        }
d788 9
a796 1
/* This function handles relaxing for the ip2k.  */
d810 5
a814 1
  static asection * last_section = NULL;
a815 2
  static bfd_boolean final_pass = FALSE;
  static unsigned int pass = 0;
d823 4
a826 1
    first_section = sec;
a829 1
      changed = FALSE;
d831 1
a833 7
  /* If we make too many passes then it's a sign that
     something is wrong and we fail the relaxation.
     Note if everything is working correctly then the
     relaxation should converge reasonably quickly.  */
  if (pass == 4096)
    return FALSE;

a842 3
  if (pass == 1)
    last_section = sec;

d906 1
a906 2

  if (pass == 1)
d908 11
a918 4
      /* On the first pass we remove *all* page instructions and
         relax the prolog for switch dispatch tables. This gets
	 us to the starting point for subsequent passes where
	 we add page instructions back in as needed.  */
d920 7
a926 2
      if (! ip2k_elf_relax_section_pass1 (abfd, sec, again, &misc))
	goto error_return;
d928 3
a930 1
      changed |= *again;
d934 7
a940 17
      /* Add page instructions back in as needed but we ignore
	 the issue with sections (functions) crossing a page
	 boundary until we have converged to an approximate
	 solution (i.e. nothing has changed on this relaxation
	 pass) and we then know roughly where the page boundaries
	 will end up.

	 After we have have converged to an approximate solution
	 we set the final pass flag and continue relaxing. On these
	 final passes if a section (function) cross page boundary
	 we will add *all* the page instructions back into such
	 sections.

	 After adding *all* page instructions back into a section
	 which crosses a page bounbdary we reset the final pass flag
	 so the we will again interate until we find a new approximate
	 solution which is closer to the final solution.  */
d942 3
a944 9
      if (! ip2k_elf_relax_section_passN (abfd, sec, again, &final_pass,
					  &misc))
	goto error_return;

      changed |= *again;

      /* If nothing has changed on this relaxation
	  pass restart the final relaxaton pass.  */
      if (! changed && last_section == sec)
d946 2
a947 8
	  /* If this was the final pass and we didn't reset
	     the final pass flag then we are done, otherwise
	     do another final pass.  */
	  if (! final_pass)
	    {
	      final_pass = TRUE;
	      *again = TRUE;
	    }
d949 1
d994 1
a994 1
/* This function handles relaxation during the first pass.  */
d997 1
a997 1
ip2k_elf_relax_section_pass1 (abfd, sec, again, misc)
d1001 3
a1003 1
     struct misc * misc;
d1007 3
a1009 1

d1013 21
a1033 36
      if (ELF32_R_TYPE (irel->r_info) == (int) R_IP2K_PAGE3)
      {
	bfd_byte code0 = bfd_get_8 (abfd,
				    misc->contents + irel->r_offset);
	bfd_byte code1 = bfd_get_8 (abfd,
				    misc->contents + irel->r_offset + 1);

        /* Verify that this is the PAGE opcode.  */
        if (IS_PAGE_OPCODE (code0, code1))
	  {
	    /* Note that we've changed the relocs, section contents, etc.  */
	    elf_section_data (sec)->relocs = misc->irelbase;
	    elf_section_data (sec)->this_hdr.contents = misc->contents;
	    misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

	    /* Handle switch dispatch tables/prologues.  */
	    if (!  relax_switch_dispatch_tables_pass1 (abfd, sec,
						       irel->r_offset, misc))
	      return FALSE;

	    /* Fix the relocation's type.  */
	    irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				         R_IP2K_NONE);

	    /* Delete the PAGE insn.  */
	    if (! ip2k_elf_relax_delete_bytes (abfd, sec,
					       irel->r_offset,
					       sizeof (page_opcode)))
	      return FALSE;

	    /* That will change things, so, we should relax again.
	       Note that this is not required, and it may be slow.  */
	    *again = TRUE;
	  }
      }
    }
d1035 4
a1038 2
  return TRUE;
}
d1040 2
a1041 1
/* This function handles relaxation for 2nd and subsequent passes.  */
d1043 4
a1046 11
static bfd_boolean
ip2k_elf_relax_section_passN (abfd, sec, again, final_pass, misc)
     bfd *abfd;
     asection *sec;
     bfd_boolean *again;
     bfd_boolean *final_pass;
     struct misc * misc;
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *irel;
  bfd_boolean add_all;
d1048 1
a1048 24
  /* If we are on the final relaxation pass and the section crosses
     then set a flag to indicate that *all* page instructions need
     to be added back into this section.  */
  if (*final_pass)
    {
      add_all = (PAGENO (BASEADDR (sec))
	         != PAGENO (BASEADDR (sec) + sec->_cooked_size));

      /* If this section crosses a page boundary set the crossed
	 page boundary flag.  */
      if (add_all)
	sec->userdata = sec;
      else
	{
	  /* If the section had previously crossed a page boundary
	     but on this pass does not then reset crossed page
	     boundary flag and rerun the 1st relaxation pass on
	     this section.  */
	  if (sec->userdata)
	    {
	      sec->userdata = NULL;
	      if (! ip2k_elf_relax_section_pass1 (abfd, sec, again, misc))
		return FALSE;
	    }
a1049 3
    }
  else
    add_all = FALSE;
d1051 5
a1055 18
  /* Walk thru the section looking for call/jmp
      instructions which need a page instruction.  */
  for (irel = misc->irelbase; irel < irelend; irel++)
    {
      if (ELF32_R_TYPE (irel->r_info) == (int) R_IP2K_ADDR16CJP)
      {
        /* Get the value of the symbol referred to by the reloc.  */
        bfd_vma symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf,
				       irel);
	bfd_byte code0, code1;

        if (symval == UNDEFINED_SYMBOL)
	  {
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;
	  }
d1057 2
a1058 44
        /* For simplicity of coding, we are going to modify the section
	   contents, the section relocs, and the BFD symbol table.  We
	   must tell the rest of the code not to free up this
	   information.  It would be possible to instead create a table
	   of changes which have to be made, as is done in coff-mips.c;
	   that would be more work, but would require less memory when
	   the linker is run.  */

	/* Get the opcode.  */
	code0 = bfd_get_8 (abfd, misc->contents + irel->r_offset);
	code1 = bfd_get_8 (abfd, misc->contents + irel->r_offset + 1);

	if (IS_JMP_OPCODE (code0, code1) || IS_CALL_OPCODE (code0, code1))
	  {
	    if (*final_pass)
	      {
		if (! unrelax_switch_dispatch_tables_passN (abfd, sec,
						            irel->r_offset,
                                                            again, misc))
		  return FALSE;

                if (*again)
		  add_all = FALSE;
	      }

	    code0 = bfd_get_8 (abfd, misc->contents + irel->r_offset - 2);
	    code1 = bfd_get_8 (abfd, misc->contents + irel->r_offset - 1);

	    if (! IS_PAGE_OPCODE (code0, code1))
	      {
		bfd_vma value = symval + irel->r_addend;
		bfd_vma addr  = BASEADDR (sec) + irel->r_offset;

		if (add_all || PAGENO (addr) != PAGENO (value))
		  {
		    if (! add_page_insn (abfd, sec, irel, misc))
		      return FALSE;

		    /* That will have changed things, so,  we must relax again.  */
		    *again = TRUE;
		  }
	       }
	   }
        }
a1060 4
  /* If anything changed reset the final pass flag.  */
  if (*again)
    *final_pass = FALSE;

d1092 1
d1135 126
d1287 1
d1294 1
a1294 3
            {
	      sym_hash->root.u.def.value += count;
            }
a1300 82
static bfd_boolean
add_page_insn (abfd, sec, irel, misc)
      bfd *abfd;
      asection *sec;
      Elf_Internal_Rela *irel;
      struct misc *misc;
{
  /* Note that we've changed the relocs, section contents, etc.  */
  elf_section_data (sec)->relocs = misc->irelbase;
  elf_section_data (sec)->this_hdr.contents = misc->contents;
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

  /* Add the PAGE insn.  */
  if (! ip2k_elf_relax_add_bytes (abfd, sec, irel->r_offset,
                                  page_opcode,
                                  sizeof (page_opcode),
				  sizeof (page_opcode)))
    return FALSE;
  else
    {
       Elf_Internal_Rela * jrel = irel - 1;

       /* Add relocation for PAGE insn added.  */
       if (ELF32_R_TYPE (jrel->r_info) != R_IP2K_NONE)
	 {
	   bfd_byte code0, code1;
	   char *msg = NULL;

	   /* Get the opcode.  */
	   code0 = bfd_get_8 (abfd, misc->contents + irel->r_offset);
	   code1 = bfd_get_8 (abfd, misc->contents + irel->r_offset + 1);

	   if (IS_JMP_OPCODE (code0, code1))
	     msg = "\tJMP instruction missing a preceeding PAGE instruction in %s\n\n";

	   else if (IS_CALL_OPCODE (code0, code1))
	     msg = "\tCALL instruction missing a preceeding PAGE instruction in %s\n\n";

	   if (msg)
	     {
	       fprintf (stderr, "\n\t *** LINKER RELAXATION failure ***\n");
	       fprintf (stderr, msg, sec->owner->filename);
	     }

	   return FALSE;
	 }

       jrel->r_addend = irel->r_addend;
       jrel->r_offset = irel->r_offset - sizeof (page_opcode);
       jrel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                    R_IP2K_PAGE3);
     }

   return TRUE;
}

/* Insert bytes into a section while relaxing.  */

static bfd_boolean
ip2k_elf_relax_add_bytes (abfd, sec, addr, bytes, count, noadj)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     const bfd_byte *bytes;
     int count;
     int noadj;
{
  bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;
  bfd_vma endaddr = sec->_cooked_size;

  /* Make room to insert the bytes.  */
  memmove (contents + addr + count, contents + addr, endaddr - addr);

  /* Insert the bytes into the section.  */
  memcpy  (contents + addr, bytes, count);

  sec->_cooked_size += count;

  adjust_all_relocations (abfd, sec, addr, endaddr, count, noadj);
  return TRUE;
}

d1360 2
a1362 1

d1380 8
d1389 30
a1418 1
    case R_IP2K_PAGE3:
d1549 1
d1551 2
a1552 3
	    {
	      relocation = 0;
	    }
d1656 1
a1656 3
          {
            return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
          }
d1668 1
a1668 1
  /* we don't use got and plt entries for ip2k */
a1671 4

/* -------------------------------------------------------------------- */


d1678 1
a1678 1
#define ELF_MAXPAGESIZE  1 /* No pages on the IP2K */
a1686 1

a1691 1

@


1.5
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d37 43
a79 19
static reloc_howto_type *    ip2k_reloc_type_lookup               PARAMS ((bfd *, bfd_reloc_code_real_type));
static void                  ip2k_info_to_howto_rela              PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static asection *            ip2k_elf_gc_mark_hook                PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *));
static boolean               ip2k_elf_gc_sweep_hook               PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
static bfd_vma               symbol_value                         PARAMS ((bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *, Elf_Internal_Rela *));
static void                  adjust_all_relocations               PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int, int));
static boolean               ip2k_elf_relax_delete_bytes          PARAMS ((bfd *, asection *, bfd_vma, int));
static boolean               ip2k_elf_relax_add_bytes             PARAMS ((bfd *, asection *, bfd_vma, const bfd_byte *, int, int));
static boolean               add_page_insn                        PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static boolean               ip2k_elf_relax_section               PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
static boolean               relax_switch_dispatch_tables_pass1   PARAMS ((bfd *, asection *, bfd_vma, struct misc *));
static boolean               unrelax_dispatch_table_entries       PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, boolean *, struct misc *));
static boolean               unrelax_switch_dispatch_tables_passN PARAMS ((bfd *, asection *, bfd_vma, boolean *, struct misc *));
static boolean               is_switch_128_dispatch_table_p       PARAMS ((bfd *, bfd_vma, boolean, struct misc *));
static boolean               is_switch_256_dispatch_table_p       PARAMS ((bfd *, bfd_vma, boolean, struct misc *));
static boolean               ip2k_elf_relax_section_pass1         PARAMS ((bfd *, asection *, boolean *, struct misc *));
static boolean               ip2k_elf_relax_section_passN         PARAMS ((bfd *, asection *, boolean *, boolean *, struct misc *));
static bfd_reloc_status_type ip2k_final_link_relocate             PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma));
static boolean               ip2k_elf_relocate_section            PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d185 1
a185 1
          false,                /* partial_inplace */ \
d191 1
a191 1
  IP2K_HOWTO (R_IP2K_NONE, 0,2,32, false, 0, "R_IP2K_NONE", 0, 0), 
d193 1
a193 1
  IP2K_HOWTO (R_IP2K_16, 0,1,16, false, 0, "R_IP2K_16", 0, 0xffff),
d195 1
a195 1
  IP2K_HOWTO (R_IP2K_32, 0,2,32, false, 0, "R_IP2K_32", 0, 0xffffffff),
d197 1
a197 1
  IP2K_HOWTO (R_IP2K_FR9, 0,1,9, false, 0, "R_IP2K_FR9", 0, 0x00ff),
d199 1
a199 1
  IP2K_HOWTO (R_IP2K_BANK, 8,1,4, false, 0, "R_IP2K_BANK", 0, 0x000f),
d201 1
a201 1
  IP2K_HOWTO (R_IP2K_ADDR16CJP, 1,1,13, false, 0, "R_IP2K_ADDR16CJP", 0, 0x1fff),
d203 1
a203 1
  IP2K_HOWTO (R_IP2K_PAGE3, 14,1,3, false, 0, "R_IP2K_PAGE3", 0, 0x0007),
d205 2
a206 2
  IP2K_HOWTO (R_IP2K_LO8DATA, 0,1,8, false, 0, "R_IP2K_LO8DATA", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8DATA, 8,1,8, false, 0, "R_IP2K_HI8DATA", 0, 0x00ff),
d208 2
a209 2
  IP2K_HOWTO (R_IP2K_LO8INSN, 1,1,8, false, 0, "R_IP2K_LO8INSN", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8INSN, 9,1,8, false, 0, "R_IP2K_HI8INSN", 0, 0x00ff),
d212 1
a212 1
  IP2K_HOWTO (R_IP2K_PC_SKIP, 1,1,1, false, 12, "R_IP2K_PC_SKIP", 0xfffe, 0x1000),
d214 1
a214 1
  IP2K_HOWTO (R_IP2K_TEXT, 1,1,16, false, 0, "R_IP2K_TEXT", 0, 0xffff),
d216 1
a216 1
  IP2K_HOWTO (R_IP2K_FR_OFFSET, 0,1,9, false, 0, "R_IP2K_FR_OFFSET", 0x180, 0x007f),
d218 1
a218 1
  IP2K_HOWTO (R_IP2K_EX8DATA, 16,1,8, false, 0, "R_IP2K_EX8DATA", 0, 0x00ff),
d284 1
a284 1
     Elf_Internal_Rela *irel;   
d323 1
a323 1
 
d337 1
a337 1
 
d349 1
a349 1
static boolean 
d351 1
a351 1
     bfd *abfd ATTRIBUTE_UNUSED;                
d353 1
a353 1
     boolean relaxed;
d359 1
a359 1
    return false;
d366 1
a366 1
    return false;
d379 1
a379 1
	return false;
d386 1
a386 1
        return false;
d391 1
a391 1
  return true;
d397 1
a397 1
 
d418 1
a418 1
 
d434 1
a434 1
static boolean 
d438 1
a438 1
     boolean relaxed;
d444 1
a444 1
    return false;
d451 1
a451 1
    return false;
d458 1
a458 1
    return false;
d465 1
a465 1
    return false;
d478 1
a478 1
	return false;
d482 1
a482 1
 
d485 1
a485 1
        return false;
d492 1
a492 1
	return false;
d497 1
a497 1
  return true;
d500 1
a500 1
static boolean
d513 1
a513 1
	  && is_switch_128_dispatch_table_p (abfd, addr, false, misc))
d517 1
a517 1
	  return true;
d521 1
a521 1
	  && is_switch_256_dispatch_table_p (abfd, addr, false, misc))
d525 1
a525 1
	  return true;
d528 2
a529 2
 
  return true;
d532 1
a532 1
static boolean
d538 1
a538 1
     boolean *changed;
d570 1
a570 1
                        return false;
d572 1
a572 1
		      *changed = true;
d580 1
a580 1
	      return false;
d589 1
a589 1
	 return false;
d592 1
a592 1
  return true;
d595 1
a595 1
static boolean 
d600 1
a600 1
     boolean *changed;
d621 1
a621 1
          && is_switch_128_dispatch_table_p (abfd, addr, true, misc))
d625 1
a625 1
	  boolean relaxed = true;
d639 1
a639 1
		  relaxed = false;
d652 1
a652 1
	    return false;
d661 1
a661 1
	        return false;
d663 1
a663 1
	      if (! is_switch_128_dispatch_table_p (abfd, addr, true, misc))
d665 2
a666 2
		return false;
		
d676 1
a676 1
                return false;
d679 1
a679 1
          return true;
d683 1
a683 1
          && is_switch_256_dispatch_table_p (abfd, addr, true, misc))
d687 1
a687 1
          boolean relaxed = true;
d709 1
a709 1
	    return false;
d712 1
a712 1
	  last = first; 
d721 1
a721 1
                  relaxed = false;
d733 1
a733 1
            return false;
d741 1
a741 1
		return false;
d743 2
a744 2
              if (! is_switch_256_dispatch_table_p (abfd, addr, true, misc))
		return false;
d754 1
a754 1
		return false;
d762 1
a762 1
		return false;
d770 1
a770 1
		return false;
d773 1
a773 1
          return true;
d777 1
a777 1
  return true;
d782 1
a782 1
static boolean
d787 1
a787 1
     boolean *again;
d795 2
a796 2
  static boolean changed = false;
  static boolean final_pass = false;
d802 1
a802 1
  *again = false;
d809 1
a809 1
      changed = false;
d818 1
a818 1
    return false;
d827 1
a827 1
    return true;
d876 1
a876 1
      
d893 1
a893 1
  
d910 1
a910 1
      /* Add page instructions back in as needed but we ignore 
d938 1
a938 1
	  /* If this was the final pass and we didn't reset 
d943 2
a944 2
	      final_pass = true;
	      *again = true;
d949 1
a949 1
  /* Perform some house keeping after relaxing the section.  */  
d976 1
a976 1
  return true;
d988 1
a988 1
  return false;
d993 1
a993 1
static boolean
d997 1
a997 1
     boolean *again;
d1024 2
a1025 2
	      return false;
	    
d1034 1
a1034 1
	      return false;
d1038 1
a1038 1
	    *again = true;
d1043 1
a1043 1
  return true;
d1048 1
a1048 1
static boolean
d1052 2
a1053 2
     boolean *again;
     boolean *final_pass;
d1058 1
a1058 1
  boolean add_all;
d1082 1
a1082 1
		return false;
d1087 1
a1087 1
    add_all = false;
d1127 1
a1127 1
		  return false;
d1130 1
a1130 1
		  add_all = false;
d1144 1
a1144 1
		      return false;
d1147 1
a1147 1
		    *again = true;
d1153 1
a1153 1
      
d1156 1
a1156 1
    *final_pass = false;
d1158 1
a1158 1
  return true;
d1189 1
a1189 1
    
d1272 1
a1272 1
static boolean
d1289 1
a1289 1
    return false;
d1299 1
a1299 1
	   
d1316 1
a1316 1
	   return false;
d1325 1
a1325 1
   return true;
d1330 1
a1330 1
static boolean
d1347 1
a1347 1
  
d1351 1
a1351 1
  return true;
d1356 1
a1356 1
static boolean
d1373 1
a1373 1
  return true;
d1494 1
a1494 1
static boolean
d1497 13
a1509 13
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *  info;
     bfd *                   input_bfd;
     asection *              input_section;
     bfd_byte *              contents;
     Elf_Internal_Rela *     relocs;
     Elf_Internal_Sym *      local_syms;
     asection **             local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
d1512 1
a1512 1
    return true;
d1529 1
a1529 1
      
d1537 1
a1537 1
      
d1543 1
a1543 1
	  
d1551 1
a1551 1
	  
d1557 1
a1557 1
	  
d1574 1
a1574 1
		return false;
d1594 1
a1594 1
	      
d1597 1
a1597 1
		(info, name, input_bfd, input_section, rel->r_offset, true);
d1599 1
a1599 1
	      
d1625 1
a1625 1
	    return false;
d1629 1
a1629 1
  return true;
d1644 1
a1644 1
#if 0 
d1678 1
a1678 1
static boolean
d1686 1
a1686 1
  return true;
@


1.4
log
@	* elf32-ip2k.c (ELF_MACHINE_ALT1): Define alternate machine code
	for ip2k port.
@
text
@d38 1
a38 1
static void                  ip2k_info_to_howto_rela              PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d41 1
a41 1
static bfd_vma               symbol_value                         PARAMS ((bfd *, Elf_Internal_Shdr *, Elf32_Internal_Sym *, Elf_Internal_Rela *));
d259 1
a259 1
     Elf32_Internal_Sym *isymbuf;
d1167 1
a1167 1
  isymbuf = (Elf32_Internal_Sym *) symtab_hdr->contents;
d1268 1
a1268 1
       Elf32_Internal_Rela * jrel = irel - 1;
d1363 1
a1363 1
     Elf32_Internal_Rela * dst;
@


1.3
log
@	* elf32-ip2k.c: Processor manufacturer changed to Ubicom.
	(struct misc): New field isymbuf. All free_* fields removed.
	(symbol_value): Pass in internal syms. No need to swap syms in.
	(ip2k_elf_relax_section): Use bfd_elf_get_elf_syms. Properly free
	possibly cached info.
	(tidyup_after_error): Removed.
	(ip2k_elf_relax_section_pass1): Don't use removed fields of struct
	misc. Use new field.
	(adjust_all_relocations): Use internal syms. No need to swap syms
	in and out.
	(add_page_insn): Don't use removed fields of struct misc.
@
text
@d1674 1
a1692 1

@


1.3.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1673 1
#define ELF_MACHINE_ALT1 EM_IP2K_OLD
d1692 1
@


1.3.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a35 6
struct ip2k_opcode
{
  unsigned short opcode;
  unsigned short mask;
};
  
d37 22
a58 45
static reloc_howto_type *ip2k_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static int ip2k_is_opcode
  PARAMS ((bfd_byte *, const struct ip2k_opcode *));
static bfd_vma symbol_value
  PARAMS ((bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *,
	   Elf_Internal_Rela *));
static void ip2k_get_mem
  PARAMS ((bfd *, bfd_byte *, int, bfd_byte *));
static bfd_vma ip2k_nominal_page_bits
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_test_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static bfd_boolean ip2k_delete_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_128
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_128
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_256
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_256
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static bfd_boolean ip2k_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean ip2k_elf_relax_section_page
  PARAMS ((bfd *, asection *, bfd_boolean *, struct misc *, unsigned long, unsigned long));
static void adjust_all_relocations
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int, int));
static bfd_boolean ip2k_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
static void ip2k_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_reloc_status_type ip2k_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean ip2k_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static asection *ip2k_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ip2k_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d60 2
a61 1
static bfd_boolean ip2k_relaxed = FALSE;
d63 1
a63 1
static const struct ip2k_opcode ip2k_page_opcode[] =
d65 1
a65 2
  {0x0010, 0xFFF8},	/* page */
  {0x0000, 0x0000},
d68 2
a69 2
#define IS_PAGE_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_page_opcode)
d71 4
a74 1
static const struct ip2k_opcode ip2k_jmp_opcode[] =
d76 1
a76 2
  {0xE000, 0xE000},	/* jmp */
  {0x0000, 0x0000},
d79 5
a83 2
#define IS_JMP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_jmp_opcode)
d85 1
a85 1
static const struct ip2k_opcode ip2k_call_opcode[] =
d87 1
a87 2
  {0xC000, 0xE000},	/* call */
  {0x0000, 0x0000},
d90 2
a91 2
#define IS_CALL_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_call_opcode)
d93 4
a96 1
static const struct ip2k_opcode ip2k_snc_opcode[] =
d98 1
a98 2
  {0xA00B, 0xFFFF},	/* snc */
  {0x0000, 0x0000},
d101 5
a105 2
#define IS_SNC_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_snc_opcode)
d107 1
a107 1
static const struct ip2k_opcode ip2k_inc_1sp_opcode[] =
d109 1
a109 2
  {0x2B81, 0xFFFF},	/* inc 1(SP) */
  {0x0000, 0x0000},
d112 5
a116 2
#define IS_INC_1SP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_inc_1sp_opcode)
d118 1
a118 1
static const struct ip2k_opcode ip2k_add_2sp_w_opcode[] =
d120 1
a120 2
  {0x1F82, 0xFFFF},	/* add 2(SP),w */
  {0x0000, 0x0000},
d123 2
a124 2
#define IS_ADD_2SP_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_2sp_w_opcode)
d126 4
a129 1
static const struct ip2k_opcode ip2k_add_w_wreg_opcode[] =
d131 1
a131 3
  {0x1C0A, 0xFFFF},	/* add w,wreg */
  {0x1E0A, 0xFFFF},	/* add wreg,w */
  {0x0000, 0x0000},
d134 2
a135 2
#define IS_ADD_W_WREG_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_w_wreg_opcode)
d137 2
a138 8
static const struct ip2k_opcode ip2k_add_pcl_w_opcode[] =
{
  {0x1E09, 0xFFFF},	/* add pcl,w */
  {0x0000, 0x0000},
};

#define IS_ADD_PCL_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_pcl_w_opcode)
d140 1
a140 1
static const struct ip2k_opcode ip2k_skip_opcodes[] =
d142 1
a142 9
  {0xB000, 0xF000},	/* sb */
  {0xA000, 0xF000},	/* snb */
  {0x7600, 0xFE00},	/* cse/csne #lit */
  {0x5800, 0xFC00},	/* incsnz */
  {0x4C00, 0xFC00},	/* decsnz */
  {0x4000, 0xFC00},	/* cse/csne */
  {0x3C00, 0xFC00},	/* incsz */
  {0x2C00, 0xFC00},	/* decsz */
  {0x0000, 0x0000},
d145 2
a146 2
#define IS_SKIP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_skip_opcodes)
d148 1
a148 1
/* Relocation tables.  */
d161 1
a161 1
          FALSE,                /* partial_inplace */ \
d166 2
a167 2
  /* This reloc does nothing.  */
  IP2K_HOWTO (R_IP2K_NONE, 0,2,32, FALSE, 0, "R_IP2K_NONE", 0, 0),
d169 1
a169 1
  IP2K_HOWTO (R_IP2K_16, 0,1,16, FALSE, 0, "R_IP2K_16", 0, 0xffff),
d171 1
a171 1
  IP2K_HOWTO (R_IP2K_32, 0,2,32, FALSE, 0, "R_IP2K_32", 0, 0xffffffff),
d173 1
a173 1
  IP2K_HOWTO (R_IP2K_FR9, 0,1,9, FALSE, 0, "R_IP2K_FR9", 0, 0x00ff),
d175 1
a175 1
  IP2K_HOWTO (R_IP2K_BANK, 8,1,4, FALSE, 0, "R_IP2K_BANK", 0, 0x000f),
d177 1
a177 1
  IP2K_HOWTO (R_IP2K_ADDR16CJP, 1,1,13, FALSE, 0, "R_IP2K_ADDR16CJP", 0, 0x1fff),
d179 1
a179 1
  IP2K_HOWTO (R_IP2K_PAGE3, 14,1,3, FALSE, 0, "R_IP2K_PAGE3", 0, 0x0007),
d181 2
a182 2
  IP2K_HOWTO (R_IP2K_LO8DATA, 0,1,8, FALSE, 0, "R_IP2K_LO8DATA", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8DATA, 8,1,8, FALSE, 0, "R_IP2K_HI8DATA", 0, 0x00ff),
d184 2
a185 2
  IP2K_HOWTO (R_IP2K_LO8INSN, 1,1,8, FALSE, 0, "R_IP2K_LO8INSN", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8INSN, 9,1,8, FALSE, 0, "R_IP2K_HI8INSN", 0, 0x00ff),
d188 1
a188 1
  IP2K_HOWTO (R_IP2K_PC_SKIP, 1,1,1, FALSE, 12, "R_IP2K_PC_SKIP", 0xfffe, 0x1000),
d190 1
a190 1
  IP2K_HOWTO (R_IP2K_TEXT, 1,1,16, FALSE, 0, "R_IP2K_TEXT", 0, 0xffff),
d192 1
a192 1
  IP2K_HOWTO (R_IP2K_FR_OFFSET, 0,1,9, FALSE, 0, "R_IP2K_FR_OFFSET", 0x180, 0x007f),
d194 1
a194 1
  IP2K_HOWTO (R_IP2K_EX8DATA, 16,1,8, FALSE, 0, "R_IP2K_EX8DATA", 0, 0x00ff),
d198 1
a198 1
/* Map BFD reloc types to IP2K ELF reloc types.  */
d207 1
a207 1
     include/elf/ip2k.h.  */
d242 1
a242 1
      /* Pacify gcc -Wall.  */
d248 1
a248 30
static void
ip2k_get_mem (abfd, addr, length, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_byte *addr;
     int length;
     bfd_byte *ptr;
{
  while (length --)
    * ptr ++ = bfd_get_8 (abfd, addr ++);
}

static bfd_boolean
ip2k_is_opcode (code, opcodes)
     bfd_byte *code;
     const struct ip2k_opcode *opcodes;
{
  unsigned short insn = (code[0] << 8) | code[1];

  while (opcodes->mask != 0)
    {
      if ((insn & opcodes->mask) == opcodes->opcode)
	return TRUE;

      opcodes ++;
    }

  return FALSE;
}

#define PAGENO(ABSADDR) ((ABSADDR) & 0xFFFFC000)
d259 2
a260 2
     Elf_Internal_Sym *isymbuf;
     Elf_Internal_Rela *irel;
a295 109
/* Returns the expected page state for the given instruction not including
   the effect of page instructions.  */

static bfd_vma
ip2k_nominal_page_bits (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma addr;
     bfd_byte *contents;
{
  bfd_vma page = PAGENO (BASEADDR (sec) + addr);

  /* Check if section flows into this page. If not then the page
     bits are assumed to match the PC. This will be true unless
     the user has a page instruction without a call/jump, in which
     case they are on their own.  */
  if (PAGENO (BASEADDR (sec)) == page)
    return page;

  /* Section flows across page boundary. The page bits should match
     the PC unless there is a possible flow from the previous page,
     in which case it is not possible to determine the value of the
     page bits.  */
  while (PAGENO (BASEADDR (sec) + addr - 2) == page)
    {
      bfd_byte code[2];

      addr -= 2;
      ip2k_get_mem (abfd, contents + addr, 2, code);
      if (!IS_PAGE_OPCODE (code))
	continue;

      /* Found a page instruction, check if jump table.  */
      if (ip2k_is_switch_table_128 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      if (ip2k_is_switch_table_256 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      /* Found a page instruction, check if conditional.  */
      if (addr >= 2)
        {
	  ip2k_get_mem (abfd, contents + addr - 2, 2, code);
          if (IS_SKIP_OPCODE (code))
	    /* Page is conditional.  */
	    continue;
        }

      /* Unconditional page instruction => page bits should be correct.  */
      return page;
    }

  /* Flow from previous page => page bits are impossible to determine.  */
  return 0;
}

static bfd_boolean
ip2k_test_page_insn (abfd, sec, irel, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     struct misc *misc;
{
  bfd_vma symval;

  /* Get the value of the symbol referred to by the reloc.  */
  symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf, irel);
  if (symval == UNDEFINED_SYMBOL)
    /* This appears to be a reference to an undefined
       symbol.  Just ignore it--it will be caught by the
       regular reloc processing.  */
    return FALSE;

  /* Test if we can delete this page instruction.  */
  if (PAGENO (symval + irel->r_addend) !=
      ip2k_nominal_page_bits (abfd, sec, irel->r_offset, misc->contents))
    return FALSE;

  return TRUE;
}

static bfd_boolean
ip2k_delete_page_insn (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  /* Note that we've changed the relocs, section contents, etc.  */
  elf_section_data (sec)->relocs = misc->irelbase;
  elf_section_data (sec)->this_hdr.contents = misc->contents;
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

  /* Fix the relocation's type.  */
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_IP2K_NONE);

  /* Delete the PAGE insn.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
    return FALSE;
	
  /* Modified => will need to iterate relaxation again.  */
  *again = TRUE;
  
  return TRUE;
}

d299 1
a299 1

d313 1
a313 1

d325 3
a327 4
static int
ip2k_is_switch_table_128 (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d329 2
a330 1
     bfd_byte *contents;
d332 1
a332 18
  bfd_byte code[4];
  int index = 0;
  
  /* Check current page-jmp.  */
  if (addr + 4 > sec->_cooked_size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);

  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;
  
  /* Search back.  */
  while (1)
    {
      if (addr < 4)
	return -1;
d334 2
a335 9
      /* Check previous 2 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 4, 4, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_ADD_PCL_W_OPCODE (code + 2)))
	return index;

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;
d337 2
a338 37
      index++;
      addr -= 4;
    }
}

static bfd_boolean
ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[4];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;
  while (1)
    {
      if (addr + 4 > sec->_cooked_size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d340 3
a342 5
      if (ireltest->r_offset != addr)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d344 2
a345 3
      if (! ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;
d347 3
a349 3
      addr += 4;
      ireltest += 2;
    }
d351 1
a351 4
  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 4, code);
  if ((! IS_ADD_W_WREG_OPCODE (code + 0))
      || (! IS_ADD_PCL_W_OPCODE (code + 2)))
d353 3
a355 6
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }

  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset - 4, 2))
    return FALSE;
d357 2
a358 1
  *again = TRUE;
d360 3
a362 6
  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
d365 3
a367 1
  return TRUE;
d373 1
a373 1

d394 1
a394 1

d410 2
a411 2
static int
ip2k_is_switch_table_256 (abfd, sec, addr, contents)
d413 66
d481 1
a481 1
     bfd_byte *contents;
d483 1
a483 14
  bfd_byte code[16];
  int index = 0;
  
  /* Check current page-jmp.  */
  if (addr + 4 > sec->_cooked_size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);
  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;
  
  /* Search back.  */
  while (1)
d485 2
a486 2
      if (addr < 16)
	return -1;
d488 7
a494 24
      /* Check previous 8 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 16, 16, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_SNC_OPCODE (code + 2))
	  && (IS_INC_1SP_OPCODE (code + 4))
	  && (IS_ADD_2SP_W_OPCODE (code + 6))
	  && (IS_SNC_OPCODE (code + 8))
	  && (IS_INC_1SP_OPCODE (code + 10))
	  && (IS_PAGE_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return index;

      if ((IS_ADD_W_WREG_OPCODE (code + 2))
	  && (IS_SNC_OPCODE (code + 4))
	  && (IS_INC_1SP_OPCODE (code + 6))
	  && (IS_ADD_2SP_W_OPCODE (code + 8))
	  && (IS_SNC_OPCODE (code + 10))
	  && (IS_INC_1SP_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return index;
      
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;
d496 7
a502 2
      index++;
      addr -= 4;
d504 2
d508 3
a510 3
static bfd_boolean
ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
d512 3
a514 2
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
d517 1
a517 7
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[12];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;
d519 1
a519 1
  while (1)
d521 2
a522 2
      if (addr + 4 > sec->_cooked_size)
	break;
d524 43
a566 1
      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
d568 2
a569 3
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;
d571 27
a597 3
      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
d599 57
a655 2
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
d658 2
a659 1
      if (ireltest->r_offset != addr)
d661 8
a668 11
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }

      if (!ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
    }
d670 2
a671 6
  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 2, code);
  if (IS_PAGE_OPCODE (code))
    addr = irel->r_offset - 16;
  else
    addr = irel->r_offset - 14;
d673 2
a674 11
  ip2k_get_mem (abfd, misc->contents + addr, 12, code);
  if ((!IS_ADD_W_WREG_OPCODE (code + 0))
      || (!IS_SNC_OPCODE (code + 2))
      || (!IS_INC_1SP_OPCODE (code + 4))
      || (!IS_ADD_2SP_W_OPCODE (code + 6))
      || (!IS_SNC_OPCODE (code + 8))
      || (!IS_INC_1SP_OPCODE (code + 10)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }
d676 6
a681 3
  /* Delete first 3 opcodes.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, addr + 0, 6))
    return FALSE;
d683 65
a747 1
  *again = TRUE;
d749 2
a750 6
  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
d753 1
a753 1
  return TRUE;
d756 1
a756 9
/* This function handles relaxing for the ip2k.

   Principle: Start with the first page and remove page instructions that
   are not require on this first page. By removing page instructions more
   code will fit into this page - repeat until nothing more can be achieved
   for this page. Move on to the next page.

   Processing the pages one at a time from the lowest page allows a removal
   only policy to be used - pages can be removed but are never reinserted.  */
d758 1
a758 1
static bfd_boolean
d763 1
a763 1
     bfd_boolean *again;
d770 3
a772 3
  static unsigned long search_addr;
  static unsigned long page_start = 0;
  static unsigned long page_end = 0;
a773 2
  static bfd_boolean new_pass = FALSE;
  static bfd_boolean changed = FALSE;
d778 1
a778 1
  *again = FALSE;
d781 1
a781 4
    {
      ip2k_relaxed = TRUE;
      first_section = sec;
    }
d785 1
a786 1
      new_pass = TRUE;
d789 7
d799 1
a799 1
  if (link_info->relocatable
d803 4
a806 1
    return TRUE;
d815 3
a817 3
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL,
					       (Elf_Internal_Rela *)NULL,
					       link_info->keep_memory);
d829 3
a831 3
      irelbase = _bfd_elf_link_read_relocs (abfd, stab, NULL,
					    (Elf_Internal_Rela *)NULL,
					    link_info->keep_memory);
d852 1
a852 1

d869 2
d872 1
a872 2
  /* This is where all the relaxation actually get done.  */
  if ((pass == 1) || (new_pass && !changed))
d874 4
a877 11
      /* On the first pass we simply search for the lowest page that
         we havn't relaxed yet. Note that the pass count is reset
         each time a page is complete in order to move on to the next page.
         If we can't find any more pages then we are finished.  */
      if (new_pass)
	{
	  pass = 1;
	  new_pass = FALSE;
	  changed = TRUE; /* Pre-initialize to break out of pass 1.  */
	  search_addr = 0xFFFFFFFF;
	}
d879 2
a880 7
      if ((BASEADDR (sec) + sec->_cooked_size < search_addr)
	  && (BASEADDR (sec) + sec->_cooked_size > page_end))
	{
	  if (BASEADDR (sec) <= page_end)
	    search_addr = page_end + 1;
	  else
	    search_addr = BASEADDR (sec);
d882 1
a882 3
	  /* Found a page => more work to do.  */
	  *again = TRUE;
	}
d886 23
a908 7
      if (new_pass)
	{
	  new_pass = FALSE;
	  changed = FALSE;
	  page_start = PAGENO (search_addr);
	  page_end = page_start | 0x00003FFF;
	}
d910 3
a912 3
      /* Only process sections in range.  */
      if ((BASEADDR (sec) + sec->_cooked_size >= page_start)
	  && (BASEADDR (sec) <= page_end))
d914 8
a921 2
          if (!ip2k_elf_relax_section_page (abfd, sec, &changed, &misc, page_start, page_end))
	    return FALSE;
a922 1
      *again = TRUE;
d925 1
a925 1
  /* Perform some house keeping after relaxing the section.  */
d952 1
a952 1
  return TRUE;
d964 1
a964 1
  return FALSE;
d967 1
a967 1
/* This function handles relaxation of a section in a specific page.  */
d969 2
a970 2
static bfd_boolean
ip2k_elf_relax_section_page (abfd, sec, again, misc, page_start, page_end)
d973 2
a974 4
     bfd_boolean *again;
     struct misc *misc;
     unsigned long page_start;
     unsigned long page_end;
d978 2
a979 4
  int switch_table_128;
  int switch_table_256;
  
  /* Walk thru the section looking for relaxation opportunities.  */
d982 36
a1017 21
      if (ELF32_R_TYPE (irel->r_info) != (int) R_IP2K_PAGE3)
	/* Ignore non page instructions.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset < page_start)
	/* Ignore page instructions on earlier page - they have
	   already been processed. Remember that there is code flow
	   that crosses a page boundary.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset > page_end)
	/* Flow beyond end of page => nothing more to do for this page.  */
	return TRUE;

      /* Detect switch tables.  */
      switch_table_128 = ip2k_is_switch_table_128 (abfd, sec, irel->r_offset, misc->contents);
      switch_table_256 = ip2k_is_switch_table_256 (abfd, sec, irel->r_offset, misc->contents);

      if ((switch_table_128 > 0) || (switch_table_256 > 0))
	/* If the index is greater than 0 then it has already been processed.  */
	continue;
d1019 4
a1022 4
      if (switch_table_128 == 0)
	{
	  if (!ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc))
	    return FALSE;
d1024 11
a1034 2
	  continue;
	}
d1036 13
a1048 1
      if (switch_table_256 == 0)
d1050 10
a1059 4
	  if (!ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc))
	    return FALSE;

	  continue;
d1061 3
d1065 18
a1082 5
      /* Simple relax.  */
      if (ip2k_test_page_insn (abfd, sec, irel, misc))
	{
	  if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	    return FALSE;
d1084 44
a1127 2
	  continue;
	}
d1129 4
d1134 1
a1134 1
  return TRUE;
d1165 1
a1165 2
  asection *stab;

d1167 1
a1167 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
a1206 126
  /* Now fix the stab relocations.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
  if (stab)
    {
      bfd_byte *stabcontents, *stabend, *stabp;

      irelbase = elf_section_data (stab)->relocs;
      irelend = irelbase + stab->reloc_count;

      /* Pull out the contents of the stab section.  */
      if (elf_section_data (stab)->this_hdr.contents != NULL)
	stabcontents = elf_section_data (stab)->this_hdr.contents;
      else
	{
	  stabcontents = (bfd_byte *) bfd_alloc (abfd, stab->_raw_size);
	  if (stabcontents == NULL)
	    return;

	  if (! bfd_get_section_contents (abfd, stab, stabcontents,
					  (file_ptr) 0, stab->_raw_size))
	    return;

	  /* We need to remember this.  */
	  elf_section_data (stab)->this_hdr.contents = stabcontents;
	}

      stabend = stabcontents + stab->_raw_size;

      for (irel = irelbase; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
	    {
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
		{
		  asection *sym_sec;
		  
		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);
		  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  
		  if (sym_sec == sec)
		    {
		      const char *name;
		      unsigned long strx;
		      unsigned char type, other;
		      unsigned short desc;
		      bfd_vma value;
		      bfd_vma baseaddr = BASEADDR (sec);
		      bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
			+ irel->r_addend;
		      
		      if ((baseaddr + addr) <= symval
			  && symval <= (baseaddr + endaddr))
			irel->r_addend += count;

		      /* Go hunt up a function and fix its line info if needed.  */
		      stabp = stabcontents + irel->r_offset - 8; 

		      /* Go pullout the stab entry.  */
		      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
		      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
		      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
		      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
		      value = bfd_h_get_32 (abfd, stabp + VALOFF);
		      
		      name = bfd_get_stab_name (type);
		      
		      if (strcmp (name, "FUN") == 0)
			{
			  int function_adjusted = 0;

			  if (symval > (baseaddr + addr))
			    /* Not in this function.  */
			    continue;

			  /* Hey we got a function hit.  */
			  stabp += STABSIZE;
			  for (;stabp < stabend; stabp += STABSIZE)
			    {
			      /* Go pullout the stab entry.  */
			      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
			      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
			      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
			      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
			      value = bfd_h_get_32 (abfd, stabp + VALOFF);

			      name = bfd_get_stab_name (type);

			      if (strcmp (name, "FUN") == 0)
				{
				  /* Hit another function entry.  */
				  if (function_adjusted)
				    {
				      /* Adjust the value.  */
				      value += count;
				  
				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				    }

				  /* And then bale out.  */
				  break;
				}

			      if (strcmp (name, "SLINE") == 0)
				{
				  /* Got a line entry.  */
				  if ((baseaddr + addr) <= (symval + value))
				    {
				      /* Adjust the line entry.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				      function_adjusted = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

a1232 1

d1239 3
a1241 1
	    sym_hash->root.u.def.value += count;
d1248 82
d1332 1
a1332 1
static bfd_boolean
d1349 1
a1349 1
  return TRUE;
d1363 1
a1363 1
     Elf_Internal_Rela * dst;
d1389 1
a1389 1
  static bfd_vma page_addr = 0;
a1390 1
  bfd_reloc_status_type r = bfd_reloc_ok;
d1408 1
a1409 38
      page_addr = BASEADDR (input_section) + rel->r_offset;
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_ADDR16CJP:
      if (BASEADDR (input_section) + rel->r_offset != page_addr + 2)
	{
	  /* No preceding page instruction, verify that it isn't needed.  */
	  if (PAGENO (relocation + rel->r_addend) !=
	      ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset, contents))
	    _bfd_error_handler (_("ip2k linker: missing page instruction at 0x%08lx (dest = 0x%08lx)."),
				BASEADDR (input_section) + rel->r_offset,
				relocation + rel->r_addend);
        }
      else if (ip2k_relaxed)
        {
          /* Preceding page instruction. Verify that the page instruction is
             really needed. One reason for the relaxation to miss a page is if
             the section is not marked as executable.  */
	  if (!ip2k_is_switch_table_128 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      !ip2k_is_switch_table_256 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      (PAGENO (relocation + rel->r_addend) ==
	       ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset - 2, contents)))
	    _bfd_error_handler (_("ip2k linker: redundant page instruction at 0x%08lx (dest = 0x%08lx)."),
				page_addr,
				relocation + rel->r_addend);
        }
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

d1450 1
a1450 1
   necessary, and (if using Rela relocs and generating a relocatable
d1464 1
a1464 1
   When generating relocatable output, this function must handle
d1470 1
a1470 1
static bfd_boolean
d1473 13
a1485 13
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d1487 2
a1488 2
  if (info->relocatable)
    return TRUE;
d1505 1
a1505 1

d1513 1
a1513 1

d1519 1
a1519 1

d1526 5
a1530 4
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
d1533 20
d1570 1
a1570 1

d1573 1
a1573 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d1575 1
a1575 1

d1601 1
a1601 1
	    return FALSE;
d1605 1
a1605 1
  return TRUE;
d1620 1
a1620 1
#if 0
d1647 3
a1649 1
	 return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1654 1
a1654 1
static bfd_boolean
d1661 2
a1662 2
  /* We don't use got and plt entries for ip2k.  */
  return TRUE;
d1665 4
d1675 1
a1675 1
#define ELF_MAXPAGESIZE  1 /* No pages on the IP2K.  */
d1684 1
d1690 1
@


1.3.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a1673 1
#define ELF_MACHINE_ALT1 EM_IP2K_OLD
d1692 1
@


1.3.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d37 19
a55 43
static reloc_howto_type *ip2k_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void ip2k_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static asection * ip2k_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ip2k_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_vma symbol_value
  PARAMS ((bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *,
	   Elf_Internal_Rela *));
static void adjust_all_relocations
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int, int));
static bfd_boolean ip2k_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, int));
static bfd_boolean ip2k_elf_relax_add_bytes
  PARAMS ((bfd *, asection *, bfd_vma, const bfd_byte *, int, int));
static bfd_boolean add_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static bfd_boolean ip2k_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean relax_switch_dispatch_tables_pass1
  PARAMS ((bfd *, asection *, bfd_vma, struct misc *));
static bfd_boolean unrelax_dispatch_table_entries
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, bfd_boolean *, struct misc *));
static bfd_boolean unrelax_switch_dispatch_tables_passN
  PARAMS ((bfd *, asection *, bfd_vma, bfd_boolean *, struct misc *));
static bfd_boolean is_switch_128_dispatch_table_p
  PARAMS ((bfd *, bfd_vma, bfd_boolean, struct misc *));
static bfd_boolean is_switch_256_dispatch_table_p
  PARAMS ((bfd *, bfd_vma, bfd_boolean, struct misc *));
static bfd_boolean ip2k_elf_relax_section_pass1
  PARAMS ((bfd *, asection *, bfd_boolean *, struct misc *));
static bfd_boolean ip2k_elf_relax_section_passN
  PARAMS ((bfd *, asection *, bfd_boolean *, bfd_boolean *, struct misc *));
static bfd_reloc_status_type ip2k_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean ip2k_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d161 1
a161 1
          FALSE,                /* partial_inplace */ \
d167 1
a167 1
  IP2K_HOWTO (R_IP2K_NONE, 0,2,32, FALSE, 0, "R_IP2K_NONE", 0, 0),
d169 1
a169 1
  IP2K_HOWTO (R_IP2K_16, 0,1,16, FALSE, 0, "R_IP2K_16", 0, 0xffff),
d171 1
a171 1
  IP2K_HOWTO (R_IP2K_32, 0,2,32, FALSE, 0, "R_IP2K_32", 0, 0xffffffff),
d173 1
a173 1
  IP2K_HOWTO (R_IP2K_FR9, 0,1,9, FALSE, 0, "R_IP2K_FR9", 0, 0x00ff),
d175 1
a175 1
  IP2K_HOWTO (R_IP2K_BANK, 8,1,4, FALSE, 0, "R_IP2K_BANK", 0, 0x000f),
d177 1
a177 1
  IP2K_HOWTO (R_IP2K_ADDR16CJP, 1,1,13, FALSE, 0, "R_IP2K_ADDR16CJP", 0, 0x1fff),
d179 1
a179 1
  IP2K_HOWTO (R_IP2K_PAGE3, 14,1,3, FALSE, 0, "R_IP2K_PAGE3", 0, 0x0007),
d181 2
a182 2
  IP2K_HOWTO (R_IP2K_LO8DATA, 0,1,8, FALSE, 0, "R_IP2K_LO8DATA", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8DATA, 8,1,8, FALSE, 0, "R_IP2K_HI8DATA", 0, 0x00ff),
d184 2
a185 2
  IP2K_HOWTO (R_IP2K_LO8INSN, 1,1,8, FALSE, 0, "R_IP2K_LO8INSN", 0, 0x00ff),
  IP2K_HOWTO (R_IP2K_HI8INSN, 9,1,8, FALSE, 0, "R_IP2K_HI8INSN", 0, 0x00ff),
d188 1
a188 1
  IP2K_HOWTO (R_IP2K_PC_SKIP, 1,1,1, FALSE, 12, "R_IP2K_PC_SKIP", 0xfffe, 0x1000),
d190 1
a190 1
  IP2K_HOWTO (R_IP2K_TEXT, 1,1,16, FALSE, 0, "R_IP2K_TEXT", 0, 0xffff),
d192 1
a192 1
  IP2K_HOWTO (R_IP2K_FR_OFFSET, 0,1,9, FALSE, 0, "R_IP2K_FR_OFFSET", 0x180, 0x007f),
d194 1
a194 1
  IP2K_HOWTO (R_IP2K_EX8DATA, 16,1,8, FALSE, 0, "R_IP2K_EX8DATA", 0, 0x00ff),
d259 2
a260 2
     Elf_Internal_Sym *isymbuf;
     Elf_Internal_Rela *irel;
d299 1
a299 1

d313 1
a313 1

d325 1
a325 1
static bfd_boolean
d327 1
a327 1
     bfd *abfd ATTRIBUTE_UNUSED;
d329 1
a329 1
     bfd_boolean relaxed;
d335 1
a335 1
    return FALSE;
d342 1
a342 1
    return FALSE;
d355 1
a355 1
	return FALSE;
d362 1
a362 1
        return FALSE;
d367 1
a367 1
  return TRUE;
d373 1
a373 1

d394 1
a394 1

d410 1
a410 1
static bfd_boolean
d414 1
a414 1
     bfd_boolean relaxed;
d420 1
a420 1
    return FALSE;
d427 1
a427 1
    return FALSE;
d434 1
a434 1
    return FALSE;
d441 1
a441 1
    return FALSE;
d454 1
a454 1
	return FALSE;
d458 1
a458 1

d461 1
a461 1
        return FALSE;
d468 1
a468 1
	return FALSE;
d473 1
a473 1
  return TRUE;
d476 1
a476 1
static bfd_boolean
d489 1
a489 1
	  && is_switch_128_dispatch_table_p (abfd, addr, FALSE, misc))
d493 1
a493 1
	  return TRUE;
d497 1
a497 1
	  && is_switch_256_dispatch_table_p (abfd, addr, FALSE, misc))
d501 1
a501 1
	  return TRUE;
d504 2
a505 2

  return TRUE;
d508 1
a508 1
static bfd_boolean
d514 1
a514 1
     bfd_boolean *changed;
d546 1
a546 1
                        return FALSE;
d548 1
a548 1
		      *changed = TRUE;
d556 1
a556 1
	      return FALSE;
d565 1
a565 1
	 return FALSE;
d568 1
a568 1
  return TRUE;
d571 1
a571 1
static bfd_boolean
d576 1
a576 1
     bfd_boolean *changed;
d597 1
a597 1
          && is_switch_128_dispatch_table_p (abfd, addr, TRUE, misc))
d601 1
a601 1
	  bfd_boolean relaxed = TRUE;
d615 1
a615 1
		  relaxed = FALSE;
d628 1
a628 1
	    return FALSE;
d637 1
a637 1
	        return FALSE;
d639 1
a639 1
	      if (! is_switch_128_dispatch_table_p (abfd, addr, TRUE, misc))
d641 2
a642 2
		return FALSE;

d652 1
a652 1
                return FALSE;
d655 1
a655 1
          return TRUE;
d659 1
a659 1
          && is_switch_256_dispatch_table_p (abfd, addr, TRUE, misc))
d663 1
a663 1
          bfd_boolean relaxed = TRUE;
d685 1
a685 1
	    return FALSE;
d688 1
a688 1
	  last = first;
d697 1
a697 1
                  relaxed = FALSE;
d709 1
a709 1
            return FALSE;
d717 1
a717 1
		return FALSE;
d719 2
a720 2
              if (! is_switch_256_dispatch_table_p (abfd, addr, TRUE, misc))
		return FALSE;
d730 1
a730 1
		return FALSE;
d738 1
a738 1
		return FALSE;
d746 1
a746 1
		return FALSE;
d749 1
a749 1
          return TRUE;
d753 1
a753 1
  return TRUE;
d758 1
a758 1
static bfd_boolean
d763 1
a763 1
     bfd_boolean *again;
d771 2
a772 2
  static bfd_boolean changed = FALSE;
  static bfd_boolean final_pass = FALSE;
d778 1
a778 1
  *again = FALSE;
d785 1
a785 1
      changed = FALSE;
d794 1
a794 1
    return FALSE;
d803 1
a803 1
    return TRUE;
d852 1
a852 1

d869 1
a869 1

d886 1
a886 1
      /* Add page instructions back in as needed but we ignore
d914 1
a914 1
	  /* If this was the final pass and we didn't reset
d919 2
a920 2
	      final_pass = TRUE;
	      *again = TRUE;
d925 1
a925 1
  /* Perform some house keeping after relaxing the section.  */
d952 1
a952 1
  return TRUE;
d964 1
a964 1
  return FALSE;
d969 1
a969 1
static bfd_boolean
d973 1
a973 1
     bfd_boolean *again;
d1000 2
a1001 2
	      return FALSE;

d1010 1
a1010 1
	      return FALSE;
d1014 1
a1014 1
	    *again = TRUE;
d1019 1
a1019 1
  return TRUE;
d1024 1
a1024 1
static bfd_boolean
d1028 2
a1029 2
     bfd_boolean *again;
     bfd_boolean *final_pass;
d1034 1
a1034 1
  bfd_boolean add_all;
d1058 1
a1058 1
		return FALSE;
d1063 1
a1063 1
    add_all = FALSE;
d1103 1
a1103 1
		  return FALSE;
d1106 1
a1106 1
		  add_all = FALSE;
d1120 1
a1120 1
		      return FALSE;
d1123 1
a1123 1
		    *again = TRUE;
d1129 1
a1129 1

d1132 1
a1132 1
    *final_pass = FALSE;
d1134 1
a1134 1
  return TRUE;
d1165 1
a1165 1

d1167 1
a1167 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1248 1
a1248 1
static bfd_boolean
d1265 1
a1265 1
    return FALSE;
d1268 1
a1268 1
       Elf_Internal_Rela * jrel = irel - 1;
d1275 1
a1275 1

d1292 1
a1292 1
	   return FALSE;
d1301 1
a1301 1
   return TRUE;
d1306 1
a1306 1
static bfd_boolean
d1323 1
a1323 1

d1327 1
a1327 1
  return TRUE;
d1332 1
a1332 1
static bfd_boolean
d1349 1
a1349 1
  return TRUE;
d1363 1
a1363 1
     Elf_Internal_Rela * dst;
d1470 1
a1470 1
static bfd_boolean
d1473 13
a1485 13
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d1488 1
a1488 1
    return TRUE;
d1505 1
a1505 1

d1513 1
a1513 1

d1519 1
a1519 1

d1527 1
a1527 1

d1533 1
a1533 1

d1550 1
a1550 1
		return FALSE;
d1570 1
a1570 1

d1573 1
a1573 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d1575 1
a1575 1

d1601 1
a1601 1
	    return FALSE;
d1605 1
a1605 1
  return TRUE;
d1620 1
a1620 1
#if 0
d1654 1
a1654 1
static bfd_boolean
d1662 1
a1662 1
  return TRUE;
@


1.3.10.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a35 6
struct ip2k_opcode
{
  unsigned short opcode;
  unsigned short mask;
};
  
d39 8
a46 2
static int ip2k_is_opcode
  PARAMS ((bfd_byte *, const struct ip2k_opcode *));
a49 20
static void ip2k_get_mem
  PARAMS ((bfd *, bfd_byte *, int, bfd_byte *));
static bfd_vma ip2k_nominal_page_bits
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_test_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, struct misc *));
static bfd_boolean ip2k_delete_page_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_128
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_128
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static int ip2k_is_switch_table_256
  PARAMS ((bfd *, asection *, bfd_vma, bfd_byte *));
static bfd_boolean ip2k_relax_switch_table_256
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *, bfd_boolean *, struct misc *));
static bfd_boolean ip2k_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean ip2k_elf_relax_section_page
  PARAMS ((bfd *, asection *, bfd_boolean *, struct misc *, unsigned long, unsigned long));
d54 20
a73 2
static void ip2k_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
a79 6
static asection *ip2k_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean ip2k_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d81 5
a85 1
static bfd_boolean ip2k_relaxed = FALSE;
d87 1
a87 1
static const struct ip2k_opcode ip2k_page_opcode[] =
d89 1
a89 2
  {0x0010, 0xFFF8},	/* page */
  {0x0000, 0x0000},
d92 5
a96 2
#define IS_PAGE_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_page_opcode)
d98 1
a98 1
static const struct ip2k_opcode ip2k_jmp_opcode[] =
d100 1
a100 2
  {0xE000, 0xE000},	/* jmp */
  {0x0000, 0x0000},
d103 2
a104 2
#define IS_JMP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_jmp_opcode)
d106 4
a109 1
static const struct ip2k_opcode ip2k_call_opcode[] =
d111 1
a111 2
  {0xC000, 0xE000},	/* call */
  {0x0000, 0x0000},
d114 5
a118 2
#define IS_CALL_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_call_opcode)
d120 1
a120 1
static const struct ip2k_opcode ip2k_snc_opcode[] =
d122 1
a122 2
  {0xA00B, 0xFFFF},	/* snc */
  {0x0000, 0x0000},
d125 5
a129 2
#define IS_SNC_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_snc_opcode)
d131 1
a131 1
static const struct ip2k_opcode ip2k_inc_1sp_opcode[] =
d133 1
a133 2
  {0x2B81, 0xFFFF},	/* inc 1(SP) */
  {0x0000, 0x0000},
d136 2
a137 2
#define IS_INC_1SP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_inc_1sp_opcode)
d139 4
a142 1
static const struct ip2k_opcode ip2k_add_2sp_w_opcode[] =
d144 1
a144 2
  {0x1F82, 0xFFFF},	/* add 2(SP),w */
  {0x0000, 0x0000},
d147 5
a151 2
#define IS_ADD_2SP_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_2sp_w_opcode)
d153 1
a153 1
static const struct ip2k_opcode ip2k_add_w_wreg_opcode[] =
d155 1
a155 3
  {0x1C0A, 0xFFFF},	/* add w,wreg */
  {0x1E0A, 0xFFFF},	/* add wreg,w */
  {0x0000, 0x0000},
d158 2
a159 8
#define IS_ADD_W_WREG_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_w_wreg_opcode)

static const struct ip2k_opcode ip2k_add_pcl_w_opcode[] =
{
  {0x1E09, 0xFFFF},	/* add pcl,w */
  {0x0000, 0x0000},
};
d161 2
a162 2
#define IS_ADD_PCL_W_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_add_pcl_w_opcode)
d164 1
a164 1
static const struct ip2k_opcode ip2k_skip_opcodes[] =
d166 1
a166 9
  {0xB000, 0xF000},	/* sb */
  {0xA000, 0xF000},	/* snb */
  {0x7600, 0xFE00},	/* cse/csne #lit */
  {0x5800, 0xFC00},	/* incsnz */
  {0x4C00, 0xFC00},	/* decsnz */
  {0x4000, 0xFC00},	/* cse/csne */
  {0x3C00, 0xFC00},	/* incsz */
  {0x2C00, 0xFC00},	/* decsz */
  {0x0000, 0x0000},
d169 2
a170 2
#define IS_SKIP_OPCODE(code) \
  ip2k_is_opcode (code, ip2k_skip_opcodes)
d172 1
a172 1
/* Relocation tables.  */
d190 1
a190 1
  /* This reloc does nothing.  */
d222 1
a222 1
/* Map BFD reloc types to IP2K ELF reloc types.  */
d231 1
a231 1
     include/elf/ip2k.h.  */
d266 1
a266 1
      /* Pacify gcc -Wall.  */
d272 1
a272 30
static void
ip2k_get_mem (abfd, addr, length, ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_byte *addr;
     int length;
     bfd_byte *ptr;
{
  while (length --)
    * ptr ++ = bfd_get_8 (abfd, addr ++);
}

static bfd_boolean
ip2k_is_opcode (code, opcodes)
     bfd_byte *code;
     const struct ip2k_opcode *opcodes;
{
  unsigned short insn = (code[0] << 8) | code[1];

  while (opcodes->mask != 0)
    {
      if ((insn & opcodes->mask) == opcodes->opcode)
	return TRUE;

      opcodes ++;
    }

  return FALSE;
}

#define PAGENO(ABSADDR) ((ABSADDR) & 0xFFFFC000)
a319 109
/* Returns the expected page state for the given instruction not including
   the effect of page instructions.  */

static bfd_vma
ip2k_nominal_page_bits (abfd, sec, addr, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     bfd_vma addr;
     bfd_byte *contents;
{
  bfd_vma page = PAGENO (BASEADDR (sec) + addr);

  /* Check if section flows into this page. If not then the page
     bits are assumed to match the PC. This will be true unless
     the user has a page instruction without a call/jump, in which
     case they are on their own.  */
  if (PAGENO (BASEADDR (sec)) == page)
    return page;

  /* Section flows across page boundary. The page bits should match
     the PC unless there is a possible flow from the previous page,
     in which case it is not possible to determine the value of the
     page bits.  */
  while (PAGENO (BASEADDR (sec) + addr - 2) == page)
    {
      bfd_byte code[2];

      addr -= 2;
      ip2k_get_mem (abfd, contents + addr, 2, code);
      if (!IS_PAGE_OPCODE (code))
	continue;

      /* Found a page instruction, check if jump table.  */
      if (ip2k_is_switch_table_128 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      if (ip2k_is_switch_table_256 (abfd, sec, addr, contents) != -1)
	/* Jump table => page is conditional.  */
	continue;

      /* Found a page instruction, check if conditional.  */
      if (addr >= 2)
        {
	  ip2k_get_mem (abfd, contents + addr - 2, 2, code);
          if (IS_SKIP_OPCODE (code))
	    /* Page is conditional.  */
	    continue;
        }

      /* Unconditional page instruction => page bits should be correct.  */
      return page;
    }

  /* Flow from previous page => page bits are impossible to determine.  */
  return 0;
}

static bfd_boolean
ip2k_test_page_insn (abfd, sec, irel, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     struct misc *misc;
{
  bfd_vma symval;

  /* Get the value of the symbol referred to by the reloc.  */
  symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf, irel);
  if (symval == UNDEFINED_SYMBOL)
    /* This appears to be a reference to an undefined
       symbol.  Just ignore it--it will be caught by the
       regular reloc processing.  */
    return FALSE;

  /* Test if we can delete this page instruction.  */
  if (PAGENO (symval + irel->r_addend) !=
      ip2k_nominal_page_bits (abfd, sec, irel->r_offset, misc->contents))
    return FALSE;

  return TRUE;
}

static bfd_boolean
ip2k_delete_page_insn (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  /* Note that we've changed the relocs, section contents, etc.  */
  elf_section_data (sec)->relocs = misc->irelbase;
  elf_section_data (sec)->this_hdr.contents = misc->contents;
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;

  /* Fix the relocation's type.  */
  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_IP2K_NONE);

  /* Delete the PAGE insn.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset, 2))
    return FALSE;
	
  /* Modified => will need to iterate relaxation again.  */
  *again = TRUE;
  
  return TRUE;
}

d349 2
a350 2
static int
ip2k_is_switch_table_128 (abfd, sec, addr, contents)
a351 1
     asection *sec;
d353 2
a354 1
     bfd_byte *contents;
d356 1
a356 28
  bfd_byte code[4];
  int index = 0;
  
  /* Check current page-jmp.  */
  if (addr + 4 > sec->_cooked_size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);

  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;
  
  /* Search back.  */
  while (1)
    {
      if (addr < 4)
	return -1;

      /* Check previous 2 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 4, 4, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_ADD_PCL_W_OPCODE (code + 2)))
	return index;

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;
d358 2
a359 4
      index++;
      addr -= 4;
    }
}
d361 2
a362 32
static bfd_boolean
ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
     struct misc *misc;
{
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[4];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;
  while (1)
    {
      if (addr + 4 > sec->_cooked_size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d364 3
a366 5
      if (ireltest->r_offset != addr)
        {
	  _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d368 2
a369 3
      if (! ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;
d371 3
a373 3
      addr += 4;
      ireltest += 2;
    }
d375 1
a375 4
  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 4, code);
  if ((! IS_ADD_W_WREG_OPCODE (code + 0))
      || (! IS_ADD_PCL_W_OPCODE (code + 2)))
d377 3
a379 6
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }

  if (!ip2k_elf_relax_delete_bytes (abfd, sec, irel->r_offset - 4, 2))
    return FALSE;
d381 2
a382 1
  *again = TRUE;
d384 3
a386 6
  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
d389 2
d434 2
a435 2
static int
ip2k_is_switch_table_256 (abfd, sec, addr, contents)
d437 66
d505 35
a539 1
     bfd_byte *contents;
d541 1
a541 42
  bfd_byte code[16];
  int index = 0;
  
  /* Check current page-jmp.  */
  if (addr + 4 > sec->_cooked_size)
    return -1;

  ip2k_get_mem (abfd, contents + addr, 4, code);
  if ((! IS_PAGE_OPCODE (code + 0))
      || (! IS_JMP_OPCODE (code + 2)))
    return -1;
  
  /* Search back.  */
  while (1)
    {
      if (addr < 16)
	return -1;

      /* Check previous 8 instructions.  */
      ip2k_get_mem (abfd, contents + addr - 16, 16, code);
      if ((IS_ADD_W_WREG_OPCODE (code + 0))
	  && (IS_SNC_OPCODE (code + 2))
	  && (IS_INC_1SP_OPCODE (code + 4))
	  && (IS_ADD_2SP_W_OPCODE (code + 6))
	  && (IS_SNC_OPCODE (code + 8))
	  && (IS_INC_1SP_OPCODE (code + 10))
	  && (IS_PAGE_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return index;

      if ((IS_ADD_W_WREG_OPCODE (code + 2))
	  && (IS_SNC_OPCODE (code + 4))
	  && (IS_INC_1SP_OPCODE (code + 6))
	  && (IS_ADD_2SP_W_OPCODE (code + 8))
	  && (IS_SNC_OPCODE (code + 10))
	  && (IS_INC_1SP_OPCODE (code + 12))
	  && (IS_JMP_OPCODE (code + 14)))
	return index;
      
      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	return -1;
d543 47
a589 2
      index++;
      addr -= 4;
d591 2
d596 2
a597 2
ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc)
     bfd *abfd ATTRIBUTE_UNUSED;
d599 2
a600 2
     Elf_Internal_Rela *irel;
     bfd_boolean *again;
d603 19
a621 22
  Elf_Internal_Rela *irelend = misc->irelbase + sec->reloc_count;
  Elf_Internal_Rela *ireltest = irel;
  bfd_byte code[12];
  bfd_vma addr;
  
  /* Test all page instructions.  */
  addr = irel->r_offset;

  while (1)
    {
      if (addr + 4 > sec->_cooked_size)
	break;

      ip2k_get_mem (abfd, misc->contents + addr, 4, code);

      if ((! IS_PAGE_OPCODE (code + 0))
	  || (! IS_JMP_OPCODE (code + 2)))
	break;

      /* Validate relocation entry (every entry should have a matching
          relocation entry).  */
      if (ireltest >= irelend)
d623 57
a679 2
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
d682 2
a683 1
      if (ireltest->r_offset != addr)
d685 28
a712 3
          _bfd_error_handler (_("ip2k relaxer: switch table without complete matching relocation information."));
          return FALSE;
        }
d714 28
a741 7
      if (!ip2k_test_page_insn (abfd, sec, ireltest, misc))
	/* Un-removable page insn => nothing can be done.  */
	return TRUE;

      addr += 4;
      ireltest += 2;
    }
d743 2
a744 6
  /* Relaxable. Adjust table header.  */
  ip2k_get_mem (abfd, misc->contents + irel->r_offset - 4, 2, code);
  if (IS_PAGE_OPCODE (code))
    addr = irel->r_offset - 16;
  else
    addr = irel->r_offset - 14;
d746 1
a746 11
  ip2k_get_mem (abfd, misc->contents + addr, 12, code);
  if ((!IS_ADD_W_WREG_OPCODE (code + 0))
      || (!IS_SNC_OPCODE (code + 2))
      || (!IS_INC_1SP_OPCODE (code + 4))
      || (!IS_ADD_2SP_W_OPCODE (code + 6))
      || (!IS_SNC_OPCODE (code + 8))
      || (!IS_INC_1SP_OPCODE (code + 10)))
    {
      _bfd_error_handler (_("ip2k relaxer: switch table header corrupt."));
      return FALSE;
    }
d748 7
a754 3
  /* Delete first 3 opcodes.  */
  if (!ip2k_elf_relax_delete_bytes (abfd, sec, addr + 0, 6))
    return FALSE;
d756 7
a762 1
  *again = TRUE;
d764 11
a774 6
  /* Delete all page instructions in table.  */
  while (irel < ireltest)
    {
      if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	return FALSE;
      irel += 2;
d780 1
a780 9
/* This function handles relaxing for the ip2k.

   Principle: Start with the first page and remove page instructions that
   are not require on this first page. By removing page instructions more
   code will fit into this page - repeat until nothing more can be achieved
   for this page. Move on to the next page.

   Processing the pages one at a time from the lowest page allows a removal
   only policy to be used - pages can be removed but are never reinserted.  */
d794 3
a796 3
  static unsigned long search_addr;
  static unsigned long page_start = 0;
  static unsigned long page_end = 0;
a797 2
  static bfd_boolean new_pass = FALSE;
  static bfd_boolean changed = FALSE;
d805 1
a805 4
    {
      ip2k_relaxed = TRUE;
      first_section = sec;
    }
d809 1
a810 1
      new_pass = TRUE;
d813 7
d829 3
d895 2
a896 1
  if ((pass == 1) || (new_pass && !changed))
d898 4
a901 11
      /* On the first pass we simply search for the lowest page that
         we havn't relaxed yet. Note that the pass count is reset
         each time a page is complete in order to move on to the next page.
         If we can't find any more pages then we are finished.  */
      if (new_pass)
	{
	  pass = 1;
	  new_pass = FALSE;
	  changed = TRUE; /* Pre-initialize to break out of pass 1.  */
	  search_addr = 0xFFFFFFFF;
	}
d903 2
a904 7
      if ((BASEADDR (sec) + sec->_cooked_size < search_addr)
	  && (BASEADDR (sec) + sec->_cooked_size > page_end))
	{
	  if (BASEADDR (sec) <= page_end)
	    search_addr = page_end + 1;
	  else
	    search_addr = BASEADDR (sec);
d906 1
a906 3
	  /* Found a page => more work to do.  */
	  *again = TRUE;
	}
d910 23
a932 7
      if (new_pass)
	{
	  new_pass = FALSE;
	  changed = FALSE;
	  page_start = PAGENO (search_addr);
	  page_end = page_start | 0x00003FFF;
	}
d934 3
a936 3
      /* Only process sections in range.  */
      if ((BASEADDR (sec) + sec->_cooked_size >= page_start)
	  && (BASEADDR (sec) <= page_end))
d938 8
a945 2
          if (!ip2k_elf_relax_section_page (abfd, sec, &changed, &misc, page_start, page_end))
	    return FALSE;
a946 1
      *again = TRUE;
d991 1
a991 1
/* This function handles relaxation of a section in a specific page.  */
d994 1
a994 1
ip2k_elf_relax_section_page (abfd, sec, again, misc, page_start, page_end)
d998 1
a998 3
     struct misc *misc;
     unsigned long page_start;
     unsigned long page_end;
d1002 1
a1002 3
  int switch_table_128;
  int switch_table_256;
  
d1006 36
a1041 21
      if (ELF32_R_TYPE (irel->r_info) != (int) R_IP2K_PAGE3)
	/* Ignore non page instructions.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset < page_start)
	/* Ignore page instructions on earlier page - they have
	   already been processed. Remember that there is code flow
	   that crosses a page boundary.  */
	continue;

      if (BASEADDR (sec) + irel->r_offset > page_end)
	/* Flow beyond end of page => nothing more to do for this page.  */
	return TRUE;

      /* Detect switch tables.  */
      switch_table_128 = ip2k_is_switch_table_128 (abfd, sec, irel->r_offset, misc->contents);
      switch_table_256 = ip2k_is_switch_table_256 (abfd, sec, irel->r_offset, misc->contents);

      if ((switch_table_128 > 0) || (switch_table_256 > 0))
	/* If the index is greater than 0 then it has already been processed.  */
	continue;
d1043 4
a1046 4
      if (switch_table_128 == 0)
	{
	  if (!ip2k_relax_switch_table_128 (abfd, sec, irel, again, misc))
	    return FALSE;
d1048 11
a1058 2
	  continue;
	}
d1060 13
a1072 1
      if (switch_table_256 == 0)
d1074 10
a1083 4
	  if (!ip2k_relax_switch_table_256 (abfd, sec, irel, again, misc))
	    return FALSE;

	  continue;
d1085 3
d1089 18
a1106 5
      /* Simple relax.  */
      if (ip2k_test_page_insn (abfd, sec, irel, misc))
	{
	  if (!ip2k_delete_page_insn (abfd, sec, irel, again, misc))
	    return FALSE;
d1108 44
a1151 2
	  continue;
	}
d1154 4
a1188 1
  asection *stab;
a1230 126
  /* Now fix the stab relocations.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
  if (stab)
    {
      bfd_byte *stabcontents, *stabend, *stabp;

      irelbase = elf_section_data (stab)->relocs;
      irelend = irelbase + stab->reloc_count;

      /* Pull out the contents of the stab section.  */
      if (elf_section_data (stab)->this_hdr.contents != NULL)
	stabcontents = elf_section_data (stab)->this_hdr.contents;
      else
	{
	  stabcontents = (bfd_byte *) bfd_alloc (abfd, stab->_raw_size);
	  if (stabcontents == NULL)
	    return;

	  if (! bfd_get_section_contents (abfd, stab, stabcontents,
					  (file_ptr) 0, stab->_raw_size))
	    return;

	  /* We need to remember this.  */
	  elf_section_data (stab)->this_hdr.contents = stabcontents;
	}

      stabend = stabcontents + stab->_raw_size;

      for (irel = irelbase; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
	    {
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
		{
		  asection *sym_sec;
		  
		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);
		  sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  
		  if (sym_sec == sec)
		    {
		      const char *name;
		      unsigned long strx;
		      unsigned char type, other;
		      unsigned short desc;
		      bfd_vma value;
		      bfd_vma baseaddr = BASEADDR (sec);
		      bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
			+ irel->r_addend;
		      
		      if ((baseaddr + addr) <= symval
			  && symval <= (baseaddr + endaddr))
			irel->r_addend += count;

		      /* Go hunt up a function and fix its line info if needed.  */
		      stabp = stabcontents + irel->r_offset - 8; 

		      /* Go pullout the stab entry.  */
		      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
		      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
		      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
		      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
		      value = bfd_h_get_32 (abfd, stabp + VALOFF);
		      
		      name = bfd_get_stab_name (type);
		      
		      if (strcmp (name, "FUN") == 0)
			{
			  int function_adjusted = 0;

			  if (symval > (baseaddr + addr))
			    /* Not in this function.  */
			    continue;

			  /* Hey we got a function hit.  */
			  stabp += STABSIZE;
			  for (;stabp < stabend; stabp += STABSIZE)
			    {
			      /* Go pullout the stab entry.  */
			      strx  = bfd_h_get_32 (abfd, stabp + STRDXOFF);
			      type  = bfd_h_get_8 (abfd, stabp + TYPEOFF);
			      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
			      desc  = bfd_h_get_16 (abfd, stabp + DESCOFF);
			      value = bfd_h_get_32 (abfd, stabp + VALOFF);

			      name = bfd_get_stab_name (type);

			      if (strcmp (name, "FUN") == 0)
				{
				  /* Hit another function entry.  */
				  if (function_adjusted)
				    {
				      /* Adjust the value.  */
				      value += count;
				  
				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				    }

				  /* And then bale out.  */
				  break;
				}

			      if (strcmp (name, "SLINE") == 0)
				{
				  /* Got a line entry.  */
				  if ((baseaddr + addr) <= (symval + value))
				    {
				      /* Adjust the line entry.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				      function_adjusted = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

a1256 1

d1263 3
a1265 1
	    sym_hash->root.u.def.value += count;
d1272 82
d1413 1
a1413 1
  static bfd_vma page_addr = 0;
a1414 1
  bfd_reloc_status_type r = bfd_reloc_ok;
d1432 1
a1433 38
      page_addr = BASEADDR (input_section) + rel->r_offset;
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

    case R_IP2K_ADDR16CJP:
      if (BASEADDR (input_section) + rel->r_offset != page_addr + 2)
	{
	  /* No preceeding page instruction, verify that it isn't needed.  */
	  if (PAGENO (relocation + rel->r_addend) !=
	      ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset, contents))
	    _bfd_error_handler (_("ip2k linker: missing page instruction at 0x%08lx (dest = 0x%08lx)."),
				BASEADDR (input_section) + rel->r_offset,
				relocation + rel->r_addend);
        }
      else if (ip2k_relaxed)
        {
          /* Preceeding page instruction. Verify that the page instruction is
             really needed. One reason for the relaxation to miss a page is if
             the section is not marked as executable.  */
	  if (!ip2k_is_switch_table_128 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      !ip2k_is_switch_table_256 (input_bfd, input_section, rel->r_offset - 2, contents) &&
	      (PAGENO (relocation + rel->r_addend) ==
	       ip2k_nominal_page_bits (input_bfd, input_section,
	      			      rel->r_offset - 2, contents)))
	    _bfd_error_handler (_("ip2k linker: redundant page instruction at 0x%08lx (dest = 0x%08lx)."),
				page_addr,
				relocation + rel->r_addend);
        }
      if ((relocation & IP2K_INSN_MASK) == IP2K_INSN_VALUE)
	relocation &= ~IP2K_INSN_MASK;
      else
	r = bfd_reloc_notsupported;
      break;

a1563 1

d1565 3
a1567 2
	    relocation = 0;

d1671 3
a1673 1
	 return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1685 1
a1685 1
  /* We don't use got and plt entries for ip2k.  */
d1689 4
d1699 1
a1699 1
#define ELF_MAXPAGESIZE  1 /* No pages on the IP2K.  */
d1708 1
d1714 1
@


1.3.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d850 3
a852 3
  internal_relocs = _bfd_elf_link_read_relocs (abfd, sec, NULL,
					       (Elf_Internal_Rela *)NULL,
					       link_info->keep_memory);
d864 3
a866 3
      irelbase = _bfd_elf_link_read_relocs (abfd, stab, NULL,
					    (Elf_Internal_Rela *)NULL,
					    link_info->keep_memory);
@


1.3.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d837 1
a837 1
  if (link_info->relocatable
d1459 1
a1459 1
   necessary, and (if using Rela relocs and generating a relocatable
d1473 1
a1473 1
   When generating relocatable output, this function must handle
d1496 1
a1496 1
  if (info->relocatable)
@


1.3.10.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1535 1
a1535 2
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
d1537 3
a1539 1
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr, relocation, sec, unresolved_reloc, info, warned);
d1542 20
@


1.3.10.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1010 1
a1010 1
  /* Walk thru the section looking for relaxation opportunities.  */
d1391 1
a1391 1
	  /* No preceding page instruction, verify that it isn't needed.  */
d1401 1
a1401 1
          /* Preceding page instruction. Verify that the page instruction is
@


1.2
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d1 1
a1 1
/* Scenix IP2xxx specific support for 32-bit ELF
d33 1
a33 4
  bfd_byte *           free_contents;
  Elf32_External_Sym * extsyms;
  Elf32_External_Sym * free_extsyms;
  Elf_Internal_Rela *  free_relocs;
d41 1
a41 1
static bfd_vma               symbol_value                         PARAMS ((bfd *, Elf_Internal_Shdr *, Elf32_External_Sym *, Elf_Internal_Rela *));
a51 1
static void                  tidyup_after_error                   PARAMS ((struct misc *));
d256 1
a256 1
symbol_value (abfd, symtab_hdr, extsyms, irel)
d259 1
a259 1
     Elf32_External_Sym *extsyms;
d264 1
a264 3
      Elf_External_Sym_Shndx *sym_shndx;
      Elf_Internal_Shdr *shndx_hdr;
      Elf_Internal_Sym isym;
d267 2
a268 6
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      sym_shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
      sym_shndx = sym_shndx ? sym_shndx + ELF32_R_SYM (irel->r_info) : NULL;
      bfd_elf32_swap_symbol_in (abfd, extsyms + ELF32_R_SYM (irel->r_info),
				sym_shndx, &isym);
      if (isym.st_shndx == SHN_UNDEF)
d270 1
a270 1
      else if (isym.st_shndx == SHN_ABS)
d272 1
a272 1
      else if (isym.st_shndx == SHN_COMMON)
d275 1
a275 1
	sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d277 1
a277 1
      return isym.st_value + BASEADDR (sym_sec);
d765 4
a768 2
  Elf_External_Sym_Shndx *shndx_buf;
  Elf_Internal_Shdr *shndx_hdr;
a807 8
  misc.symtab_hdr = NULL;
  misc.irelbase = NULL;
  misc.contents = NULL;
  misc.free_contents = NULL;
  misc.extsyms = NULL;
  misc.free_extsyms = NULL;
  misc.free_relocs = NULL;

d813 1
a813 11
  misc.symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;

  misc.irelbase = _bfd_elf32_link_read_relocs (abfd, sec, NULL,
					     (Elf_Internal_Rela *)NULL,
					     link_info->keep_memory);
  if (misc.irelbase == NULL)
    {
      tidyup_after_error (&misc);
      return false;
    }
d815 5
a819 2
  if (! link_info->keep_memory)
    misc.free_relocs = misc.irelbase;
d835 1
a835 3
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    misc.contents = elf_section_data (sec)->this_hdr.contents;
  else
d837 4
a840 12
      /* Go get them of disk.  */
      misc.contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
      if (misc.contents == NULL)
	{
	  tidyup_after_error (&misc);
	  return false;
	}

      misc.free_contents = misc.contents;
      if (! bfd_get_section_contents (abfd, sec, misc.contents,
				      (file_ptr)0,
				      sec->_raw_size))
d842 8
a849 2
	  tidyup_after_error (&misc);
	  return false;
d852 1
a852 1
  
d854 1
a854 3
  if (misc.symtab_hdr->contents != NULL)
    misc.extsyms = (Elf32_External_Sym *) misc.symtab_hdr->contents;
  else
d856 7
a862 36
      /* Go get them off disk.  */
      misc.extsyms = ((Elf32_External_Sym *)bfd_malloc (misc.symtab_hdr->sh_size));
      if (misc.extsyms == NULL)
	{
	  tidyup_after_error (&misc);
	  return false;
	}

      misc.free_extsyms = misc.extsyms;
      if (bfd_seek (abfd, misc.symtab_hdr->sh_offset, SEEK_SET) != 0
          || (bfd_read (misc.extsyms, 1, misc.symtab_hdr->sh_size, abfd)
          != misc.symtab_hdr->sh_size))
	{
	  tidyup_after_error (&misc);
	  return false;
	}
    }

  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;

      amt = misc.symtab_hdr->sh_info * sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	{
	  tidyup_after_error (&misc);
	  return false;
	}
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
	{
	  tidyup_after_error (&misc);
	  return false;
	}
      shndx_hdr->contents = (PTR) shndx_buf;
d865 5
d880 1
a880 4
        {
	  tidyup_after_error (&misc);
	  return false;
        }
d904 3
a906 6
      if (! ip2k_elf_relax_section_passN (abfd, sec, again,
					 &final_pass,  &misc))
	{
	  tidyup_after_error (&misc);
	  return false;
	}
d927 2
a928 1
  if (misc.free_relocs != NULL)
d930 4
a933 2
      free (misc.free_relocs);
      misc.free_relocs = NULL;
d936 2
a937 1
  if (misc.free_contents != NULL)
d940 1
a940 1
	free (misc.free_contents);
d944 1
a944 1
	  elf_section_data (sec)->this_hdr.contents = misc.contents;
a945 2

      misc.free_contents = NULL;
d948 3
a950 12
  if (misc.free_extsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (misc.free_extsyms);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  misc.symtab_hdr->contents = misc.extsyms;
	}

      misc.free_extsyms = NULL;
    }
a952 23
}

static void
tidyup_after_error (misc)
     struct misc *misc;
{
  if (misc->free_relocs != NULL)
    {
      free (misc->free_relocs);
      misc->free_relocs = NULL;
    }

  if (misc->free_contents != NULL)
    {
      free (misc->free_contents);
      misc->free_contents = NULL;
    }

  if (misc->free_extsyms != NULL)
    {
      free (misc->free_extsyms);
      misc->free_extsyms = NULL;
    }
d954 11
a964 1
  return;
a993 2
	    misc->free_relocs = NULL;

d995 1
a995 4
	    misc->free_contents = NULL;

	    misc->symtab_hdr->contents = (bfd_byte *) misc->extsyms;
	    misc->free_extsyms = NULL;
d1072 1
a1072 1
        bfd_vma symval = symbol_value (abfd, misc->symtab_hdr, misc->extsyms,
d1158 2
a1159 2
  Elf32_External_Sym *extsyms;
  int shndx, index;
d1162 3
a1164 5
  Elf32_External_Sym *esym, *esymend;
  asection *stab;
  bfd_byte *stabp, *stabend, *stabcontents;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_External_Sym_Shndx *sym_shndx;
d1167 1
a1167 1
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
a1182 1
              Elf_Internal_Sym isym;
a1183 2
	      Elf_External_Sym_Shndx *sym_shndx;
	      Elf_Internal_Shdr *shndx_hdr;
d1186 2
a1187 17
	      
	      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
	      sym_shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
	      sym_shndx = (sym_shndx
			   ? sym_shndx + ELF32_R_SYM (irel->r_info) : NULL);
              bfd_elf32_swap_symbol_in (abfd,
					extsyms + ELF32_R_SYM (irel->r_info),
					sym_shndx, &isym);

	      if (isym.st_shndx == SHN_UNDEF)
		sym_sec = bfd_und_section_ptr;
	      else if (isym.st_shndx == SHN_ABS)
		sym_sec = bfd_abs_section_ptr;
	      else if (isym.st_shndx == SHN_COMMON)
		sym_sec = bfd_com_section_ptr;
	      else
		sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
d1189 1
a1189 1
              if (sym_sec == sec)
d1192 1
a1192 1
                  bfd_vma symval = BASEADDR (sym_sec) + isym.st_value
a1206 142
  /* Now fix the stab relocations.  */
  stab = bfd_get_section_by_name (abfd, ".stab");
  if (stab)
    {
      irelbase = elf_section_data (stab)->relocs;
      irelend = irelbase + stab->reloc_count;

      /* Pull out the contents of the stab section.  */
      if (elf_section_data (stab)->this_hdr.contents != NULL)
	stabcontents = elf_section_data (stab)->this_hdr.contents;
      else
	{
	  stabcontents = (bfd_byte *) bfd_alloc (abfd, stab->_raw_size);
	  if (stabcontents == NULL)
	    return;
	  if (! bfd_get_section_contents (abfd, stab, stabcontents,
					  (file_ptr) 0, stab->_raw_size))
	    return;

	  /* We need to remember this.  */
	  elf_section_data (stab)->this_hdr.contents = stabcontents;
	}

      stabend = stabcontents + stab->_raw_size;

      for (irel = irelbase; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) != R_IP2K_NONE)
	    {
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
		{
		  Elf_Internal_Sym isym;
		  asection *sym_sec;
		  Elf_External_Sym_Shndx *sym_shndx;
		  Elf_Internal_Shdr *shndx_hdr;
		  
		  /* A local symbol.  */
		  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
		  sym_shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
		  sym_shndx = (sym_shndx
			       ? sym_shndx + ELF32_R_SYM (irel->r_info)
			       : NULL);
		  
		  bfd_elf32_swap_symbol_in (abfd,
					    (extsyms
					     + ELF32_R_SYM (irel->r_info)),
					    sym_shndx, &isym);
		  
		  if (isym.st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym.st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym.st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  
		  if (sym_sec == sec)
		    {
		      const char *name;
		      unsigned long strx;
		      unsigned char type, other;
		      unsigned short desc;
		      bfd_vma value;
		      bfd_vma baseaddr = BASEADDR (sec);
		      bfd_vma symval = BASEADDR (sym_sec) + isym.st_value
			+ irel->r_addend;
		      
		      if ((baseaddr + addr) <= symval
			  && symval <= (baseaddr + endaddr))
			irel->r_addend += count;

		      /* Go hunt up a function and fix its line info if needed.  */
		      stabp = stabcontents + irel->r_offset - 8; 

		      /* Go pullout the stab entry.  */
		      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
		      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
		      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
		      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
		      value = bfd_h_get_32 (abfd, stabp + VALOFF);
		      
		      name = bfd_get_stab_name (type);
		      
		      if (strcmp (name, "FUN") == 0)
			{
			  int function_adjusted = 0;

			  if (symval > (baseaddr + addr))
			    /* Not in this function.  */
			    continue;

			  /* Hey we got a function hit.  */
			  stabp += STABSIZE;
			  for (;stabp < stabend; stabp += STABSIZE)
			    {
			      /* Go pullout the stab entry.  */
			      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
			      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
			      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
			      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
			      value = bfd_h_get_32 (abfd, stabp + VALOFF);
			      name = bfd_get_stab_name (type);

			      if (strcmp (name, "FUN") == 0)
				{
				  /* Hit another function entry.  */
				  if (function_adjusted)
				    {
				      /* Adjust the value.  */
				      value += count;
				  
				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				    }

				  /* And then bale out.  */
				  break;
				}

			      if (strcmp (name, "SLINE") == 0)
				{
				  /* Got a line entry.  */
				  if ((baseaddr + addr) <= (symval + value))
				    {
				      /* Adjust the line entry.  */
				      value += count;

				      /* We need to put it back.  */
				      bfd_h_put_32 (abfd, value,stabp + VALOFF);
				      function_adjusted = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

d1216 2
a1217 5
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  sym_shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, sym_shndx = (sym_shndx ? sym_shndx + 1: NULL))
d1219 18
a1236 34
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, esym, sym_shndx, &isym);

      if (isym.st_shndx == shndx)
        {
          if (addr <= isym.st_value && isym.st_value < endaddr)
            {
              isym.st_value += count;
              bfd_elf32_swap_symbol_out (abfd, &isym, esym, &dummy);
            }
        }
    }

  /* Now adjust the global symbols defined in this section.  */
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  sym_shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
  for (index = 0; esym < esymend;
       esym++, index++, sym_shndx = (sym_shndx ? sym_shndx + 1: NULL))
    {
      Elf_Internal_Sym isym;
      struct elf_link_hash_entry *sym_hash;

      bfd_elf32_swap_symbol_in (abfd, esym, sym_shndx, &isym);
      sym_hash = elf_sym_hashes (abfd)[index];

      if (isym.st_shndx == shndx
          && (sym_hash->root.type == bfd_link_hash_defined
              || sym_hash->root.type == bfd_link_hash_defweak)
          && sym_hash->root.u.def.section == sec)
        {
a1239 2
	      Elf_External_Sym_Shndx dummy;

a1240 1
              bfd_elf32_swap_symbol_out (abfd, &isym, esym, &dummy);
d1242 1
a1242 1
        }
a1256 2
  misc->free_relocs = NULL;

d1258 1
a1258 4
  misc->free_contents = NULL;

  misc->symtab_hdr->contents = (bfd_byte *) misc->extsyms;
  misc->free_extsyms = NULL;
@


1.1
log
@Add IP2k support to BFD and LD
@
text
@a1713 3
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.
d1760 3
d1779 1
a1780 1

a1781 22

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
a1948 3
#undef USE_REL
#define USE_RELA

d1953 1
@


1.1.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@@


1.1.2.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1 1
a1 1
/* Ubicom IP2xxx specific support for 32-bit ELF
d33 4
a36 1
  Elf_Internal_Sym *   isymbuf;
d44 1
a44 1
static bfd_vma               symbol_value                         PARAMS ((bfd *, Elf_Internal_Shdr *, Elf32_Internal_Sym *, Elf_Internal_Rela *));
d55 1
d260 1
a260 1
symbol_value (abfd, symtab_hdr, isymbuf, irel)
d263 1
a263 1
     Elf32_Internal_Sym *isymbuf;
d268 3
a270 1
      Elf_Internal_Sym *isym;
d273 6
a278 2
      isym = isymbuf + ELF32_R_SYM (irel->r_info);
      if (isym->st_shndx == SHN_UNDEF)
d280 1
a280 1
      else if (isym->st_shndx == SHN_ABS)
d282 1
a282 1
      else if (isym->st_shndx == SHN_COMMON)
d285 1
a285 1
	sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d287 1
a287 1
      return isym->st_value + BASEADDR (sym_sec);
d775 2
a776 4
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
d816 8
d829 11
a839 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d841 2
a842 5
  internal_relocs = _bfd_elf32_link_read_relocs (abfd, sec, NULL,
						 (Elf_Internal_Rela *)NULL,
						 link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;
d858 3
a860 1
  if (contents == NULL)
d862 12
a873 4
      /* Get cached copy if it exists.  */
      if (elf_section_data (sec)->this_hdr.contents != NULL)
	contents = elf_section_data (sec)->this_hdr.contents;
      else
d875 2
a876 8
	  /* Go get them off disk.  */
	  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	  if (contents == NULL)
	    goto error_return;

	  if (! bfd_get_section_contents (abfd, sec, contents,
					  (file_ptr) 0, sec->_raw_size))
	    goto error_return;
d879 1
a879 1
      
d881 3
a883 1
  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d885 36
a920 7
      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (isymbuf == NULL)
	isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
      if (isymbuf == NULL)
	goto error_return;
a922 5
  misc.symtab_hdr = symtab_hdr;
  misc.isymbuf = isymbuf;
  misc.irelbase = internal_relocs;
  misc.contents = contents;
  
d933 4
a936 1
	goto error_return;
d960 6
a965 3
      if (! ip2k_elf_relax_section_passN (abfd, sec, again, &final_pass,
					  &misc))
	goto error_return;
d986 7
a992 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d995 1
a995 1
	free (isymbuf);
d997 6
a1002 1
	symtab_hdr->contents = (unsigned char *) isymbuf;
d1005 1
a1005 2
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
d1008 1
a1008 1
	free (contents);
d1011 2
a1012 2
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
d1014 2
d1018 2
a1019 3
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
d1021 21
a1041 1
  return true;
d1043 1
a1043 11
 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return false;
d1073 2
d1076 4
a1079 1
	    misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;
d1156 1
a1156 1
        bfd_vma symval = symbol_value (abfd, misc->symtab_hdr, misc->isymbuf,
d1242 2
a1243 2
  Elf_Internal_Sym *isymbuf, *isym, *isymend;
  unsigned int shndx;
d1246 5
a1250 3
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;
d1253 1
a1253 1
  isymbuf = (Elf32_Internal_Sym *) symtab_hdr->contents;
d1269 1
d1271 2
d1275 17
a1291 2
	      isym = isymbuf + ELF32_R_SYM (irel->r_info);
              sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1293 1
a1293 1
              if (isym->st_shndx == shndx)
d1296 1
a1296 1
                  bfd_vma symval = BASEADDR (sym_sec) + isym->st_value
d1311 142
d1462 5
a1466 2
  isymend = isymbuf + symtab_hdr->sh_info;
  for (isym = isymbuf; isym < isymend; isym++)
d1468 34
a1501 18
      if (isym->st_shndx == shndx
	  && addr <= isym->st_value
	  && isym->st_value < endaddr)
	isym->st_value += count;
    }

    /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
	{
d1505 2
d1508 1
d1510 1
a1510 1
	}
d1525 2
d1528 4
a1531 1
  misc->symtab_hdr->contents = (bfd_byte *) misc->isymbuf;
d1714 3
a1762 3
  if (info->relocateable)
    return true;

a1778 1
      /* This is a final link.  */
d1780 1
d1782 22
d1971 3
a1977 1
#define elf_backend_rela_normal			1
@


1.1.2.3
log
@merge from mainline
@
text
@a1673 1
#define ELF_MACHINE_ALT1 EM_IP2K_OLD
d1692 1
@


