head	1.324;
access;
symbols
	sid-snapshot-20180601:1.324
	sid-snapshot-20180501:1.324
	sid-snapshot-20180401:1.324
	sid-snapshot-20180301:1.324
	sid-snapshot-20180201:1.324
	sid-snapshot-20180101:1.324
	sid-snapshot-20171201:1.324
	sid-snapshot-20171101:1.324
	sid-snapshot-20171001:1.324
	sid-snapshot-20170901:1.324
	sid-snapshot-20170801:1.324
	sid-snapshot-20170701:1.324
	sid-snapshot-20170601:1.324
	sid-snapshot-20170501:1.324
	sid-snapshot-20170401:1.324
	sid-snapshot-20170301:1.324
	sid-snapshot-20170201:1.324
	sid-snapshot-20170101:1.324
	sid-snapshot-20161201:1.324
	sid-snapshot-20161101:1.324
	sid-snapshot-20160901:1.324
	sid-snapshot-20160801:1.324
	sid-snapshot-20160701:1.324
	sid-snapshot-20160601:1.324
	sid-snapshot-20160501:1.324
	sid-snapshot-20160401:1.324
	sid-snapshot-20160301:1.324
	sid-snapshot-20160201:1.324
	sid-snapshot-20160101:1.324
	sid-snapshot-20151201:1.324
	sid-snapshot-20151101:1.324
	sid-snapshot-20151001:1.324
	sid-snapshot-20150901:1.324
	sid-snapshot-20150801:1.324
	sid-snapshot-20150701:1.324
	sid-snapshot-20150601:1.324
	sid-snapshot-20150501:1.324
	sid-snapshot-20150401:1.324
	sid-snapshot-20150301:1.324
	sid-snapshot-20150201:1.324
	sid-snapshot-20150101:1.324
	sid-snapshot-20141201:1.324
	sid-snapshot-20141101:1.324
	sid-snapshot-20141001:1.324
	sid-snapshot-20140901:1.324
	sid-snapshot-20140801:1.324
	sid-snapshot-20140701:1.324
	sid-snapshot-20140601:1.324
	sid-snapshot-20140501:1.324
	sid-snapshot-20140401:1.324
	sid-snapshot-20140301:1.324
	sid-snapshot-20140201:1.324
	sid-snapshot-20140101:1.324
	sid-snapshot-20131201:1.324
	sid-snapshot-20131101:1.324
	sid-snapshot-20131001:1.324
	binutils-2_24-branch:1.324.0.2
	binutils-2_24-branchpoint:1.324
	binutils-2_21_1:1.248.2.2
	sid-snapshot-20130901:1.324
	gdb_7_6_1-2013-08-30-release:1.310
	sid-snapshot-20130801:1.322
	sid-snapshot-20130701:1.319
	sid-snapshot-20130601:1.317
	sid-snapshot-20130501:1.317
	gdb_7_6-2013-04-26-release:1.310
	sid-snapshot-20130401:1.315
	binutils-2_23_2:1.298.2.4
	gdb_7_6-branch:1.310.0.2
	gdb_7_6-2013-03-12-branchpoint:1.310
	sid-snapshot-20130301:1.310
	sid-snapshot-20130201:1.304
	sid-snapshot-20130101:1.304
	sid-snapshot-20121201:1.303
	gdb_7_5_1-2012-11-29-release:1.296
	binutils-2_23_1:1.298.2.1
	sid-snapshot-20121101:1.301
	binutils-2_23:1.298.2.1
	sid-snapshot-20121001:1.300
	sid-snapshot-20120901:1.299
	gdb_7_5-2012-08-17-release:1.296
	sid-snapshot-20120801:1.298
	binutils-2_23-branch:1.298.0.2
	binutils-2_23-branchpoint:1.298
	gdb_7_5-branch:1.296.0.2
	gdb_7_5-2012-07-18-branchpoint:1.296
	sid-snapshot-20120701:1.296
	sid-snapshot-20120601:1.291
	sid-snapshot-20120501:1.288
	binutils-2_22_branch:1.275.2.1.0.2
	gdb_7_4_1-2012-04-26-release:1.281.2.1
	sid-snapshot-20120401:1.285
	sid-snapshot-20120301:1.283
	sid-snapshot-20120201:1.283
	gdb_7_4-2012-01-24-release:1.281.2.1
	sid-snapshot-20120101:1.282
	gdb_7_4-branch:1.281.0.2
	gdb_7_4-2011-12-13-branchpoint:1.281
	sid-snapshot-20111201:1.281
	binutils-2_22:1.275.2.1
	sid-snapshot-20111101:1.280
	sid-snapshot-20111001:1.276
	binutils-2_22-branch:1.275.0.2
	binutils-2_22-branchpoint:1.275
	gdb_7_3_1-2011-09-04-release:1.262
	sid-snapshot-20110901:1.275
	sid-snapshot-20110801:1.273
	gdb_7_3-2011-07-26-release:1.262
	sid-snapshot-20110701:1.272
	sid-snapshot-20110601:1.267
	sid-snapshot-20110501:1.263
	gdb_7_3-branch:1.262.0.2
	gdb_7_3-2011-04-01-branchpoint:1.262
	sid-snapshot-20110401:1.262
	sid-snapshot-20110301:1.256
	sid-snapshot-20110201:1.256
	sid-snapshot-20110101:1.251
	binutils-2_21:1.248.2.1
	sid-snapshot-20101201:1.249
	binutils-2_21-branch:1.248.0.2
	binutils-2_21-branchpoint:1.248
	sid-snapshot-20101101:1.247
	sid-snapshot-20101001:1.243
	binutils-2_20_1:1.211.2.2
	gdb_7_2-2010-09-02-release:1.237
	sid-snapshot-20100901:1.241
	sid-snapshot-20100801:1.237
	gdb_7_2-branch:1.237.0.2
	gdb_7_2-2010-07-07-branchpoint:1.237
	sid-snapshot-20100701:1.237
	sid-snapshot-20100601:1.235
	sid-snapshot-20100501:1.233
	sid-snapshot-20100401:1.231
	gdb_7_1-2010-03-18-release:1.223
	sid-snapshot-20100301:1.223
	gdb_7_1-branch:1.223.0.2
	gdb_7_1-2010-02-18-branchpoint:1.223
	sid-snapshot-20100201:1.219
	sid-snapshot-20100101:1.218
	gdb_7_0_1-2009-12-22-release:1.212
	sid-snapshot-20091201:1.215
	sid-snapshot-20091101:1.213
	binutils-2_20:1.211.2.1
	gdb_7_0-2009-10-06-release:1.212
	sid-snapshot-20091001:1.213
	gdb_7_0-branch:1.212.0.2
	gdb_7_0-2009-09-16-branchpoint:1.212
	arc-sim-20090309:1.136
	binutils-arc-20081103-branch:1.157.0.8
	binutils-arc-20081103-branchpoint:1.157
	binutils-2_20-branch:1.211.0.2
	binutils-2_20-branchpoint:1.211
	sid-snapshot-20090901:1.211
	sid-snapshot-20090801:1.206
	msnyder-checkpoint-072509-branch:1.205.0.2
	msnyder-checkpoint-072509-branchpoint:1.205
	sid-snapshot-20090701:1.202
	dje-cgen-play1-branch:1.202.0.2
	dje-cgen-play1-branchpoint:1.202
	sid-snapshot-20090601:1.196
	sid-snapshot-20090501:1.190
	sid-snapshot-20090401:1.183
	arc-20081103-branch:1.157.0.6
	arc-20081103-branchpoint:1.157
	arc-insight_6_8-branch:1.136.0.6
	arc-insight_6_8-branchpoint:1.136
	insight_6_8-branch:1.136.0.4
	insight_6_8-branchpoint:1.136
	sid-snapshot-20090301:1.178
	binutils-2_19_1:1.157.2.1
	sid-snapshot-20090201:1.170
	sid-snapshot-20090101:1.163
	reverse-20081226-branch:1.163.0.2
	reverse-20081226-branchpoint:1.163
	sid-snapshot-20081201:1.160
	multiprocess-20081120-branch:1.158.0.2
	multiprocess-20081120-branchpoint:1.158
	sid-snapshot-20081101:1.157
	binutils-2_19:1.157
	sid-snapshot-20081001:1.157
	reverse-20080930-branch:1.157.0.4
	reverse-20080930-branchpoint:1.157
	binutils-2_19-branch:1.157.0.2
	binutils-2_19-branchpoint:1.157
	sid-snapshot-20080901:1.157
	sid-snapshot-20080801:1.154
	reverse-20080717-branch:1.151.0.2
	reverse-20080717-branchpoint:1.151
	sid-snapshot-20080701:1.150
	msnyder-reverse-20080609-branch:1.148.0.2
	msnyder-reverse-20080609-branchpoint:1.148
	drow-reverse-20070409-branch:1.109.0.2
	drow-reverse-20070409-branchpoint:1.109
	sid-snapshot-20080601:1.145
	sid-snapshot-20080501:1.141
	sid-snapshot-20080403:1.141
	sid-snapshot-20080401:1.141
	gdb_6_8-2008-03-27-release:1.136
	sid-snapshot-20080301:1.136
	gdb_6_8-branch:1.136.0.2
	gdb_6_8-2008-02-26-branchpoint:1.136
	sid-snapshot-20080201:1.132
	sid-snapshot-20080101:1.131
	sid-snapshot-20071201:1.131
	sid-snapshot-20071101:1.129
	gdb_6_7_1-2007-10-29-release:1.126
	gdb_6_7-2007-10-10-release:1.126
	sid-snapshot-20071001:1.128
	gdb_6_7-branch:1.126.0.2
	gdb_6_7-2007-09-07-branchpoint:1.126
	binutils-2_18:1.125
	binutils-2_18-branch:1.125.0.2
	binutils-2_18-branchpoint:1.125
	insight_6_6-20070208-release:1.101
	binutils-csl-coldfire-4_1-32:1.70.2.18
	binutils-csl-sourcerygxx-4_1-32:1.70.2.18
	gdb_6_6-2006-12-18-release:1.101
	binutils-csl-innovasic-fido-3_4_4-33:1.70.2.18
	binutils-csl-sourcerygxx-3_4_4-32:1.22.2.5
	binutils-csl-coldfire-4_1-30:1.70.2.18
	binutils-csl-sourcerygxx-4_1-30:1.70.2.18
	binutils-csl-coldfire-4_1-28:1.70.2.18
	binutils-csl-sourcerygxx-4_1-29:1.70.2.18
	binutils-csl-sourcerygxx-4_1-28:1.70.2.18
	gdb_6_6-branch:1.101.0.2
	gdb_6_6-2006-11-15-branchpoint:1.101
	binutils-csl-arm-2006q3-27:1.70.2.18
	binutils-csl-sourcerygxx-4_1-27:1.70.2.18
	binutils-csl-arm-2006q3-26:1.70.2.18
	binutils-csl-sourcerygxx-4_1-26:1.70.2.18
	binutils-csl-sourcerygxx-4_1-25:1.70.2.17
	binutils-csl-sourcerygxx-4_1-24:1.70.2.15
	binutils-csl-sourcerygxx-4_1-23:1.70.2.15
	insight_6_5-20061003-release:1.74
	gdb-csl-symbian-6_4_50_20060226-12:1.64
	binutils-csl-sourcerygxx-4_1-21:1.70.2.15
	binutils-csl-arm-2006q3-21:1.70.2.15
	binutils-csl-sourcerygxx-4_1-22:1.70.2.15
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.70.2.15
	binutils-csl-sourcerygxx-4_1-20:1.70.2.15
	binutils-csl-arm-2006q3-19:1.70.2.15
	binutils-csl-sourcerygxx-4_1-19:1.70.2.15
	binutils-csl-sourcerygxx-4_1-18:1.70.2.15
	binutils-csl-renesas-4_1-9:1.70.2.11
	gdb-csl-sourcerygxx-3_4_4-25:1.60
	binutils-csl-sourcerygxx-3_4_4-25:1.22.2.5
	nickrob-async-20060828-mergepoint:1.87
	gdb-csl-symbian-6_4_50_20060226-11:1.64
	binutils-csl-renesas-4_1-8:1.70.2.8
	binutils-csl-renesas-4_1-7:1.70.2.7
	binutils-csl-renesas-4_1-6:1.70.2.7
	gdb-csl-sourcerygxx-4_1-17:1.64
	binutils-csl-sourcerygxx-4_1-17:1.70.2.7
	gdb-csl-20060226-branch-local-2:1.64
	gdb-csl-sourcerygxx-4_1-14:1.64
	binutils-csl-sourcerygxx-4_1-14:1.70.2.7
	binutils-csl-sourcerygxx-4_1-15:1.70.2.7
	gdb-csl-sourcerygxx-4_1-13:1.64
	binutils-csl-sourcerygxx-4_1-13:1.70.2.7
	binutils-2_17:1.70.6.1
	gdb-csl-sourcerygxx-4_1-12:1.64
	binutils-csl-sourcerygxx-4_1-12:1.70.2.7
	gdb-csl-sourcerygxx-3_4_4-21:1.64
	binutils-csl-sourcerygxx-3_4_4-21:1.70.2.7
	gdb_6_5-20060621-release:1.74
	binutils-csl-wrs-linux-3_4_4-24:1.22.2.3.2.8
	binutils-csl-wrs-linux-3_4_4-23:1.22.2.3.2.8
	gdb-csl-sourcerygxx-4_1-9:1.64
	binutils-csl-sourcerygxx-4_1-9:1.70.2.5
	gdb-csl-sourcerygxx-4_1-8:1.64
	binutils-csl-sourcerygxx-4_1-8:1.70.2.5
	gdb-csl-sourcerygxx-4_1-7:1.64
	binutils-csl-sourcerygxx-4_1-7:1.70.2.5
	gdb-csl-arm-2006q1-6:1.64
	binutils-csl-arm-2006q1-6:1.70.2.5
	gdb-csl-sourcerygxx-4_1-6:1.64
	binutils-csl-sourcerygxx-4_1-6:1.70.2.5
	binutils-csl-wrs-linux-3_4_4-22:1.22.2.3.2.8
	gdb-csl-symbian-6_4_50_20060226-10:1.64
	gdb-csl-symbian-6_4_50_20060226-9:1.64
	gdb-csl-symbian-6_4_50_20060226-8:1.64
	gdb-csl-coldfire-4_1-11:1.64
	binutils-csl-coldfire-4_1-11:1.70.2.3
	gdb-csl-sourcerygxx-3_4_4-19:1.64
	binutils-csl-sourcerygxx-3_4_4-19:1.70.2.3
	gdb-csl-coldfire-4_1-10:1.64
	gdb_6_5-branch:1.74.0.4
	gdb_6_5-2006-05-14-branchpoint:1.74
	binutils-csl-coldfire-4_1-10:1.70.2.2
	gdb-csl-sourcerygxx-4_1-5:1.64
	binutils-csl-sourcerygxx-4_1-5:1.70.2.2
	nickrob-async-20060513-branch:1.74.0.2
	nickrob-async-20060513-branchpoint:1.74
	gdb-csl-sourcerygxx-4_1-4:1.64
	binutils-csl-sourcerygxx-4_1-4:1.70.2.2
	msnyder-reverse-20060502-branch:1.71.0.2
	msnyder-reverse-20060502-branchpoint:1.71
	binutils-csl-wrs-linux-3_4_4-21:1.22.2.3.2.8
	gdb-csl-morpho-4_1-4:1.64
	binutils-csl-morpho-4_1-4:1.70
	gdb-csl-sourcerygxx-3_4_4-17:1.64
	binutils-csl-sourcerygxx-3_4_4-17:1.70
	binutils-csl-wrs-linux-3_4_4-20:1.22.2.3.2.8
	readline_5_1-import-branch:1.70.0.8
	readline_5_1-import-branchpoint:1.70
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.64
	binutils-2_17-branch:1.70.0.6
	binutils-2_17-branchpoint:1.70
	gdb-csl-symbian-20060226-branch:1.64.0.4
	gdb-csl-symbian-20060226-branchpoint:1.64
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.64
	msnyder-reverse-20060331-branch:1.70.0.4
	msnyder-reverse-20060331-branchpoint:1.70
	binutils-csl-2_17-branch:1.70.0.2
	binutils-csl-2_17-branchpoint:1.70
	gdb-csl-available-20060303-branch:1.65.0.2
	gdb-csl-available-20060303-branchpoint:1.65
	gdb-csl-20060226-branch:1.64.0.2
	gdb-csl-20060226-branchpoint:1.64
	gdb_6_4-20051202-release:1.60
	msnyder-fork-checkpoint-branch:1.60.0.6
	msnyder-fork-checkpoint-branchpoint:1.60
	gdb-csl-gxxpro-6_3-branch:1.60.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.60
	gdb_6_4-branch:1.60.0.2
	gdb_6_4-2005-11-01-branchpoint:1.60
	gdb-csl-arm-20051020-branch:1.59.0.2
	gdb-csl-arm-20051020-branchpoint:1.59
	binutils-csl-gxxpro-3_4-branch:1.22.2.5.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.22.2.5
	binutils-2_16_1:1.22.2.5
	msnyder-tracepoint-checkpoint-branch:1.42.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.42
	gdb-csl-arm-20050325-2005-q1b:1.26
	binutils-csl-arm-2005q1b:1.22.2.3.2.7
	binutils-2_16:1.22.2.5
	gdb-csl-arm-20050325-2005-q1a:1.26
	binutils-csl-arm-2005q1a:1.22.2.3.2.4
	csl-arm-20050325-branch:1.26.0.2
	csl-arm-20050325-branchpoint:1.26
	binutils-csl-arm-2005q1-branch:1.22.2.3.0.2
	binutils-csl-arm-2005q1-branchpoint:1.22.2.3
	binutils-2_16-branch:1.22.0.2
	binutils-2_16-branchpoint:1.22
	csl-arm-2004-q3d:1.2
	binutils_latest_snapshot:1.324;
locks; strict;
comment	@ * @;


1.324
date	2013.08.26.19.27.24;	author roland;	state Exp;
branches;
next	1.323;

1.323
date	2013.08.14.12.20.40;	author nickc;	state Exp;
branches;
next	1.322;

1.322
date	2013.07.31.16.26.02;	author nickc;	state Exp;
branches;
next	1.321;

1.321
date	2013.07.18.12.00.26;	author nickc;	state Exp;
branches;
next	1.320;

1.320
date	2013.07.18.11.24.11;	author nickc;	state Exp;
branches;
next	1.319;

1.319
date	2013.06.28.12.22.42;	author nickc;	state Exp;
branches;
next	1.318;

1.318
date	2013.06.13.12.36.01;	author nickc;	state Exp;
branches;
next	1.317;

1.317
date	2013.04.29.09.48.31;	author willnewton;	state Exp;
branches;
next	1.316;

1.316
date	2013.04.24.16.29.55;	author roland;	state Exp;
branches;
next	1.315;

1.315
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.314;

1.314
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches;
next	1.313;

1.313
date	2013.03.27.09.51.46;	author willnewton;	state Exp;
branches;
next	1.312;

1.312
date	2013.03.27.09.48.46;	author willnewton;	state Exp;
branches;
next	1.311;

1.311
date	2013.03.21.10.34.11;	author nickc;	state Exp;
branches;
next	1.310;

1.310
date	2013.02.28.10.31.32;	author jules;	state Exp;
branches;
next	1.309;

1.309
date	2013.02.21.03.02.28;	author amodra;	state Exp;
branches;
next	1.308;

1.308
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.307;

1.307
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.306;

1.306
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches;
next	1.305;

1.305
date	2013.02.05.23.18.44;	author amodra;	state Exp;
branches;
next	1.304;

1.304
date	2012.12.17.19.13.07;	author roland;	state Exp;
branches;
next	1.303;

1.303
date	2012.11.16.18.33.00;	author yufeng;	state Exp;
branches;
next	1.302;

1.302
date	2012.11.15.00.30.10;	author roland;	state Exp;
branches;
next	1.301;

1.301
date	2012.10.30.12.44.53;	author nickc;	state Exp;
branches;
next	1.300;

1.300
date	2012.09.02.12.17.25;	author hjl;	state Exp;
branches;
next	1.299;

1.299
date	2012.08.24.07.50.27;	author mgretton;	state Exp;
branches;
next	1.298;

1.298
date	2012.07.26.13.43.23;	author nickc;	state Exp;
branches
	1.298.2.1;
next	1.297;

1.297
date	2012.07.24.21.06.57;	author ccoutant;	state Exp;
branches;
next	1.296;

1.296
date	2012.06.29.15.20.30;	author nickc;	state Exp;
branches;
next	1.295;

1.295
date	2012.06.29.14.45.58;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2012.06.28.16.57.24;	author roland;	state Exp;
branches;
next	1.293;

1.293
date	2012.06.18.00.46.28;	author amodra;	state Exp;
branches;
next	1.292;

1.292
date	2012.06.13.10.01.50;	author nickc;	state Exp;
branches;
next	1.291;

1.291
date	2012.05.16.16.38.27;	author nickc;	state Exp;
branches;
next	1.290;

1.290
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.289;

1.289
date	2012.05.01.16.07.33;	author nickc;	state Exp;
branches;
next	1.288;

1.288
date	2012.04.24.16.09.12;	author hp;	state Exp;
branches;
next	1.287;

1.287
date	2012.04.24.05.12.31;	author amodra;	state Exp;
branches;
next	1.286;

1.286
date	2012.04.12.13.01.14;	author nickc;	state Exp;
branches;
next	1.285;

1.285
date	2012.03.16.15.15.14;	author mgretton;	state Exp;
branches;
next	1.284;

1.284
date	2012.03.13.06.04.33;	author amodra;	state Exp;
branches;
next	1.283;

1.283
date	2012.01.20.09.52.43;	author uweigand;	state Exp;
branches;
next	1.282;

1.282
date	2011.12.21.21.21.16;	author uweigand;	state Exp;
branches;
next	1.281;

1.281
date	2011.11.17.00.20.01;	author amodra;	state Exp;
branches
	1.281.2.1;
next	1.280;

1.280
date	2011.10.24.12.52.37;	author nickc;	state Exp;
branches;
next	1.279;

1.279
date	2011.10.20.16.27.03;	author nickc;	state Exp;
branches;
next	1.278;

1.278
date	2011.10.19.07.17.13;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2011.10.13.09.47.51;	author nickc;	state Exp;
branches;
next	1.276;

1.276
date	2011.09.30.10.39.44;	author gingold;	state Exp;
branches;
next	1.275;

1.275
date	2011.09.01.14.10.39;	author clyon;	state Exp;
branches
	1.275.2.1;
next	1.274;

1.274
date	2011.08.09.13.10.43;	author mgretton;	state Exp;
branches;
next	1.273;

1.273
date	2011.07.12.15.17.43;	author nickc;	state Exp;
branches;
next	1.272;

1.272
date	2011.06.22.16.06.00;	author ramana;	state Exp;
branches;
next	1.271;

1.271
date	2011.06.14.02.45.12;	author amodra;	state Exp;
branches;
next	1.270;

1.270
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches;
next	1.269;

1.269
date	2011.06.10.14.04.23;	author nickc;	state Exp;
branches;
next	1.268;

1.268
date	2011.06.02.13.43.14;	author nickc;	state Exp;
branches;
next	1.267;

1.267
date	2011.05.31.14.07.57;	author pbrook;	state Exp;
branches;
next	1.266;

1.266
date	2011.05.31.13.37.27;	author pbrook;	state Exp;
branches;
next	1.265;

1.265
date	2011.05.18.13.36.11;	author nickc;	state Exp;
branches;
next	1.264;

1.264
date	2011.05.06.10.21.26;	author rsandifo;	state Exp;
branches;
next	1.263;

1.263
date	2011.04.11.08.13.16;	author nickc;	state Exp;
branches;
next	1.262;

1.262
date	2011.03.14.16.04.06;	author rsandifo;	state Exp;
branches;
next	1.261;

1.261
date	2011.03.14.15.54.59;	author rsandifo;	state Exp;
branches;
next	1.260;

1.260
date	2011.03.14.15.53.57;	author rsandifo;	state Exp;
branches;
next	1.259;

1.259
date	2011.03.14.15.53.32;	author rsandifo;	state Exp;
branches;
next	1.258;

1.258
date	2011.03.14.15.52.51;	author rsandifo;	state Exp;
branches;
next	1.257;

1.257
date	2011.03.14.15.52.05;	author rsandifo;	state Exp;
branches;
next	1.256;

1.256
date	2011.01.17.16.36.43;	author rsandifo;	state Exp;
branches;
next	1.255;

1.255
date	2011.01.17.16.36.13;	author rsandifo;	state Exp;
branches;
next	1.254;

1.254
date	2011.01.14.02.17.58;	author amodra;	state Exp;
branches;
next	1.253;

1.253
date	2011.01.11.09.06.04;	author nathan;	state Exp;
branches;
next	1.252;

1.252
date	2011.01.10.08.40.16;	author nathan;	state Exp;
branches;
next	1.251;

1.251
date	2010.12.02.13.28.35;	author rsandifo;	state Exp;
branches;
next	1.250;

1.250
date	2010.12.02.13.27.21;	author rsandifo;	state Exp;
branches;
next	1.249;

1.249
date	2010.11.10.14.54.30;	author rsandifo;	state Exp;
branches;
next	1.248;

1.248
date	2010.11.04.11.35.00;	author jsm28;	state Exp;
branches
	1.248.2.1;
next	1.247;

1.247
date	2010.10.25.15.54.13;	author drow;	state Exp;
branches;
next	1.246;

1.246
date	2010.10.25.08.23.24;	author amodra;	state Exp;
branches;
next	1.245;

1.245
date	2010.10.11.07.38.53;	author tschwinge;	state Exp;
branches;
next	1.244;

1.244
date	2010.10.06.08.22.20;	author nathan;	state Exp;
branches;
next	1.243;

1.243
date	2010.10.01.11.22.40;	author tschwinge;	state Exp;
branches;
next	1.242;

1.242
date	2010.09.24.12.14.23;	author tschwinge;	state Exp;
branches;
next	1.241;

1.241
date	2010.08.26.10.32.26;	author nathan;	state Exp;
branches;
next	1.240;

1.240
date	2010.08.25.14.53.40;	author hjl;	state Exp;
branches;
next	1.239;

1.239
date	2010.08.25.12.37.29;	author jules;	state Exp;
branches;
next	1.238;

1.238
date	2010.08.18.12.24.05;	author palves;	state Exp;
branches;
next	1.237;

1.237
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.236;

1.236
date	2010.06.15.23.10.10;	author jsm28;	state Exp;
branches;
next	1.235;

1.235
date	2010.05.11.17.36.27;	author nickc;	state Exp;
branches;
next	1.234;

1.234
date	2010.05.07.18.24.45;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2010.04.21.16.32.27;	author aph;	state Exp;
branches;
next	1.232;

1.232
date	2010.04.15.10.56.34;	author mgretton;	state Exp;
branches;
next	1.231;

1.231
date	2010.03.29.20.42.55;	author drow;	state Exp;
branches;
next	1.230;

1.230
date	2010.03.19.17.04.17;	author jiez;	state Exp;
branches;
next	1.229;

1.229
date	2010.03.18.11.22.43;	author nickc;	state Exp;
branches;
next	1.228;

1.228
date	2010.03.17.07.57.05;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2010.03.04.17.16.08;	author drow;	state Exp;
branches;
next	1.226;

1.226
date	2010.03.03.17.56.24;	author drow;	state Exp;
branches;
next	1.225;

1.225
date	2010.03.02.11.40.24;	author mgretton;	state Exp;
branches;
next	1.224;

1.224
date	2010.03.02.08.19.53;	author clyon;	state Exp;
branches;
next	1.223;

1.223
date	2010.02.18.10.56.26;	author mgretton;	state Exp;
branches;
next	1.222;

1.222
date	2010.02.12.20.52.51;	author dgutson;	state Exp;
branches;
next	1.221;

1.221
date	2010.02.08.07.09.39;	author nathan;	state Exp;
branches;
next	1.220;

1.220
date	2010.02.04.09.16.38;	author nickc;	state Exp;
branches;
next	1.219;

1.219
date	2010.01.19.03.49.43;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2009.12.28.18.55.16;	author dgutson;	state Exp;
branches;
next	1.217;

1.217
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.216;

1.216
date	2009.12.09.21.41.59;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2009.11.17.16.31.48;	author pbrook;	state Exp;
branches;
next	1.214;

1.214
date	2009.11.02.13.43.59;	author pbrook;	state Exp;
branches;
next	1.213;

1.213
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.212;

1.212
date	2009.09.09.18.36.10;	author drow;	state Exp;
branches;
next	1.211;

1.211
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches
	1.211.2.1;
next	1.210;

1.210
date	2009.08.21.23.38.06;	author dgutson;	state Exp;
branches;
next	1.209;

1.209
date	2009.08.10.15.56.30;	author nathan;	state Exp;
branches;
next	1.208;

1.208
date	2009.08.06.13.05.24;	author nathan;	state Exp;
branches;
next	1.207;

1.207
date	2009.08.05.12.36.14;	author nathan;	state Exp;
branches;
next	1.206;

1.206
date	2009.07.27.23.04.05;	author dougkwan;	state Exp;
branches;
next	1.205;

1.205
date	2009.07.10.16.56.15;	author dougkwan;	state Exp;
branches;
next	1.204;

1.204
date	2009.07.10.14.57.00;	author jules;	state Exp;
branches;
next	1.203;

1.203
date	2009.07.01.14.48.26;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2009.06.22.10.55.33;	author clyon;	state Exp;
branches;
next	1.201;

1.201
date	2009.06.18.14.18.28;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2009.06.17.18.08.34;	author hjl;	state Exp;
branches;
next	1.199;

1.199
date	2009.06.17.15.46.18;	author pb;	state Exp;
branches;
next	1.198;

1.198
date	2009.06.16.11.33.42;	author nickc;	state Exp;
branches;
next	1.197;

1.197
date	2009.06.12.14.26.08;	author pb;	state Exp;
branches;
next	1.196;

1.196
date	2009.05.22.11.58.44;	author jules;	state Exp;
branches;
next	1.195;

1.195
date	2009.05.21.14.15.48;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2009.05.15.00.08.12;	author pbrook;	state Exp;
branches;
next	1.193;

1.193
date	2009.05.13.16.46.42;	author andrewjenner;	state Exp;
branches;
next	1.192;

1.192
date	2009.05.05.14.18.29;	author pbrook;	state Exp;
branches;
next	1.191;

1.191
date	2009.05.05.13.16.56;	author clyon;	state Exp;
branches;
next	1.190;

1.190
date	2009.04.30.00.01.08;	author jsm28;	state Exp;
branches;
next	1.189;

1.189
date	2009.04.22.14.01.30;	author clyon;	state Exp;
branches;
next	1.188;

1.188
date	2009.04.21.22.05.03;	author drow;	state Exp;
branches;
next	1.187;

1.187
date	2009.04.17.13.04.40;	author clyon;	state Exp;
branches;
next	1.186;

1.186
date	2009.04.15.13.49.54;	author clyon;	state Exp;
branches;
next	1.185;

1.185
date	2009.04.02.14.12.45;	author clyon;	state Exp;
branches;
next	1.184;

1.184
date	2009.04.01.15.34.12;	author clyon;	state Exp;
branches;
next	1.183;

1.183
date	2009.03.28.23.19.00;	author mmitchel;	state Exp;
branches;
next	1.182;

1.182
date	2009.03.17.14.50.48;	author drow;	state Exp;
branches;
next	1.181;

1.181
date	2009.03.13.11.34.43;	author nickc;	state Exp;
branches;
next	1.180;

1.180
date	2009.03.06.08.57.57;	author clyon;	state Exp;
branches;
next	1.179;

1.179
date	2009.03.05.17.28.20;	author clyon;	state Exp;
branches;
next	1.178;

1.178
date	2009.02.26.15.37.52;	author clyon;	state Exp;
branches;
next	1.177;

1.177
date	2009.02.24.22.44.18;	author drow;	state Exp;
branches;
next	1.176;

1.176
date	2009.02.24.22.43.09;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2009.02.24.00.26.40;	author drow;	state Exp;
branches;
next	1.174;

1.174
date	2009.02.23.21.48.53;	author drow;	state Exp;
branches;
next	1.173;

1.173
date	2009.02.23.10.03.46;	author clyon;	state Exp;
branches;
next	1.172;

1.172
date	2009.02.18.16.56.37;	author clyon;	state Exp;
branches;
next	1.171;

1.171
date	2009.02.18.12.45.38;	author clyon;	state Exp;
branches;
next	1.170;

1.170
date	2009.01.30.01.32.25;	author jsm28;	state Exp;
branches;
next	1.169;

1.169
date	2009.01.28.16.35.12;	author clm;	state Exp;
branches;
next	1.168;

1.168
date	2009.01.19.12.14.04;	author ams;	state Exp;
branches;
next	1.167;

1.167
date	2009.01.19.11.55.35;	author ams;	state Exp;
branches;
next	1.166;

1.166
date	2009.01.19.11.50.31;	author ams;	state Exp;
branches;
next	1.165;

1.165
date	2009.01.15.18.00.48;	author ams;	state Exp;
branches;
next	1.164;

1.164
date	2009.01.15.13.03.05;	author ams;	state Exp;
branches;
next	1.163;

1.163
date	2008.12.23.11.46.17;	author nickc;	state Exp;
branches;
next	1.162;

1.162
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.161;

1.161
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2008.11.25.15.53.26;	author jsm28;	state Exp;
branches;
next	1.159;

1.159
date	2008.11.25.13.03.54;	author nickc;	state Exp;
branches;
next	1.158;

1.158
date	2008.11.18.15.45.02;	author clm;	state Exp;
branches;
next	1.157;

1.157
date	2008.08.26.14.40.18;	author nickc;	state Exp;
branches
	1.157.2.1;
next	1.156;

1.156
date	2008.08.26.11.46.41;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2008.08.17.20.48.21;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	2008.07.28.06.46.31;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2008.07.18.20.49.12;	author jsm28;	state Exp;
branches;
next	1.152;

1.152
date	2008.07.18.12.45.33;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2008.07.07.16.02.32;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.30.15.32.51;	author drow;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.25.14.28.47;	author drow;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.09.15.19.52;	author pbrook;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.09.14.53.12;	author drow;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.06.23.20.48;	author pbrook;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.23.13.53.26;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.21.12.01.36;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2008.05.15.17.00.12;	author nickc;	state Exp;
branches;
next	1.142;

1.142
date	2008.05.03.15.36.34;	author drow;	state Exp;
branches;
next	1.141;

1.141
date	2008.03.25.18.56.01;	author nathan;	state Exp;
branches;
next	1.140;

1.140
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2008.03.09.13.23.28;	author pbrook;	state Exp;
branches;
next	1.138;

1.138
date	2008.03.08.14.58.14;	author pbrook;	state Exp;
branches;
next	1.137;

1.137
date	2008.03.08.01.20.38;	author pbrook;	state Exp;
branches;
next	1.136;

1.136
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2008.02.20.15.17.56;	author pbrook;	state Exp;
branches;
next	1.134;

1.134
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2008.02.04.00.09.04;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.131;

1.131
date	2007.11.29.08.14.22;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2007.11.08.13.51.06;	author nathan;	state Exp;
branches;
next	1.129;

1.129
date	2007.10.15.02.00.11;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2007.09.26.13.45.31;	author jbeulich;	state Exp;
branches;
next	1.126;

1.126
date	2007.08.28.13.21.52;	author jsm28;	state Exp;
branches;
next	1.125;

1.125
date	2007.08.06.18.47.21;	author drow;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2007.07.10.04.08.11;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2007.07.03.15.21.30;	author jsm28;	state Exp;
branches;
next	1.122;

1.122
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.29.15.05.46;	author pbrook;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.26.13.55.04;	author jsm28;	state Exp;
branches;
next	1.118;

1.118
date	2007.05.22.17.17.53;	author pbrook;	state Exp;
branches;
next	1.117;

1.117
date	2007.05.18.00.25.04;	author pbrook;	state Exp;
branches;
next	1.116;

1.116
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.15.09.54.04;	author shinwell;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.10.17.00.03;	author rsandifo;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.09.13.02.10;	author shinwell;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.03.19.27.14;	author sandra;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.17.20.09.51;	author pbrook;	state Exp;
branches;
next	1.109;

1.109
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2007.03.20.20.19.07;	author pbrook;	state Exp;
branches;
next	1.107;

1.107
date	2007.03.20.14.24.53;	author shinwell;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.22.17.03.59;	author pbrook;	state Exp;
branches;
next	1.104;

1.104
date	2007.01.29.16.29.21;	author jules;	state Exp;
branches;
next	1.103;

1.103
date	2006.11.29.17.40.29;	author pbrook;	state Exp;
branches;
next	1.102;

1.102
date	2006.11.29.15.50.06;	author pbrook;	state Exp;
branches;
next	1.101;

1.101
date	2006.11.13.20.39.21;	author drow;	state Exp;
branches;
next	1.100;

1.100
date	2006.11.07.14.57.45;	author drow;	state Exp;
branches;
next	1.99;

1.99
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2006.11.01.20.00.25;	author drow;	state Exp;
branches;
next	1.97;

1.97
date	2006.10.19.02.10.41;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2006.10.18.15.34.50;	author shinwell;	state Exp;
branches;
next	1.95;

1.95
date	2006.10.17.15.46.21;	author shinwell;	state Exp;
branches;
next	1.94;

1.94
date	2006.10.17.14.49.51;	author shinwell;	state Exp;
branches;
next	1.93;

1.93
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2006.09.22.13.16.45;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.08.10.30.27;	author rearnsha;	state Exp;
branches;
next	1.88;

1.88
date	2006.09.04.07.11.11;	author shinwell;	state Exp;
branches;
next	1.87;

1.87
date	2006.08.22.13.18.03;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.21.10.47.22;	author shinwell;	state Exp;
branches;
next	1.85;

1.85
date	2006.08.18.16.18.23;	author pbrook;	state Exp;
branches;
next	1.84;

1.84
date	2006.08.18.15.00.18;	author pbrook;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.23.02.58.00;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2006.06.19.14.22.27;	author pbrook;	state Exp;
branches;
next	1.80;

1.80
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.15.11.03.00;	author shinwell;	state Exp;
branches;
next	1.78;

1.78
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2006.05.24.17.10.01;	author pbrook;	state Exp;
branches;
next	1.76;

1.76
date	2006.05.24.16.23.50;	author pbrook;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.15.19.57.34;	author pbrook;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.11.15.17.34;	author pbrook;	state Exp;
branches;
next	1.73;

1.73
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.02.13.09.17;	author pbrook;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.25.17.46.15;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.70.2.1
	1.70.6.1;
next	1.69;

1.69
date	2006.03.14.23.58.07;	author bje;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.10.17.20.28;	author pbrook;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.09.17.06.58;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.07.08.39.21;	author rsandifo;	state Exp;
branches;
next	1.65;

1.65
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.64;

1.64
date	2006.02.21.01.51.58;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.27.14.11.43;	author pbrook;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.11.18.11.43;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.12.17.03.39;	author pbrook;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.19.15.40.23;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.08.17.07.15;	author pbrook;	state Exp;
branches;
next	1.57;

1.57
date	2005.10.06.19.21.13;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.04.07.23.50;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.09.13.10.01;	author rearnsha;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.25.02.32.09;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.18.01.28.22;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.08.15.15.01.39;	author pbrook;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.08.11.06.16;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.02.08.17.45;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2005.07.08.06.19.58;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.07.08.00.26.44;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.05.09.14.14;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.20.18.12.06;	author hjl;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.31.22.09.51;	author zack;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.23.17.44.53;	author fnf;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.18.16.48.13;	author zack;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.18.05.40.05;	author zack;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.17.14.39.18;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.07.13.22.48;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.05.14.33.45;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.04.15.53.11;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.04.11.00.11;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.01.23.57.21;	author pbrook;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.15.16.37.46;	author jules;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.08.11.47.59;	author pbrook;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.30.17.19.28;	author jules;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.30.16.21.59;	author jules;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.29.16.54.19;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.29.16.39.51;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.22.15.39.32;	author drow;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2005.03.22.15.39.08;	author drow;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.20.23.36.16;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.18.17.06.12;	author mmitchel;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.11.16.41.09;	author pbrook;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2005.02.10.14.14.25;	author pbrook;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.31.17.50.20;	author mmitchel;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.28.17.58.24;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.28.17.24.37;	author jules;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.26.06.10.43;	author mmitchel;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.11.09.32.46;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.06.16.18.20;	author pbrook;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.31.16.22.25;	author pbrook;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.02.15.05.34;	author pbrook;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.30.17.45.53;	author pbrook;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.24.14.44.42;	author pbrook;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.19.11.58.02;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.17.17.50.23;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.16.10.08.00;	author mmitchel;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.13.13.38.15;	author pbrook;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.11.18.24.24;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.09.16.50.38;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.09.16.44.31;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.08.22.08.07;	author mmitchel;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.04.18.57.34;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.04.15.54.37;	author drow;	state Exp;
branches;
next	;

1.298.2.1
date	2012.08.28.10.50.39;	author mgretton;	state Exp;
branches;
next	1.298.2.2;

1.298.2.2
date	2012.11.15.00.33.28;	author roland;	state Exp;
branches;
next	1.298.2.3;

1.298.2.3
date	2012.11.19.18.46.03;	author yufeng;	state Exp;
branches;
next	1.298.2.4;

1.298.2.4
date	2012.12.17.19.14.11;	author roland;	state Exp;
branches;
next	1.298.2.5;

1.298.2.5
date	2013.04.24.16.35.58;	author roland;	state Exp;
branches;
next	1.298.2.6;

1.298.2.6
date	2013.05.28.16.00.35;	author willnewton;	state Exp;
branches;
next	1.298.2.7;

1.298.2.7
date	2013.07.18.21.48.09;	author roland;	state Exp;
branches;
next	1.298.2.8;

1.298.2.8
date	2013.08.26.19.28.36;	author roland;	state Exp;
branches;
next	;

1.281.2.1
date	2011.12.21.21.21.59;	author uweigand;	state Exp;
branches;
next	;

1.275.2.1
date	2011.10.13.10.08.13;	author nickc;	state Exp;
branches;
next	1.275.2.2;

1.275.2.2
date	2012.05.11.12.24.22;	author nickc;	state Exp;
branches;
next	1.275.2.3;

1.275.2.3
date	2012.11.16.18.44.06;	author yufeng;	state Exp;
branches;
next	;

1.248.2.1
date	2010.11.10.15.30.54;	author rsandifo;	state Exp;
branches;
next	1.248.2.2;

1.248.2.2
date	2011.05.06.10.27.36;	author rsandifo;	state Exp;
branches;
next	1.248.2.3;

1.248.2.3
date	2012.11.16.18.54.07;	author yufeng;	state Exp;
branches;
next	;

1.211.2.1
date	2009.09.14.12.30.59;	author drow;	state Exp;
branches;
next	1.211.2.2;

1.211.2.2
date	2010.02.19.14.44.53;	author mgretton;	state Exp;
branches;
next	;

1.157.2.1
date	2009.01.14.09.13.49;	author gingold;	state Exp;
branches;
next	;

1.125.2.1
date	2007.11.29.08.17.54;	author nickc;	state Exp;
branches;
next	;

1.70.2.1
date	2006.05.01.16.27.16;	author pbrook;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2006.05.03.14.30.23;	author pbrook;	state Exp;
branches;
next	1.70.2.3;

1.70.2.3
date	2006.05.15.20.46.23;	author pbrook;	state Exp;
branches;
next	1.70.2.4;

1.70.2.4
date	2006.05.24.16.24.56;	author pbrook;	state Exp;
branches;
next	1.70.2.5;

1.70.2.5
date	2006.05.24.17.14.51;	author pbrook;	state Exp;
branches;
next	1.70.2.6;

1.70.2.6
date	2006.06.15.15.53.10;	author shinwell;	state Exp;
branches;
next	1.70.2.7;

1.70.2.7
date	2006.06.19.14.22.33;	author pbrook;	state Exp;
branches;
next	1.70.2.8;

1.70.2.8
date	2006.08.18.15.01.15;	author pbrook;	state Exp;
branches;
next	1.70.2.9;

1.70.2.9
date	2006.08.21.09.53.55;	author shinwell;	state Exp;
branches;
next	1.70.2.10;

1.70.2.10
date	2006.08.24.14.46.50;	author shinwell;	state Exp;
branches;
next	1.70.2.11;

1.70.2.11
date	2006.08.24.14.49.51;	author shinwell;	state Exp;
branches;
next	1.70.2.12;

1.70.2.12
date	2006.08.30.17.39.17;	author shinwell;	state Exp;
branches;
next	1.70.2.13;

1.70.2.13
date	2006.08.31.14.59.52;	author shinwell;	state Exp;
branches;
next	1.70.2.14;

1.70.2.14
date	2006.09.01.17.14.16;	author shinwell;	state Exp;
branches;
next	1.70.2.15;

1.70.2.15
date	2006.09.05.16.25.47;	author pbrook;	state Exp;
branches;
next	1.70.2.16;

1.70.2.16
date	2006.10.16.13.09.20;	author shinwell;	state Exp;
branches;
next	1.70.2.17;

1.70.2.17
date	2006.10.29.00.03.03;	author pbrook;	state Exp;
branches;
next	1.70.2.18;

1.70.2.18
date	2006.10.30.21.56.42;	author pbrook;	state Exp;
branches;
next	;

1.70.6.1
date	2006.05.02.13.19.39;	author pbrook;	state Exp;
branches;
next	;

1.26.2.1
date	2005.10.14.20.04.50;	author drow;	state Exp;
branches;
next	;

1.22.2.1
date	2005.03.20.19.16.21;	author mmitchel;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2005.03.22.15.37.32;	author drow;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2005.03.22.15.38.06;	author drow;	state Exp;
branches
	1.22.2.3.2.1;
next	1.22.2.4;

1.22.2.4
date	2005.03.29.16.41.40;	author drow;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2005.05.02.00.01.14;	author pbrook;	state Exp;
branches;
next	;

1.22.2.3.2.1
date	2005.03.28.15.32.58;	author drow;	state Exp;
branches;
next	1.22.2.3.2.2;

1.22.2.3.2.2
date	2005.03.28.15.39.04;	author drow;	state Exp;
branches;
next	1.22.2.3.2.3;

1.22.2.3.2.3
date	2005.03.29.15.00.26;	author pbrook;	state Exp;
branches;
next	1.22.2.3.2.4;

1.22.2.3.2.4
date	2005.03.30.17.28.23;	author jules;	state Exp;
branches;
next	1.22.2.3.2.5;

1.22.2.3.2.5
date	2005.04.08.11.48.10;	author pbrook;	state Exp;
branches;
next	1.22.2.3.2.6;

1.22.2.3.2.6
date	2005.04.26.05.31.38;	author zack;	state Exp;
branches;
next	1.22.2.3.2.7;

1.22.2.3.2.7
date	2005.05.01.23.31.26;	author pbrook;	state Exp;
branches;
next	1.22.2.3.2.8;

1.22.2.3.2.8
date	2005.05.18.14.02.44;	author jules;	state Exp;
branches;
next	;


desc
@@


1.324
log
@bfd/
	* elf-nacl.c (nacl_modify_segment_map): Fix logic reordering the
	elf_segment_map list.  If an executable segment is page-aligned
	but does not end with a full page, then append a fake section into
	the segment map entry that pads out the page.
	(nacl_final_write_processing): New function.  Write the code fill
	laid out in nacl_modify_segment_map.
	* elf-nacl.h: Declare it.
	* elf32-arm.c (elf32_arm_nacl_final_write_processing): New function.
	(elf_backend_final_write_processing): Define it for NaCl backend.
	* elf32-i386.c (elf_backend_final_write_processing): Likewise.
	* elf64-x86-64.c (elf_backend_final_write_processing): Likewise.

	* elf-nacl.c (segment_eligible_for_headers): Rename MAXPAGESIZE
	parameter to MINPAGESIZE.
	(nacl_modify_segment_map): Use minpagesize instead of maxpagesize.

	* elf32-arm.c (ELF_MINPAGESIZE, ELF_COMMONPAGESIZE): Set to
	0x10000	for NaCl targets.

ld/testsuite/
	* ld-x86-64/ilp32-4-nacl.d: Loosen .shstrtab line regexp to match
	any file offset.
	* ld-x86-64/tlsbin-nacl.rd: Update expected code segment PT_LOAD.
	* ld-x86-64/tlsbindesc-nacl.rd: Likewise.
	* ld-scripts/rgn-at3.d: XFAIL for *-*-nacl* targets.
	* ld-scripts/rgn-over8-ok.d: Likewise.
@
text
@/* 32-bit ELF support for ARM
   Copyright 1998-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <limits.h>

#include "bfd.h"
#include "bfd_stdint.h"
#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf-nacl.h"
#include "elf-vxworks.h"
#include "elf/arm.h"

/* Return the relocation section associated with NAME.  HTAB is the
   bfd's elf32_arm_link_hash_entry.  */
#define RELOC_SECTION(HTAB, NAME) \
  ((HTAB)->use_rel ? ".rel" NAME : ".rela" NAME)

/* Return size of a relocation entry.  HTAB is the bfd's
   elf32_arm_link_hash_entry.  */
#define RELOC_SIZE(HTAB) \
  ((HTAB)->use_rel \
   ? sizeof (Elf32_External_Rel) \
   : sizeof (Elf32_External_Rela))

/* Return function to swap relocations in.  HTAB is the bfd's
   elf32_arm_link_hash_entry.  */
#define SWAP_RELOC_IN(HTAB) \
  ((HTAB)->use_rel \
   ? bfd_elf32_swap_reloc_in \
   : bfd_elf32_swap_reloca_in)

/* Return function to swap relocations out.  HTAB is the bfd's
   elf32_arm_link_hash_entry.  */
#define SWAP_RELOC_OUT(HTAB) \
  ((HTAB)->use_rel \
   ? bfd_elf32_swap_reloc_out \
   : bfd_elf32_swap_reloca_out)

#define elf_info_to_howto               0
#define elf_info_to_howto_rel           elf32_arm_info_to_howto

#define ARM_ELF_ABI_VERSION		0
#define ARM_ELF_OS_ABI_VERSION		ELFOSABI_ARM

/* The Adjusted Place, as defined by AAELF.  */
#define Pa(X) ((X) & 0xfffffffc)

static bfd_boolean elf32_arm_write_section (bfd *output_bfd,
					    struct bfd_link_info *link_info,
					    asection *sec,
					    bfd_byte *contents);

/* Note: code such as elf32_arm_reloc_type_lookup expect to use e.g.
   R_ARM_PC24 as an index into this, and find the R_ARM_PC24 HOWTO
   in that slot.  */

static reloc_howto_type elf32_arm_howto_table_1[] =
{
  /* No relocation.  */
  HOWTO (R_ARM_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_PC24,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_PC24",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 32 bit absolute */
  HOWTO (R_ARM_ABS32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* standard 32bit pc-relative reloc */
  HOWTO (R_ARM_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_REL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 8 bit absolute - R_ARM_LDR_PC_G0 in AAELF */
  HOWTO (R_ARM_LDR_PC_G0,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_PC_G0",     /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

   /* 16 bit absolute */
  HOWTO (R_ARM_ABS16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS16",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 12 bit absolute */
  HOWTO (R_ARM_ABS12,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS12",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_ABS5,	/* type */
	 6,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_ABS5",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000007e0,		/* src_mask */
	 0x000007e0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 8 bit absolute */
  HOWTO (R_ARM_ABS8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_SBREL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_SBREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_CALL,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_CALL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x07ff2fff,		/* src_mask */
	 0x07ff2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_PC8,	        /* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_PC8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_BREL_ADJ,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_BREL_ADJ",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_DESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_DESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_SWI8,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_SWI8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* BLX instruction for the ARM.  */
  HOWTO (R_ARM_XPC25,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_XPC25",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* BLX instruction for the Thumb.  */
  HOWTO (R_ARM_THM_XPC22,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_XPC22",	/* name */
	 FALSE,			/* partial_inplace */
	 0x07ff2fff,		/* src_mask */
	 0x07ff2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Dynamic TLS relocations.  */

  HOWTO (R_ARM_TLS_DTPMOD32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_DTPMOD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_DTPOFF32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_DTPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_TPOFF32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_TPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* Relocs used in ARM Linux */

  HOWTO (R_ARM_COPY,		/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_COPY",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_GLOB_DAT,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GLOB_DAT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_JUMP_SLOT,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_JUMP_SLOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_RELATIVE,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_RELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_GOTOFF32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOTOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_GOTPC,		/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 TRUE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOTPC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_GOT32,		/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOT32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_PLT32,		/* type */
	 2,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 24,                    /* bitsize */
	 TRUE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_PLT32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_CALL,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_CALL",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_JUMP24,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_JUMP24",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP24,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP24",	/* name */
	 FALSE,			/* partial_inplace */
	 0x07ff2fff,		/* src_mask */
	 0x07ff2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_BASE_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_BASE_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_ALU_PCREL7_0,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PCREL_7_0",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PCREL15_8,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 8,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PCREL_15_8",/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PCREL23_15,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 TRUE,			/* pc_relative */
	 16,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PCREL_23_15",/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SBREL_11_0,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SBREL_11_0",/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_ALU_SBREL_19_12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 12,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SBREL_19_12",/* name */
	 FALSE,			/* partial_inplace */
	 0x000ff000,		/* src_mask */
	 0x000ff000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_ALU_SBREL_27_20,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 20,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SBREL_27_20",/* name */
	 FALSE,			/* partial_inplace */
	 0x0ff00000,		/* src_mask */
	 0x0ff00000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TARGET1,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TARGET1",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_ROSEGREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ROSEGREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_V4BX,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_V4BX",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TARGET2,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TARGET2",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_PREL31,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 31,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_PREL31",	/* name */
	 FALSE,			/* partial_inplace */
	 0x7fffffff,		/* src_mask */
	 0x7fffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_MOVW_ABS_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_ABS_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000f0fff,		/* src_mask */
	 0x000f0fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVT_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000f0fff,		/* src_mask */
	 0x000f0fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVW_PREL_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_PREL_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000f0fff,		/* src_mask */
	 0x000f0fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_MOVT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000f0fff,		/* src_mask */
	 0x000f0fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_ABS_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_ABS_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_PREL_NC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_PREL_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP19,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_THM_JUMP19",	/* name */
	 FALSE,			/* partial_inplace */
	 0x043f2fff,		/* src_mask */
	 0x043f2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP6,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP6",	/* name */
	 FALSE,			/* partial_inplace */
	 0x02f8,		/* src_mask */
	 0x02f8,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* These are declared as 13-bit signed relocations because we can
     address -4095 .. 4095(base) by altering ADDW to SUBW or vice
     versa.  */
  HOWTO (R_ARM_THM_ALU_PREL_11_0,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_ALU_PREL_11_0",/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_PC12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_PC12",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ABS32_NOI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS32_NOI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_REL32_NOI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_REL32_NOI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Group relocations.  */

  HOWTO (R_ARM_ALU_PC_G0_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G0_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G1_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G1_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G0_NC,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G0_NC", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G1_NC,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G1_NC", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* End of group relocations.  */

  HOWTO (R_ARM_MOVW_BREL_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_BREL_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVT_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVW_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_BREL_NC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_BREL_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_GOTDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_ARM_TLS_GOTDESC",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_CALL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_CALL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_DESCSEQ,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_DESCSEQ",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_TLS_CALL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_TLS_CALL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x07ff07ff,		/* src_mask */
	 0x07ff07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_PLT32_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_PLT32_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_GOT_ABS,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),			/* pcrel_offset */

  HOWTO (R_ARM_GOT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_GOT_BREL12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_BREL12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_GOTOFF12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOTOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_ARM_GOTRELAX),  /* reserved for future GOT-load optimizations */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_ARM_GNU_VTENTRY,     /* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 0,                     /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
	 "R_ARM_GNU_VTENTRY",   /* name */
	 FALSE,                 /* partial_inplace */
	 0,                     /* src_mask */
	 0,                     /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_ARM_GNU_VTINHERIT, /* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 0,                     /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,                  /* special_function */
	 "R_ARM_GNU_VTINHERIT", /* name */
	 FALSE,                 /* partial_inplace */
	 0,                     /* src_mask */
	 0,                     /* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP11,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP11",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000007ff,		/* src_mask */
	 0x000007ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP8,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* TLS relocations */
  HOWTO (R_ARM_TLS_GD32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_ARM_TLS_GD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_LDM32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LDM32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_LDO32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LDO32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_IE32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                  /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_ARM_TLS_IE32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_LE32,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LE32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_TLS_LDO12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_LDO12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_LE12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_LE12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_TLS_IE12GP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_TLS_IE12GP",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 112-127 private relocations.  */
  EMPTY_HOWTO (112),
  EMPTY_HOWTO (113),
  EMPTY_HOWTO (114),
  EMPTY_HOWTO (115),
  EMPTY_HOWTO (116),
  EMPTY_HOWTO (117),
  EMPTY_HOWTO (118),
  EMPTY_HOWTO (119),
  EMPTY_HOWTO (120),
  EMPTY_HOWTO (121),
  EMPTY_HOWTO (122),
  EMPTY_HOWTO (123),
  EMPTY_HOWTO (124),
  EMPTY_HOWTO (125),
  EMPTY_HOWTO (126),
  EMPTY_HOWTO (127),

  /* R_ARM_ME_TOO, obsolete.  */
  EMPTY_HOWTO (128),

  HOWTO (R_ARM_THM_TLS_DESCSEQ,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_TLS_DESCSEQ",/* name */
	 FALSE,			/* partial_inplace */
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* 160 onwards: */
static reloc_howto_type elf32_arm_howto_table_2[1] =
{
  HOWTO (R_ARM_IRELATIVE,	/* type */
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_IRELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

/* 249-255 extended, currently unused, relocations:  */
static reloc_howto_type elf32_arm_howto_table_3[4] =
{
  HOWTO (R_ARM_RREL32,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_RREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_RABS32,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_RABS32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_RPC24,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_RPC24",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_RBASE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_RBASE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE)			/* pcrel_offset */
};

static reloc_howto_type *
elf32_arm_howto_from_type (unsigned int r_type)
{
  if (r_type < ARRAY_SIZE (elf32_arm_howto_table_1))
    return &elf32_arm_howto_table_1[r_type];

  if (r_type == R_ARM_IRELATIVE)
    return &elf32_arm_howto_table_2[r_type - R_ARM_IRELATIVE];

  if (r_type >= R_ARM_RREL32
      && r_type < R_ARM_RREL32 + ARRAY_SIZE (elf32_arm_howto_table_3))
    return &elf32_arm_howto_table_3[r_type - R_ARM_RREL32];

  return NULL;
}

static void
elf32_arm_info_to_howto (bfd * abfd ATTRIBUTE_UNUSED, arelent * bfd_reloc,
			 Elf_Internal_Rela * elf_reloc)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (elf_reloc->r_info);
  bfd_reloc->howto = elf32_arm_howto_from_type (r_type);
}

struct elf32_arm_reloc_map
  {
    bfd_reloc_code_real_type  bfd_reloc_val;
    unsigned char             elf_reloc_val;
  };

/* All entries in this list must also be present in elf32_arm_howto_table.  */
static const struct elf32_arm_reloc_map elf32_arm_reloc_map[] =
  {
    {BFD_RELOC_NONE,                 R_ARM_NONE},
    {BFD_RELOC_ARM_PCREL_BRANCH,     R_ARM_PC24},
    {BFD_RELOC_ARM_PCREL_CALL,	     R_ARM_CALL},
    {BFD_RELOC_ARM_PCREL_JUMP,	     R_ARM_JUMP24},
    {BFD_RELOC_ARM_PCREL_BLX,        R_ARM_XPC25},
    {BFD_RELOC_THUMB_PCREL_BLX,      R_ARM_THM_XPC22},
    {BFD_RELOC_32,                   R_ARM_ABS32},
    {BFD_RELOC_32_PCREL,             R_ARM_REL32},
    {BFD_RELOC_8,                    R_ARM_ABS8},
    {BFD_RELOC_16,                   R_ARM_ABS16},
    {BFD_RELOC_ARM_OFFSET_IMM,       R_ARM_ABS12},
    {BFD_RELOC_ARM_THUMB_OFFSET,     R_ARM_THM_ABS5},
    {BFD_RELOC_THUMB_PCREL_BRANCH25, R_ARM_THM_JUMP24},
    {BFD_RELOC_THUMB_PCREL_BRANCH23, R_ARM_THM_CALL},
    {BFD_RELOC_THUMB_PCREL_BRANCH12, R_ARM_THM_JUMP11},
    {BFD_RELOC_THUMB_PCREL_BRANCH20, R_ARM_THM_JUMP19},
    {BFD_RELOC_THUMB_PCREL_BRANCH9,  R_ARM_THM_JUMP8},
    {BFD_RELOC_THUMB_PCREL_BRANCH7,  R_ARM_THM_JUMP6},
    {BFD_RELOC_ARM_GLOB_DAT,         R_ARM_GLOB_DAT},
    {BFD_RELOC_ARM_JUMP_SLOT,        R_ARM_JUMP_SLOT},
    {BFD_RELOC_ARM_RELATIVE,         R_ARM_RELATIVE},
    {BFD_RELOC_ARM_GOTOFF,           R_ARM_GOTOFF32},
    {BFD_RELOC_ARM_GOTPC,            R_ARM_GOTPC},
    {BFD_RELOC_ARM_GOT_PREL,         R_ARM_GOT_PREL},
    {BFD_RELOC_ARM_GOT32,            R_ARM_GOT32},
    {BFD_RELOC_ARM_PLT32,            R_ARM_PLT32},
    {BFD_RELOC_ARM_TARGET1,	     R_ARM_TARGET1},
    {BFD_RELOC_ARM_ROSEGREL32,	     R_ARM_ROSEGREL32},
    {BFD_RELOC_ARM_SBREL32,	     R_ARM_SBREL32},
    {BFD_RELOC_ARM_PREL31,	     R_ARM_PREL31},
    {BFD_RELOC_ARM_TARGET2,	     R_ARM_TARGET2},
    {BFD_RELOC_ARM_PLT32,            R_ARM_PLT32},
    {BFD_RELOC_ARM_TLS_GOTDESC,      R_ARM_TLS_GOTDESC},
    {BFD_RELOC_ARM_TLS_CALL,         R_ARM_TLS_CALL},
    {BFD_RELOC_ARM_THM_TLS_CALL,     R_ARM_THM_TLS_CALL},
    {BFD_RELOC_ARM_TLS_DESCSEQ,      R_ARM_TLS_DESCSEQ},
    {BFD_RELOC_ARM_THM_TLS_DESCSEQ,  R_ARM_THM_TLS_DESCSEQ},
    {BFD_RELOC_ARM_TLS_DESC,         R_ARM_TLS_DESC},
    {BFD_RELOC_ARM_TLS_GD32,	     R_ARM_TLS_GD32},
    {BFD_RELOC_ARM_TLS_LDO32,	     R_ARM_TLS_LDO32},
    {BFD_RELOC_ARM_TLS_LDM32,	     R_ARM_TLS_LDM32},
    {BFD_RELOC_ARM_TLS_DTPMOD32,     R_ARM_TLS_DTPMOD32},
    {BFD_RELOC_ARM_TLS_DTPOFF32,     R_ARM_TLS_DTPOFF32},
    {BFD_RELOC_ARM_TLS_TPOFF32,      R_ARM_TLS_TPOFF32},
    {BFD_RELOC_ARM_TLS_IE32,         R_ARM_TLS_IE32},
    {BFD_RELOC_ARM_TLS_LE32,         R_ARM_TLS_LE32},
    {BFD_RELOC_ARM_IRELATIVE,        R_ARM_IRELATIVE},
    {BFD_RELOC_VTABLE_INHERIT,	     R_ARM_GNU_VTINHERIT},
    {BFD_RELOC_VTABLE_ENTRY,	     R_ARM_GNU_VTENTRY},
    {BFD_RELOC_ARM_MOVW,	     R_ARM_MOVW_ABS_NC},
    {BFD_RELOC_ARM_MOVT,	     R_ARM_MOVT_ABS},
    {BFD_RELOC_ARM_MOVW_PCREL,	     R_ARM_MOVW_PREL_NC},
    {BFD_RELOC_ARM_MOVT_PCREL,	     R_ARM_MOVT_PREL},
    {BFD_RELOC_ARM_THUMB_MOVW,	     R_ARM_THM_MOVW_ABS_NC},
    {BFD_RELOC_ARM_THUMB_MOVT,	     R_ARM_THM_MOVT_ABS},
    {BFD_RELOC_ARM_THUMB_MOVW_PCREL, R_ARM_THM_MOVW_PREL_NC},
    {BFD_RELOC_ARM_THUMB_MOVT_PCREL, R_ARM_THM_MOVT_PREL},
    {BFD_RELOC_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0_NC},
    {BFD_RELOC_ARM_ALU_PC_G0, R_ARM_ALU_PC_G0},
    {BFD_RELOC_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1_NC},
    {BFD_RELOC_ARM_ALU_PC_G1, R_ARM_ALU_PC_G1},
    {BFD_RELOC_ARM_ALU_PC_G2, R_ARM_ALU_PC_G2},
    {BFD_RELOC_ARM_LDR_PC_G0, R_ARM_LDR_PC_G0},
    {BFD_RELOC_ARM_LDR_PC_G1, R_ARM_LDR_PC_G1},
    {BFD_RELOC_ARM_LDR_PC_G2, R_ARM_LDR_PC_G2},
    {BFD_RELOC_ARM_LDRS_PC_G0, R_ARM_LDRS_PC_G0},
    {BFD_RELOC_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G1},
    {BFD_RELOC_ARM_LDRS_PC_G2, R_ARM_LDRS_PC_G2},
    {BFD_RELOC_ARM_LDC_PC_G0, R_ARM_LDC_PC_G0},
    {BFD_RELOC_ARM_LDC_PC_G1, R_ARM_LDC_PC_G1},
    {BFD_RELOC_ARM_LDC_PC_G2, R_ARM_LDC_PC_G2},
    {BFD_RELOC_ARM_ALU_SB_G0_NC, R_ARM_ALU_SB_G0_NC},
    {BFD_RELOC_ARM_ALU_SB_G0, R_ARM_ALU_SB_G0},
    {BFD_RELOC_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1_NC},
    {BFD_RELOC_ARM_ALU_SB_G1, R_ARM_ALU_SB_G1},
    {BFD_RELOC_ARM_ALU_SB_G2, R_ARM_ALU_SB_G2},
    {BFD_RELOC_ARM_LDR_SB_G0, R_ARM_LDR_SB_G0},
    {BFD_RELOC_ARM_LDR_SB_G1, R_ARM_LDR_SB_G1},
    {BFD_RELOC_ARM_LDR_SB_G2, R_ARM_LDR_SB_G2},
    {BFD_RELOC_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G0},
    {BFD_RELOC_ARM_LDRS_SB_G1, R_ARM_LDRS_SB_G1},
    {BFD_RELOC_ARM_LDRS_SB_G2, R_ARM_LDRS_SB_G2},
    {BFD_RELOC_ARM_LDC_SB_G0, R_ARM_LDC_SB_G0},
    {BFD_RELOC_ARM_LDC_SB_G1, R_ARM_LDC_SB_G1},
    {BFD_RELOC_ARM_LDC_SB_G2, R_ARM_LDC_SB_G2},
    {BFD_RELOC_ARM_V4BX,	     R_ARM_V4BX}
  };

static reloc_howto_type *
elf32_arm_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (elf32_arm_reloc_map); i ++)
    if (elf32_arm_reloc_map[i].bfd_reloc_val == code)
      return elf32_arm_howto_from_type (elf32_arm_reloc_map[i].elf_reloc_val);

  return NULL;
}

static reloc_howto_type *
elf32_arm_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			     const char *r_name)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (elf32_arm_howto_table_1); i++)
    if (elf32_arm_howto_table_1[i].name != NULL
	&& strcasecmp (elf32_arm_howto_table_1[i].name, r_name) == 0)
      return &elf32_arm_howto_table_1[i];

  for (i = 0; i < ARRAY_SIZE (elf32_arm_howto_table_2); i++)
    if (elf32_arm_howto_table_2[i].name != NULL
	&& strcasecmp (elf32_arm_howto_table_2[i].name, r_name) == 0)
      return &elf32_arm_howto_table_2[i];

  for (i = 0; i < ARRAY_SIZE (elf32_arm_howto_table_3); i++)
    if (elf32_arm_howto_table_3[i].name != NULL
	&& strcasecmp (elf32_arm_howto_table_3[i].name, r_name) == 0)
      return &elf32_arm_howto_table_3[i];

  return NULL;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
elf32_arm_nabi_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 148:		/* Linux/ARM 32-bit.  */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 72;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf32_arm_nabi_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 124:		/* Linux/ARM elf_prpsinfo.  */
	elf_tdata (abfd)->core->pid
	 = bfd_get_32 (abfd, note->descdata + 12);
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

static char *
elf32_arm_nabi_write_core_note (bfd *abfd, char *buf, int *bufsiz,
				int note_type, ...)
{
  switch (note_type)
    {
    default:
      return NULL;

    case NT_PRPSINFO:
      {
	char data[124];
	va_list ap;

	va_start (ap, note_type);
	memset (data, 0, sizeof (data));
	strncpy (data + 28, va_arg (ap, const char *), 16);
	strncpy (data + 44, va_arg (ap, const char *), 80);
	va_end (ap);

	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }

    case NT_PRSTATUS:
      {
	char data[148];
	va_list ap;
	long pid;
	int cursig;
	const void *greg;

	va_start (ap, note_type);
	memset (data, 0, sizeof (data));
	pid = va_arg (ap, long);
	bfd_put_32 (abfd, pid, data + 24);
	cursig = va_arg (ap, int);
	bfd_put_16 (abfd, cursig, data + 12);
	greg = va_arg (ap, const void *);
	memcpy (data + 72, greg, 72);
	va_end (ap);

	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }
    }
}

#define TARGET_LITTLE_SYM               bfd_elf32_littlearm_vec
#define TARGET_LITTLE_NAME              "elf32-littlearm"
#define TARGET_BIG_SYM                  bfd_elf32_bigarm_vec
#define TARGET_BIG_NAME                 "elf32-bigarm"

#define elf_backend_grok_prstatus	elf32_arm_nabi_grok_prstatus
#define elf_backend_grok_psinfo		elf32_arm_nabi_grok_psinfo
#define elf_backend_write_core_note	elf32_arm_nabi_write_core_note

typedef unsigned long int insn32;
typedef unsigned short int insn16;

/* In lieu of proper flags, assume all EABIv4 or later objects are
   interworkable.  */
#define INTERWORK_FLAG(abfd)  \
  (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) >= EF_ARM_EABI_VER4 \
  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK) \
  || ((abfd)->flags & BFD_LINKER_CREATED))

/* The linker script knows the section names for placement.
   The entry_names are used to do simple name mangling on the stubs.
   Given a function name, and its type, the stub can be found. The
   name can be changed. The only requirement is the %s be present.  */
#define THUMB2ARM_GLUE_SECTION_NAME ".glue_7t"
#define THUMB2ARM_GLUE_ENTRY_NAME   "__%s_from_thumb"

#define ARM2THUMB_GLUE_SECTION_NAME ".glue_7"
#define ARM2THUMB_GLUE_ENTRY_NAME   "__%s_from_arm"

#define VFP11_ERRATUM_VENEER_SECTION_NAME ".vfp11_veneer"
#define VFP11_ERRATUM_VENEER_ENTRY_NAME   "__vfp11_veneer_%x"

#define ARM_BX_GLUE_SECTION_NAME ".v4_bx"
#define ARM_BX_GLUE_ENTRY_NAME   "__bx_r%d"

#define STUB_ENTRY_NAME   "__%s_veneer"

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
#define ELF_DYNAMIC_INTERPRETER     "/usr/lib/ld.so.1"

static const unsigned long tls_trampoline [] =
{
  0xe08e0000,		/* add r0, lr, r0 */
  0xe5901004,		/* ldr r1, [r0,#4] */
  0xe12fff11,		/* bx  r1 */
};

static const unsigned long dl_tlsdesc_lazy_trampoline [] =
{
  0xe52d2004, /*	push    {r2}			*/
  0xe59f200c, /*      ldr     r2, [pc, #3f - . - 8]	*/
  0xe59f100c, /*      ldr     r1, [pc, #4f - . - 8]	*/
  0xe79f2002, /* 1:   ldr     r2, [pc, r2]		*/
  0xe081100f, /* 2:   add     r1, pc			*/
  0xe12fff12, /*      bx      r2			*/
  0x00000014, /* 3:   .word  _GLOBAL_OFFSET_TABLE_ - 1b - 8
				+ dl_tlsdesc_lazy_resolver(GOT)   */
  0x00000018, /* 4:   .word  _GLOBAL_OFFSET_TABLE_ - 2b - 8 */
};

#ifdef FOUR_WORD_PLT

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [] =
{
  0xe52de004,		/* str   lr, [sp, #-4]! */
  0xe59fe010,		/* ldr   lr, [pc, #16]  */
  0xe08fe00e,		/* add   lr, pc, lr     */
  0xe5bef008,		/* ldr   pc, [lr, #8]!  */
};

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [] =
{
  0xe28fc600,		/* add   ip, pc, #NN	*/
  0xe28cca00,		/* add	 ip, ip, #NN	*/
  0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
  0x00000000,		/* unused		*/
};

#else

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_plt0_entry [] =
{
  0xe52de004,		/* str   lr, [sp, #-4]! */
  0xe59fe004,		/* ldr   lr, [pc, #4]   */
  0xe08fe00e,		/* add   lr, pc, lr     */
  0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  0x00000000,		/* &GOT[0] - .          */
};

/* Subsequent entries in a procedure linkage table look like
   this.  */
static const bfd_vma elf32_arm_plt_entry [] =
{
  0xe28fc600,		/* add   ip, pc, #0xNN00000 */
  0xe28cca00,		/* add	 ip, ip, #0xNN000   */
  0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
};

#endif

/* The format of the first entry in the procedure linkage table
   for a VxWorks executable.  */
static const bfd_vma elf32_arm_vxworks_exec_plt0_entry[] =
{
  0xe52dc008,	        /* str    ip,[sp,#-8]!			*/
  0xe59fc000,   	/* ldr    ip,[pc]			*/
  0xe59cf008,   	/* ldr    pc,[ip,#8]			*/
  0x00000000,   	/* .long  _GLOBAL_OFFSET_TABLE_		*/
};

/* The format of subsequent entries in a VxWorks executable.  */
static const bfd_vma elf32_arm_vxworks_exec_plt_entry[] =
{
  0xe59fc000,         /* ldr    ip,[pc]			*/
  0xe59cf000,         /* ldr    pc,[ip]			*/
  0x00000000,         /* .long  @@got				*/
  0xe59fc000,         /* ldr    ip,[pc]			*/
  0xea000000,         /* b      _PLT				*/
  0x00000000,         /* .long  @@pltindex*sizeof(Elf32_Rela)	*/
};

/* The format of entries in a VxWorks shared library.  */
static const bfd_vma elf32_arm_vxworks_shared_plt_entry[] =
{
  0xe59fc000,         /* ldr    ip,[pc]			*/
  0xe79cf009,         /* ldr    pc,[ip,r9]			*/
  0x00000000,         /* .long  @@got				*/
  0xe59fc000,         /* ldr    ip,[pc]			*/
  0xe599f008,         /* ldr    pc,[r9,#8]			*/
  0x00000000,         /* .long  @@pltindex*sizeof(Elf32_Rela)	*/
};

/* An initial stub used if the PLT entry is referenced from Thumb code.  */
#define PLT_THUMB_STUB_SIZE 4
static const bfd_vma elf32_arm_plt_thumb_stub [] =
{
  0x4778,		/* bx pc */
  0x46c0		/* nop   */
};

/* The entries in a PLT when using a DLL-based target with multiple
   address spaces.  */
static const bfd_vma elf32_arm_symbian_plt_entry [] =
{
  0xe51ff004,         /* ldr   pc, [pc, #-4] */
  0x00000000,         /* dcd   R_ARM_GLOB_DAT(X) */
};

/* The first entry in a procedure linkage table looks like
   this.  It is set up so that any shared library function that is
   called before the relocation has been set up calls the dynamic
   linker first.  */
static const bfd_vma elf32_arm_nacl_plt0_entry [] =
{
  /* First bundle: */
  0xe300c000,		/* movw	ip, #:lower16:&GOT[2]-.+8	*/
  0xe340c000,		/* movt	ip, #:upper16:&GOT[2]-.+8	*/
  0xe08cc00f,		/* add	ip, ip, pc			*/
  0xe52dc008,		/* str	ip, [sp, #-8]!			*/
  /* Second bundle: */
  0xe3ccc103,		/* bic	ip, ip, #0xc0000000		*/
  0xe59cc000,		/* ldr	ip, [ip]			*/
  0xe3ccc13f,		/* bic	ip, ip, #0xc000000f		*/
  0xe12fff1c,		/* bx	ip				*/
  /* Third bundle: */
  0xe320f000,		/* nop					*/
  0xe320f000,		/* nop					*/
  0xe320f000,		/* nop					*/
  /* .Lplt_tail: */
  0xe50dc004,		/* str	ip, [sp, #-4]			*/
  /* Fourth bundle: */
  0xe3ccc103,		/* bic	ip, ip, #0xc0000000		*/
  0xe59cc000,		/* ldr	ip, [ip]			*/
  0xe3ccc13f,		/* bic	ip, ip, #0xc000000f		*/
  0xe12fff1c,		/* bx	ip				*/
};
#define ARM_NACL_PLT_TAIL_OFFSET	(11 * 4)

/* Subsequent entries in a procedure linkage table look like this.  */
static const bfd_vma elf32_arm_nacl_plt_entry [] =
{
  0xe300c000,		/* movw	ip, #:lower16:&GOT[n]-.+8	*/
  0xe340c000,		/* movt	ip, #:upper16:&GOT[n]-.+8	*/
  0xe08cc00f,		/* add	ip, ip, pc			*/
  0xea000000,		/* b	.Lplt_tail			*/
};

#define ARM_MAX_FWD_BRANCH_OFFSET  ((((1 << 23) - 1) << 2) + 8)
#define ARM_MAX_BWD_BRANCH_OFFSET  ((-((1 << 23) << 2)) + 8)
#define THM_MAX_FWD_BRANCH_OFFSET  ((1 << 22) -2 + 4)
#define THM_MAX_BWD_BRANCH_OFFSET  (-(1 << 22) + 4)
#define THM2_MAX_FWD_BRANCH_OFFSET (((1 << 24) - 2) + 4)
#define THM2_MAX_BWD_BRANCH_OFFSET (-(1 << 24) + 4)

enum stub_insn_type
{
  THUMB16_TYPE = 1,
  THUMB32_TYPE,
  ARM_TYPE,
  DATA_TYPE
};

#define THUMB16_INSN(X)		{(X), THUMB16_TYPE, R_ARM_NONE, 0}
/* A bit of a hack.  A Thumb conditional branch, in which the proper condition
   is inserted in arm_build_one_stub().  */
#define THUMB16_BCOND_INSN(X)	{(X), THUMB16_TYPE, R_ARM_NONE, 1}
#define THUMB32_INSN(X)		{(X), THUMB32_TYPE, R_ARM_NONE, 0}
#define THUMB32_B_INSN(X, Z)	{(X), THUMB32_TYPE, R_ARM_THM_JUMP24, (Z)}
#define ARM_INSN(X)		{(X), ARM_TYPE, R_ARM_NONE, 0}
#define ARM_REL_INSN(X, Z)	{(X), ARM_TYPE, R_ARM_JUMP24, (Z)}
#define DATA_WORD(X,Y,Z)	{(X), DATA_TYPE, (Y), (Z)}

typedef struct
{
  bfd_vma              data;
  enum stub_insn_type  type;
  unsigned int         r_type;
  int                  reloc_addend;
}  insn_sequence;

/* Arm/Thumb -> Arm/Thumb long branch stub. On V5T and above, use blx
   to reach the stub if necessary.  */
static const insn_sequence elf32_arm_stub_long_branch_any_any[] =
{
  ARM_INSN (0xe51ff004),            /* ldr   pc, [pc, #-4] */
  DATA_WORD (0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
};

/* V4T Arm -> Thumb long branch stub. Used on V4T where blx is not
   available.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_arm_thumb[] =
{
  ARM_INSN (0xe59fc000),            /* ldr   ip, [pc, #0] */
  ARM_INSN (0xe12fff1c),            /* bx    ip */
  DATA_WORD (0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
};

/* Thumb -> Thumb long branch stub. Used on M-profile architectures.  */
static const insn_sequence elf32_arm_stub_long_branch_thumb_only[] =
{
  THUMB16_INSN (0xb401),             /* push {r0} */
  THUMB16_INSN (0x4802),             /* ldr  r0, [pc, #8] */
  THUMB16_INSN (0x4684),             /* mov  ip, r0 */
  THUMB16_INSN (0xbc01),             /* pop  {r0} */
  THUMB16_INSN (0x4760),             /* bx   ip */
  THUMB16_INSN (0xbf00),             /* nop */
  DATA_WORD (0, R_ARM_ABS32, 0),     /* dcd  R_ARM_ABS32(X) */
};

/* V4T Thumb -> Thumb long branch stub. Using the stack is not
   allowed.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_thumb[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop */
  ARM_INSN (0xe59fc000),             /* ldr  ip, [pc, #0] */
  ARM_INSN (0xe12fff1c),             /* bx   ip */
  DATA_WORD (0, R_ARM_ABS32, 0),     /* dcd  R_ARM_ABS32(X) */
};

/* V4T Thumb -> ARM long branch stub. Used on V4T where blx is not
   available.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_arm[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop   */
  ARM_INSN (0xe51ff004),             /* ldr   pc, [pc, #-4] */
  DATA_WORD (0, R_ARM_ABS32, 0),     /* dcd   R_ARM_ABS32(X) */
};

/* V4T Thumb -> ARM short branch stub. Shorter variant of the above
   one, when the destination is close enough.  */
static const insn_sequence elf32_arm_stub_short_branch_v4t_thumb_arm[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop   */
  ARM_REL_INSN (0xea000000, -8),     /* b    (X-8) */
};

/* ARM/Thumb -> ARM long branch stub, PIC.  On V5T and above, use
   blx to reach the stub if necessary.  */
static const insn_sequence elf32_arm_stub_long_branch_any_arm_pic[] =
{
  ARM_INSN (0xe59fc000),             /* ldr   ip, [pc] */
  ARM_INSN (0xe08ff00c),             /* add   pc, pc, ip */
  DATA_WORD (0, R_ARM_REL32, -4),    /* dcd   R_ARM_REL32(X-4) */
};

/* ARM/Thumb -> Thumb long branch stub, PIC.  On V5T and above, use
   blx to reach the stub if necessary.  We can not add into pc;
   it is not guaranteed to mode switch (different in ARMv6 and
   ARMv7).  */
static const insn_sequence elf32_arm_stub_long_branch_any_thumb_pic[] =
{
  ARM_INSN (0xe59fc004),             /* ldr   ip, [pc, #4] */
  ARM_INSN (0xe08fc00c),             /* add   ip, pc, ip */
  ARM_INSN (0xe12fff1c),             /* bx    ip */
  DATA_WORD (0, R_ARM_REL32, 0),     /* dcd   R_ARM_REL32(X) */
};

/* V4T ARM -> ARM long branch stub, PIC.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_arm_thumb_pic[] =
{
  ARM_INSN (0xe59fc004),             /* ldr   ip, [pc, #4] */
  ARM_INSN (0xe08fc00c),             /* add   ip, pc, ip */
  ARM_INSN (0xe12fff1c),             /* bx    ip */
  DATA_WORD (0, R_ARM_REL32, 0),     /* dcd   R_ARM_REL32(X) */
};

/* V4T Thumb -> ARM long branch stub, PIC.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_arm_pic[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop  */
  ARM_INSN (0xe59fc000),             /* ldr  ip, [pc, #0] */
  ARM_INSN (0xe08cf00f),             /* add  pc, ip, pc */
  DATA_WORD (0, R_ARM_REL32, -4),     /* dcd  R_ARM_REL32(X) */
};

/* Thumb -> Thumb long branch stub, PIC. Used on M-profile
   architectures.  */
static const insn_sequence elf32_arm_stub_long_branch_thumb_only_pic[] =
{
  THUMB16_INSN (0xb401),             /* push {r0} */
  THUMB16_INSN (0x4802),             /* ldr  r0, [pc, #8] */
  THUMB16_INSN (0x46fc),             /* mov  ip, pc */
  THUMB16_INSN (0x4484),             /* add  ip, r0 */
  THUMB16_INSN (0xbc01),             /* pop  {r0} */
  THUMB16_INSN (0x4760),             /* bx   ip */
  DATA_WORD (0, R_ARM_REL32, 4),     /* dcd  R_ARM_REL32(X) */
};

/* V4T Thumb -> Thumb long branch stub, PIC. Using the stack is not
   allowed.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_thumb_pic[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop */
  ARM_INSN (0xe59fc004),             /* ldr  ip, [pc, #4] */
  ARM_INSN (0xe08fc00c),             /* add   ip, pc, ip */
  ARM_INSN (0xe12fff1c),             /* bx   ip */
  DATA_WORD (0, R_ARM_REL32, 0),     /* dcd  R_ARM_REL32(X) */
};

/* Thumb2/ARM -> TLS trampoline.  Lowest common denominator, which is a
   long PIC stub.  We can use r1 as a scratch -- and cannot use ip.  */
static const insn_sequence elf32_arm_stub_long_branch_any_tls_pic[] =
{
  ARM_INSN (0xe59f1000),             /* ldr   r1, [pc] */
  ARM_INSN (0xe08ff001),             /* add   pc, pc, r1 */
  DATA_WORD (0, R_ARM_REL32, -4),    /* dcd   R_ARM_REL32(X-4) */
};

/* V4T Thumb -> TLS trampoline.  lowest common denominator, which is a
   long PIC stub.  We can use r1 as a scratch -- and cannot use ip.  */
static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_tls_pic[] =
{
  THUMB16_INSN (0x4778),             /* bx   pc */
  THUMB16_INSN (0x46c0),             /* nop */
  ARM_INSN (0xe59f1000),             /* ldr  r1, [pc, #0] */
  ARM_INSN (0xe081f00f),             /* add  pc, r1, pc */
  DATA_WORD (0, R_ARM_REL32, -4),    /* dcd  R_ARM_REL32(X) */
};

/* NaCl ARM -> ARM long branch stub.  */
static const insn_sequence elf32_arm_stub_long_branch_arm_nacl[] =
{
  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
  ARM_INSN (0xe12fff1c),                /* bx	ip */
  ARM_INSN (0xe320f000),                /* nop */
  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
  DATA_WORD (0, R_ARM_ABS32, 0),        /* dcd	R_ARM_ABS32(X) */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
};

/* NaCl ARM -> ARM long branch stub, PIC.  */
static const insn_sequence elf32_arm_stub_long_branch_arm_nacl_pic[] =
{
  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
  ARM_INSN (0xe08cc00f),                /* add	ip, ip, pc */
  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
  ARM_INSN (0xe12fff1c),                /* bx	ip */
  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
  DATA_WORD (0, R_ARM_REL32, 8),        /* dcd	R_ARM_REL32(X+8) */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
};


/* Cortex-A8 erratum-workaround stubs.  */

/* Stub used for conditional branches (which may be beyond +/-1MB away, so we
   can't use a conditional branch to reach this stub).  */

static const insn_sequence elf32_arm_stub_a8_veneer_b_cond[] =
{
  THUMB16_BCOND_INSN (0xd001),         /* b<cond>.n true.  */
  THUMB32_B_INSN (0xf000b800, -4),     /* b.w insn_after_original_branch.  */
  THUMB32_B_INSN (0xf000b800, -4)      /* true: b.w original_branch_dest.  */
};

/* Stub used for b.w and bl.w instructions.  */

static const insn_sequence elf32_arm_stub_a8_veneer_b[] =
{
  THUMB32_B_INSN (0xf000b800, -4)	/* b.w original_branch_dest.  */
};

static const insn_sequence elf32_arm_stub_a8_veneer_bl[] =
{
  THUMB32_B_INSN (0xf000b800, -4)	/* b.w original_branch_dest.  */
};

/* Stub used for Thumb-2 blx.w instructions.  We modified the original blx.w
   instruction (which switches to ARM mode) to point to this stub.  Jump to the
   real destination using an ARM-mode branch.  */

static const insn_sequence elf32_arm_stub_a8_veneer_blx[] =
{
  ARM_REL_INSN (0xea000000, -8)	/* b original_branch_dest.  */
};

/* For each section group there can be a specially created linker section
   to hold the stubs for that group.  The name of the stub section is based
   upon the name of another section within that group with the suffix below
   applied.

   PR 13049: STUB_SUFFIX used to be ".stub", but this allowed the user to
   create what appeared to be a linker stub section when it actually
   contained user code/data.  For example, consider this fragment:

     const char * stubborn_problems[] = { "np" };

   If this is compiled with "-fPIC -fdata-sections" then gcc produces a
   section called:

     .data.rel.local.stubborn_problems

   This then causes problems in arm32_arm_build_stubs() as it triggers:

      // Ignore non-stub sections.
      if (!strstr (stub_sec->name, STUB_SUFFIX))
	continue;

   And so the section would be ignored instead of being processed.  Hence
   the change in definition of STUB_SUFFIX to a name that cannot be a valid
   C identifier.  */
#define STUB_SUFFIX ".__stub"

/* One entry per long/short branch stub defined above.  */
#define DEF_STUBS \
  DEF_STUB(long_branch_any_any)	\
  DEF_STUB(long_branch_v4t_arm_thumb) \
  DEF_STUB(long_branch_thumb_only) \
  DEF_STUB(long_branch_v4t_thumb_thumb)	\
  DEF_STUB(long_branch_v4t_thumb_arm) \
  DEF_STUB(short_branch_v4t_thumb_arm) \
  DEF_STUB(long_branch_any_arm_pic) \
  DEF_STUB(long_branch_any_thumb_pic) \
  DEF_STUB(long_branch_v4t_thumb_thumb_pic) \
  DEF_STUB(long_branch_v4t_arm_thumb_pic) \
  DEF_STUB(long_branch_v4t_thumb_arm_pic) \
  DEF_STUB(long_branch_thumb_only_pic) \
  DEF_STUB(long_branch_any_tls_pic) \
  DEF_STUB(long_branch_v4t_thumb_tls_pic) \
  DEF_STUB(long_branch_arm_nacl) \
  DEF_STUB(long_branch_arm_nacl_pic) \
  DEF_STUB(a8_veneer_b_cond) \
  DEF_STUB(a8_veneer_b) \
  DEF_STUB(a8_veneer_bl) \
  DEF_STUB(a8_veneer_blx)

#define DEF_STUB(x) arm_stub_##x,
enum elf32_arm_stub_type
{
  arm_stub_none,
  DEF_STUBS
  /* Note the first a8_veneer type */
  arm_stub_a8_veneer_lwm = arm_stub_a8_veneer_b_cond
};
#undef DEF_STUB

typedef struct
{
  const insn_sequence* template_sequence;
  int template_size;
} stub_def;

#define DEF_STUB(x) {elf32_arm_stub_##x, ARRAY_SIZE(elf32_arm_stub_##x)},
static const stub_def stub_definitions[] =
{
  {NULL, 0},
  DEF_STUBS
};

struct elf32_arm_stub_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry root;

  /* The stub section.  */
  asection *stub_sec;

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;

  /* Given the symbol's value and its section we can determine its final
     value when building the stubs (so the stub knows where to jump).  */
  bfd_vma target_value;
  asection *target_section;

  /* Offset to apply to relocation referencing target_value.  */
  bfd_vma target_addend;

  /* The instruction which caused this stub to be generated (only valid for
     Cortex-A8 erratum workaround stubs at present).  */
  unsigned long orig_insn;

  /* The stub type.  */
  enum elf32_arm_stub_type stub_type;
  /* Its encoding size in bytes.  */
  int stub_size;
  /* Its template.  */
  const insn_sequence *stub_template;
  /* The size of the template (number of entries).  */
  int stub_template_size;

  /* The symbol table entry, if any, that this was derived from.  */
  struct elf32_arm_link_hash_entry *h;

  /* Type of branch.  */
  enum arm_st_branch_type branch_type;

  /* Where this stub is being called from, or, in the case of combined
     stub sections, the first input section in the group.  */
  asection *id_sec;

  /* The name for the local symbol at the start of this stub.  The
     stub name in the hash table has to be unique; this does not, so
     it can be friendlier.  */
  char *output_name;
};

/* Used to build a map of a section.  This is required for mixed-endian
   code/data.  */

typedef struct elf32_elf_section_map
{
  bfd_vma vma;
  char type;
}
elf32_arm_section_map;

/* Information about a VFP11 erratum veneer, or a branch to such a veneer.  */

typedef enum
{
  VFP11_ERRATUM_BRANCH_TO_ARM_VENEER,
  VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER,
  VFP11_ERRATUM_ARM_VENEER,
  VFP11_ERRATUM_THUMB_VENEER
}
elf32_vfp11_erratum_type;

typedef struct elf32_vfp11_erratum_list
{
  struct elf32_vfp11_erratum_list *next;
  bfd_vma vma;
  union
  {
    struct
    {
      struct elf32_vfp11_erratum_list *veneer;
      unsigned int vfp_insn;
    } b;
    struct
    {
      struct elf32_vfp11_erratum_list *branch;
      unsigned int id;
    } v;
  } u;
  elf32_vfp11_erratum_type type;
}
elf32_vfp11_erratum_list;

typedef enum
{
  DELETE_EXIDX_ENTRY,
  INSERT_EXIDX_CANTUNWIND_AT_END
}
arm_unwind_edit_type;

/* A (sorted) list of edits to apply to an unwind table.  */
typedef struct arm_unwind_table_edit
{
  arm_unwind_edit_type type;
  /* Note: we sometimes want to insert an unwind entry corresponding to a
     section different from the one we're currently writing out, so record the
     (text) section this edit relates to here.  */
  asection *linked_section;
  unsigned int index;
  struct arm_unwind_table_edit *next;
}
arm_unwind_table_edit;

typedef struct _arm_elf_section_data
{
  /* Information about mapping symbols.  */
  struct bfd_elf_section_data elf;
  unsigned int mapcount;
  unsigned int mapsize;
  elf32_arm_section_map *map;
  /* Information about CPU errata.  */
  unsigned int erratumcount;
  elf32_vfp11_erratum_list *erratumlist;
  /* Information about unwind tables.  */
  union
  {
    /* Unwind info attached to a text section.  */
    struct
    {
      asection *arm_exidx_sec;
    } text;

    /* Unwind info attached to an .ARM.exidx section.  */
    struct
    {
      arm_unwind_table_edit *unwind_edit_list;
      arm_unwind_table_edit *unwind_edit_tail;
    } exidx;
  } u;
}
_arm_elf_section_data;

#define elf32_arm_section_data(sec) \
  ((_arm_elf_section_data *) elf_section_data (sec))

/* A fix which might be required for Cortex-A8 Thumb-2 branch/TLB erratum.
   These fixes are subject to a relaxation procedure (in elf32_arm_size_stubs),
   so may be created multiple times: we use an array of these entries whilst
   relaxing which we can refresh easily, then create stubs for each potentially
   erratum-triggering instruction once we've settled on a solution.  */

struct a8_erratum_fix
{
  bfd *input_bfd;
  asection *section;
  bfd_vma offset;
  bfd_vma addend;
  unsigned long orig_insn;
  char *stub_name;
  enum elf32_arm_stub_type stub_type;
  enum arm_st_branch_type branch_type;
};

/* A table of relocs applied to branches which might trigger Cortex-A8
   erratum.  */

struct a8_erratum_reloc
{
  bfd_vma from;
  bfd_vma destination;
  struct elf32_arm_link_hash_entry *hash;
  const char *sym_name;
  unsigned int r_type;
  enum arm_st_branch_type branch_type;
  bfd_boolean non_a8_stub;
};

/* The size of the thread control block.  */
#define TCB_SIZE	8

/* ARM-specific information about a PLT entry, over and above the usual
   gotplt_union.  */
struct arm_plt_info
{
  /* We reference count Thumb references to a PLT entry separately,
     so that we can emit the Thumb trampoline only if needed.  */
  bfd_signed_vma thumb_refcount;

  /* Some references from Thumb code may be eliminated by BL->BLX
     conversion, so record them separately.  */
  bfd_signed_vma maybe_thumb_refcount;

  /* How many of the recorded PLT accesses were from non-call relocations.
     This information is useful when deciding whether anything takes the
     address of an STT_GNU_IFUNC PLT.  A value of 0 means that all
     non-call references to the function should resolve directly to the
     real runtime target.  */
  unsigned int noncall_refcount;

  /* Since PLT entries have variable size if the Thumb prologue is
     used, we need to record the index into .got.plt instead of
     recomputing it from the PLT offset.  */
  bfd_signed_vma got_offset;
};

/* Information about an .iplt entry for a local STT_GNU_IFUNC symbol.  */
struct arm_local_iplt_info
{
  /* The information that is usually found in the generic ELF part of
     the hash table entry.  */
  union gotplt_union root;

  /* The information that is usually found in the ARM-specific part of
     the hash table entry.  */
  struct arm_plt_info arm;

  /* A list of all potential dynamic relocations against this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;
};

struct elf_arm_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;

  /* GOTPLT entries for TLS descriptors.  */
  bfd_vma *local_tlsdesc_gotent;

  /* Information for local symbols that need entries in .iplt.  */
  struct arm_local_iplt_info **local_iplt;

  /* Zero to warn when linking objects with incompatible enum sizes.  */
  int no_enum_size_warning;

  /* Zero to warn when linking objects with incompatible wchar_t sizes.  */
  int no_wchar_size_warning;
};

#define elf_arm_tdata(bfd) \
  ((struct elf_arm_obj_tdata *) (bfd)->tdata.any)

#define elf32_arm_local_got_tls_type(bfd) \
  (elf_arm_tdata (bfd)->local_got_tls_type)

#define elf32_arm_local_tlsdesc_gotent(bfd) \
  (elf_arm_tdata (bfd)->local_tlsdesc_gotent)

#define elf32_arm_local_iplt(bfd) \
  (elf_arm_tdata (bfd)->local_iplt)

#define is_arm_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_tdata (bfd) != NULL \
   && elf_object_id (bfd) == ARM_ELF_DATA)

static bfd_boolean
elf32_arm_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_arm_obj_tdata),
				  ARM_ELF_DATA);
}

#define elf32_arm_hash_entry(ent) ((struct elf32_arm_link_hash_entry *)(ent))

/* Arm ELF linker hash entry.  */
struct elf32_arm_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

  /* ARM-specific PLT information.  */
  struct arm_plt_info plt;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	4
#define GOT_TLS_GDESC	8
#define GOT_TLS_GD_ANY_P(type)	((type & GOT_TLS_GD) || (type & GOT_TLS_GDESC))
  unsigned int tls_type : 8;

  /* True if the symbol's PLT entry is in .iplt rather than .plt.  */
  unsigned int is_iplt : 1;

  unsigned int unused : 23;

  /* Offset of the GOTPLT entry reserved for the TLS descriptor,
     starting at the end of the jump table.  */
  bfd_vma tlsdesc_got;

  /* The symbol marking the real symbol location for exported thumb
     symbols with Arm stubs.  */
  struct elf_link_hash_entry *export_glue;

  /* A pointer to the most recently used stub hash entry against this
     symbol.  */
  struct elf32_arm_stub_hash_entry *stub_cache;
};

/* Traverse an arm ELF linker hash table.  */
#define elf32_arm_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Get the ARM elf linker hash table from a link_info structure.  */
#define elf32_arm_hash_table(info) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((info)->hash)) \
  == ARM_ELF_DATA ? ((struct elf32_arm_link_hash_table *) ((info)->hash)) : NULL)

#define arm_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_arm_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

/* Array to keep track of which stub sections have been created, and
   information on stub grouping.  */
struct map_stub
{
  /* This is the section to which stubs in the group will be
     attached.  */
  asection *link_sec;
  /* The stub section.  */
  asection *stub_sec;
};

#define elf32_arm_compute_jump_table_size(htab) \
  ((htab)->next_tls_desc_index * 4)

/* ARM ELF linker hash table.  */
struct elf32_arm_link_hash_table
{
  /* The main hash table.  */
  struct elf_link_hash_table root;

  /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
  bfd_size_type thumb_glue_size;

  /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
  bfd_size_type arm_glue_size;

  /* The size in bytes of section containing the ARMv4 BX veneers.  */
  bfd_size_type bx_glue_size;

  /* Offsets of ARMv4 BX veneers.  Bit1 set if present, and Bit0 set when
     veneer has been populated.  */
  bfd_vma bx_glue_offset[15];

  /* The size in bytes of the section containing glue for VFP11 erratum
     veneers.  */
  bfd_size_type vfp11_erratum_glue_size;

  /* A table of fix locations for Cortex-A8 Thumb-2 branch/TLB erratum.  This
     holds Cortex-A8 erratum fix locations between elf32_arm_size_stubs() and
     elf32_arm_write_section().  */
  struct a8_erratum_fix *a8_erratum_fixes;
  unsigned int num_a8_erratum_fixes;

  /* An arbitrary input BFD chosen to hold the glue sections.  */
  bfd * bfd_of_glue_owner;

  /* Nonzero to output a BE8 image.  */
  int byteswap_code;

  /* Zero if R_ARM_TARGET1 means R_ARM_ABS32.
     Nonzero if R_ARM_TARGET1 means R_ARM_REL32.  */
  int target1_is_rel;

  /* The relocation to use for R_ARM_TARGET2 relocations.  */
  int target2_reloc;

  /* 0 = Ignore R_ARM_V4BX.
     1 = Convert BX to MOV PC.
     2 = Generate v4 interworing stubs.  */
  int fix_v4bx;

  /* Whether we should fix the Cortex-A8 Thumb-2 branch/TLB erratum.  */
  int fix_cortex_a8;

  /* Whether we should fix the ARM1176 BLX immediate issue.  */
  int fix_arm1176;

  /* Nonzero if the ARM/Thumb BLX instructions are available for use.  */
  int use_blx;

  /* What sort of code sequences we should look for which may trigger the
     VFP11 denorm erratum.  */
  bfd_arm_vfp11_fix vfp11_fix;

  /* Global counter for the number of fixes we have emitted.  */
  int num_vfp11_fixes;

  /* Nonzero to force PIC branch veneers.  */
  int pic_veneer;

  /* The number of bytes in the initial entry in the PLT.  */
  bfd_size_type plt_header_size;

  /* The number of bytes in the subsequent PLT etries.  */
  bfd_size_type plt_entry_size;

  /* True if the target system is VxWorks.  */
  int vxworks_p;

  /* True if the target system is Symbian OS.  */
  int symbian_p;

  /* True if the target system is Native Client.  */
  int nacl_p;

  /* True if the target uses REL relocations.  */
  int use_rel;

  /* The index of the next unused R_ARM_TLS_DESC slot in .rel.plt.  */
  bfd_vma next_tls_desc_index;

  /* How many R_ARM_TLS_DESC relocations were generated so far.  */
  bfd_vma num_tls_desc;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sdynbss;
  asection *srelbss;

  /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */
  asection *srelplt2;

  /* The offset into splt of the PLT entry for the TLS descriptor
     resolver.  Special values are 0, if not necessary (or not found
     to be necessary yet), and -1 if needed but not determined
     yet.  */
  bfd_vma dt_tlsdesc_plt;

  /* The offset into sgot of the GOT entry used by the PLT entry
     above.  */
  bfd_vma dt_tlsdesc_got;

  /* Offset in .plt section of tls_arm_trampoline.  */
  bfd_vma tls_trampoline;

  /* Data for R_ARM_TLS_LDM32 relocations.  */
  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  /* For convenience in allocate_dynrelocs.  */
  bfd * obfd;

  /* The amount of space used by the reserved portion of the sgotplt
     section, plus whatever space is used by the jump slots.  */
  bfd_vma sgotplt_jump_table_size;

  /* The stub hash table.  */
  struct bfd_hash_table stub_hash_table;

  /* Linker stub bfd.  */
  bfd *stub_bfd;

  /* Linker call-backs.  */
  asection * (*add_stub_section) (const char *, asection *, unsigned int);
  void (*layout_sections_again) (void);

  /* Array to keep track of which stub sections have been created, and
     information on stub grouping.  */
  struct map_stub *stub_group;

  /* Number of elements in stub_group.  */
  int top_id;

  /* Assorted information used by elf32_arm_size_stubs.  */
  unsigned int bfd_count;
  int top_index;
  asection **input_list;
};

/* Create an entry in an ARM ELF linker hash table.  */

static struct bfd_hash_entry *
elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
			     struct bfd_hash_table * table,
			     const char * string)
{
  struct elf32_arm_link_hash_entry * ret =
    (struct elf32_arm_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct elf32_arm_link_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf32_arm_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != NULL)
    {
      ret->dyn_relocs = NULL;
      ret->tls_type = GOT_UNKNOWN;
      ret->tlsdesc_got = (bfd_vma) -1;
      ret->plt.thumb_refcount = 0;
      ret->plt.maybe_thumb_refcount = 0;
      ret->plt.noncall_refcount = 0;
      ret->plt.got_offset = -1;
      ret->is_iplt = FALSE;
      ret->export_glue = NULL;

      ret->stub_cache = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Ensure that we have allocated bookkeeping structures for ABFD's local
   symbols.  */

static bfd_boolean
elf32_arm_allocate_local_sym_info (bfd *abfd)
{
  if (elf_local_got_refcounts (abfd) == NULL)
    {
      bfd_size_type num_syms;
      bfd_size_type size;
      char *data;

      num_syms = elf_tdata (abfd)->symtab_hdr.sh_info;
      size = num_syms * (sizeof (bfd_signed_vma)
			 + sizeof (struct arm_local_iplt_info *)
			 + sizeof (bfd_vma)
			 + sizeof (char));
      data = bfd_zalloc (abfd, size);
      if (data == NULL)
	return FALSE;

      elf_local_got_refcounts (abfd) = (bfd_signed_vma *) data;
      data += num_syms * sizeof (bfd_signed_vma);

      elf32_arm_local_iplt (abfd) = (struct arm_local_iplt_info **) data;
      data += num_syms * sizeof (struct arm_local_iplt_info *);

      elf32_arm_local_tlsdesc_gotent (abfd) = (bfd_vma *) data;
      data += num_syms * sizeof (bfd_vma);

      elf32_arm_local_got_tls_type (abfd) = data;
    }
  return TRUE;
}

/* Return the .iplt information for local symbol R_SYMNDX, which belongs
   to input bfd ABFD.  Create the information if it doesn't already exist.
   Return null if an allocation fails.  */

static struct arm_local_iplt_info *
elf32_arm_create_local_iplt (bfd *abfd, unsigned long r_symndx)
{
  struct arm_local_iplt_info **ptr;

  if (!elf32_arm_allocate_local_sym_info (abfd))
    return NULL;

  BFD_ASSERT (r_symndx < elf_tdata (abfd)->symtab_hdr.sh_info);
  ptr = &elf32_arm_local_iplt (abfd)[r_symndx];
  if (*ptr == NULL)
    *ptr = bfd_zalloc (abfd, sizeof (**ptr));
  return *ptr;
}

/* Try to obtain PLT information for the symbol with index R_SYMNDX
   in ABFD's symbol table.  If the symbol is global, H points to its
   hash table entry, otherwise H is null.

   Return true if the symbol does have PLT information.  When returning
   true, point *ROOT_PLT at the target-independent reference count/offset
   union and *ARM_PLT at the ARM-specific information.  */

static bfd_boolean
elf32_arm_get_plt_info (bfd *abfd, struct elf32_arm_link_hash_entry *h,
			unsigned long r_symndx, union gotplt_union **root_plt,
			struct arm_plt_info **arm_plt)
{
  struct arm_local_iplt_info *local_iplt;

  if (h != NULL)
    {
      *root_plt = &h->root.plt;
      *arm_plt = &h->plt;
      return TRUE;
    }

  if (elf32_arm_local_iplt (abfd) == NULL)
    return FALSE;

  local_iplt = elf32_arm_local_iplt (abfd)[r_symndx];
  if (local_iplt == NULL)
    return FALSE;

  *root_plt = &local_iplt->root;
  *arm_plt = &local_iplt->arm;
  return TRUE;
}

/* Return true if the PLT described by ARM_PLT requires a Thumb stub
   before it.  */

static bfd_boolean
elf32_arm_plt_needs_thumb_stub_p (struct bfd_link_info *info,
				  struct arm_plt_info *arm_plt)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  return (arm_plt->thumb_refcount != 0
	  || (!htab->use_blx && arm_plt->maybe_thumb_refcount != 0));
}

/* Return a pointer to the head of the dynamic reloc list that should
   be used for local symbol ISYM, which is symbol number R_SYMNDX in
   ABFD's symbol table.  Return null if an error occurs.  */

static struct elf_dyn_relocs **
elf32_arm_get_local_dynreloc_list (bfd *abfd, unsigned long r_symndx,
				   Elf_Internal_Sym *isym)
{
  if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
    {
      struct arm_local_iplt_info *local_iplt;

      local_iplt = elf32_arm_create_local_iplt (abfd, r_symndx);
      if (local_iplt == NULL)
	return NULL;
      return &local_iplt->dyn_relocs;
    }
  else
    {
      /* Track dynamic relocs needed for local syms too.
	 We really need local syms available to do this
	 easily.  Oh well.  */
      asection *s;
      void *vpp;

      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
      if (s == NULL)
	abort ();

      vpp = &elf_section_data (s)->local_dynrel;
      return (struct elf_dyn_relocs **) vpp;
    }
}

/* Initialize an entry in the stub hash table.  */

static struct bfd_hash_entry *
stub_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *)
	  bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_arm_stub_hash_entry *eh;

      /* Initialize the local fields.  */
      eh = (struct elf32_arm_stub_hash_entry *) entry;
      eh->stub_sec = NULL;
      eh->stub_offset = 0;
      eh->target_value = 0;
      eh->target_section = NULL;
      eh->target_addend = 0;
      eh->orig_insn = 0;
      eh->stub_type = arm_stub_none;
      eh->stub_size = 0;
      eh->stub_template = NULL;
      eh->stub_template_size = 0;
      eh->h = NULL;
      eh->id_sec = NULL;
      eh->output_name = NULL;
    }

  return entry;
}

/* Create .got, .gotplt, and .rel(a).got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* BPABI objects never have a GOT, or associated sections.  */
  if (htab->symbian_p)
    return TRUE;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  return TRUE;
}

/* Create the .iplt, .rel(a).iplt and .igot.plt sections.  */

static bfd_boolean
create_ifunc_sections (struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *htab;
  const struct elf_backend_data *bed;
  bfd *dynobj;
  asection *s;
  flagword flags;

  htab = elf32_arm_hash_table (info);
  dynobj = htab->root.dynobj;
  bed = get_elf_backend_data (dynobj);
  flags = bed->dynamic_sec_flags;

  if (htab->root.iplt == NULL)
    {
      s = bfd_make_section_anyway_with_flags (dynobj, ".iplt",
					      flags | SEC_READONLY | SEC_CODE);
      if (s == NULL
	  || !bfd_set_section_alignment (dynobj, s, bed->plt_alignment))
	return FALSE;
      htab->root.iplt = s;
    }

  if (htab->root.irelplt == NULL)
    {
      s = bfd_make_section_anyway_with_flags (dynobj,
					      RELOC_SECTION (htab, ".iplt"),
					      flags | SEC_READONLY);
      if (s == NULL
	  || !bfd_set_section_alignment (dynobj, s, bed->s->log_file_align))
	return FALSE;
      htab->root.irelplt = s;
    }

  if (htab->root.igotplt == NULL)
    {
      s = bfd_make_section_anyway_with_flags (dynobj, ".igot.plt", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (dynobj, s, bed->s->log_file_align))
	return FALSE;
      htab->root.igotplt = s;
    }
  return TRUE;
}

/* Create .plt, .rel(a).plt, .got, .got.plt, .rel(a).got, .dynbss, and
   .rel(a).bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf32_arm_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (!htab->root.sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->sdynbss = bfd_get_linker_section (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_linker_section (dynobj,
					    RELOC_SECTION (htab, ".bss"));

  if (htab->vxworks_p)
    {
      if (!elf_vxworks_create_dynamic_sections (dynobj, info, &htab->srelplt2))
	return FALSE;

      if (info->shared)
	{
	  htab->plt_header_size = 0;
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (elf32_arm_vxworks_shared_plt_entry);
	}
      else
	{
	  htab->plt_header_size
	    = 4 * ARRAY_SIZE (elf32_arm_vxworks_exec_plt0_entry);
	  htab->plt_entry_size
	    = 4 * ARRAY_SIZE (elf32_arm_vxworks_exec_plt_entry);
	}
    }

  if (!htab->root.splt
      || !htab->root.srelplt
      || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf32_arm_copy_indirect_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;

  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ind->root.type == bfd_link_hash_indirect)
    {
      /* Copy over PLT info.  */
      edir->plt.thumb_refcount += eind->plt.thumb_refcount;
      eind->plt.thumb_refcount = 0;
      edir->plt.maybe_thumb_refcount += eind->plt.maybe_thumb_refcount;
      eind->plt.maybe_thumb_refcount = 0;
      edir->plt.noncall_refcount += eind->plt.noncall_refcount;
      eind->plt.noncall_refcount = 0;

      /* We should only allocate a function to .iplt once the final
	 symbol information is known.  */
      BFD_ASSERT (!eind->is_iplt);

      if (dir->got.refcount <= 0)
	{
	  edir->tls_type = eind->tls_type;
	  eind->tls_type = GOT_UNKNOWN;
	}
    }

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

/* Create an ARM elf linker hash table.  */

static struct bfd_link_hash_table *
elf32_arm_link_hash_table_create (bfd *abfd)
{
  struct elf32_arm_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf32_arm_link_hash_table);

  ret = (struct elf32_arm_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (& ret->root, abfd,
				      elf32_arm_link_hash_newfunc,
				      sizeof (struct elf32_arm_link_hash_entry),
				      ARM_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
#ifdef FOUR_WORD_PLT
  ret->plt_header_size = 16;
  ret->plt_entry_size = 16;
#else
  ret->plt_header_size = 20;
  ret->plt_entry_size = 12;
#endif
  ret->use_rel = 1;
  ret->obfd = abfd;

  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc,
			    sizeof (struct elf32_arm_stub_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return &ret->root.root;
}

/* Free the derived linker hash table.  */

static void
elf32_arm_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct elf32_arm_link_hash_table *ret
    = (struct elf32_arm_link_hash_table *) hash;

  bfd_hash_table_free (&ret->stub_hash_table);
  _bfd_elf_link_hash_table_free (hash);
}

/* Determine if we're dealing with a Thumb only architecture.  */

static bfd_boolean
using_thumb_only (struct elf32_arm_link_hash_table *globals)
{
  int arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				       Tag_CPU_arch);
  int profile;

  if (arch == TAG_CPU_ARCH_V6_M || arch == TAG_CPU_ARCH_V6S_M)
    return TRUE;

  if (arch != TAG_CPU_ARCH_V7 && arch != TAG_CPU_ARCH_V7E_M)
    return FALSE;

  profile = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				      Tag_CPU_arch_profile);

  return profile == 'M';
}

/* Determine if we're dealing with a Thumb-2 object.  */

static bfd_boolean
using_thumb2 (struct elf32_arm_link_hash_table *globals)
{
  int arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				       Tag_CPU_arch);
  return arch == TAG_CPU_ARCH_V6T2 || arch >= TAG_CPU_ARCH_V7;
}

/* Determine what kind of NOPs are available.  */

static bfd_boolean
arch_has_arm_nop (struct elf32_arm_link_hash_table *globals)
{
  const int arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
					     Tag_CPU_arch);
  return arch == TAG_CPU_ARCH_V6T2
	 || arch == TAG_CPU_ARCH_V6K
	 || arch == TAG_CPU_ARCH_V7
	 || arch == TAG_CPU_ARCH_V7E_M;
}

static bfd_boolean
arch_has_thumb2_nop (struct elf32_arm_link_hash_table *globals)
{
  const int arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
					     Tag_CPU_arch);
  return (arch == TAG_CPU_ARCH_V6T2 || arch == TAG_CPU_ARCH_V7
	  || arch == TAG_CPU_ARCH_V7E_M);
}

static bfd_boolean
arm_stub_is_thumb (enum elf32_arm_stub_type stub_type)
{
  switch (stub_type)
    {
    case arm_stub_long_branch_thumb_only:
    case arm_stub_long_branch_v4t_thumb_arm:
    case arm_stub_short_branch_v4t_thumb_arm:
    case arm_stub_long_branch_v4t_thumb_arm_pic:
    case arm_stub_long_branch_v4t_thumb_tls_pic:
    case arm_stub_long_branch_thumb_only_pic:
      return TRUE;
    case arm_stub_none:
      BFD_FAIL ();
      return FALSE;
      break;
    default:
      return FALSE;
    }
}

/* Determine the type of stub needed, if any, for a call.  */

static enum elf32_arm_stub_type
arm_type_of_stub (struct bfd_link_info *info,
		  asection *input_sec,
		  const Elf_Internal_Rela *rel,
		  unsigned char st_type,
		  enum arm_st_branch_type *actual_branch_type,
		  struct elf32_arm_link_hash_entry *hash,
		  bfd_vma destination,
		  asection *sym_sec,
		  bfd *input_bfd,
		  const char *name)
{
  bfd_vma location;
  bfd_signed_vma branch_offset;
  unsigned int r_type;
  struct elf32_arm_link_hash_table * globals;
  int thumb2;
  int thumb_only;
  enum elf32_arm_stub_type stub_type = arm_stub_none;
  int use_plt = 0;
  enum arm_st_branch_type branch_type = *actual_branch_type;
  union gotplt_union *root_plt;
  struct arm_plt_info *arm_plt;

  if (branch_type == ST_BRANCH_LONG)
    return stub_type;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return stub_type;

  thumb_only = using_thumb_only (globals);

  thumb2 = using_thumb2 (globals);

  /* Determine where the call point is.  */
  location = (input_sec->output_offset
	      + input_sec->output_section->vma
	      + rel->r_offset);

  r_type = ELF32_R_TYPE (rel->r_info);

  /* ST_BRANCH_TO_ARM is nonsense to thumb-only targets when we
     are considering a function call relocation.  */
  if (thumb_only && (r_type == R_ARM_THM_CALL || r_type == R_ARM_THM_JUMP24)
      && branch_type == ST_BRANCH_TO_ARM)
    branch_type = ST_BRANCH_TO_THUMB;

  /* For TLS call relocs, it is the caller's responsibility to provide
     the address of the appropriate trampoline.  */
  if (r_type != R_ARM_TLS_CALL
      && r_type != R_ARM_THM_TLS_CALL
      && elf32_arm_get_plt_info (input_bfd, hash, ELF32_R_SYM (rel->r_info),
				 &root_plt, &arm_plt)
      && root_plt->offset != (bfd_vma) -1)
    {
      asection *splt;

      if (hash == NULL || hash->is_iplt)
	splt = globals->root.iplt;
      else
	splt = globals->root.splt;
      if (splt != NULL)
	{
	  use_plt = 1;

	  /* Note when dealing with PLT entries: the main PLT stub is in
	     ARM mode, so if the branch is in Thumb mode, another
	     Thumb->ARM stub will be inserted later just before the ARM
	     PLT stub. We don't take this extra distance into account
	     here, because if a long branch stub is needed, we'll add a
	     Thumb->Arm one and branch directly to the ARM PLT entry
	     because it avoids spreading offset corrections in several
	     places.  */

	  destination = (splt->output_section->vma
			 + splt->output_offset
			 + root_plt->offset);
	  st_type = STT_FUNC;
	  branch_type = ST_BRANCH_TO_ARM;
	}
    }
  /* Calls to STT_GNU_IFUNC symbols should go through a PLT.  */
  BFD_ASSERT (st_type != STT_GNU_IFUNC);

  branch_offset = (bfd_signed_vma)(destination - location);

  if (r_type == R_ARM_THM_CALL || r_type == R_ARM_THM_JUMP24
      || r_type == R_ARM_THM_TLS_CALL)
    {
      /* Handle cases where:
	 - this call goes too far (different Thumb/Thumb2 max
	   distance)
	 - it's a Thumb->Arm call and blx is not available, or it's a
	   Thumb->Arm branch (not bl). A stub is needed in this case,
	   but only if this call is not through a PLT entry. Indeed,
	   PLT stubs handle mode switching already.
      */
      if ((!thumb2
	    && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
		|| (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
	  || (thumb2
	      && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
		  || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
	  || (branch_type == ST_BRANCH_TO_ARM
	      && (((r_type == R_ARM_THM_CALL
		    || r_type == R_ARM_THM_TLS_CALL) && !globals->use_blx)
		  || (r_type == R_ARM_THM_JUMP24))
	      && !use_plt))
	{
	  if (branch_type == ST_BRANCH_TO_THUMB)
	    {
	      /* Thumb to thumb.  */
	      if (!thumb_only)
		{
		  stub_type = (info->shared | globals->pic_veneer)
		    /* PIC stubs.  */
		    ? ((globals->use_blx
			&& (r_type == R_ARM_THM_CALL))
		       /* V5T and above. Stub starts with ARM code, so
			  we must be able to switch mode before
			  reaching it, which is only possible for 'bl'
			  (ie R_ARM_THM_CALL relocation).  */
		       ? arm_stub_long_branch_any_thumb_pic
		       /* On V4T, use Thumb code only.  */
		       : arm_stub_long_branch_v4t_thumb_thumb_pic)

		    /* non-PIC stubs.  */
		    : ((globals->use_blx
			&& (r_type == R_ARM_THM_CALL))
		       /* V5T and above.  */
		       ? arm_stub_long_branch_any_any
		       /* V4T.  */
		       : arm_stub_long_branch_v4t_thumb_thumb);
		}
	      else
		{
		  stub_type = (info->shared | globals->pic_veneer)
		    /* PIC stub.  */
		    ? arm_stub_long_branch_thumb_only_pic
		    /* non-PIC stub.  */
		    : arm_stub_long_branch_thumb_only;
		}
	    }
	  else
	    {
	      /* Thumb to arm.  */
	      if (sym_sec != NULL
		  && sym_sec->owner != NULL
		  && !INTERWORK_FLAG (sym_sec->owner))
		{
		  (*_bfd_error_handler)
		    (_("%B(%s): warning: interworking not enabled.\n"
		       "  first occurrence: %B: Thumb call to ARM"),
		     sym_sec->owner, input_bfd, name);
		}

	      stub_type =
		(info->shared | globals->pic_veneer)
		/* PIC stubs.  */
		? (r_type == R_ARM_THM_TLS_CALL
		   /* TLS PIC stubs */
		   ? (globals->use_blx ? arm_stub_long_branch_any_tls_pic
		      : arm_stub_long_branch_v4t_thumb_tls_pic)
		   : ((globals->use_blx && r_type == R_ARM_THM_CALL)
		      /* V5T PIC and above.  */
		      ? arm_stub_long_branch_any_arm_pic
		      /* V4T PIC stub.  */
		      : arm_stub_long_branch_v4t_thumb_arm_pic))

		/* non-PIC stubs.  */
		: ((globals->use_blx && r_type == R_ARM_THM_CALL)
		   /* V5T and above.  */
		   ? arm_stub_long_branch_any_any
		   /* V4T.  */
		   : arm_stub_long_branch_v4t_thumb_arm);

	      /* Handle v4t short branches.  */
	      if ((stub_type == arm_stub_long_branch_v4t_thumb_arm)
		  && (branch_offset <= THM_MAX_FWD_BRANCH_OFFSET)
		  && (branch_offset >= THM_MAX_BWD_BRANCH_OFFSET))
		stub_type = arm_stub_short_branch_v4t_thumb_arm;
	    }
	}
    }
  else if (r_type == R_ARM_CALL
	   || r_type == R_ARM_JUMP24
	   || r_type == R_ARM_PLT32
	   || r_type == R_ARM_TLS_CALL)
    {
      if (branch_type == ST_BRANCH_TO_THUMB)
	{
	  /* Arm to thumb.  */

	  if (sym_sec != NULL
	      && sym_sec->owner != NULL
	      && !INTERWORK_FLAG (sym_sec->owner))
	    {
	      (*_bfd_error_handler)
		(_("%B(%s): warning: interworking not enabled.\n"
		   "  first occurrence: %B: ARM call to Thumb"),
		 sym_sec->owner, input_bfd, name);
	    }

	  /* We have an extra 2-bytes reach because of
	     the mode change (bit 24 (H) of BLX encoding).  */
	  if (branch_offset > (ARM_MAX_FWD_BRANCH_OFFSET + 2)
	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
	      || (r_type == R_ARM_CALL && !globals->use_blx)
	      || (r_type == R_ARM_JUMP24)
	      || (r_type == R_ARM_PLT32))
	    {
	      stub_type = (info->shared | globals->pic_veneer)
		/* PIC stubs.  */
		? ((globals->use_blx)
		   /* V5T and above.  */
		   ? arm_stub_long_branch_any_thumb_pic
		   /* V4T stub.  */
		   : arm_stub_long_branch_v4t_arm_thumb_pic)

		/* non-PIC stubs.  */
		: ((globals->use_blx)
		   /* V5T and above.  */
		   ? arm_stub_long_branch_any_any
		   /* V4T.  */
		   : arm_stub_long_branch_v4t_arm_thumb);
	    }
	}
      else
	{
	  /* Arm to arm.  */
	  if (branch_offset > ARM_MAX_FWD_BRANCH_OFFSET
	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET))
	    {
	      stub_type =
		(info->shared | globals->pic_veneer)
		/* PIC stubs.  */
		? (r_type == R_ARM_TLS_CALL
		   /* TLS PIC Stub */
		   ? arm_stub_long_branch_any_tls_pic
		   : (globals->nacl_p
		      ? arm_stub_long_branch_arm_nacl_pic
		      : arm_stub_long_branch_any_arm_pic))
		/* non-PIC stubs.  */
		: (globals->nacl_p
		   ? arm_stub_long_branch_arm_nacl
		   : arm_stub_long_branch_any_any);
	    }
	}
    }

  /* If a stub is needed, record the actual destination type.  */
  if (stub_type != arm_stub_none)
    *actual_branch_type = branch_type;

  return stub_type;
}

/* Build a name for an entry in the stub hash table.  */

static char *
elf32_arm_stub_name (const asection *input_section,
		     const asection *sym_sec,
		     const struct elf32_arm_link_hash_entry *hash,
		     const Elf_Internal_Rela *rel,
		     enum elf32_arm_stub_type stub_type)
{
  char *stub_name;
  bfd_size_type len;

  if (hash)
    {
      len = 8 + 1 + strlen (hash->root.root.root.string) + 1 + 8 + 1 + 2 + 1;
      stub_name = (char *) bfd_malloc (len);
      if (stub_name != NULL)
	sprintf (stub_name, "%08x_%s+%x_%d",
		 input_section->id & 0xffffffff,
		 hash->root.root.root.string,
		 (int) rel->r_addend & 0xffffffff,
		 (int) stub_type);
    }
  else
    {
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1 + 2 + 1;
      stub_name = (char *) bfd_malloc (len);
      if (stub_name != NULL)
	sprintf (stub_name, "%08x_%x:%x+%x_%d",
		 input_section->id & 0xffffffff,
		 sym_sec->id & 0xffffffff,
		 ELF32_R_TYPE (rel->r_info) == R_ARM_TLS_CALL
		 || ELF32_R_TYPE (rel->r_info) == R_ARM_THM_TLS_CALL
		 ? 0 : (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
		 (int) rel->r_addend & 0xffffffff,
		 (int) stub_type);
    }

  return stub_name;
}

/* Look up an entry in the stub hash.  Stub entries are cached because
   creating the stub name takes a bit of time.  */

static struct elf32_arm_stub_hash_entry *
elf32_arm_get_stub_entry (const asection *input_section,
			  const asection *sym_sec,
			  struct elf_link_hash_entry *hash,
			  const Elf_Internal_Rela *rel,
			  struct elf32_arm_link_hash_table *htab,
			  enum elf32_arm_stub_type stub_type)
{
  struct elf32_arm_stub_hash_entry *stub_entry;
  struct elf32_arm_link_hash_entry *h = (struct elf32_arm_link_hash_entry *) hash;
  const asection *id_sec;

  if ((input_section->flags & SEC_CODE) == 0)
    return NULL;

  /* If this input section is part of a group of sections sharing one
     stub section, then use the id of the first section in the group.
     Stub names need to include a section id, as there may well be
     more than one stub used to reach say, printf, and we need to
     distinguish between them.  */
  id_sec = htab->stub_group[input_section->id].link_sec;

  if (h != NULL && h->stub_cache != NULL
      && h->stub_cache->h == h
      && h->stub_cache->id_sec == id_sec
      && h->stub_cache->stub_type == stub_type)
    {
      stub_entry = h->stub_cache;
    }
  else
    {
      char *stub_name;

      stub_name = elf32_arm_stub_name (id_sec, sym_sec, h, rel, stub_type);
      if (stub_name == NULL)
	return NULL;

      stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table,
					stub_name, FALSE, FALSE);
      if (h != NULL)
	h->stub_cache = stub_entry;

      free (stub_name);
    }

  return stub_entry;
}

/* Find or create a stub section.  Returns a pointer to the stub section, and
   the section to which the stub section will be attached (in *LINK_SEC_P).
   LINK_SEC_P may be NULL.  */

static asection *
elf32_arm_create_or_find_stub_sec (asection **link_sec_p, asection *section,
				   struct elf32_arm_link_hash_table *htab)
{
  asection *link_sec;
  asection *stub_sec;

  link_sec = htab->stub_group[section->id].link_sec;
  BFD_ASSERT (link_sec != NULL);
  stub_sec = htab->stub_group[section->id].stub_sec;

  if (stub_sec == NULL)
    {
      stub_sec = htab->stub_group[link_sec->id].stub_sec;
      if (stub_sec == NULL)
	{
	  size_t namelen;
	  bfd_size_type len;
	  char *s_name;

	  namelen = strlen (link_sec->name);
	  len = namelen + sizeof (STUB_SUFFIX);
	  s_name = (char *) bfd_alloc (htab->stub_bfd, len);
	  if (s_name == NULL)
	    return NULL;

	  memcpy (s_name, link_sec->name, namelen);
	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec,
						htab->nacl_p ? 4 : 3);
	  if (stub_sec == NULL)
	    return NULL;
	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
	}
      htab->stub_group[section->id].stub_sec = stub_sec;
    }

  if (link_sec_p)
    *link_sec_p = link_sec;

  return stub_sec;
}

/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct elf32_arm_stub_hash_entry *
elf32_arm_add_stub (const char *stub_name,
		    asection *section,
		    struct elf32_arm_link_hash_table *htab)
{
  asection *link_sec;
  asection *stub_sec;
  struct elf32_arm_stub_hash_entry *stub_entry;

  stub_sec = elf32_arm_create_or_find_stub_sec (&link_sec, section, htab);
  if (stub_sec == NULL)
    return NULL;

  /* Enter this entry into the linker stub hash table.  */
  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
				     TRUE, FALSE);
  if (stub_entry == NULL)
    {
      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
			     section->owner,
			     stub_name);
      return NULL;
    }

  stub_entry->stub_sec = stub_sec;
  stub_entry->stub_offset = 0;
  stub_entry->id_sec = link_sec;

  return stub_entry;
}

/* Store an Arm insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_arm_insn (struct elf32_arm_link_hash_table * htab,
	      bfd * output_bfd, bfd_vma val, void * ptr)
{
  if (htab->byteswap_code != bfd_little_endian (output_bfd))
    bfd_putl32 (val, ptr);
  else
    bfd_putb32 (val, ptr);
}

/* Store a 16-bit Thumb insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_thumb_insn (struct elf32_arm_link_hash_table * htab,
		bfd * output_bfd, bfd_vma val, void * ptr)
{
  if (htab->byteswap_code != bfd_little_endian (output_bfd))
    bfd_putl16 (val, ptr);
  else
    bfd_putb16 (val, ptr);
}

/* If it's possible to change R_TYPE to a more efficient access
   model, return the new reloc type.  */

static unsigned
elf32_arm_tls_transition (struct bfd_link_info *info, int r_type,
			  struct elf_link_hash_entry *h)
{
  int is_local = (h == NULL);

  if (info->shared || (h && h->root.type == bfd_link_hash_undefweak))
    return r_type;

  /* We do not support relaxations for Old TLS models.  */
  switch (r_type)
    {
    case R_ARM_TLS_GOTDESC:
    case R_ARM_TLS_CALL:
    case R_ARM_THM_TLS_CALL:
    case R_ARM_TLS_DESCSEQ:
    case R_ARM_THM_TLS_DESCSEQ:
      return is_local ? R_ARM_TLS_LE32 : R_ARM_TLS_IE32;
    }

  return r_type;
}

static bfd_reloc_status_type elf32_arm_final_link_relocate
  (reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, bfd_vma, struct bfd_link_info *, asection *,
   const char *, unsigned char, enum arm_st_branch_type,
   struct elf_link_hash_entry *, bfd_boolean *, char **);

static unsigned int
arm_stub_required_alignment (enum elf32_arm_stub_type stub_type)
{
  switch (stub_type)
    {
    case arm_stub_a8_veneer_b_cond:
    case arm_stub_a8_veneer_b:
    case arm_stub_a8_veneer_bl:
      return 2;

    case arm_stub_long_branch_any_any:
    case arm_stub_long_branch_v4t_arm_thumb:
    case arm_stub_long_branch_thumb_only:
    case arm_stub_long_branch_v4t_thumb_thumb:
    case arm_stub_long_branch_v4t_thumb_arm:
    case arm_stub_short_branch_v4t_thumb_arm:
    case arm_stub_long_branch_any_arm_pic:
    case arm_stub_long_branch_any_thumb_pic:
    case arm_stub_long_branch_v4t_thumb_thumb_pic:
    case arm_stub_long_branch_v4t_arm_thumb_pic:
    case arm_stub_long_branch_v4t_thumb_arm_pic:
    case arm_stub_long_branch_thumb_only_pic:
    case arm_stub_long_branch_any_tls_pic:
    case arm_stub_long_branch_v4t_thumb_tls_pic:
    case arm_stub_a8_veneer_blx:
      return 4;

    case arm_stub_long_branch_arm_nacl:
    case arm_stub_long_branch_arm_nacl_pic:
      return 16;

    default:
      abort ();  /* Should be unreachable.  */
    }
}

static bfd_boolean
arm_build_one_stub (struct bfd_hash_entry *gen_entry,
		    void * in_arg)
{
#define MAXRELOCS 3
  struct elf32_arm_stub_hash_entry *stub_entry;
  struct elf32_arm_link_hash_table *globals;
  struct bfd_link_info *info;
  asection *stub_sec;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma sym_value;
  int template_size;
  int size;
  const insn_sequence *template_sequence;
  int i;
  int stub_reloc_idx[MAXRELOCS] = {-1, -1};
  int stub_reloc_offset[MAXRELOCS] = {0, 0};
  int nrelocs = 0;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
  info = (struct bfd_link_info *) in_arg;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return FALSE;

  stub_sec = stub_entry->stub_sec;

  if ((globals->fix_cortex_a8 < 0)
      != (arm_stub_required_alignment (stub_entry->stub_type) == 2))
    /* We have to do less-strictly-aligned fixes last.  */
    return TRUE;

  /* Make a note of the offset within the stubs for this entry.  */
  stub_entry->stub_offset = stub_sec->size;
  loc = stub_sec->contents + stub_entry->stub_offset;

  stub_bfd = stub_sec->owner;

  /* This is the address of the stub destination.  */
  sym_value = (stub_entry->target_value
	       + stub_entry->target_section->output_offset
	       + stub_entry->target_section->output_section->vma);

  template_sequence = stub_entry->stub_template;
  template_size = stub_entry->stub_template_size;

  size = 0;
  for (i = 0; i < template_size; i++)
    {
      switch (template_sequence[i].type)
	{
	case THUMB16_TYPE:
	  {
	    bfd_vma data = (bfd_vma) template_sequence[i].data;
	    if (template_sequence[i].reloc_addend != 0)
	      {
		/* We've borrowed the reloc_addend field to mean we should
		   insert a condition code into this (Thumb-1 branch)
		   instruction.  See THUMB16_BCOND_INSN.  */
		BFD_ASSERT ((data & 0xff00) == 0xd000);
		data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
	      }
	    bfd_put_16 (stub_bfd, data, loc + size);
	    size += 2;
	  }
	  break;

	case THUMB32_TYPE:
	  bfd_put_16 (stub_bfd,
		      (template_sequence[i].data >> 16) & 0xffff,
		      loc + size);
	  bfd_put_16 (stub_bfd, template_sequence[i].data & 0xffff,
		      loc + size + 2);
	  if (template_sequence[i].r_type != R_ARM_NONE)
	    {
	      stub_reloc_idx[nrelocs] = i;
	      stub_reloc_offset[nrelocs++] = size;
	    }
	  size += 4;
	  break;

	case ARM_TYPE:
	  bfd_put_32 (stub_bfd, template_sequence[i].data,
		      loc + size);
	  /* Handle cases where the target is encoded within the
	     instruction.  */
	  if (template_sequence[i].r_type == R_ARM_JUMP24)
	    {
	      stub_reloc_idx[nrelocs] = i;
	      stub_reloc_offset[nrelocs++] = size;
	    }
	  size += 4;
	  break;

	case DATA_TYPE:
	  bfd_put_32 (stub_bfd, template_sequence[i].data, loc + size);
	  stub_reloc_idx[nrelocs] = i;
	  stub_reloc_offset[nrelocs++] = size;
	  size += 4;
	  break;

	default:
	  BFD_FAIL ();
	  return FALSE;
	}
    }

  stub_sec->size += size;

  /* Stub size has already been computed in arm_size_one_stub. Check
     consistency.  */
  BFD_ASSERT (size == stub_entry->stub_size);

  /* Destination is Thumb. Force bit 0 to 1 to reflect this.  */
  if (stub_entry->branch_type == ST_BRANCH_TO_THUMB)
    sym_value |= 1;

  /* Assume there is at least one and at most MAXRELOCS entries to relocate
     in each stub.  */
  BFD_ASSERT (nrelocs != 0 && nrelocs <= MAXRELOCS);

  for (i = 0; i < nrelocs; i++)
    if (template_sequence[stub_reloc_idx[i]].r_type == R_ARM_THM_JUMP24
	|| template_sequence[stub_reloc_idx[i]].r_type == R_ARM_THM_JUMP19
	|| template_sequence[stub_reloc_idx[i]].r_type == R_ARM_THM_CALL
	|| template_sequence[stub_reloc_idx[i]].r_type == R_ARM_THM_XPC22)
      {
	Elf_Internal_Rela rel;
	bfd_boolean unresolved_reloc;
	char *error_message;
	enum arm_st_branch_type branch_type
	  = (template_sequence[stub_reloc_idx[i]].r_type != R_ARM_THM_XPC22
	     ? ST_BRANCH_TO_THUMB : ST_BRANCH_TO_ARM);
	bfd_vma points_to = sym_value + stub_entry->target_addend;

	rel.r_offset = stub_entry->stub_offset + stub_reloc_offset[i];
	rel.r_info = ELF32_R_INFO (0,
				   template_sequence[stub_reloc_idx[i]].r_type);
	rel.r_addend = template_sequence[stub_reloc_idx[i]].reloc_addend;

	if (stub_entry->stub_type == arm_stub_a8_veneer_b_cond && i == 0)
	  /* The first relocation in the elf32_arm_stub_a8_veneer_b_cond[]
	     template should refer back to the instruction after the original
	     branch.  */
	  points_to = sym_value;

	/* There may be unintended consequences if this is not true.  */
	BFD_ASSERT (stub_entry->h == NULL);

	/* Note: _bfd_final_link_relocate doesn't handle these relocations
	   properly.  We should probably use this function unconditionally,
	   rather than only for certain relocations listed in the enclosing
	   conditional, for the sake of consistency.  */
	elf32_arm_final_link_relocate (elf32_arm_howto_from_type
	    (template_sequence[stub_reloc_idx[i]].r_type),
	  stub_bfd, info->output_bfd, stub_sec, stub_sec->contents, &rel,
	  points_to, info, stub_entry->target_section, "", STT_FUNC,
	  branch_type, (struct elf_link_hash_entry *) stub_entry->h,
	  &unresolved_reloc, &error_message);
      }
    else
      {
	Elf_Internal_Rela rel;
	bfd_boolean unresolved_reloc;
	char *error_message;
	bfd_vma points_to = sym_value + stub_entry->target_addend
	  + template_sequence[stub_reloc_idx[i]].reloc_addend;

	rel.r_offset = stub_entry->stub_offset + stub_reloc_offset[i];
	rel.r_info = ELF32_R_INFO (0,
				   template_sequence[stub_reloc_idx[i]].r_type);
	rel.r_addend = 0;

	elf32_arm_final_link_relocate (elf32_arm_howto_from_type
	    (template_sequence[stub_reloc_idx[i]].r_type),
	  stub_bfd, info->output_bfd, stub_sec, stub_sec->contents, &rel,
	  points_to, info, stub_entry->target_section, "", STT_FUNC,
	  stub_entry->branch_type,
	  (struct elf_link_hash_entry *) stub_entry->h, &unresolved_reloc,
	  &error_message);
      }

  return TRUE;
#undef MAXRELOCS
}

/* Calculate the template, template size and instruction size for a stub.
   Return value is the instruction size.  */

static unsigned int
find_stub_size_and_template (enum elf32_arm_stub_type stub_type,
			     const insn_sequence **stub_template,
			     int *stub_template_size)
{
  const insn_sequence *template_sequence = NULL;
  int template_size = 0, i;
  unsigned int size;

  template_sequence = stub_definitions[stub_type].template_sequence;
  if (stub_template)
    *stub_template = template_sequence;

  template_size = stub_definitions[stub_type].template_size;
  if (stub_template_size)
    *stub_template_size = template_size;

  size = 0;
  for (i = 0; i < template_size; i++)
    {
      switch (template_sequence[i].type)
	{
	case THUMB16_TYPE:
	  size += 2;
	  break;

	case ARM_TYPE:
	case THUMB32_TYPE:
	case DATA_TYPE:
	  size += 4;
	  break;

	default:
	  BFD_FAIL ();
	  return 0;
	}
    }

  return size;
}

/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */

static bfd_boolean
arm_size_one_stub (struct bfd_hash_entry *gen_entry,
		   void *in_arg ATTRIBUTE_UNUSED)
{
  struct elf32_arm_stub_hash_entry *stub_entry;
  const insn_sequence *template_sequence;
  int template_size, size;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;

  BFD_ASSERT((stub_entry->stub_type > arm_stub_none)
	     && stub_entry->stub_type < ARRAY_SIZE(stub_definitions));

  size = find_stub_size_and_template (stub_entry->stub_type, &template_sequence,
				      &template_size);

  stub_entry->stub_size = size;
  stub_entry->stub_template = template_sequence;
  stub_entry->stub_template_size = template_size;

  size = (size + 7) & ~7;
  stub_entry->stub_sec->size += size;

  return TRUE;
}

/* External entry points for sizing and building linker stubs.  */

/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  */

int
elf32_arm_setup_section_lists (bfd *output_bfd,
			       struct bfd_link_info *info)
{
  bfd *input_bfd;
  unsigned int bfd_count;
  int top_id, top_index;
  asection *section;
  asection **input_list, **list;
  bfd_size_type amt;
  struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);

  if (htab == NULL)
    return 0;
  if (! is_elf_hash_table (htab))
    return 0;

  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_count += 1;
      for (section = input_bfd->sections;
	   section != NULL;
	   section = section->next)
	{
	  if (top_id < section->id)
	    top_id = section->id;
	}
    }
  htab->bfd_count = bfd_count;

  amt = sizeof (struct map_stub) * (top_id + 1);
  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
  if (htab->stub_group == NULL)
    return -1;
  htab->top_id = top_id;

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     _bfd_strip_section_from_output doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    {
      if (top_index < section->index)
	top_index = section->index;
    }

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = (asection **) bfd_malloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    {
      if ((section->flags & SEC_CODE) != 0)
	input_list[section->index] = NULL;
    }

  return 1;
}

/* The linker repeatedly calls this function for each input section,
   in the order that input sections are linked into output sections.
   Build lists of input sections to determine groupings between which
   we may insert linker stubs.  */

void
elf32_arm_next_input_section (struct bfd_link_info *info,
			      asection *isec)
{
  struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);

  if (htab == NULL)
    return;

  if (isec->output_section->index <= htab->top_index)
    {
      asection **list = htab->input_list + isec->output_section->index;

      if (*list != bfd_abs_section_ptr && (isec->flags & SEC_CODE) != 0)
	{
	  /* Steal the link_sec pointer for our list.  */
#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
	  /* This happens to make the list in reverse order,
	     which we reverse later.  */
	  PREV_SEC (isec) = *list;
	  *list = isec;
	}
    }
}

/* See whether we can group stub sections together.  Grouping stub
   sections may result in fewer stubs.  More importantly, we need to
   put all .init* and .fini* stubs at the end of the .init or
   .fini output sections respectively, because glibc splits the
   _init and _fini functions into multiple parts.  Putting a stub in
   the middle of a function is not a good idea.  */

static void
group_sections (struct elf32_arm_link_hash_table *htab,
		bfd_size_type stub_group_size,
		bfd_boolean stubs_always_after_branch)
{
  asection **list = htab->input_list;

  do
    {
      asection *tail = *list;
      asection *head;

      if (tail == bfd_abs_section_ptr)
	continue;

      /* Reverse the list: we must avoid placing stubs at the
	 beginning of the section because the beginning of the text
	 section may be required for an interrupt vector in bare metal
	 code.  */
#define NEXT_SEC PREV_SEC
      head = NULL;
      while (tail != NULL)
	{
	  /* Pop from tail.  */
	  asection *item = tail;
	  tail = PREV_SEC (item);

	  /* Push on head.  */
	  NEXT_SEC (item) = head;
	  head = item;
	}

      while (head != NULL)
	{
	  asection *curr;
	  asection *next;
	  bfd_vma stub_group_start = head->output_offset;
	  bfd_vma end_of_next;

	  curr = head;
	  while (NEXT_SEC (curr) != NULL)
	    {
	      next = NEXT_SEC (curr);
	      end_of_next = next->output_offset + next->size;
	      if (end_of_next - stub_group_start >= stub_group_size)
		/* End of NEXT is too far from start, so stop.  */
		break;
	      /* Add NEXT to the group.  */
	      curr = next;
	    }

	  /* OK, the size from the start to the start of CURR is less
	     than stub_group_size and thus can be handled by one stub
	     section.  (Or the head section is itself larger than
	     stub_group_size, in which case we may be toast.)
	     We should really be keeping track of the total size of
	     stubs added here, as stubs contribute to the final output
	     section size.  */
	  do
	    {
	      next = NEXT_SEC (head);
	      /* Set up this stub group.  */
	      htab->stub_group[head->id].link_sec = curr;
	    }
	  while (head != curr && (head = next) != NULL);

	  /* But wait, there's more!  Input sections up to stub_group_size
	     bytes after the stub section can be handled by it too.  */
	  if (!stubs_always_after_branch)
	    {
	      stub_group_start = curr->output_offset + curr->size;

	      while (next != NULL)
		{
		  end_of_next = next->output_offset + next->size;
		  if (end_of_next - stub_group_start >= stub_group_size)
		    /* End of NEXT is too far from stubs, so stop.  */
		    break;
		  /* Add NEXT to the stub group.  */
		  head = next;
		  next = NEXT_SEC (head);
		  htab->stub_group[head->id].link_sec = curr;
		}
	    }
	  head = next;
	}
    }
  while (list++ != htab->input_list + htab->top_index);

  free (htab->input_list);
#undef PREV_SEC
#undef NEXT_SEC
}

/* Comparison function for sorting/searching relocations relating to Cortex-A8
   erratum fix.  */

static int
a8_reloc_compare (const void *a, const void *b)
{
  const struct a8_erratum_reloc *ra = (const struct a8_erratum_reloc *) a;
  const struct a8_erratum_reloc *rb = (const struct a8_erratum_reloc *) b;

  if (ra->from < rb->from)
    return -1;
  else if (ra->from > rb->from)
    return 1;
  else
    return 0;
}

static struct elf_link_hash_entry *find_thumb_glue (struct bfd_link_info *,
						    const char *, char **);

/* Helper function to scan code for sequences which might trigger the Cortex-A8
   branch/TLB erratum.  Fill in the table described by A8_FIXES_P,
   NUM_A8_FIXES_P, A8_FIX_TABLE_SIZE_P.  Returns true if an error occurs, false
   otherwise.  */

static bfd_boolean
cortex_a8_erratum_scan (bfd *input_bfd,
			struct bfd_link_info *info,
			struct a8_erratum_fix **a8_fixes_p,
			unsigned int *num_a8_fixes_p,
			unsigned int *a8_fix_table_size_p,
			struct a8_erratum_reloc *a8_relocs,
			unsigned int num_a8_relocs,
			unsigned prev_num_a8_fixes,
			bfd_boolean *stub_changed_p)
{
  asection *section;
  struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);
  struct a8_erratum_fix *a8_fixes = *a8_fixes_p;
  unsigned int num_a8_fixes = *num_a8_fixes_p;
  unsigned int a8_fix_table_size = *a8_fix_table_size_p;

  if (htab == NULL)
    return FALSE;

  for (section = input_bfd->sections;
       section != NULL;
       section = section->next)
    {
      bfd_byte *contents = NULL;
      struct _arm_elf_section_data *sec_data;
      unsigned int span;
      bfd_vma base_vma;

      if (elf_section_type (section) != SHT_PROGBITS
	  || (elf_section_flags (section) & SHF_EXECINSTR) == 0
	  || (section->flags & SEC_EXCLUDE) != 0
	  || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
	  || (section->output_section == bfd_abs_section_ptr))
	continue;

      base_vma = section->output_section->vma + section->output_offset;

      if (elf_section_data (section)->this_hdr.contents != NULL)
	contents = elf_section_data (section)->this_hdr.contents;
      else if (! bfd_malloc_and_get_section (input_bfd, section, &contents))
	return TRUE;

      sec_data = elf32_arm_section_data (section);

      for (span = 0; span < sec_data->mapcount; span++)
	{
	  unsigned int span_start = sec_data->map[span].vma;
	  unsigned int span_end = (span == sec_data->mapcount - 1)
	    ? section->size : sec_data->map[span + 1].vma;
	  unsigned int i;
	  char span_type = sec_data->map[span].type;
	  bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;

	  if (span_type != 't')
	    continue;

	  /* Span is entirely within a single 4KB region: skip scanning.  */
	  if (((base_vma + span_start) & ~0xfff)
	      == ((base_vma + span_end) & ~0xfff))
	    continue;

	  /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:

	       * The opcode is BLX.W, BL.W, B.W, Bcc.W
	       * The branch target is in the same 4KB region as the
		 first half of the branch.
	       * The instruction before the branch is a 32-bit
		 length non-branch instruction.  */
	  for (i = span_start; i < span_end;)
	    {
	      unsigned int insn = bfd_getl16 (&contents[i]);
	      bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;
	      bfd_boolean is_bl = FALSE, is_bcc = FALSE, is_32bit_branch;

	      if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)
		insn_32bit = TRUE;

	      if (insn_32bit)
		{
		  /* Load the rest of the insn (in manual-friendly order).  */
		  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);

		  /* Encoding T4: B<c>.W.  */
		  is_b = (insn & 0xf800d000) == 0xf0009000;
		  /* Encoding T1: BL<c>.W.  */
		  is_bl = (insn & 0xf800d000) == 0xf000d000;
		  /* Encoding T2: BLX<c>.W.  */
		  is_blx = (insn & 0xf800d000) == 0xf000c000;
		  /* Encoding T3: B<c>.W (not permitted in IT block).  */
		  is_bcc = (insn & 0xf800d000) == 0xf0008000
			   && (insn & 0x07f00000) != 0x03800000;
		}

	      is_32bit_branch = is_b || is_bl || is_blx || is_bcc;

	      if (((base_vma + i) & 0xfff) == 0xffe
		  && insn_32bit
		  && is_32bit_branch
		  && last_was_32bit
		  && ! last_was_branch)
		{
		  bfd_signed_vma offset = 0;
		  bfd_boolean force_target_arm = FALSE;
		  bfd_boolean force_target_thumb = FALSE;
		  bfd_vma target;
		  enum elf32_arm_stub_type stub_type = arm_stub_none;
		  struct a8_erratum_reloc key, *found;
		  bfd_boolean use_plt = FALSE;

		  key.from = base_vma + i;
		  found = (struct a8_erratum_reloc *)
		      bsearch (&key, a8_relocs, num_a8_relocs,
			       sizeof (struct a8_erratum_reloc),
			       &a8_reloc_compare);

		  if (found)
		    {
		      char *error_message = NULL;
		      struct elf_link_hash_entry *entry;

		      /* We don't care about the error returned from this
			 function, only if there is glue or not.  */
		      entry = find_thumb_glue (info, found->sym_name,
					       &error_message);

		      if (entry)
			found->non_a8_stub = TRUE;

		      /* Keep a simpler condition, for the sake of clarity.  */
		      if (htab->root.splt != NULL && found->hash != NULL
			  && found->hash->root.plt.offset != (bfd_vma) -1)
			use_plt = TRUE;

		      if (found->r_type == R_ARM_THM_CALL)
			{
			  if (found->branch_type == ST_BRANCH_TO_ARM
			      || use_plt)
			    force_target_arm = TRUE;
			  else
			    force_target_thumb = TRUE;
			}
		    }

		  /* Check if we have an offending branch instruction.  */

		  if (found && found->non_a8_stub)
		    /* We've already made a stub for this instruction, e.g.
		       it's a long branch or a Thumb->ARM stub.  Assume that
		       stub will suffice to work around the A8 erratum (see
		       setting of always_after_branch above).  */
		    ;
		  else if (is_bcc)
		    {
		      offset = (insn & 0x7ff) << 1;
		      offset |= (insn & 0x3f0000) >> 4;
		      offset |= (insn & 0x2000) ? 0x40000 : 0;
		      offset |= (insn & 0x800) ? 0x80000 : 0;
		      offset |= (insn & 0x4000000) ? 0x100000 : 0;
		      if (offset & 0x100000)
			offset |= ~ ((bfd_signed_vma) 0xfffff);
		      stub_type = arm_stub_a8_veneer_b_cond;
		    }
		  else if (is_b || is_bl || is_blx)
		    {
		      int s = (insn & 0x4000000) != 0;
		      int j1 = (insn & 0x2000) != 0;
		      int j2 = (insn & 0x800) != 0;
		      int i1 = !(j1 ^ s);
		      int i2 = !(j2 ^ s);

		      offset = (insn & 0x7ff) << 1;
		      offset |= (insn & 0x3ff0000) >> 4;
		      offset |= i2 << 22;
		      offset |= i1 << 23;
		      offset |= s << 24;
		      if (offset & 0x1000000)
			offset |= ~ ((bfd_signed_vma) 0xffffff);

		      if (is_blx)
			offset &= ~ ((bfd_signed_vma) 3);

		      stub_type = is_blx ? arm_stub_a8_veneer_blx :
			is_bl ? arm_stub_a8_veneer_bl : arm_stub_a8_veneer_b;
		    }

		  if (stub_type != arm_stub_none)
		    {
		      bfd_vma pc_for_insn = base_vma + i + 4;

		      /* The original instruction is a BL, but the target is
			 an ARM instruction.  If we were not making a stub,
			 the BL would have been converted to a BLX.  Use the
			 BLX stub instead in that case.  */
		      if (htab->use_blx && force_target_arm
			  && stub_type == arm_stub_a8_veneer_bl)
			{
			  stub_type = arm_stub_a8_veneer_blx;
			  is_blx = TRUE;
			  is_bl = FALSE;
			}
		      /* Conversely, if the original instruction was
			 BLX but the target is Thumb mode, use the BL
			 stub.  */
		      else if (force_target_thumb
			       && stub_type == arm_stub_a8_veneer_blx)
			{
			  stub_type = arm_stub_a8_veneer_bl;
			  is_blx = FALSE;
			  is_bl = TRUE;
			}

		      if (is_blx)
			pc_for_insn &= ~ ((bfd_vma) 3);

		      /* If we found a relocation, use the proper destination,
			 not the offset in the (unrelocated) instruction.
			 Note this is always done if we switched the stub type
			 above.  */
		      if (found)
			offset =
			  (bfd_signed_vma) (found->destination - pc_for_insn);

		      /* If the stub will use a Thumb-mode branch to a
			 PLT target, redirect it to the preceding Thumb
			 entry point.  */
		      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
			offset -= PLT_THUMB_STUB_SIZE;

		      target = pc_for_insn + offset;

		      /* The BLX stub is ARM-mode code.  Adjust the offset to
			 take the different PC value (+8 instead of +4) into
			 account.  */
		      if (stub_type == arm_stub_a8_veneer_blx)
			offset += 4;

		      if (((base_vma + i) & ~0xfff) == (target & ~0xfff))
			{
			  char *stub_name = NULL;

			  if (num_a8_fixes == a8_fix_table_size)
			    {
			      a8_fix_table_size *= 2;
			      a8_fixes = (struct a8_erratum_fix *)
				  bfd_realloc (a8_fixes,
					       sizeof (struct a8_erratum_fix)
					       * a8_fix_table_size);
			    }

			  if (num_a8_fixes < prev_num_a8_fixes)
			    {
			      /* If we're doing a subsequent scan,
				 check if we've found the same fix as
				 before, and try and reuse the stub
				 name.  */
			      stub_name = a8_fixes[num_a8_fixes].stub_name;
			      if ((a8_fixes[num_a8_fixes].section != section)
				  || (a8_fixes[num_a8_fixes].offset != i))
				{
				  free (stub_name);
				  stub_name = NULL;
				  *stub_changed_p = TRUE;
				}
			    }

			  if (!stub_name)
			    {
			      stub_name = (char *) bfd_malloc (8 + 1 + 8 + 1);
			      if (stub_name != NULL)
				sprintf (stub_name, "%x:%x", section->id, i);
			    }

			  a8_fixes[num_a8_fixes].input_bfd = input_bfd;
			  a8_fixes[num_a8_fixes].section = section;
			  a8_fixes[num_a8_fixes].offset = i;
			  a8_fixes[num_a8_fixes].addend = offset;
			  a8_fixes[num_a8_fixes].orig_insn = insn;
			  a8_fixes[num_a8_fixes].stub_name = stub_name;
			  a8_fixes[num_a8_fixes].stub_type = stub_type;
			  a8_fixes[num_a8_fixes].branch_type =
			    is_blx ? ST_BRANCH_TO_ARM : ST_BRANCH_TO_THUMB;

			  num_a8_fixes++;
			}
		    }
		}

	      i += insn_32bit ? 4 : 2;
	      last_was_32bit = insn_32bit;
	      last_was_branch = is_32bit_branch;
	    }
	}

      if (elf_section_data (section)->this_hdr.contents == NULL)
	free (contents);
    }

  *a8_fixes_p = a8_fixes;
  *num_a8_fixes_p = num_a8_fixes;
  *a8_fix_table_size_p = a8_fix_table_size;

  return FALSE;
}

/* Determine and set the size of the stub section for a final link.

   The basic idea here is to examine all the relocations looking for
   PC-relative calls to a target that is unreachable with a "bl"
   instruction.  */

bfd_boolean
elf32_arm_size_stubs (bfd *output_bfd,
		      bfd *stub_bfd,
		      struct bfd_link_info *info,
		      bfd_signed_vma group_size,
		      asection * (*add_stub_section) (const char *, asection *,
						      unsigned int),
		      void (*layout_sections_again) (void))
{
  bfd_size_type stub_group_size;
  bfd_boolean stubs_always_after_branch;
  struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);
  struct a8_erratum_fix *a8_fixes = NULL;
  unsigned int num_a8_fixes = 0, a8_fix_table_size = 10;
  struct a8_erratum_reloc *a8_relocs = NULL;
  unsigned int num_a8_relocs = 0, a8_reloc_table_size = 10, i;

  if (htab == NULL)
    return FALSE;

  if (htab->fix_cortex_a8)
    {
      a8_fixes = (struct a8_erratum_fix *)
	  bfd_zmalloc (sizeof (struct a8_erratum_fix) * a8_fix_table_size);
      a8_relocs = (struct a8_erratum_reloc *)
	  bfd_zmalloc (sizeof (struct a8_erratum_reloc) * a8_reloc_table_size);
    }

  /* Propagate mach to stub bfd, because it may not have been
     finalized when we created stub_bfd.  */
  bfd_set_arch_mach (stub_bfd, bfd_get_arch (output_bfd),
		     bfd_get_mach (output_bfd));

  /* Stash our params away.  */
  htab->stub_bfd = stub_bfd;
  htab->add_stub_section = add_stub_section;
  htab->layout_sections_again = layout_sections_again;
  stubs_always_after_branch = group_size < 0;

  /* The Cortex-A8 erratum fix depends on stubs not being in the same 4K page
     as the first half of a 32-bit branch straddling two 4K pages.  This is a
     crude way of enforcing that.  */
  if (htab->fix_cortex_a8)
    stubs_always_after_branch = 1;

  if (group_size < 0)
    stub_group_size = -group_size;
  else
    stub_group_size = group_size;

  if (stub_group_size == 1)
    {
      /* Default values.  */
      /* Thumb branch range is +-4MB has to be used as the default
	 maximum size (a given section can contain both ARM and Thumb
	 code, so the worst case has to be taken into account).

	 This value is 24K less than that, which allows for 2025
	 12-byte stubs.  If we exceed that, then we will fail to link.
	 The user will have to relink with an explicit group size
	 option.  */
      stub_group_size = 4170000;
    }

  group_sections (htab, stub_group_size, stubs_always_after_branch);

  /* If we're applying the cortex A8 fix, we need to determine the
     program header size now, because we cannot change it later --
     that could alter section placements.  Notice the A8 erratum fix
     ends up requiring the section addresses to remain unchanged
     modulo the page size.  That's something we cannot represent
     inside BFD, and we don't want to force the section alignment to
     be the page size.  */
  if (htab->fix_cortex_a8)
    (*htab->layout_sections_again) ();

  while (1)
    {
      bfd *input_bfd;
      unsigned int bfd_indx;
      asection *stub_sec;
      bfd_boolean stub_changed = FALSE;
      unsigned prev_num_a8_fixes = num_a8_fixes;

      num_a8_fixes = 0;
      for (input_bfd = info->input_bfds, bfd_indx = 0;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next, bfd_indx++)
	{
	  Elf_Internal_Shdr *symtab_hdr;
	  asection *section;
	  Elf_Internal_Sym *local_syms = NULL;

	  if (!is_arm_elf (input_bfd))
	    continue;

	  num_a8_relocs = 0;

	  /* We'll need the symbol table in a second.  */
	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
	  if (symtab_hdr->sh_info == 0)
	    continue;

	  /* Walk over each section attached to the input bfd.  */
	  for (section = input_bfd->sections;
	       section != NULL;
	       section = section->next)
	    {
	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

	      /* If there aren't any relocs, then there's nothing more
		 to do.  */
	      if ((section->flags & SEC_RELOC) == 0
		  || section->reloc_count == 0
		  || (section->flags & SEC_CODE) == 0)
		continue;

	      /* If this section is a link-once section that will be
		 discarded, then don't create any stubs.  */
	      if (section->output_section == NULL
		  || section->output_section->owner != output_bfd)
		continue;

	      /* Get the relocs.  */
	      internal_relocs
		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
					     NULL, info->keep_memory);
	      if (internal_relocs == NULL)
		goto error_ret_free_local;

	      /* Now examine each relocation.  */
	      irela = internal_relocs;
	      irelaend = irela + section->reloc_count;
	      for (; irela < irelaend; irela++)
		{
		  unsigned int r_type, r_indx;
		  enum elf32_arm_stub_type stub_type;
		  struct elf32_arm_stub_hash_entry *stub_entry;
		  asection *sym_sec;
		  bfd_vma sym_value;
		  bfd_vma destination;
		  struct elf32_arm_link_hash_entry *hash;
		  const char *sym_name;
		  char *stub_name;
		  const asection *id_sec;
		  unsigned char st_type;
		  enum arm_st_branch_type branch_type;
		  bfd_boolean created_stub = FALSE;

		  r_type = ELF32_R_TYPE (irela->r_info);
		  r_indx = ELF32_R_SYM (irela->r_info);

		  if (r_type >= (unsigned int) R_ARM_max)
		    {
		      bfd_set_error (bfd_error_bad_value);
		    error_ret_free_internal:
		      if (elf_section_data (section)->relocs == NULL)
			free (internal_relocs);
		      goto error_ret_free_local;
		    }

		  hash = NULL;
		  if (r_indx >= symtab_hdr->sh_info)
		    hash = elf32_arm_hash_entry
		      (elf_sym_hashes (input_bfd)
		       [r_indx - symtab_hdr->sh_info]);

		  /* Only look for stubs on branch instructions, or
		     non-relaxed TLSCALL  */
		  if ((r_type != (unsigned int) R_ARM_CALL)
		      && (r_type != (unsigned int) R_ARM_THM_CALL)
		      && (r_type != (unsigned int) R_ARM_JUMP24)
		      && (r_type != (unsigned int) R_ARM_THM_JUMP19)
		      && (r_type != (unsigned int) R_ARM_THM_XPC22)
		      && (r_type != (unsigned int) R_ARM_THM_JUMP24)
		      && (r_type != (unsigned int) R_ARM_PLT32)
		      && !((r_type == (unsigned int) R_ARM_TLS_CALL
			    || r_type == (unsigned int) R_ARM_THM_TLS_CALL)
			   && r_type == elf32_arm_tls_transition
			       (info, r_type, &hash->root)
			   && ((hash ? hash->tls_type
				: (elf32_arm_local_got_tls_type
				   (input_bfd)[r_indx]))
			       & GOT_TLS_GDESC) != 0))
		    continue;

		  /* Now determine the call target, its name, value,
		     section.  */
		  sym_sec = NULL;
		  sym_value = 0;
		  destination = 0;
		  sym_name = NULL;

		  if (r_type == (unsigned int) R_ARM_TLS_CALL
		      || r_type == (unsigned int) R_ARM_THM_TLS_CALL)
		    {
		      /* A non-relaxed TLS call.  The target is the
			 plt-resident trampoline and nothing to do
			 with the symbol.  */
		      BFD_ASSERT (htab->tls_trampoline > 0);
		      sym_sec = htab->root.splt;
		      sym_value = htab->tls_trampoline;
		      hash = 0;
		      st_type = STT_FUNC;
		      branch_type = ST_BRANCH_TO_ARM;
		    }
		  else if (!hash)
		    {
		      /* It's a local symbol.  */
		      Elf_Internal_Sym *sym;

		      if (local_syms == NULL)
			{
			  local_syms
			    = (Elf_Internal_Sym *) symtab_hdr->contents;
			  if (local_syms == NULL)
			    local_syms
			      = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
						      symtab_hdr->sh_info, 0,
						      NULL, NULL, NULL);
			  if (local_syms == NULL)
			    goto error_ret_free_internal;
			}

		      sym = local_syms + r_indx;
		      if (sym->st_shndx == SHN_UNDEF)
			sym_sec = bfd_und_section_ptr;
		      else if (sym->st_shndx == SHN_ABS)
			sym_sec = bfd_abs_section_ptr;
		      else if (sym->st_shndx == SHN_COMMON)
			sym_sec = bfd_com_section_ptr;
		      else
			sym_sec =
			  bfd_section_from_elf_index (input_bfd, sym->st_shndx);

		      if (!sym_sec)
			/* This is an undefined symbol.  It can never
			   be resolved. */
			continue;

		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
			sym_value = sym->st_value;
		      destination = (sym_value + irela->r_addend
				     + sym_sec->output_offset
				     + sym_sec->output_section->vma);
		      st_type = ELF_ST_TYPE (sym->st_info);
		      branch_type = ARM_SYM_BRANCH_TYPE (sym);
		      sym_name
			= bfd_elf_string_from_elf_section (input_bfd,
							   symtab_hdr->sh_link,
							   sym->st_name);
		    }
		  else
		    {
		      /* It's an external symbol.  */
		      while (hash->root.root.type == bfd_link_hash_indirect
			     || hash->root.root.type == bfd_link_hash_warning)
			hash = ((struct elf32_arm_link_hash_entry *)
				hash->root.root.u.i.link);

		      if (hash->root.root.type == bfd_link_hash_defined
			  || hash->root.root.type == bfd_link_hash_defweak)
			{
			  sym_sec = hash->root.root.u.def.section;
			  sym_value = hash->root.root.u.def.value;

			  struct elf32_arm_link_hash_table *globals =
						  elf32_arm_hash_table (info);

			  /* For a destination in a shared library,
			     use the PLT stub as target address to
			     decide whether a branch stub is
			     needed.  */
			  if (globals != NULL
			      && globals->root.splt != NULL
			      && hash != NULL
			      && hash->root.plt.offset != (bfd_vma) -1)
			    {
			      sym_sec = globals->root.splt;
			      sym_value = hash->root.plt.offset;
			      if (sym_sec->output_section != NULL)
				destination = (sym_value
					       + sym_sec->output_offset
					       + sym_sec->output_section->vma);
			    }
			  else if (sym_sec->output_section != NULL)
			    destination = (sym_value + irela->r_addend
					   + sym_sec->output_offset
					   + sym_sec->output_section->vma);
			}
		      else if ((hash->root.root.type == bfd_link_hash_undefined)
			       || (hash->root.root.type == bfd_link_hash_undefweak))
			{
			  /* For a shared library, use the PLT stub as
			     target address to decide whether a long
			     branch stub is needed.
			     For absolute code, they cannot be handled.  */
			  struct elf32_arm_link_hash_table *globals =
			    elf32_arm_hash_table (info);

			  if (globals != NULL
			      && globals->root.splt != NULL
			      && hash != NULL
			      && hash->root.plt.offset != (bfd_vma) -1)
			    {
			      sym_sec = globals->root.splt;
			      sym_value = hash->root.plt.offset;
			      if (sym_sec->output_section != NULL)
				destination = (sym_value
					       + sym_sec->output_offset
					       + sym_sec->output_section->vma);
			    }
			  else
			    continue;
			}
		      else
			{
			  bfd_set_error (bfd_error_bad_value);
			  goto error_ret_free_internal;
			}
		      st_type = hash->root.type;
		      branch_type = hash->root.target_internal;
		      sym_name = hash->root.root.root.string;
		    }

		  do
		    {
		      /* Determine what (if any) linker stub is needed.  */
		      stub_type = arm_type_of_stub (info, section, irela,
						    st_type, &branch_type,
						    hash, destination, sym_sec,
						    input_bfd, sym_name);
		      if (stub_type == arm_stub_none)
			break;

		      /* Support for grouping stub sections.  */
		      id_sec = htab->stub_group[section->id].link_sec;

		      /* Get the name of this stub.  */
		      stub_name = elf32_arm_stub_name (id_sec, sym_sec, hash,
						       irela, stub_type);
		      if (!stub_name)
			goto error_ret_free_internal;

		      /* We've either created a stub for this reloc already,
			 or we are about to.  */
		      created_stub = TRUE;

		      stub_entry = arm_stub_hash_lookup
				     (&htab->stub_hash_table, stub_name,
				      FALSE, FALSE);
		      if (stub_entry != NULL)
			{
			  /* The proper stub has already been created.  */
			  free (stub_name);
			  stub_entry->target_value = sym_value;
			  break;
			}

		      stub_entry = elf32_arm_add_stub (stub_name, section,
						       htab);
		      if (stub_entry == NULL)
			{
			  free (stub_name);
			  goto error_ret_free_internal;
			}

		      stub_entry->target_value = sym_value;
		      stub_entry->target_section = sym_sec;
		      stub_entry->stub_type = stub_type;
		      stub_entry->h = hash;
		      stub_entry->branch_type = branch_type;

		      if (sym_name == NULL)
			sym_name = "unnamed";
		      stub_entry->output_name = (char *)
			  bfd_alloc (htab->stub_bfd,
				     sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
				     + strlen (sym_name));
		      if (stub_entry->output_name == NULL)
			{
			  free (stub_name);
			  goto error_ret_free_internal;
			}

		      /* For historical reasons, use the existing names for
			 ARM-to-Thumb and Thumb-to-ARM stubs.  */
		      if ((r_type == (unsigned int) R_ARM_THM_CALL
			   || r_type == (unsigned int) R_ARM_THM_JUMP24)
			  && branch_type == ST_BRANCH_TO_ARM)
			sprintf (stub_entry->output_name,
				 THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
		      else if ((r_type == (unsigned int) R_ARM_CALL
			       || r_type == (unsigned int) R_ARM_JUMP24)
			       && branch_type == ST_BRANCH_TO_THUMB)
			sprintf (stub_entry->output_name,
				 ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
		      else
			sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
				 sym_name);

		      stub_changed = TRUE;
		    }
		  while (0);

		  /* Look for relocations which might trigger Cortex-A8
		     erratum.  */
		  if (htab->fix_cortex_a8
		      && (r_type == (unsigned int) R_ARM_THM_JUMP24
			  || r_type == (unsigned int) R_ARM_THM_JUMP19
			  || r_type == (unsigned int) R_ARM_THM_CALL
			  || r_type == (unsigned int) R_ARM_THM_XPC22))
		    {
		      bfd_vma from = section->output_section->vma
				     + section->output_offset
				     + irela->r_offset;

		      if ((from & 0xfff) == 0xffe)
			{
			  /* Found a candidate.  Note we haven't checked the
			     destination is within 4K here: if we do so (and
			     don't create an entry in a8_relocs) we can't tell
			     that a branch should have been relocated when
			     scanning later.  */
			  if (num_a8_relocs == a8_reloc_table_size)
			    {
			      a8_reloc_table_size *= 2;
			      a8_relocs = (struct a8_erratum_reloc *)
				  bfd_realloc (a8_relocs,
					       sizeof (struct a8_erratum_reloc)
					       * a8_reloc_table_size);
			    }

			  a8_relocs[num_a8_relocs].from = from;
			  a8_relocs[num_a8_relocs].destination = destination;
			  a8_relocs[num_a8_relocs].r_type = r_type;
			  a8_relocs[num_a8_relocs].branch_type = branch_type;
			  a8_relocs[num_a8_relocs].sym_name = sym_name;
			  a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
			  a8_relocs[num_a8_relocs].hash = hash;

			  num_a8_relocs++;
			}
		    }
		}

	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
	    }

	  if (htab->fix_cortex_a8)
	    {
	      /* Sort relocs which might apply to Cortex-A8 erratum.  */
	      qsort (a8_relocs, num_a8_relocs,
		     sizeof (struct a8_erratum_reloc),
		     &a8_reloc_compare);

	      /* Scan for branches which might trigger Cortex-A8 erratum.  */
	      if (cortex_a8_erratum_scan (input_bfd, info, &a8_fixes,
					  &num_a8_fixes, &a8_fix_table_size,
					  a8_relocs, num_a8_relocs,
					  prev_num_a8_fixes, &stub_changed)
		  != 0)
		goto error_ret_free_local;
	    }
	}

      if (prev_num_a8_fixes != num_a8_fixes)
	stub_changed = TRUE;

      if (!stub_changed)
	break;

      /* OK, we've added some stubs.  Find out the new size of the
	 stub sections.  */
      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  /* Ignore non-stub sections.  */
	  if (!strstr (stub_sec->name, STUB_SUFFIX))
	    continue;

	  stub_sec->size = 0;
	}

      bfd_hash_traverse (&htab->stub_hash_table, arm_size_one_stub, htab);

      /* Add Cortex-A8 erratum veneers to stub section sizes too.  */
      if (htab->fix_cortex_a8)
	for (i = 0; i < num_a8_fixes; i++)
	  {
	    stub_sec = elf32_arm_create_or_find_stub_sec (NULL,
			 a8_fixes[i].section, htab);

	    if (stub_sec == NULL)
	      goto error_ret_free_local;

	    stub_sec->size
	      += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
					      NULL);
	  }


      /* Ask the linker to do its stuff.  */
      (*htab->layout_sections_again) ();
    }

  /* Add stubs for Cortex-A8 erratum fixes now.  */
  if (htab->fix_cortex_a8)
    {
      for (i = 0; i < num_a8_fixes; i++)
	{
	  struct elf32_arm_stub_hash_entry *stub_entry;
	  char *stub_name = a8_fixes[i].stub_name;
	  asection *section = a8_fixes[i].section;
	  unsigned int section_id = a8_fixes[i].section->id;
	  asection *link_sec = htab->stub_group[section_id].link_sec;
	  asection *stub_sec = htab->stub_group[section_id].stub_sec;
	  const insn_sequence *template_sequence;
	  int template_size, size = 0;

	  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
					     TRUE, FALSE);
	  if (stub_entry == NULL)
	    {
	      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
				     section->owner,
				     stub_name);
	      return FALSE;
	    }

	  stub_entry->stub_sec = stub_sec;
	  stub_entry->stub_offset = 0;
	  stub_entry->id_sec = link_sec;
	  stub_entry->stub_type = a8_fixes[i].stub_type;
	  stub_entry->target_section = a8_fixes[i].section;
	  stub_entry->target_value = a8_fixes[i].offset;
	  stub_entry->target_addend = a8_fixes[i].addend;
	  stub_entry->orig_insn = a8_fixes[i].orig_insn;
	  stub_entry->branch_type = a8_fixes[i].branch_type;

	  size = find_stub_size_and_template (a8_fixes[i].stub_type,
					      &template_sequence,
					      &template_size);

	  stub_entry->stub_size = size;
	  stub_entry->stub_template = template_sequence;
	  stub_entry->stub_template_size = template_size;
	}

      /* Stash the Cortex-A8 erratum fix array for use later in
	 elf32_arm_write_section().  */
      htab->a8_erratum_fixes = a8_fixes;
      htab->num_a8_erratum_fixes = num_a8_fixes;
    }
  else
    {
      htab->a8_erratum_fixes = NULL;
      htab->num_a8_erratum_fixes = 0;
    }
  return TRUE;

 error_ret_free_local:
  return FALSE;
}

/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  We also set up the .plt entries for statically linked PIC
   functions here.  This function is called via arm_elf_finish in the
   linker.  */

bfd_boolean
elf32_arm_build_stubs (struct bfd_link_info *info)
{
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    {
      bfd_size_type size;

      /* Ignore non-stub sections.  */
      if (!strstr (stub_sec->name, STUB_SUFFIX))
	continue;

      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->size;
      stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
      if (stub_sec->contents == NULL && size != 0)
	return FALSE;
      stub_sec->size = 0;
    }

  /* Build the stubs as directed by the stub hash table.  */
  table = &htab->stub_hash_table;
  bfd_hash_traverse (table, arm_build_one_stub, info);
  if (htab->fix_cortex_a8)
    {
      /* Place the cortex a8 stubs last.  */
      htab->fix_cortex_a8 = -1;
      bfd_hash_traverse (table, arm_build_one_stub, info);
    }

  return TRUE;
}

/* Locate the Thumb encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_thumb_glue (struct bfd_link_info *link_info,
		 const char *name,
		 char **error_message)
{
  char *tmp_name;
  struct elf_link_hash_entry *hash;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the armelf specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);
  if (hash_table == NULL)
    return NULL;

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  hash = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (hash == NULL
      && asprintf (error_message, _("unable to find THUMB glue '%s' for '%s'"),
		   tmp_name, name) == -1)
    *error_message = (char *) bfd_errmsg (bfd_error_system_call);

  free (tmp_name);

  return hash;
}

/* Locate the ARM encoded calling stub for NAME.  */

static struct elf_link_hash_entry *
find_arm_glue (struct bfd_link_info *link_info,
	       const char *name,
	       char **error_message)
{
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct elf32_arm_link_hash_table *hash_table;

  /* We need a pointer to the elfarm specific hash table.  */
  hash_table = elf32_arm_hash_table (link_info);
  if (hash_table == NULL)
    return NULL;

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh == NULL
      && asprintf (error_message, _("unable to find ARM glue '%s' for '%s'"),
		   tmp_name, name) == -1)
    *error_message = (char *) bfd_errmsg (bfd_error_system_call);

  free (tmp_name);

  return myh;
}

/* ARM->Thumb glue (static images):

   .arm
   __func_from_arm:
   ldr r12, __func_addr
   bx  r12
   __func_addr:
   .word func    @@ behave as if you saw a ARM_32 reloc.

   (v5t static images)
   .arm
   __func_from_arm:
   ldr pc, __func_addr
   __func_addr:
   .word func    @@ behave as if you saw a ARM_32 reloc.

   (relocatable images)
   .arm
   __func_from_arm:
   ldr r12, __func_offset
   add r12, r12, pc
   bx  r12
   __func_offset:
   .word func - .   */

#define ARM2THUMB_STATIC_GLUE_SIZE 12
static const insn32 a2t1_ldr_insn = 0xe59fc000;
static const insn32 a2t2_bx_r12_insn = 0xe12fff1c;
static const insn32 a2t3_func_addr_insn = 0x00000001;

#define ARM2THUMB_V5_STATIC_GLUE_SIZE 8
static const insn32 a2t1v5_ldr_insn = 0xe51ff004;
static const insn32 a2t2v5_func_addr_insn = 0x00000001;

#define ARM2THUMB_PIC_GLUE_SIZE 16
static const insn32 a2t1p_ldr_insn = 0xe59fc004;
static const insn32 a2t2p_add_pc_insn = 0xe08cc00f;
static const insn32 a2t3p_bx_r12_insn = 0xe12fff1c;

/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM

     .thumb                             .thumb
     .align 2                           .align 2
 __func_from_thumb:                 __func_from_thumb:
     bx pc                              push {r6, lr}
     nop                                ldr  r6, __func_addr
     .arm                               mov  lr, pc
     b func                             bx   r6
					.arm
				    ;; back_to_thumb
					ldmia r13! {r6, lr}
					bx    lr
				    __func_addr:
					.word        func  */

#define THUMB2ARM_GLUE_SIZE 8
static const insn16 t2a1_bx_pc_insn = 0x4778;
static const insn16 t2a2_noop_insn = 0x46c0;
static const insn32 t2a3_b_insn = 0xea000000;

#define VFP11_ERRATUM_VENEER_SIZE 8

#define ARM_BX_VENEER_SIZE 12
static const insn32 armbx1_tst_insn = 0xe3100001;
static const insn32 armbx2_moveq_insn = 0x01a0f000;
static const insn32 armbx3_bx_insn = 0xe12fff10;

#ifndef ELFARM_NABI_C_INCLUDED
static void
arm_allocate_glue_section_space (bfd * abfd, bfd_size_type size, const char * name)
{
  asection * s;
  bfd_byte * contents;

  if (size == 0)
    {
      /* Do not include empty glue sections in the output.  */
      if (abfd != NULL)
	{
	  s = bfd_get_linker_section (abfd, name);
	  if (s != NULL)
	    s->flags |= SEC_EXCLUDE;
	}
      return;
    }

  BFD_ASSERT (abfd != NULL);

  s = bfd_get_linker_section (abfd, name);
  BFD_ASSERT (s != NULL);

  contents = (bfd_byte *) bfd_alloc (abfd, size);

  BFD_ASSERT (s->size == size);
  s->contents = contents;
}

bfd_boolean
bfd_elf32_arm_allocate_interworking_sections (struct bfd_link_info * info)
{
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);

  arm_allocate_glue_section_space (globals->bfd_of_glue_owner,
				   globals->arm_glue_size,
				   ARM2THUMB_GLUE_SECTION_NAME);

  arm_allocate_glue_section_space (globals->bfd_of_glue_owner,
				   globals->thumb_glue_size,
				   THUMB2ARM_GLUE_SECTION_NAME);

  arm_allocate_glue_section_space (globals->bfd_of_glue_owner,
				   globals->vfp11_erratum_glue_size,
				   VFP11_ERRATUM_VENEER_SECTION_NAME);

  arm_allocate_glue_section_space (globals->bfd_of_glue_owner,
				   globals->bx_glue_size,
				   ARM_BX_GLUE_SECTION_NAME);

  return TRUE;
}

/* Allocate space and symbols for calling a Thumb function from Arm mode.
   returns the symbol identifying the stub.  */

static struct elf_link_hash_entry *
record_arm_to_thumb_glue (struct bfd_link_info * link_info,
			  struct elf_link_hash_entry * h)
{
  const char * name = h->root.root.string;
  asection * s;
  char * tmp_name;
  struct elf_link_hash_entry * myh;
  struct bfd_link_hash_entry * bh;
  struct elf32_arm_link_hash_table * globals;
  bfd_vma val;
  bfd_size_type size;

  globals = elf32_arm_hash_table (link_info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_linker_section
    (globals->bfd_of_glue_owner, ARM2THUMB_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return myh;
    }

  /* The only trick here is using hash_table->arm_glue_size as the value.
     Even though the section isn't allocated yet, this is where we will be
     putting it.  The +1 on the value marks that the stub has not been
     output yet - not that it is a Thumb function.  */
  bh = NULL;
  val = globals->arm_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  myh->forced_local = 1;

  free (tmp_name);

  if (link_info->shared || globals->root.is_relocatable_executable
      || globals->pic_veneer)
    size = ARM2THUMB_PIC_GLUE_SIZE;
  else if (globals->use_blx)
    size = ARM2THUMB_V5_STATIC_GLUE_SIZE;
  else
    size = ARM2THUMB_STATIC_GLUE_SIZE;

  s->size += size;
  globals->arm_glue_size += size;

  return myh;
}

/* Allocate space for ARMv4 BX veneers.  */

static void
record_arm_bx_glue (struct bfd_link_info * link_info, int reg)
{
  asection * s;
  struct elf32_arm_link_hash_table *globals;
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct bfd_link_hash_entry *bh;
  bfd_vma val;

  /* BX PC does not need a veneer.  */
  if (reg == 15)
    return;

  globals = elf32_arm_hash_table (link_info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  /* Check if this veneer has already been allocated.  */
  if (globals->bx_glue_offset[reg])
    return;

  s = bfd_get_linker_section
    (globals->bfd_of_glue_owner, ARM_BX_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  /* Add symbol for veneer.  */
  tmp_name = (char *)
      bfd_malloc ((bfd_size_type) strlen (ARM_BX_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, ARM_BX_GLUE_ENTRY_NAME, reg);

  myh = elf_link_hash_lookup
    (&(globals)->root, tmp_name, FALSE, FALSE, FALSE);

  BFD_ASSERT (myh == NULL);

  bh = NULL;
  val = globals->bx_glue_size;
  _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  myh->forced_local = 1;

  s->size += ARM_BX_VENEER_SIZE;
  globals->bx_glue_offset[reg] = globals->bx_glue_size | 2;
  globals->bx_glue_size += ARM_BX_VENEER_SIZE;
}


/* Add an entry to the code/data map for section SEC.  */

static void
elf32_arm_section_map_add (asection *sec, char type, bfd_vma vma)
{
  struct _arm_elf_section_data *sec_data = elf32_arm_section_data (sec);
  unsigned int newidx;

  if (sec_data->map == NULL)
    {
      sec_data->map = (elf32_arm_section_map *)
	  bfd_malloc (sizeof (elf32_arm_section_map));
      sec_data->mapcount = 0;
      sec_data->mapsize = 1;
    }

  newidx = sec_data->mapcount++;

  if (sec_data->mapcount > sec_data->mapsize)
    {
      sec_data->mapsize *= 2;
      sec_data->map = (elf32_arm_section_map *)
	  bfd_realloc_or_free (sec_data->map, sec_data->mapsize
			       * sizeof (elf32_arm_section_map));
    }

  if (sec_data->map)
    {
      sec_data->map[newidx].vma = vma;
      sec_data->map[newidx].type = type;
    }
}


/* Record information about a VFP11 denorm-erratum veneer.  Only ARM-mode
   veneers are handled for now.  */

static bfd_vma
record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
			     elf32_vfp11_erratum_list *branch,
			     bfd *branch_bfd,
			     asection *branch_sec,
			     unsigned int offset)
{
  asection *s;
  struct elf32_arm_link_hash_table *hash_table;
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct bfd_link_hash_entry *bh;
  bfd_vma val;
  struct _arm_elf_section_data *sec_data;
  elf32_vfp11_erratum_list *newerr;

  hash_table = elf32_arm_hash_table (link_info);
  BFD_ASSERT (hash_table != NULL);
  BFD_ASSERT (hash_table->bfd_of_glue_owner != NULL);

  s = bfd_get_linker_section
    (hash_table->bfd_of_glue_owner, VFP11_ERRATUM_VENEER_SECTION_NAME);

  sec_data = elf32_arm_section_data (s);

  BFD_ASSERT (s != NULL);

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen
				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
	   hash_table->num_vfp11_fixes);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, FALSE);

  BFD_ASSERT (myh == NULL);

  bh = NULL;
  val = hash_table->vfp11_erratum_glue_size;
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  myh->forced_local = 1;

  /* Link veneer back to calling location.  */
  sec_data->erratumcount += 1;
  newerr = (elf32_vfp11_erratum_list *)
      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));

  newerr->type = VFP11_ERRATUM_ARM_VENEER;
  newerr->vma = -1;
  newerr->u.v.branch = branch;
  newerr->u.v.id = hash_table->num_vfp11_fixes;
  branch->u.b.veneer = newerr;

  newerr->next = sec_data->erratumlist;
  sec_data->erratumlist = newerr;

  /* A symbol for the return from the veneer.  */
  sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
	   hash_table->num_vfp11_fixes);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, FALSE);

  if (myh != NULL)
    abort ();

  bh = NULL;
  val = offset + 4;
  _bfd_generic_link_add_one_symbol (link_info, branch_bfd, tmp_name, BSF_LOCAL,
				    branch_sec, val, NULL, TRUE, FALSE, &bh);

  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  myh->forced_local = 1;

  free (tmp_name);

  /* Generate a mapping symbol for the veneer section, and explicitly add an
     entry for that symbol to the code/data map for the section.  */
  if (hash_table->vfp11_erratum_glue_size == 0)
    {
      bh = NULL;
      /* FIXME: Creates an ARM symbol.  Thumb mode will need attention if it
	 ever requires this erratum fix.  */
      _bfd_generic_link_add_one_symbol (link_info,
					hash_table->bfd_of_glue_owner, "$a",
					BSF_LOCAL, s, 0, NULL,
					TRUE, FALSE, &bh);

      myh = (struct elf_link_hash_entry *) bh;
      myh->type = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
      myh->forced_local = 1;

      /* The elf32_arm_init_maps function only cares about symbols from input
	 BFDs.  We must make a note of this generated mapping symbol
	 ourselves so that code byteswapping works properly in
	 elf32_arm_write_section.  */
      elf32_arm_section_map_add (s, 'a', 0);
    }

  s->size += VFP11_ERRATUM_VENEER_SIZE;
  hash_table->vfp11_erratum_glue_size += VFP11_ERRATUM_VENEER_SIZE;
  hash_table->num_vfp11_fixes++;

  /* The offset of the veneer.  */
  return val;
}

#define ARM_GLUE_SECTION_FLAGS \
  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE \
   | SEC_READONLY | SEC_LINKER_CREATED)

/* Create a fake section for use by the ARM backend of the linker.  */

static bfd_boolean
arm_make_glue_section (bfd * abfd, const char * name)
{
  asection * sec;

  sec = bfd_get_linker_section (abfd, name);
  if (sec != NULL)
    /* Already made.  */
    return TRUE;

  sec = bfd_make_section_anyway_with_flags (abfd, name, ARM_GLUE_SECTION_FLAGS);

  if (sec == NULL
      || !bfd_set_section_alignment (abfd, sec, 2))
    return FALSE;

  /* Set the gc mark to prevent the section from being removed by garbage
     collection, despite the fact that no relocs refer to this section.  */
  sec->gc_mark = 1;

  return TRUE;
}

/* Add the glue sections to ABFD.  This function is called from the
   linker scripts in ld/emultempl/{armelf}.em.  */

bfd_boolean
bfd_elf32_arm_add_glue_sections_to_bfd (bfd *abfd,
					struct bfd_link_info *info)
{
  /* If we are only performing a partial
     link do not bother adding the glue.  */
  if (info->relocatable)
    return TRUE;

  return arm_make_glue_section (abfd, ARM2THUMB_GLUE_SECTION_NAME)
    && arm_make_glue_section (abfd, THUMB2ARM_GLUE_SECTION_NAME)
    && arm_make_glue_section (abfd, VFP11_ERRATUM_VENEER_SECTION_NAME)
    && arm_make_glue_section (abfd, ARM_BX_GLUE_SECTION_NAME);
}

/* Select a BFD to be used to hold the sections used by the glue code.
   This function is called from the linker scripts in ld/emultempl/
   {armelf/pe}.em.  */

bfd_boolean
bfd_elf32_arm_get_bfd_for_interworking (bfd *abfd, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link
     do not bother getting a bfd to hold the glue.  */
  if (info->relocatable)
    return TRUE;

  /* Make sure we don't attach the glue sections to a dynamic object.  */
  BFD_ASSERT (!(abfd->flags & DYNAMIC));

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);

  if (globals->bfd_of_glue_owner != NULL)
    return TRUE;

  /* Save the bfd for later use.  */
  globals->bfd_of_glue_owner = abfd;

  return TRUE;
}

static void
check_use_blx (struct elf32_arm_link_hash_table *globals)
{
  int cpu_arch;

  cpu_arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				       Tag_CPU_arch);

  if (globals->fix_arm1176)
    {
      if (cpu_arch == TAG_CPU_ARCH_V6T2 || cpu_arch > TAG_CPU_ARCH_V6K)
	globals->use_blx = 1;
    }
  else
    {
      if (cpu_arch > TAG_CPU_ARCH_V4T)
	globals->use_blx = 1;
    }
}

bfd_boolean
bfd_elf32_arm_process_before_allocation (bfd *abfd,
					 struct bfd_link_info *link_info)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;

  asection *sec;
  struct elf32_arm_link_hash_table *globals;

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (link_info->relocatable)
    return TRUE;

  /* Here we have a bfd that is to be included on the link.  We have a
     hook to do reloc rummaging, before section sizes are nailed down.  */
  globals = elf32_arm_hash_table (link_info);
  BFD_ASSERT (globals != NULL);

  check_use_blx (globals);

  if (globals->byteswap_code && !bfd_big_endian (abfd))
    {
      _bfd_error_handler (_("%B: BE8 images only valid in big-endian mode."),
			  abfd);
      return FALSE;
    }

  /* PR 5398: If we have not decided to include any loadable sections in
     the output then we will not have a glue owner bfd.  This is OK, it
     just means that there is nothing else for us to do here.  */
  if (globals->bfd_of_glue_owner == NULL)
    return TRUE;

  /* Rummage around all the relocs and map the glue vectors.  */
  sec = abfd->sections;

  if (sec == NULL)
    return TRUE;

  for (; sec != NULL; sec = sec->next)
    {
      if (sec->reloc_count == 0)
	continue;

      if ((sec->flags & SEC_EXCLUDE) != 0)
	continue;

      symtab_hdr = & elf_symtab_hdr (abfd);

      /* Load the relocs.  */
      internal_relocs
	= _bfd_elf_link_read_relocs (abfd, sec, NULL, NULL, FALSE);

      if (internal_relocs == NULL)
	goto error_return;

      irelend = internal_relocs + sec->reloc_count;
      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  long r_type;
	  unsigned long r_index;

	  struct elf_link_hash_entry *h;

	  r_type = ELF32_R_TYPE (irel->r_info);
	  r_index = ELF32_R_SYM (irel->r_info);

	  /* These are the only relocation types we care about.  */
	  if (   r_type != R_ARM_PC24
	      && (r_type != R_ARM_V4BX || globals->fix_v4bx < 2))
	    continue;

	  /* Get the section contents if we haven't done so already.  */
	  if (contents == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (elf_section_data (sec)->this_hdr.contents != NULL)
		contents = elf_section_data (sec)->this_hdr.contents;
	      else
		{
		  /* Go get them off disk.  */
		  if (! bfd_malloc_and_get_section (abfd, sec, &contents))
		    goto error_return;
		}
	    }

	  if (r_type == R_ARM_V4BX)
	    {
	      int reg;

	      reg = bfd_get_32 (abfd, contents + irel->r_offset) & 0xf;
	      record_arm_bx_glue (link_info, reg);
	      continue;
	    }

	  /* If the relocation is not against a symbol it cannot concern us.  */
	  h = NULL;

	  /* We don't care about local symbols.  */
	  if (r_index < symtab_hdr->sh_info)
	    continue;

	  /* This is an external symbol.  */
	  r_index -= symtab_hdr->sh_info;
	  h = (struct elf_link_hash_entry *)
	    elf_sym_hashes (abfd)[r_index];

	  /* If the relocation is against a static symbol it must be within
	     the current section and so cannot be a cross ARM/Thumb relocation.  */
	  if (h == NULL)
	    continue;

	  /* If the call will go through a PLT entry then we do not need
	     glue.  */
	  if (globals->root.splt != NULL && h->plt.offset != (bfd_vma) -1)
	    continue;

	  switch (r_type)
	    {
	    case R_ARM_PC24:
	      /* This one is a call from arm code.  We need to look up
		 the target of the call.  If it is a thumb target, we
		 insert glue.  */
	      if (h->target_internal == ST_BRANCH_TO_THUMB)
		record_arm_to_thumb_glue (link_info, h);
	      break;

	    default:
	      abort ();
	    }
	}

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;

      if (internal_relocs != NULL
	  && elf_section_data (sec)->relocs != internal_relocs)
	free (internal_relocs);
      internal_relocs = NULL;
    }

  return TRUE;

error_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}
#endif


/* Initialise maps of ARM/Thumb/data for input BFDs.  */

void
bfd_elf32_arm_init_maps (bfd *abfd)
{
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Shdr *hdr;
  unsigned int i, localsyms;

  /* PR 7093: Make sure that we are dealing with an arm elf binary.  */
  if (! is_arm_elf (abfd))
    return;

  if ((abfd->flags & DYNAMIC) != 0)
    return;

  hdr = & elf_symtab_hdr (abfd);
  localsyms = hdr->sh_info;

  /* Obtain a buffer full of symbols for this BFD. The hdr->sh_info field
     should contain the number of local symbols, which should come before any
     global symbols.  Mapping symbols are always local.  */
  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, localsyms, 0, NULL, NULL,
				  NULL);

  /* No internal symbols read?  Skip this BFD.  */
  if (isymbuf == NULL)
    return;

  for (i = 0; i < localsyms; i++)
    {
      Elf_Internal_Sym *isym = &isymbuf[i];
      asection *sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
      const char *name;

      if (sec != NULL
	  && ELF_ST_BIND (isym->st_info) == STB_LOCAL)
	{
	  name = bfd_elf_string_from_elf_section (abfd,
	    hdr->sh_link, isym->st_name);

	  if (bfd_is_arm_special_symbol_name (name,
					      BFD_ARM_SPECIAL_SYM_TYPE_MAP))
	    elf32_arm_section_map_add (sec, name[1], isym->st_value);
	}
    }
}


/* Auto-select enabling of Cortex-A8 erratum fix if the user didn't explicitly
   say what they wanted.  */

void
bfd_elf32_arm_set_cortex_a8_fix (bfd *obfd, struct bfd_link_info *link_info)
{
  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
  obj_attribute *out_attr = elf_known_obj_attributes_proc (obfd);

  if (globals == NULL)
    return;

  if (globals->fix_cortex_a8 == -1)
    {
      /* Turn on Cortex-A8 erratum workaround for ARMv7-A.  */
      if (out_attr[Tag_CPU_arch].i == TAG_CPU_ARCH_V7
	  && (out_attr[Tag_CPU_arch_profile].i == 'A'
	      || out_attr[Tag_CPU_arch_profile].i == 0))
	globals->fix_cortex_a8 = 1;
      else
	globals->fix_cortex_a8 = 0;
    }
}


void
bfd_elf32_arm_set_vfp11_fix (bfd *obfd, struct bfd_link_info *link_info)
{
  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
  obj_attribute *out_attr = elf_known_obj_attributes_proc (obfd);

  if (globals == NULL)
    return;
  /* We assume that ARMv7+ does not need the VFP11 denorm erratum fix.  */
  if (out_attr[Tag_CPU_arch].i >= TAG_CPU_ARCH_V7)
    {
      switch (globals->vfp11_fix)
	{
	case BFD_ARM_VFP11_FIX_DEFAULT:
	case BFD_ARM_VFP11_FIX_NONE:
	  globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
	  break;

	default:
	  /* Give a warning, but do as the user requests anyway.  */
	  (*_bfd_error_handler) (_("%B: warning: selected VFP11 erratum "
	    "workaround is not necessary for target architecture"), obfd);
	}
    }
  else if (globals->vfp11_fix == BFD_ARM_VFP11_FIX_DEFAULT)
    /* For earlier architectures, we might need the workaround, but do not
       enable it by default.  If users is running with broken hardware, they
       must enable the erratum fix explicitly.  */
    globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
}


enum bfd_arm_vfp11_pipe
{
  VFP11_FMAC,
  VFP11_LS,
  VFP11_DS,
  VFP11_BAD
};

/* Return a VFP register number.  This is encoded as RX:X for single-precision
   registers, or X:RX for double-precision registers, where RX is the group of
   four bits in the instruction encoding and X is the single extension bit.
   RX and X fields are specified using their lowest (starting) bit.  The return
   value is:

     0...31: single-precision registers s0...s31
     32...63: double-precision registers d0...d31.

   Although X should be zero for VFP11 (encoding d0...d15 only), we might
   encounter VFP3 instructions, so we allow the full range for DP registers.  */

static unsigned int
bfd_arm_vfp11_regno (unsigned int insn, bfd_boolean is_double, unsigned int rx,
		     unsigned int x)
{
  if (is_double)
    return (((insn >> rx) & 0xf) | (((insn >> x) & 1) << 4)) + 32;
  else
    return (((insn >> rx) & 0xf) << 1) | ((insn >> x) & 1);
}

/* Set bits in *WMASK according to a register number REG as encoded by
   bfd_arm_vfp11_regno().  Ignore d16-d31.  */

static void
bfd_arm_vfp11_write_mask (unsigned int *wmask, unsigned int reg)
{
  if (reg < 32)
    *wmask |= 1 << reg;
  else if (reg < 48)
    *wmask |= 3 << ((reg - 32) * 2);
}

/* Return TRUE if WMASK overwrites anything in REGS.  */

static bfd_boolean
bfd_arm_vfp11_antidependency (unsigned int wmask, int *regs, int numregs)
{
  int i;

  for (i = 0; i < numregs; i++)
    {
      unsigned int reg = regs[i];

      if (reg < 32 && (wmask & (1 << reg)) != 0)
	return TRUE;

      reg -= 32;

      if (reg >= 16)
	continue;

      if ((wmask & (3 << (reg * 2))) != 0)
	return TRUE;
    }

  return FALSE;
}

/* In this function, we're interested in two things: finding input registers
   for VFP data-processing instructions, and finding the set of registers which
   arbitrary VFP instructions may write to.  We use a 32-bit unsigned int to
   hold the written set, so FLDM etc. are easy to deal with (we're only
   interested in 32 SP registers or 16 dp registers, due to the VFP version
   implemented by the chip in question).  DP registers are marked by setting
   both SP registers in the write mask).  */

static enum bfd_arm_vfp11_pipe
bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
			   int *numregs)
{
  enum bfd_arm_vfp11_pipe vpipe = VFP11_BAD;
  bfd_boolean is_double = ((insn & 0xf00) == 0xb00) ? 1 : 0;

  if ((insn & 0x0f000e10) == 0x0e000a00)  /* A data-processing insn.  */
    {
      unsigned int pqrs;
      unsigned int fd = bfd_arm_vfp11_regno (insn, is_double, 12, 22);
      unsigned int fm = bfd_arm_vfp11_regno (insn, is_double, 0, 5);

      pqrs = ((insn & 0x00800000) >> 20)
	   | ((insn & 0x00300000) >> 19)
	   | ((insn & 0x00000040) >> 6);

      switch (pqrs)
	{
	case 0: /* fmac[sd].  */
	case 1: /* fnmac[sd].  */
	case 2: /* fmsc[sd].  */
	case 3: /* fnmsc[sd].  */
	  vpipe = VFP11_FMAC;
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  regs[0] = fd;
	  regs[1] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);  /* Fn.  */
	  regs[2] = fm;
	  *numregs = 3;
	  break;

	case 4: /* fmul[sd].  */
	case 5: /* fnmul[sd].  */
	case 6: /* fadd[sd].  */
	case 7: /* fsub[sd].  */
	  vpipe = VFP11_FMAC;
	  goto vfp_binop;

	case 8: /* fdiv[sd].  */
	  vpipe = VFP11_DS;
	  vfp_binop:
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  regs[0] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);   /* Fn.  */
	  regs[1] = fm;
	  *numregs = 2;
	  break;

	case 15: /* extended opcode.  */
	  {
	    unsigned int extn = ((insn >> 15) & 0x1e)
			      | ((insn >> 7) & 1);

	    switch (extn)
	      {
	      case 0: /* fcpy[sd].  */
	      case 1: /* fabs[sd].  */
	      case 2: /* fneg[sd].  */
	      case 8: /* fcmp[sd].  */
	      case 9: /* fcmpe[sd].  */
	      case 10: /* fcmpz[sd].  */
	      case 11: /* fcmpez[sd].  */
	      case 16: /* fuito[sd].  */
	      case 17: /* fsito[sd].  */
	      case 24: /* ftoui[sd].  */
	      case 25: /* ftouiz[sd].  */
	      case 26: /* ftosi[sd].  */
	      case 27: /* ftosiz[sd].  */
		/* These instructions will not bounce due to underflow.  */
		*numregs = 0;
		vpipe = VFP11_FMAC;
		break;

	      case 3: /* fsqrt[sd].  */
		/* fsqrt cannot underflow, but it can (perhaps) overwrite
		   registers to cause the erratum in previous instructions.  */
		bfd_arm_vfp11_write_mask (destmask, fd);
		vpipe = VFP11_DS;
		break;

	      case 15: /* fcvt{ds,sd}.  */
		{
		  int rnum = 0;

		  bfd_arm_vfp11_write_mask (destmask, fd);

		  /* Only FCVTSD can underflow.  */
		  if ((insn & 0x100) != 0)
		    regs[rnum++] = fm;

		  *numregs = rnum;

		  vpipe = VFP11_FMAC;
		}
		break;

	      default:
		return VFP11_BAD;
	      }
	  }
	  break;

	default:
	  return VFP11_BAD;
	}
    }
  /* Two-register transfer.  */
  else if ((insn & 0x0fe00ed0) == 0x0c400a10)
    {
      unsigned int fm = bfd_arm_vfp11_regno (insn, is_double, 0, 5);

      if ((insn & 0x100000) == 0)
	{
	  if (is_double)
	    bfd_arm_vfp11_write_mask (destmask, fm);
	  else
	    {
	      bfd_arm_vfp11_write_mask (destmask, fm);
	      bfd_arm_vfp11_write_mask (destmask, fm + 1);
	    }
	}

      vpipe = VFP11_LS;
    }
  else if ((insn & 0x0e100e00) == 0x0c100a00)  /* A load insn.  */
    {
      int fd = bfd_arm_vfp11_regno (insn, is_double, 12, 22);
      unsigned int puw = ((insn >> 21) & 0x1) | (((insn >> 23) & 3) << 1);

      switch (puw)
	{
	case 0: /* Two-reg transfer.  We should catch these above.  */
	  abort ();

	case 2: /* fldm[sdx].  */
	case 3:
	case 5:
	  {
	    unsigned int i, offset = insn & 0xff;

	    if (is_double)
	      offset >>= 1;

	    for (i = fd; i < fd + offset; i++)
	      bfd_arm_vfp11_write_mask (destmask, i);
	  }
	  break;

	case 4: /* fld[sd].  */
	case 6:
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  break;

	default:
	  return VFP11_BAD;
	}

      vpipe = VFP11_LS;
    }
  /* Single-register transfer. Note L==0.  */
  else if ((insn & 0x0f100e10) == 0x0e000a10)
    {
      unsigned int opcode = (insn >> 21) & 7;
      unsigned int fn = bfd_arm_vfp11_regno (insn, is_double, 16, 7);

      switch (opcode)
	{
	case 0: /* fmsr/fmdlr.  */
	case 1: /* fmdhr.  */
	  /* Mark fmdhr and fmdlr as writing to the whole of the DP
	     destination register.  I don't know if this is exactly right,
	     but it is the conservative choice.  */
	  bfd_arm_vfp11_write_mask (destmask, fn);
	  break;

	case 7: /* fmxr.  */
	  break;
	}

      vpipe = VFP11_LS;
    }

  return vpipe;
}


static int elf32_arm_compare_mapping (const void * a, const void * b);


/* Look for potentially-troublesome code sequences which might trigger the
   VFP11 denormal/antidependency erratum.  See, e.g., the ARM1136 errata sheet
   (available from ARM) for details of the erratum.  A short version is
   described in ld.texinfo.  */

bfd_boolean
bfd_elf32_arm_vfp11_erratum_scan (bfd *abfd, struct bfd_link_info *link_info)
{
  asection *sec;
  bfd_byte *contents = NULL;
  int state = 0;
  int regs[3], numregs = 0;
  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
  int use_vector = (globals->vfp11_fix == BFD_ARM_VFP11_FIX_VECTOR);

  if (globals == NULL)
    return FALSE;

  /* We use a simple FSM to match troublesome VFP11 instruction sequences.
     The states transition as follows:

       0 -> 1 (vector) or 0 -> 2 (scalar)
	   A VFP FMAC-pipeline instruction has been seen. Fill
	   regs[0]..regs[numregs-1] with its input operands. Remember this
	   instruction in 'first_fmac'.

       1 -> 2
	   Any instruction, except for a VFP instruction which overwrites
	   regs[*].

       1 -> 3 [ -> 0 ]  or
       2 -> 3 [ -> 0 ]
	   A VFP instruction has been seen which overwrites any of regs[*].
	   We must make a veneer!  Reset state to 0 before examining next
	   instruction.

       2 -> 0
	   If we fail to match anything in state 2, reset to state 0 and reset
	   the instruction pointer to the instruction after 'first_fmac'.

     If the VFP11 vector mode is in use, there must be at least two unrelated
     instructions between anti-dependent VFP11 instructions to properly avoid
     triggering the erratum, hence the use of the extra state 1.  */

  /* If we are only performing a partial link do not bother
     to construct any glue.  */
  if (link_info->relocatable)
    return TRUE;

  /* Skip if this bfd does not correspond to an ELF image.  */
  if (! is_arm_elf (abfd))
    return TRUE;

  /* We should have chosen a fix type by the time we get here.  */
  BFD_ASSERT (globals->vfp11_fix != BFD_ARM_VFP11_FIX_DEFAULT);

  if (globals->vfp11_fix == BFD_ARM_VFP11_FIX_NONE)
    return TRUE;

  /* Skip this BFD if it corresponds to an executable or dynamic object.  */
  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
    return TRUE;

  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      unsigned int i, span, first_fmac = 0, veneer_of_insn = 0;
      struct _arm_elf_section_data *sec_data;

      /* If we don't have executable progbits, we're not interested in this
	 section.  Also skip if section is to be excluded.  */
      if (elf_section_type (sec) != SHT_PROGBITS
	  || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
	  || (sec->flags & SEC_EXCLUDE) != 0
	  || sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
	  || sec->output_section == bfd_abs_section_ptr
	  || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
	continue;

      sec_data = elf32_arm_section_data (sec);

      if (sec_data->mapcount == 0)
	continue;

      if (elf_section_data (sec)->this_hdr.contents != NULL)
	contents = elf_section_data (sec)->this_hdr.contents;
      else if (! bfd_malloc_and_get_section (abfd, sec, &contents))
	goto error_return;

      qsort (sec_data->map, sec_data->mapcount, sizeof (elf32_arm_section_map),
	     elf32_arm_compare_mapping);

      for (span = 0; span < sec_data->mapcount; span++)
	{
	  unsigned int span_start = sec_data->map[span].vma;
	  unsigned int span_end = (span == sec_data->mapcount - 1)
				  ? sec->size : sec_data->map[span + 1].vma;
	  char span_type = sec_data->map[span].type;

	  /* FIXME: Only ARM mode is supported at present.  We may need to
	     support Thumb-2 mode also at some point.  */
	  if (span_type != 'a')
	    continue;

	  for (i = span_start; i < span_end;)
	    {
	      unsigned int next_i = i + 4;
	      unsigned int insn = bfd_big_endian (abfd)
		? (contents[i] << 24)
		  | (contents[i + 1] << 16)
		  | (contents[i + 2] << 8)
		  | contents[i + 3]
		: (contents[i + 3] << 24)
		  | (contents[i + 2] << 16)
		  | (contents[i + 1] << 8)
		  | contents[i];
	      unsigned int writemask = 0;
	      enum bfd_arm_vfp11_pipe vpipe;

	      switch (state)
		{
		case 0:
		  vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
						    &numregs);
		  /* I'm assuming the VFP11 erratum can trigger with denorm
		     operands on either the FMAC or the DS pipeline. This might
		     lead to slightly overenthusiastic veneer insertion.  */
		  if (vpipe == VFP11_FMAC || vpipe == VFP11_DS)
		    {
		      state = use_vector ? 1 : 2;
		      first_fmac = i;
		      veneer_of_insn = insn;
		    }
		  break;

		case 1:
		  {
		    int other_regs[3], other_numregs;
		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
						      other_regs,
						      &other_numregs);
		    if (vpipe != VFP11_BAD
			&& bfd_arm_vfp11_antidependency (writemask, regs,
							 numregs))
		      state = 3;
		    else
		      state = 2;
		  }
		  break;

		case 2:
		  {
		    int other_regs[3], other_numregs;
		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
						      other_regs,
						      &other_numregs);
		    if (vpipe != VFP11_BAD
			&& bfd_arm_vfp11_antidependency (writemask, regs,
							 numregs))
		      state = 3;
		    else
		      {
			state = 0;
			next_i = first_fmac + 4;
		      }
		  }
		  break;

		case 3:
		  abort ();  /* Should be unreachable.  */
		}

	      if (state == 3)
		{
		  elf32_vfp11_erratum_list *newerr =(elf32_vfp11_erratum_list *)
		      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));

		  elf32_arm_section_data (sec)->erratumcount += 1;

		  newerr->u.b.vfp_insn = veneer_of_insn;

		  switch (span_type)
		    {
		    case 'a':
		      newerr->type = VFP11_ERRATUM_BRANCH_TO_ARM_VENEER;
		      break;

		    default:
		      abort ();
		    }

		  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
					       first_fmac);

		  newerr->vma = -1;

		  newerr->next = sec_data->erratumlist;
		  sec_data->erratumlist = newerr;

		  state = 0;
		}

	      i = next_i;
	    }
	}

      if (contents != NULL
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
      contents = NULL;
    }

  return TRUE;

error_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);

  return FALSE;
}

/* Find virtual-memory addresses for VFP11 erratum veneers and return locations
   after sections have been laid out, using specially-named symbols.  */

void
bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
					  struct bfd_link_info *link_info)
{
  asection *sec;
  struct elf32_arm_link_hash_table *globals;
  char *tmp_name;

  if (link_info->relocatable)
    return;

  /* Skip if this bfd does not correspond to an ELF image.  */
  if (! is_arm_elf (abfd))
    return;

  globals = elf32_arm_hash_table (link_info);
  if (globals == NULL)
    return;

  tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen
				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);

  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      struct _arm_elf_section_data *sec_data = elf32_arm_section_data (sec);
      elf32_vfp11_erratum_list *errnode = sec_data->erratumlist;

      for (; errnode != NULL; errnode = errnode->next)
	{
	  struct elf_link_hash_entry *myh;
	  bfd_vma vma;

	  switch (errnode->type)
	    {
	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
	    case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
	      /* Find veneer symbol.  */
	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
		       errnode->u.b.veneer->u.v.id);

	      myh = elf_link_hash_lookup
		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);

	      if (myh == NULL)
		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
					 "`%s'"), abfd, tmp_name);

	      vma = myh->root.u.def.section->output_section->vma
		    + myh->root.u.def.section->output_offset
		    + myh->root.u.def.value;

	      errnode->u.b.veneer->vma = vma;
	      break;

	    case VFP11_ERRATUM_ARM_VENEER:
	    case VFP11_ERRATUM_THUMB_VENEER:
	      /* Find return location.  */
	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
		       errnode->u.v.id);

	      myh = elf_link_hash_lookup
		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);

	      if (myh == NULL)
		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
					 "`%s'"), abfd, tmp_name);

	      vma = myh->root.u.def.section->output_section->vma
		    + myh->root.u.def.section->output_offset
		    + myh->root.u.def.value;

	      errnode->u.v.branch->vma = vma;
	      break;

	    default:
	      abort ();
	    }
	}
    }

  free (tmp_name);
}


/* Set target relocation values needed during linking.  */

void
bfd_elf32_arm_set_target_relocs (struct bfd *output_bfd,
				 struct bfd_link_info *link_info,
				 int target1_is_rel,
				 char * target2_type,
				 int fix_v4bx,
				 int use_blx,
				 bfd_arm_vfp11_fix vfp11_fix,
				 int no_enum_warn, int no_wchar_warn,
				 int pic_veneer, int fix_cortex_a8,
				 int fix_arm1176)
{
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (link_info);
  if (globals == NULL)
    return;

  globals->target1_is_rel = target1_is_rel;
  if (strcmp (target2_type, "rel") == 0)
    globals->target2_reloc = R_ARM_REL32;
  else if (strcmp (target2_type, "abs") == 0)
    globals->target2_reloc = R_ARM_ABS32;
  else if (strcmp (target2_type, "got-rel") == 0)
    globals->target2_reloc = R_ARM_GOT_PREL;
  else
    {
      _bfd_error_handler (_("Invalid TARGET2 relocation type '%s'."),
			  target2_type);
    }
  globals->fix_v4bx = fix_v4bx;
  globals->use_blx |= use_blx;
  globals->vfp11_fix = vfp11_fix;
  globals->pic_veneer = pic_veneer;
  globals->fix_cortex_a8 = fix_cortex_a8;
  globals->fix_arm1176 = fix_arm1176;

  BFD_ASSERT (is_arm_elf (output_bfd));
  elf_arm_tdata (output_bfd)->no_enum_size_warning = no_enum_warn;
  elf_arm_tdata (output_bfd)->no_wchar_size_warning = no_wchar_warn;
}

/* Replace the target offset of a Thumb bl or b.w instruction.  */

static void
insert_thumb_branch (bfd *abfd, long int offset, bfd_byte *insn)
{
  bfd_vma upper;
  bfd_vma lower;
  int reloc_sign;

  BFD_ASSERT ((offset & 1) == 0);

  upper = bfd_get_16 (abfd, insn);
  lower = bfd_get_16 (abfd, insn + 2);
  reloc_sign = (offset < 0) ? 1 : 0;
  upper = (upper & ~(bfd_vma) 0x7ff)
	  | ((offset >> 12) & 0x3ff)
	  | (reloc_sign << 10);
  lower = (lower & ~(bfd_vma) 0x2fff)
	  | (((!((offset >> 23) & 1)) ^ reloc_sign) << 13)
	  | (((!((offset >> 22) & 1)) ^ reloc_sign) << 11)
	  | ((offset >> 1) & 0x7ff);
  bfd_put_16 (abfd, upper, insn);
  bfd_put_16 (abfd, lower, insn + 2);
}

/* Thumb code calling an ARM function.  */

static int
elf32_thumb_to_arm_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val,
			 char **error_message)
{
  asection * s = 0;
  bfd_vma my_offset;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_thumb_glue (info, name, error_message);
  if (myh == NULL)
    return FALSE;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;

  s = bfd_get_linker_section (globals->bfd_of_glue_owner,
			      THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: Thumb call to ARM"),
	     sym_sec->owner, input_bfd, name);

	  return FALSE;
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      put_thumb_insn (globals, output_bfd, (bfd_vma) t2a1_bx_pc_insn,
		      s->contents + my_offset);

      put_thumb_insn (globals, output_bfd, (bfd_vma) t2a2_noop_insn,
		      s->contents + my_offset + 2);

      ret_offset =
	/* Address of destination of the stub.  */
	((bfd_signed_vma) val)
	- ((bfd_signed_vma)
	   /* Offset from the start of the current section
	      to the start of the stubs.  */
	   (s->output_offset
	    /* Offset of the start of this stub from the start of the stubs.  */
	    + my_offset
	    /* Address of the start of the current section.  */
	    + s->output_section->vma)
	   /* The branch instruction is 4 bytes into the stub.  */
	   + 4
	   /* ARM branches work from the pc of the instruction + 8.  */
	   + 8);

      put_arm_insn (globals, output_bfd,
		    (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
		    s->contents + my_offset + 4);
    }

  BFD_ASSERT (my_offset <= globals->thumb_glue_size);

  /* Now go back and fix up the original BL insn to point to here.  */
  ret_offset =
    /* Address of where the stub is located.  */
    (s->output_section->vma + s->output_offset + my_offset)
     /* Address of where the BL is located.  */
    - (input_section->output_section->vma + input_section->output_offset
       + offset)
    /* Addend in the relocation.  */
    - addend
    /* Biassing for PC-relative addressing.  */
    - 8;

  insert_thumb_branch (input_bfd, ret_offset, hit_data - input_section->vma);

  return TRUE;
}

/* Populate an Arm to Thumb stub.  Returns the stub symbol.  */

static struct elf_link_hash_entry *
elf32_arm_create_thumb_stub (struct bfd_link_info * info,
			     const char *           name,
			     bfd *                  input_bfd,
			     bfd *                  output_bfd,
			     asection *             sym_sec,
			     bfd_vma                val,
			     asection *             s,
			     char **                error_message)
{
  bfd_vma my_offset;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  myh = find_arm_glue (info, name, error_message);
  if (myh == NULL)
    return NULL;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  my_offset = myh->root.u.def.value;

  if ((my_offset & 0x01) == 0x01)
    {
      if (sym_sec != NULL
	  && sym_sec->owner != NULL
	  && !INTERWORK_FLAG (sym_sec->owner))
	{
	  (*_bfd_error_handler)
	    (_("%B(%s): warning: interworking not enabled.\n"
	       "  first occurrence: %B: arm call to thumb"),
	     sym_sec->owner, input_bfd, name);
	}

      --my_offset;
      myh->root.u.def.value = my_offset;

      if (info->shared || globals->root.is_relocatable_executable
	  || globals->pic_veneer)
	{
	  /* For relocatable objects we can't use absolute addresses,
	     so construct the address from a relative offset.  */
	  /* TODO: If the offset is small it's probably worth
	     constructing the address with adds.  */
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t1p_ldr_insn,
			s->contents + my_offset);
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t2p_add_pc_insn,
			s->contents + my_offset + 4);
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t3p_bx_r12_insn,
			s->contents + my_offset + 8);
	  /* Adjust the offset by 4 for the position of the add,
	     and 8 for the pipeline offset.  */
	  ret_offset = (val - (s->output_offset
			       + s->output_section->vma
			       + my_offset + 12))
		       | 1;
	  bfd_put_32 (output_bfd, ret_offset,
		      s->contents + my_offset + 12);
	}
      else if (globals->use_blx)
	{
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t1v5_ldr_insn,
			s->contents + my_offset);

	  /* It's a thumb address.  Add the low order bit.  */
	  bfd_put_32 (output_bfd, val | a2t2v5_func_addr_insn,
		      s->contents + my_offset + 4);
	}
      else
	{
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t1_ldr_insn,
			s->contents + my_offset);

	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t2_bx_r12_insn,
			s->contents + my_offset + 4);

	  /* It's a thumb address.  Add the low order bit.  */
	  bfd_put_32 (output_bfd, val | a2t3_func_addr_insn,
		      s->contents + my_offset + 8);

	  my_offset += 12;
	}
    }

  BFD_ASSERT (my_offset <= globals->arm_glue_size);

  return myh;
}

/* Arm code calling a Thumb function.  */

static int
elf32_arm_to_thumb_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val,
			 char **error_message)
{
  unsigned long int tmp;
  bfd_vma my_offset;
  asection * s;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_linker_section (globals->bfd_of_glue_owner,
			      ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  myh = elf32_arm_create_thumb_stub (info, name, input_bfd, output_bfd,
				     sym_sec, val, s, error_message);
  if (!myh)
    return FALSE;

  my_offset = myh->root.u.def.value;
  tmp = bfd_get_32 (input_bfd, hit_data);
  tmp = tmp & 0xFF000000;

  /* Somehow these are both 4 too far, so subtract 8.  */
  ret_offset = (s->output_offset
		+ my_offset
		+ s->output_section->vma
		- (input_section->output_offset
		   + input_section->output_section->vma
		   + offset + addend)
		- 8);

  tmp = tmp | ((ret_offset >> 2) & 0x00FFFFFF);

  bfd_put_32 (output_bfd, (bfd_vma) tmp, hit_data - input_section->vma);

  return TRUE;
}

/* Populate Arm stub for an exported Thumb function.  */

static bfd_boolean
elf32_arm_to_thumb_export_stub (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info * info = (struct bfd_link_info *) inf;
  asection * s;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_link_hash_table * globals;
  asection *sec;
  bfd_vma val;
  char *error_message;

  eh = elf32_arm_hash_entry (h);
  /* Allocate stubs for exported Thumb functions on v4t.  */
  if (eh->export_glue == NULL)
    return TRUE;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_linker_section (globals->bfd_of_glue_owner,
			      ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  sec = eh->export_glue->root.u.def.section;

  BFD_ASSERT (sec->output_section != NULL);

  val = eh->export_glue->root.u.def.value + sec->output_offset
	+ sec->output_section->vma;

  myh = elf32_arm_create_thumb_stub (info, h->root.root.string,
				     h->root.u.def.section->owner,
				     globals->obfd, sec, val, s,
				     &error_message);
  BFD_ASSERT (myh);
  return TRUE;
}

/* Populate ARMv4 BX veneers.  Returns the absolute adress of the veneer.  */

static bfd_vma
elf32_arm_bx_glue (struct bfd_link_info * info, int reg)
{
  bfd_byte *p;
  bfd_vma glue_addr;
  asection *s;
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (info);
  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_linker_section (globals->bfd_of_glue_owner,
			      ARM_BX_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  BFD_ASSERT (globals->bx_glue_offset[reg] & 2);

  glue_addr = globals->bx_glue_offset[reg] & ~(bfd_vma)3;

  if ((globals->bx_glue_offset[reg] & 1) == 0)
    {
      p = s->contents + glue_addr;
      bfd_put_32 (globals->obfd, armbx1_tst_insn + (reg << 16), p);
      bfd_put_32 (globals->obfd, armbx2_moveq_insn + reg, p + 4);
      bfd_put_32 (globals->obfd, armbx3_bx_insn + reg, p + 8);
      globals->bx_glue_offset[reg] |= 1;
    }

  return glue_addr + s->output_section->vma + s->output_offset;
}

/* Generate Arm stubs for exported Thumb symbols.  */
static void
elf32_arm_begin_write_processing (bfd *abfd ATTRIBUTE_UNUSED,
				  struct bfd_link_info *link_info)
{
  struct elf32_arm_link_hash_table * globals;

  if (link_info == NULL)
    /* Ignore this if we are not called by the ELF backend linker.  */
    return;

  globals = elf32_arm_hash_table (link_info);
  if (globals == NULL)
    return;

  /* If blx is available then exported Thumb symbols are OK and there is
     nothing to do.  */
  if (globals->use_blx)
    return;

  elf_link_hash_traverse (&globals->root, elf32_arm_to_thumb_export_stub,
			  link_info);
}

/* Reserve space for COUNT dynamic relocations in relocation selection
   SRELOC.  */

static void
elf32_arm_allocate_dynrelocs (struct bfd_link_info *info, asection *sreloc,
			      bfd_size_type count)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  BFD_ASSERT (htab->root.dynamic_sections_created);
  if (sreloc == NULL)
    abort ();
  sreloc->size += RELOC_SIZE (htab) * count;
}

/* Reserve space for COUNT R_ARM_IRELATIVE relocations.  If the link is
   dynamic, the relocations should go in SRELOC, otherwise they should
   go in the special .rel.iplt section.  */

static void
elf32_arm_allocate_irelocs (struct bfd_link_info *info, asection *sreloc,
			    bfd_size_type count)
{
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->root.dynamic_sections_created)
    htab->root.irelplt->size += RELOC_SIZE (htab) * count;
  else
    {
      BFD_ASSERT (sreloc != NULL);
      sreloc->size += RELOC_SIZE (htab) * count;
    }
}

/* Add relocation REL to the end of relocation section SRELOC.  */

static void
elf32_arm_add_dynreloc (bfd *output_bfd, struct bfd_link_info *info,
			asection *sreloc, Elf_Internal_Rela *rel)
{
  bfd_byte *loc;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->root.dynamic_sections_created
      && ELF32_R_TYPE (rel->r_info) == R_ARM_IRELATIVE)
    sreloc = htab->root.irelplt;
  if (sreloc == NULL)
    abort ();
  loc = sreloc->contents;
  loc += sreloc->reloc_count++ * RELOC_SIZE (htab);
  if (sreloc->reloc_count * RELOC_SIZE (htab) > sreloc->size)
    abort ();
  SWAP_RELOC_OUT (htab) (output_bfd, rel, loc);
}

/* Allocate room for a PLT entry described by ROOT_PLT and ARM_PLT.
   IS_IPLT_ENTRY says whether the entry belongs to .iplt rather than
   to .plt.  */

static void
elf32_arm_allocate_plt_entry (struct bfd_link_info *info,
			      bfd_boolean is_iplt_entry,
			      union gotplt_union *root_plt,
			      struct arm_plt_info *arm_plt)
{
  struct elf32_arm_link_hash_table *htab;
  asection *splt;
  asection *sgotplt;

  htab = elf32_arm_hash_table (info);

  if (is_iplt_entry)
    {
      splt = htab->root.iplt;
      sgotplt = htab->root.igotplt;

      /* NaCl uses a special first entry in .iplt too.  */
      if (htab->nacl_p && splt->size == 0)
	splt->size += htab->plt_header_size;

      /* Allocate room for an R_ARM_IRELATIVE relocation in .rel.iplt.  */
      elf32_arm_allocate_irelocs (info, htab->root.irelplt, 1);
    }
  else
    {
      splt = htab->root.splt;
      sgotplt = htab->root.sgotplt;

      /* Allocate room for an R_JUMP_SLOT relocation in .rel.plt.  */
      elf32_arm_allocate_dynrelocs (info, htab->root.srelplt, 1);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (splt->size == 0)
	splt->size += htab->plt_header_size;
    }

  /* Allocate the PLT entry itself, including any leading Thumb stub.  */
  if (elf32_arm_plt_needs_thumb_stub_p (info, arm_plt))
    splt->size += PLT_THUMB_STUB_SIZE;
  root_plt->offset = splt->size;
  splt->size += htab->plt_entry_size;

  if (!htab->symbian_p)
    {
      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      arm_plt->got_offset = sgotplt->size - 8 * htab->num_tls_desc;
      sgotplt->size += 4;
    }
}

static bfd_vma
arm_movw_immediate (bfd_vma value)
{
  return (value & 0x00000fff) | ((value & 0x0000f000) << 4);
}

static bfd_vma
arm_movt_immediate (bfd_vma value)
{
  return ((value & 0x0fff0000) >> 16) | ((value & 0xf0000000) >> 12);
}

/* Fill in a PLT entry and its associated GOT slot.  If DYNINDX == -1,
   the entry lives in .iplt and resolves to (*SYM_VALUE)().
   Otherwise, DYNINDX is the index of the symbol in the dynamic
   symbol table and SYM_VALUE is undefined.

   ROOT_PLT points to the offset of the PLT entry from the start of its
   section (.iplt or .plt).  ARM_PLT points to the symbol's ARM-specific
   bookkeeping information.  */

static void
elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,
			      union gotplt_union *root_plt,
			      struct arm_plt_info *arm_plt,
			      int dynindx, bfd_vma sym_value)
{
  struct elf32_arm_link_hash_table *htab;
  asection *sgot;
  asection *splt;
  asection *srel;
  bfd_byte *loc;
  bfd_vma plt_index;
  Elf_Internal_Rela rel;
  bfd_vma plt_header_size;
  bfd_vma got_header_size;

  htab = elf32_arm_hash_table (info);

  /* Pick the appropriate sections and sizes.  */
  if (dynindx == -1)
    {
      splt = htab->root.iplt;
      sgot = htab->root.igotplt;
      srel = htab->root.irelplt;

      /* There are no reserved entries in .igot.plt, and no special
	 first entry in .iplt.  */
      got_header_size = 0;
      plt_header_size = 0;
    }
  else
    {
      splt = htab->root.splt;
      sgot = htab->root.sgotplt;
      srel = htab->root.srelplt;

      got_header_size = get_elf_backend_data (output_bfd)->got_header_size;
      plt_header_size = htab->plt_header_size;
    }
  BFD_ASSERT (splt != NULL && srel != NULL);

  /* Fill in the entry in the procedure linkage table.  */
  if (htab->symbian_p)
    {
      BFD_ASSERT (dynindx >= 0);
      put_arm_insn (htab, output_bfd,
		    elf32_arm_symbian_plt_entry[0],
		    splt->contents + root_plt->offset);
      bfd_put_32 (output_bfd,
		  elf32_arm_symbian_plt_entry[1],
		  splt->contents + root_plt->offset + 4);

      /* Fill in the entry in the .rel.plt section.  */
      rel.r_offset = (splt->output_section->vma
		      + splt->output_offset
		      + root_plt->offset + 4);
      rel.r_info = ELF32_R_INFO (dynindx, R_ARM_GLOB_DAT);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = ((root_plt->offset - plt_header_size)
		   / htab->plt_entry_size);
    }
  else
    {
      bfd_vma got_offset, got_address, plt_address;
      bfd_vma got_displacement, initial_got_entry;
      bfd_byte * ptr;

      BFD_ASSERT (sgot != NULL);

      /* Get the offset into the .(i)got.plt table of the entry that
	 corresponds to this function.  */
      got_offset = (arm_plt->got_offset & -2);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.
	 After the reserved .got.plt entries, all symbols appear in
	 the same order as in .plt.  */
      plt_index = (got_offset - got_header_size) / 4;

      /* Calculate the address of the GOT entry.  */
      got_address = (sgot->output_section->vma
		     + sgot->output_offset
		     + got_offset);

      /* ...and the address of the PLT entry.  */
      plt_address = (splt->output_section->vma
		     + splt->output_offset
		     + root_plt->offset);

      ptr = splt->contents + root_plt->offset;
      if (htab->vxworks_p && info->shared)
	{
	  unsigned int i;
	  bfd_vma val;

	  for (i = 0; i != htab->plt_entry_size / 4; i++, ptr += 4)
	    {
	      val = elf32_arm_vxworks_shared_plt_entry[i];
	      if (i == 2)
		val |= got_address - sgot->output_section->vma;
	      if (i == 5)
		val |= plt_index * RELOC_SIZE (htab);
	      if (i == 2 || i == 5)
		bfd_put_32 (output_bfd, val, ptr);
	      else
		put_arm_insn (htab, output_bfd, val, ptr);
	    }
	}
      else if (htab->vxworks_p)
	{
	  unsigned int i;
	  bfd_vma val;

	  for (i = 0; i != htab->plt_entry_size / 4; i++, ptr += 4)
	    {
	      val = elf32_arm_vxworks_exec_plt_entry[i];
	      if (i == 2)
		val |= got_address;
	      if (i == 4)
		val |= 0xffffff & -((root_plt->offset + i * 4 + 8) >> 2);
	      if (i == 5)
		val |= plt_index * RELOC_SIZE (htab);
	      if (i == 2 || i == 5)
		bfd_put_32 (output_bfd, val, ptr);
	      else
		put_arm_insn (htab, output_bfd, val, ptr);
	    }

	  loc = (htab->srelplt2->contents
		 + (plt_index * 2 + 1) * RELOC_SIZE (htab));

	  /* Create the .rela.plt.unloaded R_ARM_ABS32 relocation
	     referencing the GOT for this PLT entry.  */
	  rel.r_offset = plt_address + 8;
	  rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_ARM_ABS32);
	  rel.r_addend = got_offset;
	  SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
	  loc += RELOC_SIZE (htab);

	  /* Create the R_ARM_ABS32 relocation referencing the
	     beginning of the PLT for this GOT entry.  */
	  rel.r_offset = got_address;
	  rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_ARM_ABS32);
	  rel.r_addend = 0;
	  SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
	}
      else if (htab->nacl_p)
	{
	  /* Calculate the displacement between the PLT slot and the
	     common tail that's part of the special initial PLT slot.  */
	  int32_t tail_displacement
	    = ((splt->output_section->vma + splt->output_offset
		+ ARM_NACL_PLT_TAIL_OFFSET)
	       - (plt_address + htab->plt_entry_size + 4));
	  BFD_ASSERT ((tail_displacement & 3) == 0);
	  tail_displacement >>= 2;

	  BFD_ASSERT ((tail_displacement & 0xff000000) == 0
		      || (-tail_displacement & 0xff000000) == 0);

	  /* Calculate the displacement between the PLT slot and the entry
	     in the GOT.  The offset accounts for the value produced by
	     adding to pc in the penultimate instruction of the PLT stub.  */
	  got_displacement = (got_address
			      - (plt_address + htab->plt_entry_size));

	  /* NaCl does not support interworking at all.  */
	  BFD_ASSERT (!elf32_arm_plt_needs_thumb_stub_p (info, arm_plt));

	  put_arm_insn (htab, output_bfd,
			elf32_arm_nacl_plt_entry[0]
			| arm_movw_immediate (got_displacement),
			ptr + 0);
	  put_arm_insn (htab, output_bfd,
			elf32_arm_nacl_plt_entry[1]
			| arm_movt_immediate (got_displacement),
			ptr + 4);
	  put_arm_insn (htab, output_bfd,
			elf32_arm_nacl_plt_entry[2],
			ptr + 8);
	  put_arm_insn (htab, output_bfd,
			elf32_arm_nacl_plt_entry[3]
			| (tail_displacement & 0x00ffffff),
			ptr + 12);
	}
      else
	{
	  /* Calculate the displacement between the PLT slot and the
	     entry in the GOT.  The eight-byte offset accounts for the
	     value produced by adding to pc in the first instruction
	     of the PLT stub.  */
	  got_displacement = got_address - (plt_address + 8);

	  BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

	  if (elf32_arm_plt_needs_thumb_stub_p (info, arm_plt))
	    {
	      put_thumb_insn (htab, output_bfd,
			      elf32_arm_plt_thumb_stub[0], ptr - 4);
	      put_thumb_insn (htab, output_bfd,
			      elf32_arm_plt_thumb_stub[1], ptr - 2);
	    }

	  put_arm_insn (htab, output_bfd,
			elf32_arm_plt_entry[0]
			| ((got_displacement & 0x0ff00000) >> 20),
			ptr + 0);
	  put_arm_insn (htab, output_bfd,
			elf32_arm_plt_entry[1]
			| ((got_displacement & 0x000ff000) >> 12),
			ptr+ 4);
	  put_arm_insn (htab, output_bfd,
			elf32_arm_plt_entry[2]
			| (got_displacement & 0x00000fff),
			ptr + 8);
#ifdef FOUR_WORD_PLT
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[3], ptr + 12);
#endif
	}

      /* Fill in the entry in the .rel(a).(i)plt section.  */
      rel.r_offset = got_address;
      rel.r_addend = 0;
      if (dynindx == -1)
	{
	  /* .igot.plt entries use IRELATIVE relocations against SYM_VALUE.
	     The dynamic linker or static executable then calls SYM_VALUE
	     to determine the correct run-time value of the .igot.plt entry.  */
	  rel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
	  initial_got_entry = sym_value;
	}
      else
	{
	  rel.r_info = ELF32_R_INFO (dynindx, R_ARM_JUMP_SLOT);
	  initial_got_entry = (splt->output_section->vma
			       + splt->output_offset);
	}

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd, initial_got_entry,
		  sgot->contents + got_offset);
    }

  if (dynindx == -1)
    elf32_arm_add_dynreloc (output_bfd, info, srel, &rel);
  else
    {
      loc = srel->contents + plt_index * RELOC_SIZE (htab);
      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
    }
}

/* Some relocations map to different relocations depending on the
   target.  Return the real relocation.  */

static int
arm_real_reloc_type (struct elf32_arm_link_hash_table * globals,
		     int r_type)
{
  switch (r_type)
    {
    case R_ARM_TARGET1:
      if (globals->target1_is_rel)
	return R_ARM_REL32;
      else
	return R_ARM_ABS32;

    case R_ARM_TARGET2:
      return globals->target2_reloc;

    default:
      return r_type;
    }
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);
  bfd_vma base;

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  base = align_power ((bfd_vma) TCB_SIZE, htab->tls_sec->alignment_power);
  return address - htab->tls_sec->vma + base;
}

/* Perform an R_ARM_ABS12 relocation on the field pointed to by DATA.
   VALUE is the relocation value.  */

static bfd_reloc_status_type
elf32_arm_abs12_reloc (bfd *abfd, void *data, bfd_vma value)
{
  if (value > 0xfff)
    return bfd_reloc_overflow;

  value |= bfd_get_32 (abfd, data) & 0xfffff000;
  bfd_put_32 (abfd, value, data);
  return bfd_reloc_ok;
}

/* Handle TLS relaxations.  Relaxing is possible for symbols that use
   R_ARM_GOTDESC, R_ARM_{,THM_}TLS_CALL or
   R_ARM_{,THM_}TLS_DESCSEQ relocations, during a static link.

   Return bfd_reloc_ok if we're done, bfd_reloc_continue if the caller
   is to then call final_link_relocate.  Return other values in the
   case of error.

   FIXME:When --emit-relocs is in effect, we'll emit relocs describing
   the pre-relaxed code.  It would be nice if the relocs were updated
   to match the optimization.   */

static bfd_reloc_status_type
elf32_arm_tls_relax (struct elf32_arm_link_hash_table *globals,
		     bfd *input_bfd, asection *input_sec, bfd_byte *contents,
		     Elf_Internal_Rela *rel, unsigned long is_local)
{
  unsigned long insn;

  switch (ELF32_R_TYPE (rel->r_info))
    {
    default:
      return bfd_reloc_notsupported;

    case R_ARM_TLS_GOTDESC:
      if (is_local)
	insn = 0;
      else
	{
	  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	  if (insn & 1)
	    insn -= 5; /* THUMB */
	  else
	    insn -= 8; /* ARM */
	}
      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
      return bfd_reloc_continue;

    case R_ARM_THM_TLS_DESCSEQ:
      /* Thumb insn.  */
      insn = bfd_get_16 (input_bfd, contents + rel->r_offset);
      if ((insn & 0xff78) == 0x4478)	  /* add rx, pc */
	{
	  if (is_local)
	    /* nop */
	    bfd_put_16 (input_bfd, 0x46c0, contents + rel->r_offset);
	}
      else if ((insn & 0xffc0) == 0x6840)  /* ldr rx,[ry,#4] */
	{
	  if (is_local)
	    /* nop */
	    bfd_put_16 (input_bfd, 0x46c0, contents + rel->r_offset);
	  else
	    /* ldr rx,[ry] */
	    bfd_put_16 (input_bfd, insn & 0xf83f, contents + rel->r_offset);
	}
      else if ((insn & 0xff87) == 0x4780)  /* blx rx */
	{
	  if (is_local)
	    /* nop */
	    bfd_put_16 (input_bfd, 0x46c0, contents + rel->r_offset);
	  else
	    /* mov r0, rx */
	    bfd_put_16 (input_bfd, 0x4600 | (insn & 0x78),
			contents + rel->r_offset);
	}
      else
	{
	  if ((insn & 0xf000) == 0xf000 || (insn & 0xf800) == 0xe800)
	    /* It's a 32 bit instruction, fetch the rest of it for
	       error generation.  */
	    insn = (insn << 16)
	      | bfd_get_16 (input_bfd, contents + rel->r_offset + 2);
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx):unexpected Thumb instruction '0x%x' in TLS trampoline"),
	     input_bfd, input_sec, (unsigned long)rel->r_offset, insn);
	  return bfd_reloc_notsupported;
	}
      break;

    case R_ARM_TLS_DESCSEQ:
      /* arm insn.  */
      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
      if ((insn & 0xffff0ff0) == 0xe08f0000) /* add rx,pc,ry */
	{
	  if (is_local)
	    /* mov rx, ry */
	    bfd_put_32 (input_bfd, 0xe1a00000 | (insn & 0xffff),
			contents + rel->r_offset);
	}
      else if ((insn & 0xfff00fff) == 0xe5900004) /* ldr rx,[ry,#4]*/
	{
	  if (is_local)
	    /* nop */
	    bfd_put_32 (input_bfd, 0xe1a00000, contents + rel->r_offset);
	  else
	    /* ldr rx,[ry] */
	    bfd_put_32 (input_bfd, insn & 0xfffff000,
			contents + rel->r_offset);
	}
      else if ((insn & 0xfffffff0) == 0xe12fff30) /* blx rx */
	{
	  if (is_local)
	    /* nop */
	    bfd_put_32 (input_bfd, 0xe1a00000, contents + rel->r_offset);
	  else
	    /* mov r0, rx */
	    bfd_put_32 (input_bfd, 0xe1a00000 | (insn & 0xf),
			contents + rel->r_offset);
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx):unexpected ARM instruction '0x%x' in TLS trampoline"),
	     input_bfd, input_sec, (unsigned long)rel->r_offset, insn);
	  return bfd_reloc_notsupported;
	}
      break;

    case R_ARM_TLS_CALL:
      /* GD->IE relaxation, turn the instruction into 'nop' or
	 'ldr r0, [pc,r0]'  */
      insn = is_local ? 0xe1a00000 : 0xe79f0000;
      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);
      break;

    case R_ARM_THM_TLS_CALL:
      /* GD->IE relaxation */
      if (!is_local)
	/* add r0,pc; ldr r0, [r0]  */
	insn = 0x44786800;
      else if (arch_has_thumb2_nop (globals))
	/* nop.w */
	insn = 0xf3af8000;
      else
	/* nop; nop */
	insn = 0xbf00bf00;

      bfd_put_16 (input_bfd, insn >> 16, contents + rel->r_offset);
      bfd_put_16 (input_bfd, insn & 0xffff, contents + rel->r_offset + 2);
      break;
    }
  return bfd_reloc_ok;
}

/* For a given value of n, calculate the value of G_n as required to
   deal with group relocations.  We return it in the form of an
   encoded constant-and-rotation, together with the final residual.  If n is
   specified as less than zero, then final_residual is filled with the
   input value and no further action is performed.  */

static bfd_vma
calculate_group_reloc_mask (bfd_vma value, int n, bfd_vma *final_residual)
{
  int current_n;
  bfd_vma g_n;
  bfd_vma encoded_g_n = 0;
  bfd_vma residual = value; /* Also known as Y_n.  */

  for (current_n = 0; current_n <= n; current_n++)
    {
      int shift;

      /* Calculate which part of the value to mask.  */
      if (residual == 0)
	shift = 0;
      else
	{
	  int msb;

	  /* Determine the most significant bit in the residual and
	     align the resulting value to a 2-bit boundary.  */
	  for (msb = 30; msb >= 0; msb -= 2)
	    if (residual & (3 << msb))
	      break;

	  /* The desired shift is now (msb - 6), or zero, whichever
	     is the greater.  */
	  shift = msb - 6;
	  if (shift < 0)
	    shift = 0;
	}

      /* Calculate g_n in 32-bit as well as encoded constant+rotation form.  */
      g_n = residual & (0xff << shift);
      encoded_g_n = (g_n >> shift)
		    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);

      /* Calculate the residual for the next time around.  */
      residual &= ~g_n;
    }

  *final_residual = residual;

  return encoded_g_n;
}

/* Given an ARM instruction, determine whether it is an ADD or a SUB.
   Returns 1 if it is an ADD, -1 if it is a SUB, and 0 otherwise.  */

static int
identify_add_or_sub (bfd_vma insn)
{
  int opcode = insn & 0x1e00000;

  if (opcode == 1 << 23) /* ADD */
    return 1;

  if (opcode == 1 << 22) /* SUB */
    return -1;

  return 0;
}

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
elf32_arm_final_link_relocate (reloc_howto_type *           howto,
			       bfd *                        input_bfd,
			       bfd *                        output_bfd,
			       asection *                   input_section,
			       bfd_byte *                   contents,
			       Elf_Internal_Rela *          rel,
			       bfd_vma                      value,
			       struct bfd_link_info *       info,
			       asection *                   sym_sec,
			       const char *                 sym_name,
			       unsigned char                st_type,
			       enum arm_st_branch_type      branch_type,
			       struct elf_link_hash_entry * h,
			       bfd_boolean *                unresolved_reloc_p,
			       char **                      error_message)
{
  unsigned long                 r_type = howto->type;
  unsigned long                 r_symndx;
  bfd_byte *                    hit_data = contents + rel->r_offset;
  bfd_vma *                     local_got_offsets;
  bfd_vma *                     local_tlsdesc_gotents;
  asection *                    sgot;
  asection *                    splt;
  asection *                    sreloc = NULL;
  asection *                    srelgot;
  bfd_vma                       addend;
  bfd_signed_vma                signed_addend;
  unsigned char                 dynreloc_st_type;
  bfd_vma                       dynreloc_value;
  struct elf32_arm_link_hash_table * globals;
  struct elf32_arm_link_hash_entry *eh;
  union gotplt_union           *root_plt;
  struct arm_plt_info          *arm_plt;
  bfd_vma                       plt_offset;
  bfd_vma                       gotplt_offset;
  bfd_boolean                   has_iplt_entry;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return bfd_reloc_notsupported;

  BFD_ASSERT (is_arm_elf (input_bfd));

  /* Some relocation types map to different relocations depending on the
     target.  We pick the right one here.  */
  r_type = arm_real_reloc_type (globals, r_type);

  /* It is possible to have linker relaxations on some TLS access
     models.  Update our information here.  */
  r_type = elf32_arm_tls_transition (info, r_type, h);

  if (r_type != howto->type)
    howto = elf32_arm_howto_from_type (r_type);

  /* If the start address has been set, then set the EF_ARM_HASENTRY
     flag.  Setting this more than once is redundant, but the cost is
     not too high, and it keeps the code simple.

     The test is done  here, rather than somewhere else, because the
     start address is only set just before the final link commences.

     Note - if the user deliberately sets a start address of 0, the
     flag will not be set.  */
  if (bfd_get_start_address (output_bfd) != 0)
    elf_elfheader (output_bfd)->e_flags |= EF_ARM_HASENTRY;

  eh = (struct elf32_arm_link_hash_entry *) h;
  sgot = globals->root.sgot;
  local_got_offsets = elf_local_got_offsets (input_bfd);
  local_tlsdesc_gotents = elf32_arm_local_tlsdesc_gotent (input_bfd);

  if (globals->root.dynamic_sections_created)
    srelgot = globals->root.srelgot;
  else
    srelgot = NULL;

  r_symndx = ELF32_R_SYM (rel->r_info);

  if (globals->use_rel)
    {
      addend = bfd_get_32 (input_bfd, hit_data) & howto->src_mask;

      if (addend & ((howto->src_mask + 1) >> 1))
	{
	  signed_addend = -1;
	  signed_addend &= ~ howto->src_mask;
	  signed_addend |= addend;
	}
      else
	signed_addend = addend;
    }
  else
    addend = signed_addend = rel->r_addend;

  /* ST_BRANCH_TO_ARM is nonsense to thumb-only targets when we
     are resolving a function call relocation.  */
  if (using_thumb_only (globals)
      && (r_type == R_ARM_THM_CALL
	  || r_type == R_ARM_THM_JUMP24)
      && branch_type == ST_BRANCH_TO_ARM)
    branch_type = ST_BRANCH_TO_THUMB;

  /* Record the symbol information that should be used in dynamic
     relocations.  */
  dynreloc_st_type = st_type;
  dynreloc_value = value;
  if (branch_type == ST_BRANCH_TO_THUMB)
    dynreloc_value |= 1;

  /* Find out whether the symbol has a PLT.  Set ST_VALUE, BRANCH_TYPE and
     VALUE appropriately for relocations that we resolve at link time.  */
  has_iplt_entry = FALSE;
  if (elf32_arm_get_plt_info (input_bfd, eh, r_symndx, &root_plt, &arm_plt)
      && root_plt->offset != (bfd_vma) -1)
    {
      plt_offset = root_plt->offset;
      gotplt_offset = arm_plt->got_offset;

      if (h == NULL || eh->is_iplt)
	{
	  has_iplt_entry = TRUE;
	  splt = globals->root.iplt;

	  /* Populate .iplt entries here, because not all of them will
	     be seen by finish_dynamic_symbol.  The lower bit is set if
	     we have already populated the entry.  */
	  if (plt_offset & 1)
	    plt_offset--;
	  else
	    {
	      elf32_arm_populate_plt_entry (output_bfd, info, root_plt, arm_plt,
					    -1, dynreloc_value);
	      root_plt->offset |= 1;
	    }

	  /* Static relocations always resolve to the .iplt entry.  */
	  st_type = STT_FUNC;
	  value = (splt->output_section->vma
		   + splt->output_offset
		   + plt_offset);
	  branch_type = ST_BRANCH_TO_ARM;

	  /* If there are non-call relocations that resolve to the .iplt
	     entry, then all dynamic ones must too.  */
	  if (arm_plt->noncall_refcount != 0)
	    {
	      dynreloc_st_type = st_type;
	      dynreloc_value = value;
	    }
	}
      else
	/* We populate the .plt entry in finish_dynamic_symbol.  */
	splt = globals->root.splt;
    }
  else
    {
      splt = NULL;
      plt_offset = (bfd_vma) -1;
      gotplt_offset = (bfd_vma) -1;
    }

  switch (r_type)
    {
    case R_ARM_NONE:
      /* We don't need to find a value for this symbol.  It's just a
	 marker.  */
      *unresolved_reloc_p = FALSE;
      return bfd_reloc_ok;

    case R_ARM_ABS12:
      if (!globals->vxworks_p)
	return elf32_arm_abs12_reloc (input_bfd, hit_data, value + addend);

    case R_ARM_PC24:
    case R_ARM_ABS32:
    case R_ARM_ABS32_NOI:
    case R_ARM_REL32:
    case R_ARM_REL32_NOI:
    case R_ARM_CALL:
    case R_ARM_JUMP24:
    case R_ARM_XPC25:
    case R_ARM_PREL31:
    case R_ARM_PLT32:
      /* Handle relocations which should use the PLT entry.  ABS32/REL32
	 will use the symbol's value, which may point to a PLT entry, but we
	 don't need to handle that here.  If we created a PLT entry, all
	 branches in this object should go to it, except if the PLT is too
	 far away, in which case a long branch stub should be inserted.  */
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
	   && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI
	   && r_type != R_ARM_CALL
	   && r_type != R_ARM_JUMP24
	   && r_type != R_ARM_PLT32)
	  && plt_offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry
	     to this function, it must either be a STT_GNU_IFUNC reference
	     or not be known to bind locally.  In other cases, we should
	     have cleared the PLT entry by now.  */
	  BFD_ASSERT (has_iplt_entry || !SYMBOL_CALLS_LOCAL (info, h));

	  value = (splt->output_section->vma
		   + splt->output_offset
		   + plt_offset);
	  *unresolved_reloc_p = FALSE;
	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset, value,
					   rel->r_addend);
	}

      /* When generating a shared object or relocatable executable, these
	 relocations are copied into the output file to be resolved at
	 run time.  */
      if ((info->shared || globals->root.is_relocatable_executable)
	  && (input_section->flags & SEC_ALLOC)
	  && !(globals->vxworks_p
	       && strcmp (input_section->output_section->name,
			  ".tls_vars") == 0)
	  && ((r_type != R_ARM_REL32 && r_type != R_ARM_REL32_NOI)
	      || !SYMBOL_CALLS_LOCAL (info, h))
	  && !(input_bfd == globals->stub_bfd
	       && strstr (input_section->name, STUB_SUFFIX))
	  && (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	      || h->root.type != bfd_link_hash_undefweak)
	  && r_type != R_ARM_PC24
	  && r_type != R_ARM_CALL
	  && r_type != R_ARM_JUMP24
	  && r_type != R_ARM_PREL31
	  && r_type != R_ARM_PLT32)
	{
	  Elf_Internal_Rela outrel;
	  bfd_boolean skip, relocate;

	  *unresolved_reloc_p = FALSE;

	  if (sreloc == NULL && globals->root.dynamic_sections_created)
	    {
	      sreloc = _bfd_elf_get_dynamic_reloc_section (input_bfd, input_section,
							   ! globals->use_rel);

	      if (sreloc == NULL)
		return bfd_reloc_notsupported;
	    }

	  skip = FALSE;
	  relocate = FALSE;

	  outrel.r_addend = addend;
	  outrel.r_offset =
	    _bfd_elf_section_offset (output_bfd, info, input_section,
				     rel->r_offset);
	  if (outrel.r_offset == (bfd_vma) -1)
	    skip = TRUE;
	  else if (outrel.r_offset == (bfd_vma) -2)
	    skip = TRUE, relocate = TRUE;
	  outrel.r_offset += (input_section->output_section->vma
			      + input_section->output_offset);

	  if (skip)
	    memset (&outrel, 0, sizeof outrel);
	  else if (h != NULL
		   && h->dynindx != -1
		   && (!info->shared
		       || !info->symbolic
		       || !h->def_regular))
	    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
	  else
	    {
	      int symbol;

	      /* This symbol is local, or marked to become local.  */
	      BFD_ASSERT (r_type == R_ARM_ABS32 || r_type == R_ARM_ABS32_NOI);
	      if (globals->symbian_p)
		{
		  asection *osec;

		  /* On Symbian OS, the data segment and text segement
		     can be relocated independently.  Therefore, we
		     must indicate the segment to which this
		     relocation is relative.  The BPABI allows us to
		     use any symbol in the right segment; we just use
		     the section symbol as it is convenient.  (We
		     cannot use the symbol given by "h" directly as it
		     will not appear in the dynamic symbol table.)

		     Note that the dynamic linker ignores the section
		     symbol value, so we don't subtract osec->vma
		     from the emitted reloc addend.  */
		  if (sym_sec)
		    osec = sym_sec->output_section;
		  else
		    osec = input_section->output_section;
		  symbol = elf_section_data (osec)->dynindx;
		  if (symbol == 0)
		    {
		      struct elf_link_hash_table *htab = elf_hash_table (info);

		      if ((osec->flags & SEC_READONLY) == 0
			  && htab->data_index_section != NULL)
			osec = htab->data_index_section;
		      else
			osec = htab->text_index_section;
		      symbol = elf_section_data (osec)->dynindx;
		    }
		  BFD_ASSERT (symbol != 0);
		}
	      else
		/* On SVR4-ish systems, the dynamic loader cannot
		   relocate the text and data segments independently,
		   so the symbol does not matter.  */
		symbol = 0;
	      if (dynreloc_st_type == STT_GNU_IFUNC)
		/* We have an STT_GNU_IFUNC symbol that doesn't resolve
		   to the .iplt entry.  Instead, every non-call reference
		   must use an R_ARM_IRELATIVE relocation to obtain the
		   correct run-time address.  */
		outrel.r_info = ELF32_R_INFO (symbol, R_ARM_IRELATIVE);
	      else
		outrel.r_info = ELF32_R_INFO (symbol, R_ARM_RELATIVE);
	      if (globals->use_rel)
		relocate = TRUE;
	      else
		outrel.r_addend += dynreloc_value;
	    }

	  elf32_arm_add_dynreloc (output_bfd, info, sreloc, &outrel);

	  /* If this reloc is against an external symbol, we do not want to
	     fiddle with the addend.  Otherwise, we need to include the symbol
	     value so that it becomes an addend for the dynamic reloc.  */
	  if (! relocate)
	    return bfd_reloc_ok;

	  return _bfd_final_link_relocate (howto, input_bfd, input_section,
					   contents, rel->r_offset,
					   dynreloc_value, (bfd_vma) 0);
	}
      else switch (r_type)
	{
	case R_ARM_ABS12:
	  return elf32_arm_abs12_reloc (input_bfd, hit_data, value + addend);

	case R_ARM_XPC25:	  /* Arm BLX instruction.  */
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PC24:	  /* Arm B/BL instruction.  */
	case R_ARM_PLT32:
	  {
	  struct elf32_arm_stub_hash_entry *stub_entry = NULL;

	  if (r_type == R_ARM_XPC25)
	    {
	      /* Check for Arm calling Arm function.  */
	      /* FIXME: Should we translate the instruction into a BL
		 instruction instead ?  */
	      if (branch_type != ST_BRANCH_TO_THUMB)
		(*_bfd_error_handler)
		  (_("\%B: Warning: Arm BLX instruction targets Arm function '%s'."),
		   input_bfd,
		   h ? h->root.root.string : "(local)");
	    }
	  else if (r_type == R_ARM_PC24)
	    {
	      /* Check for Arm calling Thumb function.  */
	      if (branch_type == ST_BRANCH_TO_THUMB)
		{
		  if (elf32_arm_to_thumb_stub (info, sym_name, input_bfd,
					       output_bfd, input_section,
					       hit_data, sym_sec, rel->r_offset,
					       signed_addend, value,
					       error_message))
		    return bfd_reloc_ok;
		  else
		    return bfd_reloc_dangerous;
		}
	    }

	  /* Check if a stub has to be inserted because the
	     destination is too far or we are changing mode.  */
	  if (   r_type == R_ARM_CALL
	      || r_type == R_ARM_JUMP24
	      || r_type == R_ARM_PLT32)
	    {
	      enum elf32_arm_stub_type stub_type = arm_stub_none;
	      struct elf32_arm_link_hash_entry *hash;

	      hash = (struct elf32_arm_link_hash_entry *) h;
	      stub_type = arm_type_of_stub (info, input_section, rel,
					    st_type, &branch_type,
					    hash, value, sym_sec,
					    input_bfd, sym_name);

	      if (stub_type != arm_stub_none)
		{
		  /* The target is out of reach, so redirect the
		     branch to the local stub for this function.  */
		  stub_entry = elf32_arm_get_stub_entry (input_section,
							 sym_sec, h,
							 rel, globals,
							 stub_type);
		  {
		    if (stub_entry != NULL)
		      value = (stub_entry->stub_offset
			       + stub_entry->stub_sec->output_offset
			       + stub_entry->stub_sec->output_section->vma);

		    if (plt_offset != (bfd_vma) -1)
		      *unresolved_reloc_p = FALSE;
		  }
		}
	      else
		{
		  /* If the call goes through a PLT entry, make sure to
		     check distance to the right destination address.  */
		  if (plt_offset != (bfd_vma) -1)
		    {
		      value = (splt->output_section->vma
			       + splt->output_offset
			       + plt_offset);
		      *unresolved_reloc_p = FALSE;
		      /* The PLT entry is in ARM mode, regardless of the
			 target function.  */
		      branch_type = ST_BRANCH_TO_ARM;
		    }
		}
	    }

	  /* The ARM ELF ABI says that this reloc is computed as: S - P + A
	     where:
	      S is the address of the symbol in the relocation.
	      P is address of the instruction being relocated.
	      A is the addend (extracted from the instruction) in bytes.

	     S is held in 'value'.
	     P is the base address of the section containing the
	       instruction plus the offset of the reloc into that
	       section, ie:
		 (input_section->output_section->vma +
		  input_section->output_offset +
		  rel->r_offset).
	     A is the addend, converted into bytes, ie:
		 (signed_addend * 4)

	     Note: None of these operations have knowledge of the pipeline
	     size of the processor, thus it is up to the assembler to
	     encode this information into the addend.  */
	  value -= (input_section->output_section->vma
		    + input_section->output_offset);
	  value -= rel->r_offset;
	  if (globals->use_rel)
	    value += (signed_addend << howto->size);
	  else
	    /* RELA addends do not have to be adjusted by howto->size.  */
	    value += signed_addend;

	  signed_addend = value;
	  signed_addend >>= howto->rightshift;

	  /* A branch to an undefined weak symbol is turned into a jump to
	     the next instruction unless a PLT entry will be created.
	     Do the same for local undefined symbols (but not for STN_UNDEF).
	     The jump to the next instruction is optimized as a NOP depending
	     on the architecture.  */
	  if (h ? (h->root.type == bfd_link_hash_undefweak
		   && plt_offset == (bfd_vma) -1)
	      : r_symndx != STN_UNDEF && bfd_is_und_section (sym_sec))
	    {
	      value = (bfd_get_32 (input_bfd, hit_data) & 0xf0000000);

	      if (arch_has_arm_nop (globals))
		value |= 0x0320f000;
	      else
		value |= 0x01a00000; /* Using pre-UAL nop: mov r0, r0.  */
	    }
	  else
	    {
	      /* Perform a signed range check.  */
	      if (   signed_addend >   ((bfd_signed_vma)  (howto->dst_mask >> 1))
		  || signed_addend < - ((bfd_signed_vma) ((howto->dst_mask + 1) >> 1)))
		return bfd_reloc_overflow;

	      addend = (value & 2);

	      value = (signed_addend & howto->dst_mask)
		| (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));

	      if (r_type == R_ARM_CALL)
		{
		  /* Set the H bit in the BLX instruction.  */
		  if (branch_type == ST_BRANCH_TO_THUMB)
		    {
		      if (addend)
			value |= (1 << 24);
		      else
			value &= ~(bfd_vma)(1 << 24);
		    }

		  /* Select the correct instruction (BL or BLX).  */
		  /* Only if we are not handling a BL to a stub. In this
		     case, mode switching is performed by the stub.  */
		  if (branch_type == ST_BRANCH_TO_THUMB && !stub_entry)
		    value |= (1 << 28);
		  else if (stub_entry || branch_type != ST_BRANCH_UNKNOWN)
		    {
		      value &= ~(bfd_vma)(1 << 28);
		      value |= (1 << 24);
		    }
		}
	    }
	  }
	  break;

	case R_ARM_ABS32:
	  value += addend;
	  if (branch_type == ST_BRANCH_TO_THUMB)
	    value |= 1;
	  break;

	case R_ARM_ABS32_NOI:
	  value += addend;
	  break;

	case R_ARM_REL32:
	  value += addend;
	  if (branch_type == ST_BRANCH_TO_THUMB)
	    value |= 1;
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  break;

	case R_ARM_REL32_NOI:
	  value += addend;
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  break;

	case R_ARM_PREL31:
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  value += signed_addend;
	  if (! h || h->root.type != bfd_link_hash_undefweak)
	    {
	      /* Check for overflow.  */
	      if ((value ^ (value >> 1)) & (1 << 30))
		return bfd_reloc_overflow;
	    }
	  value &= 0x7fffffff;
	  value |= (bfd_get_32 (input_bfd, hit_data) & 0x80000000);
	  if (branch_type == ST_BRANCH_TO_THUMB)
	    value |= 1;
	  break;
	}

      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS8:
      value += addend;

      /* There is no way to tell whether the user intended to use a signed or
	 unsigned addend.  When checking for overflow we accept either,
	 as specified by the AAELF.  */
      if ((long) value > 0xff || (long) value < -0x80)
	return bfd_reloc_overflow;

      bfd_put_8 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_ABS16:
      value += addend;

      /* See comment for R_ARM_ABS8.  */
      if ((long) value > 0xffff || (long) value < -0x8000)
	return bfd_reloc_overflow;

      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_THM_ABS5:
      /* Support ldr and str instructions for the thumb.  */
      if (globals->use_rel)
	{
	  /* Need to refetch addend.  */
	  addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	  /* ??? Need to determine shift amount from operand size.  */
	  addend >>= howto->rightshift;
	}
      value += addend;

      /* ??? Isn't value unsigned?  */
      if ((long) value > 0x1f || (long) value < -0x10)
	return bfd_reloc_overflow;

      /* ??? Value needs to be properly shifted into place first.  */
      value |= bfd_get_16 (input_bfd, hit_data) & 0xf83f;
      bfd_put_16 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

    case R_ARM_THM_ALU_PREL_11_0:
      /* Corresponds to: addw.w reg, pc, #offset (and similarly for subw).  */
      {
	bfd_vma insn;
	bfd_signed_vma relocation;

	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
	     | bfd_get_16 (input_bfd, hit_data + 2);

	if (globals->use_rel)
	  {
	    signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
			  | ((insn & (1 << 26)) >> 15);
	    if (insn & 0xf00000)
	      signed_addend = -signed_addend;
	  }

	relocation = value + signed_addend;
	relocation -= Pa (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->r_offset);

	value = abs (relocation);

	if (value >= 0x1000)
	  return bfd_reloc_overflow;

	insn = (insn & 0xfb0f8f00) | (value & 0xff)
	     | ((value & 0x700) << 4)
	     | ((value & 0x800) << 15);
	if (relocation < 0)
	  insn |= 0xa00000;

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);

	return bfd_reloc_ok;
      }

    case R_ARM_THM_PC8:
      /* PR 10073:  This reloc is not generated by the GNU toolchain,
	 but it is supported for compatibility with third party libraries
	 generated by other compilers, specifically the ARM/IAR.  */
      {
	bfd_vma insn;
	bfd_signed_vma relocation;

	insn = bfd_get_16 (input_bfd, hit_data);

	if (globals->use_rel)
	  addend = ((((insn & 0x00ff) << 2) + 4) & 0x3ff) -4;

	relocation = value + addend;
	relocation -= Pa (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->r_offset);

	value = abs (relocation);

	/* We do not check for overflow of this reloc.  Although strictly
	   speaking this is incorrect, it appears to be necessary in order
	   to work with IAR generated relocs.  Since GCC and GAS do not
	   generate R_ARM_THM_PC8 relocs, the lack of a check should not be
	   a problem for them.  */
	value &= 0x3fc;

	insn = (insn & 0xff00) | (value >> 2);

	bfd_put_16 (input_bfd, insn, hit_data);

	return bfd_reloc_ok;
      }

    case R_ARM_THM_PC12:
      /* Corresponds to: ldr.w reg, [pc, #offset].  */
      {
	bfd_vma insn;
	bfd_signed_vma relocation;

	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
	     | bfd_get_16 (input_bfd, hit_data + 2);

	if (globals->use_rel)
	  {
	    signed_addend = insn & 0xfff;
	    if (!(insn & (1 << 23)))
	      signed_addend = -signed_addend;
	  }

	relocation = value + signed_addend;
	relocation -= Pa (input_section->output_section->vma
			  + input_section->output_offset
			  + rel->r_offset);

	value = abs (relocation);

	if (value >= 0x1000)
	  return bfd_reloc_overflow;

	insn = (insn & 0xff7ff000) | value;
	if (relocation >= 0)
	  insn |= (1 << 23);

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);

	return bfd_reloc_ok;
      }

    case R_ARM_THM_XPC22:
    case R_ARM_THM_CALL:
    case R_ARM_THM_JUMP24:
      /* Thumb BL (branch long instruction).  */
      {
	bfd_vma relocation;
	bfd_vma reloc_sign;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max;
	bfd_signed_vma reloc_signed_min;
	bfd_vma check;
	bfd_signed_vma signed_check;
	int bitsize;
	const int thumb2 = using_thumb2 (globals);

	/* A branch to an undefined weak symbol is turned into a jump to
	   the next instruction unless a PLT entry will be created.
	   The jump to the next instruction is optimized as a NOP.W for
	   Thumb-2 enabled architectures.  */
	if (h && h->root.type == bfd_link_hash_undefweak
	    && plt_offset == (bfd_vma) -1)
	  {
	    if (arch_has_thumb2_nop (globals))
	      {
		bfd_put_16 (input_bfd, 0xf3af, hit_data);
		bfd_put_16 (input_bfd, 0x8000, hit_data + 2);
	      }
	    else
	      {
		bfd_put_16 (input_bfd, 0xe000, hit_data);
		bfd_put_16 (input_bfd, 0xbf00, hit_data + 2);
	      }
	    return bfd_reloc_ok;
	  }

	/* Fetch the addend.  We use the Thumb-2 encoding (backwards compatible
	   with Thumb-1) involving the J1 and J2 bits.  */
	if (globals->use_rel)
	  {
	    bfd_vma s = (upper_insn & (1 << 10)) >> 10;
	    bfd_vma upper = upper_insn & 0x3ff;
	    bfd_vma lower = lower_insn & 0x7ff;
	    bfd_vma j1 = (lower_insn & (1 << 13)) >> 13;
	    bfd_vma j2 = (lower_insn & (1 << 11)) >> 11;
	    bfd_vma i1 = j1 ^ s ? 0 : 1;
	    bfd_vma i2 = j2 ^ s ? 0 : 1;

	    addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
	    /* Sign extend.  */
	    addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);

	    signed_addend = addend;
	  }

	if (r_type == R_ARM_THM_XPC22)
	  {
	    /* Check for Thumb to Thumb call.  */
	    /* FIXME: Should we translate the instruction into a BL
	       instruction instead ?  */
	    if (branch_type == ST_BRANCH_TO_THUMB)
	      (*_bfd_error_handler)
		(_("%B: Warning: Thumb BLX instruction targets thumb function '%s'."),
		 input_bfd,
		 h ? h->root.root.string : "(local)");
	  }
	else
	  {
	    /* If it is not a call to Thumb, assume call to Arm.
	       If it is a call relative to a section name, then it is not a
	       function call at all, but rather a long jump.  Calls through
	       the PLT do not require stubs.  */
	    if (branch_type == ST_BRANCH_TO_ARM && plt_offset == (bfd_vma) -1)
	      {
		if (globals->use_blx && r_type == R_ARM_THM_CALL)
		  {
		    /* Convert BL to BLX.  */
		    lower_insn = (lower_insn & ~0x1000) | 0x0800;
		  }
		else if ((   r_type != R_ARM_THM_CALL)
			 && (r_type != R_ARM_THM_JUMP24))
		  {
		    if (elf32_thumb_to_arm_stub
			(info, sym_name, input_bfd, output_bfd, input_section,
			 hit_data, sym_sec, rel->r_offset, signed_addend, value,
			 error_message))
		      return bfd_reloc_ok;
		    else
		      return bfd_reloc_dangerous;
		  }
	      }
	    else if (branch_type == ST_BRANCH_TO_THUMB
		     && globals->use_blx
		     && r_type == R_ARM_THM_CALL)
	      {
		/* Make sure this is a BL.  */
		lower_insn |= 0x1800;
	      }
	  }

	enum elf32_arm_stub_type stub_type = arm_stub_none;
	if (r_type == R_ARM_THM_CALL || r_type == R_ARM_THM_JUMP24)
	  {
	    /* Check if a stub has to be inserted because the destination
	       is too far.  */
	    struct elf32_arm_stub_hash_entry *stub_entry;
	    struct elf32_arm_link_hash_entry *hash;

	    hash = (struct elf32_arm_link_hash_entry *) h;

	    stub_type = arm_type_of_stub (info, input_section, rel,
					  st_type, &branch_type,
					  hash, value, sym_sec,
					  input_bfd, sym_name);

	    if (stub_type != arm_stub_none)
	      {
		/* The target is out of reach or we are changing modes, so
		   redirect the branch to the local stub for this
		   function.  */
		stub_entry = elf32_arm_get_stub_entry (input_section,
						       sym_sec, h,
						       rel, globals,
						       stub_type);
		if (stub_entry != NULL)
		  {
		    value = (stub_entry->stub_offset
			     + stub_entry->stub_sec->output_offset
			     + stub_entry->stub_sec->output_section->vma);

		    if (plt_offset != (bfd_vma) -1)
		      *unresolved_reloc_p = FALSE;
		  }

		/* If this call becomes a call to Arm, force BLX.  */
		if (globals->use_blx && (r_type == R_ARM_THM_CALL))
		  {
		    if ((stub_entry
			 && !arm_stub_is_thumb (stub_entry->stub_type))
			|| branch_type != ST_BRANCH_TO_THUMB)
		      lower_insn = (lower_insn & ~0x1000) | 0x0800;
		  }
	      }
	  }

	/* Handle calls via the PLT.  */
	if (stub_type == arm_stub_none && plt_offset != (bfd_vma) -1)
	  {
	    value = (splt->output_section->vma
		     + splt->output_offset
		     + plt_offset);

	    if (globals->use_blx && r_type == R_ARM_THM_CALL)
	      {
		/* If the Thumb BLX instruction is available, convert
		   the BL to a BLX instruction to call the ARM-mode
		   PLT entry.  */
		lower_insn = (lower_insn & ~0x1000) | 0x0800;
		branch_type = ST_BRANCH_TO_ARM;
	      }
	    else
	      {
		/* Target the Thumb stub before the ARM PLT entry.  */
		value -= PLT_THUMB_STUB_SIZE;
		branch_type = ST_BRANCH_TO_THUMB;
	      }
	    *unresolved_reloc_p = FALSE;
	  }

	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Calculate the permissable maximum and minimum values for
	   this relocation according to whether we're relocating for
	   Thumb-2 or not.  */
	bitsize = howto->bitsize;
	if (!thumb2)
	  bitsize -= 2;
	reloc_signed_max = (1 << (bitsize - 1)) - 1;
	reloc_signed_min = ~reloc_signed_max;

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

	if ((lower_insn & 0x5000) == 0x4000)
	  /* For a BLX instruction, make sure that the relocation is rounded up
	     to a word boundary.  This follows the semantics of the instruction
	     which specifies that bit 1 of the target address will come from bit
	     1 of the base address.  */
	  relocation = (relocation + 2) & ~ 3;

	/* Put RELOCATION back into the insn.  Assumes two's complement.
	   We use the Thumb-2 encoding, which is safe even if dealing with
	   a Thumb-1 instruction by virtue of our overflow check above.  */
	reloc_sign = (signed_check < 0) ? 1 : 0;
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff)
		     | ((relocation >> 12) & 0x3ff)
		     | (reloc_sign << 10);
	lower_insn = (lower_insn & ~(bfd_vma) 0x2fff)
		     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
		     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
		     | ((relocation >> 1) & 0x7ff);

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }
      break;

    case R_ARM_THM_JUMP19:
      /* Thumb32 conditional branch instruction.  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = 0xffffe;
	bfd_signed_vma reloc_signed_min = -0x100000;
	bfd_signed_vma signed_check;

	/* Need to refetch the addend, reconstruct the top three bits,
	   and squish the two 11 bit pieces together.  */
	if (globals->use_rel)
	  {
	    bfd_vma S     = (upper_insn & 0x0400) >> 10;
	    bfd_vma upper = (upper_insn & 0x003f);
	    bfd_vma J1    = (lower_insn & 0x2000) >> 13;
	    bfd_vma J2    = (lower_insn & 0x0800) >> 11;
	    bfd_vma lower = (lower_insn & 0x07ff);

	    upper |= J1 << 6;
	    upper |= J2 << 7;
	    upper |= (!S) << 8;
	    upper -= 0x0100; /* Sign extend.  */

	    addend = (upper << 12) | (lower << 1);
	    signed_addend = addend;
	  }

	/* Handle calls via the PLT.  */
	if (plt_offset != (bfd_vma) -1)
	  {
	    value = (splt->output_section->vma
		     + splt->output_offset
		     + plt_offset);
	    /* Target the Thumb stub before the ARM PLT entry.  */
	    value -= PLT_THUMB_STUB_SIZE;
	    *unresolved_reloc_p = FALSE;
	  }

	/* ??? Should handle interworking?  GCC might someday try to
	   use this for tail calls.  */

	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
	signed_check = (bfd_signed_vma) relocation;

	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

	/* Put RELOCATION back into the insn.  */
	{
	  bfd_vma S  = (relocation & 0x00100000) >> 20;
	  bfd_vma J2 = (relocation & 0x00080000) >> 19;
	  bfd_vma J1 = (relocation & 0x00040000) >> 18;
	  bfd_vma hi = (relocation & 0x0003f000) >> 12;
	  bfd_vma lo = (relocation & 0x00000ffe) >>  1;

	  upper_insn = (upper_insn & 0xfbc0) | (S << 10) | hi;
	  lower_insn = (lower_insn & 0xd000) | (J1 << 13) | (J2 << 11) | lo;
	}

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }

    case R_ARM_THM_JUMP11:
    case R_ARM_THM_JUMP8:
    case R_ARM_THM_JUMP6:
      /* Thumb B (branch) instruction).  */
      {
	bfd_signed_vma relocation;
	bfd_signed_vma reloc_signed_max = (1 << (howto->bitsize - 1)) - 1;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_signed_vma signed_check;

	/* CZB cannot jump backward.  */
	if (r_type == R_ARM_THM_JUMP6)
	  reloc_signed_min = 0;

	if (globals->use_rel)
	  {
	    /* Need to refetch addend.  */
	    addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	    if (addend & ((howto->src_mask + 1) >> 1))
	      {
		signed_addend = -1;
		signed_addend &= ~ howto->src_mask;
		signed_addend |= addend;
	      }
	    else
	      signed_addend = addend;
	    /* The value in the insn has been right shifted.  We need to
	       undo this, so that we can perform the address calculation
	       in terms of bytes.  */
	    signed_addend <<= howto->rightshift;
	  }
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	relocation >>= howto->rightshift;
	signed_check = relocation;

	if (r_type == R_ARM_THM_JUMP6)
	  relocation = ((relocation & 0x0020) << 4) | ((relocation & 0x001f) << 3);
	else
	  relocation &= howto->dst_mask;
	relocation |= (bfd_get_16 (input_bfd, hit_data) & (~ howto->dst_mask));

	bfd_put_16 (input_bfd, relocation, hit_data);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  return bfd_reloc_overflow;

	return bfd_reloc_ok;
      }

    case R_ARM_ALU_PCREL7_0:
    case R_ARM_ALU_PCREL15_8:
    case R_ARM_ALU_PCREL23_15:
      {
	bfd_vma insn;
	bfd_vma relocation;

	insn = bfd_get_32 (input_bfd, hit_data);
	if (globals->use_rel)
	  {
	    /* Extract the addend.  */
	    addend = (insn & 0xff) << ((insn & 0xf00) >> 7);
	    signed_addend = addend;
	  }
	relocation = value + signed_addend;

	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
	insn = (insn & ~0xfff)
	       | ((howto->bitpos << 7) & 0xf00)
	       | ((relocation >> howto->bitpos) & 0xff);
	bfd_put_32 (input_bfd, value, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_GNU_VTINHERIT:
    case R_ARM_GNU_VTENTRY:
      return bfd_reloc_ok;

    case R_ARM_GOTOFF32:
      /* Relocation is relative to the start of the
	 global offset table.  */

      BFD_ASSERT (sgot != NULL);
      if (sgot == NULL)
	return bfd_reloc_notsupported;

      /* If we are addressing a Thumb function, we need to adjust the
	 address by one, so that attempts to call the function pointer will
	 correctly interpret it as Thumb code.  */
      if (branch_type == ST_BRANCH_TO_THUMB)
	value += 1;

      /* Note that sgot->output_offset is not involved in this
	 calculation.  We always want the start of .got.  If we
	 define _GLOBAL_OFFSET_TABLE in a different way, as is
	 permitted by the ABI, we might have to change this
	 calculation.  */
      value -= sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       rel->r_addend);

    case R_ARM_GOTPC:
      /* Use global offset table as symbol value.  */
      BFD_ASSERT (sgot != NULL);

      if (sgot == NULL)
	return bfd_reloc_notsupported;

      *unresolved_reloc_p = FALSE;
      value = sgot->output_section->vma;
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       rel->r_addend);

    case R_ARM_GOT32:
    case R_ARM_GOT_PREL:
      /* Relocation is to the entry for this symbol in the
	 global offset table.  */
      if (sgot == NULL)
	return bfd_reloc_notsupported;

      if (dynreloc_st_type == STT_GNU_IFUNC
	  && plt_offset != (bfd_vma) -1
	  && (h == NULL || SYMBOL_REFERENCES_LOCAL (info, h)))
	{
	  /* We have a relocation against a locally-binding STT_GNU_IFUNC
	     symbol, and the relocation resolves directly to the runtime
	     target rather than to the .iplt entry.  This means that any
	     .got entry would be the same value as the .igot.plt entry,
	     so there's no point creating both.  */
	  sgot = globals->root.igotplt;
	  value = sgot->output_offset + gotplt_offset;
	}
      else if (h != NULL)
	{
	  bfd_vma off;

	  off = h->got.offset;
	  BFD_ASSERT (off != (bfd_vma) -1);
	  if ((off & 1) != 0)
	    {
	      /* We have already processsed one GOT relocation against
		 this symbol.  */
	      off &= ~1;
	      if (globals->root.dynamic_sections_created
		  && !SYMBOL_REFERENCES_LOCAL (info, h))
		*unresolved_reloc_p = FALSE;
	    }
	  else
	    {
	      Elf_Internal_Rela outrel;

	      if (h->dynindx != -1 && !SYMBOL_REFERENCES_LOCAL (info, h))
		{
		  /* If the symbol doesn't resolve locally in a static
		     object, we have an undefined reference.  If the
		     symbol doesn't resolve locally in a dynamic object,
		     it should be resolved by the dynamic linker.  */
		  if (globals->root.dynamic_sections_created)
		    {
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
		      *unresolved_reloc_p = FALSE;
		    }
		  else
		    outrel.r_info = 0;
		  outrel.r_addend = 0;
		}
	      else
		{
		  if (dynreloc_st_type == STT_GNU_IFUNC)
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
		  else if (info->shared &&
			   (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			    || h->root.type != bfd_link_hash_undefweak))
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  else
		    outrel.r_info = 0;
		  outrel.r_addend = dynreloc_value;
		}

	      /* The GOT entry is initialized to zero by default.
		 See if we should install a different value.  */
	      if (outrel.r_addend != 0
		  && (outrel.r_info == 0 || globals->use_rel))
		{
		  bfd_put_32 (output_bfd, outrel.r_addend,
			      sgot->contents + off);
		  outrel.r_addend = 0;
		}

	      if (outrel.r_info != 0)
		{
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + off);
		  elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);
		}
	      h->got.offset |= 1;
	    }
	  value = sgot->output_offset + off;
	}
      else
	{
	  bfd_vma off;

	  BFD_ASSERT (local_got_offsets != NULL &&
		      local_got_offsets[r_symndx] != (bfd_vma) -1);

	  off = local_got_offsets[r_symndx];

	  /* The offset must always be a multiple of 4.  We use the
	     least significant bit to record whether we have already
	     generated the necessary reloc.  */
	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      if (globals->use_rel)
		bfd_put_32 (output_bfd, dynreloc_value, sgot->contents + off);

	      if (info->shared || dynreloc_st_type == STT_GNU_IFUNC)
		{
		  Elf_Internal_Rela outrel;

		  outrel.r_addend = addend + dynreloc_value;
		  outrel.r_offset = (sgot->output_section->vma
				     + sgot->output_offset
				     + off);
		  if (dynreloc_st_type == STT_GNU_IFUNC)
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
		  else
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);
		}

	      local_got_offsets[r_symndx] |= 1;
	    }

	  value = sgot->output_offset + off;
	}
      if (r_type != R_ARM_GOT32)
	value += sgot->output_section->vma;

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       rel->r_addend);

    case R_ARM_TLS_LDO32:
      value = value - dtpoff_base (info);

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       rel->r_addend);

    case R_ARM_TLS_LDM32:
      {
	bfd_vma off;

	if (sgot == NULL)
	  abort ();

	off = globals->tls_ldm_got.offset;

	if ((off & 1) != 0)
	  off &= ~1;
	else
	  {
	    /* If we don't know the module number, create a relocation
	       for it.  */
	    if (info->shared)
	      {
		Elf_Internal_Rela outrel;

		if (srelgot == NULL)
		  abort ();

		outrel.r_addend = 0;
		outrel.r_offset = (sgot->output_section->vma
				   + sgot->output_offset + off);
		outrel.r_info = ELF32_R_INFO (0, R_ARM_TLS_DTPMOD32);

		if (globals->use_rel)
		  bfd_put_32 (output_bfd, outrel.r_addend,
			      sgot->contents + off);

		elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);
	      }
	    else
	      bfd_put_32 (output_bfd, 1, sgot->contents + off);

	    globals->tls_ldm_got.offset |= 1;
	  }

	value = sgot->output_section->vma + sgot->output_offset + off
	  - (input_section->output_section->vma + input_section->output_offset + rel->r_offset);

	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 rel->r_addend);
      }

    case R_ARM_TLS_CALL:
    case R_ARM_THM_TLS_CALL:
    case R_ARM_TLS_GD32:
    case R_ARM_TLS_IE32:
    case R_ARM_TLS_GOTDESC:
    case R_ARM_TLS_DESCSEQ:
    case R_ARM_THM_TLS_DESCSEQ:
      {
	bfd_vma off, offplt;
	int indx = 0;
	char tls_type;

	BFD_ASSERT (sgot != NULL);

	if (h != NULL)
	  {
	    bfd_boolean dyn;
	    dyn = globals->root.dynamic_sections_created;
	    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		&& (!info->shared
		    || !SYMBOL_REFERENCES_LOCAL (info, h)))
	      {
		*unresolved_reloc_p = FALSE;
		indx = h->dynindx;
	      }
	    off = h->got.offset;
	    offplt = elf32_arm_hash_entry (h)->tlsdesc_got;
	    tls_type = ((struct elf32_arm_link_hash_entry *) h)->tls_type;
	  }
	else
	  {
	    BFD_ASSERT (local_got_offsets != NULL);
	    off = local_got_offsets[r_symndx];
	    offplt = local_tlsdesc_gotents[r_symndx];
	    tls_type = elf32_arm_local_got_tls_type (input_bfd)[r_symndx];
	  }

	/* Linker relaxations happens from one of the
	   R_ARM_{GOTDESC,CALL,DESCSEQ} relocations to IE or LE.  */
	if (ELF32_R_TYPE(rel->r_info) != r_type)
	  tls_type = GOT_TLS_IE;

	BFD_ASSERT (tls_type != GOT_UNKNOWN);

	if ((off & 1) != 0)
	  off &= ~1;
	else
	  {
	    bfd_boolean need_relocs = FALSE;
	    Elf_Internal_Rela outrel;
	    int cur_off = off;

	    /* The GOT entries have not been initialized yet.  Do it
	       now, and emit any relocations.  If both an IE GOT and a
	       GD GOT are necessary, we emit the GD first.  */

	    if ((info->shared || indx != 0)
		&& (h == NULL
		    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		    || h->root.type != bfd_link_hash_undefweak))
	      {
		need_relocs = TRUE;
		BFD_ASSERT (srelgot != NULL);
	      }

	    if (tls_type & GOT_TLS_GDESC)
	      {
		bfd_byte *loc;

		/* We should have relaxed, unless this is an undefined
		   weak symbol.  */
		BFD_ASSERT ((h && (h->root.type == bfd_link_hash_undefweak))
			    || info->shared);
		BFD_ASSERT (globals->sgotplt_jump_table_size + offplt + 8
			    <= globals->root.sgotplt->size);

		outrel.r_addend = 0;
		outrel.r_offset = (globals->root.sgotplt->output_section->vma
				   + globals->root.sgotplt->output_offset
				   + offplt
				   + globals->sgotplt_jump_table_size);

		outrel.r_info = ELF32_R_INFO (indx, R_ARM_TLS_DESC);
		sreloc = globals->root.srelplt;
		loc = sreloc->contents;
		loc += globals->next_tls_desc_index++ * RELOC_SIZE (globals);
		BFD_ASSERT (loc + RELOC_SIZE (globals)
			   <= sreloc->contents + sreloc->size);

		SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);

		/* For globals, the first word in the relocation gets
		   the relocation index and the top bit set, or zero,
		   if we're binding now.  For locals, it gets the
		   symbol's offset in the tls section.  */
		bfd_put_32 (output_bfd,
			    !h ? value - elf_hash_table (info)->tls_sec->vma
			    : info->flags & DF_BIND_NOW ? 0
			    : 0x80000000 | ELF32_R_SYM (outrel.r_info),
			    globals->root.sgotplt->contents + offplt
			    + globals->sgotplt_jump_table_size);

		/* Second word in the relocation is always zero.  */
		bfd_put_32 (output_bfd, 0,
			    globals->root.sgotplt->contents + offplt
			    + globals->sgotplt_jump_table_size + 4);
	      }
	    if (tls_type & GOT_TLS_GD)
	      {
		if (need_relocs)
		  {
		    outrel.r_addend = 0;
		    outrel.r_offset = (sgot->output_section->vma
				       + sgot->output_offset
				       + cur_off);
		    outrel.r_info = ELF32_R_INFO (indx, R_ARM_TLS_DTPMOD32);

		    if (globals->use_rel)
		      bfd_put_32 (output_bfd, outrel.r_addend,
				  sgot->contents + cur_off);

		    elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);

		    if (indx == 0)
		      bfd_put_32 (output_bfd, value - dtpoff_base (info),
				  sgot->contents + cur_off + 4);
		    else
		      {
			outrel.r_addend = 0;
			outrel.r_info = ELF32_R_INFO (indx,
						      R_ARM_TLS_DTPOFF32);
			outrel.r_offset += 4;

			if (globals->use_rel)
			  bfd_put_32 (output_bfd, outrel.r_addend,
				      sgot->contents + cur_off + 4);

			elf32_arm_add_dynreloc (output_bfd, info,
						srelgot, &outrel);
		      }
		  }
		else
		  {
		    /* If we are not emitting relocations for a
		       general dynamic reference, then we must be in a
		       static link or an executable link with the
		       symbol binding locally.  Mark it as belonging
		       to module 1, the executable.  */
		    bfd_put_32 (output_bfd, 1,
				sgot->contents + cur_off);
		    bfd_put_32 (output_bfd, value - dtpoff_base (info),
				sgot->contents + cur_off + 4);
		  }

		cur_off += 8;
	      }

	    if (tls_type & GOT_TLS_IE)
	      {
		if (need_relocs)
		  {
		    if (indx == 0)
		      outrel.r_addend = value - dtpoff_base (info);
		    else
		      outrel.r_addend = 0;
		    outrel.r_offset = (sgot->output_section->vma
				       + sgot->output_offset
				       + cur_off);
		    outrel.r_info = ELF32_R_INFO (indx, R_ARM_TLS_TPOFF32);

		    if (globals->use_rel)
		      bfd_put_32 (output_bfd, outrel.r_addend,
				  sgot->contents + cur_off);

		    elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);
		  }
		else
		  bfd_put_32 (output_bfd, tpoff (info, value),
			      sgot->contents + cur_off);
		cur_off += 4;
	      }

	    if (h != NULL)
	      h->got.offset |= 1;
	    else
	      local_got_offsets[r_symndx] |= 1;
	  }

	if ((tls_type & GOT_TLS_GD) && r_type != R_ARM_TLS_GD32)
	  off += 8;
	else if (tls_type & GOT_TLS_GDESC)
	  off = offplt;

	if (ELF32_R_TYPE(rel->r_info) == R_ARM_TLS_CALL
	    || ELF32_R_TYPE(rel->r_info) == R_ARM_THM_TLS_CALL)
	  {
	    bfd_signed_vma offset;
	    /* TLS stubs are arm mode.  The original symbol is a
	       data object, so branch_type is bogus.  */
	    branch_type = ST_BRANCH_TO_ARM;
	    enum elf32_arm_stub_type stub_type
	      = arm_type_of_stub (info, input_section, rel,
				  st_type, &branch_type,
				  (struct elf32_arm_link_hash_entry *)h,
				  globals->tls_trampoline, globals->root.splt,
				  input_bfd, sym_name);

	    if (stub_type != arm_stub_none)
	      {
		struct elf32_arm_stub_hash_entry *stub_entry
		  = elf32_arm_get_stub_entry
		  (input_section, globals->root.splt, 0, rel,
		   globals, stub_type);
		offset = (stub_entry->stub_offset
			  + stub_entry->stub_sec->output_offset
			  + stub_entry->stub_sec->output_section->vma);
	      }
	    else
	      offset = (globals->root.splt->output_section->vma
			+ globals->root.splt->output_offset
			+ globals->tls_trampoline);

	    if (ELF32_R_TYPE(rel->r_info) == R_ARM_TLS_CALL)
	      {
		unsigned long inst;

		offset -= (input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset + 8);

		inst = offset >> 2;
		inst &= 0x00ffffff;
		value = inst | (globals->use_blx ? 0xfa000000 : 0xeb000000);
	      }
	    else
	      {
		/* Thumb blx encodes the offset in a complicated
		   fashion.  */
		unsigned upper_insn, lower_insn;
		unsigned neg;

		offset -= (input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset + 4);

		if (stub_type != arm_stub_none
		    && arm_stub_is_thumb (stub_type))
		  {
		    lower_insn = 0xd000;
		  }
		else
		  {
		    lower_insn = 0xc000;
		    /* Round up the offset to a word boundary */
		    offset = (offset + 2) & ~2;
		  }

		neg = offset < 0;
		upper_insn = (0xf000
			      | ((offset >> 12) & 0x3ff)
			      | (neg << 10));
		lower_insn |= (((!((offset >> 23) & 1)) ^ neg) << 13)
			      | (((!((offset >> 22) & 1)) ^ neg) << 11)
			      | ((offset >> 1) & 0x7ff);
		bfd_put_16 (input_bfd, upper_insn, hit_data);
		bfd_put_16 (input_bfd, lower_insn, hit_data + 2);
		return bfd_reloc_ok;
	      }
	  }
	/* These relocations needs special care, as besides the fact
	   they point somewhere in .gotplt, the addend must be
	   adjusted accordingly depending on the type of instruction
	   we refer to */
	else if ((r_type == R_ARM_TLS_GOTDESC) && (tls_type & GOT_TLS_GDESC))
	  {
	    unsigned long data, insn;
	    unsigned thumb;

	    data = bfd_get_32 (input_bfd, hit_data);
	    thumb = data & 1;
	    data &= ~1u;

	    if (thumb)
	      {
		insn = bfd_get_16 (input_bfd, contents + rel->r_offset - data);
		if ((insn & 0xf000) == 0xf000 || (insn & 0xf800) == 0xe800)
		  insn = (insn << 16)
		    | bfd_get_16 (input_bfd,
				  contents + rel->r_offset - data + 2);
		if ((insn & 0xf800c000) == 0xf000c000)
		  /* bl/blx */
		  value = -6;
		else if ((insn & 0xffffff00) == 0x4400)
		  /* add */
		  value = -5;
		else
		  {
		    (*_bfd_error_handler)
		      (_("%B(%A+0x%lx):unexpected Thumb instruction '0x%x' referenced by TLS_GOTDESC"),
		       input_bfd, input_section,
		       (unsigned long)rel->r_offset, insn);
		    return bfd_reloc_notsupported;
		  }
	      }
	    else
	      {
		insn = bfd_get_32 (input_bfd, contents + rel->r_offset - data);

		switch (insn >> 24)
		  {
		  case 0xeb:  /* bl */
		  case 0xfa:  /* blx */
		    value = -4;
		    break;

		  case 0xe0:	/* add */
		    value = -8;
		    break;

		  default:
		    (*_bfd_error_handler)
		      (_("%B(%A+0x%lx):unexpected ARM instruction '0x%x' referenced by TLS_GOTDESC"),
		       input_bfd, input_section,
		       (unsigned long)rel->r_offset, insn);
		    return bfd_reloc_notsupported;
		  }
	      }

	    value += ((globals->root.sgotplt->output_section->vma
		       + globals->root.sgotplt->output_offset + off)
		      - (input_section->output_section->vma
			 + input_section->output_offset
			 + rel->r_offset)
		      + globals->sgotplt_jump_table_size);
	  }
	else
	  value = ((globals->root.sgot->output_section->vma
		    + globals->root.sgot->output_offset + off)
		   - (input_section->output_section->vma
		      + input_section->output_offset + rel->r_offset));

	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 rel->r_addend);
      }

    case R_ARM_TLS_LE32:
      if (info->shared && !info->pie)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): R_ARM_TLS_LE32 relocation not permitted in shared object"),
	     input_bfd, input_section,
	     (long) rel->r_offset, howto->name);
	  return bfd_reloc_notsupported;
	}
      else
	value = tpoff (info, value);

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value,
				       rel->r_addend);

    case R_ARM_V4BX:
      if (globals->fix_v4bx)
	{
	  bfd_vma insn = bfd_get_32 (input_bfd, hit_data);

	  /* Ensure that we have a BX instruction.  */
	  BFD_ASSERT ((insn & 0x0ffffff0) == 0x012fff10);

	  if (globals->fix_v4bx == 2 && (insn & 0xf) != 0xf)
	    {
	      /* Branch to veneer.  */
	      bfd_vma glue_addr;
	      glue_addr = elf32_arm_bx_glue (info, insn & 0xf);
	      glue_addr -= input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset + 8;
	      insn = (insn & 0xf0000000) | 0x0a000000
		     | ((glue_addr >> 2) & 0x00ffffff);
	    }
	  else
	    {
	      /* Preserve Rm (lowest four bits) and the condition code
		 (highest four bits). Other bits encode MOV PC,Rm.  */
	      insn = (insn & 0xf000000f) | 0x01a0f000;
	    }

	  bfd_put_32 (input_bfd, insn, hit_data);
	}
      return bfd_reloc_ok;

    case R_ARM_MOVW_ABS_NC:
    case R_ARM_MOVT_ABS:
    case R_ARM_MOVW_PREL_NC:
    case R_ARM_MOVT_PREL:
    /* Until we properly support segment-base-relative addressing then
       we assume the segment base to be zero, as for the group relocations.
       Thus R_ARM_MOVW_BREL_NC has the same semantics as R_ARM_MOVW_ABS_NC
       and R_ARM_MOVT_BREL has the same semantics as R_ARM_MOVT_ABS.  */
    case R_ARM_MOVW_BREL_NC:
    case R_ARM_MOVW_BREL:
    case R_ARM_MOVT_BREL:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);

	if (globals->use_rel)
	  {
	    addend = ((insn >> 4) & 0xf000) | (insn & 0xfff);
	    signed_addend = (addend ^ 0x8000) - 0x8000;
	  }

	value += signed_addend;

	if (r_type == R_ARM_MOVW_PREL_NC || r_type == R_ARM_MOVT_PREL)
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);

	if (r_type == R_ARM_MOVW_BREL && value >= 0x10000)
	  return bfd_reloc_overflow;

	if (branch_type == ST_BRANCH_TO_THUMB)
	  value |= 1;

	if (r_type == R_ARM_MOVT_ABS || r_type == R_ARM_MOVT_PREL
	    || r_type == R_ARM_MOVT_BREL)
	  value >>= 16;

	insn &= 0xfff0f000;
	insn |= value & 0xfff;
	insn |= (value & 0xf000) << 4;
	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_THM_MOVW_ABS_NC:
    case R_ARM_THM_MOVT_ABS:
    case R_ARM_THM_MOVW_PREL_NC:
    case R_ARM_THM_MOVT_PREL:
    /* Until we properly support segment-base-relative addressing then
       we assume the segment base to be zero, as for the above relocations.
       Thus R_ARM_THM_MOVW_BREL_NC has the same semantics as
       R_ARM_THM_MOVW_ABS_NC and R_ARM_THM_MOVT_BREL has the same semantics
       as R_ARM_THM_MOVT_ABS.  */
    case R_ARM_THM_MOVW_BREL_NC:
    case R_ARM_THM_MOVW_BREL:
    case R_ARM_THM_MOVT_BREL:
      {
	bfd_vma insn;

	insn = bfd_get_16 (input_bfd, hit_data) << 16;
	insn |= bfd_get_16 (input_bfd, hit_data + 2);

	if (globals->use_rel)
	  {
	    addend = ((insn >> 4)  & 0xf000)
		   | ((insn >> 15) & 0x0800)
		   | ((insn >> 4)  & 0x0700)
		   | (insn         & 0x00ff);
	    signed_addend = (addend ^ 0x8000) - 0x8000;
	  }

	value += signed_addend;

	if (r_type == R_ARM_THM_MOVW_PREL_NC || r_type == R_ARM_THM_MOVT_PREL)
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);

	if (r_type == R_ARM_THM_MOVW_BREL && value >= 0x10000)
	  return bfd_reloc_overflow;

	if (branch_type == ST_BRANCH_TO_THUMB)
	  value |= 1;

	if (r_type == R_ARM_THM_MOVT_ABS || r_type == R_ARM_THM_MOVT_PREL
	    || r_type == R_ARM_THM_MOVT_BREL)
	  value >>= 16;

	insn &= 0xfbf08f00;
	insn |= (value & 0xf000) << 4;
	insn |= (value & 0x0800) << 15;
	insn |= (value & 0x0700) << 4;
	insn |= (value & 0x00ff);

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);
      }
      return bfd_reloc_ok;

    case R_ARM_ALU_PC_G0_NC:
    case R_ARM_ALU_PC_G1_NC:
    case R_ARM_ALU_PC_G0:
    case R_ARM_ALU_PC_G1:
    case R_ARM_ALU_PC_G2:
    case R_ARM_ALU_SB_G0_NC:
    case R_ARM_ALU_SB_G1_NC:
    case R_ARM_ALU_SB_G0:
    case R_ARM_ALU_SB_G1:
    case R_ARM_ALU_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
	bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
	/* sb is the origin of the *segment* containing the symbol.  */
	bfd_vma sb = sym_sec ? sym_sec->output_section->vma : 0;
	bfd_vma residual;
	bfd_vma g_n;
	bfd_signed_vma signed_value;
	int group = 0;

	/* Determine which group of bits to select.  */
	switch (r_type)
	  {
	  case R_ARM_ALU_PC_G0_NC:
	  case R_ARM_ALU_PC_G0:
	  case R_ARM_ALU_SB_G0_NC:
	  case R_ARM_ALU_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_ALU_PC_G1_NC:
	  case R_ARM_ALU_PC_G1:
	  case R_ARM_ALU_SB_G1_NC:
	  case R_ARM_ALU_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_ALU_PC_G2:
	  case R_ARM_ALU_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
	if (globals->use_rel)
	  {
	    int negative;
	    bfd_vma constant = insn & 0xff;
	    bfd_vma rotation = (insn & 0xf00) >> 8;

	    if (rotation == 0)
	      signed_addend = constant;
	    else
	      {
		/* Compensate for the fact that in the instruction, the
		   rotation is stored in multiples of 2 bits.  */
		rotation *= 2;

		/* Rotate "constant" right by "rotation" bits.  */
		signed_addend = (constant >> rotation) |
				(constant << (8 * sizeof (bfd_vma) - rotation));
	      }

	    /* Determine if the instruction is an ADD or a SUB.
	       (For REL, this determines the sign of the addend.)  */
	    negative = identify_add_or_sub (insn);
	    if (negative == 0)
	      {
		(*_bfd_error_handler)
		  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
		  input_bfd, input_section,
		  (long) rel->r_offset, howto->name);
		return bfd_reloc_overflow;
	      }

	    signed_addend *= negative;
	  }

	/* Compute the value (X) to go in the place.  */
	if (r_type == R_ARM_ALU_PC_G0_NC
	    || r_type == R_ARM_ALU_PC_G1_NC
	    || r_type == R_ARM_ALU_PC_G0
	    || r_type == R_ARM_ALU_PC_G1
	    || r_type == R_ARM_ALU_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;

	/* If the target symbol is a Thumb function, then set the
	   Thumb bit in the address.  */
	if (branch_type == ST_BRANCH_TO_THUMB)
	  signed_value |= 1;

	/* Calculate the value of the relevant G_n, in encoded
	   constant-with-rotation format.  */
	g_n = calculate_group_reloc_mask (abs (signed_value), group,
					  &residual);

	/* Check for overflow if required.  */
	if ((r_type == R_ARM_ALU_PC_G0
	     || r_type == R_ARM_ALU_PC_G1
	     || r_type == R_ARM_ALU_PC_G2
	     || r_type == R_ARM_ALU_SB_G0
	     || r_type == R_ARM_ALU_SB_G1
	     || r_type == R_ARM_ALU_SB_G2) && residual != 0)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and the ADD/SUB part of the opcode; take care
	   not to destroy the S bit.  */
	insn &= 0xff1ff000;

	/* Set the opcode according to whether the value to go in the
	   place is negative.  */
	if (signed_value < 0)
	  insn |= 1 << 22;
	else
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= g_n;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDR_PC_G0:
    case R_ARM_LDR_PC_G1:
    case R_ARM_LDR_PC_G2:
    case R_ARM_LDR_SB_G0:
    case R_ARM_LDR_SB_G1:
    case R_ARM_LDR_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
	bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
	/* sb is the origin of the *segment* containing the symbol.  */
	bfd_vma sb = sym_sec ? sym_sec->output_section->vma : 0;
	bfd_vma residual;
	bfd_signed_vma signed_value;
	int group = 0;

	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDR_PC_G0:
	  case R_ARM_LDR_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_LDR_PC_G1:
	  case R_ARM_LDR_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_LDR_PC_G2:
	  case R_ARM_LDR_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
	if (globals->use_rel)
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * (insn & 0xfff);
	  }

	/* Compute the value (X) to go in the place.  */
	if (r_type == R_ARM_LDR_PC_G0
	    || r_type == R_ARM_LDR_PC_G1
	    || r_type == R_ARM_LDR_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;

	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  */
	if (residual >= 0x1000)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7ff000;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= residual;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDRS_PC_G0:
    case R_ARM_LDRS_PC_G1:
    case R_ARM_LDRS_PC_G2:
    case R_ARM_LDRS_SB_G0:
    case R_ARM_LDRS_SB_G1:
    case R_ARM_LDRS_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
	bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
	/* sb is the origin of the *segment* containing the symbol.  */
	bfd_vma sb = sym_sec ? sym_sec->output_section->vma : 0;
	bfd_vma residual;
	bfd_signed_vma signed_value;
	int group = 0;

	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDRS_PC_G0:
	  case R_ARM_LDRS_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_LDRS_PC_G1:
	  case R_ARM_LDRS_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_LDRS_PC_G2:
	  case R_ARM_LDRS_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
	if (globals->use_rel)
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
	  }

	/* Compute the value (X) to go in the place.  */
	if (r_type == R_ARM_LDRS_PC_G0
	    || r_type == R_ARM_LDRS_PC_G1
	    || r_type == R_ARM_LDRS_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;

	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  */
	if (residual >= 0x100)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7ff0f0;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= ((residual & 0xf0) << 4) | (residual & 0xf);

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDC_PC_G0:
    case R_ARM_LDC_PC_G1:
    case R_ARM_LDC_PC_G2:
    case R_ARM_LDC_SB_G0:
    case R_ARM_LDC_SB_G1:
    case R_ARM_LDC_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
	bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
	/* sb is the origin of the *segment* containing the symbol.  */
	bfd_vma sb = sym_sec ? sym_sec->output_section->vma : 0;
	bfd_vma residual;
	bfd_signed_vma signed_value;
	int group = 0;

	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDC_PC_G0:
	  case R_ARM_LDC_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_LDC_PC_G1:
	  case R_ARM_LDC_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_LDC_PC_G2:
	  case R_ARM_LDC_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
	if (globals->use_rel)
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * ((insn & 0xff) << 2);
	  }

	/* Compute the value (X) to go in the place.  */
	if (r_type == R_ARM_LDC_PC_G0
	    || r_type == R_ARM_LDC_PC_G1
	    || r_type == R_ARM_LDC_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;

	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  (The absolute value to go in the place must be
	   divisible by four and, after having been divided by four, must
	   fit in eight bits.)  */
	if ((residual & 0x3) != 0 || residual >= 0x400)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7fff00;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= residual >> 2;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    default:
      return bfd_reloc_notsupported;
    }
}

/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS.  */
static void
arm_add_to_rel (bfd *              abfd,
		bfd_byte *         address,
		reloc_howto_type * howto,
		bfd_signed_vma     increment)
{
  bfd_signed_vma addend;

  if (howto->type == R_ARM_THM_CALL
      || howto->type == R_ARM_THM_JUMP24)
    {
      int upper_insn, lower_insn;
      int upper, lower;

      upper_insn = bfd_get_16 (abfd, address);
      lower_insn = bfd_get_16 (abfd, address + 2);
      upper = upper_insn & 0x7ff;
      lower = lower_insn & 0x7ff;

      addend = (upper << 12) | (lower << 1);
      addend += increment;
      addend >>= 1;

      upper_insn = (upper_insn & 0xf800) | ((addend >> 11) & 0x7ff);
      lower_insn = (lower_insn & 0xf800) | (addend & 0x7ff);

      bfd_put_16 (abfd, (bfd_vma) upper_insn, address);
      bfd_put_16 (abfd, (bfd_vma) lower_insn, address + 2);
    }
  else
    {
      bfd_vma        contents;

      contents = bfd_get_32 (abfd, address);

      /* Get the (signed) value from the instruction.  */
      addend = contents & howto->src_mask;
      if (addend & ((howto->src_mask + 1) >> 1))
	{
	  bfd_signed_vma mask;

	  mask = -1;
	  mask &= ~ howto->src_mask;
	  addend |= mask;
	}

      /* Add in the increment, (which is a byte value).  */
      switch (howto->type)
	{
	default:
	  addend += increment;
	  break;

	case R_ARM_PC24:
	case R_ARM_PLT32:
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	  addend <<= howto->size;
	  addend += increment;

	  /* Should we check for overflow here ?  */

	  /* Drop any undesired bits.  */
	  addend >>= howto->rightshift;
	  break;
	}

      contents = (contents & ~ howto->dst_mask) | (addend & howto->dst_mask);

      bfd_put_32 (abfd, contents, address);
    }
}

#define IS_ARM_TLS_RELOC(R_TYPE)	\
  ((R_TYPE) == R_ARM_TLS_GD32		\
   || (R_TYPE) == R_ARM_TLS_LDO32	\
   || (R_TYPE) == R_ARM_TLS_LDM32	\
   || (R_TYPE) == R_ARM_TLS_DTPOFF32	\
   || (R_TYPE) == R_ARM_TLS_DTPMOD32	\
   || (R_TYPE) == R_ARM_TLS_TPOFF32	\
   || (R_TYPE) == R_ARM_TLS_LE32	\
   || (R_TYPE) == R_ARM_TLS_IE32	\
   || IS_ARM_TLS_GNU_RELOC (R_TYPE))

/* Specific set of relocations for the gnu tls dialect.  */
#define IS_ARM_TLS_GNU_RELOC(R_TYPE)	\
  ((R_TYPE) == R_ARM_TLS_GOTDESC	\
   || (R_TYPE) == R_ARM_TLS_CALL	\
   || (R_TYPE) == R_ARM_THM_TLS_CALL	\
   || (R_TYPE) == R_ARM_TLS_DESCSEQ	\
   || (R_TYPE) == R_ARM_THM_TLS_DESCSEQ)

/* Relocate an ARM ELF section.  */

static bfd_boolean
elf32_arm_relocate_section (bfd *                  output_bfd,
			    struct bfd_link_info * info,
			    bfd *                  input_bfd,
			    asection *             input_section,
			    bfd_byte *             contents,
			    Elf_Internal_Rela *    relocs,
			    Elf_Internal_Sym *     local_syms,
			    asection **            local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const char *name;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return FALSE;

  symtab_hdr = & elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int                          r_type;
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      arelent                      bfd_reloc;
      char                         sym_type;
      bfd_boolean                  unresolved_reloc = FALSE;
      char *error_message = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type   = ELF32_R_TYPE (rel->r_info);
      r_type   = arm_real_reloc_type (globals, r_type);

      if (   r_type == R_ARM_GNU_VTENTRY
	  || r_type == R_ARM_GNU_VTINHERIT)
	continue;

      bfd_reloc.howto = elf32_arm_howto_from_type (r_type);
      howto = bfd_reloc.howto;

      h = NULL;
      sym = NULL;
      sec = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sym_type = ELF32_ST_TYPE (sym->st_info);
	  sec = local_sections[r_symndx];

	  /* An object file might have a reference to a local
	     undefined symbol.  This is a daft object file, but we
	     should at least do something about it.  V4BX & NONE
	     relocations do not use the symbol and are explicitly
	     allowed to use the undefined symbol, so allow those.
	     Likewise for relocations against STN_UNDEF.  */
	  if (r_type != R_ARM_V4BX
	      && r_type != R_ARM_NONE
	      && r_symndx != STN_UNDEF
	      && bfd_is_und_section (sec)
	      && ELF_ST_BIND (sym->st_info) != STB_WEAK)
	    {
	      if (!info->callbacks->undefined_symbol
		  (info, bfd_elf_string_from_elf_section
		   (input_bfd, symtab_hdr->sh_link, sym->st_name),
		   input_bfd, input_section,
		   rel->r_offset, TRUE))
		return FALSE;
	    }

	  if (globals->use_rel)
	    {
	      relocation = (sec->output_section->vma
			    + sec->output_offset
			    + sym->st_value);
	      if (!info->relocatable
		  && (sec->flags & SEC_MERGE)
		  && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  asection *msec;
		  bfd_vma addend, value;

		  switch (r_type)
		    {
		    case R_ARM_MOVW_ABS_NC:
		    case R_ARM_MOVT_ABS:
		      value = bfd_get_32 (input_bfd, contents + rel->r_offset);
		      addend = ((value & 0xf0000) >> 4) | (value & 0xfff);
		      addend = (addend ^ 0x8000) - 0x8000;
		      break;

		    case R_ARM_THM_MOVW_ABS_NC:
		    case R_ARM_THM_MOVT_ABS:
		      value = bfd_get_16 (input_bfd, contents + rel->r_offset)
			      << 16;
		      value |= bfd_get_16 (input_bfd,
					   contents + rel->r_offset + 2);
		      addend = ((value & 0xf7000) >> 4) | (value & 0xff)
			       | ((value & 0x04000000) >> 15);
		      addend = (addend ^ 0x8000) - 0x8000;
		      break;

		    default:
		      if (howto->rightshift
			  || (howto->src_mask & (howto->src_mask + 1)))
			{
			  (*_bfd_error_handler)
			    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
			     input_bfd, input_section,
			     (long) rel->r_offset, howto->name);
			  return FALSE;
			}

		      value = bfd_get_32 (input_bfd, contents + rel->r_offset);

		      /* Get the (signed) value from the instruction.  */
		      addend = value & howto->src_mask;
		      if (addend & ((howto->src_mask + 1) >> 1))
			{
			  bfd_signed_vma mask;

			  mask = -1;
			  mask &= ~ howto->src_mask;
			  addend |= mask;
			}
		      break;
		    }

		  msec = sec;
		  addend =
		    _bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		    - relocation;
		  addend += msec->output_section->vma + msec->output_offset;

		  /* Cases here must match those in the preceding
		     switch statement.  */
		  switch (r_type)
		    {
		    case R_ARM_MOVW_ABS_NC:
		    case R_ARM_MOVT_ABS:
		      value = (value & 0xfff0f000) | ((addend & 0xf000) << 4)
			      | (addend & 0xfff);
		      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
		      break;

		    case R_ARM_THM_MOVW_ABS_NC:
		    case R_ARM_THM_MOVT_ABS:
		      value = (value & 0xfbf08f00) | ((addend & 0xf700) << 4)
			      | (addend & 0xff) | ((addend & 0x0800) << 15);
		      bfd_put_16 (input_bfd, value >> 16,
				  contents + rel->r_offset);
		      bfd_put_16 (input_bfd, value,
				  contents + rel->r_offset + 2);
		      break;

		    default:
		      value = (value & ~ howto->dst_mask)
			      | (addend & howto->dst_mask);
		      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
		      break;
		    }
		}
	    }
	  else
	    relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  sym_type = h->type;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      if (globals->use_rel)
		arm_add_to_rel (input_bfd, contents + rel->r_offset,
				howto, (bfd_signed_vma) sec->output_offset);
	      else
		rel->r_addend += sec->output_offset;
	    }
	  continue;
	}

      if (h != NULL)
	name = h->root.root.string;
      else
	{
	  name = (bfd_elf_string_from_elf_section
		  (input_bfd, symtab_hdr->sh_link, sym->st_name));
	  if (name == NULL || *name == '\0')
	    name = bfd_section_name (input_bfd, sec);
	}

      if (r_symndx != STN_UNDEF
	  && r_type != R_ARM_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && IS_ARM_TLS_RELOC (r_type) != (sym_type == STT_TLS))
	{
	  (*_bfd_error_handler)
	    ((sym_type == STT_TLS
	      ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
	      : _("%B(%A+0x%lx): %s used with non-TLS symbol %s")),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     name);
	}

      /* We call elf32_arm_final_link_relocate unless we're completely
	 done, i.e., the relaxation produced the final output we want,
	 and we won't let anybody mess with it. Also, we have to do
	 addend adjustments in case of a R_ARM_TLS_GOTDESC relocation
	 both in relaxed and non-relaxed cases */
     if ((elf32_arm_tls_transition (info, r_type, h) != (unsigned)r_type)
	 || (IS_ARM_TLS_GNU_RELOC (r_type)
	     && !((h ? elf32_arm_hash_entry (h)->tls_type :
		   elf32_arm_local_got_tls_type (input_bfd)[r_symndx])
		  & GOT_TLS_GDESC)))
       {
	 r = elf32_arm_tls_relax (globals, input_bfd, input_section,
				  contents, rel, h == NULL);
	 /* This may have been marked unresolved because it came from
	    a shared library.  But we've just dealt with that.  */
	 unresolved_reloc = 0;
       }
     else
       r = bfd_reloc_continue;

     if (r == bfd_reloc_continue)
       r = elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
					  input_section, contents, rel,
					  relocation, info, sec, name, sym_type,
					  (h ? h->target_internal
					   : ARM_SYM_BRANCH_TYPE (sym)), h,
					  &unresolved_reloc, &error_message);

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     h->root.root.string);
	  return FALSE;
	}

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      /* If the overflowing reloc was to an undefined symbol,
		 we have already printed one error message and there
		 is no point complaining again.  */
	      if ((! h ||
		   h->root.type != bfd_link_hash_undefined)
		  && (!((*info->callbacks->reloc_overflow)
			(info, (h ? &h->root : NULL), name, howto->name,
			 (bfd_vma) 0, input_bfd, input_section,
			 rel->r_offset))))
		  return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (!((*info->callbacks->undefined_symbol)
		    (info, name, input_bfd, input_section,
		     rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      error_message = _("out of range");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      error_message = _("unsupported relocation");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      /* error_message should already be set.  */
	      goto common_error;

	    default:
	      error_message = _("unknown error");
	      /* Fall through.  */

	    common_error:
	      BFD_ASSERT (error_message != NULL);
	      if (!((*info->callbacks->reloc_dangerous)
		    (info, error_message, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

/* Add a new unwind edit to the list described by HEAD, TAIL.  If TINDEX is zero,
   adds the edit to the start of the list.  (The list must be built in order of
   ascending TINDEX: the function's callers are primarily responsible for
   maintaining that condition).  */

static void
add_unwind_table_edit (arm_unwind_table_edit **head,
		       arm_unwind_table_edit **tail,
		       arm_unwind_edit_type type,
		       asection *linked_section,
		       unsigned int tindex)
{
  arm_unwind_table_edit *new_edit = (arm_unwind_table_edit *)
      xmalloc (sizeof (arm_unwind_table_edit));

  new_edit->type = type;
  new_edit->linked_section = linked_section;
  new_edit->index = tindex;

  if (tindex > 0)
    {
      new_edit->next = NULL;

      if (*tail)
	(*tail)->next = new_edit;

      (*tail) = new_edit;

      if (!*head)
	(*head) = new_edit;
    }
  else
    {
      new_edit->next = *head;

      if (!*tail)
	*tail = new_edit;

      *head = new_edit;
    }
}

static _arm_elf_section_data *get_arm_elf_section_data (asection *);

/* Increase the size of EXIDX_SEC by ADJUST bytes.  ADJUST mau be negative.  */
static void
adjust_exidx_size(asection *exidx_sec, int adjust)
{
  asection *out_sec;

  if (!exidx_sec->rawsize)
    exidx_sec->rawsize = exidx_sec->size;

  bfd_set_section_size (exidx_sec->owner, exidx_sec, exidx_sec->size + adjust);
  out_sec = exidx_sec->output_section;
  /* Adjust size of output section.  */
  bfd_set_section_size (out_sec->owner, out_sec, out_sec->size +adjust);
}

/* Insert an EXIDX_CANTUNWIND marker at the end of a section.  */
static void
insert_cantunwind_after(asection *text_sec, asection *exidx_sec)
{
  struct _arm_elf_section_data *exidx_arm_data;

  exidx_arm_data = get_arm_elf_section_data (exidx_sec);
  add_unwind_table_edit (
    &exidx_arm_data->u.exidx.unwind_edit_list,
    &exidx_arm_data->u.exidx.unwind_edit_tail,
    INSERT_EXIDX_CANTUNWIND_AT_END, text_sec, UINT_MAX);

  adjust_exidx_size(exidx_sec, 8);
}

/* Scan .ARM.exidx tables, and create a list describing edits which should be
   made to those tables, such that:

     1. Regions without unwind data are marked with EXIDX_CANTUNWIND entries.
     2. Duplicate entries are merged together (EXIDX_CANTUNWIND, or unwind
	codes which have been inlined into the index).

   If MERGE_EXIDX_ENTRIES is false, duplicate entries are not merged.

   The edits are applied when the tables are written
   (in elf32_arm_write_section).  */

bfd_boolean
elf32_arm_fix_exidx_coverage (asection **text_section_order,
			      unsigned int num_text_sections,
			      struct bfd_link_info *info,
			      bfd_boolean merge_exidx_entries)
{
  bfd *inp;
  unsigned int last_second_word = 0, i;
  asection *last_exidx_sec = NULL;
  asection *last_text_sec = NULL;
  int last_unwind_type = -1;

  /* Walk over all EXIDX sections, and create backlinks from the corrsponding
     text sections.  */
  for (inp = info->input_bfds; inp != NULL; inp = inp->link_next)
    {
      asection *sec;

      for (sec = inp->sections; sec != NULL; sec = sec->next)
	{
	  struct bfd_elf_section_data *elf_sec = elf_section_data (sec);
	  Elf_Internal_Shdr *hdr = &elf_sec->this_hdr;

	  if (!hdr || hdr->sh_type != SHT_ARM_EXIDX)
	    continue;

	  if (elf_sec->linked_to)
	    {
	      Elf_Internal_Shdr *linked_hdr
		= &elf_section_data (elf_sec->linked_to)->this_hdr;
	      struct _arm_elf_section_data *linked_sec_arm_data
		= get_arm_elf_section_data (linked_hdr->bfd_section);

	      if (linked_sec_arm_data == NULL)
		continue;

	      /* Link this .ARM.exidx section back from the text section it
		 describes.  */
	      linked_sec_arm_data->u.text.arm_exidx_sec = sec;
	    }
	}
    }

  /* Walk all text sections in order of increasing VMA.  Eilminate duplicate
     index table entries (EXIDX_CANTUNWIND and inlined unwind opcodes),
     and add EXIDX_CANTUNWIND entries for sections with no unwind table data.  */

  for (i = 0; i < num_text_sections; i++)
    {
      asection *sec = text_section_order[i];
      asection *exidx_sec;
      struct _arm_elf_section_data *arm_data = get_arm_elf_section_data (sec);
      struct _arm_elf_section_data *exidx_arm_data;
      bfd_byte *contents = NULL;
      int deleted_exidx_bytes = 0;
      bfd_vma j;
      arm_unwind_table_edit *unwind_edit_head = NULL;
      arm_unwind_table_edit *unwind_edit_tail = NULL;
      Elf_Internal_Shdr *hdr;
      bfd *ibfd;

      if (arm_data == NULL)
	continue;

      exidx_sec = arm_data->u.text.arm_exidx_sec;
      if (exidx_sec == NULL)
	{
	  /* Section has no unwind data.  */
	  if (last_unwind_type == 0 || !last_exidx_sec)
	    continue;

	  /* Ignore zero sized sections.  */
	  if (sec->size == 0)
	    continue;

	  insert_cantunwind_after(last_text_sec, last_exidx_sec);
	  last_unwind_type = 0;
	  continue;
	}

      /* Skip /DISCARD/ sections.  */
      if (bfd_is_abs_section (exidx_sec->output_section))
	continue;

      hdr = &elf_section_data (exidx_sec)->this_hdr;
      if (hdr->sh_type != SHT_ARM_EXIDX)
	continue;

      exidx_arm_data = get_arm_elf_section_data (exidx_sec);
      if (exidx_arm_data == NULL)
	continue;

      ibfd = exidx_sec->owner;

      if (hdr->contents != NULL)
	contents = hdr->contents;
      else if (! bfd_malloc_and_get_section (ibfd, exidx_sec, &contents))
	/* An error?  */
	continue;

      for (j = 0; j < hdr->sh_size; j += 8)
	{
	  unsigned int second_word = bfd_get_32 (ibfd, contents + j + 4);
	  int unwind_type;
	  int elide = 0;

	  /* An EXIDX_CANTUNWIND entry.  */
	  if (second_word == 1)
	    {
	      if (last_unwind_type == 0)
		elide = 1;
	      unwind_type = 0;
	    }
	  /* Inlined unwinding data.  Merge if equal to previous.  */
	  else if ((second_word & 0x80000000) != 0)
	    {
	      if (merge_exidx_entries
		   && last_second_word == second_word && last_unwind_type == 1)
		elide = 1;
	      unwind_type = 1;
	      last_second_word = second_word;
	    }
	  /* Normal table entry.  In theory we could merge these too,
	     but duplicate entries are likely to be much less common.  */
	  else
	    unwind_type = 2;

	  if (elide)
	    {
	      add_unwind_table_edit (&unwind_edit_head, &unwind_edit_tail,
				     DELETE_EXIDX_ENTRY, NULL, j / 8);

	      deleted_exidx_bytes += 8;
	    }

	  last_unwind_type = unwind_type;
	}

      /* Free contents if we allocated it ourselves.  */
      if (contents != hdr->contents)
	free (contents);

      /* Record edits to be applied later (in elf32_arm_write_section).  */
      exidx_arm_data->u.exidx.unwind_edit_list = unwind_edit_head;
      exidx_arm_data->u.exidx.unwind_edit_tail = unwind_edit_tail;

      if (deleted_exidx_bytes > 0)
	adjust_exidx_size(exidx_sec, -deleted_exidx_bytes);

      last_exidx_sec = exidx_sec;
      last_text_sec = sec;
    }

  /* Add terminating CANTUNWIND entry.  */
  if (last_exidx_sec && last_unwind_type != 0)
    insert_cantunwind_after(last_text_sec, last_exidx_sec);

  return TRUE;
}

static bfd_boolean
elf32_arm_output_glue_section (struct bfd_link_info *info, bfd *obfd,
			       bfd *ibfd, const char *name)
{
  asection *sec, *osec;

  sec = bfd_get_linker_section (ibfd, name);
  if (sec == NULL || (sec->flags & SEC_EXCLUDE) != 0)
    return TRUE;

  osec = sec->output_section;
  if (elf32_arm_write_section (obfd, info, sec, sec->contents))
    return TRUE;

  if (! bfd_set_section_contents (obfd, osec, sec->contents,
				  sec->output_offset, sec->size))
    return FALSE;

  return TRUE;
}

static bfd_boolean
elf32_arm_final_link (bfd *abfd, struct bfd_link_info *info)
{
  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (info);
  asection *sec, *osec;

  if (globals == NULL)
    return FALSE;

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  /* Process stub sections (eg BE8 encoding, ...).  */
  struct elf32_arm_link_hash_table *htab = elf32_arm_hash_table (info);
  int i;
  for (i=0; i<htab->top_id; i++)
    {
      sec = htab->stub_group[i].stub_sec;
      /* Only process it once, in its link_sec slot.  */
      if (sec && i == htab->stub_group[i].link_sec->id)
	{
	  osec = sec->output_section;
	  elf32_arm_write_section (abfd, info, sec, sec->contents);
	  if (! bfd_set_section_contents (abfd, osec, sec->contents,
					  sec->output_offset, sec->size))
	    return FALSE;
	}
    }

  /* Write out any glue sections now that we have created all the
     stubs.  */
  if (globals->bfd_of_glue_owner != NULL)
    {
      if (! elf32_arm_output_glue_section (info, abfd,
					   globals->bfd_of_glue_owner,
					   ARM2THUMB_GLUE_SECTION_NAME))
	return FALSE;

      if (! elf32_arm_output_glue_section (info, abfd,
					   globals->bfd_of_glue_owner,
					   THUMB2ARM_GLUE_SECTION_NAME))
	return FALSE;

      if (! elf32_arm_output_glue_section (info, abfd,
					   globals->bfd_of_glue_owner,
					   VFP11_ERRATUM_VENEER_SECTION_NAME))
	return FALSE;

      if (! elf32_arm_output_glue_section (info, abfd,
					   globals->bfd_of_glue_owner,
					   ARM_BX_GLUE_SECTION_NAME))
	return FALSE;
    }

  return TRUE;
}

/* Return a best guess for the machine number based on the attributes.  */

static unsigned int
bfd_arm_get_mach_from_attributes (bfd * abfd)
{
  int arch = bfd_elf_get_obj_attr_int (abfd, OBJ_ATTR_PROC, Tag_CPU_arch);

  switch (arch)
    {
    case TAG_CPU_ARCH_V4: return bfd_mach_arm_4;
    case TAG_CPU_ARCH_V4T: return bfd_mach_arm_4T;
    case TAG_CPU_ARCH_V5T: return bfd_mach_arm_5T;

    case TAG_CPU_ARCH_V5TE:
      {
	char * name;

	BFD_ASSERT (Tag_CPU_name < NUM_KNOWN_OBJ_ATTRIBUTES);
	name = elf_known_obj_attributes (abfd) [OBJ_ATTR_PROC][Tag_CPU_name].s;

	if (name)
	  {
	    if (strcmp (name, "IWMMXT2") == 0)
	      return bfd_mach_arm_iWMMXt2;

	    if (strcmp (name, "IWMMXT") == 0)
	      return bfd_mach_arm_iWMMXt;

	    if (strcmp (name, "XSCALE") == 0)
	      {
		int wmmx;

		BFD_ASSERT (Tag_WMMX_arch < NUM_KNOWN_OBJ_ATTRIBUTES);
		wmmx = elf_known_obj_attributes (abfd) [OBJ_ATTR_PROC][Tag_WMMX_arch].i;
		switch (wmmx)
		  {
		  case 1: return bfd_mach_arm_iWMMXt;
		  case 2: return bfd_mach_arm_iWMMXt2;
		  default: return bfd_mach_arm_XScale;
		  }
	      }
	  }

	return bfd_mach_arm_5TE;
      }

    default:
      return bfd_mach_arm_unknown;
    }
}

/* Set the right machine number.  */

static bfd_boolean
elf32_arm_object_p (bfd *abfd)
{
  unsigned int mach;

  mach = bfd_arm_get_mach_from_notes (abfd, ARM_NOTE_SECTION);

  if (mach == bfd_mach_arm_unknown)
    {
      if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
	mach = bfd_mach_arm_ep9312;
      else
	mach = bfd_arm_get_mach_from_attributes (abfd);
    }

  bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);
  return TRUE;
}

/* Function to keep ARM specific flags in the ELF header.  */

static bfd_boolean
elf32_arm_set_private_flags (bfd *abfd, flagword flags)
{
  if (elf_flags_init (abfd)
      && elf_elfheader (abfd)->e_flags != flags)
    {
      if (EF_ARM_EABI_VERSION (flags) == EF_ARM_EABI_UNKNOWN)
	{
	  if (flags & EF_ARM_INTERWORK)
	    (*_bfd_error_handler)
	      (_("Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"),
	       abfd);
	  else
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B due to outside request"),
	       abfd);
	}
    }
  else
    {
      elf_elfheader (abfd)->e_flags = flags;
      elf_flags_init (abfd) = TRUE;
    }

  return TRUE;
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
elf32_arm_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword in_flags;
  flagword out_flags;

  if (! is_arm_elf (ibfd) || ! is_arm_elf (obfd))
    return TRUE;

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (elf_flags_init (obfd)
      && EF_ARM_EABI_VERSION (out_flags) == EF_ARM_EABI_UNKNOWN
      && in_flags != out_flags)
    {
      /* Cannot mix APCS26 and APCS32 code.  */
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	return FALSE;

      /* Cannot mix float APCS and non-float APCS code.  */
      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	return FALSE;

      /* If the src and dest have different interworking flags
	 then turn off the interworking bit.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (out_flags & EF_ARM_INTERWORK)
	    _bfd_error_handler
	      (_("Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"),
	       obfd, ibfd);

	  in_flags &= ~EF_ARM_INTERWORK;
	}

      /* Likewise for PIC, though don't warn for this case.  */
      if ((in_flags & EF_ARM_PIC) != (out_flags & EF_ARM_PIC))
	in_flags &= ~EF_ARM_PIC;
    }

  elf_elfheader (obfd)->e_flags = in_flags;
  elf_flags_init (obfd) = TRUE;

  /* Also copy the EI_OSABI field.  */
  elf_elfheader (obfd)->e_ident[EI_OSABI] =
    elf_elfheader (ibfd)->e_ident[EI_OSABI];

  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  return TRUE;
}

/* Values for Tag_ABI_PCS_R9_use.  */
enum
{
  AEABI_R9_V6,
  AEABI_R9_SB,
  AEABI_R9_TLS,
  AEABI_R9_unused
};

/* Values for Tag_ABI_PCS_RW_data.  */
enum
{
  AEABI_PCS_RW_data_absolute,
  AEABI_PCS_RW_data_PCrel,
  AEABI_PCS_RW_data_SBrel,
  AEABI_PCS_RW_data_unused
};

/* Values for Tag_ABI_enum_size.  */
enum
{
  AEABI_enum_unused,
  AEABI_enum_short,
  AEABI_enum_wide,
  AEABI_enum_forced_wide
};

/* Determine whether an object attribute tag takes an integer, a
   string or both.  */

static int
elf32_arm_obj_attrs_arg_type (int tag)
{
  if (tag == Tag_compatibility)
    return ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL;
  else if (tag == Tag_nodefaults)
    return ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_NO_DEFAULT;
  else if (tag == Tag_CPU_raw_name || tag == Tag_CPU_name)
    return ATTR_TYPE_FLAG_STR_VAL;
  else if (tag < 32)
    return ATTR_TYPE_FLAG_INT_VAL;
  else
    return (tag & 1) != 0 ? ATTR_TYPE_FLAG_STR_VAL : ATTR_TYPE_FLAG_INT_VAL;
}

/* The ABI defines that Tag_conformance should be emitted first, and that
   Tag_nodefaults should be second (if either is defined).  This sets those
   two positions, and bumps up the position of all the remaining tags to
   compensate.  */
static int
elf32_arm_obj_attrs_order (int num)
{
  if (num == LEAST_KNOWN_OBJ_ATTRIBUTE)
    return Tag_conformance;
  if (num == LEAST_KNOWN_OBJ_ATTRIBUTE + 1)
    return Tag_nodefaults;
  if ((num - 2) < Tag_nodefaults)
    return num - 2;
  if ((num - 1) < Tag_conformance)
    return num - 1;
  return num;
}

/* Attribute numbers >=64 (mod 128) can be safely ignored.  */
static bfd_boolean
elf32_arm_obj_attrs_handle_unknown (bfd *abfd, int tag)
{
  if ((tag & 127) < 64)
    {
      _bfd_error_handler
	(_("%B: Unknown mandatory EABI object attribute %d"),
	 abfd, tag);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
  else
    {
      _bfd_error_handler
	(_("Warning: %B: Unknown EABI object attribute %d"),
	 abfd, tag);
      return TRUE;
    }
}

/* Read the architecture from the Tag_also_compatible_with attribute, if any.
   Returns -1 if no architecture could be read.  */

static int
get_secondary_compatible_arch (bfd *abfd)
{
  obj_attribute *attr =
    &elf_known_obj_attributes_proc (abfd)[Tag_also_compatible_with];

  /* Note: the tag and its argument below are uleb128 values, though
     currently-defined values fit in one byte for each.  */
  if (attr->s
      && attr->s[0] == Tag_CPU_arch
      && (attr->s[1] & 128) != 128
      && attr->s[2] == 0)
   return attr->s[1];

  /* This tag is "safely ignorable", so don't complain if it looks funny.  */
  return -1;
}

/* Set, or unset, the architecture of the Tag_also_compatible_with attribute.
   The tag is removed if ARCH is -1.  */

static void
set_secondary_compatible_arch (bfd *abfd, int arch)
{
  obj_attribute *attr =
    &elf_known_obj_attributes_proc (abfd)[Tag_also_compatible_with];

  if (arch == -1)
    {
      attr->s = NULL;
      return;
    }

  /* Note: the tag and its argument below are uleb128 values, though
     currently-defined values fit in one byte for each.  */
  if (!attr->s)
    attr->s = (char *) bfd_alloc (abfd, 3);
  attr->s[0] = Tag_CPU_arch;
  attr->s[1] = arch;
  attr->s[2] = '\0';
}

/* Combine two values for Tag_CPU_arch, taking secondary compatibility tags
   into account.  */

static int
tag_cpu_arch_combine (bfd *ibfd, int oldtag, int *secondary_compat_out,
		      int newtag, int secondary_compat)
{
#define T(X) TAG_CPU_ARCH_##X
  int tagl, tagh, result;
  const int v6t2[] =
    {
      T(V6T2),   /* PRE_V4.  */
      T(V6T2),   /* V4.  */
      T(V6T2),   /* V4T.  */
      T(V6T2),   /* V5T.  */
      T(V6T2),   /* V5TE.  */
      T(V6T2),   /* V5TEJ.  */
      T(V6T2),   /* V6.  */
      T(V7),     /* V6KZ.  */
      T(V6T2)    /* V6T2.  */
    };
  const int v6k[] =
    {
      T(V6K),    /* PRE_V4.  */
      T(V6K),    /* V4.  */
      T(V6K),    /* V4T.  */
      T(V6K),    /* V5T.  */
      T(V6K),    /* V5TE.  */
      T(V6K),    /* V5TEJ.  */
      T(V6K),    /* V6.  */
      T(V6KZ),   /* V6KZ.  */
      T(V7),     /* V6T2.  */
      T(V6K)     /* V6K.  */
    };
  const int v7[] =
    {
      T(V7),     /* PRE_V4.  */
      T(V7),     /* V4.  */
      T(V7),     /* V4T.  */
      T(V7),     /* V5T.  */
      T(V7),     /* V5TE.  */
      T(V7),     /* V5TEJ.  */
      T(V7),     /* V6.  */
      T(V7),     /* V6KZ.  */
      T(V7),     /* V6T2.  */
      T(V7),     /* V6K.  */
      T(V7)      /* V7.  */
    };
  const int v6_m[] =
    {
      -1,        /* PRE_V4.  */
      -1,        /* V4.  */
      T(V6K),    /* V4T.  */
      T(V6K),    /* V5T.  */
      T(V6K),    /* V5TE.  */
      T(V6K),    /* V5TEJ.  */
      T(V6K),    /* V6.  */
      T(V6KZ),   /* V6KZ.  */
      T(V7),     /* V6T2.  */
      T(V6K),    /* V6K.  */
      T(V7),     /* V7.  */
      T(V6_M)    /* V6_M.  */
    };
  const int v6s_m[] =
    {
      -1,        /* PRE_V4.  */
      -1,        /* V4.  */
      T(V6K),    /* V4T.  */
      T(V6K),    /* V5T.  */
      T(V6K),    /* V5TE.  */
      T(V6K),    /* V5TEJ.  */
      T(V6K),    /* V6.  */
      T(V6KZ),   /* V6KZ.  */
      T(V7),     /* V6T2.  */
      T(V6K),    /* V6K.  */
      T(V7),     /* V7.  */
      T(V6S_M),  /* V6_M.  */
      T(V6S_M)   /* V6S_M.  */
    };
  const int v7e_m[] =
    {
      -1,        /* PRE_V4.  */
      -1,        /* V4.  */
      T(V7E_M),  /* V4T.  */
      T(V7E_M),  /* V5T.  */
      T(V7E_M),  /* V5TE.  */
      T(V7E_M),  /* V5TEJ.  */
      T(V7E_M),  /* V6.  */
      T(V7E_M),  /* V6KZ.  */
      T(V7E_M),  /* V6T2.  */
      T(V7E_M),  /* V6K.  */
      T(V7E_M),  /* V7.  */
      T(V7E_M),  /* V6_M.  */
      T(V7E_M),  /* V6S_M.  */
      T(V7E_M)   /* V7E_M.  */
    };
  const int v8[] =
    {
      T(V8),		/* PRE_V4.  */
      T(V8),		/* V4.  */
      T(V8),		/* V4T.  */
      T(V8),		/* V5T.  */
      T(V8),		/* V5TE.  */
      T(V8),		/* V5TEJ.  */
      T(V8),		/* V6.  */
      T(V8),		/* V6KZ.  */
      T(V8),		/* V6T2.  */
      T(V8),		/* V6K.  */
      T(V8),		/* V7.  */
      T(V8),		/* V6_M.  */
      T(V8),		/* V6S_M.  */
      T(V8),		/* V7E_M.  */
      T(V8)		/* V8.  */
    };
  const int v4t_plus_v6_m[] =
    {
      -1,		/* PRE_V4.  */
      -1,		/* V4.  */
      T(V4T),		/* V4T.  */
      T(V5T),		/* V5T.  */
      T(V5TE),		/* V5TE.  */
      T(V5TEJ),		/* V5TEJ.  */
      T(V6),		/* V6.  */
      T(V6KZ),		/* V6KZ.  */
      T(V6T2),		/* V6T2.  */
      T(V6K),		/* V6K.  */
      T(V7),		/* V7.  */
      T(V6_M),		/* V6_M.  */
      T(V6S_M),		/* V6S_M.  */
      T(V7E_M),		/* V7E_M.  */
      T(V8),		/* V8.  */
      T(V4T_PLUS_V6_M)	/* V4T plus V6_M.  */
    };
  const int *comb[] =
    {
      v6t2,
      v6k,
      v7,
      v6_m,
      v6s_m,
      v7e_m,
      v8,
      /* Pseudo-architecture.  */
      v4t_plus_v6_m
    };

  /* Check we've not got a higher architecture than we know about.  */

  if (oldtag > MAX_TAG_CPU_ARCH || newtag > MAX_TAG_CPU_ARCH)
    {
      _bfd_error_handler (_("error: %B: Unknown CPU architecture"), ibfd);
      return -1;
    }

  /* Override old tag if we have a Tag_also_compatible_with on the output.  */

  if ((oldtag == T(V6_M) && *secondary_compat_out == T(V4T))
      || (oldtag == T(V4T) && *secondary_compat_out == T(V6_M)))
    oldtag = T(V4T_PLUS_V6_M);

  /* And override the new tag if we have a Tag_also_compatible_with on the
     input.  */

  if ((newtag == T(V6_M) && secondary_compat == T(V4T))
      || (newtag == T(V4T) && secondary_compat == T(V6_M)))
    newtag = T(V4T_PLUS_V6_M);

  tagl = (oldtag < newtag) ? oldtag : newtag;
  result = tagh = (oldtag > newtag) ? oldtag : newtag;

  /* Architectures before V6KZ add features monotonically.  */
  if (tagh <= TAG_CPU_ARCH_V6KZ)
    return result;

  result = comb[tagh - T(V6T2)][tagl];

  /* Use Tag_CPU_arch == V4T and Tag_also_compatible_with (Tag_CPU_arch V6_M)
     as the canonical version.  */
  if (result == T(V4T_PLUS_V6_M))
    {
      result = T(V4T);
      *secondary_compat_out = T(V6_M);
    }
  else
    *secondary_compat_out = -1;

  if (result == -1)
    {
      _bfd_error_handler (_("error: %B: Conflicting CPU architectures %d/%d"),
			  ibfd, oldtag, newtag);
      return -1;
    }

  return result;
#undef T
}

/* Query attributes object to see if integer divide instructions may be
   present in an object.  */
static bfd_boolean
elf32_arm_attributes_accept_div (const obj_attribute *attr)
{
  int arch = attr[Tag_CPU_arch].i;
  int profile = attr[Tag_CPU_arch_profile].i;

  switch (attr[Tag_DIV_use].i)
    {
    case 0:
      /* Integer divide allowed if instruction contained in archetecture.  */
      if (arch == TAG_CPU_ARCH_V7 && (profile == 'R' || profile == 'M'))
	return TRUE;
      else if (arch >= TAG_CPU_ARCH_V7E_M)
	return TRUE;
      else
	return FALSE;

    case 1:
      /* Integer divide explicitly prohibited.  */
      return FALSE;

    default:
      /* Unrecognised case - treat as allowing divide everywhere.  */
    case 2:
      /* Integer divide allowed in ARM state.  */
      return TRUE;
    }
}

/* Query attributes object to see if integer divide instructions are
   forbidden to be in the object.  This is not the inverse of
   elf32_arm_attributes_accept_div.  */
static bfd_boolean
elf32_arm_attributes_forbid_div (const obj_attribute *attr)
{
  return attr[Tag_DIV_use].i == 1;
}

/* Merge EABI object attributes from IBFD into OBFD.  Raise an error if there
   are conflicting attributes.  */

static bfd_boolean
elf32_arm_merge_eabi_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  /* Some tags have 0 = don't care, 1 = strong requirement,
     2 = weak requirement.  */
  static const int order_021[3] = {0, 2, 1};
  int i;
  bfd_boolean result = TRUE;

  /* Skip the linker stubs file.  This preserves previous behavior
     of accepting unknown attributes in the first input file - but
     is that a bug?  */
  if (ibfd->flags & BFD_LINKER_CREATED)
    return TRUE;

  if (!elf_known_obj_attributes_proc (obfd)[0].i)
    {
      /* This is the first object.  Copy the attributes.  */
      _bfd_elf_copy_obj_attributes (ibfd, obfd);

      out_attr = elf_known_obj_attributes_proc (obfd);

      /* Use the Tag_null value to indicate the attributes have been
	 initialized.  */
      out_attr[0].i = 1;

      /* We do not output objects with Tag_MPextension_use_legacy - we move
	 the attribute's value to Tag_MPextension_use.  */
      if (out_attr[Tag_MPextension_use_legacy].i != 0)
	{
	  if (out_attr[Tag_MPextension_use].i != 0
	      && out_attr[Tag_MPextension_use_legacy].i
		!= out_attr[Tag_MPextension_use].i)
	    {
	      _bfd_error_handler
		(_("Error: %B has both the current and legacy "
		   "Tag_MPextension_use attributes"), ibfd);
	      result = FALSE;
	    }

	  out_attr[Tag_MPextension_use] =
	    out_attr[Tag_MPextension_use_legacy];
	  out_attr[Tag_MPextension_use_legacy].type = 0;
	  out_attr[Tag_MPextension_use_legacy].i = 0;
	}

      return result;
    }

  in_attr = elf_known_obj_attributes_proc (ibfd);
  out_attr = elf_known_obj_attributes_proc (obfd);
  /* This needs to happen before Tag_ABI_FP_number_model is merged.  */
  if (in_attr[Tag_ABI_VFP_args].i != out_attr[Tag_ABI_VFP_args].i)
    {
      /* Ignore mismatches if the object doesn't use floating point.  */
      if (out_attr[Tag_ABI_FP_number_model].i == 0)
	out_attr[Tag_ABI_VFP_args].i = in_attr[Tag_ABI_VFP_args].i;
      else if (in_attr[Tag_ABI_FP_number_model].i != 0)
	{
	  _bfd_error_handler
	    (_("error: %B uses VFP register arguments, %B does not"),
	     in_attr[Tag_ABI_VFP_args].i ? ibfd : obfd,
	     in_attr[Tag_ABI_VFP_args].i ? obfd : ibfd);
	  result = FALSE;
	}
    }

  for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
    {
      /* Merge this attribute with existing attributes.  */
      switch (i)
	{
	case Tag_CPU_raw_name:
	case Tag_CPU_name:
	  /* These are merged after Tag_CPU_arch. */
	  break;

	case Tag_ABI_optimization_goals:
	case Tag_ABI_FP_optimization_goals:
	  /* Use the first value seen.  */
	  break;

	case Tag_CPU_arch:
	  {
	    int secondary_compat = -1, secondary_compat_out = -1;
	    unsigned int saved_out_attr = out_attr[i].i;
	    static const char *name_table[] = {
		/* These aren't real CPU names, but we can't guess
		   that from the architecture version alone.  */
		"Pre v4",
		"ARM v4",
		"ARM v4T",
		"ARM v5T",
		"ARM v5TE",
		"ARM v5TEJ",
		"ARM v6",
		"ARM v6KZ",
		"ARM v6T2",
		"ARM v6K",
		"ARM v7",
		"ARM v6-M",
		"ARM v6S-M",
		"ARM v8"
	    };

	    /* Merge Tag_CPU_arch and Tag_also_compatible_with.  */
	    secondary_compat = get_secondary_compatible_arch (ibfd);
	    secondary_compat_out = get_secondary_compatible_arch (obfd);
	    out_attr[i].i = tag_cpu_arch_combine (ibfd, out_attr[i].i,
						  &secondary_compat_out,
						  in_attr[i].i,
						  secondary_compat);
	    set_secondary_compatible_arch (obfd, secondary_compat_out);

	    /* Merge Tag_CPU_name and Tag_CPU_raw_name.  */
	    if (out_attr[i].i == saved_out_attr)
	      ; /* Leave the names alone.  */
	    else if (out_attr[i].i == in_attr[i].i)
	      {
		/* The output architecture has been changed to match the
		   input architecture.  Use the input names.  */
		out_attr[Tag_CPU_name].s = in_attr[Tag_CPU_name].s
		  ? _bfd_elf_attr_strdup (obfd, in_attr[Tag_CPU_name].s)
		  : NULL;
		out_attr[Tag_CPU_raw_name].s = in_attr[Tag_CPU_raw_name].s
		  ? _bfd_elf_attr_strdup (obfd, in_attr[Tag_CPU_raw_name].s)
		  : NULL;
	      }
	    else
	      {
		out_attr[Tag_CPU_name].s = NULL;
		out_attr[Tag_CPU_raw_name].s = NULL;
	      }

	    /* If we still don't have a value for Tag_CPU_name,
	       make one up now.  Tag_CPU_raw_name remains blank.  */
	    if (out_attr[Tag_CPU_name].s == NULL
		&& out_attr[i].i < ARRAY_SIZE (name_table))
	      out_attr[Tag_CPU_name].s =
		_bfd_elf_attr_strdup (obfd, name_table[out_attr[i].i]);
	  }
	  break;

	case Tag_ARM_ISA_use:
	case Tag_THUMB_ISA_use:
	case Tag_WMMX_arch:
	case Tag_Advanced_SIMD_arch:
	  /* ??? Do Advanced_SIMD (NEON) and WMMX conflict?  */
	case Tag_ABI_FP_rounding:
	case Tag_ABI_FP_exceptions:
	case Tag_ABI_FP_user_exceptions:
	case Tag_ABI_FP_number_model:
	case Tag_FP_HP_extension:
	case Tag_CPU_unaligned_access:
	case Tag_T2EE_use:
	case Tag_MPextension_use:
	  /* Use the largest value specified.  */
	  if (in_attr[i].i > out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
	  break;

	case Tag_ABI_align_preserved:
	case Tag_ABI_PCS_RO_data:
	  /* Use the smallest value specified.  */
	  if (in_attr[i].i < out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
	  break;

	case Tag_ABI_align_needed:
	  if ((in_attr[i].i > 0 || out_attr[i].i > 0)
	      && (in_attr[Tag_ABI_align_preserved].i == 0
		  || out_attr[Tag_ABI_align_preserved].i == 0))
	    {
	      /* This error message should be enabled once all non-conformant
		 binaries in the toolchain have had the attributes set
		 properly.
	      _bfd_error_handler
		(_("error: %B: 8-byte data alignment conflicts with %B"),
		 obfd, ibfd);
	      result = FALSE; */
	    }
	  /* Fall through.  */
	case Tag_ABI_FP_denormal:
	case Tag_ABI_PCS_GOT_use:
	  /* Use the "greatest" from the sequence 0, 2, 1, or the largest
	     value if greater than 2 (for future-proofing).  */
	  if ((in_attr[i].i > 2 && in_attr[i].i > out_attr[i].i)
	      || (in_attr[i].i <= 2 && out_attr[i].i <= 2
		  && order_021[in_attr[i].i] > order_021[out_attr[i].i]))
	    out_attr[i].i = in_attr[i].i;
	  break;

	case Tag_Virtualization_use:
	  /* The virtualization tag effectively stores two bits of
	     information: the intended use of TrustZone (in bit 0), and the
	     intended use of Virtualization (in bit 1).  */
	  if (out_attr[i].i == 0)
	    out_attr[i].i = in_attr[i].i;
	  else if (in_attr[i].i != 0
		   && in_attr[i].i != out_attr[i].i)
	    {
	      if (in_attr[i].i <= 3 && out_attr[i].i <= 3)
		out_attr[i].i = 3;
	      else
		{
		  _bfd_error_handler
		    (_("error: %B: unable to merge virtualization attributes "
		       "with %B"),
		     obfd, ibfd);
		  result = FALSE;
		}
	    }
	  break;

	case Tag_CPU_arch_profile:
	  if (out_attr[i].i != in_attr[i].i)
	    {
	      /* 0 will merge with anything.
		 'A' and 'S' merge to 'A'.
		 'R' and 'S' merge to 'R'.
		 'M' and 'A|R|S' is an error.  */
	      if (out_attr[i].i == 0
		  || (out_attr[i].i == 'S'
		      && (in_attr[i].i == 'A' || in_attr[i].i == 'R')))
		out_attr[i].i = in_attr[i].i;
	      else if (in_attr[i].i == 0
		       || (in_attr[i].i == 'S'
			   && (out_attr[i].i == 'A' || out_attr[i].i == 'R')))
		; /* Do nothing. */
	      else
		{
		  _bfd_error_handler
		    (_("error: %B: Conflicting architecture profiles %c/%c"),
		     ibfd,
		     in_attr[i].i ? in_attr[i].i : '0',
		     out_attr[i].i ? out_attr[i].i : '0');
		  result = FALSE;
		}
	    }
	  break;
	case Tag_FP_arch:
	    {
	      /* Tag_ABI_HardFP_use is handled along with Tag_FP_arch since
		 the meaning of Tag_ABI_HardFP_use depends on Tag_FP_arch
		 when it's 0.  It might mean absence of FP hardware if
		 Tag_FP_arch is zero, otherwise it is effectively SP + DP.  */

#define VFP_VERSION_COUNT 8
	      static const struct
	      {
		  int ver;
		  int regs;
	      } vfp_versions[VFP_VERSION_COUNT] =
		{
		  {0, 0},
		  {1, 16},
		  {2, 16},
		  {3, 32},
		  {3, 16},
		  {4, 32},
		  {4, 16},
		  {8, 32}
		};
	      int ver;
	      int regs;
	      int newval;

	      /* If the output has no requirement about FP hardware,
		 follow the requirement of the input.  */
	      if (out_attr[i].i == 0)
		{
		  BFD_ASSERT (out_attr[Tag_ABI_HardFP_use].i == 0);
		  out_attr[i].i = in_attr[i].i;
		  out_attr[Tag_ABI_HardFP_use].i
		    = in_attr[Tag_ABI_HardFP_use].i;
		  break;
		}
	      /* If the input has no requirement about FP hardware, do
		 nothing.  */
	      else if (in_attr[i].i == 0)
		{
		  BFD_ASSERT (in_attr[Tag_ABI_HardFP_use].i == 0);
		  break;
		}

	      /* Both the input and the output have nonzero Tag_FP_arch.
		 So Tag_ABI_HardFP_use is (SP & DP) when it's zero.  */

	      /* If both the input and the output have zero Tag_ABI_HardFP_use,
		 do nothing.  */
	      if (in_attr[Tag_ABI_HardFP_use].i == 0
		  && out_attr[Tag_ABI_HardFP_use].i == 0)
		;
	      /* If the input and the output have different Tag_ABI_HardFP_use,
		 the combination of them is 3 (SP & DP).  */
	      else if (in_attr[Tag_ABI_HardFP_use].i
		       != out_attr[Tag_ABI_HardFP_use].i)
		out_attr[Tag_ABI_HardFP_use].i = 3;

	      /* Now we can handle Tag_FP_arch.  */

	      /* Values of VFP_VERSION_COUNT or more aren't defined, so just
		 pick the biggest.  */
	      if (in_attr[i].i >= VFP_VERSION_COUNT
		  && in_attr[i].i > out_attr[i].i)
		{
		  out_attr[i] = in_attr[i];
		  break;
		}
	      /* The output uses the superset of input features
		 (ISA version) and registers.  */
	      ver = vfp_versions[in_attr[i].i].ver;
	      if (ver < vfp_versions[out_attr[i].i].ver)
		ver = vfp_versions[out_attr[i].i].ver;
	      regs = vfp_versions[in_attr[i].i].regs;
	      if (regs < vfp_versions[out_attr[i].i].regs)
		regs = vfp_versions[out_attr[i].i].regs;
	      /* This assumes all possible supersets are also a valid
		 options.  */
	      for (newval = VFP_VERSION_COUNT - 1; newval > 0; newval--)
		{
		  if (regs == vfp_versions[newval].regs
		      && ver == vfp_versions[newval].ver)
		    break;
		}
	      out_attr[i].i = newval;
	    }
	  break;
	case Tag_PCS_config:
	  if (out_attr[i].i == 0)
	    out_attr[i].i = in_attr[i].i;
	  else if (in_attr[i].i != 0 && out_attr[i].i != in_attr[i].i)
	    {
	      /* It's sometimes ok to mix different configs, so this is only
		 a warning.  */
	      _bfd_error_handler
		(_("Warning: %B: Conflicting platform configuration"), ibfd);
	    }
	  break;
	case Tag_ABI_PCS_R9_use:
	  if (in_attr[i].i != out_attr[i].i
	      && out_attr[i].i != AEABI_R9_unused
	      && in_attr[i].i != AEABI_R9_unused)
	    {
	      _bfd_error_handler
		(_("error: %B: Conflicting use of R9"), ibfd);
	      result = FALSE;
	    }
	  if (out_attr[i].i == AEABI_R9_unused)
	    out_attr[i].i = in_attr[i].i;
	  break;
	case Tag_ABI_PCS_RW_data:
	  if (in_attr[i].i == AEABI_PCS_RW_data_SBrel
	      && out_attr[Tag_ABI_PCS_R9_use].i != AEABI_R9_SB
	      && out_attr[Tag_ABI_PCS_R9_use].i != AEABI_R9_unused)
	    {
	      _bfd_error_handler
		(_("error: %B: SB relative addressing conflicts with use of R9"),
		 ibfd);
	      result = FALSE;
	    }
	  /* Use the smallest value specified.  */
	  if (in_attr[i].i < out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
	  break;
	case Tag_ABI_PCS_wchar_t:
	  if (out_attr[i].i && in_attr[i].i && out_attr[i].i != in_attr[i].i
	      && !elf_arm_tdata (obfd)->no_wchar_size_warning)
	    {
	      _bfd_error_handler
		(_("warning: %B uses %u-byte wchar_t yet the output is to use %u-byte wchar_t; use of wchar_t values across objects may fail"),
		 ibfd, in_attr[i].i, out_attr[i].i);
	    }
	  else if (in_attr[i].i && !out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
	  break;
	case Tag_ABI_enum_size:
	  if (in_attr[i].i != AEABI_enum_unused)
	    {
	      if (out_attr[i].i == AEABI_enum_unused
		  || out_attr[i].i == AEABI_enum_forced_wide)
		{
		  /* The existing object is compatible with anything.
		     Use whatever requirements the new object has.  */
		  out_attr[i].i = in_attr[i].i;
		}
	      else if (in_attr[i].i != AEABI_enum_forced_wide
		       && out_attr[i].i != in_attr[i].i
		       && !elf_arm_tdata (obfd)->no_enum_size_warning)
		{
		  static const char *aeabi_enum_names[] =
		    { "", "variable-size", "32-bit", "" };
		  const char *in_name =
		    in_attr[i].i < ARRAY_SIZE(aeabi_enum_names)
		    ? aeabi_enum_names[in_attr[i].i]
		    : "<unknown>";
		  const char *out_name =
		    out_attr[i].i < ARRAY_SIZE(aeabi_enum_names)
		    ? aeabi_enum_names[out_attr[i].i]
		    : "<unknown>";
		  _bfd_error_handler
		    (_("warning: %B uses %s enums yet the output is to use %s enums; use of enum values across objects may fail"),
		     ibfd, in_name, out_name);
		}
	    }
	  break;
	case Tag_ABI_VFP_args:
	  /* Aready done.  */
	  break;
	case Tag_ABI_WMMX_args:
	  if (in_attr[i].i != out_attr[i].i)
	    {
	      _bfd_error_handler
		(_("error: %B uses iWMMXt register arguments, %B does not"),
		 ibfd, obfd);
	      result = FALSE;
	    }
	  break;
	case Tag_compatibility:
	  /* Merged in target-independent code.  */
	  break;
	case Tag_ABI_HardFP_use:
	  /* This is handled along with Tag_FP_arch.  */
	  break;
	case Tag_ABI_FP_16bit_format:
	  if (in_attr[i].i != 0 && out_attr[i].i != 0)
	    {
	      if (in_attr[i].i != out_attr[i].i)
		{
		  _bfd_error_handler
		    (_("error: fp16 format mismatch between %B and %B"),
		     ibfd, obfd);
		  result = FALSE;
		}
	    }
	  if (in_attr[i].i != 0)
	    out_attr[i].i = in_attr[i].i;
	  break;

	case Tag_DIV_use:
	  /* A value of zero on input means that the divide instruction may
	     be used if available in the base architecture as specified via
	     Tag_CPU_arch and Tag_CPU_arch_profile.  A value of 1 means that
	     the user did not want divide instructions.  A value of 2
	     explicitly means that divide instructions were allowed in ARM
	     and Thumb state.  */
	  if (in_attr[i].i == out_attr[i].i)
	    /* Do nothing.  */ ;
	  else if (elf32_arm_attributes_forbid_div (in_attr)
		   && !elf32_arm_attributes_accept_div (out_attr))
	    out_attr[i].i = 1;
	  else if (elf32_arm_attributes_forbid_div (out_attr)
		   && elf32_arm_attributes_accept_div (in_attr))
	    out_attr[i].i = in_attr[i].i;
	  else if (in_attr[i].i == 2)
	    out_attr[i].i = in_attr[i].i;
	  break;

	case Tag_MPextension_use_legacy:
	  /* We don't output objects with Tag_MPextension_use_legacy - we
	     move the value to Tag_MPextension_use.  */
	  if (in_attr[i].i != 0 && in_attr[Tag_MPextension_use].i != 0)
	    {
	      if (in_attr[Tag_MPextension_use].i != in_attr[i].i)
		{
		  _bfd_error_handler
		    (_("%B has has both the current and legacy "
		       "Tag_MPextension_use attributes"),
		     ibfd);
		  result = FALSE;
		}
	    }

	  if (in_attr[i].i > out_attr[Tag_MPextension_use].i)
	    out_attr[Tag_MPextension_use] = in_attr[i];

	  break;

	case Tag_nodefaults:
	  /* This tag is set if it exists, but the value is unused (and is
	     typically zero).  We don't actually need to do anything here -
	     the merge happens automatically when the type flags are merged
	     below.  */
	  break;
	case Tag_also_compatible_with:
	  /* Already done in Tag_CPU_arch.  */
	  break;
	case Tag_conformance:
	  /* Keep the attribute if it matches.  Throw it away otherwise.
	     No attribute means no claim to conform.  */
	  if (!in_attr[i].s || !out_attr[i].s
	      || strcmp (in_attr[i].s, out_attr[i].s) != 0)
	    out_attr[i].s = NULL;
	  break;

	default:
	  result
	    = result && _bfd_elf_merge_unknown_attribute_low (ibfd, obfd, i);
	}

      /* If out_attr was copied from in_attr then it won't have a type yet.  */
      if (in_attr[i].type && !out_attr[i].type)
	out_attr[i].type = in_attr[i].type;
    }

  /* Merge Tag_compatibility attributes and any common GNU ones.  */
  if (!_bfd_elf_merge_object_attributes (ibfd, obfd))
    return FALSE;

  /* Check for any attributes not known on ARM.  */
  result &= _bfd_elf_merge_unknown_attribute_list (ibfd, obfd);

  return result;
}


/* Return TRUE if the two EABI versions are incompatible.  */

static bfd_boolean
elf32_arm_versions_compatible (unsigned iver, unsigned over)
{
  /* v4 and v5 are the same spec before and after it was released,
     so allow mixing them.  */
  if ((iver == EF_ARM_EABI_VER4 && over == EF_ARM_EABI_VER5)
      || (iver == EF_ARM_EABI_VER5 && over == EF_ARM_EABI_VER4))
    return TRUE;

  return (iver == over);
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd);

/* Display the flags field.  */

static bfd_boolean
elf32_arm_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE * file = (FILE *) ptr;
  unsigned long flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;
  /* Ignore init flag - it may not be set, despite the flags field
     containing valid data.  */

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  switch (EF_ARM_EABI_VERSION (flags))
    {
    case EF_ARM_EABI_UNKNOWN:
      /* The following flag bits are GNU extensions and not part of the
	 official ARM ELF extended ABI.  Hence they are only decoded if
	 the EABI version is not set.  */
      if (flags & EF_ARM_INTERWORK)
	fprintf (file, _(" [interworking enabled]"));

      if (flags & EF_ARM_APCS_26)
	fprintf (file, " [APCS-26]");
      else
	fprintf (file, " [APCS-32]");

      if (flags & EF_ARM_VFP_FLOAT)
	fprintf (file, _(" [VFP float format]"));
      else if (flags & EF_ARM_MAVERICK_FLOAT)
	fprintf (file, _(" [Maverick float format]"));
      else
	fprintf (file, _(" [FPA float format]"));

      if (flags & EF_ARM_APCS_FLOAT)
	fprintf (file, _(" [floats passed in float registers]"));

      if (flags & EF_ARM_PIC)
	fprintf (file, _(" [position independent]"));

      if (flags & EF_ARM_NEW_ABI)
	fprintf (file, _(" [new ABI]"));

      if (flags & EF_ARM_OLD_ABI)
	fprintf (file, _(" [old ABI]"));

      if (flags & EF_ARM_SOFT_FLOAT)
	fprintf (file, _(" [software FP]"));

      flags &= ~(EF_ARM_INTERWORK | EF_ARM_APCS_26 | EF_ARM_APCS_FLOAT
		 | EF_ARM_PIC | EF_ARM_NEW_ABI | EF_ARM_OLD_ABI
		 | EF_ARM_SOFT_FLOAT | EF_ARM_VFP_FLOAT
		 | EF_ARM_MAVERICK_FLOAT);
      break;

    case EF_ARM_EABI_VER1:
      fprintf (file, _(" [Version1 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      flags &= ~ EF_ARM_SYMSARESORTED;
      break;

    case EF_ARM_EABI_VER2:
      fprintf (file, _(" [Version2 EABI]"));

      if (flags & EF_ARM_SYMSARESORTED)
	fprintf (file, _(" [sorted symbol table]"));
      else
	fprintf (file, _(" [unsorted symbol table]"));

      if (flags & EF_ARM_DYNSYMSUSESEGIDX)
	fprintf (file, _(" [dynamic symbols use segment index]"));

      if (flags & EF_ARM_MAPSYMSFIRST)
	fprintf (file, _(" [mapping symbols precede others]"));

      flags &= ~(EF_ARM_SYMSARESORTED | EF_ARM_DYNSYMSUSESEGIDX
		 | EF_ARM_MAPSYMSFIRST);
      break;

    case EF_ARM_EABI_VER3:
      fprintf (file, _(" [Version3 EABI]"));
      break;

    case EF_ARM_EABI_VER4:
      fprintf (file, _(" [Version4 EABI]"));
      goto eabi;

    case EF_ARM_EABI_VER5:
      fprintf (file, _(" [Version5 EABI]"));

      if (flags & EF_ARM_ABI_FLOAT_SOFT)
	fprintf (file, _(" [soft-float ABI]"));

      if (flags & EF_ARM_ABI_FLOAT_HARD)
	fprintf (file, _(" [hard-float ABI]"));

      flags &= ~(EF_ARM_ABI_FLOAT_SOFT | EF_ARM_ABI_FLOAT_HARD);

    eabi:
      if (flags & EF_ARM_BE8)
	fprintf (file, _(" [BE8]"));

      if (flags & EF_ARM_LE8)
	fprintf (file, _(" [LE8]"));

      flags &= ~(EF_ARM_LE8 | EF_ARM_BE8);
      break;

    default:
      fprintf (file, _(" <EABI version unrecognised>"));
      break;
    }

  flags &= ~ EF_ARM_EABIMASK;

  if (flags & EF_ARM_RELEXEC)
    fprintf (file, _(" [relocatable executable]"));

  if (flags & EF_ARM_HASENTRY)
    fprintf (file, _(" [has entry point]"));

  flags &= ~ (EF_ARM_RELEXEC | EF_ARM_HASENTRY);

  if (flags)
    fprintf (file, _("<Unrecognised flag bits set>"));

  fputc ('\n', file);

  return TRUE;
}

static int
elf32_arm_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
{
  switch (ELF_ST_TYPE (elf_sym->st_info))
    {
    case STT_ARM_TFUNC:
      return ELF_ST_TYPE (elf_sym->st_info);

    case STT_ARM_16BIT:
      /* If the symbol is not an object, return the STT_ARM_16BIT flag.
	 This allows us to distinguish between data used by Thumb instructions
	 and non-data (which is probably code) inside Thumb regions of an
	 executable.  */
      if (type != STT_OBJECT && type != STT_TLS)
	return ELF_ST_TYPE (elf_sym->st_info);
      break;

    default:
      break;
    }

  return type;
}

static asection *
elf32_arm_gc_mark_hook (asection *sec,
			struct bfd_link_info *info,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_ARM_GNU_VTINHERIT:
      case R_ARM_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf32_arm_gc_sweep_hook (bfd *                     abfd,
			 struct bfd_link_info *    info,
			 asection *                sec,
			 const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  struct elf32_arm_link_hash_table * globals;

  if (info->relocatable)
    return TRUE;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return FALSE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = & elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  check_use_blx (globals);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h = NULL;
      struct elf32_arm_link_hash_entry *eh;
      int r_type;
      bfd_boolean call_reloc_p;
      bfd_boolean may_become_dynamic_p;
      bfd_boolean may_need_local_target_p;
      union gotplt_union *root_plt;
      struct arm_plt_info *arm_plt;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
      eh = (struct elf32_arm_link_hash_entry *) h;

      call_reloc_p = FALSE;
      may_become_dynamic_p = FALSE;
      may_need_local_target_p = FALSE;

      r_type = ELF32_R_TYPE (rel->r_info);
      r_type = arm_real_reloc_type (globals, r_type);
      switch (r_type)
	{
	case R_ARM_GOT32:
	case R_ARM_GOT_PREL:
	case R_ARM_TLS_GD32:
	case R_ARM_TLS_IE32:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_ARM_TLS_LDM32:
	  globals->tls_ldm_got.refcount -= 1;
	  break;

	case R_ARM_PC24:
	case R_ARM_PLT32:
	case R_ARM_CALL:
	case R_ARM_JUMP24:
	case R_ARM_PREL31:
	case R_ARM_THM_CALL:
	case R_ARM_THM_JUMP24:
	case R_ARM_THM_JUMP19:
	  call_reloc_p = TRUE;
	  may_need_local_target_p = TRUE;
	  break;

	case R_ARM_ABS12:
	  if (!globals->vxworks_p)
	    {
	      may_need_local_target_p = TRUE;
	      break;
	    }
	  /* Fall through.  */
	case R_ARM_ABS32:
	case R_ARM_ABS32_NOI:
	case R_ARM_REL32:
	case R_ARM_REL32_NOI:
	case R_ARM_MOVW_ABS_NC:
	case R_ARM_MOVT_ABS:
	case R_ARM_MOVW_PREL_NC:
	case R_ARM_MOVT_PREL:
	case R_ARM_THM_MOVW_ABS_NC:
	case R_ARM_THM_MOVT_ABS:
	case R_ARM_THM_MOVW_PREL_NC:
	case R_ARM_THM_MOVT_PREL:
	  /* Should the interworking branches be here also?  */
	  if ((info->shared || globals->root.is_relocatable_executable)
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      if (h == NULL
		  && (r_type == R_ARM_REL32 || r_type == R_ARM_REL32_NOI))
		{
		  call_reloc_p = TRUE;
		  may_need_local_target_p = TRUE;
		}
	      else
		may_become_dynamic_p = TRUE;
	    }
	  else
	    may_need_local_target_p = TRUE;
	  break;

	default:
	  break;
	}

      if (may_need_local_target_p
	  && elf32_arm_get_plt_info (abfd, eh, r_symndx, &root_plt, &arm_plt))
	{
	  /* If PLT refcount book-keeping is wrong and too low, we'll
	     see a zero value (going to -1) for the root PLT reference
	     count.  */
	  if (root_plt->refcount >= 0)
	    {
	      BFD_ASSERT (root_plt->refcount != 0);
	      root_plt->refcount -= 1;
	    }
	  else
	    /* A value of -1 means the symbol has become local, forced
	       or seeing a hidden definition.  Any other negative value
	       is an error.  */
	    BFD_ASSERT (root_plt->refcount == -1);

	  if (!call_reloc_p)
	    arm_plt->noncall_refcount--;

	  if (r_type == R_ARM_THM_CALL)
	    arm_plt->maybe_thumb_refcount--;

	  if (r_type == R_ARM_THM_JUMP24
	      || r_type == R_ARM_THM_JUMP19)
	    arm_plt->thumb_refcount--;
	}

      if (may_become_dynamic_p)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  if (h != NULL)
	    pp = &(eh->dyn_relocs);
	  else
	    {
	      Elf_Internal_Sym *isym;

	      isym = bfd_sym_from_r_symndx (&globals->sym_cache,
					    abfd, r_symndx);
	      if (isym == NULL)
		return FALSE;
	      pp = elf32_arm_get_local_dynreloc_list (abfd, r_symndx, isym);
	      if (pp == NULL)
		return FALSE;
	    }
	  for (; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
    }

  return TRUE;
}

/* Look through the relocs for a section during the first phase.  */

static bfd_boolean
elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  asection *sreloc;
  struct elf32_arm_link_hash_table *htab;
  bfd_boolean call_reloc_p;
  bfd_boolean may_become_dynamic_p;
  bfd_boolean may_need_local_target_p;
  unsigned long nsyms;

  if (info->relocatable)
    return TRUE;

  BFD_ASSERT (is_arm_elf (abfd));

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  sreloc = NULL;

  /* Create dynamic sections for relocatable executables so that we can
     copy relocations.  */
  if (htab->root.is_relocatable_executable
      && ! htab->root.dynamic_sections_created)
    {
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	return FALSE;
    }

  if (htab->root.dynobj == NULL)
    htab->root.dynobj = abfd;
  if (!create_ifunc_sections (info))
    return FALSE;

  dynobj = htab->root.dynobj;

  symtab_hdr = & elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  nsyms = NUM_SHDR_ENTRIES (symtab_hdr);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      Elf_Internal_Sym *isym;
      struct elf_link_hash_entry *h;
      struct elf32_arm_link_hash_entry *eh;
      unsigned long r_symndx;
      int r_type;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);
      r_type = arm_real_reloc_type (htab, r_type);

      if (r_symndx >= nsyms
	  /* PR 9934: It is possible to have relocations that do not
	     refer to symbols, thus it is also possible to have an
	     object file containing relocations but no symbol table.  */
	  && (r_symndx > STN_UNDEF || nsyms > 0))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"), abfd,
				   r_symndx);
	  return FALSE;
	}

      h = NULL;
      isym = NULL;
      if (nsyms > 0)
	{
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      /* A local symbol.  */
	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					    abfd, r_symndx);
	      if (isym == NULL)
		return FALSE;
	    }
	  else
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;

	      /* PR15323, ref flags aren't set for references in the
		 same object.  */
	      h->root.non_ir_ref = 1;
	    }
	}

      eh = (struct elf32_arm_link_hash_entry *) h;

      call_reloc_p = FALSE;
      may_become_dynamic_p = FALSE;
      may_need_local_target_p = FALSE;

      /* Could be done earlier, if h were already available.  */
      r_type = elf32_arm_tls_transition (info, r_type, h);
      switch (r_type)
	{
	  case R_ARM_GOT32:
	  case R_ARM_GOT_PREL:
	  case R_ARM_TLS_GD32:
	  case R_ARM_TLS_IE32:
	  case R_ARM_TLS_GOTDESC:
	  case R_ARM_TLS_DESCSEQ:
	  case R_ARM_THM_TLS_DESCSEQ:
	  case R_ARM_TLS_CALL:
	  case R_ARM_THM_TLS_CALL:
	    /* This symbol requires a global offset table entry.  */
	    {
	      int tls_type, old_tls_type;

	      switch (r_type)
		{
		case R_ARM_TLS_GD32: tls_type = GOT_TLS_GD; break;

		case R_ARM_TLS_IE32: tls_type = GOT_TLS_IE; break;

		case R_ARM_TLS_GOTDESC:
		case R_ARM_TLS_CALL: case R_ARM_THM_TLS_CALL:
		case R_ARM_TLS_DESCSEQ: case R_ARM_THM_TLS_DESCSEQ:
		  tls_type = GOT_TLS_GDESC; break;

		default: tls_type = GOT_NORMAL; break;
		}

	      if (h != NULL)
		{
		  h->got.refcount++;
		  old_tls_type = elf32_arm_hash_entry (h)->tls_type;
		}
	      else
		{
		  /* This is a global offset table entry for a local symbol.  */
		  if (!elf32_arm_allocate_local_sym_info (abfd))
		    return FALSE;
		  elf_local_got_refcounts (abfd)[r_symndx] += 1;
		  old_tls_type = elf32_arm_local_got_tls_type (abfd) [r_symndx];
		}

	      /* If a variable is accessed with both tls methods, two
		 slots may be created.  */
	      if (GOT_TLS_GD_ANY_P (old_tls_type)
		  && GOT_TLS_GD_ANY_P (tls_type))
		tls_type |= old_tls_type;

	      /* We will already have issued an error message if there
		 is a TLS/non-TLS mismatch, based on the symbol
		 type.  So just combine any TLS types needed.  */
	      if (old_tls_type != GOT_UNKNOWN && old_tls_type != GOT_NORMAL
		  && tls_type != GOT_NORMAL)
		tls_type |= old_tls_type;

	      /* If the symbol is accessed in both IE and GDESC
		 method, we're able to relax. Turn off the GDESC flag,
		 without messing up with any other kind of tls types
		 that may be involved */
	      if ((tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_GDESC))
		tls_type &= ~GOT_TLS_GDESC;

	      if (old_tls_type != tls_type)
		{
		  if (h != NULL)
		    elf32_arm_hash_entry (h)->tls_type = tls_type;
		  else
		    elf32_arm_local_got_tls_type (abfd) [r_symndx] = tls_type;
		}
	    }
	    /* Fall through.  */

	  case R_ARM_TLS_LDM32:
	    if (r_type == R_ARM_TLS_LDM32)
		htab->tls_ldm_got.refcount++;
	    /* Fall through.  */

	  case R_ARM_GOTOFF32:
	  case R_ARM_GOTPC:
	    if (htab->root.sgot == NULL
		&& !create_got_section (htab->root.dynobj, info))
	      return FALSE;
	    break;

	  case R_ARM_PC24:
	  case R_ARM_PLT32:
	  case R_ARM_CALL:
	  case R_ARM_JUMP24:
	  case R_ARM_PREL31:
	  case R_ARM_THM_CALL:
	  case R_ARM_THM_JUMP24:
	  case R_ARM_THM_JUMP19:
	    call_reloc_p = TRUE;
	    may_need_local_target_p = TRUE;
	    break;

	  case R_ARM_ABS12:
	    /* VxWorks uses dynamic R_ARM_ABS12 relocations for
	       ldr __GOTT_INDEX__ offsets.  */
	    if (!htab->vxworks_p)
	      {
		may_need_local_target_p = TRUE;
		break;
	      }
	    /* Fall through.  */

	  case R_ARM_MOVW_ABS_NC:
	  case R_ARM_MOVT_ABS:
	  case R_ARM_THM_MOVW_ABS_NC:
	  case R_ARM_THM_MOVT_ABS:
	    if (info->shared)
	      {
		(*_bfd_error_handler)
		  (_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		   abfd, elf32_arm_howto_table_1[r_type].name,
		   (h) ? h->root.root.string : "a local symbol");
		bfd_set_error (bfd_error_bad_value);
		return FALSE;
	      }

	    /* Fall through.  */
	  case R_ARM_ABS32:
	  case R_ARM_ABS32_NOI:
	  case R_ARM_REL32:
	  case R_ARM_REL32_NOI:
	  case R_ARM_MOVW_PREL_NC:
	  case R_ARM_MOVT_PREL:
	  case R_ARM_THM_MOVW_PREL_NC:
	  case R_ARM_THM_MOVT_PREL:

	    /* Should the interworking branches be listed here?  */
	    if ((info->shared || htab->root.is_relocatable_executable)
		&& (sec->flags & SEC_ALLOC) != 0)
	      {
		if (h == NULL
		    && (r_type == R_ARM_REL32 || r_type == R_ARM_REL32_NOI))
		  {
		    /* In shared libraries and relocatable executables,
		       we treat local relative references as calls;
		       see the related SYMBOL_CALLS_LOCAL code in
		       allocate_dynrelocs.  */
		    call_reloc_p = TRUE;
		    may_need_local_target_p = TRUE;
		  }
		else
		  /* We are creating a shared library or relocatable
		     executable, and this is a reloc against a global symbol,
		     or a non-PC-relative reloc against a local symbol.
		     We may need to copy the reloc into the output.  */
		  may_become_dynamic_p = TRUE;
	      }
	    else
	      may_need_local_target_p = TRUE;
	    break;

	/* This relocation describes the C++ object vtable hierarchy.
	   Reconstruct it for later use during GC.  */
	case R_ARM_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	/* This relocation describes which C++ vtable entries are actually
	   used.  Record for later use during GC.  */
	case R_ARM_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
	}

      if (h != NULL)
	{
	  if (call_reloc_p)
	    /* We may need a .plt entry if the function this reloc
	       refers to is in a different object, regardless of the
	       symbol's type.  We can't tell for sure yet, because
	       something later might force the symbol local.  */
	    h->needs_plt = 1;
	  else if (may_need_local_target_p)
	    /* If this reloc is in a read-only section, we might
	       need a copy reloc.  We can't check reliably at this
	       stage whether the section is read-only, as input
	       sections have not yet been mapped to output sections.
	       Tentatively set the flag for now, and correct in
	       adjust_dynamic_symbol.  */
	    h->non_got_ref = 1;
	}

      if (may_need_local_target_p
	  && (h != NULL || ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC))
	{
	  union gotplt_union *root_plt;
	  struct arm_plt_info *arm_plt;
	  struct arm_local_iplt_info *local_iplt;

	  if (h != NULL)
	    {
	      root_plt = &h->plt;
	      arm_plt = &eh->plt;
	    }
	  else
	    {
	      local_iplt = elf32_arm_create_local_iplt (abfd, r_symndx);
	      if (local_iplt == NULL)
		return FALSE;
	      root_plt = &local_iplt->root;
	      arm_plt = &local_iplt->arm;
	    }

	  /* If the symbol is a function that doesn't bind locally,
	     this relocation will need a PLT entry.  */
	  if (root_plt->refcount != -1)
	    root_plt->refcount += 1;

	  if (!call_reloc_p)
	    arm_plt->noncall_refcount++;

	  /* It's too early to use htab->use_blx here, so we have to
	     record possible blx references separately from
	     relocs that definitely need a thumb stub.  */

	  if (r_type == R_ARM_THM_CALL)
	    arm_plt->maybe_thumb_refcount += 1;

	  if (r_type == R_ARM_THM_JUMP24
	      || r_type == R_ARM_THM_JUMP19)
	    arm_plt->thumb_refcount += 1;
	}

      if (may_become_dynamic_p)
	{
	  struct elf_dyn_relocs *p, **head;

	  /* Create a reloc section in dynobj.  */
	  if (sreloc == NULL)
	    {
	      sreloc = _bfd_elf_make_dynamic_reloc_section
		(sec, dynobj, 2, abfd, ! htab->use_rel);

	      if (sreloc == NULL)
		return FALSE;

	      /* BPABI objects never have dynamic relocations mapped.  */
	      if (htab->symbian_p)
		{
		  flagword flags;

		  flags = bfd_get_section_flags (dynobj, sreloc);
		  flags &= ~(SEC_LOAD | SEC_ALLOC);
		  bfd_set_section_flags (dynobj, sreloc, flags);
		}
	    }

	  /* If this is a global symbol, count the number of
	     relocations we need for this symbol.  */
	  if (h != NULL)
	    head = &((struct elf32_arm_link_hash_entry *) h)->dyn_relocs;
	  else
	    {
	      head = elf32_arm_get_local_dynreloc_list (abfd, r_symndx, isym);
	      if (head == NULL)
		return FALSE;
	    }

	  p = *head;
	  if (p == NULL || p->sec != sec)
	    {
	      bfd_size_type amt = sizeof *p;

	      p = (struct elf_dyn_relocs *) bfd_alloc (htab->root.dynobj, amt);
	      if (p == NULL)
		return FALSE;
	      p->next = *head;
	      *head = p;
	      p->sec = sec;
	      p->count = 0;
	      p->pc_count = 0;
	    }

	  if (r_type == R_ARM_REL32 || r_type == R_ARM_REL32_NOI)
	    p->pc_count += 1;
	  p->count += 1;
	}
    }

  return TRUE;
}

/* Unwinding tables are not referenced directly.  This pass marks them as
   required if the corresponding code section is marked.  */

static bfd_boolean
elf32_arm_gc_mark_extra_sections (struct bfd_link_info *info,
				  elf_gc_mark_hook_fn gc_mark_hook)
{
  bfd *sub;
  Elf_Internal_Shdr **elf_shdrp;
  bfd_boolean again;

  _bfd_elf_gc_mark_extra_sections (info, gc_mark_hook);

  /* Marking EH data may cause additional code sections to be marked,
     requiring multiple passes.  */
  again = TRUE;
  while (again)
    {
      again = FALSE;
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	{
	  asection *o;

	  if (! is_arm_elf (sub))
	    continue;

	  elf_shdrp = elf_elfsections (sub);
	  for (o = sub->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Shdr *hdr;

	      hdr = &elf_section_data (o)->this_hdr;
	      if (hdr->sh_type == SHT_ARM_EXIDX
		  && hdr->sh_link
		  && hdr->sh_link < elf_numsections (sub)
		  && !o->gc_mark
		  && elf_shdrp[hdr->sh_link]->bfd_section->gc_mark)
		{
		  again = TRUE;
		  if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
		    return FALSE;
		}
	    }
	}
    }

  return TRUE;
}

/* Treat mapping symbols as special target symbols.  */

static bfd_boolean
elf32_arm_is_target_special_symbol (bfd * abfd ATTRIBUTE_UNUSED, asymbol * sym)
{
  return bfd_is_arm_special_symbol_name (sym->name,
					 BFD_ARM_SPECIAL_SYM_TYPE_ANY);
}

/* This is a copy of elf_find_function() from elf.c except that
   ARM mapping symbols are ignored when looking for function names
   and STT_ARM_TFUNC is considered to a function type.  */

static bfd_boolean
arm_elf_find_function (bfd *         abfd ATTRIBUTE_UNUSED,
		       asection *    section,
		       asymbol **    symbols,
		       bfd_vma       offset,
		       const char ** filename_ptr,
		       const char ** functionname_ptr)
{
  const char * filename = NULL;
  asymbol * func = NULL;
  bfd_vma low_func = 0;
  asymbol ** p;

  for (p = symbols; *p != NULL; p++)
    {
      elf_symbol_type *q;

      q = (elf_symbol_type *) *p;

      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))
	{
	default:
	  break;
	case STT_FILE:
	  filename = bfd_asymbol_name (&q->symbol);
	  break;
	case STT_FUNC:
	case STT_ARM_TFUNC:
	case STT_NOTYPE:
	  /* Skip mapping symbols.  */
	  if ((q->symbol.flags & BSF_LOCAL)
	      && bfd_is_arm_special_symbol_name (q->symbol.name,
		    BFD_ARM_SPECIAL_SYM_TYPE_ANY))
	    continue;
	  /* Fall through.  */
	  if (bfd_get_section (&q->symbol) == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
	    {
	      func = (asymbol *) q;
	      low_func = q->symbol.value;
	    }
	  break;
	}
    }

  if (func == NULL)
    return FALSE;

  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return TRUE;
}


/* Find the nearest line to a particular section and offset, for error
   reporting.   This code is a duplicate of the code in elf.c, except
   that it uses arm_elf_find_function.  */

static bfd_boolean
elf32_arm_find_nearest_line (bfd *          abfd,
			     asection *     section,
			     asymbol **     symbols,
			     bfd_vma        offset,
			     const char **  filename_ptr,
			     const char **  functionname_ptr,
			     unsigned int * line_ptr)
{
  bfd_boolean found = FALSE;

  /* We skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain uses it.  */

  if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
				     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, NULL, 0,
				     & elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	arm_elf_find_function (abfd, section, symbols, offset,
			       *filename_ptr ? NULL : filename_ptr,
			       functionname_ptr);

      return TRUE;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     & found, filename_ptr,
					     functionname_ptr, line_ptr,
					     & elf_tdata (abfd)->line_info))
    return FALSE;

  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  if (! arm_elf_find_function (abfd, section, symbols, offset,
			       filename_ptr, functionname_ptr))
    return FALSE;

  *line_ptr = 0;
  return TRUE;
}

static bfd_boolean
elf32_arm_find_inliner_info (bfd *          abfd,
			     const char **  filename_ptr,
			     const char **  functionname_ptr,
			     unsigned int * line_ptr)
{
  bfd_boolean found;
  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
					 functionname_ptr, line_ptr,
					 & elf_tdata (abfd)->dwarf2_find_line_info);
  return found;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf32_arm_adjust_dynamic_symbol (struct bfd_link_info * info,
				 struct elf_link_hash_entry * h)
{
  bfd * dynobj;
  asection * s;
  struct elf32_arm_link_hash_entry * eh;
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->type == STT_GNU_IFUNC
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  eh = (struct elf32_arm_link_hash_entry *) h;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC || h->type == STT_GNU_IFUNC || h->needs_plt)
    {
      /* Calls to STT_GNU_IFUNC symbols always use a PLT, even if the
	 symbol binds locally.  */
      if (h->plt.refcount <= 0
	  || (h->type != STT_GNU_IFUNC
	      && (SYMBOL_CALLS_LOCAL (info, h)
		  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		      && h->root.type == bfd_link_hash_undefweak))))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC24 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  eh->plt.thumb_refcount = 0;
	  eh->plt.maybe_thumb_refcount = 0;
	  eh->plt.noncall_refcount = 0;
	  h->needs_plt = 0;
	}

      return TRUE;
    }
  else
    {
      /* It's possible that we incorrectly decided a .plt reloc was
	 needed for an R_ARM_PC24 or similar reloc to a non-function sym
	 in check_relocs.  We can't decide accurately between function
	 and non-function syms in check-relocs; Objects loaded later in
	 the link may change h->type.  So fix it now.  */
      h->plt.offset = (bfd_vma) -1;
      eh->plt.thumb_refcount = 0;
      eh->plt.maybe_thumb_refcount = 0;
      eh->plt.noncall_refcount = 0;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* If there are no non-GOT references, we do not need a copy
     relocation.  */
  if (!h->non_got_ref)
    return TRUE;

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  Relocatable executables
     can reference data in shared objects directly, so we don't need to
     do anything here.  */
  if (info->shared || globals->root.is_relocatable_executable)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */
  s = bfd_get_linker_section (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_ARM_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel(a).bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = bfd_get_linker_section (dynobj, RELOC_SECTION (globals, ".bss"));
      elf32_arm_allocate_dynrelocs (info, srel, 1);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  eh = (struct elf32_arm_link_hash_entry *) h;

  info = (struct bfd_link_info *) inf;
  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if ((htab->root.dynamic_sections_created || h->type == STT_GNU_IFUNC)
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      /* If the call in the PLT entry binds locally, the associated
	 GOT entry should use an R_ARM_IRELATIVE relocation instead of
	 the usual R_ARM_JUMP_SLOT.  Put it in the .iplt section rather
	 than the .plt section.  */
      if (h->type == STT_GNU_IFUNC && SYMBOL_CALLS_LOCAL (info, h))
	{
	  eh->is_iplt = 1;
	  if (eh->plt.noncall_refcount == 0
	      && SYMBOL_REFERENCES_LOCAL (info, h))
	    /* All non-call references can be resolved directly.
	       This means that they can (and in some cases, must)
	       resolve directly to the run-time target, rather than
	       to the PLT.  That in turns means that any .got entry
	       would be equal to the .igot.plt entry, so there's
	       no point having both.  */
	    h->got.refcount = 0;
	}

      if (info->shared
	  || eh->is_iplt
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  elf32_arm_allocate_plt_entry (info, eh->is_iplt, &h->plt, &eh->plt);

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = htab->root.splt;
	      h->root.u.def.value = h->plt.offset;

	      /* Make sure the function is not marked as Thumb, in case
		 it is the target of an ABS32 relocation, which will
		 point to the PLT entry.  */
	      h->target_internal = ST_BRANCH_TO_ARM;
	    }

	  htab->next_tls_desc_index++;

	  /* VxWorks executables have a second set of relocations for
	     each PLT entry.  They go in a separate relocation section,
	     which is processed by the kernel loader.  */
	  if (htab->vxworks_p && !info->shared)
	    {
	      /* There is a relocation for the initial PLT entry:
		 an R_ARM_32 relocation for _GLOBAL_OFFSET_TABLE_.  */
	      if (h->plt.offset == htab->plt_header_size)
		elf32_arm_allocate_dynrelocs (info, htab->srelplt2, 1);

	      /* There are two extra relocations for each subsequent
		 PLT entry: an R_ARM_32 relocation for the GOT entry,
		 and an R_ARM_32 relocation for the PLT entry.  */
	      elf32_arm_allocate_dynrelocs (info, htab->srelplt2, 2);
	    }
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  eh = (struct elf32_arm_link_hash_entry *) h;
  eh->tlsdesc_got = (bfd_vma) -1;

  if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
      int tls_type = elf32_arm_hash_entry (h)->tls_type;
      int indx;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (!htab->symbian_p)
	{
	  s = htab->root.sgot;
	  h->got.offset = s->size;

	  if (tls_type == GOT_UNKNOWN)
	    abort ();

	  if (tls_type == GOT_NORMAL)
	    /* Non-TLS symbols need one GOT slot.  */
	    s->size += 4;
	  else
	    {
	      if (tls_type & GOT_TLS_GDESC)
		{
		  /* R_ARM_TLS_DESC needs 2 GOT slots.  */
		  eh->tlsdesc_got
		    = (htab->root.sgotplt->size
		       - elf32_arm_compute_jump_table_size (htab));
		  htab->root.sgotplt->size += 8;
		  h->got.offset = (bfd_vma) -2;
		  /* plt.got_offset needs to know there's a TLS_DESC
		     reloc in the middle of .got.plt.  */
		  htab->num_tls_desc++;
		}

	      if (tls_type & GOT_TLS_GD)
		{
		  /* R_ARM_TLS_GD32 needs 2 consecutive GOT slots.  If
		     the symbol is both GD and GDESC, got.offset may
		     have been overwritten.  */
		  h->got.offset = s->size;
		  s->size += 8;
		}

	      if (tls_type & GOT_TLS_IE)
		/* R_ARM_TLS_IE32 needs one GOT slot.  */
		s->size += 4;
	    }

	  dyn = htab->root.dynamic_sections_created;

	  indx = 0;
	  if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      && (!info->shared
		  || !SYMBOL_REFERENCES_LOCAL (info, h)))
	    indx = h->dynindx;

	  if (tls_type != GOT_NORMAL
	      && (info->shared || indx != 0)
	      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak))
	    {
	      if (tls_type & GOT_TLS_IE)
		elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);

	      if (tls_type & GOT_TLS_GD)
		elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);

	      if (tls_type & GOT_TLS_GDESC)
		{
		  elf32_arm_allocate_dynrelocs (info, htab->root.srelplt, 1);
		  /* GDESC needs a trampoline to jump to.  */
		  htab->tls_trampoline = -1;
		}

	      /* Only GD needs it.  GDESC just emits one relocation per
		 2 entries.  */
	      if ((tls_type & GOT_TLS_GD) && indx != 0)
		elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);
	    }
	  else if (indx != -1 && !SYMBOL_REFERENCES_LOCAL (info, h))
	    {
	      if (htab->root.dynamic_sections_created)
		/* Reserve room for the GOT entry's R_ARM_GLOB_DAT relocation.  */
		elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);
	    }
	  else if (h->type == STT_GNU_IFUNC
		   && eh->plt.noncall_refcount == 0)
	    /* No non-call references resolve the STT_GNU_IFUNC's PLT entry;
	       they all resolve dynamically instead.  Reserve room for the
	       GOT entry's R_ARM_IRELATIVE relocation.  */
	    elf32_arm_allocate_irelocs (info, htab->root.srelgot, 1);
	  else if (info->shared && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
				    || h->root.type != bfd_link_hash_undefweak))
	    /* Reserve room for the GOT entry's R_ARM_RELATIVE relocation.  */
	    elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);
	}
    }
  else
    h->got.offset = (bfd_vma) -1;

  /* Allocate stubs for exported Thumb functions on v4t.  */
  if (!htab->use_blx && h->dynindx != -1
      && h->def_regular
      && h->target_internal == ST_BRANCH_TO_THUMB
      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
    {
      struct elf_link_hash_entry * th;
      struct bfd_link_hash_entry * bh;
      struct elf_link_hash_entry * myh;
      char name[1024];
      asection *s;
      bh = NULL;
      /* Create a new symbol to regist the real location of the function.  */
      s = h->root.u.def.section;
      sprintf (name, "__real_%s", h->root.root.string);
      _bfd_generic_link_add_one_symbol (info, s->owner,
					name, BSF_GLOBAL, s,
					h->root.u.def.value,
					NULL, TRUE, FALSE, &bh);

      myh = (struct elf_link_hash_entry *) bh;
      myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
      myh->forced_local = 1;
      myh->target_internal = ST_BRANCH_TO_THUMB;
      eh->export_glue = myh;
      th = record_arm_to_thumb_glue (info, h);
      /* Point the symbol at the stub.  */
      h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);
      h->target_internal = ST_BRANCH_TO_ARM;
      h->root.u.def.section = th->root.u.def.section;
      h->root.u.def.value = th->root.u.def.value & ~1;
    }

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared || htab->root.is_relocatable_executable)
    {
      /* The only relocs that use pc_count are R_ARM_REL32 and
	 R_ARM_REL32_NOI, which will appear on something like
	 ".long foo - .".  We want calls to protected symbols to resolve
	 directly to the function rather than going via the plt.  If people
	 want function pointer comparisons to work as expected then they
	 should avoid writing assembly like ".long foo - .".  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      if (htab->vxworks_p)
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      if (strcmp (p->sec->output_section->name, ".tls_vars") == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}

      else if (htab->root.is_relocatable_executable && h->dynindx == -1
	       && h->root.type == bfd_link_hash_new)
	{
	  /* Output absolute symbols so that we can create relocations
	     against them.  For normal symbols we output a relocation
	     against the section that contains them.  */
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->root.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      if (h->type == STT_GNU_IFUNC
	  && eh->plt.noncall_refcount == 0
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	elf32_arm_allocate_irelocs (info, sreloc, p->count);
      else
	elf32_arm_allocate_dynrelocs (info, sreloc, p->count);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
elf32_arm_readonly_dynrelocs (struct elf_link_hash_entry * h, void * inf)
{
  struct elf32_arm_link_hash_entry * eh;
  struct elf_dyn_relocs * p;

  eh = (struct elf32_arm_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

void
bfd_elf32_arm_set_byteswap_code (struct bfd_link_info *info,
				 int byteswap_code)
{
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (info);
  if (globals == NULL)
    return;

  globals->byteswap_code = byteswap_code;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info * info)
{
  bfd * dynobj;
  asection * s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd *ibfd;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
  check_use_blx (htab);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      struct arm_local_iplt_info **local_iplt_ptr, *local_iplt;
      char *local_tls_type;
      bfd_vma *local_tlsdesc_gotent;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
      bfd_boolean is_vxworks = htab->vxworks_p;
      unsigned int symndx;

      if (! is_arm_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf_dyn_relocs *p;

	  for (p = (struct elf_dyn_relocs *)
		   elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (is_vxworks
		       && strcmp (p->sec->output_section->name,
				  ".tls_vars") == 0)
		{
		  /* Relocations in vxworks .tls_vars sections are
		     handled specially by the loader.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  elf32_arm_allocate_dynrelocs (info, srel, p->count);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = & elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_iplt_ptr = elf32_arm_local_iplt (ibfd);
      local_tls_type = elf32_arm_local_got_tls_type (ibfd);
      local_tlsdesc_gotent = elf32_arm_local_tlsdesc_gotent (ibfd);
      symndx = 0;
      s = htab->root.sgot;
      srel = htab->root.srelgot;
      for (; local_got < end_local_got;
	   ++local_got, ++local_iplt_ptr, ++local_tls_type,
	   ++local_tlsdesc_gotent, ++symndx)
	{
	  *local_tlsdesc_gotent = (bfd_vma) -1;
	  local_iplt = *local_iplt_ptr;
	  if (local_iplt != NULL)
	    {
	      struct elf_dyn_relocs *p;

	      if (local_iplt->root.refcount > 0)
		{
		  elf32_arm_allocate_plt_entry (info, TRUE,
						&local_iplt->root,
						&local_iplt->arm);
		  if (local_iplt->arm.noncall_refcount == 0)
		    /* All references to the PLT are calls, so all
		       non-call references can resolve directly to the
		       run-time target.  This means that the .got entry
		       would be the same as the .igot.plt entry, so there's
		       no point creating both.  */
		    *local_got = 0;
		}
	      else
		{
		  BFD_ASSERT (local_iplt->arm.noncall_refcount == 0);
		  local_iplt->root.offset = (bfd_vma) -1;
		}

	      for (p = local_iplt->dyn_relocs; p != NULL; p = p->next)
		{
		  asection *psrel;

		  psrel = elf_section_data (p->sec)->sreloc;
		  if (local_iplt->arm.noncall_refcount == 0)
		    elf32_arm_allocate_irelocs (info, psrel, p->count);
		  else
		    elf32_arm_allocate_dynrelocs (info, psrel, p->count);
		}
	    }
	  if (*local_got > 0)
	    {
	      Elf_Internal_Sym *isym;

	      *local_got = s->size;
	      if (*local_tls_type & GOT_TLS_GD)
		/* TLS_GD relocs need an 8-byte structure in the GOT.  */
		s->size += 8;
	      if (*local_tls_type & GOT_TLS_GDESC)
		{
		  *local_tlsdesc_gotent = htab->root.sgotplt->size
		    - elf32_arm_compute_jump_table_size (htab);
		  htab->root.sgotplt->size += 8;
		  *local_got = (bfd_vma) -2;
		  /* plt.got_offset needs to know there's a TLS_DESC
		     reloc in the middle of .got.plt.  */
		  htab->num_tls_desc++;
		}
	      if (*local_tls_type & GOT_TLS_IE)
		s->size += 4;

	      if (*local_tls_type & GOT_NORMAL)
		{
		  /* If the symbol is both GD and GDESC, *local_got
		     may have been overwritten.  */
		  *local_got = s->size;
		  s->size += 4;
		}

	      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, symndx);
	      if (isym == NULL)
		return FALSE;

	      /* If all references to an STT_GNU_IFUNC PLT are calls,
		 then all non-call references, including this GOT entry,
		 resolve directly to the run-time target.  */
	      if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC
		  && (local_iplt == NULL
		      || local_iplt->arm.noncall_refcount == 0))
		elf32_arm_allocate_irelocs (info, srel, 1);
	      else if (info->shared || output_bfd->flags & DYNAMIC)
		{
		  if ((info->shared && !(*local_tls_type & GOT_TLS_GDESC))
		      || *local_tls_type & GOT_TLS_GD)
		    elf32_arm_allocate_dynrelocs (info, srel, 1);

		  if (info->shared && *local_tls_type & GOT_TLS_GDESC)
		    {
		      elf32_arm_allocate_dynrelocs (info,
						    htab->root.srelplt, 1);
		      htab->tls_trampoline = -1;
		    }
		}
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate two GOT entries and one dynamic relocation (if necessary)
	 for R_ARM_TLS_LDM32 relocations.  */
      htab->tls_ldm_got.offset = htab->root.sgot->size;
      htab->root.sgot->size += 8;
      if (info->shared)
	elf32_arm_allocate_dynrelocs (info, htab->root.srelgot, 1);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (& htab->root, allocate_dynrelocs_for_symbol, info);

  /* Here we rummage through the found bfds to collect glue information.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      if (! is_arm_elf (ibfd))
	continue;

      /* Initialise mapping tables for code/data.  */
      bfd_elf32_arm_init_maps (ibfd);

      if (!bfd_elf32_arm_process_before_allocation (ibfd, info)
	  || !bfd_elf32_arm_vfp11_erratum_scan (ibfd, info))
	/* xgettext:c-format */
	_bfd_error_handler (_("Errors encountered processing file %s"),
			    ibfd->filename);
    }

  /* Allocate space for the glue sections now that we've sized them.  */
  bfd_elf32_arm_allocate_interworking_sections (info);

  /* For every jump slot reserved in the sgotplt, reloc_count is
     incremented.  However, when we reserve space for TLS descriptors,
     it's not incremented, so in order to compute the space reserved
     for them, it suffices to multiply the reloc count by the jump
     slot size.  */
  if (htab->root.srelplt)
    htab->sgotplt_jump_table_size = elf32_arm_compute_jump_table_size(htab);

  if (htab->tls_trampoline)
    {
      if (htab->root.splt->size == 0)
	htab->root.splt->size += htab->plt_header_size;

      htab->tls_trampoline = htab->root.splt->size;
      htab->root.splt->size += htab->plt_entry_size;

      /* If we're not using lazy TLS relocations, don't generate the
	 PLT and GOT entries they require.  */
      if (!(info->flags & DF_BIND_NOW))
	{
	  htab->dt_tlsdesc_got = htab->root.sgot->size;
	  htab->root.sgot->size += 4;

	  htab->dt_tlsdesc_plt = htab->root.splt->size;
	  htab->root.splt->size += 4 * ARRAY_SIZE (dl_tlsdesc_lazy_trampoline);
	}
    }

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char * name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (s == htab->root.splt)
	{
	  /* Remember whether there is a PLT.  */
	  plt = s->size != 0;
	}
      else if (CONST_STRNEQ (name, ".rel"))
	{
	  if (s->size != 0)
	    {
	      /* Remember whether there are any reloc sections other
		 than .rel(a).plt and .rela.plt.unloaded.  */
	      if (s != htab->root.srelplt && s != htab->srelplt2)
		relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (s != htab->root.sgot
	       && s != htab->root.sgotplt
	       && s != htab->root.iplt
	       && s != htab->root.igotplt
	       && s != htab->sdynbss)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rel(a).bss and
	     .rel(a).plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      s->contents = (unsigned char *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf32_arm_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

     if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (   !add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL,
				     htab->use_rel ? DT_REL : DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;

	  if (htab->dt_tlsdesc_plt &&
		(!add_dynamic_entry (DT_TLSDESC_PLT,0)
		 || !add_dynamic_entry (DT_TLSDESC_GOT,0)))
	    return FALSE;
	}

      if (relocs)
	{
	  if (htab->use_rel)
	    {
	      if (!add_dynamic_entry (DT_REL, 0)
		  || !add_dynamic_entry (DT_RELSZ, 0)
		  || !add_dynamic_entry (DT_RELENT, RELOC_SIZE (htab)))
		return FALSE;
	    }
	  else
	    {
	      if (!add_dynamic_entry (DT_RELA, 0)
		  || !add_dynamic_entry (DT_RELASZ, 0)
		  || !add_dynamic_entry (DT_RELAENT, RELOC_SIZE (htab)))
		return FALSE;
	    }
	}

      /* If any dynamic relocs apply to a read-only section,
	 then we need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (& htab->root, elf32_arm_readonly_dynrelocs,
				info);

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
      if (htab->vxworks_p
	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
	return FALSE;
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Size sections even though they're not dynamic.  We use it to setup
   _TLS_MODULE_BASE_, if needed.  */

static bfd_boolean
elf32_arm_always_size_sections (bfd *output_bfd,
				struct bfd_link_info *info)
{
  asection *tls_sec;

  if (info->relocatable)
    return TRUE;

  tls_sec = elf_hash_table (info)->tls_sec;

  if (tls_sec)
    {
      struct elf_link_hash_entry *tlsbase;

      tlsbase = elf_link_hash_lookup
	(elf_hash_table (info), "_TLS_MODULE_BASE_", TRUE, TRUE, FALSE);

      if (tlsbase)
	{
	  struct bfd_link_hash_entry *bh = NULL;
	  const struct elf_backend_data *bed
	    = get_elf_backend_data (output_bfd);

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
		 tls_sec, 0, NULL, FALSE,
		 bed->collect, &bh)))
	    return FALSE;

	  tlsbase->type = STT_TLS;
	  tlsbase = (struct elf_link_hash_entry *)bh;
	  tlsbase->def_regular = 1;
	  tlsbase->other = STV_HIDDEN;
	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
	}
    }
  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf32_arm_finish_dynamic_symbol (bfd * output_bfd,
				 struct bfd_link_info * info,
				 struct elf_link_hash_entry * h,
				 Elf_Internal_Sym * sym)
{
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  eh = (struct elf32_arm_link_hash_entry *) h;

  if (h->plt.offset != (bfd_vma) -1)
    {
      if (!eh->is_iplt)
	{
	  BFD_ASSERT (h->dynindx != -1);
	  elf32_arm_populate_plt_entry (output_bfd, info, &h->plt, &eh->plt,
					h->dynindx, 0);
	}

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if (!h->ref_regular_nonweak)
	    sym->st_value = 0;
	}
      else if (eh->is_iplt && eh->plt.noncall_refcount != 0)
	{
	  /* At least one non-call relocation references this .iplt entry,
	     so the .iplt entry is the function's canonical address.  */
	  sym->st_info = ELF_ST_INFO (ELF_ST_BIND (sym->st_info), STT_FUNC);
	  sym->st_target_internal = ST_BRANCH_TO_ARM;
	  sym->st_shndx = (_bfd_elf_section_from_bfd_section
			   (output_bfd, htab->root.iplt->output_section));
	  sym->st_value = (h->plt.offset
			   + htab->root.iplt->output_section->vma
			   + htab->root.iplt->output_offset);
	}
    }

  if (h->needs_copy)
    {
      asection * s;
      Elf_Internal_Rela rel;

      /* This symbol needs a copy reloc.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = htab->srelbss;
      BFD_ASSERT (s != NULL);

      rel.r_addend = 0;
      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_COPY);
      elf32_arm_add_dynreloc (output_bfd, info, s, &rel);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  On VxWorks,
     the _GLOBAL_OFFSET_TABLE_ symbol is not absolute: it is relative
     to the ".got" section.  */
  if (h == htab->root.hdynamic
      || (!htab->vxworks_p && h == htab->root.hgot))
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

static void
arm_put_trampoline (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
		    void *contents,
		    const unsigned long *template, unsigned count)
{
  unsigned ix;

  for (ix = 0; ix != count; ix++)
    {
      unsigned long insn = template[ix];

      /* Emit mov pc,rx if bx is not permitted.  */
      if (htab->fix_v4bx == 1 && (insn & 0x0ffffff0) == 0x012fff10)
	insn = (insn & 0xf000000f) | 0x01a0f000;
      put_arm_insn (htab, output_bfd, insn, (char *)contents + ix*4);
    }
}

/* Install the special first PLT entry for elf32-arm-nacl.  Unlike
   other variants, NaCl needs this entry in a static executable's
   .iplt too.  When we're handling that case, GOT_DISPLACEMENT is
   zero.  For .iplt really only the last bundle is useful, and .iplt
   could have a shorter first entry, with each individual PLT entry's
   relative branch calculated differently so it targets the last
   bundle instead of the instruction before it (labelled .Lplt_tail
   above).  But it's simpler to keep the size and layout of PLT0
   consistent with the dynamic case, at the cost of some dead code at
   the start of .iplt and the one dead store to the stack at the start
   of .Lplt_tail.  */
static void
arm_nacl_put_plt0 (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
		   asection *plt, bfd_vma got_displacement)
{
  unsigned int i;

  put_arm_insn (htab, output_bfd,
		elf32_arm_nacl_plt0_entry[0]
		| arm_movw_immediate (got_displacement),
		plt->contents + 0);
  put_arm_insn (htab, output_bfd,
		elf32_arm_nacl_plt0_entry[1]
		| arm_movt_immediate (got_displacement),
		plt->contents + 4);

  for (i = 2; i < ARRAY_SIZE (elf32_arm_nacl_plt0_entry); ++i)
    put_arm_insn (htab, output_bfd,
		  elf32_arm_nacl_plt0_entry[i],
		  plt->contents + (i * 4));
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info)
{
  bfd * dynobj;
  asection * sgot;
  asection * sdyn;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = htab->root.sgotplt;
  /* A broken linker script might have discarded the dynamic sections.
     Catch this here so that we do not seg-fault later on.  */
  if (sgot != NULL && bfd_is_abs_section (sgot->output_section))
    return FALSE;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = htab->root.splt;
      BFD_ASSERT (splt != NULL && sdyn != NULL);
      BFD_ASSERT (htab->symbian_p || sgot != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char * name;
	  asection * s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	      unsigned int type;

	    default:
	      if (htab->vxworks_p
		  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
		bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_HASH:
	      name = ".hash";
	      goto get_vma_if_bpabi;
	    case DT_STRTAB:
	      name = ".dynstr";
	      goto get_vma_if_bpabi;
	    case DT_SYMTAB:
	      name = ".dynsym";
	      goto get_vma_if_bpabi;
	    case DT_VERSYM:
	      name = ".gnu.version";
	      goto get_vma_if_bpabi;
	    case DT_VERDEF:
	      name = ".gnu.version_d";
	      goto get_vma_if_bpabi;
	    case DT_VERNEED:
	      name = ".gnu.version_r";
	      goto get_vma_if_bpabi;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_JMPREL:
	      name = RELOC_SECTION (htab, ".plt");
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s == NULL)
		{
		  /* PR ld/14397: Issue an error message if a required section is missing.  */
		  (*_bfd_error_handler)
		    (_("error: required section '%s' not found in the linker script"), name);
		  bfd_set_error (bfd_error_invalid_operation);
		  return FALSE;
		}
	      if (!htab->symbian_p)
		dyn.d_un.d_ptr = s->vma;
	      else
		/* In the BPABI, tags in the PT_DYNAMIC section point
		   at the file offset, not the memory address, for the
		   convenience of the post linker.  */
		dyn.d_un.d_ptr = s->filepos;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    get_vma_if_bpabi:
	      if (htab->symbian_p)
		goto get_vma;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->root.srelplt;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELSZ:
	    case DT_RELASZ:
	      if (!htab->symbian_p)
		{
		  /* My reading of the SVR4 ABI indicates that the
		     procedure linkage table relocs (DT_JMPREL) should be
		     included in the overall relocs (DT_REL).  This is
		     what Solaris does.  However, UnixWare can not handle
		     that case.  Therefore, we override the DT_RELSZ entry
		     here to make it not include the JMPREL relocs.  Since
		     the linker script arranges for .rel(a).plt to follow all
		     other relocation sections, we don't have to worry
		     about changing the DT_REL entry.  */
		  s = htab->root.srelplt;
		  if (s != NULL)
		    dyn.d_un.d_val -= s->size;
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		  break;
		}
	      /* Fall through.  */

	    case DT_REL:
	    case DT_RELA:
	      /* In the BPABI, the DT_REL tag must point at the file
		 offset, not the VMA, of the first relocation
		 section.  So, we use code similar to that in
		 elflink.c, but do not check for SHF_ALLOC on the
		 relcoation section, since relocations sections are
		 never allocated under the BPABI.  The comments above
		 about Unixware notwithstanding, we include all of the
		 relocations here.  */
	      if (htab->symbian_p)
		{
		  unsigned int i;
		  type = ((dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)
			  ? SHT_REL : SHT_RELA);
		  dyn.d_un.d_val = 0;
		  for (i = 1; i < elf_numsections (output_bfd); i++)
		    {
		      Elf_Internal_Shdr *hdr
			= elf_elfsections (output_bfd)[i];
		      if (hdr->sh_type == type)
			{
			  if (dyn.d_tag == DT_RELSZ
			      || dyn.d_tag == DT_RELASZ)
			    dyn.d_un.d_val += hdr->sh_size;
			  else if ((ufile_ptr) hdr->sh_offset
				   <= dyn.d_un.d_val - 1)
			    dyn.d_un.d_val = hdr->sh_offset;
			}
		    }
		  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		}
	      break;

	    case DT_TLSDESC_PLT:
	      s = htab->root.splt;
	      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
				+ htab->dt_tlsdesc_plt);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_TLSDESC_GOT:
	      s = htab->root.sgot;
	      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
				+ htab->dt_tlsdesc_got);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	      /* Set the bottom bit of DT_INIT/FINI if the
		 corresponding function is Thumb.  */
	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;
	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      /* If it wasn't set by elf_bfd_final_link
		 then there is nothing to adjust.  */
	      if (dyn.d_un.d_val != 0)
		{
		  struct elf_link_hash_entry * eh;

		  eh = elf_link_hash_lookup (elf_hash_table (info), name,
					     FALSE, FALSE, TRUE);
		  if (eh != NULL && eh->target_internal == ST_BRANCH_TO_THUMB)
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0 && htab->plt_header_size)
	{
	  const bfd_vma *plt0_entry;
	  bfd_vma got_address, plt_address, got_displacement;

	  /* Calculate the addresses of the GOT and PLT.  */
	  got_address = sgot->output_section->vma + sgot->output_offset;
	  plt_address = splt->output_section->vma + splt->output_offset;

	  if (htab->vxworks_p)
	    {
	      /* The VxWorks GOT is relocated by the dynamic linker.
		 Therefore, we must emit relocations rather than simply
		 computing the values now.  */
	      Elf_Internal_Rela rel;

	      plt0_entry = elf32_arm_vxworks_exec_plt0_entry;
	      put_arm_insn (htab, output_bfd, plt0_entry[0],
			    splt->contents + 0);
	      put_arm_insn (htab, output_bfd, plt0_entry[1],
			    splt->contents + 4);
	      put_arm_insn (htab, output_bfd, plt0_entry[2],
			    splt->contents + 8);
	      bfd_put_32 (output_bfd, got_address, splt->contents + 12);

	      /* Generate a relocation for _GLOBAL_OFFSET_TABLE_.  */
	      rel.r_offset = plt_address + 12;
	      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_ARM_ABS32);
	      rel.r_addend = 0;
	      SWAP_RELOC_OUT (htab) (output_bfd, &rel,
				     htab->srelplt2->contents);
	    }
	  else if (htab->nacl_p)
	    arm_nacl_put_plt0 (htab, output_bfd, splt,
			       got_address + 8 - (plt_address + 16));
	  else
	    {
	      got_displacement = got_address - (plt_address + 16);

	      plt0_entry = elf32_arm_plt0_entry;
	      put_arm_insn (htab, output_bfd, plt0_entry[0],
			    splt->contents + 0);
	      put_arm_insn (htab, output_bfd, plt0_entry[1],
			    splt->contents + 4);
	      put_arm_insn (htab, output_bfd, plt0_entry[2],
			    splt->contents + 8);
	      put_arm_insn (htab, output_bfd, plt0_entry[3],
			    splt->contents + 12);

#ifdef FOUR_WORD_PLT
	      /* The displacement value goes in the otherwise-unused
		 last word of the second entry.  */
	      bfd_put_32 (output_bfd, got_displacement, splt->contents + 28);
#else
	      bfd_put_32 (output_bfd, got_displacement, splt->contents + 16);
#endif
	    }
	}

      /* UnixWare sets the entsize of .plt to 4, although that doesn't
	 really seem like the right value.  */
      if (splt->output_section->owner == output_bfd)
	elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;

      if (htab->dt_tlsdesc_plt)
	{
	  bfd_vma got_address
	    = sgot->output_section->vma + sgot->output_offset;
	  bfd_vma gotplt_address = (htab->root.sgot->output_section->vma
				    + htab->root.sgot->output_offset);
	  bfd_vma plt_address
	    = splt->output_section->vma + splt->output_offset;

	  arm_put_trampoline (htab, output_bfd,
			      splt->contents + htab->dt_tlsdesc_plt,
			      dl_tlsdesc_lazy_trampoline, 6);

	  bfd_put_32 (output_bfd,
		      gotplt_address + htab->dt_tlsdesc_got
		      - (plt_address + htab->dt_tlsdesc_plt)
		      - dl_tlsdesc_lazy_trampoline[6],
		      splt->contents + htab->dt_tlsdesc_plt + 24);
	  bfd_put_32 (output_bfd,
		      got_address - (plt_address + htab->dt_tlsdesc_plt)
		      - dl_tlsdesc_lazy_trampoline[7],
		      splt->contents + htab->dt_tlsdesc_plt + 24 + 4);
	}

      if (htab->tls_trampoline)
	{
	  arm_put_trampoline (htab, output_bfd,
			      splt->contents + htab->tls_trampoline,
			      tls_trampoline, 3);
#ifdef FOUR_WORD_PLT
	  bfd_put_32 (output_bfd, 0x00000000,
		      splt->contents + htab->tls_trampoline + 12);
#endif
	}

      if (htab->vxworks_p && !info->shared && htab->root.splt->size > 0)
	{
	  /* Correct the .rel(a).plt.unloaded relocations.  They will have
	     incorrect symbol indexes.  */
	  int num_plts;
	  unsigned char *p;

	  num_plts = ((htab->root.splt->size - htab->plt_header_size)
		      / htab->plt_entry_size);
	  p = htab->srelplt2->contents + RELOC_SIZE (htab);

	  for (; num_plts; num_plts--)
	    {
	      Elf_Internal_Rela rel;

	      SWAP_RELOC_IN (htab) (output_bfd, p, &rel);
	      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_ARM_ABS32);
	      SWAP_RELOC_OUT (htab) (output_bfd, &rel, p);
	      p += RELOC_SIZE (htab);

	      SWAP_RELOC_IN (htab) (output_bfd, p, &rel);
	      rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_ARM_ABS32);
	      SWAP_RELOC_OUT (htab) (output_bfd, &rel, p);
	      p += RELOC_SIZE (htab);
	    }
	}
    }

  if (htab->nacl_p && htab->root.iplt != NULL && htab->root.iplt->size > 0)
    /* NaCl uses a special first entry in .iplt too.  */
    arm_nacl_put_plt0 (htab, output_bfd, htab->root.iplt, 0);

  /* Fill in the first three entries in the global offset table.  */
  if (sgot)
    {
      if (sgot->size > 0)
	{
	  if (sdyn == NULL)
	    bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
	  else
	    bfd_put_32 (output_bfd,
			sdyn->output_section->vma + sdyn->output_offset,
			sgot->contents);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
	}

      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
    }

  return TRUE;
}

static void
elf32_arm_post_process_headers (bfd * abfd, struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
  struct elf32_arm_link_hash_table *globals;

  i_ehdrp = elf_elfheader (abfd);

  if (EF_ARM_EABI_VERSION (i_ehdrp->e_flags) == EF_ARM_EABI_UNKNOWN)
    i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_ARM;
  else
    i_ehdrp->e_ident[EI_OSABI] = 0;
  i_ehdrp->e_ident[EI_ABIVERSION] = ARM_ELF_ABI_VERSION;

  if (link_info)
    {
      globals = elf32_arm_hash_table (link_info);
      if (globals != NULL && globals->byteswap_code)
	i_ehdrp->e_flags |= EF_ARM_BE8;
    }

  if (EF_ARM_EABI_VERSION (i_ehdrp->e_flags) == EF_ARM_EABI_VER5
      && ((i_ehdrp->e_type == ET_DYN) || (i_ehdrp->e_type == ET_EXEC)))
    {
      int abi = bfd_elf_get_obj_attr_int (abfd, OBJ_ATTR_PROC, Tag_ABI_VFP_args);
      if (abi)
	i_ehdrp->e_flags |= EF_ARM_ABI_FLOAT_HARD;
      else
	i_ehdrp->e_flags |= EF_ARM_ABI_FLOAT_SOFT;
    }
}

static enum elf_reloc_type_class
elf32_arm_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			    const asection *rel_sec ATTRIBUTE_UNUSED,
			    const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_ARM_RELATIVE:
      return reloc_class_relative;
    case R_ARM_JUMP_SLOT:
      return reloc_class_plt;
    case R_ARM_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static void
elf32_arm_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
{
  bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);
}

/* Return TRUE if this is an unwinding table entry.  */

static bfd_boolean
is_arm_elf_unwind_section_name (bfd * abfd ATTRIBUTE_UNUSED, const char * name)
{
  return (CONST_STRNEQ (name, ELF_STRING_ARM_unwind)
	  || CONST_STRNEQ (name, ELF_STRING_ARM_unwind_once));
}


/* Set the type and flags for an ARM section.  We do this by
   the section name, which is a hack, but ought to work.  */

static bfd_boolean
elf32_arm_fake_sections (bfd * abfd, Elf_Internal_Shdr * hdr, asection * sec)
{
  const char * name;

  name = bfd_get_section_name (abfd, sec);

  if (is_arm_elf_unwind_section_name (abfd, name))
    {
      hdr->sh_type = SHT_ARM_EXIDX;
      hdr->sh_flags |= SHF_LINK_ORDER;
    }
  return TRUE;
}

/* Handle an ARM specific section when reading an object file.  This is
   called when bfd_section_from_shdr finds a section with an unknown
   type.  */

static bfd_boolean
elf32_arm_section_from_shdr (bfd *abfd,
			     Elf_Internal_Shdr * hdr,
			     const char *name,
			     int shindex)
{
  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  Fortunately, the ABI gives
     names for all the ARM specific sections, so we will probably get
     away with this.  */
  switch (hdr->sh_type)
    {
    case SHT_ARM_EXIDX:
    case SHT_ARM_PREEMPTMAP:
    case SHT_ARM_ATTRIBUTES:
      break;

    default:
      return FALSE;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  return TRUE;
}

static _arm_elf_section_data *
get_arm_elf_section_data (asection * sec)
{
  if (sec && sec->owner && is_arm_elf (sec->owner))
    return elf32_arm_section_data (sec);
  else
    return NULL;
}

typedef struct
{
  void *flaginfo;
  struct bfd_link_info *info;
  asection *sec;
  int sec_shndx;
  int (*func) (void *, const char *, Elf_Internal_Sym *,
	       asection *, struct elf_link_hash_entry *);
} output_arch_syminfo;

enum map_symbol_type
{
  ARM_MAP_ARM,
  ARM_MAP_THUMB,
  ARM_MAP_DATA
};


/* Output a single mapping symbol.  */

static bfd_boolean
elf32_arm_output_map_sym (output_arch_syminfo *osi,
			  enum map_symbol_type type,
			  bfd_vma offset)
{
  static const char *names[3] = {"$a", "$t", "$d"};
  Elf_Internal_Sym sym;

  sym.st_value = osi->sec->output_section->vma
		 + osi->sec->output_offset
		 + offset;
  sym.st_size = 0;
  sym.st_other = 0;
  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
  sym.st_shndx = osi->sec_shndx;
  sym.st_target_internal = 0;
  elf32_arm_section_map_add (osi->sec, names[type][1], offset);
  return osi->func (osi->flaginfo, names[type], &sym, osi->sec, NULL) == 1;
}

/* Output mapping symbols for the PLT entry described by ROOT_PLT and ARM_PLT.
   IS_IPLT_ENTRY_P says whether the PLT is in .iplt rather than .plt.  */

static bfd_boolean
elf32_arm_output_plt_map_1 (output_arch_syminfo *osi,
			    bfd_boolean is_iplt_entry_p,
			    union gotplt_union *root_plt,
			    struct arm_plt_info *arm_plt)
{
  struct elf32_arm_link_hash_table *htab;
  bfd_vma addr, plt_header_size;

  if (root_plt->offset == (bfd_vma) -1)
    return TRUE;

  htab = elf32_arm_hash_table (osi->info);
  if (htab == NULL)
    return FALSE;

  if (is_iplt_entry_p)
    {
      osi->sec = htab->root.iplt;
      plt_header_size = 0;
    }
  else
    {
      osi->sec = htab->root.splt;
      plt_header_size = htab->plt_header_size;
    }
  osi->sec_shndx = (_bfd_elf_section_from_bfd_section
		    (osi->info->output_bfd, osi->sec->output_section));

  addr = root_plt->offset & -2;
  if (htab->symbian_p)
    {
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 4))
	return FALSE;
    }
  else if (htab->vxworks_p)
    {
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 12))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 20))
	return FALSE;
    }
  else if (htab->nacl_p)
    {
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
    }
  else
    {
      bfd_boolean thumb_stub_p;

      thumb_stub_p = elf32_arm_plt_needs_thumb_stub_p (osi->info, arm_plt);
      if (thumb_stub_p)
	{
	  if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr - 4))
	    return FALSE;
	}
#ifdef FOUR_WORD_PLT
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 12))
	return FALSE;
#else
      /* A three-word PLT with no Thumb thunk contains only Arm code,
	 so only need to output a mapping symbol for the first PLT entry and
	 entries with thumb thunks.  */
      if (thumb_stub_p || addr == plt_header_size)
	{
	  if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	    return FALSE;
	}
#endif
    }

  return TRUE;
}

/* Output mapping symbols for PLT entries associated with H.  */

static bfd_boolean
elf32_arm_output_plt_map (struct elf_link_hash_entry *h, void *inf)
{
  output_arch_syminfo *osi = (output_arch_syminfo *) inf;
  struct elf32_arm_link_hash_entry *eh;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf32_arm_link_hash_entry *) h;
  return elf32_arm_output_plt_map_1 (osi, SYMBOL_CALLS_LOCAL (osi->info, h),
				     &h->plt, &eh->plt);
}

/* Output a single local symbol for a generated stub.  */

static bfd_boolean
elf32_arm_output_stub_sym (output_arch_syminfo *osi, const char *name,
			   bfd_vma offset, bfd_vma size)
{
  Elf_Internal_Sym sym;

  sym.st_value = osi->sec->output_section->vma
		 + osi->sec->output_offset
		 + offset;
  sym.st_size = size;
  sym.st_other = 0;
  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
  sym.st_shndx = osi->sec_shndx;
  sym.st_target_internal = 0;
  return osi->func (osi->flaginfo, name, &sym, osi->sec, NULL) == 1;
}

static bfd_boolean
arm_map_one_stub (struct bfd_hash_entry * gen_entry,
		  void * in_arg)
{
  struct elf32_arm_stub_hash_entry *stub_entry;
  asection *stub_sec;
  bfd_vma addr;
  char *stub_name;
  output_arch_syminfo *osi;
  const insn_sequence *template_sequence;
  enum stub_insn_type prev_type;
  int size;
  int i;
  enum map_symbol_type sym_type;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
  osi = (output_arch_syminfo *) in_arg;

  stub_sec = stub_entry->stub_sec;

  /* Ensure this stub is attached to the current section being
     processed.  */
  if (stub_sec != osi->sec)
    return TRUE;

  addr = (bfd_vma) stub_entry->stub_offset;
  stub_name = stub_entry->output_name;

  template_sequence = stub_entry->stub_template;
  switch (template_sequence[0].type)
    {
    case ARM_TYPE:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, stub_entry->stub_size))
	return FALSE;
      break;
    case THUMB16_TYPE:
    case THUMB32_TYPE:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1,
				      stub_entry->stub_size))
	return FALSE;
      break;
    default:
      BFD_FAIL ();
      return 0;
    }

  prev_type = DATA_TYPE;
  size = 0;
  for (i = 0; i < stub_entry->stub_template_size; i++)
    {
      switch (template_sequence[i].type)
	{
	case ARM_TYPE:
	  sym_type = ARM_MAP_ARM;
	  break;

	case THUMB16_TYPE:
	case THUMB32_TYPE:
	  sym_type = ARM_MAP_THUMB;
	  break;

	case DATA_TYPE:
	  sym_type = ARM_MAP_DATA;
	  break;

	default:
	  BFD_FAIL ();
	  return FALSE;
	}

      if (template_sequence[i].type != prev_type)
	{
	  prev_type = template_sequence[i].type;
	  if (!elf32_arm_output_map_sym (osi, sym_type, addr + size))
	    return FALSE;
	}

      switch (template_sequence[i].type)
	{
	case ARM_TYPE:
	case THUMB32_TYPE:
	  size += 4;
	  break;

	case THUMB16_TYPE:
	  size += 2;
	  break;

	case DATA_TYPE:
	  size += 4;
	  break;

	default:
	  BFD_FAIL ();
	  return FALSE;
	}
    }

  return TRUE;
}

/* Output mapping symbols for linker generated sections,
   and for those data-only sections that do not have a
   $d.  */

static bfd_boolean
elf32_arm_output_arch_local_syms (bfd *output_bfd,
				  struct bfd_link_info *info,
				  void *flaginfo,
				  int (*func) (void *, const char *,
					       Elf_Internal_Sym *,
					       asection *,
					       struct elf_link_hash_entry *))
{
  output_arch_syminfo osi;
  struct elf32_arm_link_hash_table *htab;
  bfd_vma offset;
  bfd_size_type size;
  bfd *input_bfd;

  htab = elf32_arm_hash_table (info);
  if (htab == NULL)
    return FALSE;

  check_use_blx (htab);

  osi.flaginfo = flaginfo;
  osi.info = info;
  osi.func = func;

  /* Add a $d mapping symbol to data-only sections that
     don't have any mapping symbol.  This may result in (harmless) redundant
     mapping symbols.  */
  for (input_bfd = info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      if ((input_bfd->flags & (BFD_LINKER_CREATED | HAS_SYMS)) == HAS_SYMS)
	for (osi.sec = input_bfd->sections;
	     osi.sec != NULL;
	     osi.sec = osi.sec->next)
	  {
	    if (osi.sec->output_section != NULL
		&& ((osi.sec->output_section->flags & (SEC_ALLOC | SEC_CODE))
		    != 0)
		&& (osi.sec->flags & (SEC_HAS_CONTENTS | SEC_LINKER_CREATED))
		   == SEC_HAS_CONTENTS
		&& get_arm_elf_section_data (osi.sec) != NULL
		&& get_arm_elf_section_data (osi.sec)->mapcount == 0
		&& osi.sec->size > 0
		&& (osi.sec->flags & SEC_EXCLUDE) == 0)
	      {
		osi.sec_shndx = _bfd_elf_section_from_bfd_section
		  (output_bfd, osi.sec->output_section);
		if (osi.sec_shndx != (int)SHN_BAD)
		  elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, 0);
	      }
	  }
    }

  /* ARM->Thumb glue.  */
  if (htab->arm_glue_size > 0)
    {
      osi.sec = bfd_get_linker_section (htab->bfd_of_glue_owner,
					ARM2THUMB_GLUE_SECTION_NAME);

      osi.sec_shndx = _bfd_elf_section_from_bfd_section
	  (output_bfd, osi.sec->output_section);
      if (info->shared || htab->root.is_relocatable_executable
	  || htab->pic_veneer)
	size = ARM2THUMB_PIC_GLUE_SIZE;
      else if (htab->use_blx)
	size = ARM2THUMB_V5_STATIC_GLUE_SIZE;
      else
	size = ARM2THUMB_STATIC_GLUE_SIZE;

      for (offset = 0; offset < htab->arm_glue_size; offset += size)
	{
	  elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, offset);
	  elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, offset + size - 4);
	}
    }

  /* Thumb->ARM glue.  */
  if (htab->thumb_glue_size > 0)
    {
      osi.sec = bfd_get_linker_section (htab->bfd_of_glue_owner,
					THUMB2ARM_GLUE_SECTION_NAME);

      osi.sec_shndx = _bfd_elf_section_from_bfd_section
	  (output_bfd, osi.sec->output_section);
      size = THUMB2ARM_GLUE_SIZE;

      for (offset = 0; offset < htab->thumb_glue_size; offset += size)
	{
	  elf32_arm_output_map_sym (&osi, ARM_MAP_THUMB, offset);
	  elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, offset + 4);
	}
    }

  /* ARMv4 BX veneers.  */
  if (htab->bx_glue_size > 0)
    {
      osi.sec = bfd_get_linker_section (htab->bfd_of_glue_owner,
					ARM_BX_GLUE_SECTION_NAME);

      osi.sec_shndx = _bfd_elf_section_from_bfd_section
	  (output_bfd, osi.sec->output_section);

      elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0);
    }

  /* Long calls stubs.  */
  if (htab->stub_bfd && htab->stub_bfd->sections)
    {
      asection* stub_sec;

      for (stub_sec = htab->stub_bfd->sections;
	   stub_sec != NULL;
	   stub_sec = stub_sec->next)
	{
	  /* Ignore non-stub sections.  */
	  if (!strstr (stub_sec->name, STUB_SUFFIX))
	    continue;

	  osi.sec = stub_sec;

	  osi.sec_shndx = _bfd_elf_section_from_bfd_section
	    (output_bfd, osi.sec->output_section);

	  bfd_hash_traverse (&htab->stub_hash_table, arm_map_one_stub, &osi);
	}
    }

  /* Finally, output mapping symbols for the PLT.  */
  if (htab->root.splt && htab->root.splt->size > 0)
    {
      osi.sec = htab->root.splt;
      osi.sec_shndx = (_bfd_elf_section_from_bfd_section
		       (output_bfd, osi.sec->output_section));

      /* Output mapping symbols for the plt header.  SymbianOS does not have a
	 plt header.  */
      if (htab->vxworks_p)
	{
	  /* VxWorks shared libraries have no PLT header.  */
	  if (!info->shared)
	    {
	      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
		return FALSE;
	      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, 12))
		return FALSE;
	    }
	}
      else if (htab->nacl_p)
	{
	  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
	    return FALSE;
	}
      else if (!htab->symbian_p)
	{
	  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
	    return FALSE;
#ifndef FOUR_WORD_PLT
	  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, 16))
	    return FALSE;
#endif
	}
    }
  if (htab->nacl_p && htab->root.iplt && htab->root.iplt->size > 0)
    {
      /* NaCl uses a special first entry in .iplt too.  */
      osi.sec = htab->root.iplt;
      osi.sec_shndx = (_bfd_elf_section_from_bfd_section
		       (output_bfd, osi.sec->output_section));
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
	return FALSE;
    }
  if ((htab->root.splt && htab->root.splt->size > 0)
      || (htab->root.iplt && htab->root.iplt->size > 0))
    {
      elf_link_hash_traverse (&htab->root, elf32_arm_output_plt_map, &osi);
      for (input_bfd = info->input_bfds;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next)
	{
	  struct arm_local_iplt_info **local_iplt;
	  unsigned int i, num_syms;

	  local_iplt = elf32_arm_local_iplt (input_bfd);
	  if (local_iplt != NULL)
	    {
	      num_syms = elf_symtab_hdr (input_bfd).sh_info;
	      for (i = 0; i < num_syms; i++)
		if (local_iplt[i] != NULL
		    && !elf32_arm_output_plt_map_1 (&osi, TRUE,
						    &local_iplt[i]->root,
						    &local_iplt[i]->arm))
		  return FALSE;
	    }
	}
    }
  if (htab->dt_tlsdesc_plt != 0)
    {
      /* Mapping symbols for the lazy tls trampoline.  */
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, htab->dt_tlsdesc_plt))
	return FALSE;

      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA,
				     htab->dt_tlsdesc_plt + 24))
	return FALSE;
    }
  if (htab->tls_trampoline != 0)
    {
      /* Mapping symbols for the tls trampoline.  */
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, htab->tls_trampoline))
	return FALSE;
#ifdef FOUR_WORD_PLT
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA,
				     htab->tls_trampoline + 12))
	return FALSE;
#endif
    }

  return TRUE;
}

/* Allocate target specific section data.  */

static bfd_boolean
elf32_arm_new_section_hook (bfd *abfd, asection *sec)
{
  if (!sec->used_by_bfd)
    {
      _arm_elf_section_data *sdata;
      bfd_size_type amt = sizeof (*sdata);

      sdata = (_arm_elf_section_data *) bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  return _bfd_elf_new_section_hook (abfd, sec);
}


/* Used to order a list of mapping symbols by address.  */

static int
elf32_arm_compare_mapping (const void * a, const void * b)
{
  const elf32_arm_section_map *amap = (const elf32_arm_section_map *) a;
  const elf32_arm_section_map *bmap = (const elf32_arm_section_map *) b;

  if (amap->vma > bmap->vma)
    return 1;
  else if (amap->vma < bmap->vma)
    return -1;
  else if (amap->type > bmap->type)
    /* Ensure results do not depend on the host qsort for objects with
       multiple mapping symbols at the same address by sorting on type
       after vma.  */
    return 1;
  else if (amap->type < bmap->type)
    return -1;
  else
    return 0;
}

/* Add OFFSET to lower 31 bits of ADDR, leaving other bits unmodified.  */

static unsigned long
offset_prel31 (unsigned long addr, bfd_vma offset)
{
  return (addr & ~0x7ffffffful) | ((addr + offset) & 0x7ffffffful);
}

/* Copy an .ARM.exidx table entry, adding OFFSET to (applied) PREL31
   relocations.  */

static void
copy_exidx_entry (bfd *output_bfd, bfd_byte *to, bfd_byte *from, bfd_vma offset)
{
  unsigned long first_word = bfd_get_32 (output_bfd, from);
  unsigned long second_word = bfd_get_32 (output_bfd, from + 4);

  /* High bit of first word is supposed to be zero.  */
  if ((first_word & 0x80000000ul) == 0)
    first_word = offset_prel31 (first_word, offset);

  /* If the high bit of the first word is clear, and the bit pattern is not 0x1
     (EXIDX_CANTUNWIND), this is an offset to an .ARM.extab entry.  */
  if ((second_word != 0x1) && ((second_word & 0x80000000ul) == 0))
    second_word = offset_prel31 (second_word, offset);

  bfd_put_32 (output_bfd, first_word, to);
  bfd_put_32 (output_bfd, second_word, to + 4);
}

/* Data for make_branch_to_a8_stub().  */

struct a8_branch_to_stub_data
{
  asection *writing_section;
  bfd_byte *contents;
};


/* Helper to insert branches to Cortex-A8 erratum stubs in the right
   places for a particular section.  */

static bfd_boolean
make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
		       void *in_arg)
{
  struct elf32_arm_stub_hash_entry *stub_entry;
  struct a8_branch_to_stub_data *data;
  bfd_byte *contents;
  unsigned long branch_insn;
  bfd_vma veneered_insn_loc, veneer_entry_loc;
  bfd_signed_vma branch_offset;
  bfd *abfd;
  unsigned int target;

  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
  data = (struct a8_branch_to_stub_data *) in_arg;

  if (stub_entry->target_section != data->writing_section
      || stub_entry->stub_type < arm_stub_a8_veneer_lwm)
    return TRUE;

  contents = data->contents;

  veneered_insn_loc = stub_entry->target_section->output_section->vma
		      + stub_entry->target_section->output_offset
		      + stub_entry->target_value;

  veneer_entry_loc = stub_entry->stub_sec->output_section->vma
		     + stub_entry->stub_sec->output_offset
		     + stub_entry->stub_offset;

  if (stub_entry->stub_type == arm_stub_a8_veneer_blx)
    veneered_insn_loc &= ~3u;

  branch_offset = veneer_entry_loc - veneered_insn_loc - 4;

  abfd = stub_entry->target_section->owner;
  target = stub_entry->target_value;

  /* We attempt to avoid this condition by setting stubs_always_after_branch
     in elf32_arm_size_stubs if we've enabled the Cortex-A8 erratum workaround.
     This check is just to be on the safe side...  */
  if ((veneered_insn_loc & ~0xfff) == (veneer_entry_loc & ~0xfff))
    {
      (*_bfd_error_handler) (_("%B: error: Cortex-A8 erratum stub is "
			       "allocated in unsafe location"), abfd);
      return FALSE;
    }

  switch (stub_entry->stub_type)
    {
    case arm_stub_a8_veneer_b:
    case arm_stub_a8_veneer_b_cond:
      branch_insn = 0xf0009000;
      goto jump24;

    case arm_stub_a8_veneer_blx:
      branch_insn = 0xf000e800;
      goto jump24;

    case arm_stub_a8_veneer_bl:
      {
	unsigned int i1, j1, i2, j2, s;

	branch_insn = 0xf000d000;

      jump24:
	if (branch_offset < -16777216 || branch_offset > 16777214)
	  {
	    /* There's not much we can do apart from complain if this
	       happens.  */
	    (*_bfd_error_handler) (_("%B: error: Cortex-A8 erratum stub out "
				     "of range (input file too large)"), abfd);
	    return FALSE;
	  }

	/* i1 = not(j1 eor s), so:
	   not i1 = j1 eor s
	   j1 = (not i1) eor s.  */

	branch_insn |= (branch_offset >> 1) & 0x7ff;
	branch_insn |= ((branch_offset >> 12) & 0x3ff) << 16;
	i2 = (branch_offset >> 22) & 1;
	i1 = (branch_offset >> 23) & 1;
	s = (branch_offset >> 24) & 1;
	j1 = (!i1) ^ s;
	j2 = (!i2) ^ s;
	branch_insn |= j2 << 11;
	branch_insn |= j1 << 13;
	branch_insn |= s << 26;
      }
      break;

    default:
      BFD_FAIL ();
      return FALSE;
    }

  bfd_put_16 (abfd, (branch_insn >> 16) & 0xffff, &contents[target]);
  bfd_put_16 (abfd, branch_insn & 0xffff, &contents[target + 2]);

  return TRUE;
}

/* Do code byteswapping.  Return FALSE afterwards so that the section is
   written out as normal.  */

static bfd_boolean
elf32_arm_write_section (bfd *output_bfd,
			 struct bfd_link_info *link_info,
			 asection *sec,
			 bfd_byte *contents)
{
  unsigned int mapcount, errcount;
  _arm_elf_section_data *arm_data;
  struct elf32_arm_link_hash_table *globals = elf32_arm_hash_table (link_info);
  elf32_arm_section_map *map;
  elf32_vfp11_erratum_list *errnode;
  bfd_vma ptr;
  bfd_vma end;
  bfd_vma offset = sec->output_section->vma + sec->output_offset;
  bfd_byte tmp;
  unsigned int i;

  if (globals == NULL)
    return FALSE;

  /* If this section has not been allocated an _arm_elf_section_data
     structure then we cannot record anything.  */
  arm_data = get_arm_elf_section_data (sec);
  if (arm_data == NULL)
    return FALSE;

  mapcount = arm_data->mapcount;
  map = arm_data->map;
  errcount = arm_data->erratumcount;

  if (errcount != 0)
    {
      unsigned int endianflip = bfd_big_endian (output_bfd) ? 3 : 0;

      for (errnode = arm_data->erratumlist; errnode != 0;
	   errnode = errnode->next)
	{
	  bfd_vma target = errnode->vma - offset;

	  switch (errnode->type)
	    {
	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
	      {
		bfd_vma branch_to_veneer;
		/* Original condition code of instruction, plus bit mask for
		   ARM B instruction.  */
		unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
				  | 0x0a000000;

		/* The instruction is before the label.  */
		target -= 4;

		/* Above offset included in -4 below.  */
		branch_to_veneer = errnode->u.b.veneer->vma
				   - errnode->vma - 4;

		if ((signed) branch_to_veneer < -(1 << 25)
		    || (signed) branch_to_veneer >= (1 << 25))
		  (*_bfd_error_handler) (_("%B: error: VFP11 veneer out of "
					   "range"), output_bfd);

		insn |= (branch_to_veneer >> 2) & 0xffffff;
		contents[endianflip ^ target] = insn & 0xff;
		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
	      }
	      break;

	    case VFP11_ERRATUM_ARM_VENEER:
	      {
		bfd_vma branch_from_veneer;
		unsigned int insn;

		/* Take size of veneer into account.  */
		branch_from_veneer = errnode->u.v.branch->vma
				     - errnode->vma - 12;

		if ((signed) branch_from_veneer < -(1 << 25)
		    || (signed) branch_from_veneer >= (1 << 25))
		  (*_bfd_error_handler) (_("%B: error: VFP11 veneer out of "
					   "range"), output_bfd);

		/* Original instruction.  */
		insn = errnode->u.v.branch->u.b.vfp_insn;
		contents[endianflip ^ target] = insn & 0xff;
		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;

		/* Branch back to insn after original insn.  */
		insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
		contents[endianflip ^ (target + 4)] = insn & 0xff;
		contents[endianflip ^ (target + 5)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 6)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 7)] = (insn >> 24) & 0xff;
	      }
	      break;

	    default:
	      abort ();
	    }
	}
    }

  if (arm_data->elf.this_hdr.sh_type == SHT_ARM_EXIDX)
    {
      arm_unwind_table_edit *edit_node
	= arm_data->u.exidx.unwind_edit_list;
      /* Now, sec->size is the size of the section we will write.  The original
	 size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
	 markers) was sec->rawsize.  (This isn't the case if we perform no
	 edits, then rawsize will be zero and we should use size).  */
      bfd_byte *edited_contents = (bfd_byte *) bfd_malloc (sec->size);
      unsigned int input_size = sec->rawsize ? sec->rawsize : sec->size;
      unsigned int in_index, out_index;
      bfd_vma add_to_offsets = 0;

      for (in_index = 0, out_index = 0; in_index * 8 < input_size || edit_node;)
	{
	  if (edit_node)
	    {
	      unsigned int edit_index = edit_node->index;

	      if (in_index < edit_index && in_index * 8 < input_size)
		{
		  copy_exidx_entry (output_bfd, edited_contents + out_index * 8,
				    contents + in_index * 8, add_to_offsets);
		  out_index++;
		  in_index++;
		}
	      else if (in_index == edit_index
		       || (in_index * 8 >= input_size
			   && edit_index == UINT_MAX))
		{
		  switch (edit_node->type)
		    {
		    case DELETE_EXIDX_ENTRY:
		      in_index++;
		      add_to_offsets += 8;
		      break;

		    case INSERT_EXIDX_CANTUNWIND_AT_END:
		      {
			asection *text_sec = edit_node->linked_section;
			bfd_vma text_offset = text_sec->output_section->vma
					      + text_sec->output_offset
					      + text_sec->size;
			bfd_vma exidx_offset = offset + out_index * 8;
			unsigned long prel31_offset;

			/* Note: this is meant to be equivalent to an
			   R_ARM_PREL31 relocation.  These synthetic
			   EXIDX_CANTUNWIND markers are not relocated by the
			   usual BFD method.  */
			prel31_offset = (text_offset - exidx_offset)
					& 0x7ffffffful;

			/* First address we can't unwind.  */
			bfd_put_32 (output_bfd, prel31_offset,
				    &edited_contents[out_index * 8]);

			/* Code for EXIDX_CANTUNWIND.  */
			bfd_put_32 (output_bfd, 0x1,
				    &edited_contents[out_index * 8 + 4]);

			out_index++;
			add_to_offsets -= 8;
		      }
		      break;
		    }

		  edit_node = edit_node->next;
		}
	    }
	  else
	    {
	      /* No more edits, copy remaining entries verbatim.  */
	      copy_exidx_entry (output_bfd, edited_contents + out_index * 8,
				contents + in_index * 8, add_to_offsets);
	      out_index++;
	      in_index++;
	    }
	}

      if (!(sec->flags & SEC_EXCLUDE) && !(sec->flags & SEC_NEVER_LOAD))
	bfd_set_section_contents (output_bfd, sec->output_section,
				  edited_contents,
				  (file_ptr) sec->output_offset, sec->size);

      return TRUE;
    }

  /* Fix code to point to Cortex-A8 erratum stubs.  */
  if (globals->fix_cortex_a8)
    {
      struct a8_branch_to_stub_data data;

      data.writing_section = sec;
      data.contents = contents;

      bfd_hash_traverse (&globals->stub_hash_table, make_branch_to_a8_stub,
			 &data);
    }

  if (mapcount == 0)
    return FALSE;

  if (globals->byteswap_code)
    {
      qsort (map, mapcount, sizeof (* map), elf32_arm_compare_mapping);

      ptr = map[0].vma;
      for (i = 0; i < mapcount; i++)
	{
	  if (i == mapcount - 1)
	    end = sec->size;
	  else
	    end = map[i + 1].vma;

	  switch (map[i].type)
	    {
	    case 'a':
	      /* Byte swap code words.  */
	      while (ptr + 3 < end)
		{
		  tmp = contents[ptr];
		  contents[ptr] = contents[ptr + 3];
		  contents[ptr + 3] = tmp;
		  tmp = contents[ptr + 1];
		  contents[ptr + 1] = contents[ptr + 2];
		  contents[ptr + 2] = tmp;
		  ptr += 4;
		}
	      break;

	    case 't':
	      /* Byte swap code halfwords.  */
	      while (ptr + 1 < end)
		{
		  tmp = contents[ptr];
		  contents[ptr] = contents[ptr + 1];
		  contents[ptr + 1] = tmp;
		  ptr += 2;
		}
	      break;

	    case 'd':
	      /* Leave data alone.  */
	      break;
	    }
	  ptr = end;
	}
    }

  free (map);
  arm_data->mapcount = -1;
  arm_data->mapsize = 0;
  arm_data->map = NULL;

  return FALSE;
}

/* Mangle thumb function symbols as we read them in.  */

static bfd_boolean
elf32_arm_swap_symbol_in (bfd * abfd,
			  const void *psrc,
			  const void *pshn,
			  Elf_Internal_Sym *dst)
{
  if (!bfd_elf32_swap_symbol_in (abfd, psrc, pshn, dst))
    return FALSE;

  /* New EABI objects mark thumb function symbols by setting the low bit of
     the address.  */
  if (ELF_ST_TYPE (dst->st_info) == STT_FUNC
      || ELF_ST_TYPE (dst->st_info) == STT_GNU_IFUNC)
    {
      if (dst->st_value & 1)
	{
	  dst->st_value &= ~(bfd_vma) 1;
	  dst->st_target_internal = ST_BRANCH_TO_THUMB;
	}
      else
	dst->st_target_internal = ST_BRANCH_TO_ARM;
    }
  else if (ELF_ST_TYPE (dst->st_info) == STT_ARM_TFUNC)
    {
      dst->st_info = ELF_ST_INFO (ELF_ST_BIND (dst->st_info), STT_FUNC);
      dst->st_target_internal = ST_BRANCH_TO_THUMB;
    }
  else if (ELF_ST_TYPE (dst->st_info) == STT_SECTION)
    dst->st_target_internal = ST_BRANCH_LONG;
  else
    dst->st_target_internal = ST_BRANCH_UNKNOWN;

  return TRUE;
}


/* Mangle thumb function symbols as we write them out.  */

static void
elf32_arm_swap_symbol_out (bfd *abfd,
			   const Elf_Internal_Sym *src,
			   void *cdst,
			   void *shndx)
{
  Elf_Internal_Sym newsym;

  /* We convert STT_ARM_TFUNC symbols into STT_FUNC with the low bit
     of the address set, as per the new EABI.  We do this unconditionally
     because objcopy does not set the elf header flags until after
     it writes out the symbol table.  */
  if (src->st_target_internal == ST_BRANCH_TO_THUMB)
    {
      newsym = *src;
      if (ELF_ST_TYPE (src->st_info) != STT_GNU_IFUNC)
	newsym.st_info = ELF_ST_INFO (ELF_ST_BIND (src->st_info), STT_FUNC);
      if (newsym.st_shndx != SHN_UNDEF)
	{
	  /* Do this only for defined symbols. At link type, the static
	     linker will simulate the work of dynamic linker of resolving
	     symbols and will carry over the thumbness of found symbols to
	     the output symbol table. It's not clear how it happens, but
	     the thumbness of undefined symbols can well be different at
	     runtime, and writing '1' for them will be confusing for users
	     and possibly for dynamic linker itself.
	  */
	  newsym.st_value |= 1;
	}

      src = &newsym;
    }
  bfd_elf32_swap_symbol_out (abfd, src, cdst, shndx);
}

/* Add the PT_ARM_EXIDX program header.  */

static bfd_boolean
elf32_arm_modify_segment_map (bfd *abfd,
			      struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map *m;
  asection *sec;

  sec = bfd_get_section_by_name (abfd, ".ARM.exidx");
  if (sec != NULL && (sec->flags & SEC_LOAD) != 0)
    {
      /* If there is already a PT_ARM_EXIDX header, then we do not
	 want to add another one.  This situation arises when running
	 "strip"; the input binary already has the header.  */
      m = elf_seg_map (abfd);
      while (m && m->p_type != PT_ARM_EXIDX)
	m = m->next;
      if (!m)
	{
	  m = (struct elf_segment_map *)
	      bfd_zalloc (abfd, sizeof (struct elf_segment_map));
	  if (m == NULL)
	    return FALSE;
	  m->p_type = PT_ARM_EXIDX;
	  m->count = 1;
	  m->sections[0] = sec;

	  m->next = elf_seg_map (abfd);
	  elf_seg_map (abfd) = m;
	}
    }

  return TRUE;
}

/* We may add a PT_ARM_EXIDX program header.  */

static int
elf32_arm_additional_program_headers (bfd *abfd,
				      struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *sec;

  sec = bfd_get_section_by_name (abfd, ".ARM.exidx");
  if (sec != NULL && (sec->flags & SEC_LOAD) != 0)
    return 1;
  else
    return 0;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  */

static bfd_boolean
elf32_arm_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			   Elf_Internal_Sym *sym, const char **namep,
			   flagword *flagsp, asection **secp, bfd_vma *valp)
{
  if ((abfd->flags & DYNAMIC) == 0
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

  if (elf32_arm_hash_table (info)->vxworks_p
      && !elf_vxworks_add_symbol_hook (abfd, info, sym, namep,
				       flagsp, secp, valp))
    return FALSE;

  return TRUE;
}

/* We use this to override swap_symbol_in and swap_symbol_out.  */
const struct elf_size_info elf32_arm_size_info =
{
  sizeof (Elf32_External_Ehdr),
  sizeof (Elf32_External_Phdr),
  sizeof (Elf32_External_Shdr),
  sizeof (Elf32_External_Rel),
  sizeof (Elf32_External_Rela),
  sizeof (Elf32_External_Sym),
  sizeof (Elf32_External_Dyn),
  sizeof (Elf_External_Note),
  4,
  1,
  32, 2,
  ELFCLASS32, EV_CURRENT,
  bfd_elf32_write_out_phdrs,
  bfd_elf32_write_shdrs_and_ehdr,
  bfd_elf32_checksum_contents,
  bfd_elf32_write_relocs,
  elf32_arm_swap_symbol_in,
  elf32_arm_swap_symbol_out,
  bfd_elf32_slurp_reloc_table,
  bfd_elf32_slurp_symbol_table,
  bfd_elf32_swap_dyn_in,
  bfd_elf32_swap_dyn_out,
  bfd_elf32_swap_reloc_in,
  bfd_elf32_swap_reloc_out,
  bfd_elf32_swap_reloca_in,
  bfd_elf32_swap_reloca_out
};

#define ELF_ARCH			bfd_arch_arm
#define ELF_TARGET_ID			ARM_ELF_DATA
#define ELF_MACHINE_CODE		EM_ARM
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE			0x1000
#else
#define ELF_MAXPAGESIZE			0x8000
#endif
#define ELF_MINPAGESIZE			0x1000
#define ELF_COMMONPAGESIZE		0x1000

#define bfd_elf32_mkobject		        elf32_arm_mkobject

#define bfd_elf32_bfd_copy_private_bfd_data	elf32_arm_copy_private_bfd_data
#define bfd_elf32_bfd_merge_private_bfd_data	elf32_arm_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags		elf32_arm_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data	elf32_arm_print_private_bfd_data
#define bfd_elf32_bfd_link_hash_table_create    elf32_arm_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free      elf32_arm_hash_table_free
#define bfd_elf32_bfd_reloc_type_lookup		elf32_arm_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup		elf32_arm_reloc_name_lookup
#define bfd_elf32_find_nearest_line	        elf32_arm_find_nearest_line
#define bfd_elf32_find_inliner_info	        elf32_arm_find_inliner_info
#define bfd_elf32_new_section_hook		elf32_arm_new_section_hook
#define bfd_elf32_bfd_is_target_special_symbol	elf32_arm_is_target_special_symbol
#define bfd_elf32_bfd_final_link		elf32_arm_final_link

#define elf_backend_get_symbol_type             elf32_arm_get_symbol_type
#define elf_backend_gc_mark_hook                elf32_arm_gc_mark_hook
#define elf_backend_gc_mark_extra_sections	elf32_arm_gc_mark_extra_sections
#define elf_backend_gc_sweep_hook               elf32_arm_gc_sweep_hook
#define elf_backend_check_relocs                elf32_arm_check_relocs
#define elf_backend_relocate_section		elf32_arm_relocate_section
#define elf_backend_write_section		elf32_arm_write_section
#define elf_backend_adjust_dynamic_symbol	elf32_arm_adjust_dynamic_symbol
#define elf_backend_create_dynamic_sections     elf32_arm_create_dynamic_sections
#define elf_backend_finish_dynamic_symbol	elf32_arm_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections	elf32_arm_finish_dynamic_sections
#define elf_backend_size_dynamic_sections	elf32_arm_size_dynamic_sections
#define elf_backend_always_size_sections	elf32_arm_always_size_sections
#define elf_backend_init_index_section		_bfd_elf_init_2_index_sections
#define elf_backend_post_process_headers	elf32_arm_post_process_headers
#define elf_backend_reloc_type_class		elf32_arm_reloc_type_class
#define elf_backend_object_p			elf32_arm_object_p
#define elf_backend_fake_sections  		elf32_arm_fake_sections
#define elf_backend_section_from_shdr  		elf32_arm_section_from_shdr
#define elf_backend_final_write_processing      elf32_arm_final_write_processing
#define elf_backend_copy_indirect_symbol        elf32_arm_copy_indirect_symbol
#define elf_backend_size_info			elf32_arm_size_info
#define elf_backend_modify_segment_map		elf32_arm_modify_segment_map
#define elf_backend_additional_program_headers  elf32_arm_additional_program_headers
#define elf_backend_output_arch_local_syms      elf32_arm_output_arch_local_syms
#define elf_backend_begin_write_processing      elf32_arm_begin_write_processing
#define elf_backend_add_symbol_hook		elf32_arm_add_symbol_hook

#define elf_backend_can_refcount       1
#define elf_backend_can_gc_sections    1
#define elf_backend_plt_readonly       1
#define elf_backend_want_got_plt       1
#define elf_backend_want_plt_sym       0
#define elf_backend_may_use_rel_p      1
#define elf_backend_may_use_rela_p     0
#define elf_backend_default_use_rela_p 0

#define elf_backend_got_header_size	12

#undef  elf_backend_obj_attrs_vendor
#define elf_backend_obj_attrs_vendor		"aeabi"
#undef  elf_backend_obj_attrs_section
#define elf_backend_obj_attrs_section		".ARM.attributes"
#undef  elf_backend_obj_attrs_arg_type
#define elf_backend_obj_attrs_arg_type		elf32_arm_obj_attrs_arg_type
#undef  elf_backend_obj_attrs_section_type
#define elf_backend_obj_attrs_section_type	SHT_ARM_ATTRIBUTES
#define elf_backend_obj_attrs_order		elf32_arm_obj_attrs_order
#define elf_backend_obj_attrs_handle_unknown 	elf32_arm_obj_attrs_handle_unknown

#include "elf32-target.h"

/* Native Client targets.  */

#undef	TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		bfd_elf32_littlearm_nacl_vec
#undef	TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elf32-littlearm-nacl"
#undef	TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf32_bigarm_nacl_vec
#undef	TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf32-bigarm-nacl"

/* Like elf32_arm_link_hash_table_create -- but overrides
   appropriately for NaCl.  */

static struct bfd_link_hash_table *
elf32_arm_nacl_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = elf32_arm_link_hash_table_create (abfd);
  if (ret)
    {
      struct elf32_arm_link_hash_table *htab
	= (struct elf32_arm_link_hash_table *) ret;

      htab->nacl_p = 1;

      htab->plt_header_size = 4 * ARRAY_SIZE (elf32_arm_nacl_plt0_entry);
      htab->plt_entry_size = 4 * ARRAY_SIZE (elf32_arm_nacl_plt_entry);
    }
  return ret;
}

/* Since NaCl doesn't use the ARM-specific unwind format, we don't
   really need to use elf32_arm_modify_segment_map.  But we do it
   anyway just to reduce gratuitous differences with the stock ARM backend.  */

static bfd_boolean
elf32_arm_nacl_modify_segment_map (bfd *abfd, struct bfd_link_info *info)
{
  return (elf32_arm_modify_segment_map (abfd, info)
	  && nacl_modify_segment_map (abfd, info));
}

static void
elf32_arm_nacl_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  elf32_arm_final_write_processing (abfd, linker);
  nacl_final_write_processing (abfd, linker);
}


#undef	elf32_bed
#define elf32_bed			elf32_arm_nacl_bed
#undef  bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create	\
  elf32_arm_nacl_link_hash_table_create
#undef	elf_backend_plt_alignment
#define elf_backend_plt_alignment	4
#undef	elf_backend_modify_segment_map
#define	elf_backend_modify_segment_map		elf32_arm_nacl_modify_segment_map
#undef	elf_backend_modify_program_headers
#define	elf_backend_modify_program_headers	nacl_modify_program_headers
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_nacl_final_write_processing

#undef	ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE			0x10000
#undef	ELF_MINPAGESIZE
#undef	ELF_COMMONPAGESIZE


#include "elf32-target.h"

/* Reset to defaults.  */
#undef	elf_backend_plt_alignment
#undef	elf_backend_modify_segment_map
#define elf_backend_modify_segment_map		elf32_arm_modify_segment_map
#undef	elf_backend_modify_program_headers
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_final_write_processing
#undef	ELF_MINPAGESIZE
#define ELF_MINPAGESIZE			0x1000
#undef	ELF_COMMONPAGESIZE
#define ELF_COMMONPAGESIZE		0x1000


/* VxWorks Targets.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM               bfd_elf32_littlearm_vxworks_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME              "elf32-littlearm-vxworks"
#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM                  bfd_elf32_bigarm_vxworks_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME                 "elf32-bigarm-vxworks"

/* Like elf32_arm_link_hash_table_create -- but overrides
   appropriately for VxWorks.  */

static struct bfd_link_hash_table *
elf32_arm_vxworks_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = elf32_arm_link_hash_table_create (abfd);
  if (ret)
    {
      struct elf32_arm_link_hash_table *htab
	= (struct elf32_arm_link_hash_table *) ret;
      htab->use_rel = 0;
      htab->vxworks_p = 1;
    }
  return ret;
}

static void
elf32_arm_vxworks_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  elf32_arm_final_write_processing (abfd, linker);
  elf_vxworks_final_write_processing (abfd, linker);
}

#undef  elf32_bed
#define elf32_bed elf32_arm_vxworks_bed

#undef  bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create	elf32_arm_vxworks_link_hash_table_create
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_vxworks_final_write_processing
#undef  elf_backend_emit_relocs
#define elf_backend_emit_relocs			elf_vxworks_emit_relocs

#undef  elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p	0
#undef  elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p	1
#undef  elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p	1
#undef  elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	1
#undef  ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE			0x1000

#include "elf32-target.h"


/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
{
  flagword out_flags;
  flagword in_flags;
  bfd_boolean flags_compatible = TRUE;
  asection *sec;

  /* Check if we have the same endianness.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (! is_arm_elf (ibfd) || ! is_arm_elf (obfd))
    return TRUE;

  if (!elf32_arm_merge_eabi_attributes (ibfd, obfd))
    return FALSE;

  /* The input BFD must have had its flags initialised.  */
  /* The following seems bogus to me -- The flags are initialized in
     the assembler but I don't think an elf_flags_init field is
     written into the object.  */
  /* BFD_ASSERT (elf_flags_init (ibfd)); */

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  /* In theory there is no reason why we couldn't handle this.  However
     in practice it isn't even close to working and there is no real
     reason to want it.  */
  if (EF_ARM_EABI_VERSION (in_flags) >= EF_ARM_EABI_VER4
      && !(ibfd->flags & DYNAMIC)
      && (in_flags & EF_ARM_BE8))
    {
      _bfd_error_handler (_("error: %B is already in final BE8 format"),
			  ibfd);
      return FALSE;
    }

  if (!elf_flags_init (obfd))
    {
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
	 uninitialised values, which surprise surprise, correspond
	 to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Identical flags must be compatible.  */
  if (in_flags == out_flags)
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatiblity.  Do not short-circuit
     dynamic objects; their section list may be emptied by
    elf_link_add_object_symbols.

    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;
      bfd_boolean only_data_sections = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		only_data_sections = FALSE;

	      null_input_bfd = FALSE;
	      break;
	    }
	}

      if (null_input_bfd || only_data_sections)
	return TRUE;
    }

  /* Complain about various flag mismatches.  */
  if (!elf32_arm_versions_compatible (EF_ARM_EABI_VERSION (in_flags),
				      EF_ARM_EABI_VERSION (out_flags)))
    {
      _bfd_error_handler
	(_("error: Source object %B has EABI version %d, but target %B has EABI version %d"),
	 ibfd, obfd,
	 (in_flags & EF_ARM_EABIMASK) >> 24,
	 (out_flags & EF_ARM_EABIMASK) >> 24);
      return FALSE;
    }

  /* Not sure what needs to be checked for EABI versions >= 1.  */
  /* VxWorks libraries do not use these flags.  */
  if (get_elf_backend_data (obfd) != &elf32_arm_vxworks_bed
      && get_elf_backend_data (ibfd) != &elf32_arm_vxworks_bed
      && EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
    {
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	{
	  _bfd_error_handler
	    (_("error: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
	     ibfd, obfd,
	     in_flags & EF_ARM_APCS_26 ? 26 : 32,
	     out_flags & EF_ARM_APCS_26 ? 26 : 32);
	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	{
	  if (in_flags & EF_ARM_APCS_FLOAT)
	    _bfd_error_handler
	      (_("error: %B passes floats in float registers, whereas %B passes them in integer registers"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B passes floats in integer registers, whereas %B passes them in float registers"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_VFP_FLOAT) != (out_flags & EF_ARM_VFP_FLOAT))
	{
	  if (in_flags & EF_ARM_VFP_FLOAT)
	    _bfd_error_handler
	      (_("error: %B uses VFP instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B uses FPA instructions, whereas %B does not"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler
	      (_("error: %B uses Maverick instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B does not use Maverick instructions, whereas %B does"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
	{
	  /* We can allow interworking between code that is VFP format
	     layout, and uses either soft float or integer regs for
	     passing floating point arguments and results.  We already
	     know that the APCS_FLOAT flags match; similarly for VFP
	     flags.  */
	  if ((in_flags & EF_ARM_APCS_FLOAT) != 0
	      || (in_flags & EF_ARM_VFP_FLOAT) == 0)
	    {
	      if (in_flags & EF_ARM_SOFT_FLOAT)
		_bfd_error_handler
		  (_("error: %B uses software FP, whereas %B uses hardware FP"),
		   ibfd, obfd);
	      else
		_bfd_error_handler
		  (_("error: %B uses hardware FP, whereas %B uses software FP"),
		   ibfd, obfd);

	      flags_compatible = FALSE;
	    }
	}
#endif

      /* Interworking mismatch is only a warning.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (in_flags & EF_ARM_INTERWORK)
	    {
	      _bfd_error_handler
		(_("Warning: %B supports interworking, whereas %B does not"),
		 ibfd, obfd);
	    }
	  else
	    {
	      _bfd_error_handler
		(_("Warning: %B does not support interworking, whereas %B does"),
		 ibfd, obfd);
	    }
	}
    }

  return flags_compatible;
}


/* Symbian OS Targets.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM               bfd_elf32_littlearm_symbian_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME              "elf32-littlearm-symbian"
#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM                  bfd_elf32_bigarm_symbian_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME                 "elf32-bigarm-symbian"

/* Like elf32_arm_link_hash_table_create -- but overrides
   appropriately for Symbian OS.  */

static struct bfd_link_hash_table *
elf32_arm_symbian_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = elf32_arm_link_hash_table_create (abfd);
  if (ret)
    {
      struct elf32_arm_link_hash_table *htab
	= (struct elf32_arm_link_hash_table *)ret;
      /* There is no PLT header for Symbian OS.  */
      htab->plt_header_size = 0;
      /* The PLT entries are each one instruction and one word.  */
      htab->plt_entry_size = 4 * ARRAY_SIZE (elf32_arm_symbian_plt_entry);
      htab->symbian_p = 1;
      /* Symbian uses armv5t or above, so use_blx is always true.  */
      htab->use_blx = 1;
      htab->root.is_relocatable_executable = 1;
    }
  return ret;
}

static const struct bfd_elf_special_section
elf32_arm_symbian_special_sections[] =
{
  /* In a BPABI executable, the dynamic linking sections do not go in
     the loadable read-only segment.  The post-linker may wish to
     refer to these sections, but they are not part of the final
     program image.  */
  { STRING_COMMA_LEN (".dynamic"),       0, SHT_DYNAMIC,  0 },
  { STRING_COMMA_LEN (".dynstr"),        0, SHT_STRTAB,   0 },
  { STRING_COMMA_LEN (".dynsym"),        0, SHT_DYNSYM,   0 },
  { STRING_COMMA_LEN (".got"),           0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".hash"),          0, SHT_HASH,     0 },
  /* These sections do not need to be writable as the SymbianOS
     postlinker will arrange things so that no dynamic relocation is
     required.  */
  { STRING_COMMA_LEN (".init_array"),    0, SHT_INIT_ARRAY,    SHF_ALLOC },
  { STRING_COMMA_LEN (".fini_array"),    0, SHT_FINI_ARRAY,    SHF_ALLOC },
  { STRING_COMMA_LEN (".preinit_array"), 0, SHT_PREINIT_ARRAY, SHF_ALLOC },
  { NULL,                             0, 0, 0,                 0 }
};

static void
elf32_arm_symbian_begin_write_processing (bfd *abfd,
					  struct bfd_link_info *link_info)
{
  /* BPABI objects are never loaded directly by an OS kernel; they are
     processed by a postlinker first, into an OS-specific format.  If
     the D_PAGED bit is set on the file, BFD will align segments on
     page boundaries, so that an OS can directly map the file.  With
     BPABI objects, that just results in wasted space.  In addition,
     because we clear the D_PAGED bit, map_sections_to_segments will
     recognize that the program headers should not be mapped into any
     loadable segment.  */
  abfd->flags &= ~D_PAGED;
  elf32_arm_begin_write_processing (abfd, link_info);
}

static bfd_boolean
elf32_arm_symbian_modify_segment_map (bfd *abfd,
				      struct bfd_link_info *info)
{
  struct elf_segment_map *m;
  asection *dynsec;

  /* BPABI shared libraries and executables should have a PT_DYNAMIC
     segment.  However, because the .dynamic section is not marked
     with SEC_LOAD, the generic ELF code will not create such a
     segment.  */
  dynsec = bfd_get_section_by_name (abfd, ".dynamic");
  if (dynsec)
    {
      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
	if (m->p_type == PT_DYNAMIC)
	  break;

      if (m == NULL)
	{
	  m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
	  m->next = elf_seg_map (abfd);
	  elf_seg_map (abfd) = m;
	}
    }

  /* Also call the generic arm routine.  */
  return elf32_arm_modify_segment_map (abfd, info);
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf32_arm_symbian_plt_sym_val (bfd_vma i, const asection *plt,
			       const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + 4 * ARRAY_SIZE (elf32_arm_symbian_plt_entry) * i;
}


#undef  elf32_bed
#define elf32_bed elf32_arm_symbian_bed

/* The dynamic sections are not allocated on SymbianOS; the postlinker
   will process them and then discard them.  */
#undef  ELF_DYNAMIC_SEC_FLAGS
#define ELF_DYNAMIC_SEC_FLAGS \
  (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED)

#undef elf_backend_emit_relocs

#undef  bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create	elf32_arm_symbian_link_hash_table_create
#undef  elf_backend_special_sections
#define elf_backend_special_sections 		elf32_arm_symbian_special_sections
#undef  elf_backend_begin_write_processing
#define elf_backend_begin_write_processing	elf32_arm_symbian_begin_write_processing
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_final_write_processing

#undef  elf_backend_modify_segment_map
#define elf_backend_modify_segment_map elf32_arm_symbian_modify_segment_map

/* There is no .got section for BPABI objects, and hence no header.  */
#undef  elf_backend_got_header_size
#define elf_backend_got_header_size 0

/* Similarly, there is no .got.plt section.  */
#undef  elf_backend_want_got_plt
#define elf_backend_want_got_plt 0

#undef  elf_backend_plt_sym_val
#define elf_backend_plt_sym_val		elf32_arm_symbian_plt_sym_val

#undef  elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p	1
#undef  elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p	0
#undef  elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p	0
#undef  elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	0
#undef  ELF_MAXPAGESIZE
#define ELF_MAXPAGESIZE			0x8000

#include "elf32-target.h"
@


1.323
log
@	PR ld/15787
	* elf32-arm.c (elf32_arm_final_link_relocate): Use origin of output
	segment containing the relocating symbol instead of assuming 0 for
	sb group relocations.

	* ld-arm/group-relocs-ldr-bad.s: Redefine bar into foo section
	beyond 16 bit offset width.
	* ld-arm/group-relocs-ldrs-bad.s: Likewise.
	* ld-arm/group-relocs-ldr-bad.d: Adjust expected result.
	* ld-arm/group-relocs-ldrs-bad.d: Likewise.
	* ld-arm/group-relocs.s: Add comments.  Move symbols used for sb
	group relocations into .data section.  Drop section zero.  Use pc/r0
	as base register when pc/sb group relocations are used.
	* ld-arm/group-relocs.d: Adjust expected result.
	* ld-arm/group-relocs-alu-bad-2.d: New test for sb group relocation.
	* ld-arm/group-relocs-ldc-bad-2.d: Likewise.
	* ld-arm/group-relocs-ldr-bad-2.d: New test for pc group relocation.
	* ld-arm/group-relocs-ldrs-bad-2.d: Likewise.
	* ld-arm/unresolved-2.d: Add sb relocation failure test.
	* ld-arm/group-relocs-alu-bad-2.s: New test source.
	* ld-arm/group-relocs-ldr-bad-2.s: Likewise.
	* ld-arm/group-relocs-ldrs-bad-2.s: Likewise.
	* ld-arm/group-relocs-ldc-bad-2.s: Likewise.
	* ld-arm/unresolved-2.s: Likewise.
	* ld-arm/arm-elf.exp: For group-relocs, drop section zero start
	definition.  Run the new tests.
@
text
@d15863 8
d15882 2
d15887 3
d15898 7
@


1.322
log
@	PR ld/15787
	* elf32-arm.c (elf32_arm_final_link_relocate): Base SB on the
	output section VMA.

	* ld-arm/group-relocs-alu-bad-2.d; New.
	* ld-arm/group-relocs-alu-bad-2.s: New.
	* ld-arm/group-relocs-ldc-bad-2.d: New.
	* ld-arm/group-relocs-ldc-bad-2.s: New.
	* ld-arm/group-relocs-ldr-bad-2.d: New.
	* ld-arm/group-relocs-ldr-bad-2.s: New.
	* ld-arm/group-relocs-ldrs-bad-2.d: New.
	* ld-arm/group-relocs-ldrs-bad-2: New.
	* ld-arm/arm-elf.exp: Add the new tests.
	* ld-arm/group-relocs-ldr-bad.d: Update expected output.
	* ld-arm/group-relocs-ldr-bad.s: Likewise.
	* ld-arm/group-relocs-ldrs-bad.d: Likewise.
	* ld-arm/group-relocs-ldrs-bad.s: Likewise.
	* ld-arm/group-relocs.d: Likewise.
	* ld-arm/group-relocs.s: Likewise.
@
text
@d9856 1
a9856 1
	bfd_vma sb = sym_sec->output_section->vma;
d9990 1
a9990 1
	bfd_vma sb = sym_sec->output_section->vma;
d10074 1
a10074 1
	bfd_vma sb = sym_sec->output_section->vma;
d10158 1
a10158 1
	bfd_vma sb = sym_sec->output_section->vma;
@


1.321
log
@        * elf32-arm.c (arm_type_of_stub): Don't use ST_BRANCH_TO_ARM for
thumb only targets.
        (elf32_arm_final_link_relocate): Likewise.

        * ld-arm/thumb-b-lks-sym.d: Updated to be more flexible.
        * ld-arm/thumb-bl-lks-sym.d: Likewise.
@
text
@d9855 2
a9856 4
	/* sb should be the origin of the *segment* containing the symbol.
	   It is not clear how to obtain this OS-dependent value, so we
	   make an arbitrary choice of zero.  */
	bfd_vma sb = 0;
d9989 2
a9990 1
	bfd_vma sb = 0; /* See note above.  */
d10073 2
a10074 1
	bfd_vma sb = 0; /* See note above.  */
d10157 2
a10158 1
	bfd_vma sb = 0; /* See note above.  */
@


1.320
log
@	* elf32-arm.c (elf32_arm_stub_long_branch_arm_nacl): New variable.
	(elf32_arm_stub_long_branch_arm_nacl_pic): New variable.
	(arm_build_one_stub): Increase MAXRELOCS to 3.
	(arm_type_of_stub): Use them if GLOBALS->nacl_p.
	(struct elf32_arm_link_hash_table): Give add_stub_section member's
	pointee type a third argument.
	(elf32_arm_create_or_find_stub_sec): Update caller.
	(elf32_arm_size_stubs): Update argument type.
	* bfd-in.h (elf32_arm_size_stubs): Update decl.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* emultempl/armelf.em (elf32_arm_add_stub_section): Take third
	argument ALIGNMENT_POWER, use it instead of constant 3.

	* ld-arm/farcall-arm-nacl.d: New file.
	* ld-arm/farcall-arm-nacl-pic.d: New file.
	* ld-arm/farcall-data-nacl.d: New file.
	* ld-arm/arm-elf.exp (armeabitests_common): Add extra element to
	"action" lists for those cases to use a different dump file for NaCl
	targets.
	Massage $armeabitests_common to drop the extra element or the one
	before it, depending on [istarget "arm*-*-nacl*"].

	* ld-arm/arm-elf.exp (armelftests_common): Move all "Cortex-A8
	erratum fix", Thumb-only and interworking cases to ...
	(armelftests_nonacl): ... here.
	(armeabitests_common): Move all "erratum 760522 fix", Thumb-only
	and interworking cases to ...
	(armeabitests_nonacl): ... here.
@
text
@d3612 6
d8132 8
@


1.319
log
@	PR ld/15302
	* elf32-arm.c (allocate_dynrelocs_for_symbol): Revert previous patch.
@
text
@d2418 27
d2521 2
d3015 1
a3015 1
  asection * (*add_stub_section) (const char *, asection *);
d3804 3
a3806 1
		   : arm_stub_long_branch_any_arm_pic)
d3808 3
a3810 1
		: arm_stub_long_branch_any_any;
d3946 2
a3947 1
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
d4080 4
d4093 1
a4093 1
#define MAXRELOCS 2
d4905 2
a4906 1
		      asection * (*add_stub_section) (const char *, asection *),
@


1.318
log
@	PR ld/15302
	* elf32-arm.c (allocate_dynrelocs_for_symbol): Transform
	ST_BRANCH_TO_ARM into ST_BRANCH_TO_THUMB if the target only
	supports thumb instructions.

	PR ld/15302
	* ld-arm/branch-lks-sym.ld: New script.
	* ld-arm/thumb-b-lks-sym.s: New test.
	* ld-arm/thumb-b-lks-sym.d: Expected disassembly.
	* ld-arm/thumb-bl-lks-sym.s: New test.
	* ld-arm/thumb-bl-lks-sym.d: Expected disassembly.
	* ld-arm/arm-elf.exp: Run the new tests.
@
text
@a13342 6
  /* Make sure we are not applying ST_BRANCH_TO_ARM to symbols
     for thumb-only targets.  */
  if (using_thumb_only (htab)
      && h->target_internal == ST_BRANCH_TO_ARM)
    h->target_internal = ST_BRANCH_TO_THUMB;

@


1.317
log
@bfd/efl32-arm.c: Fix handling of IRELATIVE relocs.

bfd/ChangeLog:

2013-04-24  Will Newton  <will.newton@@linaro.org>

	* elf32-arm.c (elf32_arm_populate_plt_entry): Call
	elf32_arm_add_dynreloc when emitting R_ARM_IRELATIVE relocs.

ld/testsuite/ChangeLog:

2013-04-24  Will Newton  <will.newton@@linaro.org>

	* ld-arm/arm-elf.exp: Add IFUNC test 17.
	* ld-arm/ifunc-17.dd: New file.
	* ld-arm/ifunc-17.gd: Likewise.
	* ld-arm/ifunc-17.rd: Likewise.
	* ld-arm/ifunc-17.s: Likweise.
	* ld-arm/ifunc-1.rd: Reorder relocs to match linker output.
	* ld-arm/ifunc-2.rd: Likewise.
	* ld-arm/ifunc-5.rd: Likewise.
	* ld-arm/ifunc-6.rd: Likewise.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
d13343 6
@


1.316
log
@bfd/
	* elf32-arm.c (elf32_arm_allocate_plt_entry): If HTAB->nacl_p,
	allocate space for PLT header even if IS_IPLT_ENTRY.
	(arm_nacl_put_plt0): New function, broken out of ...
	(elf32_arm_finish_dynamic_sections): ... here.  Call it.
	If HTAB->nacl_p, set up the PLT header in .iplt too.
	(elf32_arm_output_arch_local_syms): If HTAB->nacl_p, write
	a mapping symbol for the start of .iplt too.
@
text
@d7702 7
a7708 2
  loc = srel->contents + plt_index * RELOC_SIZE (htab);
  SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
@


1.315
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
d330 12
a341 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_DTPMOD32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d344 12
a355 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_DTPOFF32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d358 12
a369 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_TPOFF32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d374 12
a385 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_COPY",		/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d388 12
a399 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_GLOB_DAT",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d402 12
a413 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_JUMP_SLOT",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d416 12
a427 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_RELATIVE",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d430 12
a441 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_GOTOFF32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d444 12
a455 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         TRUE,			/* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_GOTPC",		/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         TRUE),			/* pcrel_offset */
d458 12
a469 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,			/* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_GOT32",		/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),		/* pcrel_offset */
d472 12
a483 12
         2,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         24,                    /* bitsize */
         TRUE,			/* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_PLT32",		/* name */
         FALSE,			/* partial_inplace */
         0x00ffffff,		/* src_mask */
         0x00ffffff,		/* dst_mask */
         TRUE),			/* pcrel_offset */
d1490 12
a1501 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_ARM_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d1505 12
a1516 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_ARM_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d1548 12
a1559 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         NULL,			/* special_function */
         "R_ARM_TLS_GD32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d1562 12
a1573 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LDM32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d1576 12
a1587 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LDO32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d1590 12
a1601 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                  /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         NULL,			/* special_function */
         "R_ARM_TLS_IE32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d1604 12
a1615 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LE32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d1699 12
a1710 12
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_IRELATIVE",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE)			/* pcrel_offset */
d2101 1
a2101 1
		   		+ dl_tlsdesc_lazy_resolver(GOT)   */
d3007 2
a3008 2
                             struct bfd_hash_table * table,
                             const char * string)
d3017 1
a3017 1
        bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
d3191 1
a3191 1
          bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
d3628 1
a3628 1
           distance)
d3630 3
a3632 3
           Thumb->Arm branch (not bl). A stub is needed in this case,
           but only if this call is not through a PLT entry. Indeed,
           PLT stubs handle mode switching already.
d4111 5
a4115 5
                /* We've borrowed the reloc_addend field to mean we should
                   insert a condition code into this (Thumb-1 branch)
                   instruction.  See THUMB16_BCOND_INSN.  */
                BFD_ASSERT ((data & 0xff00) == 0xd000);
                data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
d4128 7
a4134 7
          if (template_sequence[i].r_type != R_ARM_NONE)
            {
              stub_reloc_idx[nrelocs] = i;
              stub_reloc_offset[nrelocs++] = size;
            }
          size += 4;
          break;
d4192 1
a4192 1
                                   template_sequence[stub_reloc_idx[i]].r_type);
d4225 1
a4225 1
                                   template_sequence[stub_reloc_idx[i]].r_type);
d4455 9
a4463 9
        {
          /* Pop from tail.  */
          asection *item = tail;
          tail = PREV_SEC (item);

          /* Push on head.  */
          NEXT_SEC (item) = head;
          head = item;
        }
d4582 5
a4586 5
          || (elf_section_flags (section) & SHF_EXECINSTR) == 0
          || (section->flags & SEC_EXCLUDE) != 0
          || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
          || (section->output_section == bfd_abs_section_ptr))
        continue;
d4591 1
a4591 1
        contents = elf_section_data (section)->this_hdr.contents;
d4593 1
a4593 1
        return TRUE;
d4598 7
a4604 7
        {
          unsigned int span_start = sec_data->map[span].vma;
          unsigned int span_end = (span == sec_data->mapcount - 1)
            ? section->size : sec_data->map[span + 1].vma;
          unsigned int i;
          char span_type = sec_data->map[span].type;
          bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;
d4606 2
a4607 2
          if (span_type != 't')
            continue;
d4609 2
a4610 2
          /* Span is entirely within a single 4KB region: skip scanning.  */
          if (((base_vma + span_start) & ~0xfff)
d4612 1
a4612 1
            continue;
d4614 1
a4614 1
          /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
d4616 9
a4624 9
               * The opcode is BLX.W, BL.W, B.W, Bcc.W
               * The branch target is in the same 4KB region as the
                 first half of the branch.
               * The instruction before the branch is a 32-bit
                 length non-branch instruction.  */
          for (i = span_start; i < span_end;)
            {
              unsigned int insn = bfd_getl16 (&contents[i]);
              bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;
d4627 2
a4628 2
              if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)
                insn_32bit = TRUE;
d4631 10
a4640 10
	        {
                  /* Load the rest of the insn (in manual-friendly order).  */
                  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);

        	  /* Encoding T4: B<c>.W.  */
        	  is_b = (insn & 0xf800d000) == 0xf0009000;
        	  /* Encoding T1: BL<c>.W.  */
        	  is_bl = (insn & 0xf800d000) == 0xf000d000;
        	  /* Encoding T2: BLX<c>.W.  */
        	  is_blx = (insn & 0xf800d000) == 0xf000c000;
d4648 1
a4648 1
              if (((base_vma + i) & 0xfff) == 0xffe
d4653 3
a4655 3
                {
                  bfd_signed_vma offset = 0;
                  bfd_boolean force_target_arm = FALSE;
d4657 10
a4666 10
                  bfd_vma target;
                  enum elf32_arm_stub_type stub_type = arm_stub_none;
                  struct a8_erratum_reloc key, *found;
                  bfd_boolean use_plt = FALSE;

                  key.from = base_vma + i;
                  found = (struct a8_erratum_reloc *)
                      bsearch (&key, a8_relocs, num_a8_relocs,
                               sizeof (struct a8_erratum_reloc),
                               &a8_reloc_compare);
d4674 1
a4674 1
		         function, only if there is glue or not.  */
d4696 1
a4696 1
                  /* Check if we have an offending branch instruction.  */
d4704 37
a4740 37
                  else if (is_bcc)
                    {
                      offset = (insn & 0x7ff) << 1;
                      offset |= (insn & 0x3f0000) >> 4;
                      offset |= (insn & 0x2000) ? 0x40000 : 0;
                      offset |= (insn & 0x800) ? 0x80000 : 0;
                      offset |= (insn & 0x4000000) ? 0x100000 : 0;
                      if (offset & 0x100000)
                        offset |= ~ ((bfd_signed_vma) 0xfffff);
                      stub_type = arm_stub_a8_veneer_b_cond;
                    }
                  else if (is_b || is_bl || is_blx)
                    {
                      int s = (insn & 0x4000000) != 0;
                      int j1 = (insn & 0x2000) != 0;
                      int j2 = (insn & 0x800) != 0;
                      int i1 = !(j1 ^ s);
                      int i2 = !(j2 ^ s);

                      offset = (insn & 0x7ff) << 1;
                      offset |= (insn & 0x3ff0000) >> 4;
                      offset |= i2 << 22;
                      offset |= i1 << 23;
                      offset |= s << 24;
                      if (offset & 0x1000000)
                        offset |= ~ ((bfd_signed_vma) 0xffffff);

                      if (is_blx)
                        offset &= ~ ((bfd_signed_vma) 3);

                      stub_type = is_blx ? arm_stub_a8_veneer_blx :
                        is_bl ? arm_stub_a8_veneer_bl : arm_stub_a8_veneer_b;
                    }

                  if (stub_type != arm_stub_none)
                    {
                      bfd_vma pc_for_insn = base_vma + i + 4;
d4743 1
a4743 1
		         an ARM instruction.  If we were not making a stub,
d4764 2
a4765 2
                      if (is_blx)
                        pc_for_insn &= ~ ((bfd_vma) 3);
d4767 2
a4768 2
                      /* If we found a relocation, use the proper destination,
		         not the offset in the (unrelocated) instruction.
d4771 2
a4772 2
                      if (found)
                        offset =
d4775 5
a4779 5
                      /* If the stub will use a Thumb-mode branch to a
                         PLT target, redirect it to the preceding Thumb
                         entry point.  */
                      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
                        offset -= PLT_THUMB_STUB_SIZE;
d4781 1
a4781 1
                      target = pc_for_insn + offset;
d4783 2
a4784 2
                      /* The BLX stub is ARM-mode code.  Adjust the offset to
		         take the different PC value (+8 instead of +4) into
d4786 2
a4787 2
                      if (stub_type == arm_stub_a8_veneer_blx)
                        offset += 4;
d4789 12
a4800 12
                      if (((base_vma + i) & ~0xfff) == (target & ~0xfff))
                        {
                          char *stub_name = NULL;

                          if (num_a8_fixes == a8_fix_table_size)
                            {
                              a8_fix_table_size *= 2;
                              a8_fixes = (struct a8_erratum_fix *)
                                  bfd_realloc (a8_fixes,
                                               sizeof (struct a8_erratum_fix)
                                               * a8_fix_table_size);
                            }
d4825 8
a4832 8
                          a8_fixes[num_a8_fixes].input_bfd = input_bfd;
                          a8_fixes[num_a8_fixes].section = section;
                          a8_fixes[num_a8_fixes].offset = i;
                          a8_fixes[num_a8_fixes].addend = offset;
                          a8_fixes[num_a8_fixes].orig_insn = insn;
                          a8_fixes[num_a8_fixes].stub_name = stub_name;
                          a8_fixes[num_a8_fixes].stub_type = stub_type;
                          a8_fixes[num_a8_fixes].branch_type =
d4835 4
a4838 4
                          num_a8_fixes++;
                        }
                    }
                }
d4840 2
a4841 2
              i += insn_32bit ? 4 : 2;
              last_was_32bit = insn_32bit;
d4843 2
a4844 2
            }
        }
d4847 1
a4847 1
        free (contents);
d4885 1
a4885 1
          bfd_zmalloc (sizeof (struct a8_erratum_fix) * a8_fix_table_size);
d4887 1
a4887 1
          bfd_zmalloc (sizeof (struct a8_erratum_reloc) * a8_reloc_table_size);
d4955 2
a4956 2
          if (!is_arm_elf (input_bfd))
            continue;
d5229 21
a5249 21
                      stub_entry->target_value = sym_value;
                      stub_entry->target_section = sym_sec;
                      stub_entry->stub_type = stub_type;
                      stub_entry->h = hash;
                      stub_entry->branch_type = branch_type;

                      if (sym_name == NULL)
                	sym_name = "unnamed";
                      stub_entry->output_name = (char *)
                          bfd_alloc (htab->stub_bfd,
                                     sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
                                     + strlen (sym_name));
                      if (stub_entry->output_name == NULL)
                	{
                          free (stub_name);
                          goto error_ret_free_internal;
                	}

                      /* For historical reasons, use the existing names for
                	 ARM-to-Thumb and Thumb-to-ARM stubs.  */
                      if ((r_type == (unsigned int) R_ARM_THM_CALL
d5252 3
a5254 3
                	sprintf (stub_entry->output_name,
                        	 THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
                      else if ((r_type == (unsigned int) R_ARM_CALL
d5257 55
a5311 55
                	sprintf (stub_entry->output_name,
                        	 ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
                      else
                	sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
                        	 sym_name);

                      stub_changed = TRUE;
                    }
                  while (0);

                  /* Look for relocations which might trigger Cortex-A8
                     erratum.  */
                  if (htab->fix_cortex_a8
                      && (r_type == (unsigned int) R_ARM_THM_JUMP24
                          || r_type == (unsigned int) R_ARM_THM_JUMP19
                          || r_type == (unsigned int) R_ARM_THM_CALL
                          || r_type == (unsigned int) R_ARM_THM_XPC22))
                    {
                      bfd_vma from = section->output_section->vma
                                     + section->output_offset
                                     + irela->r_offset;

                      if ((from & 0xfff) == 0xffe)
                        {
                          /* Found a candidate.  Note we haven't checked the
                             destination is within 4K here: if we do so (and
                             don't create an entry in a8_relocs) we can't tell
                             that a branch should have been relocated when
                             scanning later.  */
                          if (num_a8_relocs == a8_reloc_table_size)
                            {
                              a8_reloc_table_size *= 2;
                              a8_relocs = (struct a8_erratum_reloc *)
                                  bfd_realloc (a8_relocs,
                                               sizeof (struct a8_erratum_reloc)
                                               * a8_reloc_table_size);
                            }

                          a8_relocs[num_a8_relocs].from = from;
                          a8_relocs[num_a8_relocs].destination = destination;
                          a8_relocs[num_a8_relocs].r_type = r_type;
                          a8_relocs[num_a8_relocs].branch_type = branch_type;
                          a8_relocs[num_a8_relocs].sym_name = sym_name;
                          a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
                          a8_relocs[num_a8_relocs].hash = hash;

                          num_a8_relocs++;
                        }
                    }
		}

              /* We're done with the internal relocs, free them.  */
              if (elf_section_data (section)->relocs == NULL)
                free (internal_relocs);
            }
d5313 1
a5313 1
          if (htab->fix_cortex_a8)
d5315 2
a5316 2
              /* Sort relocs which might apply to Cortex-A8 erratum.  */
              qsort (a8_relocs, num_a8_relocs,
d5318 1
a5318 1
                     &a8_reloc_compare);
d5320 2
a5321 2
              /* Scan for branches which might trigger Cortex-A8 erratum.  */
              if (cortex_a8_erratum_scan (input_bfd, info, &a8_fixes,
d5331 1
a5331 1
        stub_changed = TRUE;
d5353 2
a5354 2
        for (i = 0; i < num_a8_fixes; i++)
          {
d5361 4
a5364 4
            stub_sec->size
              += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
                                              NULL);
          }
d5375 28
a5402 28
        {
          struct elf32_arm_stub_hash_entry *stub_entry;
          char *stub_name = a8_fixes[i].stub_name;
          asection *section = a8_fixes[i].section;
          unsigned int section_id = a8_fixes[i].section->id;
          asection *link_sec = htab->stub_group[section_id].link_sec;
          asection *stub_sec = htab->stub_group[section_id].stub_sec;
          const insn_sequence *template_sequence;
          int template_size, size = 0;

          stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
                                             TRUE, FALSE);
          if (stub_entry == NULL)
            {
              (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
                                     section->owner,
                                     stub_name);
              return FALSE;
            }

          stub_entry->stub_sec = stub_sec;
          stub_entry->stub_offset = 0;
          stub_entry->id_sec = link_sec;
          stub_entry->stub_type = a8_fixes[i].stub_type;
          stub_entry->target_section = a8_fixes[i].section;
          stub_entry->target_value = a8_fixes[i].offset;
          stub_entry->target_addend = a8_fixes[i].addend;
          stub_entry->orig_insn = a8_fixes[i].orig_insn;
d5405 8
a5412 8
          size = find_stub_size_and_template (a8_fixes[i].stub_type,
                                              &template_sequence,
                                              &template_size);

          stub_entry->stub_size = size;
          stub_entry->stub_template = template_sequence;
          stub_entry->stub_template_size = template_size;
        }
d5415 1
a5415 1
         elf32_arm_write_section().  */
d5495 1
a5495 1
                                  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d5531 1
a5531 1
                                  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d5598 6
a5603 6
                                        .arm
		 		    ;; back_to_thumb
                 		        ldmia r13! {r6, lr}
 				        bx    lr
                                    __func_addr:
                                        .word        func  */
d5700 1
a5700 1
                                  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d5791 2
a5792 2
                                    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
                                    NULL, TRUE, FALSE, &bh);
d5815 1
a5815 1
          bfd_malloc (sizeof (elf32_arm_section_map));
d5826 2
a5827 2
          bfd_realloc_or_free (sec_data->map, sec_data->mapsize
                               * sizeof (elf32_arm_section_map));
d5843 4
a5846 4
                             elf32_vfp11_erratum_list *branch,
                             bfd *branch_bfd,
                             asection *branch_sec,
                             unsigned int offset)
d5869 1
a5869 1
                                  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d5884 2
a5885 2
                                    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
                                    NULL, TRUE, FALSE, &bh);
d5932 1
a5932 1
         ever requires this erratum fix.  */
d5936 1
a5936 1
                                        TRUE, FALSE, &bh);
d5943 3
a5945 3
         BFDs.  We must make a note of this generated mapping symbol
         ourselves so that code byteswapping works properly in
         elf32_arm_write_section.  */
d6178 2
a6179 2
	         the target of the call.  If it is a thumb target, we
	         insert glue.  */
d6251 4
a6254 4
          && ELF_ST_BIND (isym->st_info) == STB_LOCAL)
        {
          name = bfd_elf_string_from_elf_section (abfd,
            hdr->sh_link, isym->st_name);
d6256 1
a6256 1
          if (bfd_is_arm_special_symbol_name (name,
d6258 2
a6259 2
            elf32_arm_section_map_add (sec, name[1], isym->st_value);
        }
d6301 11
a6311 11
        {
        case BFD_ARM_VFP11_FIX_DEFAULT:
        case BFD_ARM_VFP11_FIX_NONE:
          globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
          break;

        default:
          /* Give a warning, but do as the user requests anyway.  */
          (*_bfd_error_handler) (_("%B: warning: selected VFP11 erratum "
            "workaround is not necessary for target architecture"), obfd);
        }
d6343 1
a6343 1
                     unsigned int x)
d6375 1
a6375 1
        return TRUE;
d6380 1
a6380 1
        continue;
d6383 1
a6383 1
        return TRUE;
d6399 1
a6399 1
                           int *numregs)
d6411 2
a6412 2
           | ((insn & 0x00300000) >> 19)
           | ((insn & 0x00000040) >> 6);
d6415 33
a6447 64
        {
        case 0: /* fmac[sd].  */
        case 1: /* fnmac[sd].  */
        case 2: /* fmsc[sd].  */
        case 3: /* fnmsc[sd].  */
          vpipe = VFP11_FMAC;
          bfd_arm_vfp11_write_mask (destmask, fd);
          regs[0] = fd;
          regs[1] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);  /* Fn.  */
          regs[2] = fm;
          *numregs = 3;
          break;

        case 4: /* fmul[sd].  */
        case 5: /* fnmul[sd].  */
        case 6: /* fadd[sd].  */
        case 7: /* fsub[sd].  */
          vpipe = VFP11_FMAC;
          goto vfp_binop;

        case 8: /* fdiv[sd].  */
          vpipe = VFP11_DS;
          vfp_binop:
          bfd_arm_vfp11_write_mask (destmask, fd);
          regs[0] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);   /* Fn.  */
          regs[1] = fm;
          *numregs = 2;
          break;

        case 15: /* extended opcode.  */
          {
            unsigned int extn = ((insn >> 15) & 0x1e)
                              | ((insn >> 7) & 1);

            switch (extn)
              {
              case 0: /* fcpy[sd].  */
              case 1: /* fabs[sd].  */
              case 2: /* fneg[sd].  */
              case 8: /* fcmp[sd].  */
              case 9: /* fcmpe[sd].  */
              case 10: /* fcmpz[sd].  */
              case 11: /* fcmpez[sd].  */
              case 16: /* fuito[sd].  */
              case 17: /* fsito[sd].  */
              case 24: /* ftoui[sd].  */
              case 25: /* ftouiz[sd].  */
              case 26: /* ftosi[sd].  */
              case 27: /* ftosiz[sd].  */
                /* These instructions will not bounce due to underflow.  */
                *numregs = 0;
                vpipe = VFP11_FMAC;
                break;

              case 3: /* fsqrt[sd].  */
                /* fsqrt cannot underflow, but it can (perhaps) overwrite
                   registers to cause the erratum in previous instructions.  */
                bfd_arm_vfp11_write_mask (destmask, fd);
                vpipe = VFP11_DS;
                break;

              case 15: /* fcvt{ds,sd}.  */
                {
                  int rnum = 0;
d6449 32
a6480 1
                  bfd_arm_vfp11_write_mask (destmask, fd);
d6483 2
a6484 2
                  if ((insn & 0x100) != 0)
                    regs[rnum++] = fm;
d6486 1
a6486 1
                  *numregs = rnum;
d6488 13
a6500 13
                  vpipe = VFP11_FMAC;
                }
                break;

              default:
                return VFP11_BAD;
              }
          }
          break;

        default:
          return VFP11_BAD;
        }
d6509 7
a6515 7
          if (is_double)
            bfd_arm_vfp11_write_mask (destmask, fm);
          else
            {
              bfd_arm_vfp11_write_mask (destmask, fm);
              bfd_arm_vfp11_write_mask (destmask, fm + 1);
            }
d6526 26
a6551 26
        {
        case 0: /* Two-reg transfer.  We should catch these above.  */
          abort ();

        case 2: /* fldm[sdx].  */
        case 3:
        case 5:
          {
            unsigned int i, offset = insn & 0xff;

            if (is_double)
              offset >>= 1;

            for (i = fd; i < fd + offset; i++)
              bfd_arm_vfp11_write_mask (destmask, i);
          }
          break;

        case 4: /* fld[sd].  */
        case 6:
          bfd_arm_vfp11_write_mask (destmask, fd);
          break;

        default:
          return VFP11_BAD;
        }
d6562 12
a6573 12
        {
        case 0: /* fmsr/fmdlr.  */
        case 1: /* fmdhr.  */
          /* Mark fmdhr and fmdlr as writing to the whole of the DP
             destination register.  I don't know if this is exactly right,
             but it is the conservative choice.  */
          bfd_arm_vfp11_write_mask (destmask, fn);
          break;

        case 7: /* fmxr.  */
          break;
        }
d6607 3
a6609 3
           A VFP FMAC-pipeline instruction has been seen. Fill
           regs[0]..regs[numregs-1] with its input operands. Remember this
           instruction in 'first_fmac'.
d6612 2
a6613 2
           Any instruction, except for a VFP instruction which overwrites
           regs[*].
d6617 3
a6619 3
           A VFP instruction has been seen which overwrites any of regs[*].
           We must make a veneer!  Reset state to 0 before examining next
           instruction.
d6622 2
a6623 2
           If we fail to match anything in state 2, reset to state 0 and reset
           the instruction pointer to the instruction after 'first_fmac'.
d6654 1
a6654 1
         section.  Also skip if section is to be excluded.  */
d6656 2
a6657 2
          || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
          || (sec->flags & SEC_EXCLUDE) != 0
d6660 2
a6661 2
          || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
        continue;
d6666 1
a6666 1
        continue;
d6677 3
a6679 3
        {
          unsigned int span_start = sec_data->map[span].vma;
          unsigned int span_end = (span == sec_data->mapcount - 1)
d6681 37
a6717 1
          char span_type = sec_data->map[span].type;
d6719 4
a6722 40
          /* FIXME: Only ARM mode is supported at present.  We may need to
             support Thumb-2 mode also at some point.  */
          if (span_type != 'a')
            continue;

          for (i = span_start; i < span_end;)
            {
              unsigned int next_i = i + 4;
              unsigned int insn = bfd_big_endian (abfd)
                ? (contents[i] << 24)
                  | (contents[i + 1] << 16)
                  | (contents[i + 2] << 8)
                  | contents[i + 3]
                : (contents[i + 3] << 24)
                  | (contents[i + 2] << 16)
                  | (contents[i + 1] << 8)
                  | contents[i];
              unsigned int writemask = 0;
              enum bfd_arm_vfp11_pipe vpipe;

              switch (state)
                {
                case 0:
                  vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
                                                    &numregs);
                  /* I'm assuming the VFP11 erratum can trigger with denorm
                     operands on either the FMAC or the DS pipeline. This might
                     lead to slightly overenthusiastic veneer insertion.  */
                  if (vpipe == VFP11_FMAC || vpipe == VFP11_DS)
                    {
                      state = use_vector ? 1 : 2;
                      first_fmac = i;
                      veneer_of_insn = insn;
                    }
                  break;

                case 1:
                  {
                    int other_regs[3], other_numregs;
                    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6724 3
a6726 3
                                                      &other_numregs);
                    if (vpipe != VFP11_BAD
                        && bfd_arm_vfp11_antidependency (writemask, regs,
d6728 10
a6737 10
                      state = 3;
                    else
                      state = 2;
                  }
                  break;

                case 2:
                  {
                    int other_regs[3], other_numregs;
                    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6739 3
a6741 3
                                                      &other_numregs);
                    if (vpipe != VFP11_BAD
                        && bfd_arm_vfp11_antidependency (writemask, regs,
d6743 8
a6750 31
                      state = 3;
                    else
                      {
                        state = 0;
                        next_i = first_fmac + 4;
                      }
                  }
                  break;

                case 3:
                  abort ();  /* Should be unreachable.  */
                }

              if (state == 3)
                {
                  elf32_vfp11_erratum_list *newerr =(elf32_vfp11_erratum_list *)
                      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));

                  elf32_arm_section_data (sec)->erratumcount += 1;

                  newerr->u.b.vfp_insn = veneer_of_insn;

                  switch (span_type)
                    {
                    case 'a':
                      newerr->type = VFP11_ERRATUM_BRANCH_TO_ARM_VENEER;
                      break;

                    default:
                      abort ();
                    }
d6752 24
a6775 1
                  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
d6778 1
a6778 1
                  newerr->vma = -1;
d6780 2
a6781 2
                  newerr->next = sec_data->erratumlist;
                  sec_data->erratumlist = newerr;
d6783 2
a6784 2
                  state = 0;
                }
d6786 3
a6788 3
              i = next_i;
            }
        }
d6791 2
a6792 2
          && elf_section_data (sec)->this_hdr.contents != contents)
        free (contents);
d6829 1
a6829 1
                                  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d6837 10
a6846 10
        {
          struct elf_link_hash_entry *myh;
          bfd_vma vma;

          switch (errnode->type)
            {
            case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
            case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
              /* Find veneer symbol.  */
              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
d6849 6
a6854 2
              myh = elf_link_hash_lookup
                (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d6856 3
a6858 7
              if (myh == NULL)
                (*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
                			 "`%s'"), abfd, tmp_name);

              vma = myh->root.u.def.section->output_section->vma
                    + myh->root.u.def.section->output_offset
                    + myh->root.u.def.value;
d6860 2
a6861 2
              errnode->u.b.veneer->vma = vma;
              break;
d6864 4
a6867 4
            case VFP11_ERRATUM_THUMB_VENEER:
              /* Find return location.  */
              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
                       errnode->u.v.id);
d6869 2
a6870 2
              myh = elf_link_hash_lookup
                (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d6872 2
a6873 2
              if (myh == NULL)
                (*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
d6876 11
a6886 11
              vma = myh->root.u.def.section->output_section->vma
                    + myh->root.u.def.section->output_offset
                    + myh->root.u.def.value;

              errnode->u.v.branch->vma = vma;
              break;

            default:
              abort ();
            }
        }
d6900 1
a6900 1
                                 int fix_v4bx,
d6902 1
a6902 1
                                 bfd_arm_vfp11_fix vfp11_fix,
d7397 4
d7623 1
a7623 1
                              - (plt_address + htab->plt_entry_size));
d7937 1
a7937 1
        shift = 0;
d7939 2
a7940 2
        {
          int msb;
d7942 12
a7953 12
          /* Determine the most significant bit in the residual and
             align the resulting value to a 2-bit boundary.  */
          for (msb = 30; msb >= 0; msb -= 2)
            if (residual & (3 << msb))
              break;

          /* The desired shift is now (msb - 6), or zero, whichever
             is the greater.  */
          shift = msb - 6;
          if (shift < 0)
            shift = 0;
        }
d7958 1
a7958 1
                    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);
d8170 1
a8170 1
           && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI
d8587 1
a8587 1
             | bfd_get_16 (input_bfd, hit_data + 2);
d8589 7
a8595 7
        if (globals->use_rel)
          {
            signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
                          | ((insn & (1 << 26)) >> 15);
            if (insn & 0xf00000)
              signed_addend = -signed_addend;
          }
d8599 2
a8600 2
		          + input_section->output_offset
		          + rel->r_offset);
d8602 1
a8602 1
        value = abs (relocation);
d8604 2
a8605 2
        if (value >= 0x1000)
          return bfd_reloc_overflow;
d8608 4
a8611 4
             | ((value & 0x700) << 4)
             | ((value & 0x800) << 15);
        if (relocation < 0)
          insn |= 0xa00000;
d8616 1
a8616 1
        return bfd_reloc_ok;
d8629 1
a8629 1
        if (globals->use_rel)
d8634 2
a8635 2
		          + input_section->output_offset
		          + rel->r_offset);
d8637 1
a8637 1
        value = abs (relocation);
d8650 1
a8650 1
        return bfd_reloc_ok;
d8660 1
a8660 1
             | bfd_get_16 (input_bfd, hit_data + 2);
d8662 6
a8667 6
        if (globals->use_rel)
          {
            signed_addend = insn & 0xfff;
            if (!(insn & (1 << 23)))
              signed_addend = -signed_addend;
          }
d8671 2
a8672 2
		          + input_section->output_offset
		          + rel->r_offset);
d8674 1
a8674 1
        value = abs (relocation);
d8676 2
a8677 2
        if (value >= 0x1000)
          return bfd_reloc_overflow;
d8680 2
a8681 2
        if (relocation >= 0)
          insn |= (1 << 23);
d8686 1
a8686 1
        return bfd_reloc_ok;
d8695 1
a8695 1
        bfd_vma reloc_sign;
d8727 1
a8727 1
           with Thumb-1) involving the J1 and J2 bits.  */
d8730 3
a8732 3
            bfd_vma s = (upper_insn & (1 << 10)) >> 10;
            bfd_vma upper = upper_insn & 0x3ff;
            bfd_vma lower = lower_insn & 0x7ff;
d8735 2
a8736 2
            bfd_vma i1 = j1 ^ s ? 0 : 1;
            bfd_vma i2 = j2 ^ s ? 0 : 1;
d8738 3
a8740 3
            addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
            /* Sign extend.  */
            addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);
d8897 1
a8897 1
        reloc_sign = (signed_check < 0) ? 1 : 0;
d8899 2
a8900 2
                     | ((relocation >> 12) & 0x3ff)
                     | (reloc_sign << 10);
d8902 3
a8904 3
                     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
                     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
                     | ((relocation >> 1) & 0x7ff);
d8958 1
a8958 1
      	relocation = value + signed_addend;
d9073 1
a9073 1
         global offset table.  */
d9077 1
a9077 1
        return bfd_reloc_notsupported;
d9086 4
a9089 4
         calculation.  We always want the start of .got.  If we
         define _GLOBAL_OFFSET_TABLE in a different way, as is
         permitted by the ABI, we might have to change this
         calculation.  */
d9100 1
a9100 1
        return bfd_reloc_notsupported;
d9111 1
a9111 1
         global offset table.  */
d9164 1
a9164 1
 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
d9168 3
a9170 3
 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
 		  else
 		    outrel.r_info = 0;
d9223 1
a9223 1
 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
d9369 1
a9369 1
                            <= globals->root.sgotplt->size);
d9382 1
a9382 1
		   	   <= sreloc->contents + sreloc->size);
d9390 1
a9390 1
	    	bfd_put_32 (output_bfd,
d9398 1
a9398 1
	    	bfd_put_32 (output_bfd, 0,
d9714 1
a9714 1
          return bfd_reloc_overflow;
d9720 1
a9720 1
            || r_type == R_ARM_MOVT_BREL)
d9764 1
a9764 1
          return bfd_reloc_overflow;
d9770 1
a9770 1
            || r_type == R_ARM_THM_MOVT_BREL)
d9796 1
a9796 1
        bfd_vma pc = input_section->output_section->vma
d9798 6
a9803 6
        /* sb should be the origin of the *segment* containing the symbol.
           It is not clear how to obtain this OS-dependent value, so we
           make an arbitrary choice of zero.  */
        bfd_vma sb = 0;
        bfd_vma residual;
        bfd_vma g_n;
d9805 11
a9815 1
        int group = 0;
d9817 11
a9827 25
        /* Determine which group of bits to select.  */
        switch (r_type)
          {
          case R_ARM_ALU_PC_G0_NC:
          case R_ARM_ALU_PC_G0:
          case R_ARM_ALU_SB_G0_NC:
          case R_ARM_ALU_SB_G0:
            group = 0;
            break;

          case R_ARM_ALU_PC_G1_NC:
          case R_ARM_ALU_PC_G1:
          case R_ARM_ALU_SB_G1_NC:
          case R_ARM_ALU_SB_G1:
            group = 1;
            break;

          case R_ARM_ALU_PC_G2:
          case R_ARM_ALU_SB_G2:
            group = 2;
            break;

          default:
            abort ();
          }
d9829 6
a9834 2
        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
d9836 29
a9864 29
          {
            int negative;
            bfd_vma constant = insn & 0xff;
            bfd_vma rotation = (insn & 0xf00) >> 8;

            if (rotation == 0)
              signed_addend = constant;
            else
              {
                /* Compensate for the fact that in the instruction, the
                   rotation is stored in multiples of 2 bits.  */
                rotation *= 2;

                /* Rotate "constant" right by "rotation" bits.  */
                signed_addend = (constant >> rotation) |
                                (constant << (8 * sizeof (bfd_vma) - rotation));
              }

            /* Determine if the instruction is an ADD or a SUB.
               (For REL, this determines the sign of the addend.)  */
            negative = identify_add_or_sub (insn);
            if (negative == 0)
              {
                (*_bfd_error_handler)
                  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
                  input_bfd, input_section,
                  (long) rel->r_offset, howto->name);
                return bfd_reloc_overflow;
    	      }
d9866 2
a9867 2
            signed_addend *= negative;
          }
d9870 10
a9879 10
        if (r_type == R_ARM_ALU_PC_G0_NC
            || r_type == R_ARM_ALU_PC_G1_NC
            || r_type == R_ARM_ALU_PC_G0
            || r_type == R_ARM_ALU_PC_G1
            || r_type == R_ARM_ALU_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;
d9881 2
a9882 2
        /* If the target symbol is a Thumb function, then set the
           Thumb bit in the address.  */
d9886 30
a9915 30
        /* Calculate the value of the relevant G_n, in encoded
           constant-with-rotation format.  */
        g_n = calculate_group_reloc_mask (abs (signed_value), group,
                                          &residual);

        /* Check for overflow if required.  */
        if ((r_type == R_ARM_ALU_PC_G0
             || r_type == R_ARM_ALU_PC_G1
             || r_type == R_ARM_ALU_PC_G2
             || r_type == R_ARM_ALU_SB_G0
             || r_type == R_ARM_ALU_SB_G1
             || r_type == R_ARM_ALU_SB_G2) && residual != 0)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and the ADD/SUB part of the opcode; take care
           not to destroy the S bit.  */
        insn &= 0xff1ff000;

        /* Set the opcode according to whether the value to go in the
           place is negative.  */
        if (signed_value < 0)
          insn |= 1 << 22;
        else
          insn |= 1 << 23;
d9917 2
a9918 2
        /* Encode the offset.  */
        insn |= g_n;
d9932 1
a9932 1
        bfd_vma pc = input_section->output_section->vma
d9934 2
a9935 2
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
d9937 1
a9937 1
        int group = 0;
d9939 12
a9950 21
        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDR_PC_G0:
          case R_ARM_LDR_SB_G0:
            group = 0;
            break;

          case R_ARM_LDR_PC_G1:
          case R_ARM_LDR_SB_G1:
            group = 1;
            break;

          case R_ARM_LDR_PC_G2:
          case R_ARM_LDR_SB_G2:
            group = 2;
            break;

          default:
            abort ();
          }
d9952 11
a9962 2
        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
d9964 4
a9967 4
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * (insn & 0xfff);
          }
d9970 8
a9977 29
        if (r_type == R_ARM_LDR_PC_G0
            || r_type == R_ARM_LDR_PC_G1
            || r_type == R_ARM_LDR_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  */
        if (residual >= 0x1000)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7ff000;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;
d9979 23
a10001 2
        /* Encode the offset.  */
        insn |= residual;
d10015 1
a10015 1
        bfd_vma pc = input_section->output_section->vma
d10017 2
a10018 2
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
d10020 9
a10028 1
        int group = 0;
d10030 4
a10033 21
        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDRS_PC_G0:
          case R_ARM_LDRS_SB_G0:
            group = 0;
            break;

          case R_ARM_LDRS_PC_G1:
          case R_ARM_LDRS_SB_G1:
            group = 1;
            break;

          case R_ARM_LDRS_PC_G2:
          case R_ARM_LDRS_SB_G2:
            group = 2;
            break;

          default:
            abort ();
          }
d10035 11
a10045 2
        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
d10047 4
a10050 4
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
          }
d10053 8
a10060 29
        if (r_type == R_ARM_LDRS_PC_G0
            || r_type == R_ARM_LDRS_PC_G1
            || r_type == R_ARM_LDRS_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  */
        if (residual >= 0x100)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7ff0f0;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;
d10062 23
a10084 2
        /* Encode the offset.  */
        insn |= ((residual & 0xf0) << 4) | (residual & 0xf);
d10098 1
a10098 1
        bfd_vma pc = input_section->output_section->vma
d10100 2
a10101 2
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
d10103 14
a10116 1
        int group = 0;
d10118 8
a10125 21
        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDC_PC_G0:
          case R_ARM_LDC_SB_G0:
            group = 0;
            break;

          case R_ARM_LDC_PC_G1:
          case R_ARM_LDC_SB_G1:
            group = 1;
            break;

          case R_ARM_LDC_PC_G2:
          case R_ARM_LDC_SB_G2:
            group = 2;
            break;

          default:
            abort ();
          }
d10127 2
a10128 2
        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
d10130 4
a10133 4
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * ((insn & 0xff) << 2);
          }
d10136 24
a10159 31
        if (r_type == R_ARM_LDC_PC_G0
            || r_type == R_ARM_LDC_PC_G1
            || r_type == R_ARM_LDC_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  (The absolute value to go in the place must be
           divisible by four and, after having been divided by four, must
           fit in eight bits.)  */
        if ((residual & 0x3) != 0 || residual >= 0x400)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7fff00;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;
d10161 9
a10169 2
        /* Encode the offset.  */
        insn |= residual >> 2;
d10321 2
a10322 2
          || r_type == R_ARM_GNU_VTINHERIT)
        continue;
d10515 4
a10518 4
         done, i.e., the relaxation produced the final output we want,
         and we won't let anybody mess with it. Also, we have to do
         addend adjustments in case of a R_ARM_TLS_GOTDESC relocation
         both in relaxed and non-relaxed cases */
d10546 2
a10547 2
          && !((input_section->flags & SEC_DEBUGGING) != 0
               && h->def_dynamic)
d10694 1
a10694 1
        codes which have been inlined into the index).
d10720 1
a10720 1
        {
d10730 1
a10730 1
	        = &elf_section_data (elf_sec->linked_to)->this_hdr;
d10732 1
a10732 1
	        = get_arm_elf_section_data (linked_hdr->bfd_section);
d10735 1
a10735 1
	        continue;
d10738 1
a10738 1
	         describes.  */
d10763 1
a10763 1
        continue;
d10787 1
a10787 1
        continue;
d10791 1
a10791 1
        continue;
d10841 1
a10841 1
        free (contents);
d11068 1
a11068 1
         then turn off the interworking bit.  */
d11500 1
a11500 1
	        != out_attr[Tag_MPextension_use].i)
d11688 1
a11688 1
	         'M' and 'A|R|S' is an error.  */
d11786 1
a11786 1
	         options.  */
d11802 1
a11802 1
	         a warning.  */
d12488 1
a12488 1
        {
d12531 1
a12531 1
	         slots may be created.  */
d12544 3
a12546 3
	         method, we're able to relax. Turn off the GDESC flag,
	         without messing up with any other kind of tls types
	         that may be involved */
d12643 16
a12658 16
        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_ARM_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_ARM_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
        }
d12916 1
a12916 1
                                     section, symbols, offset,
d13227 2
a13228 2
              if (tls_type & GOT_TLS_GDESC)
	        {
d13230 1
a13230 1
	          eh->tlsdesc_got
d13233 2
a13234 2
	          htab->root.sgotplt->size += 8;
	          h->got.offset = (bfd_vma) -2;
d13237 2
a13238 2
                  htab->num_tls_desc++;
	        }
d13351 5
a13355 5
         R_ARM_REL32_NOI, which will appear on something like
         ".long foo - .".  We want calls to protected symbols to resolve
         directly to the function rather than going via the plt.  If people
         want function pointer comparisons to work as expected then they
         should avoid writing assembly like ".long foo - .".  */
d13385 1
a13385 1
         visibility.  */
d13556 1
a13556 1
                   elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
d13652 1
a13652 1
                  htab->num_tls_desc++;
d13681 1
a13681 1
		  
d13722 2
a13723 2
        /* xgettext:c-format */
        _bfd_error_handler (_("Errors encountered processing file %s"),
d13747 1
a13747 1
         PLT and GOT entries they require.  */
d13901 1
a13901 1
	                        struct bfd_link_info *info)
d13918 2
a13919 2
        {
          struct bfd_link_hash_entry *bh = NULL;
d13921 1
a13921 1
            = get_elf_backend_data (output_bfd);
d13923 1
a13923 1
          if (!(_bfd_generic_link_add_one_symbol
d13929 5
a13933 5
      	  tlsbase->type = STT_TLS;
          tlsbase = (struct elf_link_hash_entry *)bh;
          tlsbase->def_regular = 1;
          tlsbase->other = STV_HIDDEN;
          (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
d14041 32
d14238 1
a14238 1
              s = htab->root.splt;
d14245 1
a14245 1
              s = htab->root.sgot;
d14247 1
a14247 1
		      		+ htab->dt_tlsdesc_got);
d14311 2
a14312 18
	    {
	      unsigned int i;

	      got_displacement = got_address + 8 - (plt_address + 16);

	      put_arm_insn (htab, output_bfd,
			    elf32_arm_nacl_plt0_entry[0]
			    | arm_movw_immediate (got_displacement),
			    splt->contents + 0);
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_nacl_plt0_entry[1]
			    | arm_movt_immediate (got_displacement),
			    splt->contents + 4);
	      for (i = 2; i < ARRAY_SIZE (elf32_arm_nacl_plt0_entry); ++i)
		put_arm_insn (htab, output_bfd,
			      elf32_arm_nacl_plt0_entry[i],
			      splt->contents + (i * 4));
	    }
d14405 4
d14992 9
d15137 1
a15137 1
                       void *in_arg)
d15276 13
a15288 13
           errnode = errnode->next)
        {
          bfd_vma target = errnode->vma - offset;

          switch (errnode->type)
            {
            case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
              {
                bfd_vma branch_to_veneer;
                /* Original condition code of instruction, plus bit mask for
                   ARM B instruction.  */
                unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
                                  | 0x0a000000;
d15295 1
a15295 1
                                   - errnode->vma - 4;
d15302 7
a15308 7
                insn |= (branch_to_veneer >> 2) & 0xffffff;
                contents[endianflip ^ target] = insn & 0xff;
                contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
              }
              break;
d15311 7
a15317 7
              {
                bfd_vma branch_from_veneer;
                unsigned int insn;

                /* Take size of veneer into account.  */
                branch_from_veneer = errnode->u.v.branch->vma
                                     - errnode->vma - 12;
d15324 20
a15343 20
                /* Original instruction.  */
                insn = errnode->u.v.branch->u.b.vfp_insn;
                contents[endianflip ^ target] = insn & 0xff;
                contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;

                /* Branch back to insn after original insn.  */
                insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
                contents[endianflip ^ (target + 4)] = insn & 0xff;
                contents[endianflip ^ (target + 5)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (target + 6)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (target + 7)] = (insn >> 24) & 0xff;
              }
              break;

            default:
              abort ();
            }
        }
d15349 1
a15349 1
        = arm_data->u.exidx.unwind_edit_list;
d15351 1
a15351 1
         size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
d15360 1
a15360 1
        {
d15366 1
a15366 1
	        {
d15375 1
a15375 1
	        {
d15385 1
a15385 1
		        asection *text_sec = edit_node->linked_section;
d15390 1
a15390 1
		        unsigned long prel31_offset;
d15455 2
a15456 2
        {
          if (i == mapcount - 1)
d15458 2
a15459 2
          else
            end = map[i + 1].vma;
d15461 1
a15461 1
          switch (map[i].type)
d15466 9
a15474 9
	        {
	          tmp = contents[ptr];
	          contents[ptr] = contents[ptr + 3];
	          contents[ptr + 3] = tmp;
	          tmp = contents[ptr + 1];
	          contents[ptr + 1] = contents[ptr + 2];
	          contents[ptr + 2] = tmp;
	          ptr += 4;
	        }
d15480 6
a15485 6
	        {
	          tmp = contents[ptr];
	          contents[ptr] = contents[ptr + 1];
	          contents[ptr + 1] = tmp;
	          ptr += 2;
	        }
d15492 2
a15493 2
          ptr = end;
        }
d15562 11
a15572 11
        {
          /* Do this only for defined symbols. At link type, the static
             linker will simulate the work of dynamic linker of resolving
             symbols and will carry over the thumbness of found symbols to
             the output symbol table. It's not clear how it happens, but
             the thumbness of undefined symbols can well be different at
             runtime, and writing '1' for them will be confusing for users
             and possibly for dynamic linker itself.
          */
          newsym.st_value |= 1;
        }
d15600 1
a15600 1
              bfd_zalloc (abfd, sizeof (struct elf_segment_map));
d15937 2
a15938 2
         uninitialised values, which surprise surprise, correspond
         to the default values.  */
d15986 1
a15986 1
	    	only_data_sections = FALSE;
@


1.314
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d12468 4
@


1.313
log
@bfd/ChangeLog:

2013-03-20  Will Newton  <will.newton@@linaro.org>

	* elf32-arm.c (elf32_arm_final_link_relocate): Avoid emitting a
	dynamic reloc for symbols with dynindx == -1.
	(allocate_dynrelocs_for_symbol): Avoid allocating space for a
	dynamic reloc for symbols with dynindx == -1.
@
text
@d14435 3
a14437 1
elf32_arm_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.312
log
@bfd/ChangeLog:

2013-03-20  Will Newton  <will.newton@@linaro.org>

	* elf32-arm.c (elf32_arm_final_link_relocate): Avoid emitting a
	dynamic reloc for symbols with dynindx == -1.
	(allocate_dynrelocs_for_symbol): Avoid allocating space for a
	dynamic reloc for symbols with dynindx == -1.
@
text
@d9142 1
a9142 1
	      if (!SYMBOL_REFERENCES_LOCAL (info, h))
d13277 1
a13277 1
	  else if (!SYMBOL_REFERENCES_LOCAL (info, h))
@


1.311
log
@	PR sim/15286
	* elf32-arm.c (bfd_arm_get_mach_from_attributes): Identify XScale,
	iWMMXt and iWMMXt2 processors from attributes.
@
text
@d9161 3
a9163 1
		  else if (info->shared)
d13289 2
a13290 1
	  else if (info->shared)
@


1.310
log
@    bfd/
    * elf32-arm.c (elf32_arm_size_dynamic_sections): Don't call
    elf32_arm_allocate_dynrelocs for source reloc for non-dynamic link.

    ld/testsuite/
    * ld-arm/tls-local-static.s: New test.
    * ld-arm/tls-local-static.d: New.
    * ld-arm/arm-elf.exp (tls-local-static): Add test.
@
text
@d10961 14
@


1.309
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d13651 1
a13651 5
	      else if ((info->shared && !(*local_tls_type & GOT_TLS_GDESC))
		       || *local_tls_type & GOT_TLS_GD)
		elf32_arm_allocate_dynrelocs (info, srel, 1);

	      if (info->shared && *local_tls_type & GOT_TLS_GDESC)
d13653 10
a13662 2
		  elf32_arm_allocate_dynrelocs (info, htab->root.srelplt, 1);
		  htab->tls_trampoline = -1;
@


1.308
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@d1948 1
a1948 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d1951 1
a1951 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d1974 1
a1974 1
	elf_tdata (abfd)->core_pid
d1976 1
a1976 1
	elf_tdata (abfd)->core_program
d1978 1
a1978 1
	elf_tdata (abfd)->core_command
d1986 1
a1986 1
    char *command = elf_tdata (abfd)->core_command;
@


1.307
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d15534 1
a15534 1
      m = elf_tdata (abfd)->segment_map;
d15547 2
a15548 2
	  m->next = elf_tdata (abfd)->segment_map;
	  elf_tdata (abfd)->segment_map = m;
d16141 1
a16141 1
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d16148 2
a16149 2
	  m->next = elf_tdata (abfd)->segment_map;
	  elf_tdata (abfd)->segment_map = m;
@


1.306
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3463 1
a3463 1
  _bfd_generic_link_hash_table_free (hash);
@


1.305
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Only test for
	stubs in stub_bfd.
@
text
@d3420 1
a3420 1
  ret = (struct elf32_arm_link_hash_table *) bfd_malloc (amt);
a3432 12
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->srelplt2 = NULL;
  ret->dt_tlsdesc_plt = 0;
  ret->dt_tlsdesc_got = 0;
  ret->tls_trampoline = 0;
  ret->next_tls_desc_index = 0;
  ret->num_tls_desc = 0;
  ret->thumb_glue_size = 0;
  ret->arm_glue_size = 0;
  ret->bx_glue_size = 0;
  memset (ret->bx_glue_offset, 0, sizeof (ret->bx_glue_offset));
a3433 8
  ret->vfp11_erratum_glue_size = 0;
  ret->num_vfp11_fixes = 0;
  ret->fix_cortex_a8 = 0;
  ret->fix_arm1176 = 0;
  ret->bfd_of_glue_owner = NULL;
  ret->byteswap_code = 0;
  ret->target1_is_rel = 0;
  ret->target2_reloc = R_ARM_NONE;
a3440 5
  ret->fix_v4bx = 0;
  ret->use_blx = 0;
  ret->vxworks_p = 0;
  ret->symbian_p = 0;
  ret->nacl_p = 0;
a3441 1
  ret->sym_cache.abfd = NULL;
a3442 9
  ret->tls_ldm_got.refcount = 0;
  ret->stub_bfd = NULL;
  ret->add_stub_section = NULL;
  ret->layout_sections_again = NULL;
  ret->stub_group = NULL;
  ret->top_id = 0;
  ret->bfd_count = 0;
  ret->top_index = 0;
  ret->input_list = NULL;
@


1.304
log
@bfd/
	* elf32-arm.c (elf32_arm_size_stubs): Skip input BFDs that are
	not ARM ELF.
@
text
@d8232 2
a8233 1
	  && (!strstr (input_section->name, STUB_SUFFIX))
@


1.303
log
@bfd/ChangeLog

2012-11-16  Joey Ye  <joey.ye@@arm.com>

	* elf32-arm.c (elf32_arm_final_link_relocate,
	case R_ARM_THM_ALU_PREL_11_0, case R_ARM_THM_PC12): Align address of
	the place being relocated.
	(elf32_arm_final_link_relocate, case R_ARM_THM_PC8): Align address
	of the place being relocated and truncate addend.
	(Pa): New macro.
@
text
@d4990 3
@


1.302
log
@bfd/
	* elf32-arm.c (elf32_arm_nacl_plt0_entry): Use bic rather than bfc
	instruction for data sandboxing.

gold/
	* arm.cc (Output_data_plt_arm_nacl::first_plt_entry): Use bic rather
	than bfc instruction for data sandboxing.
@
text
@d66 3
d8625 3
a8627 3
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
d8657 1
a8657 1
	  addend = (insn & 0x00ff) << 2;
d8660 3
a8662 3
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
d8697 3
a8699 3
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);
@


1.301
log
@
bfd:
        * elf32-arm.c (elf32_arm_print_private_bfd_data): Recognise and
        display the new ARM hard-float/soft-float ABI flags for EABI_VER5
        (elf32_arm_post_process_headers): Add the hard-float/soft-float
        ABI flag as appropriate for ET_DYN/ET_EXEC in EABI_VER5.

binutils:
        * readelf.c (decode_ARM_machine_flags): Recognise and display the
        new ARM hard-float/soft-float ABI flags for EABI_VER5. Split out
        the code for EABI_VER4 and EABI_VER5 to allow this.

elfcpp:
        * arm.h: New enum for EABI soft- and hard-float flags.

gold:
        * gold.cc (Target_arm::do_adjust_elf_header): Add the
        hard-float/soft-float ABI flag as appropriate for ET_DYN/ET_EXEC
        in EABI_VER5.

include:
        * elf/arm.h (EF_ARM_ABI_FLOAT_SOFT): New define.
        (EF_ARM_ABI_FLOAT_HARD): Likewise.

ld/testsuite:
        * ld-arm/eabi-hard-float.s: New test source.
        * ld-arm/eabi-soft-float.s: New test source.
        * ld-arm/eabi-hard-float.d: New test.
        * ld-arm/eabi-soft-float.d: New test.
        * ld-arm/eabi-soft-float-ABI4.d: New test.
        * ld-arm/eabi-soft-float-r.d: New test.
        * ld-arm/arm-elf.xp: Use the new tests.

binutils:
	PR binutils/14779
	* configure.in: Add checks for wchar.h and mbstate_t.
	* config.in: Regenerate.
	* configure: Regenerate.
	* readelf.c: Conditionally include wchar.h.
	(print_symbol): Conditionally use mbstate_t.
@
text
@d2212 2
a2213 2
  0xe7dfcf1f, 	/* bfc	ip, #30, #2			*/
  0xe59cc000, 	/* ldr	ip, [ip]			*/
d2215 1
a2215 1
  0xe12fff1c, 	/* bx	ip				*/
d2217 3
a2219 3
  0xe320f000, 	/* nop					*/
  0xe320f000, 	/* nop					*/
  0xe320f000, 	/* nop					*/
d2223 2
a2224 2
  0xe7dfcf1f,		/* bfc	ip, #30, #2			*/
  0xe59cc000, 	/* ldr	ip, [ip]			*/
d2226 1
a2226 1
  0xe12fff1c, 	/* bx	ip				*/
@


1.300
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d12113 9
d14429 10
@


1.299
log
@	* bfd/elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.
	* binutils/readelf.c (arm_attr_tag_CPU_arch): Update for ARMv8.
	(arm_attr_tag_FP_arch): Likewise.
	(arm_attr_tag_Advanced_SIMD_arch): Likewise.
	* gas/config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* gas/doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/testsuite/gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a.d: Likewise.
	* include/elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* include/opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Add new testcases.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld/testsuite/ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8.s: Likewise.
@
text
@d14006 1
a14006 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.298
log
@	PR ld/14397
	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Report an error
	if a required section is missing from the linker script.

	* ld-arm/arm-elf.exp: Add tests of linking without .rel.plt.
	* ld-arm/arm-no-rel-plt.out: Linker script without .rel.plt section.
	* ld-arm/arm-no-rel-plt.out: Expected output.
@
text
@d11330 18
d11364 1
d11375 1
d11577 2
a11578 1
		"ARM v6S-M"
d11723 1
d11728 1
a11728 1
	      } vfp_versions[7] =
d11736 2
a11737 1
		  {4, 16}
d11777 4
a11780 3
	      /* Values greater than 6 aren't defined, so just pick the
	         biggest */
	      if (in_attr[i].i > 6 && in_attr[i].i > out_attr[i].i)
d11795 1
a11795 1
	      for (newval = 6; newval > 0; newval--)
@


1.298.2.1
log
@	Apply mainline patches

bfd/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.

gas/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm>
	* config/tc-arm.c (CVT_FLAVOUR_VAR): New define.
	(CVT_VAR): New helper define.
	(neon_cvt_flavour): New enumeration, function renamed...
	(get_neon_cvt_flavour): ...to this.
	(do_vfp_nsyn_cvt): Update to use new neon_cvt_flavour.
	(do_vfp_nsyn_cvtz): Likewise.
	(do_neon_cvt_1): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (insns): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.

	2012-08-24  Matthew Gretton-Dann <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_setend): Warn on deprecated SETEND.
	(do_t_setend): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_it): Fully initialise now_it.
	(new_automatic_it_block): Likewise.
	(handle_it_block): Record whether current instruction is
	conditionally executed.
	* config/tc-arm.c (depr_insn_mask): New structure.
	(depr_it_insns): New variable.
	(it_fsm_post_encode): Warn on deprecated uses.
	* config/tc-arm.h (current_it): Add new fields.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (deprecated_coproc_regs_s): New structure.
	(deprecated_coproc_regs): New variable.
	(deprecated_coproc_reg_count): Likewise.
	(do_co_reg): Error on obsolete & warn on deprecated registers.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (check_obsolete): New function.
	(do_rd_rm_rn): Check swp{b} for obsoletion.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.

gas/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/arm/armv8-a+crypto.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: New testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/half-prec-vfpv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/arm/armv8-a+simdv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/armv8-a+simd.d: Likewise.
	* gas/arm/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: New testcase.
	* gas/arm/armv8-a+fp.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.d: Update.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.s: New testcase.
	* gas/arm/armv8-a.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-barrier.s: New testcase.
	* gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/arm/armv8-a-barrier-thumb.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-it-bad.d: New testcase.
	* gas/arm/armv8-a-it-bad.l: Likewise.
	* gas/arm/armv8-a-it-bad.s: Likewise.
	* gas/arm/ldr-t-bad.s: Update testcase.
	* gas/arm/ldr-t.d: Likewise.
	* gas/arm/ldr-t.s: Likewise.
	* gas/arm/neon-cond-bad-inc.s: Likewise.
	* gas/arm/sp-pc-validations-bad-t: Likewise.
	* gas/arm/vfp-fma-inc.s: Likewise.
	* gas/arm/vfp-neon-syntax-inc.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.d: New testcase.
	* gas/arm/armv8-a-bad.l: Likewise.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/depr-swp.l: Update for change in expected output.
	* gas/arm/depr-swp.s: Add additional test.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/arm/attr-march-armv8-a.d: Likewise.

include/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* opcode/arm.h (ARM_CPU_IS_ANY): New define.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.

ld/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* ld-arm/arm-elf.exp: Add new testcases.
	* ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld-arm/attr-merge-vfp-armv8.s: Likewise.

opcodes/
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add 2 operand sha instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add support for AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.

	2012-08-24  Matthew  Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (thumb32_opcodes): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com
	* arm-dis.c (COND_UNCOND): New constant.
	(print_insn_coprocessor): Add support for %u format specifier.
	(print_insn_neon): Likewise.
@
text
@a11329 18
  const int v8[] =
    {
      T(V8),		/* PRE_V4.  */
      T(V8),		/* V4.  */
      T(V8),		/* V4T.  */
      T(V8),		/* V5T.  */
      T(V8),		/* V5TE.  */
      T(V8),		/* V5TEJ.  */
      T(V8),		/* V6.  */
      T(V8),		/* V6KZ.  */
      T(V8),		/* V6T2.  */
      T(V8),		/* V6K.  */
      T(V8),		/* V7.  */
      T(V8),		/* V6_M.  */
      T(V8),		/* V6S_M.  */
      T(V8),		/* V7E_M.  */
      T(V8)		/* V8.  */
    };
a11345 1
      T(V8),		/* V8.  */
a11355 1
      v8,
d11557 1
a11557 2
		"ARM v6S-M",
		"ARM v8"
a11701 1
#define VFP_VERSION_COUNT 8
d11706 1
a11706 1
	      } vfp_versions[VFP_VERSION_COUNT] =
d11714 1
a11714 2
		  {4, 16},
		  {8, 32}
d11754 3
a11756 4
	      /* Values of VFP_VERSION_COUNT or more aren't defined, so just
		 pick the biggest.  */
	      if (in_attr[i].i >= VFP_VERSION_COUNT
		  && in_attr[i].i > out_attr[i].i)
d11771 1
a11771 1
	      for (newval = VFP_VERSION_COUNT - 1; newval > 0; newval--)
@


1.298.2.2
log
@bfd/
	* elf32-arm.c (elf32_arm_nacl_plt0_entry): Use bic rather than bfc
	instruction for data sandboxing.

gold/
	* arm.cc (Output_data_plt_arm_nacl::first_plt_entry): Use bic rather
	than bfc instruction for data sandboxing.
@
text
@d2212 2
a2213 2
  0xe3ccc103,		/* bic	ip, ip, #0xc0000000		*/
  0xe59cc000,		/* ldr	ip, [ip]			*/
d2215 1
a2215 1
  0xe12fff1c,		/* bx	ip				*/
d2217 3
a2219 3
  0xe320f000,		/* nop					*/
  0xe320f000,		/* nop					*/
  0xe320f000,		/* nop					*/
d2223 2
a2224 2
  0xe3ccc103,		/* bic	ip, ip, #0xc0000000		*/
  0xe59cc000,		/* ldr	ip, [ip]			*/
d2226 1
a2226 1
  0xe12fff1c,		/* bx	ip				*/
@


1.298.2.3
log
@bfd/ChangeLog

2012-11-19  Joey Ye  <joey.ye@@arm.com>

	* elf32-arm.c (elf32_arm_final_link_relocate,
	case R_ARM_THM_ALU_PREL_11_0, case R_ARM_THM_PC12): Align address of
	the place being relocated.
	(elf32_arm_final_link_relocate, case R_ARM_THM_PC8): Align address
	of the place being relocated and truncate addend.
	(Pa): New macro.
@
text
@a65 3
/* The Adjusted Place, as defined by AAELF.  */
#define Pa(X) ((X) & 0xfffffffc)

d8622 3
a8624 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d8654 1
a8654 1
	  addend = ((((insn & 0x00ff) << 2) + 4) & 0x3ff) -4;
d8657 3
a8659 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d8694 3
a8696 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
@


1.298.2.4
log
@bfd/
	* elf32-arm.c (elf32_arm_size_stubs): Skip input BFDs that are
	not ARM ELF.
@
text
@a4989 3
          if (!is_arm_elf (input_bfd))
            continue;

@


1.298.2.5
log
@bfd/
	* elf32-arm.c (elf32_arm_allocate_plt_entry): If HTAB->nacl_p,
	allocate space for PLT header even if IS_IPLT_ENTRY.
	(arm_nacl_put_plt0): New function, broken out of ...
	(elf32_arm_finish_dynamic_sections): ... here.  Call it.
	If HTAB->nacl_p, set up the PLT header in .iplt too.
	(elf32_arm_output_arch_local_syms): If HTAB->nacl_p, write
	a mapping symbol for the start of .iplt too.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
d330 12
a341 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_DTPMOD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d344 12
a355 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_DTPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d358 12
a369 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_TPOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d374 12
a385 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_COPY",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d388 12
a399 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GLOB_DAT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d402 12
a413 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_JUMP_SLOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d416 12
a427 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_RELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d430 12
a441 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOTOFF32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d444 12
a455 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 TRUE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOTPC",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d458 12
a469 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_GOT32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d472 12
a483 12
	 2,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 24,                    /* bitsize */
	 TRUE,			/* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_PLT32",		/* name */
	 FALSE,			/* partial_inplace */
	 0x00ffffff,		/* src_mask */
	 0x00ffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d1490 12
a1501 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 0,                     /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
	 "R_ARM_GNU_VTENTRY",   /* name */
	 FALSE,                 /* partial_inplace */
	 0,                     /* src_mask */
	 0,                     /* dst_mask */
	 FALSE),                /* pcrel_offset */
d1505 12
a1516 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 0,                     /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,                  /* special_function */
	 "R_ARM_GNU_VTINHERIT", /* name */
	 FALSE,                 /* partial_inplace */
	 0,                     /* src_mask */
	 0,                     /* dst_mask */
	 FALSE),                /* pcrel_offset */
d1548 12
a1559 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_ARM_TLS_GD32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d1562 12
a1573 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LDM32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d1576 12
a1587 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LDO32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d1590 12
a1601 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                  /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_ARM_TLS_IE32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d1604 12
a1615 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_TLS_LE32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),                /* pcrel_offset */
d1699 12
a1710 12
	 0,                     /* rightshift */
	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
	 32,                    /* bitsize */
	 FALSE,                 /* pc_relative */
	 0,                     /* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_IRELATIVE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE)			/* pcrel_offset */
d2101 1
a2101 1
				+ dl_tlsdesc_lazy_resolver(GOT)   */
d3007 2
a3008 2
			     struct bfd_hash_table * table,
			     const char * string)
d3017 1
a3017 1
	bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
d3191 1
a3191 1
	  bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
d3663 1
a3663 1
	   distance)
d3665 3
a3667 3
	   Thumb->Arm branch (not bl). A stub is needed in this case,
	   but only if this call is not through a PLT entry. Indeed,
	   PLT stubs handle mode switching already.
d4146 5
a4150 5
		/* We've borrowed the reloc_addend field to mean we should
		   insert a condition code into this (Thumb-1 branch)
		   instruction.  See THUMB16_BCOND_INSN.  */
		BFD_ASSERT ((data & 0xff00) == 0xd000);
		data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
d4163 7
a4169 7
	  if (template_sequence[i].r_type != R_ARM_NONE)
	    {
	      stub_reloc_idx[nrelocs] = i;
	      stub_reloc_offset[nrelocs++] = size;
	    }
	  size += 4;
	  break;
d4227 1
a4227 1
				   template_sequence[stub_reloc_idx[i]].r_type);
d4260 1
a4260 1
				   template_sequence[stub_reloc_idx[i]].r_type);
d4490 9
a4498 9
	{
	  /* Pop from tail.  */
	  asection *item = tail;
	  tail = PREV_SEC (item);

	  /* Push on head.  */
	  NEXT_SEC (item) = head;
	  head = item;
	}
d4617 5
a4621 5
	  || (elf_section_flags (section) & SHF_EXECINSTR) == 0
	  || (section->flags & SEC_EXCLUDE) != 0
	  || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
	  || (section->output_section == bfd_abs_section_ptr))
	continue;
d4626 1
a4626 1
	contents = elf_section_data (section)->this_hdr.contents;
d4628 1
a4628 1
	return TRUE;
d4633 7
a4639 7
	{
	  unsigned int span_start = sec_data->map[span].vma;
	  unsigned int span_end = (span == sec_data->mapcount - 1)
	    ? section->size : sec_data->map[span + 1].vma;
	  unsigned int i;
	  char span_type = sec_data->map[span].type;
	  bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;
d4641 2
a4642 2
	  if (span_type != 't')
	    continue;
d4644 2
a4645 2
	  /* Span is entirely within a single 4KB region: skip scanning.  */
	  if (((base_vma + span_start) & ~0xfff)
d4647 1
a4647 1
	    continue;
d4649 1
a4649 1
	  /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
d4651 9
a4659 9
	       * The opcode is BLX.W, BL.W, B.W, Bcc.W
	       * The branch target is in the same 4KB region as the
		 first half of the branch.
	       * The instruction before the branch is a 32-bit
		 length non-branch instruction.  */
	  for (i = span_start; i < span_end;)
	    {
	      unsigned int insn = bfd_getl16 (&contents[i]);
	      bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;
d4662 2
a4663 2
	      if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)
		insn_32bit = TRUE;
d4666 10
a4675 10
		{
		  /* Load the rest of the insn (in manual-friendly order).  */
		  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);

		  /* Encoding T4: B<c>.W.  */
		  is_b = (insn & 0xf800d000) == 0xf0009000;
		  /* Encoding T1: BL<c>.W.  */
		  is_bl = (insn & 0xf800d000) == 0xf000d000;
		  /* Encoding T2: BLX<c>.W.  */
		  is_blx = (insn & 0xf800d000) == 0xf000c000;
d4683 1
a4683 1
	      if (((base_vma + i) & 0xfff) == 0xffe
d4688 3
a4690 3
		{
		  bfd_signed_vma offset = 0;
		  bfd_boolean force_target_arm = FALSE;
d4692 10
a4701 10
		  bfd_vma target;
		  enum elf32_arm_stub_type stub_type = arm_stub_none;
		  struct a8_erratum_reloc key, *found;
		  bfd_boolean use_plt = FALSE;

		  key.from = base_vma + i;
		  found = (struct a8_erratum_reloc *)
		      bsearch (&key, a8_relocs, num_a8_relocs,
			       sizeof (struct a8_erratum_reloc),
			       &a8_reloc_compare);
d4709 1
a4709 1
			 function, only if there is glue or not.  */
d4731 1
a4731 1
		  /* Check if we have an offending branch instruction.  */
d4739 37
a4775 37
		  else if (is_bcc)
		    {
		      offset = (insn & 0x7ff) << 1;
		      offset |= (insn & 0x3f0000) >> 4;
		      offset |= (insn & 0x2000) ? 0x40000 : 0;
		      offset |= (insn & 0x800) ? 0x80000 : 0;
		      offset |= (insn & 0x4000000) ? 0x100000 : 0;
		      if (offset & 0x100000)
			offset |= ~ ((bfd_signed_vma) 0xfffff);
		      stub_type = arm_stub_a8_veneer_b_cond;
		    }
		  else if (is_b || is_bl || is_blx)
		    {
		      int s = (insn & 0x4000000) != 0;
		      int j1 = (insn & 0x2000) != 0;
		      int j2 = (insn & 0x800) != 0;
		      int i1 = !(j1 ^ s);
		      int i2 = !(j2 ^ s);

		      offset = (insn & 0x7ff) << 1;
		      offset |= (insn & 0x3ff0000) >> 4;
		      offset |= i2 << 22;
		      offset |= i1 << 23;
		      offset |= s << 24;
		      if (offset & 0x1000000)
			offset |= ~ ((bfd_signed_vma) 0xffffff);

		      if (is_blx)
			offset &= ~ ((bfd_signed_vma) 3);

		      stub_type = is_blx ? arm_stub_a8_veneer_blx :
			is_bl ? arm_stub_a8_veneer_bl : arm_stub_a8_veneer_b;
		    }

		  if (stub_type != arm_stub_none)
		    {
		      bfd_vma pc_for_insn = base_vma + i + 4;
d4778 1
a4778 1
			 an ARM instruction.  If we were not making a stub,
d4799 2
a4800 2
		      if (is_blx)
			pc_for_insn &= ~ ((bfd_vma) 3);
d4802 2
a4803 2
		      /* If we found a relocation, use the proper destination,
			 not the offset in the (unrelocated) instruction.
d4806 2
a4807 2
		      if (found)
			offset =
d4810 5
a4814 5
		      /* If the stub will use a Thumb-mode branch to a
			 PLT target, redirect it to the preceding Thumb
			 entry point.  */
		      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
			offset -= PLT_THUMB_STUB_SIZE;
d4816 1
a4816 1
		      target = pc_for_insn + offset;
d4818 2
a4819 2
		      /* The BLX stub is ARM-mode code.  Adjust the offset to
			 take the different PC value (+8 instead of +4) into
d4821 2
a4822 2
		      if (stub_type == arm_stub_a8_veneer_blx)
			offset += 4;
d4824 12
a4835 12
		      if (((base_vma + i) & ~0xfff) == (target & ~0xfff))
			{
			  char *stub_name = NULL;

			  if (num_a8_fixes == a8_fix_table_size)
			    {
			      a8_fix_table_size *= 2;
			      a8_fixes = (struct a8_erratum_fix *)
				  bfd_realloc (a8_fixes,
					       sizeof (struct a8_erratum_fix)
					       * a8_fix_table_size);
			    }
d4860 8
a4867 8
			  a8_fixes[num_a8_fixes].input_bfd = input_bfd;
			  a8_fixes[num_a8_fixes].section = section;
			  a8_fixes[num_a8_fixes].offset = i;
			  a8_fixes[num_a8_fixes].addend = offset;
			  a8_fixes[num_a8_fixes].orig_insn = insn;
			  a8_fixes[num_a8_fixes].stub_name = stub_name;
			  a8_fixes[num_a8_fixes].stub_type = stub_type;
			  a8_fixes[num_a8_fixes].branch_type =
d4870 4
a4873 4
			  num_a8_fixes++;
			}
		    }
		}
d4875 2
a4876 2
	      i += insn_32bit ? 4 : 2;
	      last_was_32bit = insn_32bit;
d4878 2
a4879 2
	    }
	}
d4882 1
a4882 1
	free (contents);
d4920 1
a4920 1
	  bfd_zmalloc (sizeof (struct a8_erratum_fix) * a8_fix_table_size);
d4922 1
a4922 1
	  bfd_zmalloc (sizeof (struct a8_erratum_reloc) * a8_reloc_table_size);
d4990 2
a4991 2
	  if (!is_arm_elf (input_bfd))
	    continue;
d5264 21
a5284 21
		      stub_entry->target_value = sym_value;
		      stub_entry->target_section = sym_sec;
		      stub_entry->stub_type = stub_type;
		      stub_entry->h = hash;
		      stub_entry->branch_type = branch_type;

		      if (sym_name == NULL)
			sym_name = "unnamed";
		      stub_entry->output_name = (char *)
			  bfd_alloc (htab->stub_bfd,
				     sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
				     + strlen (sym_name));
		      if (stub_entry->output_name == NULL)
			{
			  free (stub_name);
			  goto error_ret_free_internal;
			}

		      /* For historical reasons, use the existing names for
			 ARM-to-Thumb and Thumb-to-ARM stubs.  */
		      if ((r_type == (unsigned int) R_ARM_THM_CALL
d5287 3
a5289 3
			sprintf (stub_entry->output_name,
				 THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
		      else if ((r_type == (unsigned int) R_ARM_CALL
d5292 55
a5346 55
			sprintf (stub_entry->output_name,
				 ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
		      else
			sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
				 sym_name);

		      stub_changed = TRUE;
		    }
		  while (0);

		  /* Look for relocations which might trigger Cortex-A8
		     erratum.  */
		  if (htab->fix_cortex_a8
		      && (r_type == (unsigned int) R_ARM_THM_JUMP24
			  || r_type == (unsigned int) R_ARM_THM_JUMP19
			  || r_type == (unsigned int) R_ARM_THM_CALL
			  || r_type == (unsigned int) R_ARM_THM_XPC22))
		    {
		      bfd_vma from = section->output_section->vma
				     + section->output_offset
				     + irela->r_offset;

		      if ((from & 0xfff) == 0xffe)
			{
			  /* Found a candidate.  Note we haven't checked the
			     destination is within 4K here: if we do so (and
			     don't create an entry in a8_relocs) we can't tell
			     that a branch should have been relocated when
			     scanning later.  */
			  if (num_a8_relocs == a8_reloc_table_size)
			    {
			      a8_reloc_table_size *= 2;
			      a8_relocs = (struct a8_erratum_reloc *)
				  bfd_realloc (a8_relocs,
					       sizeof (struct a8_erratum_reloc)
					       * a8_reloc_table_size);
			    }

			  a8_relocs[num_a8_relocs].from = from;
			  a8_relocs[num_a8_relocs].destination = destination;
			  a8_relocs[num_a8_relocs].r_type = r_type;
			  a8_relocs[num_a8_relocs].branch_type = branch_type;
			  a8_relocs[num_a8_relocs].sym_name = sym_name;
			  a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
			  a8_relocs[num_a8_relocs].hash = hash;

			  num_a8_relocs++;
			}
		    }
		}

	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
	    }
d5348 1
a5348 1
	  if (htab->fix_cortex_a8)
d5350 2
a5351 2
	      /* Sort relocs which might apply to Cortex-A8 erratum.  */
	      qsort (a8_relocs, num_a8_relocs,
d5353 1
a5353 1
		     &a8_reloc_compare);
d5355 2
a5356 2
	      /* Scan for branches which might trigger Cortex-A8 erratum.  */
	      if (cortex_a8_erratum_scan (input_bfd, info, &a8_fixes,
d5366 1
a5366 1
	stub_changed = TRUE;
d5388 2
a5389 2
	for (i = 0; i < num_a8_fixes; i++)
	  {
d5396 4
a5399 4
	    stub_sec->size
	      += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
					      NULL);
	  }
d5410 28
a5437 28
	{
	  struct elf32_arm_stub_hash_entry *stub_entry;
	  char *stub_name = a8_fixes[i].stub_name;
	  asection *section = a8_fixes[i].section;
	  unsigned int section_id = a8_fixes[i].section->id;
	  asection *link_sec = htab->stub_group[section_id].link_sec;
	  asection *stub_sec = htab->stub_group[section_id].stub_sec;
	  const insn_sequence *template_sequence;
	  int template_size, size = 0;

	  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
					     TRUE, FALSE);
	  if (stub_entry == NULL)
	    {
	      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
				     section->owner,
				     stub_name);
	      return FALSE;
	    }

	  stub_entry->stub_sec = stub_sec;
	  stub_entry->stub_offset = 0;
	  stub_entry->id_sec = link_sec;
	  stub_entry->stub_type = a8_fixes[i].stub_type;
	  stub_entry->target_section = a8_fixes[i].section;
	  stub_entry->target_value = a8_fixes[i].offset;
	  stub_entry->target_addend = a8_fixes[i].addend;
	  stub_entry->orig_insn = a8_fixes[i].orig_insn;
d5440 8
a5447 8
	  size = find_stub_size_and_template (a8_fixes[i].stub_type,
					      &template_sequence,
					      &template_size);

	  stub_entry->stub_size = size;
	  stub_entry->stub_template = template_sequence;
	  stub_entry->stub_template_size = template_size;
	}
d5450 1
a5450 1
	 elf32_arm_write_section().  */
d5530 1
a5530 1
				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d5566 1
a5566 1
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d5633 6
a5638 6
					.arm
				    ;; back_to_thumb
					ldmia r13! {r6, lr}
					bx    lr
				    __func_addr:
					.word        func  */
d5735 1
a5735 1
				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d5826 2
a5827 2
				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);
d5850 1
a5850 1
	  bfd_malloc (sizeof (elf32_arm_section_map));
d5861 2
a5862 2
	  bfd_realloc_or_free (sec_data->map, sec_data->mapsize
			       * sizeof (elf32_arm_section_map));
d5878 4
a5881 4
			     elf32_vfp11_erratum_list *branch,
			     bfd *branch_bfd,
			     asection *branch_sec,
			     unsigned int offset)
d5904 1
a5904 1
				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d5919 2
a5920 2
				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);
d5967 1
a5967 1
	 ever requires this erratum fix.  */
d5971 1
a5971 1
					TRUE, FALSE, &bh);
d5978 3
a5980 3
	 BFDs.  We must make a note of this generated mapping symbol
	 ourselves so that code byteswapping works properly in
	 elf32_arm_write_section.  */
d6213 2
a6214 2
		 the target of the call.  If it is a thumb target, we
		 insert glue.  */
d6286 4
a6289 4
	  && ELF_ST_BIND (isym->st_info) == STB_LOCAL)
	{
	  name = bfd_elf_string_from_elf_section (abfd,
	    hdr->sh_link, isym->st_name);
d6291 1
a6291 1
	  if (bfd_is_arm_special_symbol_name (name,
d6293 2
a6294 2
	    elf32_arm_section_map_add (sec, name[1], isym->st_value);
	}
d6336 11
a6346 11
	{
	case BFD_ARM_VFP11_FIX_DEFAULT:
	case BFD_ARM_VFP11_FIX_NONE:
	  globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
	  break;

	default:
	  /* Give a warning, but do as the user requests anyway.  */
	  (*_bfd_error_handler) (_("%B: warning: selected VFP11 erratum "
	    "workaround is not necessary for target architecture"), obfd);
	}
d6378 1
a6378 1
		     unsigned int x)
d6410 1
a6410 1
	return TRUE;
d6415 1
a6415 1
	continue;
d6418 1
a6418 1
	return TRUE;
d6434 1
a6434 1
			   int *numregs)
d6446 2
a6447 2
	   | ((insn & 0x00300000) >> 19)
	   | ((insn & 0x00000040) >> 6);
d6450 64
a6513 33
	{
	case 0: /* fmac[sd].  */
	case 1: /* fnmac[sd].  */
	case 2: /* fmsc[sd].  */
	case 3: /* fnmsc[sd].  */
	  vpipe = VFP11_FMAC;
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  regs[0] = fd;
	  regs[1] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);  /* Fn.  */
	  regs[2] = fm;
	  *numregs = 3;
	  break;

	case 4: /* fmul[sd].  */
	case 5: /* fnmul[sd].  */
	case 6: /* fadd[sd].  */
	case 7: /* fsub[sd].  */
	  vpipe = VFP11_FMAC;
	  goto vfp_binop;

	case 8: /* fdiv[sd].  */
	  vpipe = VFP11_DS;
	  vfp_binop:
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  regs[0] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);   /* Fn.  */
	  regs[1] = fm;
	  *numregs = 2;
	  break;

	case 15: /* extended opcode.  */
	  {
	    unsigned int extn = ((insn >> 15) & 0x1e)
			      | ((insn >> 7) & 1);
d6515 1
a6515 32
	    switch (extn)
	      {
	      case 0: /* fcpy[sd].  */
	      case 1: /* fabs[sd].  */
	      case 2: /* fneg[sd].  */
	      case 8: /* fcmp[sd].  */
	      case 9: /* fcmpe[sd].  */
	      case 10: /* fcmpz[sd].  */
	      case 11: /* fcmpez[sd].  */
	      case 16: /* fuito[sd].  */
	      case 17: /* fsito[sd].  */
	      case 24: /* ftoui[sd].  */
	      case 25: /* ftouiz[sd].  */
	      case 26: /* ftosi[sd].  */
	      case 27: /* ftosiz[sd].  */
		/* These instructions will not bounce due to underflow.  */
		*numregs = 0;
		vpipe = VFP11_FMAC;
		break;

	      case 3: /* fsqrt[sd].  */
		/* fsqrt cannot underflow, but it can (perhaps) overwrite
		   registers to cause the erratum in previous instructions.  */
		bfd_arm_vfp11_write_mask (destmask, fd);
		vpipe = VFP11_DS;
		break;

	      case 15: /* fcvt{ds,sd}.  */
		{
		  int rnum = 0;

		  bfd_arm_vfp11_write_mask (destmask, fd);
d6518 2
a6519 2
		  if ((insn & 0x100) != 0)
		    regs[rnum++] = fm;
d6521 1
a6521 1
		  *numregs = rnum;
d6523 13
a6535 13
		  vpipe = VFP11_FMAC;
		}
		break;

	      default:
		return VFP11_BAD;
	      }
	  }
	  break;

	default:
	  return VFP11_BAD;
	}
d6544 7
a6550 7
	  if (is_double)
	    bfd_arm_vfp11_write_mask (destmask, fm);
	  else
	    {
	      bfd_arm_vfp11_write_mask (destmask, fm);
	      bfd_arm_vfp11_write_mask (destmask, fm + 1);
	    }
d6561 26
a6586 26
	{
	case 0: /* Two-reg transfer.  We should catch these above.  */
	  abort ();

	case 2: /* fldm[sdx].  */
	case 3:
	case 5:
	  {
	    unsigned int i, offset = insn & 0xff;

	    if (is_double)
	      offset >>= 1;

	    for (i = fd; i < fd + offset; i++)
	      bfd_arm_vfp11_write_mask (destmask, i);
	  }
	  break;

	case 4: /* fld[sd].  */
	case 6:
	  bfd_arm_vfp11_write_mask (destmask, fd);
	  break;

	default:
	  return VFP11_BAD;
	}
d6597 12
a6608 12
	{
	case 0: /* fmsr/fmdlr.  */
	case 1: /* fmdhr.  */
	  /* Mark fmdhr and fmdlr as writing to the whole of the DP
	     destination register.  I don't know if this is exactly right,
	     but it is the conservative choice.  */
	  bfd_arm_vfp11_write_mask (destmask, fn);
	  break;

	case 7: /* fmxr.  */
	  break;
	}
d6642 3
a6644 3
	   A VFP FMAC-pipeline instruction has been seen. Fill
	   regs[0]..regs[numregs-1] with its input operands. Remember this
	   instruction in 'first_fmac'.
d6647 2
a6648 2
	   Any instruction, except for a VFP instruction which overwrites
	   regs[*].
d6652 3
a6654 3
	   A VFP instruction has been seen which overwrites any of regs[*].
	   We must make a veneer!  Reset state to 0 before examining next
	   instruction.
d6657 2
a6658 2
	   If we fail to match anything in state 2, reset to state 0 and reset
	   the instruction pointer to the instruction after 'first_fmac'.
d6689 1
a6689 1
	 section.  Also skip if section is to be excluded.  */
d6691 2
a6692 2
	  || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
	  || (sec->flags & SEC_EXCLUDE) != 0
d6695 2
a6696 2
	  || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
	continue;
d6701 1
a6701 1
	continue;
d6712 3
a6714 3
	{
	  unsigned int span_start = sec_data->map[span].vma;
	  unsigned int span_end = (span == sec_data->mapcount - 1)
d6716 1
a6716 6
	  char span_type = sec_data->map[span].type;

	  /* FIXME: Only ARM mode is supported at present.  We may need to
	     support Thumb-2 mode also at some point.  */
	  if (span_type != 'a')
	    continue;
d6718 40
a6757 35
	  for (i = span_start; i < span_end;)
	    {
	      unsigned int next_i = i + 4;
	      unsigned int insn = bfd_big_endian (abfd)
		? (contents[i] << 24)
		  | (contents[i + 1] << 16)
		  | (contents[i + 2] << 8)
		  | contents[i + 3]
		: (contents[i + 3] << 24)
		  | (contents[i + 2] << 16)
		  | (contents[i + 1] << 8)
		  | contents[i];
	      unsigned int writemask = 0;
	      enum bfd_arm_vfp11_pipe vpipe;

	      switch (state)
		{
		case 0:
		  vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
						    &numregs);
		  /* I'm assuming the VFP11 erratum can trigger with denorm
		     operands on either the FMAC or the DS pipeline. This might
		     lead to slightly overenthusiastic veneer insertion.  */
		  if (vpipe == VFP11_FMAC || vpipe == VFP11_DS)
		    {
		      state = use_vector ? 1 : 2;
		      first_fmac = i;
		      veneer_of_insn = insn;
		    }
		  break;

		case 1:
		  {
		    int other_regs[3], other_numregs;
		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6759 3
a6761 3
						      &other_numregs);
		    if (vpipe != VFP11_BAD
			&& bfd_arm_vfp11_antidependency (writemask, regs,
d6763 10
a6772 10
		      state = 3;
		    else
		      state = 2;
		  }
		  break;

		case 2:
		  {
		    int other_regs[3], other_numregs;
		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6774 3
a6776 3
						      &other_numregs);
		    if (vpipe != VFP11_BAD
			&& bfd_arm_vfp11_antidependency (writemask, regs,
d6778 31
a6808 8
		      state = 3;
		    else
		      {
			state = 0;
			next_i = first_fmac + 4;
		      }
		  }
		  break;
d6810 1
a6810 24
		case 3:
		  abort ();  /* Should be unreachable.  */
		}

	      if (state == 3)
		{
		  elf32_vfp11_erratum_list *newerr =(elf32_vfp11_erratum_list *)
		      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));

		  elf32_arm_section_data (sec)->erratumcount += 1;

		  newerr->u.b.vfp_insn = veneer_of_insn;

		  switch (span_type)
		    {
		    case 'a':
		      newerr->type = VFP11_ERRATUM_BRANCH_TO_ARM_VENEER;
		      break;

		    default:
		      abort ();
		    }

		  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
d6813 1
a6813 1
		  newerr->vma = -1;
d6815 2
a6816 2
		  newerr->next = sec_data->erratumlist;
		  sec_data->erratumlist = newerr;
d6818 2
a6819 2
		  state = 0;
		}
d6821 3
a6823 3
	      i = next_i;
	    }
	}
d6826 2
a6827 2
	  && elf_section_data (sec)->this_hdr.contents != contents)
	free (contents);
d6864 1
a6864 1
				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d6872 10
a6881 10
	{
	  struct elf_link_hash_entry *myh;
	  bfd_vma vma;

	  switch (errnode->type)
	    {
	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
	    case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
	      /* Find veneer symbol.  */
	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
d6884 2
a6885 2
	      myh = elf_link_hash_lookup
		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d6887 7
a6893 7
	      if (myh == NULL)
		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
					 "`%s'"), abfd, tmp_name);

	      vma = myh->root.u.def.section->output_section->vma
		    + myh->root.u.def.section->output_offset
		    + myh->root.u.def.value;
d6895 2
a6896 2
	      errnode->u.b.veneer->vma = vma;
	      break;
d6899 4
a6902 4
	    case VFP11_ERRATUM_THUMB_VENEER:
	      /* Find return location.  */
	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
		       errnode->u.v.id);
d6904 2
a6905 2
	      myh = elf_link_hash_lookup
		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
d6907 2
a6908 2
	      if (myh == NULL)
		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
d6911 11
a6921 11
	      vma = myh->root.u.def.section->output_section->vma
		    + myh->root.u.def.section->output_offset
		    + myh->root.u.def.value;

	      errnode->u.v.branch->vma = vma;
	      break;

	    default:
	      abort ();
	    }
	}
d6935 1
a6935 1
				 int fix_v4bx,
d6937 1
a6937 1
				 bfd_arm_vfp11_fix vfp11_fix,
a7431 4
      /* NaCl uses a special first entry in .iplt too.  */
      if (htab->nacl_p && splt->size == 0)
	splt->size += htab->plt_header_size;

d7654 1
a7654 1
			      - (plt_address + htab->plt_entry_size));
d7968 1
a7968 1
	shift = 0;
d7970 2
a7971 2
	{
	  int msb;
d7973 12
a7984 12
	  /* Determine the most significant bit in the residual and
	     align the resulting value to a 2-bit boundary.  */
	  for (msb = 30; msb >= 0; msb -= 2)
	    if (residual & (3 << msb))
	      break;

	  /* The desired shift is now (msb - 6), or zero, whichever
	     is the greater.  */
	  shift = msb - 6;
	  if (shift < 0)
	    shift = 0;
	}
d7989 1
a7989 1
		    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);
d8201 1
a8201 1
	   && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI
d8617 1
a8617 1
	     | bfd_get_16 (input_bfd, hit_data + 2);
d8619 7
a8625 7
	if (globals->use_rel)
	  {
	    signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
			  | ((insn & (1 << 26)) >> 15);
	    if (insn & 0xf00000)
	      signed_addend = -signed_addend;
	  }
d8629 2
a8630 2
			  + input_section->output_offset
			  + rel->r_offset);
d8632 1
a8632 1
	value = abs (relocation);
d8634 2
a8635 2
	if (value >= 0x1000)
	  return bfd_reloc_overflow;
d8638 4
a8641 4
	     | ((value & 0x700) << 4)
	     | ((value & 0x800) << 15);
	if (relocation < 0)
	  insn |= 0xa00000;
d8646 1
a8646 1
	return bfd_reloc_ok;
d8659 1
a8659 1
	if (globals->use_rel)
d8664 2
a8665 2
			  + input_section->output_offset
			  + rel->r_offset);
d8667 1
a8667 1
	value = abs (relocation);
d8680 1
a8680 1
	return bfd_reloc_ok;
d8690 1
a8690 1
	     | bfd_get_16 (input_bfd, hit_data + 2);
d8692 6
a8697 6
	if (globals->use_rel)
	  {
	    signed_addend = insn & 0xfff;
	    if (!(insn & (1 << 23)))
	      signed_addend = -signed_addend;
	  }
d8701 2
a8702 2
			  + input_section->output_offset
			  + rel->r_offset);
d8704 1
a8704 1
	value = abs (relocation);
d8706 2
a8707 2
	if (value >= 0x1000)
	  return bfd_reloc_overflow;
d8710 2
a8711 2
	if (relocation >= 0)
	  insn |= (1 << 23);
d8716 1
a8716 1
	return bfd_reloc_ok;
d8725 1
a8725 1
	bfd_vma reloc_sign;
d8757 1
a8757 1
	   with Thumb-1) involving the J1 and J2 bits.  */
d8760 3
a8762 3
	    bfd_vma s = (upper_insn & (1 << 10)) >> 10;
	    bfd_vma upper = upper_insn & 0x3ff;
	    bfd_vma lower = lower_insn & 0x7ff;
d8765 2
a8766 2
	    bfd_vma i1 = j1 ^ s ? 0 : 1;
	    bfd_vma i2 = j2 ^ s ? 0 : 1;
d8768 3
a8770 3
	    addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
	    /* Sign extend.  */
	    addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);
d8927 1
a8927 1
	reloc_sign = (signed_check < 0) ? 1 : 0;
d8929 2
a8930 2
		     | ((relocation >> 12) & 0x3ff)
		     | (reloc_sign << 10);
d8932 3
a8934 3
		     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
		     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
		     | ((relocation >> 1) & 0x7ff);
d8988 1
a8988 1
	relocation = value + signed_addend;
d9103 1
a9103 1
	 global offset table.  */
d9107 1
a9107 1
	return bfd_reloc_notsupported;
d9116 4
a9119 4
	 calculation.  We always want the start of .got.  If we
	 define _GLOBAL_OFFSET_TABLE in a different way, as is
	 permitted by the ABI, we might have to change this
	 calculation.  */
d9130 1
a9130 1
	return bfd_reloc_notsupported;
d9141 1
a9141 1
	 global offset table.  */
d9194 1
a9194 1
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
d9196 3
a9198 3
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  else
		    outrel.r_info = 0;
d9251 1
a9251 1
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
d9397 1
a9397 1
			    <= globals->root.sgotplt->size);
d9410 1
a9410 1
			   <= sreloc->contents + sreloc->size);
d9418 1
a9418 1
		bfd_put_32 (output_bfd,
d9426 1
a9426 1
		bfd_put_32 (output_bfd, 0,
d9742 1
a9742 1
	  return bfd_reloc_overflow;
d9748 1
a9748 1
	    || r_type == R_ARM_MOVT_BREL)
d9792 1
a9792 1
	  return bfd_reloc_overflow;
d9798 1
a9798 1
	    || r_type == R_ARM_THM_MOVT_BREL)
d9824 1
a9824 1
	bfd_vma pc = input_section->output_section->vma
d9826 6
a9831 6
	/* sb should be the origin of the *segment* containing the symbol.
	   It is not clear how to obtain this OS-dependent value, so we
	   make an arbitrary choice of zero.  */
	bfd_vma sb = 0;
	bfd_vma residual;
	bfd_vma g_n;
d9833 1
a9833 1
	int group = 0;
d9835 25
a9859 9
	/* Determine which group of bits to select.  */
	switch (r_type)
	  {
	  case R_ARM_ALU_PC_G0_NC:
	  case R_ARM_ALU_PC_G0:
	  case R_ARM_ALU_SB_G0_NC:
	  case R_ARM_ALU_SB_G0:
	    group = 0;
	    break;
d9861 2
a9862 18
	  case R_ARM_ALU_PC_G1_NC:
	  case R_ARM_ALU_PC_G1:
	  case R_ARM_ALU_SB_G1_NC:
	  case R_ARM_ALU_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_ALU_PC_G2:
	  case R_ARM_ALU_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
d9864 29
a9892 29
	  {
	    int negative;
	    bfd_vma constant = insn & 0xff;
	    bfd_vma rotation = (insn & 0xf00) >> 8;

	    if (rotation == 0)
	      signed_addend = constant;
	    else
	      {
		/* Compensate for the fact that in the instruction, the
		   rotation is stored in multiples of 2 bits.  */
		rotation *= 2;

		/* Rotate "constant" right by "rotation" bits.  */
		signed_addend = (constant >> rotation) |
				(constant << (8 * sizeof (bfd_vma) - rotation));
	      }

	    /* Determine if the instruction is an ADD or a SUB.
	       (For REL, this determines the sign of the addend.)  */
	    negative = identify_add_or_sub (insn);
	    if (negative == 0)
	      {
		(*_bfd_error_handler)
		  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
		  input_bfd, input_section,
		  (long) rel->r_offset, howto->name);
		return bfd_reloc_overflow;
	      }
d9894 2
a9895 2
	    signed_addend *= negative;
	  }
d9898 10
a9907 10
	if (r_type == R_ARM_ALU_PC_G0_NC
	    || r_type == R_ARM_ALU_PC_G1_NC
	    || r_type == R_ARM_ALU_PC_G0
	    || r_type == R_ARM_ALU_PC_G1
	    || r_type == R_ARM_ALU_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;
d9909 2
a9910 2
	/* If the target symbol is a Thumb function, then set the
	   Thumb bit in the address.  */
d9914 30
a9943 19
	/* Calculate the value of the relevant G_n, in encoded
	   constant-with-rotation format.  */
	g_n = calculate_group_reloc_mask (abs (signed_value), group,
					  &residual);

	/* Check for overflow if required.  */
	if ((r_type == R_ARM_ALU_PC_G0
	     || r_type == R_ARM_ALU_PC_G1
	     || r_type == R_ARM_ALU_PC_G2
	     || r_type == R_ARM_ALU_SB_G0
	     || r_type == R_ARM_ALU_SB_G1
	     || r_type == R_ARM_ALU_SB_G2) && residual != 0)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }
d9945 2
a9946 13
	/* Mask out the value and the ADD/SUB part of the opcode; take care
	   not to destroy the S bit.  */
	insn &= 0xff1ff000;

	/* Set the opcode according to whether the value to go in the
	   place is negative.  */
	if (signed_value < 0)
	  insn |= 1 << 22;
	else
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= g_n;
d9960 1
a9960 1
	bfd_vma pc = input_section->output_section->vma
d9962 2
a9963 2
	bfd_vma sb = 0; /* See note above.  */
	bfd_vma residual;
d9965 1
a9965 9
	int group = 0;

	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDR_PC_G0:
	  case R_ARM_LDR_SB_G0:
	    group = 0;
	    break;
d9967 21
a9987 9
	  case R_ARM_LDR_PC_G1:
	  case R_ARM_LDR_SB_G1:
	    group = 1;
	    break;

	  case R_ARM_LDR_PC_G2:
	  case R_ARM_LDR_SB_G2:
	    group = 2;
	    break;
d9989 2
a9990 6
	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
d9992 4
a9995 4
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * (insn & 0xfff);
	  }
d9998 29
a10026 8
	if (r_type == R_ARM_LDR_PC_G0
	    || r_type == R_ARM_LDR_PC_G1
	    || r_type == R_ARM_LDR_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;
d10028 2
a10029 23
	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  */
	if (residual >= 0x1000)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7ff000;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= residual;
d10043 1
a10043 1
	bfd_vma pc = input_section->output_section->vma
d10045 2
a10046 2
	bfd_vma sb = 0; /* See note above.  */
	bfd_vma residual;
d10048 1
a10048 1
	int group = 0;
d10050 21
a10070 12
	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDRS_PC_G0:
	  case R_ARM_LDRS_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_LDRS_PC_G1:
	  case R_ARM_LDRS_SB_G1:
	    group = 1;
	    break;
d10072 2
a10073 11
	  case R_ARM_LDRS_PC_G2:
	  case R_ARM_LDRS_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }

	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
d10075 4
a10078 4
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
	  }
d10081 29
a10109 8
	if (r_type == R_ARM_LDRS_PC_G0
	    || r_type == R_ARM_LDRS_PC_G1
	    || r_type == R_ARM_LDRS_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;
d10111 2
a10112 23
	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  */
	if (residual >= 0x100)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7ff0f0;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= ((residual & 0xf0) << 4) | (residual & 0xf);
d10126 1
a10126 1
	bfd_vma pc = input_section->output_section->vma
d10128 2
a10129 2
	bfd_vma sb = 0; /* See note above.  */
	bfd_vma residual;
d10131 1
a10131 14
	int group = 0;

	/* Determine which groups of bits to calculate.  */
	switch (r_type)
	  {
	  case R_ARM_LDC_PC_G0:
	  case R_ARM_LDC_SB_G0:
	    group = 0;
	    break;

	  case R_ARM_LDC_PC_G1:
	  case R_ARM_LDC_SB_G1:
	    group = 1;
	    break;
d10133 21
a10153 8
	  case R_ARM_LDC_PC_G2:
	  case R_ARM_LDC_SB_G2:
	    group = 2;
	    break;

	  default:
	    abort ();
	  }
d10155 2
a10156 2
	/* If REL, extract the addend from the insn.  If RELA, it will
	   have already been fetched for us.  */
d10158 4
a10161 4
	  {
	    int negative = (insn & (1 << 23)) ? 1 : -1;
	    signed_addend = negative * ((insn & 0xff) << 2);
	  }
d10164 31
a10194 8
	if (r_type == R_ARM_LDC_PC_G0
	    || r_type == R_ARM_LDC_PC_G1
	    || r_type == R_ARM_LDC_PC_G2)
	  /* PC relative.  */
	  signed_value = value - pc + signed_addend;
	else
	  /* Section base relative.  */
	  signed_value = value - sb + signed_addend;
d10196 2
a10197 25
	/* Calculate the value of the relevant G_{n-1} to obtain
	   the residual at that stage.  */
	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

	/* Check for overflow.  (The absolute value to go in the place must be
	   divisible by four and, after having been divided by four, must
	   fit in eight bits.)  */
	if ((residual & 0x3) != 0 || residual >= 0x400)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
	      input_bfd, input_section,
	      (long) rel->r_offset, abs (signed_value), howto->name);
	    return bfd_reloc_overflow;
	  }

	/* Mask out the value and U bit.  */
	insn &= 0xff7fff00;

	/* Set the U bit if the value to go in the place is non-negative.  */
	if (signed_value >= 0)
	  insn |= 1 << 23;

	/* Encode the offset.  */
	insn |= residual >> 2;
d10349 2
a10350 2
	  || r_type == R_ARM_GNU_VTINHERIT)
	continue;
d10543 4
a10546 4
	 done, i.e., the relaxation produced the final output we want,
	 and we won't let anybody mess with it. Also, we have to do
	 addend adjustments in case of a R_ARM_TLS_GOTDESC relocation
	 both in relaxed and non-relaxed cases */
d10574 2
a10575 2
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
d10722 1
a10722 1
	codes which have been inlined into the index).
d10748 1
a10748 1
	{
d10758 1
a10758 1
		= &elf_section_data (elf_sec->linked_to)->this_hdr;
d10760 1
a10760 1
		= get_arm_elf_section_data (linked_hdr->bfd_section);
d10763 1
a10763 1
		continue;
d10766 1
a10766 1
		 describes.  */
d10791 1
a10791 1
	continue;
d10815 1
a10815 1
	continue;
d10819 1
a10819 1
	continue;
d10869 1
a10869 1
	free (contents);
d11082 1
a11082 1
	 then turn off the interworking bit.  */
d11514 1
a11514 1
		!= out_attr[Tag_MPextension_use].i)
d11702 1
a11702 1
		 'M' and 'A|R|S' is an error.  */
d11800 1
a11800 1
		 options.  */
d11816 1
a11816 1
		 a warning.  */
d12489 1
a12489 1
	{
d12532 1
a12532 1
		 slots may be created.  */
d12545 3
a12547 3
		 method, we're able to relax. Turn off the GDESC flag,
		 without messing up with any other kind of tls types
		 that may be involved */
d12644 16
a12659 16
	/* This relocation describes the C++ object vtable hierarchy.
	   Reconstruct it for later use during GC.  */
	case R_ARM_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	/* This relocation describes which C++ vtable entries are actually
	   used.  Record for later use during GC.  */
	case R_ARM_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
	}
d12917 1
a12917 1
				     section, symbols, offset,
d13228 2
a13229 2
	      if (tls_type & GOT_TLS_GDESC)
		{
d13231 1
a13231 1
		  eh->tlsdesc_got
d13234 2
a13235 2
		  htab->root.sgotplt->size += 8;
		  h->got.offset = (bfd_vma) -2;
d13238 2
a13239 2
		  htab->num_tls_desc++;
		}
d13351 5
a13355 5
	 R_ARM_REL32_NOI, which will appear on something like
	 ".long foo - .".  We want calls to protected symbols to resolve
	 directly to the function rather than going via the plt.  If people
	 want function pointer comparisons to work as expected then they
	 should avoid writing assembly like ".long foo - .".  */
d13385 1
a13385 1
	 visibility.  */
d13556 1
a13556 1
		   elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
d13652 1
a13652 1
		  htab->num_tls_desc++;
d13718 2
a13719 2
	/* xgettext:c-format */
	_bfd_error_handler (_("Errors encountered processing file %s"),
d13743 1
a13743 1
	 PLT and GOT entries they require.  */
d13897 1
a13897 1
				struct bfd_link_info *info)
d13914 2
a13915 2
	{
	  struct bfd_link_hash_entry *bh = NULL;
d13917 1
a13917 1
	    = get_elf_backend_data (output_bfd);
d13919 1
a13919 1
	  if (!(_bfd_generic_link_add_one_symbol
d13925 5
a13929 5
	  tlsbase->type = STT_TLS;
	  tlsbase = (struct elf_link_hash_entry *)bh;
	  tlsbase->def_regular = 1;
	  tlsbase->other = STV_HIDDEN;
	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
a14036 32
/* Install the special first PLT entry for elf32-arm-nacl.  Unlike
   other variants, NaCl needs this entry in a static executable's
   .iplt too.  When we're handling that case, GOT_DISPLACEMENT is
   zero.  For .iplt really only the last bundle is useful, and .iplt
   could have a shorter first entry, with each individual PLT entry's
   relative branch calculated differently so it targets the last
   bundle instead of the instruction before it (labelled .Lplt_tail
   above).  But it's simpler to keep the size and layout of PLT0
   consistent with the dynamic case, at the cost of some dead code at
   the start of .iplt and the one dead store to the stack at the start
   of .Lplt_tail.  */
static void
arm_nacl_put_plt0 (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
		   asection *plt, bfd_vma got_displacement)
{
  unsigned int i;

  put_arm_insn (htab, output_bfd,
		elf32_arm_nacl_plt0_entry[0]
		| arm_movw_immediate (got_displacement),
		plt->contents + 0);
  put_arm_insn (htab, output_bfd,
		elf32_arm_nacl_plt0_entry[1]
		| arm_movt_immediate (got_displacement),
		plt->contents + 4);

  for (i = 2; i < ARRAY_SIZE (elf32_arm_nacl_plt0_entry); ++i)
    put_arm_insn (htab, output_bfd,
		  elf32_arm_nacl_plt0_entry[i],
		  plt->contents + (i * 4));
}

d14202 1
a14202 1
	      s = htab->root.splt;
d14209 1
a14209 1
	      s = htab->root.sgot;
d14211 1
a14211 1
				+ htab->dt_tlsdesc_got);
d14275 18
a14292 2
	    arm_nacl_put_plt0 (htab, output_bfd, splt,
			       got_address + 8 - (plt_address + 16));
a14384 4
  if (htab->nacl_p && htab->root.iplt != NULL && htab->root.iplt->size > 0)
    /* NaCl uses a special first entry in .iplt too.  */
    arm_nacl_put_plt0 (htab, output_bfd, htab->root.iplt, 0);

a14955 9
  if (htab->nacl_p && htab->root.iplt && htab->root.iplt->size > 0)
    {
      /* NaCl uses a special first entry in .iplt too.  */
      osi.sec = htab->root.iplt;
      osi.sec_shndx = (_bfd_elf_section_from_bfd_section
		       (output_bfd, osi.sec->output_section));
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
	return FALSE;
    }
d15092 1
a15092 1
		       void *in_arg)
d15231 13
a15243 13
	   errnode = errnode->next)
	{
	  bfd_vma target = errnode->vma - offset;

	  switch (errnode->type)
	    {
	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
	      {
		bfd_vma branch_to_veneer;
		/* Original condition code of instruction, plus bit mask for
		   ARM B instruction.  */
		unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
				  | 0x0a000000;
d15250 1
a15250 1
				   - errnode->vma - 4;
d15257 7
a15263 7
		insn |= (branch_to_veneer >> 2) & 0xffffff;
		contents[endianflip ^ target] = insn & 0xff;
		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
	      }
	      break;
d15266 7
a15272 7
	      {
		bfd_vma branch_from_veneer;
		unsigned int insn;

		/* Take size of veneer into account.  */
		branch_from_veneer = errnode->u.v.branch->vma
				     - errnode->vma - 12;
d15279 20
a15298 20
		/* Original instruction.  */
		insn = errnode->u.v.branch->u.b.vfp_insn;
		contents[endianflip ^ target] = insn & 0xff;
		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;

		/* Branch back to insn after original insn.  */
		insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
		contents[endianflip ^ (target + 4)] = insn & 0xff;
		contents[endianflip ^ (target + 5)] = (insn >> 8) & 0xff;
		contents[endianflip ^ (target + 6)] = (insn >> 16) & 0xff;
		contents[endianflip ^ (target + 7)] = (insn >> 24) & 0xff;
	      }
	      break;

	    default:
	      abort ();
	    }
	}
d15304 1
a15304 1
	= arm_data->u.exidx.unwind_edit_list;
d15306 1
a15306 1
	 size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
d15315 1
a15315 1
	{
d15321 1
a15321 1
		{
d15330 1
a15330 1
		{
d15340 1
a15340 1
			asection *text_sec = edit_node->linked_section;
d15345 1
a15345 1
			unsigned long prel31_offset;
d15410 2
a15411 2
	{
	  if (i == mapcount - 1)
d15413 2
a15414 2
	  else
	    end = map[i + 1].vma;
d15416 1
a15416 1
	  switch (map[i].type)
d15421 9
a15429 9
		{
		  tmp = contents[ptr];
		  contents[ptr] = contents[ptr + 3];
		  contents[ptr + 3] = tmp;
		  tmp = contents[ptr + 1];
		  contents[ptr + 1] = contents[ptr + 2];
		  contents[ptr + 2] = tmp;
		  ptr += 4;
		}
d15435 6
a15440 6
		{
		  tmp = contents[ptr];
		  contents[ptr] = contents[ptr + 1];
		  contents[ptr + 1] = tmp;
		  ptr += 2;
		}
d15447 2
a15448 2
	  ptr = end;
	}
d15517 11
a15527 11
	{
	  /* Do this only for defined symbols. At link type, the static
	     linker will simulate the work of dynamic linker of resolving
	     symbols and will carry over the thumbness of found symbols to
	     the output symbol table. It's not clear how it happens, but
	     the thumbness of undefined symbols can well be different at
	     runtime, and writing '1' for them will be confusing for users
	     and possibly for dynamic linker itself.
	  */
	  newsym.st_value |= 1;
	}
d15555 1
a15555 1
	      bfd_zalloc (abfd, sizeof (struct elf_segment_map));
d15892 2
a15893 2
	 uninitialised values, which surprise surprise, correspond
	 to the default values.  */
d15941 1
a15941 1
		only_data_sections = FALSE;
@


1.298.2.6
log
@bfd/efl32-arm.c: Fix handling of IRELATIVE relocs.

bfd/ChangeLog:

2013-05-28  Will Newton  <will.newton@@linaro.org>

	* elf32-arm.c (elf32_arm_populate_plt_entry): Call
	elf32_arm_add_dynreloc when emitting R_ARM_IRELATIVE relocs.

ld/testsuite/ChangeLog:

2013-05-28  Will Newton  <will.newton@@linaro.org>

	* ld-arm/arm-elf.exp: Add IFUNC test 17.
	* ld-arm/ifunc-17.dd: New file.
	* ld-arm/ifunc-17.gd: Likewise.
	* ld-arm/ifunc-17.rd: Likewise.
	* ld-arm/ifunc-17.s: Likweise.
	* ld-arm/ifunc-1.rd: Reorder relocs to match linker output.
	* ld-arm/ifunc-2.rd: Likewise.
	* ld-arm/ifunc-5.rd: Likewise.
	* ld-arm/ifunc-6.rd: Likewise.
@
text
@d7737 2
a7738 7
  if (dynindx == -1)
    elf32_arm_add_dynreloc (output_bfd, info, srel, &rel);
  else
    {
      loc = srel->contents + plt_index * RELOC_SIZE (htab);
      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
    }
@


1.298.2.7
log
@bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_arm_nacl): New variable.
	(elf32_arm_stub_long_branch_arm_nacl_pic): New variable.
	(arm_build_one_stub): Increase MAXRELOCS to 3.
	(arm_type_of_stub): Use them if GLOBALS->nacl_p.
	(struct elf32_arm_link_hash_table): Give add_stub_section member's
	pointee type a third argument.
	(elf32_arm_create_or_find_stub_sec): Update caller.
	(elf32_arm_size_stubs): Update argument type.
	* bfd-in.h (elf32_arm_size_stubs): Update decl.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

ld/
	* emultempl/armelf.em (elf32_arm_add_stub_section): Take third
	argument ALIGNMENT_POWER, use it instead of constant 3.

ld/testsuite/
	* ld-arm/farcall-arm-nacl.d: New file.
	* ld-arm/farcall-arm-nacl-pic.d: New file.
	* ld-arm/farcall-data-nacl.d: New file.
	* ld-arm/arm-elf.exp (armeabitests_common): Add extra element to
	"action" lists for those cases to use a different dump file for NaCl
	targets.
	Massage $armeabitests_common to drop the extra element or the one
	before it, depending on [istarget "arm*-*-nacl*"].

	* ld-arm/arm-elf.exp (armelftests_common): Move all "Cortex-A8
	erratum fix", Thumb-only and interworking cases to ...
	(armelftests_nonacl): ... here.
	(armeabitests_common): Move all "erratum 760522 fix", Thumb-only
	and interworking cases to ...
	(armeabitests_nonacl): ... here.
@
text
@a2418 27
/* NaCl ARM -> ARM long branch stub.  */
static const insn_sequence elf32_arm_stub_long_branch_arm_nacl[] =
{
  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
  ARM_INSN (0xe12fff1c),                /* bx	ip */
  ARM_INSN (0xe320f000),                /* nop */
  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
  DATA_WORD (0, R_ARM_ABS32, 0),        /* dcd	R_ARM_ABS32(X) */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
};

/* NaCl ARM -> ARM long branch stub, PIC.  */
static const insn_sequence elf32_arm_stub_long_branch_arm_nacl_pic[] =
{
  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
  ARM_INSN (0xe08cc00f),                /* add	ip, ip, pc */
  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
  ARM_INSN (0xe12fff1c),                /* bx	ip */
  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
  DATA_WORD (0, R_ARM_REL32, 8),        /* dcd	R_ARM_REL32(X+8) */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
};


a2494 2
  DEF_STUB(long_branch_arm_nacl) \
  DEF_STUB(long_branch_arm_nacl_pic) \
d2987 1
a2987 1
  asection * (*add_stub_section) (const char *, asection *, unsigned int);
a3810 1
		   : globals->nacl_p ? arm_stub_long_branch_arm_nacl_pic
a3812 1
		: globals->nacl_p ? arm_stub_long_branch_arm_nacl
d3949 1
a3949 2
	  stub_sec = (*htab->add_stub_section) (s_name, link_sec,
						htab->nacl_p ? 4 : 3);
a4081 4
    case arm_stub_long_branch_arm_nacl:
    case arm_stub_long_branch_arm_nacl_pic:
      return 16;

d4091 1
a4091 1
#define MAXRELOCS 3
d4903 1
a4903 2
		      asection * (*add_stub_section) (const char *, asection *,
						      unsigned int),
@


1.298.2.8
log
@bfd/
	* elf-nacl.c (nacl_modify_segment_map): Fix logic reordering the
	elf_segment_map list.  If an executable segment is page-aligned
	but does not end with a full page, then append a fake section into
	the segment map entry that pads out the page.
	(nacl_final_write_processing): New function.  Write the code fill
	laid out in nacl_modify_segment_map.
	* elf-nacl.h: Declare it.
	* elf32-arm.c (elf32_arm_nacl_final_write_processing): New function.
	(elf_backend_final_write_processing): Define it for NaCl backend.
	* elf32-i386.c (elf_backend_final_write_processing): Likewise.
	* elf64-x86-64.c (elf_backend_final_write_processing): Likewise.

	* elf-nacl.c (segment_eligible_for_headers): Rename MAXPAGESIZE
	parameter to MINPAGESIZE.
	(nacl_modify_segment_map): Use minpagesize instead of maxpagesize.

	* elf32-arm.c (ELF_MINPAGESIZE, ELF_COMMONPAGESIZE): Set to
	0x10000	for NaCl targets.

ld/testsuite/
	* ld-x86-64/ilp32-4-nacl.d: Loosen .shstrtab line regexp to match
	any file offset.
	* ld-x86-64/tlsbin-nacl.rd: Update expected code segment PT_LOAD.
	* ld-x86-64/tlsbindesc-nacl.rd: Likewise.
	* ld-scripts/rgn-at3.d: XFAIL for *-*-nacl* targets.
	* ld-scripts/rgn-over8-ok.d: Likewise.
@
text
@a15834 8
static void
elf32_arm_nacl_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  elf32_arm_final_write_processing (abfd, linker);
  nacl_final_write_processing (abfd, linker);
}


a15845 2
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_nacl_final_write_processing
a15848 3
#undef	ELF_MINPAGESIZE
#undef	ELF_COMMONPAGESIZE

a15856 7
#undef  elf_backend_final_write_processing
#define elf_backend_final_write_processing	elf32_arm_final_write_processing
#undef	ELF_MINPAGESIZE
#define ELF_MINPAGESIZE			0x1000
#undef	ELF_COMMONPAGESIZE
#define ELF_COMMONPAGESIZE		0x1000

@


1.297
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d14086 8
a14093 1
	      BFD_ASSERT (s != NULL);
@


1.296
log
@	PR ld/14189
	* elf32-arm.c (elf32_arm_check_relocs): Do not increment refcount
	for locally bound symbols.
@
text
@d12889 1
a12889 1
				     line_ptr, 0,
@


1.295
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d12672 2
a12673 1
	  root_plt->refcount += 1;
@


1.294
log
@bfd/
	* elf32-arm.c (elf32_arm_populate_plt_entry): Use int32_t for
	displacement calculation in nacl_p case.
@
text
@d3259 2
a3260 2
      s = bfd_make_section_with_flags (dynobj, ".iplt",
				       flags | SEC_READONLY | SEC_CODE);
d3269 3
a3271 2
      s = bfd_make_section_with_flags (dynobj, RELOC_SECTION (htab, ".iplt"),
				       flags | SEC_READONLY);
d3280 1
a3280 1
      s = bfd_make_section_with_flags (dynobj, ".igot.plt", flags);
d3308 1
a3308 1
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d3310 2
a3311 2
    htab->srelbss = bfd_get_section_by_name (dynobj,
					     RELOC_SECTION (htab, ".bss"));
d5658 1
a5658 1
	  s = bfd_get_section_by_name (abfd, name);
d5667 1
a5667 1
  s = bfd_get_section_by_name (abfd, name);
d5723 1
a5723 1
  s = bfd_get_section_by_name
d5799 1
a5799 1
  s = bfd_get_section_by_name
d5890 1
a5890 1
  s = bfd_get_section_by_name
d5997 1
a5997 1
  sec = bfd_get_section_by_name (abfd, name);
d6002 1
a6002 1
  sec = bfd_make_section_with_flags (abfd, name, ARM_GLUE_SECTION_FLAGS);
d7022 2
a7023 2
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       THUMB2ARM_GLUE_SECTION_NAME);
d7212 2
a7213 2
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
d7266 2
a7267 2
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
d7301 2
a7302 2
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM_BX_GLUE_SECTION_NAME);
d10889 1
a10889 1
  sec = bfd_get_section_by_name (ibfd, name);
d13042 1
a13042 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d13053 1
a13053 1
      srel = bfd_get_section_by_name (dynobj, RELOC_SECTION (globals, ".bss"));
d13495 1
a13495 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d14027 1
a14027 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d14812 2
a14813 2
      osi.sec = bfd_get_section_by_name (htab->bfd_of_glue_owner,
					 ARM2THUMB_GLUE_SECTION_NAME);
d14835 2
a14836 2
      osi.sec = bfd_get_section_by_name (htab->bfd_of_glue_owner,
					 THUMB2ARM_GLUE_SECTION_NAME);
d14852 2
a14853 2
      osi.sec = bfd_get_section_by_name (htab->bfd_of_glue_owner,
					 ARM_BX_GLUE_SECTION_NAME);
@


1.293
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Correct return value.
@
text
@d26 1
d7633 1
a7633 1
	  bfd_vma tail_displacement
d7646 2
a7647 1
	  got_displacement = got_address - (plt_address + htab->plt_entry_size);
d10987 1
a10987 1
	      return bfd_mach_arm_iWMMXt;	
@


1.292
log
@	* elf32-arm.c (bfd_arm_get_mach_from_attributes): New function.
	(elf32_arm_object_p): If the machine number could not be deduced
	from the notes, call bfd_arm_get_mach_from_attributes to get the
	number from the attributes.
@
text
@d9667 1
a9667 1
	  return (bfd_reloc_status_type) FALSE;
@


1.291
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@d10959 37
d11005 7
a11011 8
  if (mach != bfd_mach_arm_unknown)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);

  else if (elf_elfheader (abfd)->e_flags & EF_ARM_MAVERICK_FLOAT)
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, bfd_mach_arm_ep9312);

  else
    bfd_default_set_arch_mach (abfd, bfd_arch_arm, mach);
d11013 1
@


1.290
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d3261 1
a3261 1
	  || !bfd_set_section_alignment (abfd, s, bed->plt_alignment))
d3271 1
a3271 1
	  || !bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
@


1.289
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@d10486 1
a10486 1
					 rel, relend, howto, contents);
@


1.288
log
@	PR ld/13990
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Handle a forced-local
	symbol, where PLT refcount is set to -1.
@
text
@d14443 1
a14443 1
  void *finfo;
d14478 1
a14478 1
  return osi->func (osi->finfo, names[type], &sym, osi->sec, NULL) == 1;
d14605 1
a14605 1
  return osi->func (osi->finfo, name, &sym, osi->sec, NULL) == 1;
d14717 1
a14717 1
				  void *finfo,
d14735 1
a14735 1
  osi.finfo = finfo;
@


1.287
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d12259 13
a12271 2
	  BFD_ASSERT (root_plt->refcount > 0);
	  root_plt->refcount -= 1;
@


1.286
log
@	* elf32-arm.c (elf32_arm_nacl_plt0_entry, elf32_arm_nacl_plt_entry):
	New variables.
	(struct elf32_arm_link_hash_table): New member `nacl_p'.
	(elf32_arm_link_hash_table_create): Initialize it.
	(elf32_arm_nacl_link_hash_table_create): New function.
	(arm_movw_immediate, arm_movt_immediate): New functions.
	(elf32_arm_populate_plt_entry): Test HTAB->nacl_p.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_output_plt_map_1): Likewise.
	(bfd_elf32_littlearm_nacl_vec, bfd_elf32_bigarm_nacl_vec):
	New backend vector stanza.
	(elf32_arm_nacl_modify_segment_map): New function.
	* config.bfd: Handle arm-*-nacl*, armeb-*-nacl*.
	* targets.c: Support bfd_elf32_{big,little}_nacl_vec.
	* configure.in: Likewise.
	(bfd_elf32_bigarm_nacl_vec): Add elf-nacl.lo here.
	(bfd_elf32_littlearm_nacl_vec): Likewise.
	(bfd_elf32_bigarm_vec, bfd_elf32_littlearm_vec): Likewise.
	(bfd_elf32_bigarm_symbian_vec): Likewise.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(bfd_elf32_bigarm_vxworks_vec): Likewise.
	(bfd_elf32_littlearm_vxworks_vec): Likewise.
	* configure: Regenerated.

	* configure.tgt (arm-*-nacl*): Match it.
	* config/te-nacl.h (FPU_DEFAULT, EABI_DEFAULT): Define.
	(LOCAL_LABELS_DOLLAR): Define.
	* config/tc-arm.c (elf32_arm_target_format) [TE_NACL]:
	Use nacl format variants.

	* gas/elf/elf.exp (run_elf_list_test): Treat arm-*-nacl* targets
	as -armeabi.

	* gas/arm/any-idiv.d: Match *-*-nacl* targets too.
	* gas/arm/arch4t.d: Likewise.
	* gas/arm/arch4t-eabi.d: Likewise.
	* gas/arm/attr-any-armv4t.d: Likewise.
	* gas/arm/attr-any-thumbv6.d: Likewise.
	* gas/arm/attr-cpu-directive.d: Likewise.
	* gas/arm/attr-default.d: Likewise.
	* gas/arm/attr-march-all.d: Likewise.
	* gas/arm/attr-march-armv1.d: Likewise.
	* gas/arm/attr-march-armv2a.d: Likewise.
	* gas/arm/attr-march-armv2.d: Likewise.
	* gas/arm/attr-march-armv2s.d: Likewise.
	* gas/arm/attr-march-armv3.d: Likewise.
	* gas/arm/attr-march-armv3m.d: Likewise.
	* gas/arm/attr-march-armv4.d: Likewise.
	* gas/arm/attr-march-armv4t.d: Likewise.
	* gas/arm/attr-march-armv4txm.d: Likewise.
	* gas/arm/attr-march-armv4xm.d: Likewise.
	* gas/arm/attr-march-armv5.d: Likewise.
	* gas/arm/attr-march-armv5t.d: Likewise.
	* gas/arm/attr-march-armv5te.d: Likewise.
	* gas/arm/attr-march-armv5tej.d: Likewise.
	* gas/arm/attr-march-armv5texp.d: Likewise.
	* gas/arm/attr-march-armv5txm.d: Likewise.
	* gas/arm/attr-march-armv6.d: Likewise.
	* gas/arm/attr-march-armv6j.d: Likewise.
	* gas/arm/attr-march-armv6k.d: Likewise.
	* gas/arm/attr-march-armv6k+sec.d: Likewise.
	* gas/arm/attr-march-armv6kt2.d: Likewise.
	* gas/arm/attr-march-armv6-m.d: Likewise.
	* gas/arm/attr-march-armv6-m+os.d: Likewise.
	* gas/arm/attr-march-armv6s-m.d: Likewise.
	* gas/arm/attr-march-armv6t2.d: Likewise.
	* gas/arm/attr-march-armv6z.d: Likewise.
	* gas/arm/attr-march-armv6zk.d: Likewise.
	* gas/arm/attr-march-armv6zkt2.d: Likewise.
	* gas/arm/attr-march-armv6zt2.d: Likewise.
	* gas/arm/attr-march-armv7-a.d: Likewise.
	* gas/arm/attr-march-armv7a.d: Likewise.
	* gas/arm/attr-march-armv7-a+idiv.d: Likewise.
	* gas/arm/attr-march-armv7-a+mp.d: Likewise.
	* gas/arm/attr-march-armv7-a+sec.d: Likewise.
	* gas/arm/attr-march-armv7-a+sec+virt.d: Likewise.
	* gas/arm/attr-march-armv7-a+virt.d: Likewise.
	* gas/arm/attr-march-armv7.d: Likewise.
	* gas/arm/attr-march-armv7em.d: Likewise.
	* gas/arm/attr-march-armv7-m.d: Likewise.
	* gas/arm/attr-march-armv7m.d: Likewise.
	* gas/arm/attr-march-armv7-r.d: Likewise.
	* gas/arm/attr-march-armv7r.d: Likewise.
	* gas/arm/attr-march-armv7-r+mp.d: Likewise.
	* gas/arm/attr-march-iwmmxt2.d: Likewise.
	* gas/arm/attr-march-iwmmxt.d: Likewise.
	* gas/arm/attr-march-xscale.d: Likewise.
	* gas/arm/attr-mcpu.d: Likewise.
	* gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/arm/attr-mfpu-arm7500fe.d: Likewise.
	* gas/arm/attr-mfpu-fpa10.d: Likewise.
	* gas/arm/attr-mfpu-fpa11.d: Likewise.
	* gas/arm/attr-mfpu-fpa.d: Likewise.
	* gas/arm/attr-mfpu-fpe2.d: Likewise.
	* gas/arm/attr-mfpu-fpe3.d: Likewise.
	* gas/arm/attr-mfpu-fpe.d: Likewise.
	* gas/arm/attr-mfpu-maverick.d: Likewise.
	* gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/arm/attr-mfpu-softfpa.d: Likewise.
	* gas/arm/attr-mfpu-softvfp.d: Likewise.
	* gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/arm/attr-names.d: Likewise.
	* gas/arm/attr-order.d: Likewise.
	* gas/arm/attr-override-cpu-directive.d: Likewise.
	* gas/arm/attr-override-mcpu.d: Likewise.
	* gas/arm/got_prel.d: Likewise.
	* gas/arm/mapdir.d: Likewise.
	* gas/arm/mapmisc.d: Likewise.
	* gas/arm/mapsecs.d: Likewise.
	* gas/arm/mapshort-eabi.d: Likewise.
	* gas/arm/mapshort-elf.d: Likewise.
	* gas/arm/mov-highregs-any.d: Likewise.
	* gas/arm/mov-lowregs-any.d: Likewise.
	* gas/arm/pr12198-1.d: Likewise.
	* gas/arm/pr12198-2.d: Likewise.
	* gas/arm/thumb.d: Likewise.
	* gas/arm/thumb-eabi.d: Likewise.
	* gas/arm/thumbrel.d: Likewise.

	* configure.tgt (arm*-*-nacl*, arm*b-*-nacl*): Handle them.
	* emulparams/armelf_nacl.sh: New file.
	* emulparams/armelfb_nacl.sh: New file.
	* Makefile.am (ALL_EMULATION_SOURCES): Add earmelf_nacl.c
	and earmelfb_nacl.c here.
	(earmelf_nacl.c, earmelfb_nacl.c): New targets.
	* Makefile.in: Regenerated.

	* ld-arm/arm-elf.exp (armelftests): Split out into ...
	(armelftests_common, armelftests_nonacl): ... these two.
	(armeabitests): Split out into ...
	(armeabitests_common, armeabitests_nonacl): ... these two.
	Omit _nonacl sets for arm*-*-nacl* targets.

	* ld-arm/farcall-mix.d: Don't match exact addresses, only symbolic ones.
	* ld-arm/farcall-mix2.d: Likewise.
	* ld-arm/farcall-group.d: Likewise.

	* ld-arm/tls-gdesc-got.d: Match variant file formats too.
	Accept some variation in exact addresses.

	* ld-arm/thumb2-b-interwork.d: Match variant file formats too.
	Fix regexps not to care about exact addresses where not relevant.

	* ld-arm/thumb2-bl-undefweak.d: Match any hex strings, not any
	strings of particular exact lengths.
	* ld-arm/thumb2-bl-undefweak1.d: Likewise.

	* ld-arm/arm-app.r: Match variant file formats too.
	* ld-arm/arm-app-abs32.r: Likewise.
	* ld-arm/arm-lib.d: Likewise.
	* ld-arm/arm-lib.r: Likewise.
	* ld-arm/arm-static-app.r: Likewise.
	* ld-arm/armv4-bx.d: Likewise.
	* ld-arm/data-only-map.d: Likewise.
	* ld-arm/group-relocs.d: Likewise.
	* ld-arm/jump19.d: Likewise.
	* ld-arm/reloc-boundaries.d: Likewise.
	* ld-arm/thumb1-bl.d: Likewise.
	* ld-arm/thumb2-bl.d: Likewise.
	* ld-arm/tls-app.d: Likewise.
	* ld-arm/tls-app.r: Likewise.
	* ld-arm/tls-gdierelax.d: Likewise.
	* ld-arm/tls-gdierelax2.d: Likewise.
	* ld-arm/tls-gdlerelax.d: Likewise.
	* ld-arm/tls-lib.d: Likewise.
	* ld-arm/tls-lib.r: Likewise.
	* ld-arm/tls-mixed.r: Likewise.
	* ld-arm/vfp11-fix-none.d: Likewise.
	* ld-arm/vfp11-fix-scalar.d: Likewise.
	* ld-arm/vfp11-fix-vector.d: Likewise.
	* ld-arm/arm-static-app.d: Likewise.
	Fix regexps not to care about exact number of leading spaces.
	* ld-arm/arm-app-abs32.d: Likewise.
	* ld-arm/fix-arm1176-off.d: Likewise.
	* ld-arm/fix-arm1176-on.d: Likewise.

	* ld-arm/arm-elf.exp: Treat nacl targets like eabi targets.
@
text
@d4614 1
a4614 1
          || (section->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
d6685 1
a6685 1
	  || sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS
d10484 1
a10484 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.285
log
@	* bfd/elf32-arm.c (elf32_arm_attributes_accept_div): New function.
	(elf32_arm_attributes_forbid_div): Likewise.
	(elf32_arm_merge_eabi_attributes): Correct handling of
	Tag_DIV_use.
@
text
@d29 1
d2082 5
a2086 5
  {
    0xe08e0000,		/* add r0, lr, r0 */
    0xe5901004,		/* ldr r1, [r0,#4] */
    0xe12fff11,		/* bx  r1 */
  };
d2089 8
a2096 8
  {
    0xe52d2004, /*	push    {r2}			*/
    0xe59f200c, /*      ldr     r2, [pc, #3f - . - 8]	*/
    0xe59f100c, /*      ldr     r1, [pc, #4f - . - 8]	*/
    0xe79f2002, /* 1:   ldr     r2, [pc, r2]		*/
    0xe081100f, /* 2:   add     r1, pc			*/
    0xe12fff12, /*      bx      r2			*/
    0x00000014, /* 3:   .word  _GLOBAL_OFFSET_TABLE_ - 1b - 8
d2098 2
a2099 2
    0x00000018, /* 4:   .word  _GLOBAL_OFFSET_TABLE_ - 2b - 8 */ 
  };
d2108 6
a2113 6
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe010,		/* ldr   lr, [pc, #16]  */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
  };
d2118 6
a2123 6
  {
    0xe28fc600,		/* add   ip, pc, #NN	*/
    0xe28cca00,		/* add	 ip, ip, #NN	*/
    0xe5bcf000,		/* ldr	 pc, [ip, #NN]! */
    0x00000000,		/* unused		*/
  };
d2132 7
a2138 7
  {
    0xe52de004,		/* str   lr, [sp, #-4]! */
    0xe59fe004,		/* ldr   lr, [pc, #4]   */
    0xe08fe00e,		/* add   lr, pc, lr     */
    0xe5bef008,		/* ldr   pc, [lr, #8]!  */
    0x00000000,		/* &GOT[0] - .          */
  };
d2143 5
a2147 5
  {
    0xe28fc600,		/* add   ip, pc, #0xNN00000 */
    0xe28cca00,		/* add	 ip, ip, #0xNN000   */
    0xe5bcf000,		/* ldr	 pc, [ip, #0xNNN]!  */
  };
d2154 6
a2159 6
  {
    0xe52dc008,	        /* str    ip,[sp,#-8]!			*/
    0xe59fc000,         /* ldr    ip,[pc]			*/
    0xe59cf008,         /* ldr    pc,[ip,#8]			*/
    0x00000000,         /* .long  _GLOBAL_OFFSET_TABLE_		*/
  };
d2163 8
a2170 8
  {
    0xe59fc000,         /* ldr    ip,[pc]			*/
    0xe59cf000,         /* ldr    pc,[ip]			*/
    0x00000000,         /* .long  @@got				*/
    0xe59fc000,         /* ldr    ip,[pc]			*/
    0xea000000,         /* b      _PLT				*/
    0x00000000,         /* .long  @@pltindex*sizeof(Elf32_Rela)	*/
  };
d2174 8
a2181 8
  {
    0xe59fc000,         /* ldr    ip,[pc]			*/
    0xe79cf009,         /* ldr    pc,[ip,r9]			*/
    0x00000000,         /* .long  @@got				*/
    0xe59fc000,         /* ldr    ip,[pc]			*/
    0xe599f008,         /* ldr    pc,[r9,#8]			*/
    0x00000000,         /* .long  @@pltindex*sizeof(Elf32_Rela)	*/
  };
d2186 4
a2189 4
  {
    0x4778,		/* bx pc */
    0x46c0		/* nop   */
  };
d2194 43
a2236 4
  {
    0xe51ff004,         /* ldr   pc, [pc, #-4] */
    0x00000000,         /* dcd   R_ARM_GLOB_DAT(X) */
  };
d2246 6
a2251 6
  {
    THUMB16_TYPE = 1,
    THUMB32_TYPE,
    ARM_TYPE,
    DATA_TYPE
  };
d2265 4
a2268 4
  bfd_vma data;
  enum stub_insn_type type;
  unsigned int r_type;
  int reloc_addend;
d2274 4
a2277 4
  {
    ARM_INSN(0xe51ff004),            /* ldr   pc, [pc, #-4] */
    DATA_WORD(0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
  };
d2282 5
a2286 5
  {
    ARM_INSN(0xe59fc000),            /* ldr   ip, [pc, #0] */
    ARM_INSN(0xe12fff1c),            /* bx    ip */
    DATA_WORD(0, R_ARM_ABS32, 0),    /* dcd   R_ARM_ABS32(X) */
  };
d2290 9
a2298 9
  {
    THUMB16_INSN(0xb401),             /* push {r0} */
    THUMB16_INSN(0x4802),             /* ldr  r0, [pc, #8] */
    THUMB16_INSN(0x4684),             /* mov  ip, r0 */
    THUMB16_INSN(0xbc01),             /* pop  {r0} */
    THUMB16_INSN(0x4760),             /* bx   ip */
    THUMB16_INSN(0xbf00),             /* nop */
    DATA_WORD(0, R_ARM_ABS32, 0),     /* dcd  R_ARM_ABS32(X) */
  };
d2303 7
a2309 7
  {
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop */
    ARM_INSN(0xe59fc000),             /* ldr  ip, [pc, #0] */
    ARM_INSN(0xe12fff1c),             /* bx   ip */
    DATA_WORD(0, R_ARM_ABS32, 0),     /* dcd  R_ARM_ABS32(X) */
  };
d2314 6
a2319 6
  {
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop   */
    ARM_INSN(0xe51ff004),             /* ldr   pc, [pc, #-4] */
    DATA_WORD(0, R_ARM_ABS32, 0),     /* dcd   R_ARM_ABS32(X) */
  };
d2324 5
a2328 5
  {
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop   */
    ARM_REL_INSN(0xea000000, -8),     /* b    (X-8) */
  };
d2333 5
a2337 5
  {
    ARM_INSN(0xe59fc000),             /* ldr   ip, [pc] */
    ARM_INSN(0xe08ff00c),             /* add   pc, pc, ip */
    DATA_WORD(0, R_ARM_REL32, -4),    /* dcd   R_ARM_REL32(X-4) */
  };
d2344 6
a2349 6
  {
    ARM_INSN(0xe59fc004),             /* ldr   ip, [pc, #4] */
    ARM_INSN(0xe08fc00c),             /* add   ip, pc, ip */
    ARM_INSN(0xe12fff1c),             /* bx    ip */
    DATA_WORD(0, R_ARM_REL32, 0),     /* dcd   R_ARM_REL32(X) */
  };
d2353 6
a2358 6
  {
    ARM_INSN(0xe59fc004),             /* ldr   ip, [pc, #4] */
    ARM_INSN(0xe08fc00c),             /* add   ip, pc, ip */
    ARM_INSN(0xe12fff1c),             /* bx    ip */
    DATA_WORD(0, R_ARM_REL32, 0),     /* dcd   R_ARM_REL32(X) */
  };
d2362 7
a2368 7
  {
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop  */
    ARM_INSN(0xe59fc000),             /* ldr  ip, [pc, #0] */
    ARM_INSN(0xe08cf00f),             /* add  pc, ip, pc */
    DATA_WORD(0, R_ARM_REL32, -4),     /* dcd  R_ARM_REL32(X) */
  };
d2373 9
a2381 9
  {
    THUMB16_INSN(0xb401),             /* push {r0} */
    THUMB16_INSN(0x4802),             /* ldr  r0, [pc, #8] */
    THUMB16_INSN(0x46fc),             /* mov  ip, pc */
    THUMB16_INSN(0x4484),             /* add  ip, r0 */
    THUMB16_INSN(0xbc01),             /* pop  {r0} */
    THUMB16_INSN(0x4760),             /* bx   ip */
    DATA_WORD(0, R_ARM_REL32, 4),     /* dcd  R_ARM_REL32(X) */
  };
d2386 8
a2393 8
  {
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop */
    ARM_INSN(0xe59fc004),             /* ldr  ip, [pc, #4] */
    ARM_INSN(0xe08fc00c),             /* add   ip, pc, ip */
    ARM_INSN(0xe12fff1c),             /* bx   ip */
    DATA_WORD(0, R_ARM_REL32, 0),     /* dcd  R_ARM_REL32(X) */
  };
d2399 3
a2401 3
    ARM_INSN(0xe59f1000),             /* ldr   r1, [pc] */
    ARM_INSN(0xe08ff001),             /* add   pc, pc, r1 */
    DATA_WORD(0, R_ARM_REL32, -4),    /* dcd   R_ARM_REL32(X-4) */
d2408 5
a2412 5
    THUMB16_INSN(0x4778),             /* bx   pc */
    THUMB16_INSN(0x46c0),             /* nop */
    ARM_INSN(0xe59f1000),             /* ldr  r1, [pc, #0] */
    ARM_INSN(0xe081f00f),             /* add  pc, r1, pc */
    DATA_WORD(0, R_ARM_REL32, -4),    /* dcd  R_ARM_REL32(X) */
d2421 5
a2425 5
  {
    THUMB16_BCOND_INSN(0xd001),         /* b<cond>.n true.  */
    THUMB32_B_INSN(0xf000b800, -4),     /* b.w insn_after_original_branch.  */
    THUMB32_B_INSN(0xf000b800, -4)      /* true: b.w original_branch_dest.  */
  };
d2430 3
a2432 3
  {
    THUMB32_B_INSN(0xf000b800, -4)	/* b.w original_branch_dest.  */
  };
d2435 3
a2437 3
  {
    THUMB32_B_INSN(0xf000b800, -4)	/* b.w original_branch_dest.  */
  };
d2444 3
a2446 3
  {
    ARM_REL_INSN(0xea000000, -8)	/* b original_branch_dest.  */
  };
d2456 1
a2456 1
   
d2497 2
a2498 1
enum elf32_arm_stub_type {
d2513 2
a2514 1
static const stub_def stub_definitions[] = {
d2667 2
a2668 1
struct a8_erratum_fix {
d2682 2
a2683 1
struct a8_erratum_reloc {
d2698 2
a2699 1
struct arm_plt_info {
d2722 2
a2723 1
struct arm_local_iplt_info {
d2784 2
a2785 2
  {
    struct elf_link_hash_entry root;
d2787 2
a2788 2
    /* Track dynamic relocs copied for this symbol.  */
    struct elf_dyn_relocs *dyn_relocs;
d2790 2
a2791 2
    /* ARM-specific PLT information.  */
    struct arm_plt_info plt;
d2799 1
a2799 1
    unsigned int tls_type : 8;
d2801 2
a2802 2
    /* True if the symbol's PLT entry is in .iplt rather than .plt.  */
    unsigned int is_iplt : 1;
d2804 1
a2804 1
    unsigned int unused : 23;
d2806 3
a2808 3
    /* Offset of the GOTPLT entry reserved for the TLS descriptor,
       starting at the end of the jump table.  */
    bfd_vma tlsdesc_got;
d2810 3
a2812 3
    /* The symbol marking the real symbol location for exported thumb
       symbols with Arm stubs.  */
    struct elf_link_hash_entry *export_glue;
d2814 1
a2814 1
   /* A pointer to the most recently used stub hash entry against this
d2816 2
a2817 2
    struct elf32_arm_stub_hash_entry *stub_cache;
  };
d2927 3
d2954 1
a2954 1
  bfd_vma dt_tlsdesc_got;    
d3250 1
a3250 1
  
d3460 1
d3629 1
a3629 1
	{	
d3913 1
a3913 1
   the section to which the stub section will be attached (in *LINK_SEC_P). 
d3951 1
a3951 1
  
d3954 1
a3954 1
  
d4022 1
a4022 1
elf32_arm_tls_transition (struct bfd_link_info *info, int r_type, 
d4030 1
a4030 1
  /* We do not support relaxations for Old TLS models.  */ 
d4076 1
a4076 1
    
d5049 1
a5049 1
		  
d5055 1
a5055 1
		  
d5081 1
a5081 1
		  
d5626 1
a5626 1
		 		    ;; back_to_thumb       
d5628 1
a5628 1
 				        bx    lr           
d6065 1
a6065 1
  cpu_arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC, 
d7456 12
d7628 38
d7806 1
a7806 1
static bfd_reloc_status_type 
d7808 1
a7808 1
		     bfd *input_bfd, asection *input_sec, bfd_byte *contents, 
d7812 1
a7812 1
  
d7817 1
a7817 1
      
d7873 1
a7873 1
      
d7919 1
a7919 1
      
d7931 1
a7931 1
	
d9352 1
a9352 1
	   R_ARM_{GOTDESC,CALL,DESCSEQ} relocations to IE or LE.  */ 
d9354 1
a9354 1
	  tls_type = GOT_TLS_IE; 
d9395 1
a9395 1
		
d9413 3
a9415 3
			    globals->root.sgotplt->contents + offplt +
			    globals->sgotplt_jump_table_size);
		
d9418 2
a9419 2
			    globals->root.sgotplt->contents + offplt +
			    globals->sgotplt_jump_table_size + 4);
d9539 4
a9542 3
		
		offset -= (input_section->output_section->vma +
			   input_section->output_offset + rel->r_offset + 8);
d9555 2
a9556 2
		offset -= (input_section->output_section->vma + 
			   input_section->output_offset
d9558 1
a9558 1
	    
d9591 1
a9591 1
	    
d9595 1
a9595 1
	    
d9632 1
a9632 1
		    
d9641 1
a9641 1
 
d10375 1
a10375 1
	  
d10540 1
a10540 1
	     && !((h ? elf32_arm_hash_entry (h)->tls_type : 
d10552 1
a10552 1
     
d10648 1
a10648 1
  
d10652 1
a10652 1
  
d10710 1
a10710 1
   
d10718 1
a10718 2
   (in elf32_arm_write_section).
*/
d10737 1
a10737 1
      
d10742 1
a10742 1
	  
d10745 1
a10745 1
	  
d10807 1
a10807 1
      
d10811 1
a10811 1
      
d10813 1
a10813 1
	  
d10865 1
a10865 1
	  
d11879 1
a11879 1
		       "Tag_MPextension_use attributes"), 
d12353 1
a12353 1
  
d12425 1
a12425 1
		  
d12427 1
a12427 1
		  
d12432 1
a12432 1
		  
d13192 1
a13192 1
	      if (tls_type & GOT_TLS_GDESC) 
d13201 1
a13201 1
	      if ((tls_type & GOT_TLS_GD) && indx != 0)  
d13656 1
a13656 1
      
d13659 1
a13659 1
      
d13767 1
a13767 1
		(!add_dynamic_entry (DT_TLSDESC_PLT,0) 
d13769 1
a13769 1
	    return FALSE; 
d13842 1
a13842 1
	  
d13943 1
a13943 1
  
d14185 19
d14242 1
a14242 1
	  arm_put_trampoline (htab, output_bfd, 
d14259 1
a14259 1
	  arm_put_trampoline (htab, output_bfd, 
d14265 1
a14265 1
#endif 
d14521 5
d14852 5
d14896 1
a14896 1
       
d14910 1
a14910 1
#endif 
d14912 1
a14912 1
  
d14975 1
a14975 1
  
d14979 1
a14979 1
  
d14984 1
a14984 1
  
d14991 2
a14992 1
struct a8_branch_to_stub_data {
d15230 1
a15230 1
	      
d15248 1
a15248 1
		    
d15278 1
a15278 1
		  
d15568 1
a15568 1
#define bfd_elf32_bfd_reloc_name_lookup	elf32_arm_reloc_name_lookup
d15622 63
a15684 2
#define elf_backend_obj_attrs_order	elf32_arm_obj_attrs_order
#define elf_backend_obj_attrs_handle_unknown elf32_arm_obj_attrs_handle_unknown
d15688 6
@


1.284
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d11271 40
d11752 16
a11767 23
	  /* This tag is set to zero if we can use UDIV and SDIV in Thumb
	     mode on a v7-M or v7-R CPU; to one if we can not use UDIV or
	     SDIV at all; and to two if we can use UDIV or SDIV on a v7-A
	     CPU.  We will merge as follows: If the input attribute's value
	     is one then the output attribute's value remains unchanged.  If
	     the input attribute's value is zero or two then if the output
	     attribute's value is one the output value is set to the input
	     value, otherwise the output value must be the same as the
	     inputs.  */ 
	  if (in_attr[i].i != 1 && out_attr[i].i != 1) 
	    { 
	      if (in_attr[i].i != out_attr[i].i)
		{
		  _bfd_error_handler
		    (_("DIV usage mismatch between %B and %B"),
		     ibfd, obfd); 
		  result = FALSE;
		}
	    } 

	  if (in_attr[i].i != 1)
	    out_attr[i].i = in_attr[i].i; 
	  
@


1.283
log
@	* elf.c (elfcore_write_prpsinfo): Provide unconditionally.
	Return NULL if core file generation is unsupported.
	(elfcore_write_prstatus): Likewise.
	* elf32-arm.c (elf32_arm_nabi_write_core_note): New function.
	(elf_backend_write_core_note): Define.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011  Free Software Foundation, Inc.
a12848 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d12865 1
a12865 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.282
log
@	* elf32-arm.c (elf32_arm_nabi_grok_psinfo): Fill in core_pid.
@
text
@d1991 48
d2046 1
@


1.281
log
@	* elf32-arm.c (elf32_thumb_to_arm_stub): Sync message so that it
	needs to be translated only once.
@
text
@d1969 2
@


1.281.2.1
log
@	* elf32-arm.c (elf32_arm_nabi_grok_psinfo): Fill in core_pid.
@
text
@a1968 2
	elf_tdata (abfd)->core_pid
	 = bfd_get_32 (abfd, note->descdata + 12);
@


1.280
log
@	PR ld/13273
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Do not warn about
	identical TAG_PCS_config attributes.
@
text
@d6934 1
a6934 1
	       "  first occurrence: %B: thumb call to arm"),
@


1.279
log
@	PR ld/13049
	* elf32-arm.c (STUB_SUFFIX): Avoid collision with user namespace
	symbol names.
	* elf64-ppc.c (STUB_SUFFIX): Likewise.
	* elf32-hppa.c (STUB_SUFFIX): Likewise.
@
text
@d11552 1
a11552 1
	  else if (in_attr[i].i != 0 && out_attr[i].i != 0)
@


1.278
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2357 26
a2382 3
/* Section name for stubs is the associated section name plus this
   string.  */
#define STUB_SUFFIX ".stub"
d3583 1
a3583 1
			&& (r_type ==R_ARM_THM_CALL))
d3594 1
a3594 1
			&& (r_type ==R_ARM_THM_CALL))
d3823 1
d3825 1
@


1.277
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Mark PLT calls via
	stubs as resolved.
@
text
@d10389 3
a10391 1
               && h->def_dynamic))
@


1.276
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@a8222 1

d8227 9
a8235 4
		  if (stub_entry != NULL)
		    value = (stub_entry->stub_offset
			     + stub_entry->stub_sec->output_offset
			     + stub_entry->stub_sec->output_section->vma);
d8660 8
a8667 3
		  value = (stub_entry->stub_offset
			   + stub_entry->stub_sec->output_offset
			   + stub_entry->stub_sec->output_section->vma);
@


1.275
log
@2011-09-01  Christophe Lyon  <christophe.lyon@@st.com>

        bfd/
	* elf32-arm.c (elf32_arm_output_arch_local_syms): Skip excluded
	sections.

        ld/testsuite/
	* ld-arm/arm-elf.exp: Add new rodata-merge-map test.
	* ld-arm/rodata-merge-map.ld: New file.
	* ld-arm/rodata-merge-map.sym: Likewise.
	* ld-arm/rodata-merge-map1.s Likewise.
	* ld-arm/rodata-merge-map2.s: Likewise.
	* ld-arm/rodata-merge-map3.s: Likewise.
@
text
@d12614 2
a12615 1
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
@


1.275.2.1
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Mark PLT calls via
	stubs as resolved.
@
text
@d8228 4
a8231 9
		  {
		    if (stub_entry != NULL)
		      value = (stub_entry->stub_offset
			       + stub_entry->stub_sec->output_offset
			       + stub_entry->stub_sec->output_section->vma);

		    if (plt_offset != (bfd_vma) -1)
		      *unresolved_reloc_p = FALSE;
		  }
d8656 3
a8658 8
		  {
		    value = (stub_entry->stub_offset
			     + stub_entry->stub_sec->output_offset
			     + stub_entry->stub_sec->output_section->vma);

		    if (plt_offset != (bfd_vma) -1)
		      *unresolved_reloc_p = FALSE;
		  }
@


1.275.2.2
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4488 1
a4488 1
          || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
d6559 1
a6559 1
	  || sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
d10308 1
a10308 1
      if (sec != NULL && discarded_section (sec))
@


1.275.2.3
log
@bfd/ChangeLog

2012-11-16  Joey Ye  <joey.ye@@arm.com>

	* elf32-arm.c (elf32_arm_final_link_relocate,
	case R_ARM_THM_ALU_PREL_11_0, case R_ARM_THM_PC12): Align address of
	the place being relocated.
	(elf32_arm_final_link_relocate, case R_ARM_THM_PC8): Align address
	of the place being relocated and truncate addend.
	(Pa): New macro.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011, 2012  Free Software Foundation, Inc.
a63 3
/* The Adjusted Place, as defined by AAELF.  */
#define Pa(X) ((X) & 0xfffffffc)

d8444 3
a8446 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d8476 1
a8476 1
	  addend = ((((insn & 0x00ff) << 2) + 4) & 0x3ff) -4;
d8479 3
a8481 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d8516 3
a8518 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
@


1.274
log
@	* bfd/bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bfd-in2.h (bfd_elf32_arm_set_target_relocs): Likewise.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): New field.
	(elf232_arm_link_hash_table_create): Initialise new field.
	(check_use_blx): Change test depending on fix_arm1176.
	(bfd_elf32_arm_set_target_relocs): Set fix_arm1176 from
	command line options.
	* ld/emultempl/armelf.em (fix_arm1176): New variable.
	(arm_elf_create_output_section_statements): Pass
	fix_arm1176 option to bfd backend.
	(OPTION_FIX_ARM1176): New define.
	(OPTION_NO_FIX_ARM1176): Likewise.
	(PARSE_AND_LIST_LONGOPTS): Add new command line options.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Likewise.
	* ld/ld.texinfo: Document new command line options.
	* ld/testsuite/ld-arm/arm-elf.exp (armelftests): Update for new command-line
	options.
	(armeabitests): Update for new command-line options, and add
	new test cases.
	* ld/testsuite/ld-arm/fix-arm1176.s: Add test case.
	* ld/testsuite/ld-arm/fix-arm1176-off.d: Likewise.
	* ld/testsuite/ld-arm/fix-arm1176-on.d: Likewise.
@
text
@d14509 2
a14510 1
		&& osi.sec->size > 0)
@


1.273
log
@	* elf32-arm.c (elf32_arm_section_flags): Delete.
	(elf_backend_section_flags): Remove.
@
text
@d2779 3
d3321 1
d5937 15
a5951 3
  if (bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				Tag_CPU_arch) > 2)
    globals->use_blx = 1;
d6805 2
a6806 1
				 int pic_veneer, int fix_cortex_a8)
d6831 1
@


1.272
log
@2011-06-22  Ramana Radhakrishnan  <ramana.radhakrishnan@@linaro.org>

       * elf32-arm.c (elf32_arm_final_link_relocate): Allow R_ARM_TLS_LE32
       for PIE.
@
text
@a14103 11
/* Set the right machine number for an Arm ELF file.  */

static bfd_boolean
elf32_arm_section_flags (flagword *flags, const Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_type == SHT_NOTE)
    *flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_SAME_CONTENTS;

  return TRUE;
}

a15328 1
#define elf_backend_section_flags		elf32_arm_section_flags
@


1.271
log
@	PR ld/12851
	* elflink.c (_bfd_elf_gc_mark_extra_sections): New function.
	(elf_gc_sweep): Don't treat debug and sections like .comment
	specially here.
	(bfd_elf_gc_sections): Treat note sections as gc roots only when
	not part of a group.  Always call gc_mark_extra_sections.
	* elf-bfd.h (_bfd_elf_gc_mark_extra_sections): Declare.
	* elfxx-target.h (elf_backend_gc_mark_extra_sections): Default to
	_bfd_elf_gc_mark_extra_sections.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Call
	_bfd_elf_gc_mark_extra_sections.
	* elf32-tic6x.c (elf32_tic6x_gc_mark_extra_sections): Likewise.
@
text
@d9457 1
a9457 1
      if (info->shared)
@


1.270
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d232 2
a233 2
	 0x07ff07ff,		/* src_mask */
	 0x07ff07ff,		/* dst_mask */
d296 1
a296 1
	 25,			/* bitsize */
d311 1
a311 1
	 22,			/* bitsize */
d318 2
a319 2
	 0x07ff07ff,		/* src_mask */
	 0x07ff07ff,		/* dst_mask */
d12470 2
@


1.269
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): If the
	backend does not provide a function for creating dynamic sections
	then fail.
	(bfd_elf_final_link): Issue a warning message if a dynamic section
	has the SHT_NOTE type.
	(bfd_elf_final_link): Do not look for dynamic strings in a section
	that does not have the SHT_STRTAB type or the name .dynstr.
	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Fail if the got
	section is not in the output binary.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Likewise.

	* ld-elf/elf.exp: Add test for linking a shared library with a
	broken linker script that marks dynamic sections as being notes.
	* ld-elf/note-3.s: New test source file.
	* ld-elf/note-3.t: New test linker script.
	* ld-elf/note-3.l: Expected output from the linker.
	* lib/ld-lib.exp (run_ld_link_tests): Improve description.
@
text
@a12789 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a13152 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.268
log
@Fix spelling mistakes.
@
text
@d13747 4
@


1.267
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Only do bl conversion
	for known functions.
	(elf32_arm_swap_symbol_in): Only set ST_BRANCH_TO_ARM for function
	symbols.

	include/elf/
	* arm.h (arm_st_branch_type): Add ST_BRANCH_UNKNOWN.

	ld/testsuite/
	* ld-arm/cortex-a8-far.d: Adjust expected output.
	* ld-arm/arm-call1.s: Give function symbol correct type.
	* ld-arm/arm-call2.s: Ditto.
	* ld-arm/farcall-group4.s: Ditto.
	* ld-arm/arm-elf.exp (cortex-a8-far): Define far symbols with correct
	type via assembly file.
	* ld-arm/cortex-a8-far-3.s: New file.
	* ld-arm/abs-call-1.s: Add Thumb tests
@
text
@d10236 1
a10236 1
		  /* Cases here must match those in the preceeding
d15451 1
a15451 1
  /* Check if we have the same endianess.  */
@


1.266
log
@2011-05-31  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (arm_stub_is_thumb): Add
	arm_stub_long_branch_v4t_thumb_tls_pic.
	(elf32_arm_final_link_relocate): TLS stubs are always ARM.
	Handle Thumb stubs.

	ld/testsuite/
	* ld-arm/tls-longplt.d: Update expected output.
	* ld-arm/tls-thumb1.d: Ditto.
@
text
@d8307 1
a8307 1
		  else
d15134 2
a15135 3
  if ((ELF_ST_TYPE (dst->st_info) == STT_FUNC
       || ELF_ST_TYPE (dst->st_info) == STT_GNU_IFUNC)
      && (dst->st_value & 1))
d15137 7
a15143 2
      dst->st_value &= ~(bfd_vma) 1;
      dst->st_target_internal = ST_BRANCH_TO_THUMB;
d15153 1
a15153 1
    dst->st_target_internal = ST_BRANCH_TO_ARM;
@


1.265
log
@	PR ld/12778
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Use the computed dynamic
	reloc pointer.
@
text
@d3430 1
d9308 3
d9355 12
a9366 2
		/* Round up the offset to a word boundary */
		offset = (offset + 2) & ~2;
d9371 1
a9371 2
		lower_insn = (0xc000
			      | (((!((offset >> 23) & 1)) ^ neg) << 13)
d9373 1
a9373 1
			      | ((offset >> 1) & 0x7ff));
@


1.264
log
@bfd/
	* elf32-arm.c (cortex_a8_erratum_scan): If the stub is a Thumb
	branch to a PLT entry, redirect it to the PLT's Thumb entry point.

ld/testsuite/
	* ld-arm/cortex-a8-fix-b-plt.s, ld-arm/cortex-a8-fix-b-plt.d,
	ld-arm/cortex-a8-fix-bcc-plt.s, ld-arm/cortex-a8-fix-bcc-plt.d,
	ld-arm/cortex-a8-fix-bl-plt.s, ld-arm/cortex-a8-fix-bl-plt.d,
	ld-arm/cortex-a8-fix-blx-plt.s, ld-arm/cortex-a8-fix-blx-plt.d,
	ld-arm/cortex-a8-fix-plt.ld: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d12028 1
a12028 1
	    pp = &((struct elf32_arm_link_hash_entry *) h)->dyn_relocs;
d12041 1
a12041 1
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
@


1.263
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d4559 1
a4570 1
		      bfd_boolean use_plt = FALSE;
d4674 6
@


1.262
log
@include/elf/
	* arm.h (R_ARM_IRELATIVE): New relocation.

bfd/
	* reloc.c (BFD_RELOC_ARM_IRELATIVE): New relocation.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_howto_table_2): Rename existing definition
	to elf32_arm_howto_table_3 and replace with a single R_ARM_IRELATIVE
	entry.
	(elf32_arm_howto_from_type): Update accordingly.
	(elf32_arm_reloc_map): Map BFD_RELOC_ARM_IRELATIVE to R_ARM_IRELATIVE.
	(elf32_arm_reloc_name_lookup): Handle elf32_arm_howto_table_3.
	(arm_plt_info): New structure, split out from elf32_arm_link_hash_entry
	with an extra noncall_refcount field.
	(arm_local_iplt_info): New structure.
	(elf_arm_obj_tdata): Add local_iplt.
	(elf32_arm_local_iplt): New accessor macro.
	(elf32_arm_link_hash_entry): Replace plt_thumb_refcount,
	plt_maybe_thumb_refcount and plt_got_offset with an arm_plt_info.
	Change tls_type to a bitfield and add is_iplt.
	(elf32_arm_link_hash_newfunc): Update accordingly.
	(elf32_arm_allocate_local_sym_info): New function.
	(elf32_arm_create_local_iplt): Likewise.
	(elf32_arm_get_plt_info): Likewise.
	(elf32_arm_plt_needs_thumb_stub_p): Likewise.
	(elf32_arm_get_local_dynreloc_list): Likewise.
	(create_ifunc_sections): Likewise.
	(elf32_arm_copy_indirect_symbol): Update after the changes to
	elf32_arm_link_hash_entry.  Assert the is_iplt has not yet been set.
	(arm_type_of_stub): Add an st_type argument.  Use elf32_arm_get_plt_info
	to get PLT information.  Assert that all STT_GNU_IFUNC references
	are turned into PLT references.
	(arm_build_one_stub): Pass the symbol type to
	elf32_arm_final_link_relocate.
	(elf32_arm_size_stubs): Pass the symbol type to arm_type_of_stub.
	(elf32_arm_allocate_irelocs): New function.
	(elf32_arm_add_dynreloc): In static objects, use .rel.iplt for
	all R_ARM_IRELATIVE.
	(elf32_arm_allocate_plt_entry): New function.
	(elf32_arm_populate_plt_entry): Likewise.
	(elf32_arm_final_link_relocate): Add an st_type parameter.
	Set srelgot to null for static objects.  Use separate variables
	to record which st_value and st_type should be used when generating
	a dynamic relocation.  Use elf32_arm_get_plt_info to find the
	symbol's PLT information, setting has_iplt_entry, splt,
	plt_offset and gotplt_offset accordingly.  Check whether
	STT_GNU_IFUNC symbols should resolve to an .iplt entry, and change
	the relocation target accordingly.  Broaden assert to include
	.iplts.  Don't set sreloc for static relocations.  Assert that
	we only generate dynamic R_ARM_RELATIVE relocations for R_ARM_ABS32
	and R_ARM_ABS32_NOI.  Generate R_ARM_IRELATIVE relocations instead
	of R_ARM_RELATIVE relocations if the target is an STT_GNU_IFUNC
	symbol.  Pass the symbol type to arm_type_of_stub.  Conditionally
	resolve GOT references to the .igot.plt entry.
	(elf32_arm_relocate_section): Update the call to
	elf32_arm_final_link_relocate.
	(elf32_arm_gc_sweep_hook): Use elf32_arm_get_plt_info to get PLT
	information.  Treat R_ARM_REL32 and R_ARM_REL32_NOI as call
	relocations in shared libraries and relocatable executables.
	Count non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_check_relocs): Always create ifunc sections.  Set isym
	at the same time as setting h.  Use elf32_arm_allocate_local_sym_info
	to allocate local symbol information.  Treat R_ARM_REL32 and
	R_ARM_REL32_NOI as call relocations in shared libraries and
	relocatable executables.  Record PLT information for local
	STT_GNU_IFUNC functions as well as global functions.   Count
	non-call PLT references.  Use elf32_arm_get_local_dynreloc_list
	to get the list of dynamic relocations for a local symbol.
	(elf32_arm_adjust_dynamic_symbol): Handle STT_GNU_IFUNC symbols.
	Don't remove STT_GNU_IFUNC PLTs unless all references have been
	removed.  Update after the changes to elf32_arm_link_hash_entry.
	(allocate_dynrelocs_for_symbol): Decide whether STT_GNU_IFUNC PLT
	entries should live in .plt or .iplt.  Check whether the .igot.plt
	and .got entries can be combined.  Use elf32_arm_allocate_plt_entry
	to allocate .plt and .(i)got.plt entries.  Detect which .got
	entries will need R_ARM_IRELATIVE relocations and use
	elf32_arm_allocate_irelocs to allocate them.  Likewise other
	non-.got dynamic relocations.
	(elf32_arm_size_dynamic_sections): Allocate .iplt, .igot.plt
	and dynamic relocations for local STT_GNU_IFUNC symbols.
	Check whether the .igot.plt and .got entries can be combined.
	Detect which .got entries will need R_ARM_IRELATIVE relocations
	and use elf32_arm_allocate_irelocs to allocate them.  Use stashed
	section pointers intead of strcmp checks.  Handle iplt and igotplt.
	(elf32_arm_finish_dynamic_symbol): Use elf32_arm_populate_plt_entry
	to fill in .plt, .got.plt and .rel(a).plt entries.  Point
	STT_GNU_IFUNC symbols at an .iplt entry if non-call relocations
	resolve to it.
	(elf32_arm_output_plt_map_1): New function, split out from
	elf32_arm_output_plt_map.  Handle .iplt entries.  Use
	elf32_arm_plt_needs_thumb_stub_p.
	(elf32_arm_output_plt_map): Call it.
	(elf32_arm_output_arch_local_syms): Add mapping symbols for
	local .iplt entries.
	(elf32_arm_swap_symbol_in): Handle Thumb STT_GNU_IFUNC symbols.
	(elf32_arm_swap_symbol_out): Likewise.
	(elf32_arm_add_symbol_hook): New function.
	(elf_backend_add_symbol_hook): Define for all targets.

opcodes/
	* arm-dis.c (get_sym_code_type): Treat STT_GNU_IFUNCs as code.

gas/
	* config/tc-arm.c (md_pcrel_from_section): Use S_FORCE_RELOC to
	determine whether a relocation is needed.
	(md_apply_fix, arm_apply_sym_value): Likewise.

ld/testsuite/
	* ld-arm/ifunc-1.s, ld-arm/ifunc-1.dd, ld-arm/ifunc-1.gd,
	ld-arm/ifunc-1.rd, ld-arm/ifunc-2.s, ld-arm/ifunc-2.dd,
	ld-arm/ifunc-2.gd, ld-arm/ifunc-2.rd, ld-arm/ifunc-3.s,
	ld-arm/ifunc-3.dd, ld-arm/ifunc-3.gd, ld-arm/ifunc-3.rd,
	ld-arm/ifunc-4.s, ld-arm/ifunc-4.dd, ld-arm/ifunc-4.gd,
	ld-arm/ifunc-4.rd, ld-arm/ifunc-5.s, ld-arm/ifunc-5.dd,
	ld-arm/ifunc-5.gd, ld-arm/ifunc-5.rd, ld-arm/ifunc-6.s,
	ld-arm/ifunc-6.dd, ld-arm/ifunc-6.gd, ld-arm/ifunc-6.rd,
	ld-arm/ifunc-7.s, ld-arm/ifunc-7.dd, ld-arm/ifunc-7.gd,
	ld-arm/ifunc-7.rd, ld-arm/ifunc-8.s, ld-arm/ifunc-8.dd,
	ld-arm/ifunc-8.gd, ld-arm/ifunc-8.rd, ld-arm/ifunc-9.s,
	ld-arm/ifunc-9.dd, ld-arm/ifunc-9.gd, ld-arm/ifunc-9.rd,
	ld-arm/ifunc-10.s, ld-arm/ifunc-10.dd, ld-arm/ifunc-10.gd,
	ld-arm/ifunc-10.rd, ld-arm/ifunc-11.s, ld-arm/ifunc-11.dd,
	ld-arm/ifunc-11.gd, ld-arm/ifunc-11.rd, ld-arm/ifunc-12.s,
	ld-arm/ifunc-12.dd, ld-arm/ifunc-12.gd, ld-arm/ifunc-12.rd,
	ld-arm/ifunc-13.s, ld-arm/ifunc-13.dd, ld-arm/ifunc-13.gd,
	ld-arm/ifunc-13.rd, ld-arm/ifunc-14.s, ld-arm/ifunc-14.dd,
	ld-arm/ifunc-14.gd, ld-arm/ifunc-14.rd, ld-arm/ifunc-15.s,
	ld-arm/ifunc-15.dd, ld-arm/ifunc-15.gd, ld-arm/ifunc-15.rd,
	ld-arm/ifunc-16.s, ld-arm/ifunc-16.dd, ld-arm/ifunc-16.gd,
	ld-arm/ifunc-16.rd, ld-arm/ifunc-dynamic.ld,
	ld-arm/ifunc-static.ld: New tests.
	* ld-arm/farcall-group.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-mixed-lib-v4t.d, ld-arm/farcall-mixed-lib.d: Update
	for new stub hashes.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d15233 3
a15235 2
      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
    elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.261
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d1654 1
d1671 2
d1690 17
a1706 5
/* 112-127 private relocations
   128 R_ARM_ME_TOO, obsolete
   129-255 unallocated in AAELF.

   249-255 extended, currently unused, relocations:  */
d1708 2
a1709 1
static reloc_howto_type elf32_arm_howto_table_2[4] =
d1774 3
d1778 2
a1779 2
      && r_type < R_ARM_RREL32 + ARRAY_SIZE (elf32_arm_howto_table_2))
    return &elf32_arm_howto_table_2[r_type - R_ARM_RREL32];
d1849 1
d1920 5
d2578 38
d2626 3
d2645 3
d2670 2
a2671 12
    /* We reference count Thumb references to a PLT entry separately,
       so that we can emit the Thumb trampoline only if needed.  */
    bfd_signed_vma plt_thumb_refcount;

    /* Some references from Thumb code may be eliminated by BL->BLX
       conversion, so record them separately.  */
    bfd_signed_vma plt_maybe_thumb_refcount;

    /* Since PLT entries have variable size if the Thumb prologue is
       used, we need to record the index into .got.plt instead of
       recomputing it from the PLT offset.  */
    bfd_signed_vma plt_got_offset;
d2679 6
a2684 1
    unsigned char tls_type;
d2900 5
a2904 3
      ret->plt_thumb_refcount = 0;
      ret->plt_maybe_thumb_refcount = 0;
      ret->plt_got_offset = -1;
d2913 136
d3114 47
d3260 10
a3269 4
      edir->plt_thumb_refcount += eind->plt_thumb_refcount;
      eind->plt_thumb_refcount = 0;
      edir->plt_maybe_thumb_refcount += eind->plt_maybe_thumb_refcount;
      eind->plt_maybe_thumb_refcount = 0;
d3447 1
d3464 2
d3485 33
a3517 20
  /* Keep a simpler condition, for the sake of clarity.  */
  if (globals->root.splt != NULL
      && hash != NULL
      && hash->root.plt.offset != (bfd_vma) -1)
    {
      use_plt = 1;

      /* Note when dealing with PLT entries: the main PLT stub is in
	 ARM mode, so if the branch is in Thumb mode, another
	 Thumb->ARM stub will be inserted later just before the ARM
	 PLT stub. We don't take this extra distance into account
	 here, because if a long branch stub is needed, we'll add a
	 Thumb->Arm one and branch directly to the ARM PLT entry
	 because it avoids spreading offset corrections in several
	 places.  */

      destination = (globals->root.splt->output_section->vma
		     + globals->root.splt->output_offset
		     + hash->root.plt.offset);
      branch_type = ST_BRANCH_TO_ARM;
d3519 2
d3916 2
a3917 2
   const char *, enum arm_st_branch_type, struct elf_link_hash_entry *,
   bfd_boolean *, char **);
d4110 3
a4112 3
	  points_to, info, stub_entry->target_section, "", branch_type,
	  (struct elf_link_hash_entry *) stub_entry->h, &unresolved_reloc,
	  &error_message);
d4130 1
a4130 1
	  points_to, info, stub_entry->target_section, "",
d4897 1
d4955 1
d4997 1
d5072 1
d5081 2
a5082 2
						    &branch_type, hash,
						    destination, sym_sec,
d7210 20
d7240 3
d7252 275
d7820 2
a7821 1
			       enum arm_st_branch_type     branch_type,
d7831 2
a7832 2
  asection *                    sgot = NULL;
  asection *                    splt = NULL;
d7837 2
d7840 6
d7876 1
a7877 2
  splt = globals->root.splt;
  srelgot = globals->root.srelgot;
d7881 5
d7904 59
d7995 7
a8001 8
	  && h != NULL
	  && splt != NULL
	  && h->plt.offset != (bfd_vma) -1)
	{
	  /* If we've created a .plt section, and assigned a PLT entry to
	     this function, it should not be known to bind locally.  If
	     it were, we would have cleared the PLT entry.  */
	  BFD_ASSERT (!SYMBOL_CALLS_LOCAL (info, h));
d8005 1
a8005 1
		   + h->plt.offset);
d8037 1
a8037 1
	  if (sreloc == NULL)
d8073 1
a8073 2
	      if (branch_type == ST_BRANCH_TO_THUMB)
		value |= 1;
d8113 8
a8120 1
	      outrel.r_info = ELF32_R_INFO (symbol, R_ARM_RELATIVE);
d8124 1
a8124 1
		outrel.r_addend += value;
d8136 2
a8137 2
					   contents, rel->r_offset, value,
					   (bfd_vma) 0);
d8190 2
a8191 2
					    &branch_type, hash,
					    value, sym_sec,
d8212 1
a8212 3
		  if (h != NULL
		      && splt != NULL
		      && h->plt.offset != (bfd_vma) -1)
d8216 1
a8216 1
			       + h->plt.offset);
d8262 1
a8262 1
		   && !(splt != NULL && h->plt.offset != (bfd_vma) -1))
d8527 1
a8527 1
	    && !(splt != NULL && h->plt.offset != (bfd_vma) -1))
d8578 1
a8578 3
	    if (branch_type == ST_BRANCH_TO_ARM
		&& (h == NULL || splt == NULL
		    || h->plt.offset == (bfd_vma) -1))
d8617 2
a8618 1
					  &branch_type, hash, value, sym_sec,
d8647 1
a8647 4
	if (stub_type == arm_stub_none
	    && h != NULL
	    && splt != NULL
	    && h->plt.offset != (bfd_vma) -1)
d8651 1
a8651 1
		     + h->plt.offset);
d8756 1
a8756 1
	if (h != NULL && splt != NULL && h->plt.offset != (bfd_vma) -1)
d8760 1
a8760 1
		     + h->plt.offset);
d8926 13
a8938 1
      if (h != NULL)
d8974 7
a8980 7
		  if (info->shared)
		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
		  else
		    outrel.r_info = 0;
		  outrel.r_addend = value;
		  if (branch_type == ST_BRANCH_TO_THUMB)
		    outrel.r_addend |= 1;
a9019 7
	      /* If we are addressing a Thumb function, we need to
		 adjust the address by one, so that attempts to
		 call the function pointer will correctly
		 interpret it as Thumb code.  */
	      if (branch_type == ST_BRANCH_TO_THUMB)
		value |= 1;

d9021 1
a9021 1
		bfd_put_32 (output_bfd, value, sgot->contents + off);
d9023 1
a9023 1
	      if (info->shared)
d9027 1
a9027 3
		  BFD_ASSERT (srelgot != NULL);

		  outrel.r_addend = addend + value;
d9031 4
a9034 1
		  outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
d9302 2
a9303 1
	      = arm_type_of_stub (info, input_section, rel, &branch_type,
d10333 1
a10333 1
					  relocation, info, sec, name,
d11903 1
d11906 2
d11919 1
d11955 1
d11980 11
a11990 4
	      && (sec->flags & SEC_ALLOC) != 0
	      && (h != NULL
		  || (r_type != R_ARM_REL32 && r_type != R_ARM_REL32_NOI)))
	    may_become_dynamic_p = TRUE;
d11999 2
a12000 1
      if (may_need_local_target_p && h != NULL)
d12002 5
a12006 2
	  BFD_ASSERT (h->plt.refcount > 0);
	  h->plt.refcount -= 1;
d12009 1
a12009 1
	    eh->plt_maybe_thumb_refcount--;
d12013 1
a12013 1
	    eh->plt_thumb_refcount--;
d12016 1
a12016 1
      if (may_become_dynamic_p && h != NULL)
d12021 14
d12088 2
d12100 1
d12121 3
a12123 3
      if (nsyms == 0 || r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
d12125 15
a12139 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a12185 2
		  bfd_signed_vma *local_got_refcounts;

d12187 3
a12189 21
		  local_got_refcounts = elf_local_got_refcounts (abfd);
		  if (local_got_refcounts == NULL)
		    {
		      bfd_size_type size;

		      size = symtab_hdr->sh_info;
		      size *= (sizeof (bfd_signed_vma)
			       + sizeof (bfd_vma) + sizeof (char));
		      local_got_refcounts = (bfd_signed_vma *)
                          bfd_zalloc (abfd, size);
		      if (local_got_refcounts == NULL)
			return FALSE;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		      elf32_arm_local_tlsdesc_gotent (abfd)
		        = (bfd_vma *) (local_got_refcounts
				       + symtab_hdr->sh_info);
		      elf32_arm_local_got_tls_type (abfd)
			= (char *) (elf32_arm_local_tlsdesc_gotent (abfd)
				    + symtab_hdr->sh_info);
		    }
		  local_got_refcounts[r_symndx] += 1;
a12281 4
	    /* If we are creating a shared library or relocatable
	       executable, and this is a reloc against a global symbol,
	       or a non-PC-relative reloc against a local symbol,
	       then we may need to copy the reloc into the output.  */
d12283 19
a12301 4
		&& (sec->flags & SEC_ALLOC) != 0
		&& (h != NULL
		    || (r_type != R_ARM_REL32 && r_type != R_ARM_REL32_NOI)))
	      may_become_dynamic_p = TRUE;
d12341 2
a12342 1
      if (may_need_local_target_p && h != NULL)
d12344 18
d12364 4
a12367 1
	  h->plt.refcount += 1;
d12374 1
a12374 1
	    eh->plt_maybe_thumb_refcount += 1;
d12378 1
a12378 1
	    eh->plt_thumb_refcount += 1;
d12411 2
a12412 10
	      /* Track dynamic relocs needed for local syms too.
		 We really need local syms available to do this
		 easily.  Oh well.  */
	      asection *s;
	      void *vpp;
	      Elf_Internal_Sym *isym;

	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					    abfd, r_symndx);
	      if (isym == NULL)
a12413 7

	      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
	      if (s == NULL)
		s = sec;

	      vpp = &elf_section_data (s)->local_dynrel;
	      head = (struct elf_dyn_relocs **) vpp;
d12645 1
d12656 1
a12656 1
  if (h->type == STT_FUNC || h->needs_plt)
d12658 2
d12661 4
a12664 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d12672 3
a12674 2
	  eh->plt_thumb_refcount = 0;
	  eh->plt_maybe_thumb_refcount = 0;
d12688 3
a12690 2
      eh->plt_thumb_refcount = 0;
      eh->plt_maybe_thumb_refcount = 0;
a12766 1
  bfd_signed_vma thumb_refs;
d12784 1
a12784 1
  if (htab->root.dynamic_sections_created
d12796 18
d12815 1
d12818 1
a12818 20
	  asection *s = htab->root.splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += htab->plt_header_size;

	  h->plt.offset = s->size;

	  /* If we will insert a Thumb trampoline before this PLT, leave room
	     for it.  */
	  thumb_refs = eh->plt_thumb_refcount;
	  if (!htab->use_blx)
	    thumb_refs += eh->plt_maybe_thumb_refcount;

	  if (thumb_refs > 0)
	    {
	      h->plt.offset += PLT_THUMB_STUB_SIZE;
	      s->size += PLT_THUMB_STUB_SIZE;
	    }
d12828 1
a12828 1
	      h->root.u.def.section = s;
a12836 14
	  /* Make room for this entry.  */
	  s->size += htab->plt_entry_size;

	  if (!htab->symbian_p)
	    {
	      /* We also need to make an entry in the .got.plt section, which
		 will be placed in the .got section by the linker script.  */
	      eh->plt_got_offset = (htab->root.sgotplt->size
				    - 8 * htab->num_tls_desc);
	      htab->root.sgotplt->size += 4;
	    }

	  /* We also need to make an entry in the .rel(a).plt section.  */
	  elf32_arm_allocate_dynrelocs (info, htab->root.srelplt, 1);
d12907 1
a12907 1
		  /* plt_got_offset needs to know there's a TLS_DESC
d12963 6
d13121 6
a13126 1
      elf32_arm_allocate_dynrelocs (info, sreloc, p->count);
d13213 1
d13220 1
d13264 1
d13267 1
d13271 2
a13272 1
	   ++local_got, ++local_tls_type, ++local_tlsdesc_gotent)
d13275 35
d13312 2
d13324 1
a13324 1
		  /* plt_got_offset needs to know there's a TLS_DESC
d13339 13
a13351 2
	      if ((info->shared && !(*local_tls_type & GOT_TLS_GDESC))
		  || *local_tls_type & GOT_TLS_GD)
d13444 1
a13444 1
      if (strcmp (name, ".plt") == 0)
d13463 5
a13467 2
      else if (! CONST_STRNEQ (name, ".got")
	       && strcmp (name, ".dynbss") != 0)
d13629 1
a13629 17
      asection * splt;
      asection * srel;
      bfd_byte *loc;
      bfd_vma plt_index;
      Elf_Internal_Rela rel;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = htab->root.splt;
      srel = htab->root.srelplt;
      BFD_ASSERT (splt != NULL && srel != NULL);

      /* Fill in the entry in the procedure linkage table.  */
      if (htab->symbian_p)
d13631 3
a13633 19
	  put_arm_insn (htab, output_bfd,
		      elf32_arm_symbian_plt_entry[0],
		      splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd,
		      elf32_arm_symbian_plt_entry[1],
		      splt->contents + h->plt.offset + 4);

	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (splt->output_section->vma
			  + splt->output_offset
			  + h->plt.offset + 4);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);

	  /* Get the index in the procedure linkage table which
	     corresponds to this symbol.  This is the index of this symbol
	     in all the symbols for which we are making plt entries.  The
	     first entry in the procedure linkage table is reserved.  */
	  plt_index = ((h->plt.offset - htab->plt_header_size)
		       / htab->plt_entry_size);
a13634 142
      else
	{
	  bfd_vma got_offset, got_address, plt_address;
	  bfd_vma got_displacement;
	  asection * sgot;
	  bfd_byte * ptr;

	  sgot = htab->root.sgotplt;
	  BFD_ASSERT (sgot != NULL);

	  /* Get the offset into the .got.plt table of the entry that
	     corresponds to this function.  */
	  got_offset = eh->plt_got_offset;

	  /* Get the index in the procedure linkage table which
	     corresponds to this symbol.  This is the index of this symbol
	     in all the symbols for which we are making plt entries.  The
	     first three entries in .got.plt are reserved; after that
	     symbols appear in the same order as in .plt.  */
	  plt_index = (got_offset - 12) / 4;

	  /* Calculate the address of the GOT entry.  */
	  got_address = (sgot->output_section->vma
			 + sgot->output_offset
			 + got_offset);

	  /* ...and the address of the PLT entry.  */
	  plt_address = (splt->output_section->vma
			 + splt->output_offset
			 + h->plt.offset);

	  ptr = splt->contents + h->plt.offset;
	  if (htab->vxworks_p && info->shared)
	    {
	      unsigned int i;
	      bfd_vma val;

	      for (i = 0; i != htab->plt_entry_size / 4; i++, ptr += 4)
		{
		  val = elf32_arm_vxworks_shared_plt_entry[i];
		  if (i == 2)
		    val |= got_address - sgot->output_section->vma;
		  if (i == 5)
		    val |= plt_index * RELOC_SIZE (htab);
		  if (i == 2 || i == 5)
		    bfd_put_32 (output_bfd, val, ptr);
		  else
		    put_arm_insn (htab, output_bfd, val, ptr);
		}
	    }
	  else if (htab->vxworks_p)
	    {
	      unsigned int i;
	      bfd_vma val;

	      for (i = 0; i != htab->plt_entry_size / 4; i++, ptr += 4)
		{
		  val = elf32_arm_vxworks_exec_plt_entry[i];
		  if (i == 2)
		    val |= got_address;
		  if (i == 4)
		    val |= 0xffffff & -((h->plt.offset + i * 4 + 8) >> 2);
		  if (i == 5)
		    val |= plt_index * RELOC_SIZE (htab);
		  if (i == 2 || i == 5)
		    bfd_put_32 (output_bfd, val, ptr);
		  else
		    put_arm_insn (htab, output_bfd, val, ptr);
		}

	      loc = (htab->srelplt2->contents
		     + (plt_index * 2 + 1) * RELOC_SIZE (htab));

	      /* Create the .rela.plt.unloaded R_ARM_ABS32 relocation
		 referencing the GOT for this PLT entry.  */
	      rel.r_offset = plt_address + 8;
	      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_ARM_ABS32);
	      rel.r_addend = got_offset;
	      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
	      loc += RELOC_SIZE (htab);

	      /* Create the R_ARM_ABS32 relocation referencing the
		 beginning of the PLT for this GOT entry.  */
	      rel.r_offset = got_address;
	      rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_ARM_ABS32);
	      rel.r_addend = 0;
	      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
	    }
	  else
	    {
	      bfd_signed_vma thumb_refs;
	      /* Calculate the displacement between the PLT slot and the
		 entry in the GOT.  The eight-byte offset accounts for the
		 value produced by adding to pc in the first instruction
		 of the PLT stub.  */
	      got_displacement = got_address - (plt_address + 8);

	      BFD_ASSERT ((got_displacement & 0xf0000000) == 0);

	      thumb_refs = eh->plt_thumb_refcount;
	      if (!htab->use_blx)
		thumb_refs += eh->plt_maybe_thumb_refcount;

	      if (thumb_refs > 0)
		{
		  put_thumb_insn (htab, output_bfd,
				  elf32_arm_plt_thumb_stub[0], ptr - 4);
		  put_thumb_insn (htab, output_bfd,
				  elf32_arm_plt_thumb_stub[1], ptr - 2);
		}

	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[0]
			    | ((got_displacement & 0x0ff00000) >> 20),
			    ptr + 0);
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[1]
			    | ((got_displacement & 0x000ff000) >> 12),
			    ptr+ 4);
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[2]
			    | (got_displacement & 0x00000fff),
			    ptr + 8);
#ifdef FOUR_WORD_PLT
	      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3], ptr + 12);
#endif
	    }

	  /* Fill in the entry in the global offset table.  */
	  bfd_put_32 (output_bfd,
		      (splt->output_section->vma
		       + splt->output_offset),
		      sgot->contents + got_offset);

	  /* Fill in the entry in the .rel(a).plt section.  */
	  rel.r_addend = 0;
	  rel.r_offset = got_address;
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_JUMP_SLOT);
	}

      loc = srel->contents + plt_index * RELOC_SIZE (htab);
      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
d13648 12
d14214 2
a14215 2

/* Output mapping symbols for PLT entries associated with H.  */
d14218 4
a14221 1
elf32_arm_output_plt_map (struct elf_link_hash_entry *h, void *inf)
a14222 1
  output_arch_syminfo *osi = (output_arch_syminfo *) inf;
d14224 1
a14224 2
  struct elf32_arm_link_hash_entry *eh;
  bfd_vma addr;
d14226 1
a14226 10
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->plt.offset == (bfd_vma) -1)
d14233 14
a14246 2
  eh = (struct elf32_arm_link_hash_entry *) h;
  addr = h->plt.offset;
d14267 1
a14267 1
      bfd_signed_vma thumb_refs;
d14269 2
a14270 5
      thumb_refs = eh->plt_thumb_refcount;
      if (!htab->use_blx)
	thumb_refs += eh->plt_maybe_thumb_refcount;

      if (thumb_refs > 0)
d14284 1
a14284 1
      if (thumb_refs > 0 || addr == 20)
d14295 22
d14571 5
a14575 2
  if (!htab->root.splt || htab->root.splt->size == 0)
    return TRUE;
d14577 14
a14590 9
  osi.sec = htab->root.splt;
  osi.sec_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
						     osi.sec->output_section);
  /* Output mapping symbols for the plt header.  SymbianOS does not have a
     plt header.  */
  if (htab->vxworks_p)
    {
      /* VxWorks shared libraries have no PLT header.  */
      if (!info->shared)
d14594 2
a14595 1
	  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, 12))
d14597 1
d14600 2
a14601 1
  else if (!htab->symbian_p)
d14603 20
a14622 6
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
	return FALSE;
#ifndef FOUR_WORD_PLT
      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA, 16))
	return FALSE;
#endif
a14623 1

a14645 1
  elf_link_hash_traverse (&htab->root, elf32_arm_output_plt_map, (void *) &osi);
d15115 2
a15116 1
  if ((ELF_ST_TYPE (dst->st_info) == STT_FUNC)
d15153 2
a15154 1
      newsym.st_info = ELF_ST_INFO (ELF_ST_BIND (src->st_info), STT_FUNC);
d15224 20
d15329 1
a15396 2
#undef  elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook		elf_vxworks_add_symbol_hook
a15763 1
#undef elf_backend_add_symbol_hook
@


1.260
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Always assign a dynobj.
	(elf32_arm_finish_dynamic_sections): Move sgot != NULL assertion
	into the PLT block.

ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Check dynobj
	instead of dynamic_sections_created.
@
text
@d2413 2
a2414 2
  /* Destination symbol type (STT_ARM_TFUNC, ...) */
  unsigned char st_type;
d2534 1
a2534 1
  int st_type;
d2546 1
a2546 1
  unsigned char st_type;
d3192 1
a3192 1
		  int *actual_st_type,
d3207 1
a3207 1
  int st_type = *actual_st_type;
d3209 1
a3209 3
  /* We don't know the actual type of destination in case it is of
     type STT_SECTION: give up.  */
  if (st_type == STT_SECTION)
d3246 1
a3246 1
      st_type = STT_FUNC;
d3268 1
a3268 1
	  || ((st_type != STT_ARM_TFUNC)
d3274 1
a3274 1
	  if (st_type == STT_ARM_TFUNC)
d3354 1
a3354 1
      if (st_type == STT_ARM_TFUNC)
d3413 1
a3413 1
    *actual_st_type = st_type;
d3643 2
a3644 1
   const char *, int, struct elf_link_hash_entry *, bfd_boolean *, char **);
d3795 1
a3795 1
  if (stub_entry->st_type == STT_ARM_TFUNC)
d3811 3
a3813 3
	int sym_flags
	  = (template_sequence[stub_reloc_idx[i]].r_type != R_ARM_THM_XPC22)
	    ? STT_ARM_TFUNC : 0;
d3837 1
a3837 1
	  points_to, info, stub_entry->target_section, "", sym_flags,
d3857 2
a3858 1
	  points_to, info, stub_entry->target_section, "", stub_entry->st_type,
d4314 2
a4315 1
			  if (found->st_type != STT_ARM_TFUNC || use_plt)
d4452 2
a4453 2
                          a8_fixes[num_a8_fixes].st_type =
			    is_blx ? STT_FUNC : STT_ARM_TFUNC;
d4624 1
a4624 1
		  int st_type;
d4681 1
a4681 1
		      st_type = STT_FUNC;
d4722 1
a4722 1
		      st_type = ELF_ST_TYPE (sym->st_info);
d4796 1
a4796 1
		      st_type = ELF_ST_TYPE (hash->root.type);
d4804 1
a4804 1
						    &st_type, hash,
d4846 1
a4846 1
                      stub_entry->st_type = st_type;
d4862 3
a4864 3
                      if ( ((r_type == (unsigned int) R_ARM_THM_CALL)
                            || (r_type == (unsigned int) R_ARM_THM_JUMP24))
                           && st_type != STT_ARM_TFUNC)
d4867 3
a4869 3
                      else if ( ((r_type == (unsigned int) R_ARM_CALL)
                        	 || (r_type == (unsigned int) R_ARM_JUMP24))
                               && st_type == STT_ARM_TFUNC)
d4911 1
a4911 1
                          a8_relocs[num_a8_relocs].st_type = st_type;
d5016 1
a5016 1
	  stub_entry->st_type = a8_fixes[i].st_type;
d5781 1
a5781 1
	      if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC)
d7245 1
a7245 1
			       int		            sym_flags,
d7427 1
a7427 1
	      if (sym_flags == STT_ARM_TFUNC)
d7505 1
a7505 1
	      if (sym_flags != STT_ARM_TFUNC)
d7514 1
a7514 1
	      if (sym_flags == STT_ARM_TFUNC)
d7538 1
a7538 1
					    &sym_flags, hash,
d7570 1
a7570 1
		      sym_flags = STT_FUNC;
d7637 1
a7637 1
		  if (sym_flags == STT_ARM_TFUNC)
d7648 1
a7648 1
		  if (sym_flags == STT_ARM_TFUNC && !stub_entry)
d7662 1
a7662 1
	  if (sym_flags == STT_ARM_TFUNC)
d7672 1
a7672 1
	  if (sym_flags == STT_ARM_TFUNC)
d7696 1
a7696 1
	  if (sym_flags == STT_ARM_TFUNC)
d7916 1
a7916 1
	    if (sym_flags == STT_ARM_TFUNC)
d7928 1
a7928 1
	    if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION
d7949 2
a7950 1
	    else if (sym_flags == STT_ARM_TFUNC && globals->use_blx
d7969 1
a7969 1
					  &sym_flags, hash, value, sym_sec,
d7991 1
a7991 1
			|| (sym_flags != STT_ARM_TFUNC))
d8013 1
a8013 1
		sym_flags = STT_FUNC;
d8019 1
a8019 1
		sym_flags = STT_ARM_TFUNC;
d8247 1
a8247 1
      if (sym_flags == STT_ARM_TFUNC)
d8321 1
a8321 1
		  if (sym_flags == STT_ARM_TFUNC)
d8366 1
a8366 1
	      if (sym_flags == STT_ARM_TFUNC)
d8650 1
a8650 1
	      = arm_type_of_stub (info, input_section, rel, &sym_flags,
d8859 1
a8859 1
	if (sym_flags == STT_ARM_TFUNC)
d8909 1
a8909 1
	if (sym_flags == STT_ARM_TFUNC)
d9026 1
a9026 1
	if (sym_flags == STT_ARM_TFUNC)
d9681 2
a9682 2
					  (h ? ELF_ST_TYPE (h->type) :
					   ELF_ST_TYPE (sym->st_info)), h,
d11960 1
a11960 2
  if (h->type == STT_FUNC || h->type == STT_ARM_TFUNC
      || h->needs_plt)
d12134 1
a12134 2
	      if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC)
		h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);
d12288 1
a12288 1
      && ELF_ST_TYPE (h->type) == STT_ARM_TFUNC
d12306 1
a12306 1
      myh->type = ELF_ST_INFO (STB_LOCAL, STT_ARM_TFUNC);
d12308 1
d12313 1
d13303 1
a13303 2
		  if (eh != NULL
		      && ELF_ST_TYPE (eh->type) == STT_ARM_TFUNC)
d13618 1
d13718 1
a14464 13
/* Display STT_ARM_TFUNC symbols as functions.  */

static void
elf32_arm_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
			     asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;

  if (ELF_ST_TYPE (elfsym->internal_elf_sym.st_info) == STT_ARM_TFUNC)
    elfsym->symbol.flags |= BSF_FUNCTION;
}


d14477 1
a14477 1
     the address.  Turn these into STT_ARM_TFUNC.  */
a14480 1
      dst->st_info = ELF_ST_INFO (ELF_ST_BIND (dst->st_info), STT_ARM_TFUNC);
d14482 6
d14489 5
d14512 1
a14512 1
  if (ELF_ST_TYPE (src->st_info) == STT_ARM_TFUNC)
a14584 8
/* We have two function types: STT_FUNC and STT_ARM_TFUNC.  */

static bfd_boolean
elf32_arm_is_function_type (unsigned int type)
{
  return (type == STT_FUNC) || (type == STT_ARM_TFUNC);
}

a14664 1
#define elf_backend_symbol_processing		elf32_arm_symbol_processing
a14669 1
#define elf_backend_is_function_type		elf32_arm_is_function_type
@


1.259
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Use call_reloc_p,
	may_need_local_target_p and may_become_dynamic_p to classify
	the relocation type.  Don't check info->symbolic or h->def_regular
	when deciding whether to record a potential dynamic reloc.
	Don't treat potential dynamic relocs as PLT references.
	(elf32_arm_gc_sweep_hook): Update to match.  Assert that we don't
	try to make the PLT reference count go negative.

ld/testsuite/
	* ld-arm/arm-lib-plt-2a.s, ld-arm/arm-lib-plt-2b.s,
	ld-arm/arm-lib-plt-2.dd, ld-arm/arm-lib-plt-2.rd: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d11401 5
a11405 1
  dynobj = elf_hash_table (info)->dynobj;
d11551 3
a11553 7
	    if (htab->root.sgot == NULL)
	      {
		if (htab->root.dynobj == NULL)
		  htab->root.dynobj = abfd;
		if (!create_got_section (htab->root.dynobj, info))
		  return FALSE;
	      }
a13134 1
  BFD_ASSERT (htab->symbian_p || sgot != NULL);
d13144 1
@


1.258
log
@bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Always fill in the
	GOT entry here, rather than leaving it to finish_dynamic_symbol.
	Only create a dynamic relocation for local references if
	info->shared.
	(allocate_dynrelocs_for_symbol): Update dynamic relocation
	allocation accordingly.
	(elf32_arm_finish_dynamic_symbol): Don't initialise the GOT entry here.

ld/testsuite/
	* ld-arm/exec-got-1a.s, ld-arm/exec-got-1b.s, ld-arm/exec-got-1.d,
	ld-arm/unresolved-1.s, ld-arm/unresolved-1.d,
	ld-arm/unresolved-1-dyn.d: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d11246 1
d11248 2
d11259 4
a11287 4
	case R_ARM_ABS32:
	case R_ARM_ABS32_NOI:
	case R_ARM_REL32:
	case R_ARM_REL32_NOI:
d11296 14
d11319 8
d11328 8
a11335 5
	  if (h != NULL)
	    {
	      struct elf32_arm_link_hash_entry *eh;
	      struct elf_dyn_relocs **pp;
	      struct elf_dyn_relocs *p;
d11337 2
a11338 1
	      eh = (struct elf32_arm_link_hash_entry *) h;
d11340 9
a11348 20
	      if (h->plt.refcount > 0)
		{
		  h->plt.refcount -= 1;
		  if (r_type == R_ARM_THM_CALL)
		    eh->plt_maybe_thumb_refcount--;

		  if (r_type == R_ARM_THM_JUMP24
		      || r_type == R_ARM_THM_JUMP19)
		    eh->plt_thumb_refcount--;
		}

	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    /* Everything must go for SEC.  */
		    *pp = p->next;
		    break;
		  }
	    }
	  break;
d11350 7
a11356 2
	default:
	  break;
d11376 3
a11378 1
  bfd_boolean needs_plt;
d11441 4
a11555 7
	  case R_ARM_ABS12:
	    /* VxWorks uses dynamic R_ARM_ABS12 relocations for
	       ldr __GOTT_INDEX__ offsets.  */
	    if (!htab->vxworks_p)
	      break;
	    /* Fall through.  */

d11564 13
a11576 2
	    needs_plt = 1;
	    goto normal_reloc;
a11600 2
	    needs_plt = 0;
	  normal_reloc:
d11603 4
a11606 46
	    if (h != NULL)
	      {
		/* If this reloc is in a read-only section, we might
		   need a copy reloc.  We can't check reliably at this
		   stage whether the section is read-only, as input
		   sections have not yet been mapped to output sections.
		   Tentatively set the flag for now, and correct in
		   adjust_dynamic_symbol.  */
		if (!info->shared)
		  h->non_got_ref = 1;

		/* We may need a .plt entry if the function this reloc
		   refers to is in a different object.  We can't tell for
		   sure yet, because something later might force the
		   symbol local.  */
		if (needs_plt)
		  h->needs_plt = 1;

		/* If we create a PLT entry, this relocation will reference
		   it, even if it's an ABS32 relocation.  */
		h->plt.refcount += 1;

		/* It's too early to use htab->use_blx here, so we have to
		   record possible blx references separately from
		   relocs that definitely need a thumb stub.  */

		if (r_type == R_ARM_THM_CALL)
		  eh->plt_maybe_thumb_refcount += 1;

		if (r_type == R_ARM_THM_JUMP24
		    || r_type == R_ARM_THM_JUMP19)
		  eh->plt_thumb_refcount += 1;
	      }

	    /* If we are creating a shared library or relocatable executable,
	       and this is a reloc against a global symbol, or a non PC
	       relative reloc against a local symbol, then we need to copy
	       the reloc into the shared library.  However, if we are linking
	       with -Bsymbolic, we do not need to copy a reloc against a
               global symbol which is defined in an object we are
               including in the link (i.e., DEF_REGULAR is set).  At
               this point we have not seen all the input files, so it is
               possible that DEF_REGULAR is not set now but will be set
               later (it is never cleared).  We account for that
               possibility below by storing information in the
               dyn_relocs field of the hash table entry.  */
d11609 5
a11613 76
		&& ((r_type == R_ARM_ABS32 || r_type == R_ARM_ABS32_NOI)
		    || (h != NULL && ! needs_plt
			&& (! info->symbolic || ! h->def_regular))))
	      {
		struct elf_dyn_relocs *p, **head;

	        /* When creating a shared object, we must copy these
                   reloc types into the output file.  We create a reloc
                   section in dynobj and make room for this reloc.  */
  	        if (sreloc == NULL)
		  {
		    sreloc = _bfd_elf_make_dynamic_reloc_section
		      (sec, dynobj, 2, abfd, ! htab->use_rel);

		    if (sreloc == NULL)
		      return FALSE;

		    /* BPABI objects never have dynamic relocations mapped.  */
		    if (htab->symbian_p)
		      {
			flagword flags;

			flags = bfd_get_section_flags (dynobj, sreloc);
			flags &= ~(SEC_LOAD | SEC_ALLOC);
			bfd_set_section_flags (dynobj, sreloc, flags);
		      }
		  }

		/* If this is a global symbol, we count the number of
		   relocations we need for this symbol.  */
		if (h != NULL)
		  {
		    head = &((struct elf32_arm_link_hash_entry *) h)->dyn_relocs;
		  }
		else
		  {
		    /* Track dynamic relocs needed for local syms too.
		       We really need local syms available to do this
		       easily.  Oh well.  */
		    asection *s;
		    void *vpp;
		    Elf_Internal_Sym *isym;

		    isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						  abfd, r_symndx);
		    if (isym == NULL)
		      return FALSE;

		    s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		    if (s == NULL)
		      s = sec;

		    vpp = &elf_section_data (s)->local_dynrel;
		    head = (struct elf_dyn_relocs **) vpp;
		  }

		p = *head;
		if (p == NULL || p->sec != sec)
		  {
		    bfd_size_type amt = sizeof *p;

		    p = (struct elf_dyn_relocs *)
                        bfd_alloc (htab->root.dynobj, amt);
		    if (p == NULL)
		      return FALSE;
		    p->next = *head;
		    *head = p;
		    p->sec = sec;
		    p->count = 0;
		    p->pc_count = 0;
		  }

		if (r_type == R_ARM_REL32 || r_type == R_ARM_REL32_NOI)
		  p->pc_count += 1;
		p->count += 1;
	      }
d11632 106
@


1.257
log
@bfd/
	* elf32-arm.c (elf32_arm_allocate_dynrelocs): New function.
	(elf32_arm_add_dynreloc): Likewise.
	(elf32_arm_adjust_dynamic_symbol): Use elf32_arm_allocate_dynrelocs
	to allocate dynamic relocations.
	(elf32_arm_size_dynamic_sections): Likewise.
	(allocate_dynrelocs): Likewise.  Rename to
	allocate_dynrelocs_for_symbol.
	(elf32_arm_final_link_relocate): Use elf32_arm_add_dynreloc to
	create dynamic relocations.
	(elf32_arm_finish_dynamic_symbol): Likewise.
@
text
@a8280 1
	  bfd_boolean dyn;
d8284 12
a8295 1
	  dyn = globals->root.dynamic_sections_created;
d8297 15
a8311 17
	  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      || (info->shared
		  && SYMBOL_REFERENCES_LOCAL (info, h))
	      || (ELF_ST_VISIBILITY (h->other)
		  && h->root.type == bfd_link_hash_undefweak))
	    {
	      /* This is actually a static link, or it is a -Bsymbolic link
		 and the symbol is defined locally.  We must initialize this
		 entry in the global offset table.  Since the offset must
		 always be a multiple of 4, we use the least significant bit
		 to record whether we have initialized it already.

		 When doing a dynamic link, we create a .rel(a).got relocation
		 entry to initialize the value.  This is done in the
		 finish_dynamic_symbol routine.  */
	      if ((off & 1) != 0)
		off &= ~1;
d8314 5
a8318 4
		  /* If we are addressing a Thumb function, we need to
		     adjust the address by one, so that attempts to
		     call the function pointer will correctly
		     interpret it as Thumb code.  */
d8320 12
a8331 1
		    value |= 1;
d8333 6
a8338 2
		  bfd_put_32 (output_bfd, value, sgot->contents + off);
		  h->got.offset |= 1;
d8340 1
a8341 3
	  else
	    *unresolved_reloc_p = FALSE;

d12247 8
a12254 4
	  else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		    || h->root.type != bfd_link_hash_undefweak)
		   && (info->shared
	    	   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a13044 47
  if (h->got.offset != (bfd_vma) -1
      && (! GOT_TLS_GD_ANY_P (elf32_arm_hash_entry (h)->tls_type)) 
      && (elf32_arm_hash_entry (h)->tls_type & GOT_TLS_IE) == 0)
    {
      asection * sgot;
      asection * srel;
      Elf_Internal_Rela rel;
      bfd_vma offset;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      sgot = htab->root.sgot;
      srel = htab->root.srelgot;
      BFD_ASSERT (sgot != NULL && srel != NULL);

      offset = (h->got.offset & ~(bfd_vma) 1);
      rel.r_addend = 0;
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + offset);

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  BFD_ASSERT ((h->got.offset & 1) != 0);
	  rel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
	  if (!htab->use_rel)
	    {
	      rel.r_addend = bfd_get_32 (output_bfd, sgot->contents + offset);
	      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + offset);
	    }
	}
      else
	{
	  BFD_ASSERT ((h->got.offset & 1) == 0);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + offset);
	  rel.r_info = ELF32_R_INFO (h->dynindx, R_ARM_GLOB_DAT);
	}

      elf32_arm_add_dynreloc (output_bfd, info, srel, &rel);
    }

@


1.256
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Check needs_plt rather than
	h->needs_plt when deciding whether to record a possible dynamic reloc.

ld/testsuite/
	* ld-arm/arm-rel32.s, ld-arm/arm-rel32.d: New testcase.
	* ld-arm/arm-elf.exp: Run it.
@
text
@d6916 35
a7385 1
	  bfd_byte *loc;
d7474 1
a7474 3
	  loc = sreloc->contents;
	  loc += sreloc->reloc_count++ * RELOC_SIZE (globals);
	  SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
a8350 1
		  bfd_byte *loc;
d8359 1
a8359 3
		  loc = srelgot->contents;
		  loc += srelgot->reloc_count++ * RELOC_SIZE (globals);
		  SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
a8398 1
		bfd_byte *loc;
d8412 1
a8412 3
		loc = srelgot->contents;
		loc += srelgot->reloc_count++ * RELOC_SIZE (globals);
		SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
a8477 1
	    bfd_byte *loc = NULL;
d8495 2
a8547 2
		    loc = srelgot->contents;
		    loc += srelgot->reloc_count++ * RELOC_SIZE (globals);
d8549 1
a8549 1
		    SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
d8565 2
a8566 4
		    	loc = srelgot->contents;
		   	loc += srelgot->reloc_count++ * RELOC_SIZE (globals);

			SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
d8602 1
a8602 4
		    loc = srelgot->contents;
		    loc += srelgot->reloc_count++ * RELOC_SIZE (globals);

		    SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
d12002 1
a12002 2
      BFD_ASSERT (srel != NULL);
      srel->size += RELOC_SIZE (globals);
d12013 1
a12013 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d12104 1
a12104 1
	  htab->root.srelplt->size += RELOC_SIZE (htab);
d12115 1
a12115 1
		htab->srelplt2->size += RELOC_SIZE (htab);
d12120 1
a12120 1
	      htab->srelplt2->size += RELOC_SIZE (htab) * 2;
d12208 1
a12208 1
		htab->root.srelgot->size += RELOC_SIZE (htab);
d12211 1
a12211 1
		htab->root.srelgot->size += RELOC_SIZE (htab);
d12215 1
a12215 1
		  htab->root.srelplt->size += RELOC_SIZE (htab); 
d12223 1
a12223 1
		htab->root.srelgot->size += RELOC_SIZE (htab); 
d12229 1
a12229 1
	    htab->root.srelgot->size += RELOC_SIZE (htab);
d12377 1
a12377 1
      sreloc->size += p->count * RELOC_SIZE (htab);
d12499 1
a12499 1
		  srel->size += p->count * RELOC_SIZE (htab);
d12550 1
a12550 1
		srel->size += RELOC_SIZE (htab);
d12554 1
a12554 1
		  htab->root.srelplt->size += RELOC_SIZE (htab);
d12570 1
a12570 1
	htab->root.srelgot->size += RELOC_SIZE (htab);
d12577 1
a12577 1
  elf_link_hash_traverse (& htab->root, allocate_dynrelocs, info);
a13025 1
      bfd_byte *loc;
d13063 1
a13063 2
      loc = srel->contents + srel->reloc_count++ * RELOC_SIZE (htab);
      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
a13069 1
      bfd_byte *loc;
d13084 1
a13084 2
      loc = s->contents + s->reloc_count++ * RELOC_SIZE (htab);
      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
@


1.255
log
@bfd/
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Remove all registered
	dynamic relocs for the removed section.

ld/testsuite/
	* ld-arm/gc-thumb-lib.s, ld-arm/gc-thumb.s,
	ld-arm/gc-thumb.d: New test.
	* ld-arm/arm-elf.exp: Run it.
@
text
@d11579 1
a11579 1
		    || (h != NULL && ! h->needs_plt
@


1.254
log
@	PR ld/12339
	* elf32-arm.c (allocate_dynrelocs): Don't set up eh before
	following bfd_link_hash_warning symbol link.
@
text
@d11280 7
a11286 15
	      if (r_type == R_ARM_ABS32
		  || r_type == R_ARM_REL32
                  || r_type == R_ARM_ABS32_NOI
                  || r_type == R_ARM_REL32_NOI)
		for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		  if (p->sec == sec)
		    {
		      p->count -= 1;
		      if (ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
			  || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32_NOI)
			p->pc_count -= 1;
		      if (p->count == 0)
			*pp = p->next;
		      break;
		    }
@


1.253
log
@elf32-arm.c (elf32_arm_tls_relax): Note fixme pointed out by AlanM
@
text
@d3 1
a3 1
   2008, 2009, 2010  Free Software Foundation, Inc.
a12009 2
  eh = (struct elf32_arm_link_hash_entry *) h;

d12019 2
@


1.252
log
@	bfd/
	* reloc.c (BFD_RELOC_ARM_TLS_GOTDESC, BFD_RELOC_ARM_TLS_CALL,
	BFD_RELOC_ARM_THM_TLS_CALL, BFD_RELOC_ARM_TLS_DESCSEQ,
	BFD_RELOC_ARM_THM_TLS_DESCSEQ, BFD_RELOC_ARM_TLS_DESC): New
	relocations.
	* libbfd.h: Rebuilt.
	* bfd-in2.h: Rebuilt.
	* elf32-arm.c (elf32_arm_howto_table_1): Add new relocations.
	(elf32_arm_reloc_map): Likewise.
	(tls_trampoline, dl_tlsdesc_lazy_trampoline): New PLT templates.
	(elf32_arm_stub_long_branch_any_tls_pic,
	elf32_arm_stub_long_branch_v4t_thumb_tls_pic): New stub templates.
	(DEF_STUBS): Add new stubs.
	(struct_elf_arm_obj_data): Add local_tlsdesc_gotent field.
	(elf32_arm_local_tlsdesc_gotent): New.
	(GOT_TLS_GDESC): New mask.
	(GOT_TLS_GD_ANY): Define.
	(struct elf32_arm_link_hash_entry): Add tlsdesc_got field.
	(elf32_arm_compute_jump_table_size): New.
	(struct elf32_arm_link_hash_table): Add next_tls_desc_index,
	num_tls_desc, dt_tlsdesc_plt, dt_tlsdesc_got, tls_trampoline,
	sgotplt_jump_table_size fields.
	(elf32_arm_link_hash_newfunc): Initialize tlsdesc_got field.
	(elf32_arm_link_hash_table_create): Initialize new fields.
	(arm_type_of_stub): Check TLS desc relocs too.
	(elf32_arm_stub_name): TLS desc relocs can be shared.
	(elf32_arm_tls_transition): Determine relaxation.
	(arm_stub_required_alignment): Add tls stubs.
	(elf32_arm_size_stubs): Likewise.
	(elf32_arm_tls_relax): Perform TLS relaxing.
	(elf32_arm_final_link_relocate): Process TLS DESC relocations.
	(IS_ARM_TLS_GNU_RELOC): New.
	(IS_ARM_TLS_RELOC): Use it.
	(elf32_arm_relocate_section): Perform TLS relaxing.
	(elf32_arm_check_relocs): Anticipate TLS relaxing, process tls
	desc relocations.
	(allocate_dynrelocs): Allocate tls desc relcoations.
	(elf32_arm_output_arch_local_syms): Emit tls trampoline mapping
	symbols.
	(elf32_arm_size_dynamic_sections): Allocate tls trampolines and
	got slots.
	(elf32_arm_always_size_sections): New. Create _TLS_MODULE_BASE
	symbol.
	(elf32_arm_finish_dynamic_symbol): Adjust.
	(arm_put_trampoline): New.
	(elf32_arm_finish_dynamic_sections): Emit new dynamic tags and tls
	trampolines.
	(elf_backend_always_size_sections): Define.

	include/elf/
	* arm.h (R_ARM_TLS_DESC, R_ARM_TLS_GOTDESC, R_ARM_TLS_CALL,
	R_ARM_TLS_DESCSEQ, T_ARM_THM_TLS_CALL, R_ARM_THM_TLS_DESCSEQ): New
	relocations.

	gas/
	* doc/c-arm.texi: Document TLSDESC and TLSCALL relocations, and
	.tlsdescseq directive.
	* config/tc-arm.c (arm_typed_reg_parse): Check for potential reloc
	following a symbol.
	(s_arm_tls_descseq): New directive.
	(md_pseudo_table): Add it.
	(encode_branch): Allow TLS_CALL relocs too.
	(do_t_blx, do_t_branch23): Use encode_branch.
	(reloc_names): Add tlsdesc and tlscall.
	(md_apply_fix): Process tls desc relocations.
	(tc_gen_reloc): Likewise.
	(arm_fix_adjustable): Likewise.

	gas/testsuite/
	* gas/arm/tls.s: Add tlsdesc tests.
	* gas/arm/tls.d: Adjust.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Added tests for new TLS handling
	relocations.
	* ld-arm/tls-descrelax-be32.d: New.
	* ld-arm/tls-descrelax-be32.s: New.
	* ld-arm/tls-descrelax-be8.d: New.
	* ld-arm/tls-descrelax-be8.s: New.
	* ld-arm/tls-descrelax-v7.d: New.
	* ld-arm/tls-descrelax-v7.s: New.
	* ld-arm/tls-descrelax.d: New.
	* ld-arm/tls-descrelax.s: New.
	* ld-arm/tls-descseq.d: New.
	* ld-arm/tls-descseq.r: New.
	* ld-arm/tls-descseq.s: New.
	* ld-arm/tls-gdesc-got.d: New.
	* ld-arm/tls-gdesc-got.s: New.
	* ld-arm/tls-gdesc-nlazy.g: New.
	* ld-arm/tls-gdesc-nlazy.s: New.
	* ld-arm/tls-gdesc.d: New.
	* ld-arm/tls-gdesc.r: New.
	* ld-arm/tls-gdesc.s: New.
	* ld-arm/tls-gdierelax.d: New.
	* ld-arm/tls-gdierelax.s: New.
	* ld-arm/tls-gdierelax2.d: New.
	* ld-arm/tls-gdierelax2.s: New.
	* ld-arm/tls-gdlerelax.d: New.
	* ld-arm/tls-gdlerelax.s: New.
	* ld-arm/tls-lib-loc.d: New.
	* ld-arm/tls-lib-loc.r: New.
	* ld-arm/tls-lib-loc.s: New.
	* ld-arm/tls-longplt-lib.d: New.
	* ld-arm/tls-longplt-lib.s: New.
	* ld-arm/tls-longplt.d: New.
	* ld-arm/tls-longplt.s: New.
	* ld-arm/tls-mixed.r: New.
	* ld-arm/tls-mixed.s: New.
	* ld-arm/tls-thumb1.d: New.
	* ld-arm/tls-thumb1.s: New.
	* ld-arm/arm-elf.exp: New.
@
text
@d6988 5
a6992 2
   case of error.  */
 
@


1.251
log
@bfd/
	* elf32-arm.c (elf32_arm_link_hash_table): Remove sgot, sgotplt,
	srelgot, splt, srelplt.
	(create_got_section, elf32_arm_link_hash_table_create): Don't set them.
	(elf32_arm_create_dynamic_sections): Likewise.  Use htab->root
	fields instead.
	(arm_type_of_stub): Use the root fields instead of the removed ones.
	(cortex_a8_erratum_scan, elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(elf32_arm_check_relocs, allocate_dynrelocs): Likewise.
	(elf32_arm_size_dynamic_sections): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	(elf32_arm_final_link_relocate): Set sgot, splt and srelgot from the
	htab fields instead of looking them up by name.  Consistently use
	these local variables instead of htab fields.
	(elf32_arm_finish_dynamic_symbol): Likewise sgot, splt and srel.
	Use srelbss instead of looking it up by name.
	(elf32_arm_finish_dynamic_sections): Use sgotplt, splt and srelplt
	instead of looking up the symbols by name.  Use the root fields
	instead of the removed ones.
@
text
@d264 1
a264 1
  HOWTO (R_ARM_SWI24,		/* type */
d266 2
a267 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d270 1
a270 1
	 complain_overflow_signed,/* complain_on_overflow */
d272 1
a272 1
	 "R_ARM_SWI24",		/* name */
d274 2
a275 2
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
d1355 55
a1409 4
  EMPTY_HOWTO (90),   /* Unallocated.  */
  EMPTY_HOWTO (91),
  EMPTY_HOWTO (92),
  EMPTY_HOWTO (93),
d1653 32
d1816 6
d2004 20
d2279 20
d2350 2
d2560 3
d2576 3
d2618 2
d2622 4
d2662 3
d2743 6
d2756 13
d2782 4
d2835 1
d3050 5
d3253 2
a3254 1
  if (r_type == R_ARM_THM_CALL || r_type == R_ARM_THM_JUMP24)
d3271 2
a3272 1
	      && (((r_type == R_ARM_THM_CALL) && !globals->use_blx)
d3323 2
a3324 1
	      stub_type = (info->shared | globals->pic_veneer)
d3326 9
a3334 6
		? ((globals->use_blx
		    && (r_type ==R_ARM_THM_CALL))
		   /* V5T and above.  */
		   ? arm_stub_long_branch_any_arm_pic
		   /* V4T PIC stub.  */
		   : arm_stub_long_branch_v4t_thumb_arm_pic)
d3337 1
a3337 2
		: ((globals->use_blx
		    && (r_type ==R_ARM_THM_CALL))
d3353 2
a3354 1
	   || r_type == R_ARM_PLT32)
d3374 1
a3374 1
	      || ((r_type == R_ARM_CALL) && !globals->use_blx)
d3400 2
a3401 1
	      stub_type = (info->shared | globals->pic_veneer)
d3403 4
a3406 1
		? arm_stub_long_branch_any_arm_pic
d3451 3
a3453 1
		 (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
d3616 26
d3669 2
d4637 9
a4645 2

		  /* Only look for stubs on branch instructions.  */
d4652 9
a4660 1
		      && (r_type != (unsigned int) R_ARM_PLT32))
a4667 1
		  hash = NULL;
d4669 14
a4682 1
		  if (r_indx < symtab_hdr->sh_info)
a4729 6
		      int e_indx;

		      e_indx = r_indx - symtab_hdr->sh_info;
		      hash = ((struct elf32_arm_link_hash_entry *)
			      elf_sym_hashes (input_bfd)[e_indx]);

d6982 142
d7215 1
d7233 5
d7257 2
d8399 2
d8403 3
d8407 2
a8408 2
	bfd_vma off;
	int indx;
d8411 1
a8411 2
	if (sgot == NULL)
	  abort ();
a8412 1
	indx = 0;
d8425 1
d8430 1
a8430 2
	    if (local_got_offsets == NULL)
	      abort ();
d8432 1
d8436 6
a8441 2
	if (tls_type == GOT_UNKNOWN)
	  abort ();
d8462 1
a8462 4
		if (srelgot == NULL)
		  abort ();
		loc = srelgot->contents;
		loc += srelgot->reloc_count * RELOC_SIZE (globals);
d8465 40
d8518 2
a8521 2
		    srelgot->reloc_count++;
		    loc += RELOC_SIZE (globals);
d8537 2
a8540 2
			srelgot->reloc_count++;
			loc += RELOC_SIZE (globals);
d8576 3
a8579 2
		    srelgot->reloc_count++;
		    loc += RELOC_SIZE (globals);
d8595 136
a8730 2
	value = sgot->output_section->vma + sgot->output_offset + off
	  - (input_section->output_section->vma + input_section->output_offset + rel->r_offset);
d9358 10
a9367 1
   || (R_TYPE) == R_ARM_TLS_IE32)
d9610 27
a9636 6
      r = elf32_arm_final_link_relocate (howto, input_bfd, output_bfd,
					 input_section, contents, rel,
					 relocation, info, sec, name,
					 (h ? ELF_ST_TYPE (h->type) :
					  ELF_ST_TYPE (sym->st_info)), h,
					 &unresolved_reloc, &error_message);
d11379 2
d11387 5
d11399 1
d11401 6
d11426 2
a11427 1
		      size *= (sizeof (bfd_signed_vma) + sizeof (char));
d11433 3
d11437 2
a11438 1
			= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d11444 9
a11452 4
	      /* We will already have issued an error message if there is a
		 TLS / non-TLS mismatch, based on the symbol type.  We don't
		 support any linker relaxations.  So just combine any TLS
		 types needed.  */
d11457 7
d12084 2
a12085 1
	      eh->plt_got_offset = htab->root.sgotplt->size;
d12091 1
d12121 3
d12153 13
d12167 8
a12174 2
		/* R_ARM_TLS_GD32 needs 2 consecutive GOT slots.  */
		s->size += 8;
d12199 11
a12209 2
	      if ((tls_type & GOT_TLS_GD) && indx != 0)
		htab->root.srelgot->size += RELOC_SIZE (htab);
d12451 1
d12500 1
d12503 2
a12504 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
d12506 1
d12513 10
a12524 2
	      if (*local_tls_type == GOT_NORMAL)
		s->size += 4;
d12526 10
a12535 1
	      if (info->shared || *local_tls_type == GOT_TLS_GD)
d12537 6
d12584 28
d12702 5
d12747 43
d13006 1
a13006 1
      && (elf32_arm_hash_entry (h)->tls_type & GOT_TLS_GD) == 0
d13087 18
d13258 14
d13361 35
d13970 22
d14650 1
@


1.250
log
@bfd/
	* elf32-arm.c (elf32_arm_relocs_copied): Delete.
	(elf32_arm_link_hash_entry): Replace relocs_copied with dyn_relocs.
	(elf32_arm_link_hash_newfunc): Update accordingly.
	(elf32_arm_copy_indirect_symbol, elf32_arm_gc_sweep_hook): Likewise.
	(elf32_arm_check_relocs, allocate_dynrelocs): Likewise.
	(elf32_arm_readonly_dynrelocs): Likewise.
	(elf32_arm_size_dynamic_sections): Likewise.
@
text
@a2597 5
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
a2738 9
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_get_section_by_name (dynobj,
					   RELOC_SECTION (htab, ".got"));
  if (htab->srelgot == NULL)
    return FALSE;
d2755 1
a2755 1
  if (!htab->sgot && !create_got_section (dynobj, info))
a2760 3
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj,
					   RELOC_SECTION (htab, ".plt"));
d2786 2
a2787 2
  if (!htab->splt
      || !htab->srelplt
a2876 5
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
d3055 1
a3055 1
  if (globals->splt != NULL
d3070 2
a3071 2
      destination = (globals->splt->output_section->vma
		     + globals->splt->output_offset
d4093 1
a4093 1
		      if (htab->splt != NULL && found->hash != NULL
d4513 1
a4513 1
			      && globals->splt != NULL
d4517 1
a4517 1
			      sym_sec = globals->splt;
d4540 1
a4540 1
			      && globals->splt != NULL
d4544 1
a4544 1
			      sym_sec = globals->splt;
d5535 1
a5535 1
	  if (globals->splt != NULL && h->plt.offset != (bfd_vma) -1)
a6835 1
  bfd *                         dynobj = NULL;
d6840 1
d6869 3
a6871 6
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj)
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      splt = bfd_get_section_by_name (dynobj, ".plt");
    }
a7928 1
		  asection * srelgot;
a7931 2
		  srelgot = (bfd_get_section_by_name
			     (dynobj, RELOC_SECTION (globals, ".got")));
d7967 1
a7967 1
	if (globals->sgot == NULL)
d7983 1
a7983 1
		if (globals->srelgot == NULL)
d7987 2
a7988 2
		outrel.r_offset = (globals->sgot->output_section->vma
				   + globals->sgot->output_offset + off);
d7993 1
a7993 1
			      globals->sgot->contents + off);
d7995 2
a7996 2
		loc = globals->srelgot->contents;
		loc += globals->srelgot->reloc_count++ * RELOC_SIZE (globals);
d8000 1
a8000 1
	      bfd_put_32 (output_bfd, 1, globals->sgot->contents + off);
d8005 1
a8005 1
	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off
d8020 1
a8020 1
	if (globals->sgot == NULL)
d8068 1
a8068 1
		if (globals->srelgot == NULL)
d8070 2
a8071 2
		loc = globals->srelgot->contents;
		loc += globals->srelgot->reloc_count * RELOC_SIZE (globals);
d8079 2
a8080 2
		    outrel.r_offset = (globals->sgot->output_section->vma
				       + globals->sgot->output_offset
d8086 1
a8086 1
				  globals->sgot->contents + cur_off);
d8089 1
a8089 1
		    globals->srelgot->reloc_count++;
d8094 1
a8094 1
				  globals->sgot->contents + cur_off + 4);
d8104 1
a8104 1
				      globals->sgot->contents + cur_off + 4);
d8108 1
a8108 1
			globals->srelgot->reloc_count++;
d8120 1
a8120 1
				globals->sgot->contents + cur_off);
d8122 1
a8122 1
				globals->sgot->contents + cur_off + 4);
d8136 2
a8137 2
		    outrel.r_offset = (globals->sgot->output_section->vma
				       + globals->sgot->output_offset
d8143 1
a8143 1
				  globals->sgot->contents + cur_off);
d8146 1
a8146 1
		    globals->srelgot->reloc_count++;
d8151 1
a8151 1
			      globals->sgot->contents + cur_off);
d8163 1
a8163 1
	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off
d10854 1
a10854 1
	    if (htab->sgot == NULL)
d11411 1
a11411 1
	  asection *s = htab->splt;
d11457 2
a11458 2
	      eh->plt_got_offset = htab->sgotplt->size;
	      htab->sgotplt->size += 4;
d11462 1
a11462 1
	  htab->srelplt->size += RELOC_SIZE (htab);
d11510 1
a11510 1
	  s = htab->sgot;
d11543 1
a11543 1
		htab->srelgot->size += RELOC_SIZE (htab);
d11546 1
a11546 1
		htab->srelgot->size += RELOC_SIZE (htab);
d11549 1
a11549 1
		htab->srelgot->size += RELOC_SIZE (htab);
d11555 1
a11555 1
	    htab->srelgot->size += RELOC_SIZE (htab);
d11839 2
a11840 2
      s = htab->sgot;
      srel = htab->srelgot;
d11866 2
a11867 2
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 8;
d11869 1
a11869 1
	htab->srelgot->size += RELOC_SIZE (htab);
d11924 1
a11924 1
	      if (s != htab->srelplt && s != htab->srelplt2)
a12035 1
  bfd * dynobj;
a12038 1
  dynobj = elf_hash_table (info)->dynobj;
d12058 2
a12059 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      srel = bfd_get_section_by_name (dynobj, RELOC_SECTION (htab, ".plt"));
d12092 1
a12092 1
	  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d12116 1
a12116 1
	  ptr = htab->splt->contents + h->plt.offset;
d12254 2
a12255 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, RELOC_SECTION (htab, ".got"));
d12302 1
a12302 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   RELOC_SECTION (htab, ".bss"));
d12340 1
a12340 1
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d12349 1
a12349 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
d12416 1
a12416 2
	      s = bfd_get_section_by_name (output_bfd,
					   RELOC_SECTION (htab, ".plt"));
d12435 1
a12435 2
		  s = bfd_get_section_by_name (output_bfd,
					       RELOC_SECTION (htab, ".plt"));
d12566 1
a12566 1
      if (htab->vxworks_p && !info->shared && htab->splt->size > 0)
d12573 1
a12573 1
	  num_plts = ((htab->splt->size - htab->plt_header_size)
d13111 1
a13111 1
  if (!htab->splt || htab->splt->size == 0)
d13114 1
d13116 1
a13116 2
						     htab->splt->output_section);
  osi.sec = htab->splt;
@


1.249
log
@bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Remove unused
	variables.
@
text
@a2453 20
/* The ARM linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of relocs we have copied
   for a given symbol.  */
struct elf32_arm_relocs_copied
  {
    /* Next section.  */
    struct elf32_arm_relocs_copied * next;
    /* A section in dynobj.  */
    asection * section;
    /* Number of relocs copied in this section.  */
    bfd_size_type count;
    /* Number of PC-relative relocs copied in this section.  */
    bfd_size_type pc_count;
  };

d2461 2
a2462 2
    /* Number of PC relative relocs copied for this symbol.  */
    struct elf32_arm_relocs_copied * relocs_copied;
d2669 1
a2669 1
      ret->relocs_copied = NULL;
d2824 1
a2824 1
  if (eind->relocs_copied != NULL)
d2826 1
a2826 1
      if (edir->relocs_copied != NULL)
d2828 2
a2829 2
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;
d2833 1
a2833 1
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
d2835 1
a2835 1
	      struct elf32_arm_relocs_copied *q;
d2837 2
a2838 2
	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
d2848 1
a2848 1
	  *pp = edir->relocs_copied;
d2851 2
a2852 2
      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
d10693 2
a10694 2
	      struct elf32_arm_relocs_copied **pp;
	      struct elf32_arm_relocs_copied *p;
d10713 2
a10714 4
		{
		  for (pp = &eh->relocs_copied; (p = *pp) != NULL;
		       pp = &p->next)
		  if (p->section == sec)
d10718 1
a10718 1
                          || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32_NOI)
a10723 1
		}
d10981 1
a10981 1
               relocs_copied field of the hash table entry.  */
d10988 1
a10988 1
		struct elf32_arm_relocs_copied *p, **head;
d11016 1
a11016 1
		    head = &((struct elf32_arm_link_hash_entry *) h)->relocs_copied;
d11037 1
a11037 1
		    head = (struct elf32_arm_relocs_copied **) vpp;
d11041 1
a11041 1
		if (p == NULL || p->section != sec)
d11045 1
a11045 1
		    p = (struct elf32_arm_relocs_copied *)
d11051 1
a11051 1
		    p->section = sec;
d11405 1
a11405 1
  struct elf32_arm_relocs_copied *p;
d11620 1
a11620 1
  if (eh->relocs_copied == NULL)
d11639 1
a11639 1
	  struct elf32_arm_relocs_copied **pp;
d11641 1
a11641 1
	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
d11654 1
a11654 1
	  struct elf32_arm_relocs_copied **pp;
d11656 1
a11656 1
	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
d11658 1
a11658 1
	      if (strcmp (p->section->output_section->name, ".tls_vars") == 0)
d11667 1
a11667 1
      if (eh->relocs_copied != NULL
d11671 1
a11671 1
	    eh->relocs_copied = NULL;
d11722 1
a11722 1
      eh->relocs_copied = NULL;
d11728 1
a11728 1
  for (p = eh->relocs_copied; p != NULL; p = p->next)
d11730 1
a11730 1
      asection *sreloc = elf_section_data (p->section)->sreloc;
d11743 1
a11743 1
  struct elf32_arm_relocs_copied * p;
d11749 1
a11749 1
  for (p = eh->relocs_copied; p != NULL; p = p->next)
d11751 1
a11751 1
      asection *s = p->section;
d11829 1
a11829 1
	  struct elf32_arm_relocs_copied *p;
d11831 1
a11831 1
	  for (p = (struct elf32_arm_relocs_copied *)
d11834 2
a11835 2
	      if (!bfd_is_abs_section (p->section)
		  && bfd_is_abs_section (p->section->output_section))
d11843 1
a11843 1
		       && strcmp (p->section->output_section->name,
d11851 1
a11851 1
		  srel = elf_section_data (p->section)->sreloc;
d11853 1
a11853 1
		  if ((p->section->output_section->flags & SEC_READONLY) != 0)
@


1.248
log
@	* elf-attrs.c (_bfd_elf_merge_unknown_attribute_low,
	_bfd_elf_merge_unknown_attribute_list): New.
	* elf-bfd.h (struct elf_backend_data): Add
	obj_attrs_handle_unknown.
	(_bfd_elf_merge_unknown_attribute_low,
	_bfd_elf_merge_unknown_attribute_list): Declare.
	* elf32-arm.c (elf32_arm_obj_attrs_handle_unknown): New.  Split
	out from elf32_arm_merge_eabi_attributes.
	(elf32_arm_merge_eabi_attributes): Use
	_bfd_elf_merge_unknown_attribute_low and
	_bfd_elf_merge_unknown_attribute_list.
	(elf_backend_obj_attrs_handle_unknown): Define.
	* elfxx-target.h (elf_backend_obj_attrs_handle_unknown): Define.
	(elfNN_bed): Update initializer.
@
text
@a9906 3
  obj_attribute_list *in_list;
  obj_attribute_list *out_list;
  obj_attribute_list **out_listp;
a10416 4
  in_list = elf_other_obj_attributes_proc (ibfd);
  out_listp = &elf_other_obj_attributes_proc (obfd);
  out_list = *out_listp;

@


1.248.2.1
log
@bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Remove unused
	variables.
@
text
@d9907 3
d10420 4
@


1.248.2.2
log
@bfd/
	* elf32-arm.c (cortex_a8_erratum_scan): If the stub is a Thumb
	branch to a PLT entry, redirect it to the PLT's Thumb entry point.

ld/testsuite/
	* ld-arm/cortex-a8-fix-b-plt.s, ld-arm/cortex-a8-fix-b-plt.d,
	ld-arm/cortex-a8-fix-bcc-plt.s, ld-arm/cortex-a8-fix-bcc-plt.d,
	ld-arm/cortex-a8-fix-bl-plt.s, ld-arm/cortex-a8-fix-bl-plt.d,
	ld-arm/cortex-a8-fix-blx-plt.s, ld-arm/cortex-a8-fix-blx-plt.d,
	ld-arm/cortex-a8-fix-plt.ld: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@a4112 1
                  bfd_boolean use_plt = FALSE;
d4124 1
a4226 6
                      /* If the stub will use a Thumb-mode branch to a
                         PLT target, redirect it to the preceding Thumb
                         entry point.  */
                      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
                        offset -= PLT_THUMB_STUB_SIZE;

@


1.248.2.3
log
@bfd/ChangeLog

2012-11-16  Joey Ye  <joey.ye@@arm.com>

	* elf32-arm.c (elf32_arm_final_link_relocate,
	case R_ARM_THM_ALU_PREL_11_0, case R_ARM_THM_PC12): Align address of
	the place being relocated.
	(elf32_arm_final_link_relocate, case R_ARM_THM_PC8): Align address
	of the place being relocated and truncate addend.
	(Pa): New macro.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011, 2012  Free Software Foundation, Inc.
a63 3
/* The Adjusted Place, as defined by AAELF.  */
#define Pa(X) ((X) & 0xfffffffc)

d7393 3
a7395 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d7425 1
a7425 1
	  addend = ((((insn & 0x00ff) << 2) + 4) & 0x3ff) -4;
d7428 3
a7430 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
d7465 3
a7467 3
	relocation -= Pa (input_section->output_section->vma
		          + input_section->output_offset
		          + rel->r_offset);
@


1.247
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d9656 21
d10406 2
a10407 39
	  {
	    bfd *err_bfd = NULL;

	    /* The "known_obj_attributes" table does contain some undefined
	       attributes.  Ensure that there are unused.  */
	    if (out_attr[i].i != 0 || out_attr[i].s != NULL)
	      err_bfd = obfd;
	    else if (in_attr[i].i != 0 || in_attr[i].s != NULL)
	      err_bfd = ibfd;

	    if (err_bfd != NULL)
	      {
		/* Attribute numbers >=64 (mod 128) can be safely ignored.  */
		if ((i & 127) < 64)
		  {
		    _bfd_error_handler
		      (_("%B: Unknown mandatory EABI object attribute %d"),
		       err_bfd, i);
		    bfd_set_error (bfd_error_bad_value);
		    result = FALSE;
		  }
		else
		  {
		    _bfd_error_handler
		      (_("Warning: %B: Unknown EABI object attribute %d"),
		       err_bfd, i);
		  }
	      }

	    /* Only pass on attributes that match in both inputs.  */
	    if (in_attr[i].i != out_attr[i].i
		|| in_attr[i].s != out_attr[i].s
		|| (in_attr[i].s != NULL && out_attr[i].s != NULL
		    && strcmp (in_attr[i].s, out_attr[i].s) != 0))
	      {
		out_attr[i].i = 0;
		out_attr[i].s = NULL;
	      }
	  }
d10424 1
a10424 48
  for (; in_list || out_list; )
    {
      bfd *err_bfd = NULL;
      int err_tag = 0;

      /* The tags for each list are in numerical order.  */
      /* If the tags are equal, then merge.  */
      if (out_list && (!in_list || in_list->tag > out_list->tag))
	{
	  /* This attribute only exists in obfd.  We can't merge, and we don't
	     know what the tag means, so delete it.  */
	  err_bfd = obfd;
	  err_tag = out_list->tag;
	  *out_listp = out_list->next;
	  out_list = *out_listp;
	}
      else if (in_list && (!out_list || in_list->tag < out_list->tag))
	{
	  /* This attribute only exists in ibfd. We can't merge, and we don't
	     know what the tag means, so ignore it.  */
	  err_bfd = ibfd;
	  err_tag = in_list->tag;
	  in_list = in_list->next;
	}
      else /* The tags are equal.  */
	{
	  /* As present, all attributes in the list are unknown, and
	     therefore can't be merged meaningfully.  */
	  err_bfd = obfd;
	  err_tag = out_list->tag;

	  /*  Only pass on attributes that match in both inputs.  */
	  if (in_list->attr.i != out_list->attr.i
	      || in_list->attr.s != out_list->attr.s
	      || (in_list->attr.s && out_list->attr.s
		  && strcmp (in_list->attr.s, out_list->attr.s) != 0))
	    {
	      /* No match.  Delete the attribute.  */
	      *out_listp = out_list->next;
	      out_list = *out_listp;
	    }
	  else
	    {
	      /* Matched.  Keep the attribute and move to the next.  */
	      out_list = out_list->next;
	      in_list = in_list->next;
	    }
	}
a10425 19
      if (err_bfd)
	{
	  /* Attribute numbers >=64 (mod 128) can be safely ignored.  */
	  if ((err_tag & 127) < 64)
	    {
	      _bfd_error_handler
		(_("%B: Unknown mandatory EABI object attribute %d"),
		 err_bfd, err_tag);
	      bfd_set_error (bfd_error_bad_value);
	      result = FALSE;
	    }
	  else
	    {
	      _bfd_error_handler
		(_("Warning: %B: Unknown EABI object attribute %d"),
		 err_bfd, err_tag);
	    }
	}
    }
d13898 1
@


1.246
log
@	* elf32-arm.c (find_stub_size_and_template): Avoid uninitialized
	var warning at -O3.
@
text
@d9035 2
a9036 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.245
log
@	* elf32-arm.c (elf32_arm_final_link_relocate)
	(elf32_arm_relocate_section): Handle relocations against STN_UNDEF.
@
text
@d3707 3
d3711 2
d3731 1
a3731 1
	  return FALSE;
a3734 6
  if (stub_template)
    *stub_template = template_sequence;

  if (stub_template_size)
    *stub_template_size = template_size;

@


1.244
log
@	bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_any_arm_pic,
	elf32_arm_stub_long_branch_any_arm_pic): Use a consistent name for
	ip/r12.
	(arm_type_of_stub): Remove superfluous braces.

	gas/
	* config/tc-arm.c (encode_branch): Remove superfluous braces.
	(do_t_branch): Move reloc setting to end of routine.
@
text
@d7232 1
a7232 1
	     Do the same for local undefined symbols.
d7237 1
a7237 1
	      : bfd_is_und_section (sym_sec))
d8911 2
a8912 1
	     allowed to use the undefined symbol, so allow those.  */
d8915 1
@


1.243
log
@2010-10-01  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c (elf32_arm_size_stubs): Don't choke on local symbols in
	SHN_UNDEF, SHN_ABS, SHN_COMMON.
@
text
@d2109 1
a2109 1
    ARM_INSN(0xe59fc000),             /* ldr   r12, [pc] */
d2120 1
a2120 1
    ARM_INSN(0xe59fc004),             /* ldr   r12, [pc, #4] */
d3272 1
a3272 3
    {
      *actual_st_type = st_type;
    }
@


1.242
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@a4488 1
		      Elf_Internal_Shdr *hdr;
d4504 10
a4513 2
		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
		      sym_sec = hdr->bfd_section;
@


1.241
log
@	* elf32-arm.c (elf32_arm_final_link): Process stub sections
	exactly once.
@
text
@d9066 1
a9066 1
      if (r_symndx != 0
d10905 1
a10905 1
	  && (r_symndx > 0 || nsyms > 0))
@


1.240
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d9446 12
a9457 8
  for(i=0; i<htab->top_id; i++) {
    sec = htab->stub_group[i].stub_sec;
    if (sec) {
      osec = sec->output_section;
      elf32_arm_write_section (abfd, info, sec, sec->contents);
      if (! bfd_set_section_contents (abfd, osec, sec->contents,
				      sec->output_offset, sec->size))
	return FALSE;
a9458 1
  }
@


1.239
log
@    bfd/
    * elf32-arm.c (arm_stub_required_alignment): New.
    (arm_build_one_stub): Use above to partition stubs.
    (make_branch_to_a8_stub): Use arm_stub_a8_veneer_lwm not
    arm_stub_a8_veneer_b_cond.

    ld/testsuite/
    * ld-arm/arm-elf.exp (armelftests): Add cortex-a8-fix-blx-bcond.s.
    * ld-arm/cortex-a8-fix-blx-bcond.s: New.
    * ld-arm/cortex-a8-fix-blx-bcond.d: New.
@
text
@d13903 1
@


1.238
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d3478 30
d3539 2
a3540 3
      != (stub_entry->stub_type >= arm_stub_a8_veneer_lwm))
    /* We have to do the a8 fixes last, as they are less aligned than
       the other veneers.  */
d13388 1
a13388 1
      || stub_entry->stub_type < arm_stub_a8_veneer_b_cond)
@


1.237
log
@fix set but unused variable warnings
@
text
@d1832 1
a1832 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.236
log
@	* elf-bfd.h (LEAST_KNOWN_OBJ_ATTRIBUTE): Define.
	(struct elf_backend_data): Update comment on obj_attrs_order.
	* elf-attrs.c (vendor_obj_attr_size, vendor_set_obj_attr_contents,
	_bfd_elf_copy_obj_attributes): Use LEAST_KNOWN_OBJ_ATTRIBUTE
	instead of hardcoded 4.
	* elf32-arm.c (elf32_arm_obj_attrs_order): Use
	LEAST_KNOWN_OBJ_ATTRIBUTE and LEAST_KNOWN_OBJ_ATTRIBUTE + 1
	instead of hardcoded 4 and 5.
	(elf32_arm_merge_eabi_attributes): Use LEAST_KNOWN_OBJ_ATTRIBUTE
	instead of hardcoded 4.
@
text
@a3487 1
  bfd_vma stub_addr;
a3519 4
  /* This is the address of the start of the stub.  */
  stub_addr = stub_sec->output_section->vma + stub_sec->output_offset
    + stub_entry->stub_offset;

d3717 1
a3717 1
		   void * in_arg)
a3719 1
  struct elf32_arm_link_hash_table *htab;
a3724 1
  htab = (struct elf32_arm_link_hash_table *) in_arg;
a5239 1
  int errcount;
d5277 1
a5277 1
  errcount = ++(sec_data->erratumcount);
a6132 1
                  int errcount;
d6134 1
a6134 1
                  errcount = ++(elf32_arm_section_data (sec)->erratumcount);
a6845 2
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
a6883 2
  symtab_hdr = & elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
a10827 1
  bfd_vma *local_got_offsets;
a10852 2
  local_got_offsets = elf_local_got_offsets (abfd);

a12994 1
  struct bfd_link_info *info;
a13008 2
  info = osi->info;

@


1.235
log
@2010-05-10  Andrew Stubbs  <ams@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set Tag_DIV_use.

        gas/testsuite/
        * gas/arm/attr-cpu-directive.d: Add Tag_DIV_use.
        * gas/arm/attr-default.d: Likewise.
        * gas/arm/attr-march-armv1.d: Likewise.
        * gas/arm/attr-march-armv2.d: Likewise.
        * gas/arm/attr-march-armv2a.d: Likewise.
        * gas/arm/attr-march-armv2s.d: Likewise.
        * gas/arm/attr-march-armv3.d: Likewise.
        * gas/arm/attr-march-armv3m.d: Likewise.
        * gas/arm/attr-march-armv4.d: Likewise.
        * gas/arm/attr-march-armv4t.d: Likewise.
        * gas/arm/attr-march-armv4txm.d: Likewise.
        * gas/arm/attr-march-armv4xm.d: Likewise.
        * gas/arm/attr-march-armv5.d: Likewise.
        * gas/arm/attr-march-armv5t.d: Likewise.
        * gas/arm/attr-march-armv5te.d: Likewise.
        * gas/arm/attr-march-armv5tej.d: Likewise.
        * gas/arm/attr-march-armv5texp.d: Likewise.
        * gas/arm/attr-march-armv5txm.d: Likewise.
        * gas/arm/attr-march-armv6-m.d: Likewise.
        * gas/arm/attr-march-armv6.d: Likewise.
        * gas/arm/attr-march-armv6j.d: Likewise.
        * gas/arm/attr-march-armv6k.d: Likewise.
        * gas/arm/attr-march-armv6kt2.d: Likewise.
        * gas/arm/attr-march-armv6t2.d: Likewise.
        * gas/arm/attr-march-armv6z.d: Likewise.
        * gas/arm/attr-march-armv6zk.d: Likewise.
        * gas/arm/attr-march-armv6zkt2.d: Likewise.
        * gas/arm/attr-march-armv6zt2.d: Likewise.
        * gas/arm/attr-march-armv7-a.d: Likewise.
        * gas/arm/attr-march-armv7.d: Likewise.
        * gas/arm/attr-march-armv7a.d: Likewise.
        * gas/arm/attr-march-iwmmxt.d: Likewise.
        * gas/arm/attr-march-iwmmxt2.d: Likewise.
        * gas/arm/attr-march-marvell-f.d: Likewise.
        * gas/arm/attr-march-xscale.d: Likewise.
        * gas/arm/attr-mcpu.d: Likewise.
        * gas/arm/attr-mfpu-arm1020e.d: Likewise.
        * gas/arm/attr-mfpu-arm1020t.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
        * gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
        * gas/arm/attr-mfpu-arm7500fe.d: Likewise.
        * gas/arm/attr-mfpu-fpa.d: Likewise.
        * gas/arm/attr-mfpu-fpa10.d: Likewise.
        * gas/arm/attr-mfpu-fpa11.d: Likewise.
        * gas/arm/attr-mfpu-fpe.d: Likewise.
        * gas/arm/attr-mfpu-fpe2.d: Likewise.
        * gas/arm/attr-mfpu-fpe3.d: Likewise.
        * gas/arm/attr-mfpu-maverick.d: Likewise.
        * gas/arm/attr-mfpu-neon-fp16.d: Likewise.
        * gas/arm/attr-mfpu-neon.d: Likewise.
        * gas/arm/attr-mfpu-softfpa.d: Likewise.
        * gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
        * gas/arm/attr-mfpu-softvfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp.d: Likewise.
        * gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
        * gas/arm/attr-mfpu-vfp10.d: Likewise.
        * gas/arm/attr-mfpu-vfp3.d: Likewise.
        * gas/arm/attr-mfpu-vfp9.d: Likewise.
        * gas/arm/attr-mfpu-vfpv2.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv3.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
        * gas/arm/attr-mfpu-vfpv4.d: Likewise.
        * gas/arm/attr-mfpu-vfpxd.d: Likewise.
        * gas/arm/attr-order.d: Likewise.
        * gas/arm/attr-override-cpu-directive.d: Likewise.
        * gas/arm/attr-override-mcpu.d: Likewise.
        * gas/arm/eabi_attr_1.d: Likewise.

        ld/testsuite/
        * ld-arm/attr-merge-2.attr: Add Tag_DIV_use.
        * ld-arm/attr-merge-2a.s: Likewise.
        * ld-arm/attr-merge-2b.s: Likewise.
        * ld-arm/attr-merge-3a.s: Likewise.
        * ld-arm/attr-merge-3b.s: Likewise.
        * ld-arm/attr-merge-4.attr: Likewise.
        * ld-arm/attr-merge-5.attr: Likewise.
        * ld-arm/attr-merge-6.attr: Likewise.
        * ld-arm/attr-merge-7.attr: Likewise.
        * ld-arm/attr-merge-arch-1.attr: Likewise.
        * ld-arm/attr-merge-arch-2.attr: Likewise.
        * ld-arm/attr-merge-unknown-2.d: Likewise.
        * ld-arm/attr-merge-unknown-2r.d: Likewise.
        * ld-arm/attr-merge-unknown-3.d: Likewise.
        * ld-arm/attr-merge-vfp-1.d: Likewise.
        * ld-arm/attr-merge-vfp-1r.d: Likewise.
        * ld-arm/attr-merge-vfp-2.d: Likewise.
        * ld-arm/attr-merge-vfp-2r.d: Likewise.
        * ld-arm/attr-merge-vfp-3.d: Likewise.
        * ld-arm/attr-merge-vfp-3r.d: Likewise.
        * ld-arm/attr-merge-vfp-4.d: Likewise.
        * ld-arm/attr-merge-vfp-4r.d: Likewise.
        * ld-arm/attr-merge-vfp-5.d: Likewise.
        * ld-arm/attr-merge-vfp-5r.d: Likewise.
        * ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-00.d: Likewise.
        * ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-02.d: Likewise.
        * ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-04.d: Likewise.
        * ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-20.d: Likewise.
        * ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-22.d: Likewise.
        * ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-40.d: Likewise.
        * ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
        * ld-arm/attr-merge-wchar-44.d: Likewise.
        * ld-arm/attr-merge.attr: Likewise.

2010-04-07  Jie Zhang  <jie@@codesourcery.com>

        gas/
        * config/tc-arm.c (aeabi_set_public_attributes): Set
        Tag_ABI_HardFP_use to 1 if a single precision FPU is selected.

        gas/testsuite/
        * gas/arm/attr-mfpu-vfpxd.d: New test.

        bfd/
        * elf32-arm.c (elf32_arm_merge_eabi_attributes): Merge
        Tag_ABI_HardFP_use correctly.

        ld/testsuite/
        * ld-arm/attr-merge-vfp-6.d: New test.
        * ld-arm/attr-merge-vfp-6r.d: New test.
        * ld-arm/attr-merge-vfpv3xd.s: New test.
        * ld-arm/arm-elf.exp: Add attr-merge-vfp-6 and attr-merge-vfp-6r.

2010-05-11  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>

        * arm-dis.c (thumb_opcodes): Update ldmia entry to use new %W
        format.
        (print_insn_thumb16): Add support for new %W format.

        * gas/arm/thumb32.d: Fix expected disassembly of ldmia
          instruction.
@
text
@d9627 1
a9627 1
  if (num == 4)
d9629 1
a9629 1
  if (num == 5)
d9935 1
a9935 1
  for (i = 4; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
@


1.234
log
@	bfd/
	* elf32-arm.c (struct a8_erratum_reloc): Add hash member.  Move
	sym_name to improve packing.
	(cortex_a8_erratum_scan): Check for PLT entries.
	(elf32_arm_size_stubs): Save the target symbol for a8 relocs.

	ld/testsuite/
	* ld-arm/cortex-a8-fix-bl-rel-plt.d: New file.
	* ld-arm/arm-elf.exp (armelftests): Run cortex-a8-fix-bl-rel-plt.d.
@
text
@d10109 5
d10132 34
d10286 1
a10286 6
	  /* 1 (SP) and 2 (DP) conflict, so combine to 3 (SP & DP).  */
	  if ((in_attr[i].i == 1 && out_attr[i].i == 2)
	      || (in_attr[i].i == 2 && out_attr[i].i == 1))
	    out_attr[i].i = 3;
	  else if (in_attr[i].i > out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
@


1.233
log
@2010-04-15  Andrew Haley  <aph@@redhat.com>

	* emultempl/armelf.em (merge_exidx_entries): New variable.
	(OPTION_NO_MERGE_EXIDX_ENTRIES): New definition.
	("no-merge-exidx-entries"): New option.
	* ld.texinfo (merge-exidx-entries): Document this option.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add new flag:
	merge_exidx_entries.
	* bfd-in2.h: Likewise.
	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Likewise.  Use it to
	control merging of exidx entries.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* options.h (merge_exidx_entries): New option.
	* arm.cc (class Arm_exidx_fixup): Add new arg, merge_exidx_entries.
	(class Arm_exidx_fixup::merge_exidx_entries_): New member.
	(Output_section::fix_exidx_coverage): Add new arg, merge_exidx_entries.
	(Target_arm::merge_exidx_entries): New function.
	(process_exidx_entry): Don't merge if merge_exidx_entries_ is false.
	(Arm_output_section::fix_exidx_coverage): Pass merge_exidx_entries
	to Arm_exidx_fixup constructor.
	Add new arg, merge_exidx_entries.
	(Target_arm::fix_exidx_coverage): pass merge_exidx_entries to
	Arm_output_section::fix_exidx_coverage.
@
text
@d2412 2
a2415 1
  const char *sym_name;
d4105 1
d4115 12
a4126 6
		      if (found->r_type == R_ARM_THM_CALL
			  && found->st_type != STT_ARM_TFUNC)
			force_target_arm = TRUE;
		      else if (found->r_type == R_ARM_THM_CALL
			       && found->st_type == STT_ARM_TFUNC)
			force_target_thumb = TRUE;
d4693 1
@


1.232
log
@	* ld/testsuite/ld-arm/attr-merge-2.attr: Update for changes in attribute output.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likeiwse.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge.attr: Likewise.
	* binutils/readelf.c (arm_attr_tag_FP_arch): Rename from arm_attr_tag_VFP_arch.
	(arm_attr_tag_ABI_align8_needed): Remove.
	(arm_attr_tag_ABI_align8_preserved): Remove.
	(arm_attr_tag_ABI_HardFP_use): Update text strings.
	(arm_attr_public_tags): Add strings for ABI v2.08 attribute tags.
	(display_arm_attribute): Add decoding of ABI v2.08 attributes.
	* include/elf/arm.h (Tag_FP_arch, Tag_ABI_align_needed, Tag_ABI_align_preserved,
	Tag_FP_HP_extension): Add new ABI attribute tags.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute): Add support for
	new tag names in v2.08 of ARM ABI.
	* gas/doc/c-arm.texi: Document new tag names in ABI.
	* gas/testsuite/gas/arm/attr-mcpu.d: Update for new attribute tag names.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/testsuite/gas/arm/attr-names.d: Add test to make sure all attribute names
	are recognised.
	* gas/testsuite/gas/arm/attr-names.s: Likewise.
@
text
@d9218 2
d9227 2
a9228 1
			      struct bfd_link_info *info)
d9340 2
a9341 1
	      if (last_second_word == second_word && last_unwind_type == 1)
@


1.231
log
@	bfd/
	* elf32-arm.c (using_thumb_only): Handle v6-M.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armeabitests): Add v6-M farcall test.
@
text
@d10006 1
a10006 1
	case Tag_VFP_HP_extension:
a10008 1
	case Tag_Virtualization_use:
d10015 1
a10015 1
	case Tag_ABI_align8_preserved:
d10022 1
a10022 1
	case Tag_ABI_align8_needed:
d10024 2
a10025 2
	      && (in_attr[Tag_ABI_align8_preserved].i == 0
		  || out_attr[Tag_ABI_align8_preserved].i == 0))
d10046 21
d10094 1
a10094 1
	case Tag_VFP_arch:
@


1.230
log
@	* elf32-arm.c (struct section_list): Remove.
	(section_list): Remove typedef.
	(record_section_with_arm_elf_section_data): Remove.
	(find_arm_elf_section_entry): Remove.
	(get_arm_elf_section_data): Use is_arm_elf.
	(unrecord_section_with_arm_elf_section_data): Remove.
	(elf32_arm_new_section_hook): Don't call
	record_section_with_arm_elf_section_data.
	(elf32_arm_write_section): Set mapcount to -1 when
	the map has been used. Don't call
	unrecord_section_with_arm_elf_section_data.
	(unrecord_section_via_map_over_sections): Remove.
	(elf32_arm_close_and_cleanup): Remove.
	(elf32_arm_bfd_free_cached_info): Remove.
	(bfd_elf32_close_and_cleanup): Don't define.
	(bfd_elf32_bfd_free_cached_info): Don't define.
@
text
@d2988 3
@


1.229
log
@bfd/
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * bfd-in2.h (enum bfd_reloc_code_real): New BFD_RELOC_GOT_PREL type.
       * elf32-arm.c (elf32_arm_reloc_map): BFD_RELOC_GOT_PREL to
       R_ARM_GOT_PREL map.
       * libbfd.h (bfd_reloc_code_real_names): BFD_RELOC_GOT_PREL name.
       * reloc.c (comments): Document the new relocation.

gas/
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * config/tc-arm.c (reloc_names): New relocation names.
       (md_apply_fix): New case for BFD_RELOC_ARM_GOT_PREL.
       (tc_gen_reloc): New case for BFD_RELOC_ARM_GOT_PREL.
       * doc/c-arm.texi (ARM-Relocations): Document the new relocation.

gas/testsuite
2010-03-15  Wei Guozhi  <carrot@@google.com>

       PR gas/11323
       * gas/arm/got_prel.s: New test case.
       * gas/arm/got_prel.d: Likewise.
@
text
@a12789 69
/* A structure used to record a list of sections, independently
   of the next and prev fields in the asection structure.  */
typedef struct section_list
{
  asection * sec;
  struct section_list * next;
  struct section_list * prev;
}
section_list;

/* Unfortunately we need to keep a list of sections for which
   an _arm_elf_section_data structure has been allocated.  This
   is because it is possible for functions like elf32_arm_write_section
   to be called on a section which has had an elf_data_structure
   allocated for it (and so the used_by_bfd field is valid) but
   for which the ARM extended version of this structure - the
   _arm_elf_section_data structure - has not been allocated.  */
static section_list * sections_with_arm_elf_section_data = NULL;

static void
record_section_with_arm_elf_section_data (asection * sec)
{
  struct section_list * entry;

  entry = (struct section_list *) bfd_malloc (sizeof (* entry));
  if (entry == NULL)
    return;
  entry->sec = sec;
  entry->next = sections_with_arm_elf_section_data;
  entry->prev = NULL;
  if (entry->next != NULL)
    entry->next->prev = entry;
  sections_with_arm_elf_section_data = entry;
}

static struct section_list *
find_arm_elf_section_entry (asection * sec)
{
  struct section_list * entry;
  static struct section_list * last_entry = NULL;

  /* This is a short cut for the typical case where the sections are added
     to the sections_with_arm_elf_section_data list in forward order and
     then looked up here in backwards order.  This makes a real difference
     to the ld-srec/sec64k.exp linker test.  */
  entry = sections_with_arm_elf_section_data;
  if (last_entry != NULL)
    {
      if (last_entry->sec == sec)
	entry = last_entry;
      else if (last_entry->next != NULL
	       && last_entry->next->sec == sec)
	entry = last_entry->next;
    }

  for (; entry; entry = entry->next)
    if (entry->sec == sec)
      break;

  if (entry)
    /* Record the entry prior to this one - it is the entry we are most
       likely to want to locate next time.  Also this way if we have been
       called from unrecord_section_with_arm_elf_section_data() we will not
       be caching a pointer that is about to be freed.  */
    last_entry = entry->prev;

  return entry;
}

d12793 2
a12794 6
  struct section_list * entry;

  entry = find_arm_elf_section_entry (sec);

  if (entry)
    return elf32_arm_section_data (entry->sec);
a12798 20
static void
unrecord_section_with_arm_elf_section_data (asection * sec)
{
  struct section_list * entry;

  entry = find_arm_elf_section_entry (sec);

  if (entry)
    {
      if (entry->prev != NULL)
	entry->prev->next = entry->next;
      if (entry->next != NULL)
	entry->next->prev = entry->prev;
      if (entry == sections_with_arm_elf_section_data)
	sections_with_arm_elf_section_data = entry->next;
      free (entry);
    }
}


a13222 2
  record_section_with_arm_elf_section_data (sec);

d13653 1
a13653 1
  arm_data->mapcount = 0;
a13655 1
  unrecord_section_with_arm_elf_section_data (sec);
a13659 30
static void
unrecord_section_via_map_over_sections (bfd * abfd ATTRIBUTE_UNUSED,
					asection * sec,
					void * ignore ATTRIBUTE_UNUSED)
{
  unrecord_section_with_arm_elf_section_data (sec);
}

static bfd_boolean
elf32_arm_close_and_cleanup (bfd * abfd)
{
  if (abfd->sections)
    bfd_map_over_sections (abfd,
			   unrecord_section_via_map_over_sections,
			   NULL);

  return _bfd_elf_close_and_cleanup (abfd);
}

static bfd_boolean
elf32_arm_bfd_free_cached_info (bfd * abfd)
{
  if (abfd->sections)
    bfd_map_over_sections (abfd,
			   unrecord_section_via_map_over_sections,
			   NULL);

  return _bfd_free_cached_info (abfd);
}

a13845 2
#define bfd_elf32_close_and_cleanup             elf32_arm_close_and_cleanup
#define bfd_elf32_bfd_free_cached_info          elf32_arm_bfd_free_cached_info
@


1.228
log
@warning fixes
@
text
@d1724 1
@


1.227
log
@	* elf32-arm.c (elf32_arm_output_arch_local_syms): Skip non-program
	sections.
@
text
@d4083 1
a4083 1
                  bfd_signed_vma offset;
@


1.226
log
@	* elf32-arm.c (elf32_arm_output_arch_local_syms): Do not add
	a mapping symbol to an empty section.
@
text
@d13175 2
@


1.225
log
@	* ld/testsuite/ld-arm/arm-merge-incompatible.d: New test.
	* ld/testsuite/ld-arm/arm-merge-incompatiblea.s: Likewise.
	* ld/testsuite/ld-arm/arm-merge-incompatibleb.s: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Run the new test.
	* bfd/elf32-arm.c (elf32_arm_merge_eabi_attributes): Add a check of the
	return value from the call to _bfd_elf_merge_object_attributes.
@
text
@d13178 2
a13179 1
		&& get_arm_elf_section_data (osi.sec)->mapcount == 0)
@


1.224
log
@2010-03-02  Christophe Lyon  <christophe.lyon@@st.com>
	Alan Modra  <amodra@@gmail.com>

	bfd/
	* elf32-arm.c (a8_erratum_fix): Add st_type field to record the
	destination mode of the a8 stub.
	(elf32_arm_link_hash_table): Add top_id field.
	(elf32_arm_link_hash_table_create): Initialize top_id.
	(arm_type_of_stub): Update prototype, st_type can now be updated
	by this function. Actual destination address in case of PLT is
	computed here, to help factorizing code.
	(elf32_arm_stub_name): Update prototype, use stub_type additional
	parameter to build stub name.
	(elf32_arm_get_stub_entry): Update prototype, use stub_type
	additional parameter to build stub entry.
	(arm_build_one_stub): Use bfd_put_16/bfd_put_32 instead of
	put_thumb_insn/put_arm_insn as BE8 encoding is now handled later.
	Call elf32_arm_final_link_relocate to process all in-stub
	relocations.
	(elf32_arm_setup_section_lists): Update top_id.
	(cortex_a8_erratum_scan): Record stub destination mode.
	(elf32_arm_size_stubs): Update call to arm_type_of_stub according
	to new prototype.
	(elf32_arm_final_link_relocate): Enable processing of in-stub
	REL32 relocations. Rely on arm_type_of_stub to detect if a stub is
	needed, enabling code factorization.
	(elf32_arm_final_link): Process stub sections.
	(elf32_arm_output_map_sym): Add entry to code/data map.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Change .text start address for
	farcall-thumb-arm tests. Add v4t variant for farcall-mixed-lib
	test.
	* ld-arm/farcall-mixed-lib-v4t.d: New test.
	* ld-arm/farcall-mixed-lib1.s: Don't force armv5t.
	* ld-arm/farcall-mixed-lib2.s: Likewise.
	* ld-arm/arm-call.d: Update expected results.
	* ld-arm/cortex-a8-far.d: Likewise.
	* ld-arm/farcall-group-size2.d: Likewise.
	* ld-arm/farcall-group.d: Likewise.
	* ld-arm/farcall-mix.d: Likewise.
	* ld-arm/farcall-mix2.d: Likewise.
	* ld-arm/farcall-mixed-app-v5.d: Likewise.
	* ld-arm/farcall-mixed-app.d: Likewise.
	* ld-arm/farcall-mixed-lib.d: Likewise.
	* ld-arm/farcall-thumb-arm.d: Likewise.
	* ld-arm/farcall-thumb-arm-blx.d: Likewise.
	* ld-arm/farcall-thumb-arm-pic-veneer.d: Likewise.
	* ld-arm/farcall-thumb-arm-blx-pic-veneer.d: Likewise.
	* ld-arm/farcall-thumb-arm.s: Update test. Add a new call to
	potentially generate different types of stubs.
@
text
@d10343 2
a10344 1
  _bfd_elf_merge_object_attributes (ibfd, obfd);
@


1.223
log
@	* bfd/elf32-arm.c (elf32_arm_merge_eabi_attributes): Add support for
	merging Tag_DIV_use, Tag_MPextension_use, and
	Tag_MPextension_use_legacy tags.
	* binutils/readelf.c (arm_attr_tag_Advanced_SIMD_arch): Add
	description of newly permitted attribute values.
	(arm_attr_tag_Virtualization_use): Likewise.
	(arm_attr_tag_DIV_use): Add description of new attribute.
	(arm_attr_tag_MPextension_use_legacy): Likewise.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute):
	Add Tag_DIV_use.
	* gas/doc/c-arm.texi: Likewise.
	* gas/testsuite/gas/arm/attr-order.d: Fix test for new names for
	attribute values.
	* include/elf/arm.h (Tag_MPextension_use): Renumber.
	(Tag_DIV_use): Add.
	(Tag_MPextension_use_legacy): Likewise.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Fix test for new attribute
	values.
	* ld/testsuite/ld-arm/attr-merge-3b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.d: Fix test now that 42
	is a recognised attribute ID.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6.attr: New test.
	* ld/testsuite/ld-arm/attr-merge-6a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7b.s: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Run the new tests.
@
text
@d2402 1
d2654 3
d2951 1
d3054 1
a3054 1
		  unsigned char st_type,
d3069 1
a3088 2
  branch_offset = (bfd_signed_vma)(destination - location);

d3092 3
a3094 1
  if (globals->splt != NULL && hash != NULL && hash->root.plt.offset != (bfd_vma) -1)
d3097 1
d3106 5
d3113 2
d3208 3
a3210 1
  else if (r_type == R_ARM_CALL || r_type == R_ARM_JUMP24 || r_type == R_ARM_PLT32)
d3265 6
d3280 2
a3281 1
		     const Elf_Internal_Rela *rel)
d3288 1
a3288 1
      len = 8 + 1 + strlen (hash->root.root.root.string) + 1 + 8 + 1;
d3291 1
a3291 1
	sprintf (stub_name, "%08x_%s+%x",
d3294 2
a3295 1
		 (int) rel->r_addend & 0xffffffff);
d3299 1
a3299 1
      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
d3302 1
a3302 1
	sprintf (stub_name, "%08x_%x:%x+%x",
d3306 2
a3307 1
		 (int) rel->r_addend & 0xffffffff);
d3321 2
a3322 1
			  struct elf32_arm_link_hash_table *htab)
d3340 2
a3341 1
      && h->stub_cache->id_sec == id_sec)
d3349 1
a3349 1
      stub_name = elf32_arm_stub_name (id_sec, sym_sec, h, rel);
d3509 1
a3509 1
  
d3544 1
a3544 1
	    put_thumb_insn (globals, stub_bfd, data, loc + size);
d3550 5
a3554 5
          put_thumb_insn (globals, stub_bfd,
                          (template_sequence[i].data >> 16) & 0xffff,
                          loc + size);
          put_thumb_insn (globals, stub_bfd, template_sequence[i].data & 0xffff,
                          loc + size + 2);
d3564 2
a3565 2
	  put_arm_insn (globals, stub_bfd, template_sequence[i].data,
                        loc + size);
d3644 17
a3660 5
	_bfd_final_link_relocate (elf32_arm_howto_from_type
	    (template_sequence[stub_reloc_idx[i]].r_type), stub_bfd, stub_sec,
	  stub_sec->contents, stub_entry->stub_offset + stub_reloc_offset[i],
	  sym_value + stub_entry->target_addend,
	  template_sequence[stub_reloc_idx[i]].reloc_addend);
d3787 1
d4076 1
a4076 1
			   
d4247 2
d4264 1
a4264 1
  
d4268 1
a4268 1
  
d4419 1
a4419 1
		  unsigned char st_type;
d4477 1
a4477 1
		  
d4571 1
a4571 1
						    st_type, hash,
d4582 1
a4582 1
						       irela);
d4782 1
a4782 1
          stub_entry->st_type = STT_ARM_TFUNC;
d6963 1
a7087 1
	  bfd_signed_vma branch_offset;
d7123 10
a7132 27
	      bfd_vma from;
	      
	      /* If the call goes through a PLT entry, make sure to
		 check distance to the right destination address.  */
	      if (h != NULL && splt != NULL && h->plt.offset != (bfd_vma) -1)
		{
		  value = (splt->output_section->vma
			   + splt->output_offset
			   + h->plt.offset);
		  *unresolved_reloc_p = FALSE;
		  /* The PLT entry is in ARM mode, regardless of the
		     target function.  */
		  sym_flags = STT_FUNC;
		}

	      from = (input_section->output_section->vma
		      + input_section->output_offset
		      + rel->r_offset);
	      branch_offset = (bfd_signed_vma)(value - from);

	      if (branch_offset > ARM_MAX_FWD_BRANCH_OFFSET
		  || branch_offset < ARM_MAX_BWD_BRANCH_OFFSET
		  || ((sym_flags == STT_ARM_TFUNC)
		      && (((r_type == R_ARM_CALL) && !globals->use_blx)
			  || (r_type == R_ARM_JUMP24)
			  || (r_type == R_ARM_PLT32) ))
		  )
d7139 2
a7140 1
							 rel, globals);
d7146 17
d7547 1
a7547 22
	/* Handle calls via the PLT.  */
	if (h != NULL && splt != NULL && h->plt.offset != (bfd_vma) -1)
	  {
	    value = (splt->output_section->vma
		     + splt->output_offset
		     + h->plt.offset);
 	    if (globals->use_blx && r_type == R_ARM_THM_CALL)
 	      {
 		/* If the Thumb BLX instruction is available, convert the
		   BL to a BLX instruction to call the ARM-mode PLT entry.  */
		lower_insn = (lower_insn & ~0x1000) | 0x0800;
		sym_flags = STT_FUNC;
 	      }
 	    else
	      {
		/* Target the Thumb stub before the ARM PLT entry.  */
		value -= PLT_THUMB_STUB_SIZE;
		sym_flags = STT_ARM_TFUNC;
	      }
	    *unresolved_reloc_p = FALSE;
	  }

d7552 10
a7561 19
	    bfd_vma from;
	    bfd_signed_vma branch_offset;
	    struct elf32_arm_stub_hash_entry *stub_entry = NULL;

	    from = (input_section->output_section->vma
		    + input_section->output_offset
		    + rel->r_offset);
	    branch_offset = (bfd_signed_vma)(value - from);

	    if ((!thumb2
		 && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
		     || (branch_offset < THM_MAX_BWD_BRANCH_OFFSET)))
		||
		(thumb2
		 && (branch_offset > THM2_MAX_FWD_BRANCH_OFFSET
		     || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET)))
		|| ((sym_flags != STT_ARM_TFUNC)
		    && (((r_type == R_ARM_THM_CALL) && !globals->use_blx)
			|| r_type == R_ARM_THM_JUMP24)))
d7568 2
a7569 1
						       rel, globals);
d7586 27
d9401 1
d9410 14
d12925 1
@


1.222
log
@2010-02-12  Daniel Gutson  <dgutson@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_output_arch_local_syms): add
	missing mapping symbol to data only sections.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): New test case added.
	* ld-arm/data-only-map.s: New file.
	* ld-arm/data-only-map.d: New file.
	* ld-arm/data-only-map.ld: New file.
@
text
@d9815 2
d9819 21
a9839 1
      elf_known_obj_attributes_proc (obfd)[0].i = 1;
d9841 1
a9841 1
      return TRUE;
d10176 46
@


1.221
log
@bfd/
	* elf32-ppc.c (ppc_elf_begin_write_processing): Allow empty
	apuinfo sections, only scan input sections once and reuse the
	buffer.
ld/testsuite/
	* ld-powerpc/apuinfo-nul.s: New.
	* ld-powerpc/apuinfo.rd: Add it.
	* ld-powerpc/powerpc.exp: Likewise.
@
text
@d13007 3
a13009 1
/* Output mapping symbols for linker generated sections.  */
d13024 1
d13036 26
@


1.220
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d9834 2
a9835 1
	     ibfd, obfd);
@


1.219
log
@	* elf32-arm.c (elf32_arm_howto_table_1): Correct bitsize of
	R_ARM_THM_CALL entry.
	(elf32_arm_final_link_relocate): Correct calculation of
	reloc_signed_max when doing a R_ARM_THM_CALL, R_ARM_THM_XPC22,
	or R_ARM_THM_JUMP24 relocation.
@
text
@d2442 1
a2442 1
   && elf_object_id (bfd) == ARM_ELF_TDATA)
d2448 1
a2448 1
				  ARM_ELF_TDATA);
d2518 2
a2519 1
  ((struct elf32_arm_link_hash_table *) ((info)->hash))
d2748 3
d2780 3
d2901 2
a2902 1
				      sizeof (struct elf32_arm_link_hash_entry)))
d3071 2
d3452 1
a3453 1
  struct elf32_arm_link_hash_table *htab;
a3462 1
  struct elf32_arm_link_hash_table * globals;
d3472 2
a3474 1
  htab = elf32_arm_hash_table (info);
d3477 1
a3477 1
  if ((htab->fix_cortex_a8 < 0)
d3723 2
d3796 3
d3958 3
d4252 3
d4474 3
a4476 1
			  if (globals->splt != NULL && hash != NULL
d4501 3
a4503 1
			  if (globals->splt != NULL && hash != NULL
d4781 2
d4828 2
d4864 2
a5027 1

a5099 1

a5195 1

a5359 1

a5398 1

d5599 3
d5621 2
d5926 3
d6152 2
d6236 2
a6312 1

a6409 1

a6504 1

a6558 1

a6593 1

d6631 3
d6811 2
d6916 1
a6916 1
	  && !(elf32_arm_hash_table (info)->vxworks_p
d8788 2
d9361 3
d10511 2
d10559 1
a10559 1
	  elf32_arm_hash_table (info)->tls_ldm_got.refcount -= 1;
d10655 3
d11180 3
d11321 2
d11552 1
a11552 1
      if (elf32_arm_hash_table (info)->vxworks_p)
d11673 3
d11693 3
d11722 1
a11722 1
      bfd_boolean is_vxworks = elf32_arm_hash_table (info)->vxworks_p;
d11970 3
d12263 5
d12272 1
a12272 1
  BFD_ASSERT (elf32_arm_hash_table (info)->symbian_p || sgot != NULL);
a12278 1
      struct elf32_arm_link_hash_table *htab;
a12279 1
      htab = elf32_arm_hash_table (info);
d12438 1
a12438 1
      if (splt->size > 0 && elf32_arm_hash_table (info)->plt_header_size)
d12565 1
a12565 1
      if (globals->byteswap_code)
a12790 1
  struct elf32_arm_link_hash_table *htab;
a12792 1
  htab = elf32_arm_hash_table (osi->info);
a12813 2
  htab = elf32_arm_hash_table (osi->info);

d12826 4
a12888 1
  struct elf32_arm_link_hash_table *htab;
a12890 1
  htab = elf32_arm_hash_table (osi->info);
a12906 1
  struct elf32_arm_link_hash_table *htab;
a12922 1
  htab = elf32_arm_hash_table (info);
d13023 3
d13349 3
@


1.218
log
@        bfd/
        * elf32-arm.c (elf32_arm_final_link_relocate): limits
        fixed.

        ld/testsuite/
        * ld-arm/arm-elf.exp (armelftests): New test case added.
        * ld-arm/reloc-boundaries.s: New file.
        * ld-arm/reloc-boundaries.d: New file.
@
text
@d3 1
a3 1
   2008, 2009  Free Software Foundation, Inc.
d225 1
a225 1
	 25,			/* bitsize */
d7555 1
a7555 1
	reloc_signed_max = ((1 << (bitsize - 1)) - 1) >> howto->rightshift;
@


1.217
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d7215 5
a7219 1
      if ((long) value > 0x7f || (long) value < -0x80)
d7228 2
a7229 1
      if ((long) value > 0x7fff || (long) value < -0x8000)
@


1.216
log
@	bfd/
	* elf32-arm.c (elf32_arm_next_input_section): Skip sections without
	SEC_CODE.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armeabitests): Add farcall-data.
	* ld-arm/farcall-data.d, ld-arm/farcall-data.s: New.
	* lib/ld-lib.exp (run_ld_link_tests, run_cc_link_tests): Correct
	regular expression for archives.
@
text
@d5696 1
a5696 1
  enum bfd_arm_vfp11_pipe pipe = VFP11_BAD;
d5715 1
a5715 1
          pipe = VFP11_FMAC;
d5727 1
a5727 1
          pipe = VFP11_FMAC;
d5731 1
a5731 1
          pipe = VFP11_DS;
d5761 1
a5761 1
                pipe = VFP11_FMAC;
d5768 1
a5768 1
                pipe = VFP11_DS;
d5783 1
a5783 1
                  pipe = VFP11_FMAC;
d5813 1
a5813 1
      pipe = VFP11_LS;
d5848 1
a5848 1
      pipe = VFP11_LS;
d5870 1
a5870 1
      pipe = VFP11_LS;
d5873 1
a5873 1
  return pipe;
d5993 1
a5993 1
              enum bfd_arm_vfp11_pipe pipe;
d5998 1
a5998 1
                  pipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
d6003 1
a6003 1
                  if (pipe == VFP11_FMAC || pipe == VFP11_DS)
d6014 1
a6014 1
                    pipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6017 1
a6017 1
                    if (pipe != VFP11_BAD
d6029 1
a6029 1
                    pipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
d6032 1
a6032 1
                    if (pipe != VFP11_BAD
d9047 1
a9047 1
/* Add a new unwind edit to the list described by HEAD, TAIL.  If INDEX is zero,
d9049 1
a9049 1
   ascending INDEX: the function's callers are primarily responsible for
d9057 1
a9057 1
		       unsigned int index)
d9064 1
a9064 1
  new_edit->index = index;
d9066 1
a9066 1
  if (index > 0)
d9176 1
a9176 2
     and add EXIDX_CANTUNWIND entries for sections with no unwind table data.
   */
d13168 1
a13168 1
  unsigned int index;
d13193 1
a13193 1
  index = stub_entry->target_value;
d13254 2
a13255 2
  bfd_put_16 (abfd, (branch_insn >> 16) & 0xffff, &contents[index]);
  bfd_put_16 (abfd, branch_insn & 0xffff, &contents[index + 2]);
d13297 1
a13297 1
          bfd_vma index = errnode->vma - offset;
d13310 1
a13310 1
		index -= 4;
d13322 4
a13325 4
                contents[endianflip ^ index] = insn & 0xff;
                contents[endianflip ^ (index + 1)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (index + 2)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (index + 3)] = (insn >> 24) & 0xff;
d13345 4
a13348 4
                contents[endianflip ^ index] = insn & 0xff;
                contents[endianflip ^ (index + 1)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (index + 2)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (index + 3)] = (insn >> 24) & 0xff;
d13352 4
a13355 4
                contents[endianflip ^ (index + 4)] = insn & 0xff;
                contents[endianflip ^ (index + 5)] = (insn >> 8) & 0xff;
                contents[endianflip ^ (index + 6)] = (insn >> 16) & 0xff;
                contents[endianflip ^ (index + 7)] = (insn >> 24) & 0xff;
@


1.215
log
@2009-11-17  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	gas/
	* doc/c-arm.texi: Document .arch armv7e-m.
	* config/tc-arm.c (arm_ext_v6_dsp, arm_ext_v7m): New.
	(insns): Put Thumb versions of v5TExP instructions into
	arm_ext_v5exp also.  Move some Thumb variants from
	arm_ext_v6_notm to arm_ext_v6_dsp.
	(arm_archs): Add armv7e-m architecture.
	(aeabi_set_public_attributes): Handle -march=armv7e-m.

	gas/testsuite/
	* gas/arm/attr-march-armv7em.d: New test.
	* gas/arm/arch7em-bad.d: New test.
	* gas/arm/arch7em-bad.l: New test.
	* gas/arm/arch7em.d: New test.
	* gas/arm/arch7em.s: New test.

	include/elf/
	* arm.h (TAG_CPU_ARCH_V7E_M): Define.

	include/opcode/
	* arm.h (ARM_EXT_V6_DSP): Define.
	(ARM_AEXT_V6T2, ARM_AEXT_NOTM): Include ARM_EXT_V6_DSP.
	(ARM_AEXT_V7EM, ARM_ARCH_V7EM): Define.

	binutils/
	* readelf.c (arm_attr_tag_CPU_arch): Add v7E-M.

	bfd/
	* elf32-arm.c (using_thumb_only, arch_has_arm_nop,
	arch_has_thumb2_nop): Handle TAG_CPU_ARCH_V7E_M.
	(tag_cpu_arch_combine): Ditto. Correct MAX_TAG_CPU_ARCH test.
@
text
@d3788 1
a3788 1
      if (*list != bfd_abs_section_ptr)
@


1.214
log
@2009-11-02  Paul Brook  <paul@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new attr-merge-vfp tests.
	* ld-arm/attr-merge-vfp-1.d: New test.
	* ld-arm/attr-merge-vfp-1r.d: New test.
	* ld-arm/attr-merge-vfp-2.d: New test.
	* ld-arm/attr-merge-vfp-2r.d: New test.
	* ld-arm/attr-merge-vfp-3.d: New test.
	* ld-arm/attr-merge-vfp-3r.d: New test.
	* ld-arm/attr-merge-vfp-4.d: New test.
	* ld-arm/attr-merge-vfp-4r.d: New test.
	* ld-arm/attr-merge-vfp-5.d: New test.
	* ld-arm/attr-merge-vfp-5r.d: New test.
	* ld-arm/attr-merge-vfp-2.s: New test.
	* ld-arm/attr-merge-vfp-3.s: New test.
	* ld-arm/attr-merge-vfp-3-d16.s: New test.
	* ld-arm/attr-merge-vfp-4.s: New test.
	* ld-arm/attr-merge-vfp-4-d16.s: New test.

	gas/
	* doc/c-arm.texi: Document new -mfpu options.
	* config/tc-arm.c (fpu_vfp_ext_v3xd, fpu_vfp_fp16, fpu_neon_ext_fma,
	fpu_vfp_ext_fma): New.
	(NEON_ENC_TAB): Add vfma, vfms, vfnma and vfnms.
	(do_vfp_nsyn_fma_fms, do_neon_fmac): New functions.
	(insns): Move double precision load/store.  Split out double
	precision VFPv3 instrucitons.  Add VFPv4 instructions.
	(arm_fpus): Add VFPv3-FP16, VFPv3xD and VFPv4 variants.
	(aeabi_set_public_attributes): Set VFPv4 variants

	gas/testsuite/
	* gas/arm/attr-mfpu-vfpv4.d: New test.
	* gas/arm/attr-mfpu-vfpv4-d16.d: New test.
	* gas/arm/neon-fma-cov.d: New test.
	* gas/arm/neon-fma-cov.s: New test.
	* gas/arm/vfp-fma-inc.s: New test.
	* gas/arm/vfp-fma-arm.d: New test.
	* gas/arm/vfp-fma-arm.s: New test.
	* gas/arm/vfp-fma-thumb.d: New test.
	* gas/arm/vfp-fma-thumb.s: New test.
	* gas/arm/vfma1.d: New test.
	* gas/arm/vfma1.s: New test.
	* gas/arm/vfpv3xd.d: New test.
	* gas/arm/vfpv3xd.s: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_V3xD, FPU_VFP_EXT_FP16, FPU_NEON_EXT_FMA,
	FPU_VFP_EXT_FMA, FPU_VFP_V3xD, FPU_VFP_V4D16, FPU_VFP_V4): Define.
	(FPU_ARCH_VFP_V3D16_FP16, FPU_ARCH_VFP_V3_FP16, FPU_ARCH_VFP_V3xD,
	FPU_ARCH_VFP_V3xD_FP16, FPU_ARCH_VFP_V4, FPU_ARCH_VFP_V4D16,
	FPU_ARCH_NEON_VFP_V4): Define.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add VFPv4 and VFPv4-D16.

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle VFPv4
	attributes.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Update to use new feature flags.
	Add VFPv4 instructions.
@
text
@d2974 1
a2974 1
  if (arch != TAG_CPU_ARCH_V7)
d3002 2
a3003 1
	 || arch == TAG_CPU_ARCH_V7;
d3011 2
a3012 1
  return arch == TAG_CPU_ARCH_V6T2 || arch == TAG_CPU_ARCH_V7;
d9642 17
d9674 1
d9684 1
d9691 1
a9691 1
  if (oldtag >= MAX_TAG_CPU_ARCH || newtag >= MAX_TAG_CPU_ARCH)
@


1.213
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@a9732 2
  /* For use with Tag_VFP_arch.  */
  static const int order_01243[5] = {0, 1, 2, 4, 3};
d9924 44
a9967 6
	  /* Use the "greatest" from the sequence 0, 1, 2, 4, 3, or the
	     largest value if greater than 4 (for future-proofing).  */
	  if ((in_attr[i].i > 4 && in_attr[i].i > out_attr[i].i)
	      || (in_attr[i].i <= 4 && out_attr[i].i <= 4
		  && order_01243[in_attr[i].i] > order_01243[out_attr[i].i]))
	    out_attr[i].i = in_attr[i].i;
@


1.212
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set sym_flags
	for the mode of target PLT entries.
	(allocate_dynrelocs): Only adjust symbol type if setting its
	value.

	ld/testsuite/
	* ld-arm/farcall-mixed-lib.d: Update.
@
text
@a63 2
static struct elf_backend_data elf32_arm_vxworks_bed;

d2524 11
d2650 1
a2650 8
  struct map_stub
  {
    /* This is the section to which stubs in the group will be
       attached.  */
    asection *link_sec;
    /* The stub section.  */
    asection *stub_sec;
  } *stub_group;
d2671 2
a2672 1
    ret = bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
d2706 2
a2707 2
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf32_arm_stub_hash_entry));
d2888 1
a2888 1
  ret = bfd_malloc (amt);
d3254 1
a3254 1
      stub_name = bfd_malloc (len);
d3264 1
a3264 1
      stub_name = bfd_malloc (len);
d3349 1
a3349 1
	  s_name = bfd_alloc (htab->stub_bfd, len);
d3731 1
a3731 1
  htab->stub_group = bfd_zmalloc (amt);
d3748 1
a3748 1
  input_list = bfd_malloc (amt);
d3905 2
a3906 1
  const struct a8_erratum_reloc *ra = a, *rb = b;
d4031 4
a4034 3
                  found = bsearch (&key, a8_relocs, num_a8_relocs,
                                   sizeof (struct a8_erratum_reloc),
                                   &a8_reloc_compare);
d4151 4
a4154 3
                              a8_fixes = bfd_realloc (a8_fixes,
                                sizeof (struct a8_erratum_fix)
                                * a8_fix_table_size);
d4175 1
a4175 1
			      stub_name = bfd_malloc (8 + 1 + 8 + 1);
d4234 4
a4237 4
      a8_fixes = bfd_zmalloc (sizeof (struct a8_erratum_fix)
                              * a8_fix_table_size);
      a8_relocs = bfd_zmalloc (sizeof (struct a8_erratum_reloc)
                               * a8_reloc_table_size);
d4548 2
a4549 2
                      stub_entry->output_name
                	= bfd_alloc (htab->stub_bfd,
d4600 4
a4603 3
                              a8_relocs = bfd_realloc (a8_relocs,
                                sizeof (struct a8_erratum_reloc)
                                * a8_reloc_table_size);
d4767 1
a4767 1
      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
d4800 2
a4801 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
d4834 2
a4835 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d4945 1
a4945 1
  contents = bfd_alloc (abfd, size);
d5004 2
a5005 1
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name) + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
d5082 2
a5083 1
  tmp_name = bfd_malloc ((bfd_size_type) strlen (ARM_BX_GLUE_ENTRY_NAME) + 1);
d5120 2
a5121 1
      sec_data->map = bfd_malloc (sizeof (elf32_arm_section_map));
d5131 3
a5133 2
      sec_data->map = bfd_realloc_or_free (sec_data->map, sec_data->mapsize
					   * sizeof (elf32_arm_section_map));
d5176 2
a5177 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen
			 (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d5201 2
a5202 1
  newerr = bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
d6048 2
a6049 2
                  elf32_vfp11_erratum_list *newerr
                    = bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
d6117 2
a6118 2
  tmp_name = bfd_malloc ((bfd_size_type) strlen
			   (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
d8107 1
a8107 1
	  return FALSE;
d9057 2
a9058 1
  arm_unwind_table_edit *new_edit = xmalloc (sizeof (arm_unwind_table_edit));
d9555 1
a9555 1
    attr->s = bfd_alloc (abfd, 3);
d10211 1
a10211 219
elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
{
  flagword out_flags;
  flagword in_flags;
  bfd_boolean flags_compatible = TRUE;
  asection *sec;

  /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (! is_arm_elf (ibfd) || ! is_arm_elf (obfd))
    return TRUE;

  if (!elf32_arm_merge_eabi_attributes (ibfd, obfd))
    return FALSE;

  /* The input BFD must have had its flags initialised.  */
  /* The following seems bogus to me -- The flags are initialized in
     the assembler but I don't think an elf_flags_init field is
     written into the object.  */
  /* BFD_ASSERT (elf_flags_init (ibfd)); */

  in_flags  = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  /* In theory there is no reason why we couldn't handle this.  However
     in practice it isn't even close to working and there is no real
     reason to want it.  */
  if (EF_ARM_EABI_VERSION (in_flags) >= EF_ARM_EABI_VER4
      && !(ibfd->flags & DYNAMIC)
      && (in_flags & EF_ARM_BE8))
    {
      _bfd_error_handler (_("error: %B is already in final BE8 format"),
			  ibfd);
      return FALSE;
    }

  if (!elf_flags_init (obfd))
    {
      /* If the input is the default architecture and had the default
	 flags then do not bother setting the flags for the output
	 architecture, instead allow future merges to do this.  If no
	 future merges ever set these flags then they will retain their
         uninitialised values, which surprise surprise, correspond
         to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default
	  && elf_elfheader (ibfd)->e_flags == 0)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Determine what should happen if the input ARM architecture
     does not match the output ARM architecture.  */
  if (! bfd_arm_merge_machines (ibfd, obfd))
    return FALSE;

  /* Identical flags must be compatible.  */
  if (in_flags == out_flags)
    return TRUE;

  /* Check to see if the input BFD actually contains any sections.  If
     not, its flags may not have been initialised either, but it
     cannot actually cause any incompatiblity.  Do not short-circuit
     dynamic objects; their section list may be emptied by
    elf_link_add_object_symbols.

    Also check to see if there are no code sections in the input.
    In this case there is no need to check for code specific flags.
    XXX - do we need to worry about floating-point format compatability
    in data sections ?  */
  if (!(ibfd->flags & DYNAMIC))
    {
      bfd_boolean null_input_bfd = TRUE;
      bfd_boolean only_data_sections = TRUE;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  /* Ignore synthetic glue sections.  */
	  if (strcmp (sec->name, ".glue_7")
	      && strcmp (sec->name, ".glue_7t"))
	    {
	      if ((bfd_get_section_flags (ibfd, sec)
		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
	    	only_data_sections = FALSE;

	      null_input_bfd = FALSE;
	      break;
	    }
	}

      if (null_input_bfd || only_data_sections)
	return TRUE;
    }

  /* Complain about various flag mismatches.  */
  if (!elf32_arm_versions_compatible (EF_ARM_EABI_VERSION (in_flags),
				      EF_ARM_EABI_VERSION (out_flags)))
    {
      _bfd_error_handler
	(_("error: Source object %B has EABI version %d, but target %B has EABI version %d"),
	 ibfd, obfd,
	 (in_flags & EF_ARM_EABIMASK) >> 24,
	 (out_flags & EF_ARM_EABIMASK) >> 24);
      return FALSE;
    }

  /* Not sure what needs to be checked for EABI versions >= 1.  */
  /* VxWorks libraries do not use these flags.  */
  if (get_elf_backend_data (obfd) != &elf32_arm_vxworks_bed
      && get_elf_backend_data (ibfd) != &elf32_arm_vxworks_bed
      && EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
    {
      if ((in_flags & EF_ARM_APCS_26) != (out_flags & EF_ARM_APCS_26))
	{
	  _bfd_error_handler
	    (_("error: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
	     ibfd, obfd,
	     in_flags & EF_ARM_APCS_26 ? 26 : 32,
	     out_flags & EF_ARM_APCS_26 ? 26 : 32);
	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_APCS_FLOAT) != (out_flags & EF_ARM_APCS_FLOAT))
	{
	  if (in_flags & EF_ARM_APCS_FLOAT)
	    _bfd_error_handler
	      (_("error: %B passes floats in float registers, whereas %B passes them in integer registers"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B passes floats in integer registers, whereas %B passes them in float registers"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_VFP_FLOAT) != (out_flags & EF_ARM_VFP_FLOAT))
	{
	  if (in_flags & EF_ARM_VFP_FLOAT)
	    _bfd_error_handler
	      (_("error: %B uses VFP instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B uses FPA instructions, whereas %B does not"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

      if ((in_flags & EF_ARM_MAVERICK_FLOAT) != (out_flags & EF_ARM_MAVERICK_FLOAT))
	{
	  if (in_flags & EF_ARM_MAVERICK_FLOAT)
	    _bfd_error_handler
	      (_("error: %B uses Maverick instructions, whereas %B does not"),
	       ibfd, obfd);
	  else
	    _bfd_error_handler
	      (_("error: %B does not use Maverick instructions, whereas %B does"),
	       ibfd, obfd);

	  flags_compatible = FALSE;
	}

#ifdef EF_ARM_SOFT_FLOAT
      if ((in_flags & EF_ARM_SOFT_FLOAT) != (out_flags & EF_ARM_SOFT_FLOAT))
	{
	  /* We can allow interworking between code that is VFP format
	     layout, and uses either soft float or integer regs for
	     passing floating point arguments and results.  We already
	     know that the APCS_FLOAT flags match; similarly for VFP
	     flags.  */
	  if ((in_flags & EF_ARM_APCS_FLOAT) != 0
	      || (in_flags & EF_ARM_VFP_FLOAT) == 0)
	    {
	      if (in_flags & EF_ARM_SOFT_FLOAT)
		_bfd_error_handler
		  (_("error: %B uses software FP, whereas %B uses hardware FP"),
		   ibfd, obfd);
	      else
		_bfd_error_handler
		  (_("error: %B uses hardware FP, whereas %B uses software FP"),
		   ibfd, obfd);

	      flags_compatible = FALSE;
	    }
	}
#endif

      /* Interworking mismatch is only a warning.  */
      if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
	{
	  if (in_flags & EF_ARM_INTERWORK)
	    {
	      _bfd_error_handler
		(_("Warning: %B supports interworking, whereas %B does not"),
		 ibfd, obfd);
	    }
	  else
	    {
	      _bfd_error_handler
		(_("Warning: %B does not support interworking, whereas %B does"),
		 ibfd, obfd);
	    }
	}
    }

  return flags_compatible;
}
d10636 2
a10637 1
		      local_got_refcounts = bfd_zalloc (abfd, size);
d10836 2
a10837 1
		    p = bfd_alloc (htab->root.dynobj, amt);
d11611 2
a11612 1
	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
d11766 1
a11766 1
      s->contents = bfd_zalloc (dynobj, s->size);
d12561 1
a12561 1
  entry = bfd_malloc (sizeof (* entry));
d13025 1
a13025 1
      sdata = bfd_zalloc (abfd, amt);
d13317 1
a13317 1
      bfd_byte *edited_contents = bfd_malloc (sec->size);
d13590 2
a13591 1
	  m = bfd_zalloc (abfd, sizeof (struct elf_segment_map));
d13803 225
@


1.211
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d7039 3
d7458 1
d7461 5
a7465 2
 	      /* Target the Thumb stub before the ARM PLT entry.  */
 	      value -= PLT_THUMB_STUB_SIZE;
d11459 6
a11466 6
	  /* Make sure the function is not marked as Thumb, in case
	     it is the target of an ABS32 relocation, which will
	     point to the PLT entry.  */
	  if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC)
	    h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);

@


1.211.2.1
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set sym_flags
	for the mode of target PLT entries.
	(allocate_dynrelocs): Only adjust symbol type if setting its
	value.

	ld/testsuite/
	* ld-arm/farcall-mixed-lib.d: Update.
@
text
@a7038 3
		  /* The PLT entry is in ARM mode, regardless of the
		     target function.  */
		  sym_flags = STT_FUNC;
a7454 1
		sym_flags = STT_FUNC;
d7457 2
a7458 5
	      {
		/* Target the Thumb stub before the ARM PLT entry.  */
		value -= PLT_THUMB_STUB_SIZE;
		sym_flags = STT_ARM_TFUNC;
	      }
d11452 1
d11454 5
a11458 6
	      /* Make sure the function is not marked as Thumb, in case
		 it is the target of an ABS32 relocation, which will
		 point to the PLT entry.  */
	      if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC)
		h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);
	    }
@


1.211.2.2
log
@	2010-01-19  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* bfd/elf32-arm.c (elf32_arm_howto_table_1): Correct bitsize of
	R_ARM_THM_CALL entry.
	(elf32_arm_final_link_relocate): Correct calculation of
	reloc_signed_max when doing a R_ARM_THM_CALL, R_ARM_THM_XPC22,
	or R_ARM_THM_JUMP24 relocation.
	2010-02-15  Matthew Gretton-Dann <matthew.gretton-dann@@arm.com>
	* ld/testsuite/ld-arm/jump-reloc-veneers-long.d: Correct testcase for
	arm-none-eabi target.
	* ld/testsuite/ld-arm/jump-reloc-veneers-short1.d: Likewise
	* ld/testsuite/ld-arm/jump-reloc-veneers-short2.d: Likewise
	2010-02-01  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* ld/testsuite/ld-arm/jump-reloc-veneers-long.d: New test.
	* ld/testsuite/ld-arm/jump-reloc-veneers-short1.d: Likewise.
	* ld/testsuite/ld-arm/jump-reloc-veneers-short2.d: Likewise.
	* ld/testsuite/ld-arm/jump-reloc-veneers.s: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp (armelftests): Run them.
@
text
@d3 1
a3 1
   2008, 2009, 2010  Free Software Foundation, Inc.
d227 1
a227 1
	 24,			/* bitsize */
d7536 1
a7536 1
	reloc_signed_max = (1 << (bitsize - 1)) - 1;
@


1.210
log
@2S09-08-21  Daniel Gutson  <dgutson@@codesourcery.com>

	ld/
        * ld-arm/callweak.d: Opcodes updated.
        * ld-arm/callweak.s: Architecture specified.
        * ld-arm/callweak-2.d: New test case.
        * ld-arm/callweak-2.s: New file.

	bfd/
	* elf32-arm.c (arch_has_thumb2_nop): New function.
	(arch_has_arm_nop): New function.
	(elf32_arm_final_link_relocate): NOP opcodes changed.

SVS: ----------------------------------------------------------------------
@
text
@d2238 1
a2238 1
  const insn_sequence* template;
d3446 1
a3446 1
  const insn_sequence *template;
d3483 1
a3483 1
  template = stub_entry->stub_template;
d3489 1
a3489 1
      switch (template[i].type)
d3493 2
a3494 2
	    bfd_vma data = template[i].data;
	    if (template[i].reloc_addend != 0)
d3508 2
a3509 1
          put_thumb_insn (globals, stub_bfd, (template[i].data >> 16) & 0xffff,
d3511 1
a3511 1
          put_thumb_insn (globals, stub_bfd, template[i].data & 0xffff,
d3513 1
a3513 1
          if (template[i].r_type != R_ARM_NONE)
d3522 2
a3523 1
	  put_arm_insn (globals, stub_bfd, template[i].data, loc + size);
d3526 1
a3526 1
	  if (template[i].r_type == R_ARM_JUMP24)
d3535 1
a3535 1
	  bfd_put_32 (stub_bfd, template[i].data, loc + size);
d3562 4
a3565 4
    if (template[stub_reloc_idx[i]].r_type == R_ARM_THM_JUMP24
	|| template[stub_reloc_idx[i]].r_type == R_ARM_THM_JUMP19
	|| template[stub_reloc_idx[i]].r_type == R_ARM_THM_CALL
	|| template[stub_reloc_idx[i]].r_type == R_ARM_THM_XPC22)
d3571 1
a3571 1
	  = (template[stub_reloc_idx[i]].r_type != R_ARM_THM_XPC22)
d3576 3
a3578 2
	rel.r_info = ELF32_R_INFO (0, template[stub_reloc_idx[i]].r_type);
	rel.r_addend = template[stub_reloc_idx[i]].reloc_addend;
d3594 1
a3594 1
	    (template[stub_reloc_idx[i]].r_type),
d3603 1
a3603 1
	    (template[stub_reloc_idx[i]].r_type), stub_bfd, stub_sec,
d3606 1
a3606 1
	  template[stub_reloc_idx[i]].reloc_addend);
d3621 1
a3621 1
  const insn_sequence *template = NULL;
d3625 1
a3625 1
  template = stub_definitions[stub_type].template;
d3631 1
a3631 1
      switch (template[i].type)
d3650 1
a3650 1
    *stub_template = template;
d3667 1
a3667 1
  const insn_sequence *template;
d3677 1
a3677 1
  size = find_stub_size_and_template (stub_entry->stub_type, &template,
d3681 1
a3681 1
  stub_entry->stub_template = template;
d4685 1
a4685 1
          const insn_sequence *template;
d4708 2
a4709 1
          size = find_stub_size_and_template (a8_fixes[i].stub_type, &template,
d4713 1
a4713 1
          stub_entry->stub_template = template;
d12983 1
a12983 1
  const insn_sequence *template;
d13006 2
a13007 2
  template = stub_entry->stub_template;
  switch (template[0].type)
d13028 1
a13028 1
      switch (template[i].type)
d13048 1
a13048 1
      if (template[i].type != prev_type)
d13050 1
a13050 1
	  prev_type = template[i].type;
d13055 1
a13055 1
      switch (template[i].type)
@


1.209
log
@	* elf32-arm.c (elf32_arm_size_stubs): Don't die on undefined local
	symbols.
	(elf32_arm_final_link_relocate): Treat local undefined symbols the
	same as global undefined symbols.
	(elf32_arm_relocate_section): Give an error for local undefined
	non-weak symbols, unless the reloc will not use the symbol.
@
text
@d2990 20
d7096 3
a7098 1
	     Do the same for local undefined symbols.  */
d7103 6
a7108 2
	      value = (bfd_get_32 (input_bfd, hit_data) & 0xf0000000)
		      | 0x0affffff;
d7353 1
a7353 1
	int thumb2 = using_thumb2 (globals);
d7356 3
a7358 1
	   the next instruction unless a PLT entry will be created.  */
d7362 10
a7371 2
	    bfd_put_16 (input_bfd, 0xe000, hit_data);
	    bfd_put_16 (input_bfd, 0xbf00, hit_data + 2);
@


1.208
log
@	bfd/
	* elf32-arm.c (elf32_arm_size_stubs): Call layout_sections_again
	at least once when fixing cortex-a8.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new test.
	* ld-arm/cortex-a8-fix-hdr.d: New.
	* ld-arm/cortex-a8-fix-hdr.s: New.
	* ld-arm/cortex-a8-fix-hdr.t: New.
@
text
@d4379 5
a6968 1
	  bfd_vma from;
d7005 2
d7075 5
a7079 3
	     the next instruction unless a PLT entry will be created.  */
	  if (h && h->root.type == bfd_link_hash_undefweak
	      && !(splt != NULL && h->plt.offset != (bfd_vma) -1))
d8725 19
@


1.207
log
@	bfd/
	* elf32-arm.c (elf32_arm_stub_type): Add arm_stub_a8_veneer_lwm.
	(arm_build_one_stub): Build a8 veneers as a separate pass.
	(cortex_a8_erratum_scan): Add prev_num_a8_fixes and stub_changed_p
	parameters.  Use them to check if we create a different a8 fixup
	than the previous pass.
	(elf32_arm_size_stubs): Move scope of stub_changed and
	prev_num_a8_fixes into main loop.
	(elf32_arm_build_stubs): Build a8 veneers in a second pass.

	ld/testsuite/
	* ld-arm/cortex-a8-far-1.s: New.
	* ld-arm/cortex-a8-far-2.s: New.
	* ld-arm/cortex-a8-far.d: New.
	* ld-arm/arm-elf.exp: Add new test.
@
text
@d4249 10
@


1.206
log
@2009-07-27  Doug Kwan  <dougkwan@@google.com>

        * elf32-arm.c (stub_hash_newfunc): Initialize field output_name.
@
text
@d2231 2
d3442 6
d3904 3
a3906 1
			unsigned int num_a8_relocs)
d4118 1
a4118 1
                          char *stub_name;
d4128 22
a4149 3
                          stub_name = bfd_malloc (8 + 1 + 8 + 1);
                          if (stub_name != NULL)
                            sprintf (stub_name, "%x:%x", section->id, i);
a4196 1
  bfd_boolean stub_changed = 0;
d4199 1
a4199 1
  unsigned int num_a8_fixes = 0, prev_num_a8_fixes = 0, a8_fix_table_size = 10;
d4254 2
a4257 1

d4484 1
d4581 2
a4582 1
              qsort (a8_relocs, num_a8_relocs, sizeof (struct a8_erratum_reloc),
d4588 3
a4590 1
					  a8_relocs, num_a8_relocs) != 0)
d4595 1
a4595 1
      if (htab->fix_cortex_a8 && num_a8_fixes != prev_num_a8_fixes)
a4633 2
      stub_changed = FALSE;
      prev_num_a8_fixes = num_a8_fixes;
d4730 6
@


1.205
log
@2009-07-10  Doug Kwan  <dougkwan@@google.com>

	* elf32-arm.c (stub_hash_newfunc): Initialize fields
	target_addend and orig_insn.
@
text
@d2727 1
@


1.204
log
@	* elf32-arm.c (arm_build_one_stub): Use the hash entry of the
	symbol a stub entry is derived from, not the entry for the stub
	itself, in call to elf32_arm_final_link_relocate.
@
text
@d2719 2
@


1.203
log
@        PR 10072
        * elf32-arm.c (elf32_arm_final_link_relocate): Add code to handle
        to R_ARM_THM_PC8 relocation.
@
text
@d3552 3
d3563 1
a3563 1
	  (struct elf_link_hash_entry *) stub_entry, &unresolved_reloc,
@


1.202
log
@2009-06-22  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (elf32_arm_size_stubs): Use PLT address as
	destination for defined dynamic symbols when deciding whether to
	insert a stub or not.
	(allocate_dynrelocs): Make sure functions are not marked as Thumb
	when actually accessed through a PLT, even when generating a
	shared lib.

	ld/testsuite:
	* ld-arm/farcall-mixed-app.s: Add new references to check more
	modes switching.
	* ld-arm/farcall-mixed-lib1.s: Likewise.
	* ld-arm/farcall-mixed-app-v5.d: Update expected result.
	* farcall-mixed-app.d: Likewise.
	* ld-arm/farcall-mixed-lib.d: Likewise.
@
text
@d7181 34
@


1.201
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d4364 19
a4382 1
			  if (sym_sec->output_section != NULL)
d11298 1
d11300 5
a11304 6
	      /* Make sure the function is not marked as Thumb, in case
		 it is the target of an ABS32 relocation, which will
		 point to the PLT entry.  */
	      if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC)
		h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);
	    }
@


1.200
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d2621 2
a2622 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d2924 1
a2924 1
  ret->sym_sec.abfd = NULL;
a10838 1

d10841 6
d10848 1
a10848 2
		    s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						   sec, r_symndx);
d10850 1
a10850 1
		      return FALSE;
@


1.199
log
@Undo accidental checkin of bogus change
@
text
@d2751 3
a2753 9
  htab->srelgot = bfd_make_section_with_flags (dynobj,
					       RELOC_SECTION (htab, ".got"),
					       (SEC_ALLOC | SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
@


1.198
log
@ * elf32-arm.c (cortex_a8_erratum_scan): Change type of offset
   to bfd_signed_vma.  Cast constant operands which are used in
   offset related expressions to bfd_signed_vma type as appropriate.
@
text
@d3178 5
a3182 6
	  if ((branch_offset > (ARM_MAX_FWD_BRANCH_OFFSET + 2)
               || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
               || ((r_type == R_ARM_CALL) && !globals->use_blx)
               || (r_type == R_ARM_JUMP24)
               || (r_type == R_ARM_PLT32))
              && !use_plt)
@


1.197
log
@2009-06-10  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Avoid crash if
	elf_sec->this_hdr == NULL.
@
text
@d3 1
a3 1
   2008 Free Software Foundation, Inc.
d3887 1
a3887 1
   NUM_A8_FIXES_P, A8_FIX_TABLE_SIZE_P.  Return 1 if an error occurs, 0
d3890 3
a3892 2
static int
cortex_a8_erratum_scan (bfd *input_bfd, struct bfd_link_info *info,
d3926 1
a3926 1
        return 1;
d3953 1
a3953 3
                 length non-branch instruction.
          */

d3981 5
a3985 2
              if (((base_vma + i) & 0xfff) == 0xffe && insn_32bit
		  && is_32bit_branch && last_was_32bit && !last_was_branch)
d3987 1
a3987 1
                  bfd_vma offset;
d4036 1
a4036 1
                        offset |= ~0xfffff;
d4053 1
a4053 1
                        offset |= ~0xffffff;
d4056 1
a4056 1
                        offset &= ~3u;
d4089 1
a4089 1
                        pc_for_insn &= ~3u;
d4096 2
a4097 1
                        offset = found->destination - pc_for_insn;
d4150 1
a4150 1
  return 0;
@


1.196
log
@    ld/
    * emultempl/armelf.em (fix_cortex_a8): New.
    (arm_elf_before_allocation): Call bfd_elf32_arm_set_cortex_a8_fix.
    (arm_elf_create_output_section_statements): Add fix_cortex_a8 to
    bfd_elf32_arm_set_target_relocs.
    (OPTION_FIX_CORTEX_A8, OPTION_NO_FIX_CORTEX_A8): New.
    (PARSE_AND_LIST_LONGOPTS): Add [no-]fix-cortex-a8 options.
    (PARSE_AND_LIST_OPTIONS): Add [no-]fix-cortex-a8 options.
    (PARSE_AND_LIST_ARGS_CASES): Handle OPTION_[NO_]FIX_CORTEX_A8.
    * ld.texinfo (--[no-]fix-cortex-a8): Briefly document new options.

    bfd/
    * elf32-arm.c (THUMB16_BCOND_INSN, THUMB32_INSN, THUMB32_B_INSN):
    New macros.
    (elf32_arm_stub_a8_veneer_b_cond, elf32_arm_stub_a8_veneer_b)
    (elf32_arm_stub_a8_veneer_blx): New stub sequences.
    (elf32_arm_stub_type): Add arm_stub_a8_veneer_b_cond,
    arm_stub_a8_veneer_b and arm_stub_a8_veneer_blx.
    (elf32_arm_stub_hash_entry): Add target_addend, orig_insn fields.
    (a8_erratum_fix, a8_erratum_reloc): New structs.
    (elf32_arm_link_hash_table): Add a8_erratum_fixes,
    num_a8_erratum_fixes, fix_cortex_a8 fields.
    (elf32_arm_link_hash_table_create): Zero fix_cortex_a8.
    (elf32_arm_add_stub): Split into two parts, creating...
    (elf32_arm_create_or_find_stub_sec): New function.
    (elf32_arm_final_link_relocate): Add forward declaration.
    (arm_build_one_stub): Add support for THUMB32_TYPE, Thumb-2
    relocations, multiple relocations per stub.
    (find_stub_size_and_template): New (using parts of
    arm_size_one_stub).
    (arm_size_one_stub): Use find_stub_size_and_template.
    (a8_reloc_compare): New.
    (find_thumb_glue): Add forward declaration.
    (cortex_a8_erratum_scan): New.
    (elf32_arm_size_stubs): Add Cortex-A8 erratum workaround support.
    (bfd_elf32_arm_set_cortex_a8_fix): New.
    (bfd_elf32_arm_set_target_relocs): Add fix_cortex_a8 argument.
    (arm_map_one_stub): Add THUMB32_TYPE support.
    (a8_branch_to_stub_data): New.
    (make_branch_to_a8_stub): New.
    (elf32_arm_write_section): Add Cortex-A8 erratum workaround support.
    * bfd-in.h (bfd_elf32_arm_set_cortex_a8_fix): New.
    (bfd_elf32_arm_set_target_relocs): Add argument for controlling
    Cortex-A8 erratum workaround.
    * bfd-in2.h: Regenerate.

    ld/testsuite/
    * ld-arm/cortex-a8-arm-target.s: New.
    * ld-arm/cortex-a8-thumb-target.s: New.
    * ld-arm/cortex-a8-fix-b-rel.s: New.
    * ld-arm/cortex-a8-fix-b-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-b-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-b.s: New.
    * ld-arm/cortex-a8-fix-b.d: New.
    * ld-arm/cortex-a8-fix-bl-rel.s: New.
    * ld-arm/cortex-a8-fix-bl-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-bl-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-bl.s: New.
    * ld-arm/cortex-a8-fix-bl.d: New.
    * ld-arm/cortex-a8-fix-bcc-rel.s: New.
    * ld-arm/cortex-a8-fix-bcc-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-bcc.s: New.
    * ld-arm/cortex-a8-fix-bcc.d: New.
    * ld-arm/cortex-a8-fix-blx-rel.s: New.
    * ld-arm/cortex-a8-fix-blx-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-blx-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-blx.s: New.
    * ld-arm/cortex-a8-fix-blx.d: New.
    * ld-arm/arm-elf.exp: Add new tests.
@
text
@d3178 6
a3183 5
	  if (branch_offset > (ARM_MAX_FWD_BRANCH_OFFSET + 2)
	      || (branch_offset < ARM_MAX_BWD_BRANCH_OFFSET)
	      || ((r_type == R_ARM_CALL) && !globals->use_blx)
	      || (r_type == R_ARM_JUMP24)
	      || (r_type == R_ARM_PLT32))
d8964 1
a8964 1
	  if (hdr->sh_type != SHT_ARM_EXIDX)
@


1.195
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d2029 9
a2037 5
#define THUMB16_INSN(X)    {(X), THUMB16_TYPE, R_ARM_NONE, 0}
#define THUMB32_INSN(X)    {(X), THUMB32_TYPE, R_ARM_NONE, 0}
#define ARM_INSN(X)        {(X), ARM_TYPE, R_ARM_NONE, 0}
#define ARM_REL_INSN(X, Z) {(X), ARM_TYPE, R_ARM_JUMP24, (Z)}
#define DATA_WORD(X,Y,Z)   {(X), DATA_TYPE, (Y), (Z)}
d2171 33
d2221 5
a2225 1
  DEF_STUB(long_branch_thumb_only_pic)
d2262 7
d2388 28
d2547 6
d2571 3
d2913 1
d3303 3
a3305 2
/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */
d3307 3
a3309 4
static struct elf32_arm_stub_hash_entry *
elf32_arm_add_stub (const char *stub_name,
		    asection *section,
		    struct elf32_arm_link_hash_table *htab)
a3312 1
  struct elf32_arm_stub_hash_entry *stub_entry;
d3340 22
d3407 5
d3416 1
d3430 3
a3432 2
  int stub_reloc_idx = -1;
  int stub_reloc_offset = 0;
d3467 13
a3479 2
	  put_thumb_insn (globals, stub_bfd, template[i].data, loc + size);
	  size += 2;
d3482 13
d3501 2
a3502 2
	      stub_reloc_idx = i;
	      stub_reloc_offset = size;
d3509 2
a3510 2
	  stub_reloc_idx = i;
	  stub_reloc_offset = size;
d3530 47
a3576 7
  /* Assume there is one and only one entry to relocate in each stub.  */
  BFD_ASSERT (stub_reloc_idx != -1);

  _bfd_final_link_relocate (elf32_arm_howto_from_type (template[stub_reloc_idx].r_type),
			    stub_bfd, stub_sec, stub_sec->contents,
			    stub_entry->stub_offset + stub_reloc_offset,
			    sym_value, template[stub_reloc_idx].reloc_addend);
d3579 1
d3582 2
a3583 2
/* As above, but don't actually build the stub.  Just bump offset so
   we know stub section sizes.  */
d3585 8
a3592 17
static bfd_boolean
arm_size_one_stub (struct bfd_hash_entry *gen_entry,
		   void * in_arg)
{
  struct elf32_arm_stub_hash_entry *stub_entry;
  struct elf32_arm_link_hash_table *htab;
  const insn_sequence *template;
  int template_size;
  int size;
  int i;

  /* Massage our args to the form they really have.  */
  stub_entry = (struct elf32_arm_stub_hash_entry *) gen_entry;
  htab = (struct elf32_arm_link_hash_table *) in_arg;

  BFD_ASSERT((stub_entry->stub_type > arm_stub_none)
	     && stub_entry->stub_type < ARRAY_SIZE(stub_definitions));
d3594 2
a3595 2
  template = stub_definitions[stub_entry->stub_type].template;
  template_size = stub_definitions[stub_entry->stub_type].template_size;
d3607 1
a3607 3
	  size += 4;
	  break;

d3618 31
d3865 284
d4167 12
d4190 7
d4224 2
d4234 2
d4284 1
d4302 2
d4404 32
a4435 6
		  /* Determine what (if any) linker stub is needed.  */
		  stub_type = arm_type_of_stub (info, section, irela, st_type,
						hash, destination, sym_sec,
						input_bfd, sym_name);
		  if (stub_type == arm_stub_none)
		    continue;
d4437 7
a4443 2
		  /* Support for grouping stub sections.  */
		  id_sec = htab->stub_group[section->id].link_sec;
d4445 33
a4477 14
		  /* Get the name of this stub.  */
		  stub_name = elf32_arm_stub_name (id_sec, sym_sec, hash, irela);
		  if (!stub_name)
		    goto error_ret_free_internal;

		  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table,
						    stub_name,
						    FALSE, FALSE);
		  if (stub_entry != NULL)
		    {
		      /* The proper stub has already been created.  */
		      free (stub_name);
		      continue;
		    }
d4479 3
a4481 6
		  stub_entry = elf32_arm_add_stub (stub_name, section, htab);
		  if (stub_entry == NULL)
		    {
		      free (stub_name);
		      goto error_ret_free_internal;
		    }
d4483 33
a4515 17
		  stub_entry->target_value = sym_value;
		  stub_entry->target_section = sym_sec;
		  stub_entry->stub_type = stub_type;
		  stub_entry->h = hash;
		  stub_entry->st_type = st_type;

		  if (sym_name == NULL)
		    sym_name = "unnamed";
		  stub_entry->output_name
		    = bfd_alloc (htab->stub_bfd,
				 sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
				 + strlen (sym_name));
		  if (stub_entry->output_name == NULL)
		    {
		      free (stub_name);
		      goto error_ret_free_internal;
		    }
d4517 4
a4520 15
		  /* For historical reasons, use the existing names for
		     ARM-to-Thumb and Thumb-to-ARM stubs.  */
		  if ( ((r_type == (unsigned int) R_ARM_THM_CALL)
			|| (r_type == (unsigned int) R_ARM_THM_JUMP24))
		       && st_type != STT_ARM_TFUNC)
		    sprintf (stub_entry->output_name, THUMB2ARM_GLUE_ENTRY_NAME,
			     sym_name);
		  else if ( ((r_type == (unsigned int) R_ARM_CALL)
			     || (r_type == (unsigned int) R_ARM_JUMP24))
			   && st_type == STT_ARM_TFUNC)
		    sprintf (stub_entry->output_name, ARM2THUMB_GLUE_ENTRY_NAME,
			     sym_name);
		  else
		    sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
			     sym_name);
d4522 4
a4525 2
		  stub_changed = TRUE;
		}
d4527 11
a4537 3
	      /* We're done with the internal relocs, free them.  */
	      if (elf_section_data (section)->relocs == NULL)
		free (internal_relocs);
d4541 3
d4562 16
d4581 1
d4584 52
d5453 22
d6084 1
a6084 1
				 int pic_veneer)
d6106 1
d12841 1
d12848 1
a12848 1
      return FALSE;
d12862 1
d12885 1
d13112 114
d13235 1
a13235 1
  int mapcount, errcount;
d13244 1
a13244 1
  int i;
d13419 12
@


1.194
log
@2009-05-15  Andrew Stubbs  <ams@@codesourcery.com>
	Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Don't attempt to
	fix discarded sections.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add unwind-5.
	* ld-arm/discard-unwind.ld: New file.
	* ld-arm/unwind-5.d: New test.
	* ld-arm/unwind-5.s: New test.
@
text
@d12001 2
a12002 2
  bfd_boolean (*func) (void *, const char *, Elf_Internal_Sym *,
		       asection *, struct elf_link_hash_entry *);
d12032 1
a12032 3
  if (!osi->func (osi->finfo, names[type], &sym, osi->sec, NULL))
    return FALSE;
  return TRUE;
d12130 1
a12130 3
  if (!osi->func (osi->finfo, name, &sym, osi->sec, NULL))
    return FALSE;
  return TRUE;
d12243 4
a12246 4
				  bfd_boolean (*func) (void *, const char *,
						       Elf_Internal_Sym *,
						       asection *,
						       struct elf_link_hash_entry *))
@


1.193
log
@     * elf32-arm.c: Move sysdep.h to start of file.
@
text
@d8355 4
@


1.192
log
@2009-05-05  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (arm_unwind_edit_type, arm_unwind_table_edit): Define.
	(_arm_elf_section_data): Add text and exidx fields.
	(add_unwind_table_edit, get_arm_elf_section_data, adjust_exidx_size,
	insert_cantunwind_after, elf32_arm_fix_exidx_coverage, offset_prel31,
	copy_exidx_entry): New functions.
	(elf32_arm_write_section): Fixup .ARM.exidx contents.

	ld/
	* emultempl/armelf.em (compare_output_sec_vma): New function.
	(gld${EMULATION_NAME}_finish): Add exidx munging code.

	ld/testsuite/
	* ld-arm/arm.ld: Add .ARM.exidx and .ARM.extab.
	* ld-arm/arm-elf.exp: Add unwind-[1-4].
	* ld-arm/unwind-1.d: New test.
	* ld-arm/unwind-1.s: New test.
	* ld-arm/unwind-2.d: New test.
	* ld-arm/unwind-2.s: New test.
	* ld-arm/unwind-3.d: New test.
	* ld-arm/unwind-3.s: New test.
	* ld-arm/unwind-4.d: New test.
	* ld-arm/unwind-4.s: New test.
@
text
@d22 1
a24 1
#include "sysdep.h"
@


1.191
log
@2009-05-05  Christophe lyon  <christophe.lyon@@st.com>
	bfd/
	* elf32-arm.c (DEF_STUBS): New helper define.
	(DEF_STUB): Likewise.
	(stub_def): New type.
	(stub_definitions): New array, containing stub template pointers
	and sizes.
	(arm_size_one_stub): Make use of stub_definitions.
@
text
@d22 2
d2288 20
d2310 1
d2315 1
d2318 16
d8191 239
d12413 29
d12548 88
@


1.190
log
@bfd:
	* elf32-arm.c (elf32_arm_check_relocs): Give errors for absolute
	MOVW and MOVT relocations in a shared library link.

ld/testsuite:
	* ld-arm/movw-shared-1.d, ld-arm/movw-shared-1.s,
	ld-arm/movw-shared-2.d, ld-arm/movw-shared-2.s,
	ld-arm/movw-shared-3.d, ld-arm/movw-shared-3.s,
	ld-arm/movw-shared-4.d, ld-arm/movw-shared-4.s: New tests.
	* ld-arm/arm-elf.exp: Run these new tests.
@
text
@d2169 23
a2191 1
enum elf32_arm_stub_type
d2193 8
a2200 13
  arm_stub_none,
  arm_stub_long_branch_any_any,
  arm_stub_long_branch_v4t_arm_thumb,
  arm_stub_long_branch_thumb_only,
  arm_stub_long_branch_v4t_thumb_thumb,
  arm_stub_long_branch_v4t_thumb_arm,
  arm_stub_short_branch_v4t_thumb_arm,
  arm_stub_long_branch_any_arm_pic,
  arm_stub_long_branch_any_thumb_pic,
  arm_stub_long_branch_v4t_arm_thumb_pic,
  arm_stub_long_branch_v4t_thumb_arm_pic,
  arm_stub_long_branch_thumb_only_pic,
  arm_stub_long_branch_v4t_thumb_thumb_pic,
d3381 5
a3385 54
  switch (stub_entry->stub_type)
    {
    case arm_stub_long_branch_any_any:
      template =  elf32_arm_stub_long_branch_any_any;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_any_any);
      break;
    case arm_stub_long_branch_v4t_arm_thumb:
      template =  elf32_arm_stub_long_branch_v4t_arm_thumb;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_arm_thumb);
      break;
    case arm_stub_long_branch_thumb_only:
      template =  elf32_arm_stub_long_branch_thumb_only;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_thumb_only);
      break;
    case arm_stub_long_branch_v4t_thumb_thumb:
      template =  elf32_arm_stub_long_branch_v4t_thumb_thumb;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_thumb_thumb);
      break;
    case arm_stub_long_branch_v4t_thumb_arm:
      template =  elf32_arm_stub_long_branch_v4t_thumb_arm;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_thumb_arm);
      break;
    case arm_stub_short_branch_v4t_thumb_arm:
      template =  elf32_arm_stub_short_branch_v4t_thumb_arm;
      template_size = ARRAY_SIZE (elf32_arm_stub_short_branch_v4t_thumb_arm);
      break;
    case arm_stub_long_branch_any_arm_pic:
      template = elf32_arm_stub_long_branch_any_arm_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_any_arm_pic);
      break;
    case arm_stub_long_branch_any_thumb_pic:
      template = elf32_arm_stub_long_branch_any_thumb_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_any_thumb_pic);
      break;
    case arm_stub_long_branch_v4t_arm_thumb_pic:
      template = elf32_arm_stub_long_branch_v4t_arm_thumb_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_arm_thumb_pic);
      break;
    case arm_stub_long_branch_v4t_thumb_arm_pic:
      template = elf32_arm_stub_long_branch_v4t_thumb_arm_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_thumb_arm_pic);
      break;
    case arm_stub_long_branch_thumb_only_pic:
      template = elf32_arm_stub_long_branch_thumb_only_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_thumb_only_pic);
      break;
    case arm_stub_long_branch_v4t_thumb_thumb_pic:
      template = elf32_arm_stub_long_branch_v4t_thumb_thumb_pic;
      template_size = ARRAY_SIZE (elf32_arm_stub_long_branch_v4t_thumb_thumb_pic);
      break;
    default:
      BFD_FAIL ();
      return FALSE;
    }
@


1.189
log
@2009-04-22  Christophe Lyon  <christophe.lyon@@st.com>

	PR9743
	bfd/
	* elf32-arm.c (arm_type_of_stub): Handle R_ARM_THM_JUMP24,
	R_ARM_JUMP24 and R_ARM_PLT32 relocations.
	(elf32_arm_size_stubs): Likewise.
	(record_thumb_to_arm_glue): Deleted unused function.
	(bfd_elf32_arm_process_before_allocation): No longer handle
	R_ARM_THM_JUMP24, R_ARM_JUMP24 and R_ARM_PLT32 relocations here.
	(elf32_arm_final_link_relocate): Handle R_ARM_THM_JUMP24,
	R_ARM_JUMP24 and R_ARM_PLT32 relocations.

	testsuite/
	* ld-arm/arm-call.d: Update expected result.
	* ld-arm/arm-pic-veneer.d: Likewise.
	* ld-arm/thumb2-b-interwork.d: Likewise.
@
text
@d9811 15
a9829 2
	  case R_ARM_MOVW_ABS_NC:
	  case R_ARM_MOVT_ABS:
a9831 2
	  case R_ARM_THM_MOVW_ABS_NC:
	  case R_ARM_THM_MOVT_ABS:
@


1.188
log
@	bfd/
	* elf32-arm.c (INTERWORK_FLAG): Check BFD_LINKER_CREATED.
	(elf32_arm_write_section): Declare early.
	(elf32_arm_size_stubs): Skip non-stub sections in the stub BFD.
	(arm_allocate_glue_section_space): Exclude empty sections.
	(ARM_GLUE_SECTION_FLAGS): Add SEC_LINKER_CREATED.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Do not skip the stub
	BFD.
	(elf32_arm_output_glue_section, elf32_arm_final_link): New.
	(elf32_arm_merge_eabi_attributes): Skip the stub BFD.
	(elf32_arm_size_dynamic_sections): Allocate interworking
	sections here.
	(bfd_elf32_bfd_final_link): Define.

	ld/
	* emultempl/armelf.em (bfd_for_interwork, arm_elf_after_open)
	(arm_elf_set_bfd_for_interworking): Delete.
	(arm_elf_before_allocation): Do not set the interworking BFD.
	Move allocation inside not-dynamic block.
	(arm_elf_create_output_section_statements): Create glue sections
	and set the interworking BFD here.
	(LDEMUL_AFTER_OPEN): Delete.

	ld/testsuite/
	* ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
	ld-arm/farcall-group-size2.d, ld-arm/farcall-group.d,
	ld-arm/farcall-mixed-lib.d: Update for linker changes.
@
text
@d2924 1
a2924 1
  if (r_type == R_ARM_THM_CALL)
d2929 4
a2932 3
	 - it's a Thumb->Arm call and blx is not available. A stub is
           needed in this case, but only if this call is not through a
           PLT entry. Indeed, PLT stubs handle mode switching already.
d2941 2
a2942 1
	      && ((r_type == R_ARM_THM_CALL) && !globals->use_blx)
d2952 6
a2957 2
		    ? ((globals->use_blx)
		       /* V5T and above.  */
d2963 2
a2964 1
		    : ((globals->use_blx)
d2994 2
a2995 1
		? ((globals->use_blx)
d3002 2
a3003 1
		: ((globals->use_blx)
d3017 1
a3017 1
  else if (r_type == R_ARM_CALL)
d3037 3
a3039 1
	      || !globals->use_blx)
d3783 1
a3783 1
		  /* Only look for stubs on call instructions.  */
d3785 4
a3788 1
		      && (r_type != (unsigned int) R_ARM_THM_CALL))
d3939 3
a3941 2
		  if (r_type == (unsigned int) R_ARM_THM_CALL
		      && st_type != STT_ARM_TFUNC)
d3944 2
a3945 1
		  else if (r_type == (unsigned int) R_ARM_CALL
a4294 80
static void
record_thumb_to_arm_glue (struct bfd_link_info *link_info,
			  struct elf_link_hash_entry *h)
{
  const char *name = h->root.root.string;
  asection *s;
  char *tmp_name;
  struct elf_link_hash_entry *myh;
  struct bfd_link_hash_entry *bh;
  struct elf32_arm_link_hash_table *hash_table;
  bfd_vma val;

  hash_table = elf32_arm_hash_table (link_info);

  BFD_ASSERT (hash_table != NULL);
  BFD_ASSERT (hash_table->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name
    (hash_table->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

  BFD_ASSERT (s != NULL);

  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);

  myh = elf_link_hash_lookup
    (&(hash_table)->root, tmp_name, FALSE, FALSE, TRUE);

  if (myh != NULL)
    {
      /* We've already seen this guy.  */
      free (tmp_name);
      return;
    }

  /* The only trick here is using hash_table->thumb_glue_size as the value.
     Even though the section isn't allocated yet, this is where we will be
     putting it.  The +1 on the value marks that the stub has not been
     output yet - not that it is a Thumb function.  */
  bh = NULL;
  val = hash_table->thumb_glue_size + 1;
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_GLOBAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  /* If we mark it 'Thumb', the disassembler will do a better job.  */
  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_ARM_TFUNC);
  myh->forced_local = 1;

  free (tmp_name);

#define CHANGE_TO_ARM "__%s_change_to_arm"
#define BACK_FROM_ARM "__%s_back_from_arm"

  /* Allocate another symbol to mark where we switch to Arm mode.  */
  tmp_name = bfd_malloc ((bfd_size_type) strlen (name)
			 + strlen (CHANGE_TO_ARM) + 1);

  BFD_ASSERT (tmp_name);

  sprintf (tmp_name, CHANGE_TO_ARM, name);

  bh = NULL;
  val = hash_table->thumb_glue_size + 4,
  _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
				    tmp_name, BSF_LOCAL, s, val,
				    NULL, TRUE, FALSE, &bh);

  free (tmp_name);

  s->size += THUMB2ARM_GLUE_SIZE;
  hash_table->thumb_glue_size += THUMB2ARM_GLUE_SIZE;
}


a4663 3
	      && r_type != R_ARM_PLT32
	      && r_type != R_ARM_JUMP24
	      && r_type != R_ARM_THM_JUMP24
a4714 2
	    case R_ARM_PLT32:
	    case R_ARM_JUMP24:
a4721 10
	    case R_ARM_THM_JUMP24:
	      /* This one is a call from thumb code.  We look
	         up the target of the call.  If it is not a thumb
                 target, we insert glue.  */
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC
		  && !(globals->use_blx && r_type == R_ARM_THM_CALL)
		  && h->root.type != bfd_link_hash_undefweak)
		record_thumb_to_arm_glue (link_info, h);
	      break;

d6067 3
a6069 1
	   && r_type != R_ARM_CALL)
d6237 1
a6237 1
	  else if (r_type != R_ARM_CALL)
d6255 3
a6257 1
	  if (r_type == R_ARM_CALL)
d6276 5
a6280 1
		  || sym_flags == STT_ARM_TFUNC)
a6345 8
	      /* Set the H bit in the BLX instruction.  */
	      if (sym_flags == STT_ARM_TFUNC)
		{
		  if (addend)
		    value |= (1 << 24);
		  else
		    value &= ~(bfd_vma)(1 << 24);
		}
d6348 9
d6600 2
a6601 1
		else if (r_type != R_ARM_THM_CALL)
d6638 1
a6638 1
	if (r_type == R_ARM_THM_CALL)
d6658 3
a6660 1
		|| ((sym_flags != STT_ARM_TFUNC) && !globals->use_blx))
d6674 1
a6674 1
		if (globals->use_blx)
@


1.187
log
@2009-04-17  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (elf32_arm_size_stubs): Handle long branches through
	PLT entries to an undefined symbol when generating a shared
	library.

	testsuite/
	* ld-arm/arm-elf.exp: Add new test farcall-mixed-lib.
	* ld-arm/farcall-mixed-lib.d: Update expected output.
	* ld-arm/farcall-mixed-lib1.s: New file.
	* ld-arm/farcall-mixed-lib2.s: New file.
@
text
@d64 5
d1889 2
a1890 1
  || (elf_elfheader (abfd)->e_flags & EF_ARM_INTERWORK))
d3954 7
a3960 1
	stub_sec->size = 0;
d4158 10
a4167 1
    return;
a4568 3
/* Note: we do not include the flag SEC_LINKER_CREATED, as that
   would prevent elf_link_input_bfd() from processing the contents
   of the section.  */
d4570 2
a4571 1
  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY)
a4609 4
  /* Linker stubs don't need glue.  */
  if (!strcmp (abfd->filename, "linker stubs"))
    return TRUE;

d8250 58
d8699 6
d10863 3
d12604 1
@


1.186
log
@2009-04-15  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Don't convert ARM
	branch to an undef weak symbol into a jump to next instruction if
	a PLT entry will be created.

	testsuite/
	* ld-arm/arm-elf.exp: Add 1 more test to check undef weak
	reference with PLT in ARM mode.
	* ld-arm/thumb2-bl-undefweak1.d, ld-arm/thumb2-bl-undefweak1.s:
	New files.
@
text
@d3835 23
a3857 6
		      else if (hash->root.root.type == bfd_link_hash_undefweak
			       || hash->root.root.type == bfd_link_hash_undefined)
			/* For a shared library, these will need a PLT stub,
			   which is treated separately.
			   For absolute code, they cannot be handled.  */
			continue;
@


1.185
log
@2009-04-02  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_v4t_thumb_thumb,
	elf32_arm_stub_long_branch_v4t_thumb_thumb_pic): Two new long
	branch stubs.
	(elf32_arm_stub_type): New enum values for the two new stubs.
	(arm_type_of_stub): Make use of the two new stubs.
	(arm_size_one_stub): Handle the two new stubs.

	testsuite/
	* ld-arm/farcall-thumb-thumb-pic-veneer.d: Update expected
	results.
	* ld-arm/farcall-thumb-thumb.d: Likewise.
@
text
@d6366 3
a6368 2
	     the next instruction.  */
	  if (h && h->root.type == bfd_link_hash_undefweak)
@


1.184
log
@2009-04-01  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (group_sections): Rewrite loops for better
	readability.
@
text
@d2052 1
a2052 3
/* Thumb -> Thumb long branch stub. Used on architectures which
   support only this mode, or on V4T where it is expensive to switch
   to ARM.  */
d2064 11
d2134 2
a2135 3
/* Thumb -> Thumb long branch stub, PIC. Used on architectures which
   support only this mode, or on V4T where it is expensive to switch
   to ARM.  */
d2147 12
d2169 1
d2177 1
d2948 1
a2948 1
		       : arm_stub_long_branch_thumb_only_pic)
d2955 1
a2955 1
		       : arm_stub_long_branch_thumb_only);
d3361 4
d3393 4
@


1.183
log
@	* coff-arm.c (coff_arm_merge_private_bfd_data): Use "error:", not
	"ERROR:", in error messages.
	* cpu-arm.c (bfd_arm_merge_machines): Likewise.
	* elf-attrs.c (_bfd_elf_merge_object_attributes): Likewise.
	* elf32-arm.c (tag_cpu_arch_combine): Likewise.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(elf32_arm_merge_private_bfd_data): Likewise.
@
text
@a3527 1
      asection *tp;
d3537 11
a3547 11
      head = tail;
      tp = NULL;
      for (;;)
	{
	  asection *h = PREV_SEC (head);
	  NEXT_SEC (head) = tp;
	  if (h == NULL)
	    break;
	  tp = head;
	  head = h;
	}
d3553 2
a3554 1
	  bfd_size_type total;
d3557 1
a3557 2
	  total = 0;
	  while ((next = NEXT_SEC (curr)) != NULL)
d3559 4
a3562 7
	      if ( (total + next->output_offset - curr->output_offset
		    + next->size)
		   < stub_group_size )
		{
		  total += next->output_offset - curr->output_offset;
		}
	      else
d3564 2
a3565 2

	    curr = next;
d3587 2
a3588 1
	      total = head->size;
d3591 3
a3593 7
		  if ( (total + next->output_offset - head->output_offset
			+ next->size)
		       < stub_group_size )
		    {
		      total += next->output_offset - head->output_offset;
		    }
		  else
d3595 1
a3595 1

@


1.182
log
@	* elf32-arm.c (elf32_arm_check_relocs): Correct symbian_p test.
@
text
@d8519 1
a8519 1
      _bfd_error_handler (_("ERROR: %B: Unknown CPU architecture"), ibfd);
d8557 1
a8557 1
      _bfd_error_handler (_("ERROR: %B: Conflicting CPU architectures %d/%d"),
d8608 1
a8608 1
	    (_("ERROR: %B uses VFP register arguments, %B does not"),
d8724 1
a8724 1
		(_("ERROR: %B: 8-byte data alignment conflicts with %B"),
d8758 1
a8758 1
		    (_("ERROR: %B: Conflicting architecture profiles %c/%c"),
d8791 1
a8791 1
		(_("ERROR: %B: Conflicting use of R9"), ibfd);
d8803 1
a8803 1
		(_("ERROR: %B: SB relative addressing conflicts with use of R9"),
d8859 1
a8859 1
		(_("ERROR: %B uses iWMMXt register arguments, %B does not"),
d8881 1
a8881 1
		    (_("ERROR: fp16 format mismatch between %B and %B"),
d9085 1
a9085 1
      _bfd_error_handler (_("ERROR: %B is already in final BE8 format"),
d9161 1
a9161 1
	(_("ERROR: Source object %B has EABI version %d, but target %B has EABI version %d"),
d9177 1
a9177 1
	    (_("ERROR: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"),
d9188 1
a9188 1
	      (_("ERROR: %B passes floats in float registers, whereas %B passes them in integer registers"),
d9192 1
a9192 1
	      (_("ERROR: %B passes floats in integer registers, whereas %B passes them in float registers"),
d9202 1
a9202 1
	      (_("ERROR: %B uses VFP instructions, whereas %B does not"),
d9206 1
a9206 1
	      (_("ERROR: %B uses FPA instructions, whereas %B does not"),
d9216 1
a9216 1
	      (_("ERROR: %B uses Maverick instructions, whereas %B does not"),
d9220 1
a9220 1
	      (_("ERROR: %B does not use Maverick instructions, whereas %B does"),
d9239 1
a9239 1
		  (_("ERROR: %B uses software FP, whereas %B uses hardware FP"),
d9243 1
a9243 1
		  (_("ERROR: %B uses hardware FP, whereas %B uses software FP"),
@


1.181
log
@        PR 9934
        * elf-bfd.h (NUM_SHDR_ENTRIES): Cope with an empty section.
        * elflink.c (elf_link_read_relocs_from_section): Use
        NUM_SHDR_ENTRIES.  Gracefully handle the case where there are
        relocs but no symbol table.
        * elf32-arm.c (elf32_arm_check_relocs): Likewise.
@
text
@d9840 1
a9840 1
		    if (! htab->symbian_p)
d9845 1
a9845 1
			flags |= (SEC_LOAD | SEC_ALLOC);
@


1.180
log
@09-03-05  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (group_sections): Take next section size into
	account before accepting to group it.

	testsuite/
	* ld-arm/arm-elf.exp: Add new farcall-group-limit test.
	* ld-arm/farcall-group-limit.d: New file.
	* ld-arm/farcall-group3.s: New file.
	* ld-arm/farcall-group4.s: New file.
@
text
@d9600 1
d9624 2
a9625 1

d9638 5
a9642 1
      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
d9645 1
a9645 1
				 r_symndx);
d9649 1
a9649 1
      if (r_symndx < symtab_hdr->sh_info)
@


1.179
log
@2009-03-05  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (arm_type_of_stub): Handle long branches targetting
	PLT entries.
	(elf32_arm_final_link_relocate): Likewise.

	testsuite/
	* ld-arm/arm-elf.exp: Add 2 more tests to check long branch stubs
	in PLT context.
	* ld-arm/farcall-mixed-app-v5.d: New file.
	* ld-arm/farcall-mixed-app.d: Likewise.
	* ld-arm/farcall-mixed-app.r: Likewise.
	* ld-arm/farcall-mixed-app.s: Likewise.
	* ld-arm/farcall-mixed-app.sym: Likewise.
	* ld-arm/farcall-mixed-lib.d: Likewise.
	* ld-arm/farcall-mixed-lib.r: Likewise.
@
text
@d3557 12
a3568 4
	  total = head->size;
	  while ((next = NEXT_SEC (curr)) != NULL
		 && ((total += next->output_offset - curr->output_offset)
		     < stub_group_size))
d3570 1
d3591 2
a3592 4
	      total = 0;
	      while (next != NULL
		     && ((total += next->output_offset - head->output_offset)
			 < stub_group_size))
d3594 9
@


1.178
log
@2009-02-26  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (stub_reloc_type): Removed.
	(insn_sequence): Renamed reloc_type field to r_type.
	(elf32_arm_stub_long_branch_v4t_arm_thumb_pic): New stub.
	(elf32_arm_stub_long_branch_v4t_thumb_arm_pic): Likewise.
	(elf32_arm_stub_long_branch_thumb_only_pic): Likewise.
	(elf32_arm_stub_type): Add new enum entries for the new stubs.
	(arm_stub_is_thumb): Catch new stubs.
	(arm_type_of_stub): Handle new stubs.
	(arm_size_one_stub): Use ARRAY_SIZE. Handle new stubs.
	(bfd_elf32_arm_process_before_allocation): Remove useless
	condition.

	testsuite/
	* ld-arm/arm-elf.exp: Add 3 tests for the 3 new stubs.
	* ld-arm/farcall-thumb-arm-pic-veneer.d: New expected result, the
	test is now expected to pass.
	* ld-arm/farcall-thumb-thumb-m-pic-veneer.d: Likewise.
	* ld-arm/farcall-thumb-thumb-pic-veneer.d: Likewise.
@
text
@d2860 1
d2882 1
a2882 2
  /* If the call will go through a PLT entry then we do not need
     glue.  */
d2884 11
a2894 1
    return stub_type;
d2898 7
d2911 3
a2913 1
	  || ((st_type != STT_ARM_TFUNC) && !globals->use_blx))
d6071 2
a6072 1
	 branches in this object should go to it.  */
d6074 2
a6075 1
           && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI)
a6231 5
	  from = (input_section->output_section->vma
		  + input_section->output_offset
		  + rel->r_offset);
	  branch_offset = (bfd_signed_vma)(value - from);

d6263 15
@


1.177
log
@	bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_any_any_pic): Rename
	to elf32_arm_stub_long_branch_any_arm_pic.
	(elf32_arm_stub_long_branch_any_thumb_pic): New.
	(enum elf32_arm_stub_type, arm_type_of_stub)
	(arm_size_one_stub): Handle any to ARM PIC and any to Thumb PIC
	separately.

	ld/testsuite/
	* ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
	ld-arm/farcall-arm-thumb-pic-veneer.d,
	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d: Update for fixed
	Thumb PIC stub.
@
text
@a2020 7
enum stub_reloc_type
  {
    STUB_RELOC_NONE = 0,
    STUB_RELOC_ABS,
    STUB_RELOC_PIC,
  };

d2031 1
a2031 1
  enum stub_reloc_type reloc_type;
d2106 33
d2153 3
d2828 2
d2906 2
a2907 2
		       /* not yet supported on V4T.  */
		       : arm_stub_none)
d2919 2
a2920 2
		    /* PIC stub not yet supported on V4T.  */
		    ? arm_stub_none
d2943 2
a2944 2
		   /* not yet supported on V4T.  */
		   : arm_stub_none)
d2985 6
a2990 1
		? arm_stub_long_branch_any_thumb_pic
d3246 1
a3246 1
	  if (template[i].reloc_type == R_ARM_JUMP24)
d3280 1
a3280 1
  _bfd_final_link_relocate (elf32_arm_howto_from_type (template[stub_reloc_idx].reloc_type),
d3310 1
a3310 2
      template_size = sizeof (elf32_arm_stub_long_branch_any_any) / sizeof (insn_sequence);

d3314 1
a3314 1
      template_size = sizeof (elf32_arm_stub_long_branch_v4t_arm_thumb) / sizeof (insn_sequence);
d3318 1
a3318 1
      template_size = sizeof (elf32_arm_stub_long_branch_thumb_only) / sizeof (insn_sequence);
d3322 1
a3322 1
      template_size = sizeof (elf32_arm_stub_long_branch_v4t_thumb_arm) / sizeof (insn_sequence);
d3326 1
a3326 1
      template_size = sizeof (elf32_arm_stub_short_branch_v4t_thumb_arm) / sizeof (insn_sequence);
d3330 1
a3330 1
      template_size = sizeof (elf32_arm_stub_long_branch_any_arm_pic) / sizeof (insn_sequence);
d3334 13
a3346 1
      template_size = sizeof (elf32_arm_stub_long_branch_any_thumb_pic) / sizeof (insn_sequence);
d4697 1
a4697 2
	      if (ELF_ST_TYPE (h->type) == STT_ARM_TFUNC
		  && !(r_type == R_ARM_CALL && globals->use_blx))
@


1.176
log
@2009-02-24  Joseph Myers  <joseph@@codesourcery.com>

	bfd/
	* elf32-arm.c (PREV_SEC): Update comment.
	(group_sections): Rename argument to stubs_always_after_branch.
	Reverse the list and place stubs at the end of input sections.
	Undefine NEXT_SEC.
	(elf32_arm_size_stubs): Update to use stubs_always_after_branch.

	ld/
	* ld.texinfo (ARM): Document changed meaning of --stub-group-size.
	* emultempl/armelf.em (hook_in_stub): Insert after the input section.
	(elf32_arm_add_stub_section): Update comment.
	(PARSE_AND_LIST_OPTIONS): Update help for --stub-group-size.

2009-02-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp (armeabitests): Update duplicate test names.
	Use normal output files for big-endian.
	* ld-arm/farcall-arm-arm-be.d, ld-arm/farcall-thumb-arm-be.d: Delete.
	* ld-arm/farcall-arm-arm-be8.d, ld-arm/farcall-arm-arm-pic-veneer.d,
	ld-arm/farcall-arm-arm.d, ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
	ld-arm/farcall-arm-thumb-blx.d, ld-arm/farcall-arm-thumb-pic-veneer.d,
	ld-arm/farcall-arm-thumb.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-group.d, ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
	ld-arm/farcall-thumb-arm-be8.d,
	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
	ld-arm/farcall-thumb-arm-blx.d, ld-arm/farcall-thumb-arm-short.d,
	ld-arm/farcall-thumb-arm.d,
	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d,
	ld-arm/farcall-thumb-thumb-blx.d, ld-arm/farcall-thumb-thumb-m.d,
	ld-arm/farcall-thumb-thumb.d, ld-arm/thumb2-bl-as-thumb1-bad.d,
	ld-arm/thumb2-bl-bad.d: Update for moved stubs.
@
text
@d2092 1
a2092 1
/* ARM/Thumb -> ARM/Thumb long branch stub, PIC. On V5T and above, use
d2094 1
a2094 1
static const insn_sequence elf32_arm_stub_long_branch_any_any_pic[] =
d2101 12
d2125 2
a2126 1
  arm_stub_long_branch_any_any_pic,
d2874 1
a2874 1
		       ? arm_stub_long_branch_any_any_pic
d2911 1
a2911 1
		   ? arm_stub_long_branch_any_any_pic
d2954 1
a2954 1
		? arm_stub_long_branch_any_any_pic
d2971 1
a2971 1
		? arm_stub_long_branch_any_any_pic
d3293 7
a3299 3
    case arm_stub_long_branch_any_any_pic:
      template = elf32_arm_stub_long_branch_any_any_pic;
      template_size = sizeof (elf32_arm_stub_long_branch_any_any_pic) / sizeof (insn_sequence);
@


1.175
log
@	* elf32-arm.c (arm_build_one_stub): Initialize stub_reloc_offset.
	Fix formatting.
	(arm_size_one_stub): Remove unnecessary break.
	(arm_map_one_stub): Fix formatting.  Return after BFD_FAIL.
@
text
@d3420 1
a3420 1
	     which is what we want.  */
d3429 1
a3429 1
   put all .init* and .fini* stubs at the beginning of the .init or
d3437 1
a3437 1
		bfd_boolean stubs_always_before_branch)
d3439 1
a3439 1
  asection **list = htab->input_list + htab->top_index;
d3444 2
d3450 18
a3467 1
      while (tail != NULL)
d3470 1
a3470 1
	  asection *prev;
d3473 4
a3476 4
	  curr = tail;
	  total = tail->size;
	  while ((prev = PREV_SEC (curr)) != NULL
		 && ((total += curr->output_offset - prev->output_offset)
d3478 1
a3478 1
	    curr = prev;
d3480 1
a3480 1
	  /* OK, the size from the start of CURR to the end is less
d3482 1
a3482 1
	     section.  (Or the tail section is itself larger than
d3489 1
a3489 1
	      prev = PREV_SEC (tail);
d3491 1
a3491 1
	      htab->stub_group[tail->id].link_sec = curr;
d3493 1
a3493 1
	  while (tail != curr && (tail = prev) != NULL);
d3496 2
a3497 2
	     bytes before the stub section can be handled by it too.  */
	  if (!stubs_always_before_branch)
d3500 2
a3501 2
	      while (prev != NULL
		     && ((total += tail->output_offset - prev->output_offset)
d3504 3
a3506 3
		  tail = prev;
		  prev = PREV_SEC (tail);
		  htab->stub_group[tail->id].link_sec = curr;
d3509 1
a3509 1
	  tail = prev;
d3512 1
a3512 1
  while (list-- != htab->input_list);
d3516 1
d3534 1
a3534 1
  bfd_boolean stubs_always_before_branch;
d3547 1
a3547 1
  stubs_always_before_branch = group_size < 0;
d3567 1
a3567 1
  group_sections (htab, stub_group_size, stubs_always_before_branch);
@


1.174
log
@2009-02-23  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (stub_insn_type): New type.
	(stub_reloc_type): Likewise.
	(insn_sequence): Likewise.
	(elf32_arm_stub_long_branch_any_any): Encode using insn_sequence.
	(elf32_arm_stub_long_branch_v4t_arm_thumb): Likewise.
	(elf32_arm_stub_long_branch_thumb_only): Likewise.
	(elf32_arm_stub_long_branch_v4t_thumb_arm): Likewise.
	(elf32_arm_stub_short_branch_v4t_thumb_arm): Likewise.
	(elf32_arm_stub_long_branch_any_any_pic): Likewise.
	(elf32_arm_stub_hash_entry): Add new helper fields.
	(stub_hash_newfunc): Initialize these new fields.
	(arm_build_one_stub): Encode Arm and Thumb instructions separately
	to take endianness into account.
	(arm_size_one_stub): Compute size of stubs using insn_sequence.
	(arm_map_one_stub): Code is now more generic, thanks to
	insn_sequence.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new farcall-thumb-arm-be8 test.
	* ld-arm/farcall-thumb-arm-be8.d: New expected result.
	* ld-arm/farcall-arm-arm-be8.d: Replace wildcards by instructions.
@
text
@d3154 1
a3154 1
  int stub_reloc_offset;
d3186 1
a3186 1
      switch(template[i].type)
a3286 1
      break;
d3292 1
a3292 1
      switch(template[i].type)
d11718 1
a11718 1
  switch(template[0].type)
d11731 1
d11738 1
a11738 1
      switch(template[i].type)
d11754 1
d11764 1
a11764 1
      switch(template[i].type)
d11780 1
@


1.173
log
@2009-02-23  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_thumb_only): Fix stub
	code.
	(elf32_arm_stub_long_branch_v4t_thumb_arm): Likewise.
	(arm_type_of_stub): Use Thumb-only long branch stub (non-PIC) when
	BLX is not available. Fix typo in warning message. Add comments
	and improve formatting.
	(arm_build_one_stub): Adjust to new
	elf32_arm_stub_long_branch_v4t_thumb_arm stub.
	(arm_map_one_stub): Likewise.

	testsuite/
	* ld-arm/arm-elf.exp: Rewrite non-EABI variants of
	thumb2-bl-as-thumb1-bad and thumb2-bl-bad tests, which now
	pass. farcall-thumb-thumb now passes in EABI mode.
	* ld-arm/farcall-thumb-arm-pic-veneer.d: Fixed name, source, as
	and ld flags to match intended test.
	* ld-arm/farcall-thumb-arm.d: New expected result.
	* ld-arm/farcall-thumb-thumb-m.d: Likewise.
	* ld-arm/farcall-thumb-thumb-m-pic-veneer.d: Fixed name and ld
	flags.
	* ld-arm/farcall-thumb-thumb-pic-veneer.d: Likewise.
	* ld-arm/farcall-thumb-thumb.d: New expected result, this test is
	now expected to pass.
	* ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d: Likewise.
	* ld-arm/thumb2-bl-bad-noeabi.d: Likewise.
	* ld-arm/thumb2-bl-as-thumb1-bad.d: Update addresses according to
	new use.
	* ld-arm/thumb2-bl-as-thumb1-bad.s: Update comment.
@
text
@d2013 29
d2044 1
a2044 1
static const bfd_vma elf32_arm_stub_long_branch_any_any[] =
d2046 2
a2047 2
    0xe51ff004,         /* ldr   pc, [pc, #-4] */
    0x00000000,         /* dcd   R_ARM_ABS32(X) */
d2052 1
a2052 1
static const bfd_vma elf32_arm_stub_long_branch_v4t_arm_thumb[] =
d2054 3
a2056 3
    0xe59fc000,         /* ldr   ip, [pc, #0] */
    0xe12fff1c,         /* bx    ip */
    0x00000000,         /* dcd   R_ARM_ABS32(X) */
d2062 1
a2062 1
static const bfd_vma elf32_arm_stub_long_branch_thumb_only[] =
d2064 7
a2070 7
    0x4802b401,         /* push {r0} */
                        /* ldr  r0, [pc, #8] */
    0xbc014684,         /* mov  ip, r0 */
                        /* pop  {r0} */
    0xbf004760,         /* bx   ip */
                        /* nop */
    0x00000000,         /* dcd  R_ARM_ABS32(X) */
d2075 1
a2075 1
static const bfd_vma elf32_arm_stub_long_branch_v4t_thumb_arm[] =
d2077 4
a2080 4
    0x46c04778,         /* bx   pc */
                        /* nop   */
    0xe51ff004,         /* ldr   pc, [pc, #-4] */
    0x00000000,         /* dcd   R_ARM_ABS32(X) */
d2085 1
a2085 1
static const bfd_vma elf32_arm_stub_short_branch_v4t_thumb_arm[] =
d2087 3
a2089 3
    0x46c04778,         /* bx   pc */
                        /* nop   */
    0xea000000,         /* b    (X) */
d2094 1
a2094 1
static const bfd_vma elf32_arm_stub_long_branch_any_any_pic[] =
d2096 3
a2098 3
    0xe59fc000,         /* ldr   r12, [pc] */
    0xe08ff00c,         /* add   pc, pc, ip */
    0x00000000,         /* dcd   R_ARM_REL32(X-4) */
d2132 1
d2134 6
d2508 3
d3150 1
a3150 1
  const bfd_vma *template;
d3153 2
d3180 2
a3181 30
  switch (stub_entry->stub_type)
    {
    case arm_stub_long_branch_any_any:
      template = elf32_arm_stub_long_branch_any_any;
      template_size = (sizeof (elf32_arm_stub_long_branch_any_any) / sizeof (bfd_vma)) * 4;
      break;
    case arm_stub_long_branch_v4t_arm_thumb:
      template =  elf32_arm_stub_long_branch_v4t_arm_thumb;
      template_size = (sizeof (elf32_arm_stub_long_branch_v4t_arm_thumb) / sizeof (bfd_vma)) * 4;
      break;
    case arm_stub_long_branch_thumb_only:
      template =  elf32_arm_stub_long_branch_thumb_only;
      template_size = (sizeof (elf32_arm_stub_long_branch_thumb_only) / sizeof (bfd_vma)) * 4;
      break;
    case arm_stub_long_branch_v4t_thumb_arm:
      template =  elf32_arm_stub_long_branch_v4t_thumb_arm;
      template_size = (sizeof (elf32_arm_stub_long_branch_v4t_thumb_arm) / sizeof (bfd_vma)) * 4;
      break;
    case arm_stub_short_branch_v4t_thumb_arm:
      template =  elf32_arm_stub_short_branch_v4t_thumb_arm;
      template_size = (sizeof(elf32_arm_stub_short_branch_v4t_thumb_arm) / sizeof (bfd_vma)) * 4;
      break;
    case arm_stub_long_branch_any_any_pic:
      template = elf32_arm_stub_long_branch_any_any_pic;
      template_size = (sizeof (elf32_arm_stub_long_branch_any_any_pic) / sizeof (bfd_vma)) * 4;
      break;
    default:
      BFD_FAIL ();
      return FALSE;
    }
d3184 1
a3184 1
  for (i = 0; i < (template_size / 4); i++)
d3186 25
a3210 6
      /* A 0 pattern is a placeholder, every other pattern is an
	 instruction.  */
      if (template[i] != 0)
	put_arm_insn (globals, stub_bfd, template[i], loc + size);
      else
	bfd_put_32 (stub_bfd, template[i], loc + size);
d3212 4
a3215 1
      size += 4;
d3217 1
d3220 4
d3228 2
a3229 28
  switch (stub_entry->stub_type)
    {
    case arm_stub_long_branch_any_any:
      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
				stub_bfd, stub_sec, stub_sec->contents,
				stub_entry->stub_offset + 4, sym_value, 0);
      break;
    case arm_stub_long_branch_v4t_arm_thumb:
      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
				stub_bfd, stub_sec, stub_sec->contents,
				stub_entry->stub_offset + 8, sym_value, 0);
      break;
    case arm_stub_long_branch_thumb_only:
      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
				stub_bfd, stub_sec, stub_sec->contents,
				stub_entry->stub_offset + 12, sym_value, 0);
      break;
    case arm_stub_long_branch_v4t_thumb_arm:
      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
				stub_bfd, stub_sec, stub_sec->contents,
				stub_entry->stub_offset + 8, sym_value, 0);
      break;
    case arm_stub_short_branch_v4t_thumb_arm:
      {
	long int rel_offset;
	static const insn32 t2a3_b_insn = 0xea000000;

	rel_offset = sym_value - (stub_addr + 8 + 4);
d3231 4
a3234 17
	put_arm_insn (globals, stub_bfd,
		      (bfd_vma) t2a3_b_insn | ((rel_offset >> 2) & 0x00FFFFFF),
		      loc + 4);
      }
      break;

    case arm_stub_long_branch_any_any_pic:
      /* We want the value relative to the address 8 bytes from the
	 start of the stub.  */
      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_REL32),
				stub_bfd, stub_sec, stub_sec->contents,
				stub_entry->stub_offset + 8, sym_value, -4);
      break;
    default:
      BFD_FAIL();
      break;
    }
d3248 1
a3248 1
  const bfd_vma *template;
d3261 2
a3262 1
      template_size = (sizeof (elf32_arm_stub_long_branch_any_any) / sizeof (bfd_vma)) * 4;
d3266 1
a3266 1
      template_size = (sizeof (elf32_arm_stub_long_branch_v4t_arm_thumb) / sizeof (bfd_vma)) * 4;
d3270 1
a3270 1
      template_size = (sizeof (elf32_arm_stub_long_branch_thumb_only) / sizeof (bfd_vma)) * 4;
d3274 1
a3274 1
      template_size = (sizeof (elf32_arm_stub_long_branch_v4t_thumb_arm) / sizeof (bfd_vma)) * 4;
d3278 1
a3278 1
      template_size = (sizeof(elf32_arm_stub_short_branch_v4t_thumb_arm) / sizeof (bfd_vma)) * 4;
d3282 1
a3282 1
      template_size = (sizeof (elf32_arm_stub_long_branch_any_any_pic) / sizeof (bfd_vma)) * 4;
d3291 26
a3316 2
  for (i = 0; i < (template_size / 4); i++)
      size += 4;
d3319 1
d11695 5
d11718 2
a11719 1
  switch (stub_entry->stub_type)
d11721 2
a11722 32
    case arm_stub_long_branch_any_any:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 8))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 4))
	return FALSE;
      break;
    case arm_stub_long_branch_v4t_arm_thumb:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 12))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
	return FALSE;
      break;
    case arm_stub_long_branch_thumb_only:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 16))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 12))
	return FALSE;
      break;
    case arm_stub_long_branch_v4t_thumb_arm:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 20))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 4))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
d11725 3
a11727 14
    case arm_stub_short_branch_v4t_thumb_arm:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr | 1, 8))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_THUMB, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 4))
	return FALSE;
      break;
    case arm_stub_long_branch_any_any_pic:
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr, 12))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 8))
d11734 48
@


1.172
log
@2009-02-18  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (arm_build_one_stub): Fix relocation target for pic
	stub. Catch default case error.
	(arm_map_one_stub): Add missing Thumb mapping symbol.

	testsuite/
	* ld-arm/farcall-arm-arm-pic-veneer.d,
	ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
	ld-arm/farcall-arm-thumb-pic-veneer.d,
	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d: Fix expected stub
	target.
@
text
@d2035 5
a2039 5
    0x4e02b540,         /* push {r6, lr} */
                        /* ldr  r6, [pc, #8] */
    0x473046fe,         /* mov  lr, pc */
                        /* bx   r6 */
    0xbf00bd40,         /* pop  {r6, pc} */
d2048 4
a2051 7
    0x4e03b540,         /* push {r6, lr} */
                        /* ldr  r6, [pc, #12] */
    0x473046fe,         /* mov  lr, pc */
                        /* bx   r6 */
    0xe8bd4040,         /* pop  {r6, pc} */
    0xe12fff1e,         /* bx   lr */
    0x00000000,         /* dcd  R_ARM_ABS32(X) */
d2819 1
d2821 1
d2823 1
d2825 7
a2831 3
		    : (globals->use_blx)
		    ? arm_stub_long_branch_any_any
		    : arm_stub_none;
d2836 1
d2838 2
a2839 3
		    : (globals->use_blx)
		    ? arm_stub_long_branch_thumb_only
		    : arm_stub_none;
d2856 1
d2858 1
d2860 1
d2862 7
a2868 3
		: (globals->use_blx)
		? arm_stub_long_branch_any_any
		: arm_stub_long_branch_v4t_thumb_arm;
d2890 1
a2890 1
		   "  first occurrence: %B: Thumb call to ARM"),
d2901 1
d2903 6
a2908 3
		: (globals->use_blx)
		? arm_stub_long_branch_any_any
		: arm_stub_long_branch_v4t_arm_thumb;
d2918 1
d2920 1
d3208 1
a3208 1
				stub_entry->stub_offset + 16, sym_value, 0);
d11717 1
a11717 1
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr + 8))
d11719 1
a11719 1
      if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 16))
@


1.171
log
@2009-02-16  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (arm_long_branch_stub,
	arm_thumb_v4t_long_branch_stub,
	arm_thumb_thumb_long_branch_stub,
	arm_thumb_arm_v4t_long_branch_stub,
	arm_thumb_arm_v4t_short_branch_stub,
	arm_pic_long_branch_stub):
	Renamed to elf32_arm_stub_long_branch_any_any,
	elf32_arm_stub_long_branch_v4t_arm_thumb,
	elf32_arm_stub_long_branch_thumb_only,
	elf32_arm_stub_long_branch_v4t_thumb_arm,
	elf32_arm_stub_short_branch_v4t_thumb_arm,
	elf32_arm_stub_long_branch_any_any_pic.
	(arm_stub_long_branch, arm_thumb_v4t_stub_long_branch,
	arm_thumb_thumb_stub_long_branch,
	arm_thumb_arm_v4t_stub_long_branch,
	arm_thumb_arm_v4t_stub_short_branch, arm_stub_pic_long_branch):
	Renamed to arm_stub_long_branch_any_any,
	arm_stub_long_branch_v4t_arm_thumb,
	arm_stub_long_branch_thumb_only,
	arm_stub_long_branch_v4t_thumb_arm,
	arm_stub_short_branch_v4t_thumb_arm,
	arm_stub_long_branch_any_any_pic.
@
text
@d2072 1
a2072 1
    0x00000000,         /* dcd   R_ARM_REL32(X) */
d3211 1
a3211 1
				stub_entry->stub_offset + 8, sym_value, 0);
d3214 1
d11708 2
@


1.170
log
@2009-01-30  Julian Brown  <julian@@codesourcery.com>

	* elf32-arm.c (bfd_elf32_arm_vfp11_erratum_scan): Skip BFDs with
	EXEC_P or DYNAMIC flags, and skip sections which are being linked
	with --just-symbols (-R).
@
text
@d2013 3
a2015 1
static const bfd_vma arm_long_branch_stub[] =
d2021 3
a2023 1
static const bfd_vma arm_thumb_v4t_long_branch_stub[] =
d2030 4
a2033 1
static const bfd_vma arm_thumb_thumb_long_branch_stub[] =
d2044 3
a2046 1
static const bfd_vma arm_thumb_arm_v4t_long_branch_stub[] =
d2057 3
a2059 1
static const bfd_vma arm_thumb_arm_v4t_short_branch_stub[] =
d2066 3
a2068 1
static const bfd_vma arm_pic_long_branch_stub[] =
d2082 6
a2087 6
  arm_stub_long_branch,
  arm_thumb_v4t_stub_long_branch,
  arm_thumb_thumb_stub_long_branch,
  arm_thumb_arm_v4t_stub_long_branch,
  arm_thumb_arm_v4t_stub_short_branch,
  arm_stub_pic_long_branch,
d2747 3
a2749 3
    case arm_thumb_thumb_stub_long_branch:
    case arm_thumb_arm_v4t_stub_long_branch:
    case arm_thumb_arm_v4t_stub_short_branch:
d2823 1
a2823 1
		       ? arm_stub_pic_long_branch
d2826 1
a2826 1
		    ? arm_stub_long_branch
d2834 1
a2834 1
		    ? arm_thumb_thumb_stub_long_branch
d2853 1
a2853 1
		   ? arm_stub_pic_long_branch
d2856 2
a2857 2
		? arm_stub_long_branch
		: arm_thumb_arm_v4t_stub_long_branch;
d2860 1
a2860 1
	      if ((stub_type == arm_thumb_arm_v4t_stub_long_branch)
d2863 1
a2863 1
		stub_type = arm_thumb_arm_v4t_stub_short_branch;
d2890 1
a2890 1
		? arm_stub_pic_long_branch
d2892 2
a2893 2
		? arm_stub_long_branch
		: arm_thumb_v4t_stub_long_branch;
d2903 2
a2904 2
		? arm_stub_pic_long_branch
		: arm_stub_long_branch;
d3124 3
a3126 3
    case arm_stub_long_branch:
      template = arm_long_branch_stub;
      template_size = (sizeof (arm_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3128 3
a3130 3
    case arm_thumb_v4t_stub_long_branch:
      template =  arm_thumb_v4t_long_branch_stub;
      template_size = (sizeof (arm_thumb_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3132 3
a3134 3
    case arm_thumb_thumb_stub_long_branch:
      template =  arm_thumb_thumb_long_branch_stub;
      template_size = (sizeof (arm_thumb_thumb_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3136 3
a3138 3
    case arm_thumb_arm_v4t_stub_long_branch:
      template =  arm_thumb_arm_v4t_long_branch_stub;
      template_size = (sizeof (arm_thumb_arm_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3140 3
a3142 3
    case arm_thumb_arm_v4t_stub_short_branch:
      template =  arm_thumb_arm_v4t_short_branch_stub;
      template_size = (sizeof(arm_thumb_arm_v4t_short_branch_stub) / sizeof (bfd_vma)) * 4;
d3144 3
a3146 3
    case arm_stub_pic_long_branch:
      template = arm_pic_long_branch_stub;
      template_size = (sizeof (arm_pic_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3173 1
a3173 1
    case arm_stub_long_branch:
d3178 1
a3178 1
    case arm_thumb_v4t_stub_long_branch:
d3183 1
a3183 1
    case arm_thumb_thumb_stub_long_branch:
d3188 1
a3188 1
    case arm_thumb_arm_v4t_stub_long_branch:
d3193 1
a3193 1
    case arm_thumb_arm_v4t_stub_short_branch:
d3206 1
a3206 1
    case arm_stub_pic_long_branch:
d3240 3
a3242 3
    case arm_stub_long_branch:
      template =  arm_long_branch_stub;
      template_size = (sizeof (arm_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3244 3
a3246 3
    case arm_thumb_v4t_stub_long_branch:
      template =  arm_thumb_v4t_long_branch_stub;
      template_size = (sizeof (arm_thumb_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3248 3
a3250 3
    case arm_thumb_thumb_stub_long_branch:
      template =  arm_thumb_thumb_long_branch_stub;
      template_size = (sizeof (arm_thumb_thumb_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3252 3
a3254 3
    case arm_thumb_arm_v4t_stub_long_branch:
      template =  arm_thumb_arm_v4t_long_branch_stub;
      template_size = (sizeof (arm_thumb_arm_v4t_long_branch_stub) / sizeof (bfd_vma)) * 4;
d3256 3
a3258 3
    case arm_thumb_arm_v4t_stub_short_branch:
      template =  arm_thumb_arm_v4t_short_branch_stub;
      template_size = (sizeof(arm_thumb_arm_v4t_short_branch_stub) / sizeof (bfd_vma)) * 4;
d3260 3
a3262 3
    case arm_stub_pic_long_branch:
      template = arm_pic_long_branch_stub;
      template_size = (sizeof (arm_pic_long_branch_stub) / sizeof (bfd_vma)) * 4;
d11670 1
a11670 1
    case arm_stub_long_branch:
d11678 1
a11678 1
    case arm_thumb_v4t_stub_long_branch:
d11686 1
a11686 1
    case arm_thumb_thumb_stub_long_branch:
d11694 1
a11694 1
    case arm_thumb_arm_v4t_stub_long_branch:
d11704 1
a11704 1
    case arm_thumb_arm_v4t_stub_short_branch:
d11710 1
a11710 1
    case arm_stub_pic_long_branch:
@


1.169
log
@        * elf32-arm.c (elf32_arm_check_relocs): Set SEC_ALLOC and
        SEC_LOAD for dynamic relocation sections.
@
text
@d5001 4
d5015 2
@


1.168
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (vendor_set_obj_attr_contents): Support tag ordering.
	* elf-bfd.h (elf_backend_data): Add obj_attrs_order.
	* elf32-arm.c (elf32_arm_obj_attrs_order): New function.
	(elf_backend_obj_attrs_order): New define.
	* elfxx-target.h (elf_backend_obj_attrs_order): New define.
	(elfNN_bed): Add elf_backend_obj_attrs_order.

	gas/testsuite/
	* gas/arm/attr-order.d: New file.
	* gas/arm/attr-order.s: New file.
@
text
@d9646 1
a9646 1
			flags &= ~(SEC_LOAD | SEC_ALLOC);
@


1.167
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (is_default_attr): Substitute magic numbers with macros.
	(obj_attr_size): Likewise.
	(write_obj_attribute): Likewise.
	(_bfd_elf_copy_obj_attributes): Likewise.
	(_bfd_elf_parse_attributes): Likewise.
	* elf-bfd.h (ATTR_TYPE_FLAG_INT_VAL): New define.
	(ATTR_TYPE_FLAG_STR_VAL, ATTR_TYPE_FLAG_NO_DEFAULT): New defines.
	(ATTR_TYPE_HAS_INT_VAL, ATTR_TYPE_HAS_STR_VAL): New defines.
	(ATTR_TYPE_HAS_NO_DEFAULT): New define.
	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Replace magic numbers
	with macros.
@
text
@d8152 18
d12313 1
@


1.166
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (is_default_attr): Support defaultless attributes.
	(bfd_elf_add_obj_attr_int): Get type from _bfd_elf_obj_attrs_arg_type.
	(bfd_elf_add_obj_attr_string): Likewise.
	(bfd_elf_add_obj_attr_int_string): Likewise.
	(_bfd_elf_parse_attributes): Allow for unknown flag bits in type.
	* elf-bfd.h (struct obj_attribute): Document new flag bit.
	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Specify that
	Tag_nodefaults has no default value.
	(elf32_arm_merge_eabi_attributes): Modify the Tag_nodefaults
	comment to reflect the new state.

	gas/
	* read.c (s_vendor_attribute): Allow for unknown flag bits in type.
@
text
@d8141 1
a8141 1
    return 3;
d8143 3
a8145 3
    return 5;
  else if (tag == 4 || tag == 5)
    return 2;
d8147 1
a8147 1
    return 1;
d8149 1
a8149 1
    return (tag & 1) != 0 ? 2 : 1;
@


1.165
log
@2009-01-15  Andrew Stubbs  <ams@@codesourcery.com>
	    Julian Brown   <julian@@codesourcery.com>

	bfd/
	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 71 to include all known
	ARM attributes in ABI 2.07.
	* elf32-arm.c (get_secondary_compatible_arch): New function.
	(set_secondary_compatible_arch): New function.
	(tag_cpu_arch_combine): New function.
	(elf32_arm_copy_one_eabi_other_attribute): Delete function.
	(elf32_arm_copy_eabi_other_attribute_list): Delete function.
	(elf32_arm_merge_eabi_attributes): Rename order_312 to order_021 to
	make it fit with order_01243.
	Add support for Tag_also_compatible_with,
	Tag_CPU_unaligned_access, Tag_T2EE_use, Tag_Virtualization_use,
	Tag_MPextension_use, Tag_nodefaults and Tag_conformance.
	Improve/tidy up support for Tag_CPU_raw_name, Tag_CPU_name,
	Tag_CPU_arch, Tag_ABI_HardFP_use, Tag_VFP_HP_extension,
	Tag_ABI_FP_denormal, Tag_ABI_PCS_GOT_use, Tag_ABI_align8_needed,
	Tag_VFP_arch and Tag_ABI_FP_16bit_format.
	Rework the way unknown attributes are handled.
	Defer errors until all attributes have been processed.

	gas/
	* config/tc-arm.c (cpu_arch): Change ARM_ARCH_V6M to 11.

	include/elf/
	* arm.h (TAG_CPU_ARCH_V6_M, TAG_CPU_ARCH_V6S_M): New defines.
	(MAX_TAG_CPU_ARCH, TAG_CPU_ARCH_V4T_PLUS_V6_M): New defines.
	(Tag_NEON_arch): Rename to Tag_Advanced_SIMD_arch to match ARM ABI
	version 2.07.
	(Tag_undefined39, Tag_nodefaults): New enum values.
	(Tag_also_compatible_with, Tag_T2EE_use): Likewise.
	(Tag_conformance, Tag_Virtualization_use): Likewise.
	(Tag_undefined69, Tag_MPextension_use): Likewise.
@
text
@d8142 2
d8680 4
a8683 5
	  /* This tag is set if it exists, but the value is unused.
	     Unfortunately, we don't record whether each attribute is zero
	     initialized, or read from the file, so the information has been
	     lost.  In any case, we don't write attributes with zero values.
	     Do nothing. */
@


1.164
log
@2009-01-15  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	Read Tag_compatibility from its new location in the attribute array,
	rather than the attribute list.
	(_bfd_elf_copy_obj_attributes): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
	(_bfd_elf_parse_attributes): Likewise.
	(_bfd_elf_merge_object_attributes): There's now only one
	Tag_compatibility, and it's in the array, not the list.
	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 33 to include
	Tag_compatibility.
	(bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	(bfd_elf_add_proc_attr_compat): Rename to
	bfd_elf_add_proc_attr_int_string.
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Explicitly don't handle
	Tag_compatibility.

	gas/
	* read.c (s_vendor_attribute): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
@
text
@d8150 24
d8175 1
a8175 1
elf32_arm_copy_one_eabi_other_attribute (bfd *ibfd, bfd *obfd, obj_attribute_list *in_list)
d8177 4
a8180 1
  switch (in_list->tag)
d8182 3
a8184 4
    case Tag_VFP_HP_extension:
    case Tag_ABI_FP_16bit_format:
      bfd_elf_add_obj_attr_int (obfd, OBJ_ATTR_PROC, in_list->tag, in_list->attr.i);
      break;
d8186 7
a8192 8
    default:
      if ((in_list->tag & 127) < 64)
	{
	  _bfd_error_handler
	      (_("Warning: %B: Unknown EABI object attribute %d"), ibfd, in_list->tag);
	  break;
	}
    }
d8195 6
a8200 2
static void 
elf32_arm_copy_eabi_other_attribute_list (bfd *ibfd, bfd *obfd, obj_attribute_list *in_list)
d8202 149
a8350 2
  for (; in_list; in_list = in_list->next )
    elf32_arm_copy_one_eabi_other_attribute (ibfd, obfd, in_list);
d8363 1
d8366 1
a8366 1
  static const int order_312[3] = {3, 1, 2};
d8370 1
d8397 1
a8397 1
	  return FALSE;
d8408 1
a8408 6
	  /* Use whichever has the greatest architecture requirements.  We
	     won't necessarily have both the above tags, so make sure input
	     name is non-NULL.  */
	  if (in_attr[Tag_CPU_arch].i > out_attr[Tag_CPU_arch].i
	      && in_attr[i].s)
	    out_attr[i].s = _bfd_elf_attr_strdup (obfd, in_attr[i].s);
d8417 59
d8479 2
a8480 2
	case Tag_NEON_arch:
	  /* ??? Do NEON and WMMX conflict?  */
a8481 1
	case Tag_ABI_FP_denormal:
d8485 5
a8489 2
	case Tag_ABI_align8_preserved:
	case Tag_ABI_HardFP_use:
d8495 32
d8528 1
a8528 2
	  /* Warn if conflicting architecture profiles used.  */
	  if (out_attr[i].i && in_attr[i].i && in_attr[i].i != out_attr[i].i)
d8530 21
a8550 4
	      _bfd_error_handler
		(_("ERROR: %B: Conflicting architecture profiles %c/%c"),
		 ibfd, in_attr[i].i, out_attr[i].i);
	      return FALSE;
a8551 2
	  if (in_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
d8554 5
a8558 2
	  if (in_attr[i].i > 4 || out_attr[i].i > 4
	      || order_01243[in_attr[i].i] > order_01243[out_attr[i].i])
d8579 1
a8579 1
	      return FALSE;
d8592 1
a8592 1
	      return FALSE;
a8597 10
	case Tag_ABI_PCS_RO_data:
	  /* Use the smallest value specified.  */
	  if (in_attr[i].i < out_attr[i].i)
	    out_attr[i].i = in_attr[i].i;
	  break;
	case Tag_ABI_PCS_GOT_use:
	  if (in_attr[i].i > 2 || out_attr[i].i > 2
	      || order_312[in_attr[i].i] < order_312[out_attr[i].i])
	    out_attr[i].i = in_attr[i].i;
	  break;
a8608 6
	case Tag_ABI_align8_needed:
	  /* ??? Check against Tag_ABI_align8_preserved.  */
	  if (in_attr[i].i > 2 || out_attr[i].i > 2
	      || order_312[in_attr[i].i] < order_312[out_attr[i].i])
	    out_attr[i].i = in_attr[i].i;
	  break;
d8623 1
a8623 1
		  const char *aeabi_enum_names[] =
d8625 8
d8635 1
a8635 2
		     ibfd, aeabi_enum_names[in_attr[i].i],
		     aeabi_enum_names[out_attr[i].i]);
d8648 1
a8648 1
	      return FALSE;
a8650 1

d8654 22
d8677 17
a8693 3
	default: /* All known attributes should be explicitly covered.   */
	  abort ();
	}
d8695 1
a8695 2
      if (in_attr[i].type && !out_attr[i].type)
	switch (in_attr[i].type)
d8697 8
a8704 4
	  case 1:
	    if (out_attr[i].i)
	      out_attr[i].type = 1;
	    break;
d8706 18
a8723 4
	  case 2:
	    if (out_attr[i].s)
	      out_attr[i].type = 2;
	    break;
d8725 9
a8733 2
	  default:
	    abort ();
d8735 5
d8747 2
a8748 1
  out_list = elf_other_obj_attributes_proc (obfd);
d8750 1
a8750 1
  for (; in_list != NULL; )
d8752 2
a8753 5
      if (out_list == NULL)
	{
	  elf32_arm_copy_eabi_other_attribute_list (ibfd, obfd, in_list);
	  return TRUE;
	}
d8757 35
a8791 3
      if (in_list->tag == out_list->tag)
        {
	  switch (in_list->tag)
d8793 3
a8795 27
	    case Tag_VFP_HP_extension:
	      if (out_list->attr.i == 0)
	    	out_list->attr.i = in_list->attr.i;
	      break;

	    case Tag_ABI_FP_16bit_format:
	      if (in_list->attr.i != 0 && out_list->attr.i != 0)
		{
	          if (in_list->attr.i != out_list->attr.i)
	            {
		      _bfd_error_handler
		        (_("ERROR: fp16 format mismatch between %B and %B"),
		         ibfd, obfd);
		      return FALSE;
	            }
		}
	      if (in_list->attr.i != 0)
		out_list->attr.i = in_list->attr.i;
	      break;

	    default:
	      if ((in_list->tag & 127) < 64)
	        {
	          _bfd_error_handler
		    (_("Warning: %B: Unknown EABI object attribute %d"), ibfd, in_list->tag);
	          break;
	        }
d8798 2
a8799 1
      else if (in_list->tag < out_list->tag)
d8801 15
a8815 9
	  /* This attribute is in ibfd, but not obfd.  Copy to obfd and advance to
            next input attribute.  */
	  elf32_arm_copy_one_eabi_other_attribute (ibfd, obfd, in_list);
	}
      if (in_list->tag <= out_list->tag)
	{
	  in_list = in_list->next;
	  if (in_list == NULL)
	    continue;
a8816 2
      while (out_list && out_list->tag < in_list->tag)
        out_list = out_list->next;
d8818 1
a8818 1
  return TRUE;
@


1.163
log
@        PR 7093
        * elf32-arm.c (bfd_elf32_arm_init_maps): Only process ARM ELF
        object files.
@
text
@d8378 4
a8408 3
  while (in_list && in_list->tag == Tag_compatibility)
    in_list = in_list->next;

a8409 2
  while (out_list && out_list->tag == Tag_compatibility)
    out_list = out_list->next;
@


1.162
log
@Remove STT_IFUNC support.
@
text
@d4611 4
@


1.161
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a9432 1
	case STT_IFUNC:
d9558 1
a9558 1
  if (h->type == STT_FUNC || h->type == STT_ARM_TFUNC || h->type == STT_IFUNC
d11732 1
a11732 2
  if ((ELF_ST_TYPE (dst->st_info) == STT_FUNC
       || ELF_ST_TYPE (dst->st_info) == STT_IFUNC)
d11833 1
a11833 1
  return (type == STT_FUNC) || (type == STT_ARM_TFUNC) || (type == STT_IFUNC);
@


1.160
log
@bfd:
	* elf32-arm.c (elf32_arm_final_link_relocate): Do not turn
	branches to undefine weak symbols into branches to the next
	instruction if creating PLT entries for those symbols.

ld/testsuite:
	* ld-arm/thumb2-bl-undefweak.d, ld-arm/thumb2-bl-undefweak.s: New.
	* ld-arm/arm-elf.exp: Run thumb2-bl-undefweak test.
@
text
@d9433 1
d9559 1
a9559 1
  if (h->type == STT_FUNC || h->type == STT_ARM_TFUNC
d11733 2
a11734 1
  if (ELF_ST_TYPE (dst->st_info) == STT_FUNC
d11835 1
a11835 1
  return (type == STT_FUNC) || (type == STT_ARM_TFUNC);
@


1.159
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d6363 3
a6365 2
	   the next instruction.  */
	if (h && h->root.type == bfd_link_hash_undefweak)
@


1.158
log
@Add support for ARM half-precision conversion instructions.
@
text
@a2468 13
/* Return true if NAME is the name of the relocation section associated
   with S.  */

static bfd_boolean
reloc_section_p (struct elf32_arm_link_hash_table *htab,
		 const char *name, asection *s)
{
  if (htab->use_rel)
    return CONST_STRNEQ (name, ".rel") && strcmp (s->name, name + 4) == 0;
  else
    return CONST_STRNEQ (name, ".rela") && strcmp (s->name, name + 5) == 0;
}

d5950 2
a5951 1
	      const char * name;
d5953 1
a5953 5
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd,
		       elf_elfheader (input_bfd)->e_shstrndx,
		       elf_section_data (input_section)->rel_hdr.sh_name));
	      if (name == NULL)
a5954 5

	      BFD_ASSERT (reloc_section_p (globals, name, input_section));

	      sreloc = bfd_get_section_by_name (dynobj, name);
	      BFD_ASSERT (sreloc != NULL);
d9260 1
a9260 1
	        if (sreloc == NULL)
d9262 2
a9263 1
		    const char * name;
d9265 1
a9265 5
		    name = (bfd_elf_string_from_elf_section
			    (abfd,
			     elf_elfheader (abfd)->e_shstrndx,
			     elf_section_data (sec)->rel_hdr.sh_name));
		    if (name == NULL)
d9268 2
a9269 4
		    BFD_ASSERT (reloc_section_p (htab, name, sec));

		    sreloc = bfd_get_section_by_name (dynobj, name);
		    if (sreloc == NULL)
d9271 1
a9271 1
		        flagword flags;
d9273 3
a9275 13
		        flags = (SEC_HAS_CONTENTS | SEC_READONLY
			         | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		        if ((sec->flags & SEC_ALLOC) != 0
			    /* BPABI objects never have dynamic
			       relocations mapped.  */
			    && !htab->symbian_p)
			  flags |= SEC_ALLOC | SEC_LOAD;
		        sreloc = bfd_make_section_with_flags (dynobj,
							      name,
							      flags);
		        if (sreloc == NULL
			    || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			  return FALSE;
a9276 2

		    elf_section_data (sec)->sreloc = sreloc;
@


1.157
log
@            * elf32-arm.c: Fix up comment describing Thumb to ARM interworking
            stub.
@
text
@d8166 27
d8202 1
d8227 1
a8227 1
      /* Ignore mismatches if teh object doesn't use floating point.  */
d8393 1
d8424 5
a8428 1
  for (; in_list; in_list = in_list->next)
d8430 42
a8471 1
      if ((in_list->tag & 128) < 64)
d8473 9
a8481 4
	  _bfd_error_handler
	    (_("Warning: %B: Unknown EABI object attribute %d"),
	     ibfd, in_list->tag);
	  break;
d8483 2
@


1.157.2.1
log
@Backport of:

bfd:
2008-11-24  Joseph Myers  <joseph@@codesourcery.com>

	* elf32-arm.c (elf32_arm_final_link_relocate): Do not turn
	branches to undefine weak symbols into branches to the next
	instruction if creating PLT entries for those symbols.

ld/testsuite:
2008-11-24  Joseph Myers  <joseph@@codesourcery.com>

	* ld-arm/thumb2-bl-undefweak.d, ld-arm/thumb2-bl-undefweak.s: New.
	* ld-arm/arm-elf.exp: Run thumb2-bl-undefweak test.
@
text
@d6384 2
a6385 3
	   the next instruction unless a PLT entry will be created.  */
	if (h && h->root.type == bfd_link_hash_undefweak
	    && !(splt != NULL && h->plt.offset != (bfd_vma) -1))
@


1.156
log
@bfd/
        * elf32-arm.c (arm_thumb_arm_v4t_short_branch_stub): Define.
        (elf32_arm_stub_type): Add arm_thumb_arm_v4t_stub_short_branch.
        (arm_type_of_stub): Handle armv4t short branches. Update
        prototype.
        (arm_stub_is_thumb): Handle arm_thumb_arm_v4t_stub_short_branch.
        (arm_build_one_stub): Likewise.
        (arm_size_one_stub): Likewise.
        (elf32_arm_size_stubs): Use new arm_type_of_stub prototype.
        (arm_map_one_stub): Handle arm_thumb_arm_v4t_stub_short_branch.

        ld/testsuite/
        * ld-arm/arm-elf.exp: Add farcall-thumb-arm-short test.
        * ld-arm/farcall-group2.s: Fix comment.
        * ld-arm/farcall-thumb-arm-short.d: New test.
        * ld-arm/farcall-thumb-arm-short.s: New test.
@
text
@d3916 4
a3919 3
 ;; back_to_thumb                       .arm
     ldmia r13! {r6, lr}                ldmia r13! {r6, lr}
     bx    lr  				bx    lr
@


1.155
log
@* elf32-arm.c: Tidy up the code.
  (bfd_elf32_arm_allocate_interworking_sections): Move common code
  into...
  (arm_allocate_glue_section_space): ... New function.
  (bfd_elf32_arm_add_glue_sections_to_bfd): Move common code
  into...
  (arm_make_glue_section): ... New function.
@
text
@d2048 7
d2073 1
d2749 1
d2768 4
a2771 1
		  bfd_vma destination)
d2841 10
d2858 6
d2872 13
a2884 2
	  /* We have an extra 2-bytes reach because of the mode change
	     (bit 24 (H) of BLX encoding).  */
d3140 4
d3193 13
d3256 4
d3666 2
a3667 1
						hash, destination);
d11269 6
@


1.154
log
@	* elf32-arm.c (arm_map_one_stub): Declare variables at beginning
	of block.
	* elf32-avr.c (get_local_syms): Likewise.
@
text
@d70 1
a70 1
  /* No relocation */
d1350 1
a1350 1
  EMPTY_HOWTO (90),   /* unallocated */
d1781 1
d1821 1
a1821 1
      case 148:		/* Linux/ARM 32-bit*/
d1848 1
a1848 1
      case 124:		/* Linux/ARM elf_prpsinfo */
d2248 1
a2248 1
     symbol. */
d2770 1
a2770 1
     type STT_SECTION: give up */
d3019 2
a3020 2
put_arm_insn (struct elf32_arm_link_hash_table *htab,
	     bfd * output_bfd, bfd_vma val, void * ptr)
d3032 2
a3033 2
put_thumb_insn (struct elf32_arm_link_hash_table *htab,
	       bfd * output_bfd, bfd_vma val, void * ptr)
d3720 1
a3720 1
      /* Ignore non-stub sections */
d3830 1
a3830 2
   .word func - .
   */
d3848 12
a3859 13
   .thumb                               .thumb
   .align 2                             .align 2
   __func_from_thumb:              __func_from_thumb:
   bx pc                                push {r6, lr}
   nop                                  ldr  r6, __func_addr
   .arm                                         mov  lr, pc
   __func_change_to_arm:                        bx   r6
   b func                       .arm
   __func_back_to_thumb:
   ldmia r13! {r6, lr}
   bx    lr
   __func_addr:
   .word        func  */
d3874 2
a3875 2
bfd_boolean
bfd_elf32_arm_allocate_interworking_sections (struct bfd_link_info * info)
d3878 1
a3878 2
  bfd_byte * foo;
  struct elf32_arm_link_hash_table * globals;
d3880 2
a3881 1
  globals = elf32_arm_hash_table (info);
d3883 1
a3883 1
  BFD_ASSERT (globals != NULL);
d3885 2
a3886 3
  if (globals->arm_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
d3888 1
a3888 2
      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
				   ARM2THUMB_GLUE_SECTION_NAME);
d3890 3
a3892 1
      BFD_ASSERT (s != NULL);
d3894 4
a3897 1
      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->arm_glue_size);
d3899 2
a3900 3
      BFD_ASSERT (s->size == globals->arm_glue_size);
      s->contents = foo;
    }
d3902 3
a3904 18
  if (globals->thumb_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name
	(globals->bfd_of_glue_owner, THUMB2ARM_GLUE_SECTION_NAME);

      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->thumb_glue_size);

      BFD_ASSERT (s->size == globals->thumb_glue_size);
      s->contents = foo;
    }

  if (globals->vfp11_erratum_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
d3906 7
a3912 2
      s = bfd_get_section_by_name
        (globals->bfd_of_glue_owner, VFP11_ERRATUM_VENEER_SECTION_NAME);
d3914 2
a3915 14
      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner,
		       globals->vfp11_erratum_glue_size);

      BFD_ASSERT (s->size == globals->vfp11_erratum_glue_size);
      s->contents = foo;
    }

  if (globals->bx_glue_size != 0)
    {
      BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

      s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
a3917 8
      BFD_ASSERT (s != NULL);

      foo = bfd_alloc (globals->bfd_of_glue_owner, globals->bx_glue_size);

      BFD_ASSERT (s->size == globals->bx_glue_size);
      s->contents = foo;
    }

a4069 2

  return;
d4283 31
a4320 3
  flagword flags;
  asection *sec;

d4326 1
a4326 1
  /* linker stubs don't need glue */
d4330 4
a4333 78
  sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      /* Note: we do not include the flag SEC_LINKER_CREATED, as this
	 will prevent elf_link_input_bfd() from processing the contents
	 of this section.  */
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);

      sec = bfd_make_section_with_flags (abfd,
					 ARM2THUMB_GLUE_SECTION_NAME,
					 flags);

      if (sec == NULL
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      /* Set the gc mark to prevent the section from being removed by garbage
	 collection, despite the fact that no relocs refer to this section.  */
      sec->gc_mark = 1;
    }

  sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);

      sec = bfd_make_section_with_flags (abfd,
					 THUMB2ARM_GLUE_SECTION_NAME,
					 flags);

      if (sec == NULL
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      sec->gc_mark = 1;
    }

  sec = bfd_get_section_by_name (abfd, VFP11_ERRATUM_VENEER_SECTION_NAME);

  if (sec == NULL)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);

      sec = bfd_make_section_with_flags (abfd,
					 VFP11_ERRATUM_VENEER_SECTION_NAME,
                                         flags);

      if (sec == NULL
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      sec->gc_mark = 1;
    }

  sec = bfd_get_section_by_name (abfd, ARM_BX_GLUE_SECTION_NAME);

  if (sec == NULL)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_CODE | SEC_READONLY);

      sec = bfd_make_section_with_flags (abfd,
					 ARM_BX_GLUE_SECTION_NAME,
                                         flags);

      if (sec == NULL
	  || !bfd_set_section_alignment (abfd, sec, 2))
	return FALSE;

      sec->gc_mark = 1;
    }

  return TRUE;
d4338 1
a4338 1
   {armelf/pe}.em  */
d5365 2
a5366 2
			     asection		    *s,
			     char **error_message)
d5441 2
d5545 1
d5598 2
a5599 1
  if (!link_info)
d5614 1
d5763 1
a5763 1
			       char **error_message)
d6013 1
a6013 1
	case R_ARM_PC24:	  /* Arm B/BL instruction */
d6053 1
a6053 1
	     destination is too far or we are changing mode */
d6135 1
a6135 1
		     case, mode switching is performed by the stub. */
d6178 1
a6178 1
	      /* Check for overflow */
d6375 10
a6384 9
		else if (r_type != R_ARM_THM_CALL) {
		  if (elf32_thumb_to_arm_stub
		    (info, sym_name, input_bfd, output_bfd, input_section,
		     hit_data, sym_sec, rel->r_offset, signed_addend, value,
		     error_message))
		  return bfd_reloc_ok;
		else
		  return bfd_reloc_dangerous;
	      }
d6415 1
a6415 1
	       is too far. */
d7939 1
a7939 1
	      /* fall through */
d8398 1
a8398 1
      _bfd_error_handler (_("ERROR: %B is already in final BE8 format"), 
d9029 1
a9029 1
	    /* Fall through */
d9034 1
a9034 1
	    /* Fall through */
d9052 1
a9052 1
	    /* Fall through */
d9892 1
a9892 1
elf32_arm_readonly_dynrelocs (struct elf_link_hash_entry *h, PTR inf)
d9894 2
a9895 2
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_relocs_copied *p;
d10180 2
a10181 2
	elf_link_hash_traverse (&htab->root, elf32_arm_readonly_dynrelocs,
				(PTR) info);
d10610 1
a10610 1
	      /* Fall through */
d10699 1
a10699 1
	      /* Generate a relocation for _GLOBAL_OFFSET_TABLE_. */
d11144 2
a11145 2
arm_map_one_stub (struct bfd_hash_entry *gen_entry,
		  PTR in_arg)
d11298 3
a11300 2
  /* Long calls stubs. */
  if (htab->stub_bfd && htab->stub_bfd->sections) {
d11302 1
d11305 5
a11309 1
	   stub_sec = stub_sec->next) {
d11311 1
a11311 3
	/* Ignore non-stub sections */
	if (!strstr(stub_sec->name, STUB_SUFFIX))
	  continue;
d11313 2
a11314 1
	osi.sec = stub_sec;
d11316 3
a11318 6
	osi.sec_shndx = _bfd_elf_section_from_bfd_section
	  (output_bfd, osi.sec->output_section);

	bfd_hash_traverse (&htab->stub_hash_table, arm_map_one_stub, &osi);
      }
  }
d11325 1
a11325 1
      htab->splt->output_section);
d11405 2
a11406 1
			 struct bfd_link_info *link_info, asection *sec,
d12010 1
a12010 1
#undef elf32_bed
@


1.153
log
@bfd:
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add new parameter.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (struct elf_arm_obj_tdata): Add field
	no_wchar_size_warning.
	(bfd_elf32_arm_set_target_relocs): Add new parameter
	no_wchar_warn.
	(elf32_arm_merge_eabi_attributes): Give a warning, not an error,
	for conflicting wchar_t attributes.  Do not warn if
	--no-wchar-size-warning.  Make diagnostic text more specific.

ld:
	* ld.texinfo (--no-wchar-size-warning): Document new ARM option.
	* emultempl/armelf.em (no_wchar_size_warning): New.
	(arm_elf_create_output_section_statements): Pass
	no_wchar_size_warning to arm_elf_create_output_section_statements.
	(OPTION_NO_WCHAR_SIZE_WARNING): New.
	(PARSE_AND_LIST_LONGOPTS): Add no-wchar-size-warning.
	(PARSE_AND_LIST_OPTIONS): List --no-wchar-size-warning.
	(PARSE_AND_LIST_ARGS_CASES): Handle --no-wchar-size-warning.

ld/testsuite:
	* ld-arm/attr-merge-wchar-0.s,ld-arm/attr-merge-wchar-2.s,
	ld-arm/attr-merge-wchar-4.s, ld-arm/attr-merge-wchar-00-nowarn.d,
	ld-arm/attr-merge-wchar-00.d, ld-arm/attr-merge-wchar-02-nowarn.d,
	ld-arm/attr-merge-wchar-02.d, ld-arm/attr-merge-wchar-04-nowarn.d,
	ld-arm/attr-merge-wchar-04.d, ld-arm/attr-merge-wchar-20-nowarn.d,
	ld-arm/attr-merge-wchar-20.d, ld-arm/attr-merge-wchar-22-nowarn.d,
	ld-arm/attr-merge-wchar-22.d, ld-arm/attr-merge-wchar-24-nowarn.d,
	ld-arm/attr-merge-wchar-24.d, ld-arm/attr-merge-wchar-40-nowarn.d,
	ld-arm/attr-merge-wchar-40.d, ld-arm/attr-merge-wchar-42-nowarn.d,
	ld-arm/attr-merge-wchar-42.d, ld-arm/attr-merge-wchar-44-nowarn.d,
	ld-arm/attr-merge-wchar-44.d: New.
	* ld-arm/arm-elf.exp: Run new tests.
@
text
@d11224 1
d11228 1
a11229 1
  output_arch_syminfo *osi = (output_arch_syminfo *) in_arg;
@


1.152
log
@2008-07-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/6748
	* elf32-arm.c (elf32_arm_link_hash_table_create): Initialize
	new fields added for ARM long call support.
@
text
@d2170 3
d5277 2
a5278 1
				 int no_enum_warn, int pic_veneer)
d5303 1
d8323 2
a8324 1
	  if (out_attr[i].i && in_attr[i].i && out_attr[i].i != in_attr[i].i)
d8327 2
a8328 2
		(_("ERROR: %B: Conflicting definitions of wchar_t"), ibfd);
	      return FALSE;
d8330 1
a8330 1
	  if (in_attr[i].i)
@


1.151
log
@        * elf32-arm.c (arm_type_of_stub): Don't crash on local symbols in
        the presence of a PLT.
@
text
@d2672 7
@


1.150
log
@	* elf32-arm.c (record_arm_to_thumb_glue, record_thumb_to_arm_glue):
	Expand comments.
	(arm_map_one_stub): Use | 1 when setting the low bit.
@
text
@d2780 1
a2780 1
  if (globals->splt != NULL && hash->root.plt.offset != (bfd_vma) -1)
@


1.149
log
@	* elf32-arm.c (STUB_ENTRY_NAME): Define.
	(arm_thumb_thumb_long_branch_stub): Use bx instead of b.n.
	(arm_pic_long_branch_stub): Mention R_ARM_REL32 instead of
	R_ARM_ABS32.
	(struct elf32_arm_stub_hash_entry): Add output_name.
	(arm_build_one_stub): Move offsets into the offset argument
	of _bfd_final_link_relocate.  Correct offset for
	arm_thumb_arm_v4t_stub_long_branch.
	(elf32_arm_size_stubs): Set stub_entry->output_name.
	(elf32_arm_ouput_plt_map_sym): Rename to elf32_arm_output_map_sym.
	Update all callers.
	(elf32_arm_output_stub_sym): New.
	(arm_map_one_stub): Correct formatting.  Use elf32_arm_output_stub_sym.

	* ld-arm/farcall-arm-arm-be8.d, ld-arm/farcall-arm-arm-pic-veneer.d,
	ld-arm/farcall-arm-arm.d, ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
	ld-arm/farcall-arm-thumb-blx.d, ld-arm/farcall-arm-thumb-pic-veneer.d,
	ld-arm/farcall-arm-thumb.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-group.d, ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
	ld-arm/farcall-thumb-arm-blx.d, ld-arm/farcall-thumb-arm.d,
	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d,
	ld-arm/farcall-thumb-thumb-blx.d, ld-arm/farcall-thumb-thumb-m.d,
	ld-arm/thumb2-bl-as-thumb1-bad.d, ld-arm/thumb2-bl-bad.d: Update for
	stub symbols and stub corrections.
@
text
@d3984 2
a3985 1
     putting it.  */
d4051 4
d11248 1
a11248 1
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr + 1, 16))
d11256 1
a11256 1
      if (!elf32_arm_output_stub_sym (osi, stub_name, addr + 1, 20))
@


1.148
log
@2008-06-09  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_merge_private_bfd_data): Allow BE8 shared
	libraries.
@
text
@d1901 2
d2029 2
a2030 2
    0xe7fe46fe,         /* mov  lr, pc */
                        /* b.n  r6 */
d2051 1
a2051 1
    0x00000000,         /* dcd   R_ARM_ABS32(X) */
d2095 5
d3121 2
a3122 2
				stub_bfd, stub_sec, stub_sec->contents + 4,
				stub_entry->stub_offset, sym_value, 0);
d3126 2
a3127 2
				stub_bfd, stub_sec, stub_sec->contents + 8,
				stub_entry->stub_offset, sym_value, 0);
d3131 2
a3132 2
				stub_bfd, stub_sec, stub_sec->contents + 12,
				stub_entry->stub_offset, sym_value, 0);
d3136 2
a3137 2
				stub_bfd, stub_sec, stub_sec->contents + 20,
				stub_entry->stub_offset, sym_value, 0);
d3142 3
a3144 5
      sym_value -= stub_addr + 8;

      _bfd_final_link_relocate (elf32_arm_howto_from_type (R_ARM_ABS32),
				stub_bfd, stub_sec, stub_sec->contents + 8,
				stub_entry->stub_offset, sym_value, 0);
d3492 1
d3520 1
d3549 4
d3590 1
d3629 27
d11072 1
a11072 1
/* Output a single PLT mapping symbol.  */
d11075 3
a11077 3
elf32_arm_ouput_plt_map_sym (output_arch_syminfo *osi,
			     enum map_symbol_type type,
			     bfd_vma offset)
d11125 1
a11125 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11127 1
a11127 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 4))
d11132 1
a11132 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11134 1
a11134 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 8))
d11136 1
a11136 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr + 12))
d11138 1
a11138 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 20))
d11151 1
a11151 1
	  if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_THUMB, addr - 4))
d11155 1
a11155 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11157 1
a11157 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 12))
d11165 1
a11165 1
	  if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11174 21
d11205 1
d11217 1
a11217 1
     processed */
d11221 2
a11222 1
  addr = (bfd_vma)stub_entry->stub_offset;
d11224 2
a11225 1
  switch(stub_entry->stub_type) {
d11227 1
a11227 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11229 3
a11231 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 4))
d11235 3
a11237 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11239 1
a11239 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 8))
d11243 1
a11243 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_THUMB, addr))
d11245 3
a11247 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 12))
d11251 3
a11253 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_THUMB, addr))
d11255 1
a11255 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr + 8))
d11257 1
a11257 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 16))
d11261 3
a11263 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
d11265 1
a11265 1
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 8))
d11270 1
a11270 1
  }
d11316 2
a11317 2
	  elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, offset);
	  elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_DATA, offset + size - 4);
d11333 2
a11334 2
	  elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_THUMB, offset);
	  elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, offset + 4);
d11347 1
a11347 1
      elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, 0);
d11384 1
a11384 1
	  if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, 0))
d11386 1
a11386 1
	  if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_DATA, 12))
d11392 1
a11392 1
      if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, 0))
d11395 1
a11395 1
      if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_DATA, 16))
@


1.147
log
@2008-06-03  Christophe Lyon  <christophe.lyon@@st.com>

	bfd/
	* elf32-arm.c (arm_stub_is_thumb): Define.
	(elf32_arm_final_link_relocate): Handle near mode switching stubs.

	ld/testsuite/
	* ld-arm/farcall-thumb-thumb-m.d: Fix branch type.
	* ld-arm/farcall-thumb-arm.d: Likewise.
@
text
@d8409 1
@


1.146
log
@2008-06-06  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_merge_private_bfd_data): Reject BE8 input.
@
text
@d2716 17
d6446 2
a6447 1
		     || (branch_offset < THM2_MAX_BWD_BRANCH_OFFSET))))
d6460 8
a6467 2
		/* This call becomes a call to Arm for sure. Force BLX.  */
		lower_insn = (lower_insn & ~0x1000) | 0x0800;
@


1.145
log
@        bfd/
        * elf32-arm.c (arm_type_of_stub): Ignore STT_SECTION symbols.
        (elf32_arm_stub_add_mapping_symbol): Remove.
        (elf32_arm_add_stub): Don't generate mapping symbols. Change
        prototype.
        (elf32_arm_size_stubs): Use new elf32_arm_add_stub
        prototype. Don't generate thumb to arm glue for calls.
        (arm_map_one_stub): Define.
        (elf32_arm_output_arch_local_syms): Generate mapping symbols for
        long calls stubs.

        ld/testsuite/
        * ld-arm/farcall-arm-arm.s: Force function type on 'bar'.
        * ld-arm/farcall-thumb-arm.s: Likewise.
        * ld-arm/farcall-thumb-arm-blx.d: Fix encoding.
        * ld-arm/farcall-thumb-arm.d: Likewise.
        * ld-arm/farcall-thumb-arm-blx-pic-veneer.d: Likewise.
        * ld-arm/arm-elf.exp (armelftests): Add farcall-mix, farcall-mix2,
        farcall-group-default, farcall-group-size2, farcall-section Ignore
        gas warnings in farcall-thumb-arm, farcall-thumb-arm-blx,
        farcall-thumb-arm-blx-pic-veneer.
@
text
@d8381 11
@


1.144
log
@        Multi-GOT support for m68k.

        bfd/

        * elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
        glist): New fields.
        (struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
        struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
        struct elf_m68k_multi_got): New data structures.
        (struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
        allow_multigot_p, multi_got_): New fields.
        (elf_m68k_multi_got): New macro.
        (elf_m68k_link_hash_newfunc): Initialize new fields of
        struct elf_m68k_link_hash_entry.
        (elf_m68k_link_hash_table_create): Initialize new fields of
        struct elf_m68k_link_hash_table.
        (elf_m68k_link_hash_table_free): New static function implementing hook.
        (elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
        static functions for struct elf_m68k_got.
        (elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
        elf_m68k_got_entry_eq): New static functions for
        struct elf_m68k_got_entry.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
        ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
        (enum elf_m68k_get_entry_howto): New enum.
        (elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
        elf_m68k_remove_got_entry_type): New static functions for
        struct elf_m68k_got_entry.
        (elf_m68k_add_entry_to_got): New static function.
        (elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
        elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
        functions for struct elf_m68k_bfd2got_entry.
        (struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
        elf_m68k_can_merge_gots): New traversal.
        (struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
        elf_m68k_merge_gots): Ditto.
        (struct elf_m68k_finalize_got_offsets_arg,
        elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
        (struct elf_m68k_partition_multi_got_arg,
        elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
        elf_m68k_partition_multi_got): Ditto.
        (elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
        functions.
        (elf_m68k_copy_indirect_symbol): New static function implementing
        a hook.
        (elf_m68k_check_relocs): Update to add entries to multi-GOT.
        (elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
        (elf_m68k_always_size_sections): Assign BFDs to GOTs.
        (elf_m68k_relocate_section): Update to properly handle GOT relocations.
        (elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
        of a global symbol.
        (bfd_elf_m68k_set_target_options): New function.
        (bfd_elf32_bfd_link_hash_table_free): Define hook.
        (bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
        to skip generic calculation of GOT offsets.
        (elf_backend_copy_indirect_symbol): Define hook.

        * bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
        * bfd-in2.h: Regenerate.

        ld/

        * configure.in (--enable-got): New option.  Handle it.
        * configure: Regenerate.
        * config.in: Regenerate.

        * emultempl/m68kelf.em: (got_handling_target_default): New shell
        variable.
        (GOT_HANDLING_TARGET_DEFAULT): New macro.
        (GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
        option if one was given.
        (got_handling): New static variable.
        (elf_m68k_create_output_section_statements): New static function
        implementing hook.
        (PARSE_AND_LIST_PROLOGUE): Define shell variable.
        (OPTION_GOT): New macro.
        (PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
        --got option.
        (got): New linker option.
        (PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
        for --got option.
        (PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
        option.

        * ld.texinfo: Document --got=<type> option.
        * gen-doc.texi: Add M68K.
        * NEWS: Mention the new feature.

        ld/testsuite/

        * ld-m68k/got-12.s: New file.
        * ld-m68k/got-13.s: New file.
        * ld-m68k/got-14.s: New file.
        * ld-m68k/got-15.s: New file.
        * ld-m68k/got-34.s: New file.
        * ld-m68k/got-35.s: New file.
        * ld-m68k/got-single-12-ok.d: New dump test.
        * ld-m68k/got-single-13-er.d: New dump test.
        * ld-m68k/got-negative-14-ok.d: New dump test.
        * ld-m68k/got-negative-15-er.d: New dump test.
        * ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
        * ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
        * ld-m68k/got-multigot-14-ok.d: New dump test.
        * ld-m68k/got-multigot-15-er.d: New dump test.
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
        * ld-m68k/xgot-15.s: New source.
        * ld-m68k/got-xgot-15-ok.d: New test.
        * ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
        * ld-m68k/m68k.exp: Run new tests.
@
text
@d2236 1
a2236 1
  /* A pointer to the most recently used stub hash entry against this
d2238 1
a2238 1
  struct elf32_arm_stub_hash_entry *stub_cache;
d2734 5
a2922 18
static void elf32_arm_stub_add_mapping_symbol (struct bfd_link_info * link_info,
					       asection *stub_sec,
					       char* name,
					       bfd_vma val)
{
  struct bfd_link_hash_entry * bh = NULL;
  struct elf_link_hash_entry * myh;

  _bfd_generic_link_add_one_symbol (link_info,
				    stub_sec->owner, name,
				    BSF_LOCAL, stub_sec, stub_sec->size + val,
				    NULL, TRUE, FALSE, &bh);

  myh = (struct elf_link_hash_entry *) bh;
  myh->type = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
  myh->forced_local = 1;
}

d2929 1
a2929 3
		    struct elf32_arm_link_hash_table *htab,
		    struct bfd_link_info * link_info,
		    enum elf32_arm_stub_type stub_type)
a2976 27
  switch (stub_type)
    {
    case arm_stub_long_branch:
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$a", 0);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$d", 4);
      break;
    case arm_thumb_v4t_stub_long_branch:
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$a", 0);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$d", 8);
      break;
    case arm_thumb_thumb_stub_long_branch:
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$t", 0);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$d", 12);
      break;
    case arm_thumb_arm_v4t_stub_long_branch:
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$t", 0);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$a", 8);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$d", 16);
      break;
    case arm_stub_pic_long_branch:
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$a", 0);
      elf32_arm_stub_add_mapping_symbol (link_info, stub_sec, "$d", 8);
      break;
    default:
      BFD_FAIL ();
  }

d3588 1
a3588 1
		  stub_entry = elf32_arm_add_stub (stub_name, section, htab, info, stub_type);
d6374 2
a6375 1
		else if (elf32_thumb_to_arm_stub
d6383 1
d11100 66
d11241 20
@


1.143
log
@        bfd/
        * elf32-arm.c (THM2_MAX_FWD_BRANCH_OFFSET): Define.
        (THM2_MAX_BWD_BRANCH_OFFSET): Define.
        (ARM_MAX_FWD_BRANCH_OFFSET): Define.
        (ARM_MAX_BWD_BRANCH_OFFSET): Define.
        (THM_MAX_FWD_BRANCH_OFFSET): Define.
        (THM_MAX_BWD_BRANCH_OFFSET): Define.
        (arm_long_branch_stub): Define.
        (arm_pic_long_branch_stub): Define.
        (arm_thumb_v4t_long_branch_stub): Define.
        (arm_thumb_thumb_long_branch_stub): Define.
        (arm_thumb_arm_v4t_long_branch_stub): Define.
        (STUB_SUFFIX): Define.
        (elf32_arm_stub_type): Define.
        (elf32_arm_stub_hash_entry): Define.
        (elf32_arm_link_hash_entry): Add stub_cache field.
        (arm_stub_hash_lookup): Define.
        (elf32_arm_link_hash_table): Add stub_hash_table, stub_bfd,
        add_stub_section, layout_sections_again, stub_group, bfd_count,
        top_index, input_list fields.
        (elf32_arm_link_hash_newfunc): Init new field.
        (stub_hash_newfunc): New function.
        (elf32_arm_link_hash_table_create): Init stub_hash_table.
        (elf32_arm_hash_table_free): New function.
        (arm_type_of_stub): New function.
        (elf32_arm_stub_name): New function.
        (elf32_arm_get_stub_entry): New function.
        (elf32_arm_stub_add_mapping_symbol): New function.
        (elf32_arm_add_stub): New function.
        (arm_build_one_stub): New function.
        (arm_size_one_stub): New function.
        (elf32_arm_setup_section_lists): New function.
        (elf32_arm_next_input_section): New function.
        (group_sections): New function.
        (elf32_arm_size_stubs): New function.
        (elf32_arm_build_stubs): New function.
        (bfd_elf32_arm_add_glue_sections_to_bfd): Skip stub sections.
        (bfd_elf32_arm_process_before_allocation): No longer handle
        R_ARM_CALL and R_ARM_THM_CALL.
        (using_thumb_only): New function.
        (elf32_arm_final_link_relocate): Redirect calls to stub if range
        exceeds encoding capabilities.
        (bfd_elf32_bfd_link_hash_table_free): Define.
        * bfd-in.h (R_ARM_max): Fix value to 130.
        (elf32_arm_setup_section_lists): Protype.
        (elf32_arm_next_input_section): Protype.
        (elf32_arm_size_stubs): Protype.
        (elf32_arm_build_stubs): Protype.

        ld/
        * emultempl/armelf.em (build_section_lists): New function.
        (stub_file): Define.
        (need_laying_out): Define.
        (group_size): Define.
        (hook_stub_info): Define.
        (hook_in_stub): New function.
        (elf32_arm_add_stub_section): New function.
        (gldarm_layout_sections_again): New function.
        (gld${EMULATION_NAME}_finish): Replace arm_elf_finish(). Generate
        stubs for long calls if needed.
        (arm_elf_create_output_section_statements): create stub_file bfd.
        (arm_for_each_input_file_wrapper): New function.
        (arm_lang_for_each_input_file): New function.
        (lang_for_each_input_file): Define.
        (PARSE_AND_LIST_PROLOGUE): Add option token OPTION_STUBGROUP_SIZE.
        (PARSE_AND_LIST_LONGOPTS): Add option stub-group-size.
        (PARSE_AND_LIST_OPTIONS): Add option stub-group-size.
        (PARSE_AND_LIST_ARGS_CASES): Add OPTION_STUBGROUP_SIZE case.
        (LDEMUL_FINISH): Update to gld${EMULATION_NAME}_finish.
        * ld/lang.c (print_input_statement): Skip if bfd has
        BFD_LINKER_CREATED.

        ld/testsuite
        * ld-arm/arm-elf.exp (armelftests): Add farcall-arm-arm,
        farcall-arm-arm-pic-veneer, farcall-arm-arm-be8 farcall-arm-thumb,
        farcall-arm-thumb-blx, farcall-arm-thumb-pic-veneer,
        farcall-arm-thumb-blx-pic-veneer, farcall-thumb-thumb,
        farcall-thumb-thumb-pic-veneer, farcall-thumb-thumb-blx,
        farcall-thumb-thumb-m, farcall-thumb-thumb-m-pic-veneer,
        farcall-thumb-thumb-blx-pic-veneer, farcall-thumb-arm,
        farcall-thumb-arm-pic-veneer, farcall-thumb-arm-blx,
        farcall-thumb-arm-blx-pic-veneer.
        Change thumb2-bl-as-thumb1-bad, thumb2-bl-bad.
        * ld-arm/thumb2-bl-as-thumb1-bad.d: Reflects farcall stub
        generation.
        * ld-arm/thumb2-bl-bad.d: Likewise.
        * ld-arm/thumb2-bl-as-thumb1-bad.s: Update comments.
        * ld-arm/thumb2-bl-bad.s: Likewise.
@
text
@d3368 1
a3368 1
	     section.  (or the tail section is itself larger than
d3372 1
a3372 1
	     section size. */
@


1.142
log
@	* elf32-arm.c (elf32_arm_symbian_link_hash_table_create): Use
	ARRAY_SIZE.
	(elf32_arm_symbian_plt_sym_val): New.
	(elf_backend_plt_sym_val): Define.
@
text
@a29 4
#ifndef NUM_ELEM
#define NUM_ELEM(a)  (sizeof (a) / (sizeof (a)[0]))
#endif

d1667 1
a1667 1
  if (r_type < NUM_ELEM (elf32_arm_howto_table_1))
d1671 1
a1671 1
      && r_type < R_ARM_RREL32 + NUM_ELEM (elf32_arm_howto_table_2))
d1781 1
a1781 1
  for (i = 0; i < NUM_ELEM (elf32_arm_reloc_map); i ++)
d1794 1
a1794 4
  for (i = 0;
       i < (sizeof (elf32_arm_howto_table_1)
	    / sizeof (elf32_arm_howto_table_1[0]));
       i++)
d1799 1
a1799 4
  for (i = 0;
       i < (sizeof (elf32_arm_howto_table_2)
	    / sizeof (elf32_arm_howto_table_2[0]));
       i++)
d1807 2
a1808 1
/* Support for core dump NOTE sections */
a1856 1

d1997 1
a1997 1
static const bfd_vma elf32_arm_symbian_plt_entry [] = 
d2003 92
d2235 4
d2252 4
d2258 12
a2269 3
  {
    /* The main hash table.  */
    struct elf_link_hash_table root;
d2271 3
a2273 2
    /* The size in bytes of the section containing the Thumb-to-ARM glue.  */
    bfd_size_type thumb_glue_size;
d2275 3
a2277 2
    /* The size in bytes of the section containing the ARM-to-Thumb glue.  */
    bfd_size_type arm_glue_size;
d2279 2
a2280 2
    /* The size in bytes of section containing the ARMv4 BX veneers.  */
    bfd_size_type bx_glue_size;
d2282 2
a2283 3
    /* Offsets of ARMv4 BX veneers.  Bit1 set if present, and Bit0 set when
       veneer has been populated.  */
    bfd_vma bx_glue_offset[15];
d2285 3
a2287 3
    /* The size in bytes of the section containing glue for VFP11 erratum
       veneers.  */
    bfd_size_type vfp11_erratum_glue_size;
d2289 2
a2290 2
    /* An arbitrary input BFD chosen to hold the glue sections.  */
    bfd * bfd_of_glue_owner;
d2292 4
a2295 2
    /* Nonzero to output a BE8 image.  */
    int byteswap_code;
d2297 2
a2298 3
    /* Zero if R_ARM_TARGET1 means R_ARM_ABS32.
       Nonzero if R_ARM_TARGET1 means R_ARM_REL32.  */
    int target1_is_rel;
d2300 3
a2302 2
    /* The relocation to use for R_ARM_TARGET2 relocations.  */
    int target2_reloc;
d2304 2
a2305 4
    /* 0 = Ignore R_ARM_V4BX.
       1 = Convert BX to MOV PC.
       2 = Generate v4 interworing stubs.  */
    int fix_v4bx;
d2307 2
a2308 2
    /* Nonzero if the ARM/Thumb BLX instructions are available for use.  */
    int use_blx;
d2310 2
a2311 3
    /* What sort of code sequences we should look for which may trigger the
       VFP11 denorm erratum.  */
    bfd_arm_vfp11_fix vfp11_fix;
d2313 2
a2314 2
    /* Global counter for the number of fixes we have emitted.  */
    int num_vfp11_fixes;
d2316 2
a2317 2
    /* Nonzero to force PIC branch veneers.  */
    int pic_veneer;
d2319 2
a2320 2
    /* The number of bytes in the initial entry in the PLT.  */
    bfd_size_type plt_header_size;
d2322 2
a2323 2
    /* The number of bytes in the subsequent PLT etries.  */
    bfd_size_type plt_entry_size;
d2325 8
a2332 2
    /* True if the target system is VxWorks.  */
    int vxworks_p;
d2334 2
a2335 2
    /* True if the target system is Symbian OS.  */
    int symbian_p;
d2337 6
a2342 2
    /* True if the target uses REL relocations.  */
    int use_rel;
d2344 2
a2345 8
    /* Short-cuts to get to dynamic linker sections.  */
    asection *sgot;
    asection *sgotplt;
    asection *srelgot;
    asection *splt;
    asection *srelplt;
    asection *sdynbss;
    asection *srelbss;
d2347 2
a2348 2
    /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */
    asection *srelplt2;
d2350 9
a2358 8
    /* Data for R_ARM_TLS_LDM32 relocations.  */
    union {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;
    
    /* Small local sym to section mapping cache.  */
    struct sym_sec_cache sym_sec;
d2360 16
a2375 3
    /* For convenience in allocate_dynrelocs.  */
    bfd * obfd;
  };
d2389 1
a2389 1
  if (ret == (struct elf32_arm_link_hash_entry *) NULL)
d2406 2
d2413 37
d2541 1
a2541 1
  if (!htab->splt 
d2550 1055
a3604 1
/* Copy the extra info we tack onto an elf_link_hash_entry.  */
d3606 23
a3628 6
static void
elf32_arm_copy_indirect_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *dir,
				struct elf_link_hash_entry *ind)
{
  struct elf32_arm_link_hash_entry *edir, *eind;
d3630 6
a3635 2
  edir = (struct elf32_arm_link_hash_entry *) dir;
  eind = (struct elf32_arm_link_hash_entry *) ind;
d3637 7
a3643 12
  if (eind->relocs_copied != NULL)
    {
      if (edir->relocs_copied != NULL)
	{
	  struct elf32_arm_relocs_copied **pp;
	  struct elf32_arm_relocs_copied *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->relocs_copied; (p = *pp) != NULL; )
	    {
	      struct elf32_arm_relocs_copied *q;
d3645 3
a3647 10
	      for (q = edir->relocs_copied; q != NULL; q = q->next)
		if (q->section == p->section)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
a3648 1
	  *pp = edir->relocs_copied;
d3651 15
a3665 2
      edir->relocs_copied = eind->relocs_copied;
      eind->relocs_copied = NULL;
d3668 1
a3668 7
  if (ind->root.type == bfd_link_hash_indirect)
    {
      /* Copy over PLT info.  */
      edir->plt_thumb_refcount += eind->plt_thumb_refcount;
      eind->plt_thumb_refcount = 0;
      edir->plt_maybe_thumb_refcount += eind->plt_maybe_thumb_refcount;
      eind->plt_maybe_thumb_refcount = 0;
d3670 2
a3671 8
      if (dir->got.refcount <= 0)
	{
	  edir->tls_type = eind->tls_type;
	  eind->tls_type = GOT_UNKNOWN;
	}
    }

  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
d3674 5
a3678 1
/* Create an ARM elf linker hash table.  */
d3680 2
a3681 2
static struct bfd_link_hash_table *
elf32_arm_link_hash_table_create (bfd *abfd)
d3683 3
a3685 2
  struct elf32_arm_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf32_arm_link_hash_table);
d3687 1
a3687 3
  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
d3689 3
a3691 3
  if (!_bfd_elf_link_hash_table_init (& ret->root, abfd,
				      elf32_arm_link_hash_newfunc,
				      sizeof (struct elf32_arm_link_hash_entry)))
d3693 12
a3704 2
      free (ret);
      return NULL;
d3707 3
a3709 34
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->srelplt2 = NULL;
  ret->thumb_glue_size = 0;
  ret->arm_glue_size = 0;
  ret->bx_glue_size = 0;
  memset (ret->bx_glue_offset, 0, sizeof(ret->bx_glue_offset));
  ret->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
  ret->vfp11_erratum_glue_size = 0;
  ret->num_vfp11_fixes = 0;
  ret->bfd_of_glue_owner = NULL;
  ret->byteswap_code = 0;
  ret->target1_is_rel = 0;
  ret->target2_reloc = R_ARM_NONE;
#ifdef FOUR_WORD_PLT
  ret->plt_header_size = 16;
  ret->plt_entry_size = 16;
#else
  ret->plt_header_size = 20;
  ret->plt_entry_size = 12;
#endif
  ret->fix_v4bx = 0;
  ret->use_blx = 0;
  ret->vxworks_p = 0;
  ret->symbian_p = 0;
  ret->use_rel = 1;
  ret->sym_sec.abfd = NULL;
  ret->obfd = abfd;
  ret->tls_ldm_got.refcount = 0;
d3711 1
a3711 1
  return &ret->root.root;
d3789 1
a3789 1
   .word func    @@ behave as if you saw a ARM_32 reloc.  
d3796 1
a3796 1
   .word func    @@ behave as if you saw a ARM_32 reloc.  
d3891 1
a3891 1
  
d3895 1
a3895 1
      
d3898 1
a3898 1
      
d3900 1
a3900 1
      
d3903 1
a3903 1
      
d3927 2
a3928 1
   returns the symbol identifying teh stub.  */
d4107 1
a4107 1
  
d4109 1
a4109 1
  
d4111 1
a4111 1
  
d4114 1
a4114 1
  
d4116 1
a4116 1
  
d4140 1
a4140 1
  
d4147 1
a4147 1
  
d4149 1
a4149 1
  
d4184 1
a4184 1
  
d4186 1
a4186 1
  
d4189 1
a4189 1
  
d4192 1
a4192 1
  
d4194 1
a4194 1
  
d4196 1
a4196 1
  
d4199 1
a4199 1
  
d4201 1
a4201 1
  
d4204 1
a4204 1
  
d4207 1
a4207 1
  
d4209 1
a4209 1
  
d4223 1
a4223 1
  
d4239 1
a4239 1
  
d4247 1
a4247 1
  
d4253 1
a4253 1
  
d4269 1
a4269 1
      
d4276 1
a4276 1
  
d4280 1
a4280 1
  
d4300 4
d4414 2
a4415 1
static void check_use_blx(struct elf32_arm_link_hash_table *globals)
d4478 1
a4478 2
	= _bfd_elf_link_read_relocs (abfd, sec, (void *) NULL,
				     (Elf_Internal_Rela *) NULL, FALSE);
a4496 1
	      && r_type != R_ARM_CALL
a4497 1
	      && r_type != R_ARM_THM_CALL
a4550 1
	    case R_ARM_CALL:
d4555 1
a4555 1
	      if (ELF_ST_TYPE(h->type) == STT_ARM_TFUNC
a4559 1
	    case R_ARM_THM_CALL:
d4631 1
a4631 1
      
d4637 1
a4637 1
          
d4651 1
a4651 1
  
d4661 1
a4661 1
        
d4676 2
a4677 1
enum bfd_arm_vfp11_pipe {
d4692 1
a4692 1
  
d4695 1
a4695 1
   
d4724 1
a4724 1
  
d4731 1
a4731 1
      
d4736 1
a4736 1
      
d4740 1
a4740 1
  
d4861 1
a4861 1
      
d4879 1
a4879 1
      
d4884 1
a4884 1
        
d4898 1
a4898 1
        
d4903 1
a4903 1
        
d4954 1
a4954 1
  
d4957 1
a4957 1
     
d4966 1
a4966 1
       
d4972 1
a4972 1
       
d4979 1
a4979 2
     triggering the erratum, hence the use of the extra state 1.
  */
d4989 1
a4989 1
  
d5010 1
a5010 1
      
d5013 1
a5013 1
      
d5028 1
a5028 1
          
d5117 1
a5117 1
                    
d5136 1
a5136 1
      
d5149 1
a5149 1
  
d5163 1
a5163 1
  
d5172 1
a5172 1
  
d5180 1
a5180 1
      
d5227 1
a5227 1
            
d5233 1
a5233 1
  
d5292 1
a5292 1
  lower = (lower & ~(bfd_vma) 0x2fff) 
a5299 29

/* Store an Arm insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_arm_insn (struct elf32_arm_link_hash_table *htab,
	     bfd * output_bfd, bfd_vma val, void * ptr)
{
    if (htab->byteswap_code != bfd_little_endian (output_bfd))
      bfd_putl32 (val, ptr);
    else
      bfd_putb32 (val, ptr);
}


/* Store a 16-bit Thumb insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_thumb_insn (struct elf32_arm_link_hash_table *htab,
	       bfd * output_bfd, bfd_vma val, void * ptr)
{
    if (htab->byteswap_code != bfd_little_endian (output_bfd))
      bfd_putl16 (val, ptr);
    else
      bfd_putb16 (val, ptr);
}


d5567 1
a5567 1
  eh = elf32_arm_hash_entry(h);
d5636 1
a5636 1
elf32_arm_begin_write_processing (bfd *abfd ATTRIBUTE_UNUSED, 
d5773 1
d5775 1
a5775 1
identify_add_or_sub(bfd_vma insn)
a5787 9
/* Determine if we're dealing with a Thumb-2 object.  */

static int using_thumb2 (struct elf32_arm_link_hash_table *globals)
{
  int arch = bfd_elf_get_obj_attr_int (globals->obfd, OBJ_ATTR_PROC,
				       Tag_CPU_arch);
  return arch == TAG_CPU_ARCH_V6T2 || arch >= TAG_CPU_ARCH_V7;
}

d6056 10
d6077 1
a6077 1
	  else if (r_type != R_ARM_CALL || !globals->use_blx)
d6093 21
d6175 3
a6177 1
		  if (sym_flags == STT_ARM_TFUNC)
d6186 1
d6450 37
d6529 1
a6529 1
	lower_insn = (lower_insn & ~(bfd_vma) 0x2fff) 
d6894 1
a6894 1
	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off 
d7052 1
a7052 1
	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off 
d7067 1
a7067 1
	  return FALSE;	  
d7071 1
a7071 1
      
d7163 1
a7163 1
	
d7249 1
a7249 1
            abort();
d7282 1
a7282 1
                return bfd_reloc_overflow;	  
d7377 1
a7377 1
            abort();
d7460 1
a7460 1
            abort();
d7543 1
a7543 1
            abort();
d7684 1
d8121 1
d8137 1
d8804 1
a8804 1
  check_use_blx(globals);
d9017 1
a9017 1
		      
d9019 1
a9019 1
		      size *= (sizeof (bfd_signed_vma) + sizeof(char));
d9262 2
a9263 2
elf32_arm_gc_mark_extra_sections(struct bfd_link_info *info,
				 elf_gc_mark_hook_fn gc_mark_hook)
d9373 1
a9373 1
}  
d9773 1
a9773 1
      sprintf(name, "__real_%s", h->root.root.string);
d10077 1
a10077 1
      
d10146 1
a10146 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d10219 4
a10222 2
elf32_arm_finish_dynamic_symbol (bfd * output_bfd, struct bfd_link_info * info,
				 struct elf_link_hash_entry * h, Elf_Internal_Sym * sym)
d10252 1
a10252 1
	  put_arm_insn (htab, output_bfd, 
d10255 1
a10255 1
	  bfd_put_32 (output_bfd, 
d10258 1
a10258 1
	  
d10269 1
a10269 1
	  plt_index = ((h->plt.offset - htab->plt_header_size) 
d10278 1
a10278 1
	  
d10405 1
a10405 1
	  
d10459 1
a10459 1
	  BFD_ASSERT((h->got.offset & 1) != 0);
d10469 1
a10469 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
d10607 1
a10607 1
	      
d10648 1
a10648 1
		      Elf_Internal_Shdr *hdr 
d10652 1
a10652 1
			  if (dyn.d_tag == DT_RELSZ 
d10680 1
a10680 1
		  if (eh != (struct elf_link_hash_entry *) NULL
d11125 1
a11125 1
      /* A three-word PLT with no Thumb thunk contains only Arm code, 
d11144 6
a11149 5
    struct bfd_link_info *info,
    void *finfo, bfd_boolean (*func) (void *, const char *,
				    Elf_Internal_Sym *,
				    asection *,
				    struct elf_link_hash_entry *))
d11157 1
a11157 1
  check_use_blx(htab);
d11162 1
a11162 1
  
d11554 1
a11554 1
      
d11563 1
a11563 1
elf32_arm_modify_segment_map (bfd *abfd, 
d11611 1
d11619 2
a11620 1
const struct elf_size_info elf32_arm_size_info = {
d11666 1
d11700 12
a11711 15
#define elf_backend_additional_program_headers \
  elf32_arm_additional_program_headers
#define elf_backend_output_arch_local_syms \
  elf32_arm_output_arch_local_syms
#define elf_backend_begin_write_processing \
    elf32_arm_begin_write_processing
#define elf_backend_is_function_type		elf32_arm_is_function_type 

#define elf_backend_can_refcount    1
#define elf_backend_can_gc_sections 1
#define elf_backend_plt_readonly    1
#define elf_backend_want_got_plt    1
#define elf_backend_want_plt_sym    0
#define elf_backend_may_use_rel_p   1
#define elf_backend_may_use_rela_p  0
d11716 7
a11722 7
#undef elf_backend_obj_attrs_vendor
#define elf_backend_obj_attrs_vendor	"aeabi"
#undef elf_backend_obj_attrs_section
#define elf_backend_obj_attrs_section	".ARM.attributes"
#undef elf_backend_obj_attrs_arg_type
#define elf_backend_obj_attrs_arg_type	elf32_arm_obj_attrs_arg_type
#undef elf_backend_obj_attrs_section_type
d11727 1
a11727 1
/* VxWorks Targets */
d11729 1
a11729 1
#undef TARGET_LITTLE_SYM
d11731 1
a11731 1
#undef TARGET_LITTLE_NAME
d11733 1
a11733 1
#undef TARGET_BIG_SYM
d11735 1
a11735 1
#undef TARGET_BIG_NAME
d11740 1
d11755 1
a11755 1
}     
d11764 1
a11764 1
#undef elf32_bed
d11767 8
a11774 12
#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
  elf32_arm_vxworks_link_hash_table_create
#undef elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook \
  elf_vxworks_add_symbol_hook
#undef elf_backend_final_write_processing
#define elf_backend_final_write_processing \
  elf32_arm_vxworks_final_write_processing
#undef elf_backend_emit_relocs
#define elf_backend_emit_relocs \
  elf_vxworks_emit_relocs
d11776 1
a11776 1
#undef elf_backend_may_use_rel_p
d11778 1
a11778 1
#undef elf_backend_may_use_rela_p
d11780 1
a11780 1
#undef elf_backend_default_use_rela_p
d11782 1
a11782 1
#undef elf_backend_want_plt_sym
d11784 1
a11784 1
#undef ELF_MAXPAGESIZE
d11790 1
a11790 1
/* Symbian OS Targets */
d11792 1
a11792 1
#undef TARGET_LITTLE_SYM
d11794 1
a11794 1
#undef TARGET_LITTLE_NAME
d11796 1
a11796 1
#undef TARGET_BIG_SYM
d11798 1
a11798 1
#undef TARGET_BIG_NAME
d11803 1
d11824 1
a11824 1
}     
d11848 1
a11848 1
elf32_arm_symbian_begin_write_processing (bfd *abfd, 
d11860 1
a11860 1
  elf32_arm_begin_write_processing(abfd, link_info);
d11864 1
a11864 1
elf32_arm_symbian_modify_segment_map (bfd *abfd, 
d11909 1
a11909 1
#undef ELF_DYNAMIC_SEC_FLAGS
a11912 3
#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
  elf32_arm_symbian_link_hash_table_create
d11914 1
d11916 8
a11923 10
#undef elf_backend_special_sections
#define elf_backend_special_sections elf32_arm_symbian_special_sections

#undef elf_backend_begin_write_processing
#define elf_backend_begin_write_processing \
    elf32_arm_symbian_begin_write_processing
#undef elf_backend_final_write_processing
#define elf_backend_final_write_processing \
  elf32_arm_final_write_processing
#undef elf_backend_emit_relocs
d11925 1
a11925 1
#undef elf_backend_modify_segment_map
d11929 1
a11929 1
#undef elf_backend_got_header_size
d11933 1
a11933 1
#undef elf_backend_want_got_plt
d11936 1
a11936 1
#undef elf_backend_plt_sym_val
d11939 1
a11939 1
#undef elf_backend_may_use_rel_p
d11941 1
a11941 1
#undef elf_backend_may_use_rela_p
d11943 1
a11943 1
#undef elf_backend_default_use_rela_p
d11945 1
a11945 1
#undef elf_backend_want_plt_sym
d11947 1
a11947 1
#undef ELF_MAXPAGESIZE
@


1.141
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Skip dynamic relocs
	in vxworks tls_vars sections.
	(allocate_dynrelocs, elf32_arm_size_dynamic_sections): Likewise.
	* elf32-i386.c (allocate_dynrelocs,
	elf_i386_size_dynamic_sections, elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (allocate_dynrelocs, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs,
	_bfd_sparc_elf_size_dynamic_sections,
	_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-vxworks/tls-3.s: New.
	* ld-vxworks/tls-3.d: New.
@
text
@d10576 2
a10577 2
      /* The PLT entries are each three instructions.  */
      htab->plt_entry_size = 4 * NUM_ELEM (elf32_arm_symbian_plt_entry);
d10653 11
d10700 3
@


1.140
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d4755 3
d8583 13
d8747 1
d8766 7
@


1.139
log
@2008-03-09  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle new
	Tag_VFP_arch values.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add "VFPv3-D16".

	gas/
	* config/tc-arm.c (fpu_vfp_ext_d32): New vairable.
	(parse_vfp_reg_list, encode_arm_vfp_reg): Use it.
	(arm_option_cpu_value): Add vfpv3-d16, vfpv2 and vfpv3.
	(aeabi_set_public_attributes): Handle Tag_VFP_arch=VFPV3-D16.
	* doc/c-arm.texi: Document new ARM FPU variants.

	gas/testsuite/
	* gas/arm/vfpv3-d16-bad.d: New test.
	* gas/arm/vfpv3-d16-bad.l: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_D32, FPU_VFP_V3D16, FPU_ARCH_VFP_V3D16): Define.
@
text
@d8046 3
a8048 1
	      if (hdr->sh_type == SHT_ARM_EXIDX && hdr->sh_link
@


1.138
log
@2008-03-08  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (insert_thumb_branch): Rewrite.
	(elf32_thumb_to_arm_stub): Use new insert_thumb_branch.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armeabitests): Add thumb2-b-interwork.
	* ld-arm/thumb2-b-interwork.d: New test.
	* ld-arm/thumb2-b-interwork.s: New test.
@
text
@d6905 2
a6960 1
	case Tag_VFP_arch:
d6988 5
@


1.137
log
@2008-03-07  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_howto_table_1): Fix bitmasks for MOVW and
	MOVT relocations.
	(elf32_arm_final_link_relocate): Fix off by one MOVW/MOVT sign
	extension.
	(elf32_arm_relocate_section): Handle MOVW and MOVT
	relocations.  Improve safety check for other weird relocations.
	(elf32_arm_check_relocs): Only set h->needs_plt for branch/call
	relocations.

	gas/
	* config/tc-arm.c (md_apply_fix): Use correct offset range.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add movw-merge and arm-app-movw.
	* ld-arm/arm-app-movw.s: New test.
	* ld-arm/arm-app.r: Update expected output.
	* ld-arm/movw-merge.d: New test.
	* ld-arm/movw-merge.s: New test.
@
text
@d4073 1
a4073 50
/* The thumb form of a long branch is a bit finicky, because the offset
   encoding is split over two fields, each in it's own instruction. They
   can occur in any order. So given a thumb form of long branch, and an
   offset, insert the offset into the thumb branch and return finished
   instruction.

   It takes two thumb instructions to encode the target address. Each has
   11 bits to invest. The upper 11 bits are stored in one (identified by
   H-0.. see below), the lower 11 bits are stored in the other (identified
   by H-1).

   Combine together and shifted left by 1 (it's a half word address) and
   there you have it.

   Op: 1111 = F,
   H-0, upper address-0 = 000
   Op: 1111 = F,
   H-1, lower address-0 = 800

   They can be ordered either way, but the arm tools I've seen always put
   the lower one first. It probably doesn't matter. krk@@cygnus.com

   XXX:  Actually the order does matter.  The second instruction (H-1)
   moves the computed address into the PC, so it must be the second one
   in the sequence.  The problem, however is that whilst little endian code
   stores the instructions in HI then LOW order, big endian code does the
   reverse.  nickc@@cygnus.com.  */

#define LOW_HI_ORDER      0xF800F000
#define HI_LOW_ORDER      0xF000F800

static insn32
insert_thumb_branch (insn32 br_insn, int rel_off)
{
  unsigned int low_bits;
  unsigned int high_bits;

  BFD_ASSERT ((rel_off & 1) != 1);

  rel_off >>= 1;				/* Half word aligned address.  */
  low_bits = rel_off & 0x000007FF;		/* The bottom 11 bits.  */
  high_bits = (rel_off >> 11) & 0x000007FF;	/* The top 11 bits.  */

  if ((br_insn & LOW_HI_ORDER) == LOW_HI_ORDER)
    br_insn = LOW_HI_ORDER | (low_bits << 16) | high_bits;
  else if ((br_insn & HI_LOW_ORDER) == HI_LOW_ORDER)
    br_insn = HI_LOW_ORDER | (high_bits << 16) | low_bits;
  else
    /* FIXME: abort is probably not the right call. krk@@cygnus.com  */
    abort ();	/* Error - not a valid branch instruction form.  */
d4075 21
a4095 1
  return br_insn;
a4143 1
  unsigned long int tmp;
d4224 1
a4224 6
  tmp = bfd_get_32 (input_bfd, hit_data
		    - input_section->vma);

  bfd_put_32 (output_bfd,
	      (bfd_vma) insert_thumb_branch (tmp, ret_offset),
	      hit_data - input_section->vma);
@


1.136
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d699 2
a700 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d713 2
a714 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d727 2
a728 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d741 2
a742 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d5919 1
a5919 1
	    signed_addend = (addend ^ 0x10000) - 0x10000;
d5969 1
a5969 1
	    signed_addend = (addend ^ 0x10000) - 0x10000;
d6551 1
a6551 1
		  if (howto->rightshift)
d6553 28
a6580 6
		      (*_bfd_error_handler)
			(_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
			 input_bfd, input_section,
			 (long) rel->r_offset, howto->name);
		      return FALSE;
		    }
d6582 1
a6582 1
		  value = bfd_get_32 (input_bfd, contents + rel->r_offset);
d6584 5
a6588 5
		  /* Get the (signed) value from the instruction.  */
		  addend = value & howto->src_mask;
		  if (addend & ((howto->src_mask + 1) >> 1))
		    {
		      bfd_signed_vma mask;
d6590 5
a6594 3
		      mask = -1;
		      mask &= ~ howto->src_mask;
		      addend |= mask;
d6596 1
d6602 28
a6629 2
		  value = (value & ~ howto->dst_mask) | (addend & howto->dst_mask);
		  bfd_put_32 (input_bfd, value, contents + rel->r_offset);
d7717 1
a7858 4
	  case R_ARM_ABS32:
	  case R_ARM_ABS32_NOI:
	  case R_ARM_REL32:
	  case R_ARM_REL32_NOI:
d7867 7
d7882 3
d7901 1
a7901 5
		if (r_type != R_ARM_ABS32
                    && r_type != R_ARM_REL32
                    && r_type != R_ARM_ABS32_NOI
                    && r_type != R_ARM_REL32_NOI
                    && r_type != R_ARM_ABS12)
@


1.135
log
@2008-02-20  Paul Brook  <paul@@codesourcery.com>

	ld/
	* emultempl/armelf.em (OPTION_FIX_V4BX_INTERWORKING): Define.
	(PARSE_AND_LIST_LONGOPTS): Add fix-v4bx-interworking.
	(PARSE_AND_LIST_OPTIONS): Ditto.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_FIX_V4BX_INTERWORKING.
	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Add .v4_bx.
	* emulparams/armelf_linux.sh (OTHER_TEXT_SECTIONS): Ditto.
	* emulparams/armnto.sh (OTHER_TEXT_SECTIONS): Ditto.
	* ld.texinfo: Document --fix-v4bx-interworking.

	ld/testsuite/
	* ld-arm/armv4-bx.d: New test.
	* ld-arm/armv4-bx.s: New test.
	* ld-arm/arm.ld: Add .v4bx.
	* ld-arm/arm-elf.exp: Add armv4-bx.

	gas/testsuite/
	* gas/arm/thumb.d: Exclude EABI targets.
	* gas/arm/arch4t.d: Exclude EABI targts.
	* gas/arm/v4bx.d: New test.
	* gas/arm/v4bx.s: New test.
	* gas/arm/thumb-eabi.d: New test.
	* gas/arm/arch4t-eabi.d: New test.

	gas/
	* config/tc-arm.c (fix_v4bx): New variable.
	(do_bx): Generate V4BX relocations.
	(md_assemble): Allow bx on v4 codes when fix_v4bx.
	(md_apply_fix): Handle BFD_RELOC_ARM_V4BX.
	(tc_gen_reloc): Ditto.
	(OPTION_FIX_V4BX): Define.
	(md_longopts): Add fix-v4bx.
	(md_parse_option): Handle OPTION_FIX_V4BX.
	(md_show_usage): Document --fix-v4bx.
	* doc/c-arm.texi: Document --fix-v4bx.

	bfd/
	* reloc.c: Add BFD_RELOC_ARM_V4BX.
	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_V4BX.
	(ARM_BX_GLUE_SECTION_NAME, ARM_BX_GLUE_SECTION_NAME): Define.
	(elf32_arm_link_hash_table): Add bx_glue_size and bx_glue_offset.
	Update comment for fix_v4bx.
	(elf32_arm_link_hash_table_create): Zero bx_glue_size and
	bx_glue_offset.
	(ARM_BX_VENEER_SIZE, armbx1_tst_insn, armbx2_moveq_insn,
	armbx3_bx_insn): New.
	(bfd_elf32_arm_allocate_interworking_sections): Allocate BX veneer
	section.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Ditto.
	(bfd_elf32_arm_process_before_allocation): Record BX veneers.
	(record_arm_bx_glue, elf32_arm_bx_glue): New functions.
	(elf32_arm_final_link_relocate): Handle BX veneers.
	(elf32_arm_output_arch_local_syms): Output mapping symbol for .v4_bx.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d2951 8
a2958 2
      sec_data->map = bfd_realloc (sec_data->map, sec_data->mapsize
				     * sizeof (elf32_arm_section_map));
a2959 3
  
  sec_data->map[newidx].vma = vma;
  sec_data->map[newidx].type = type;
@


1.134
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d1776 2
a1777 1
    {BFD_RELOC_ARM_LDC_SB_G2, R_ARM_LDC_SB_G2}
d1908 3
d2178 7
d2202 3
a2204 1
    /* Nonzero to fix BX instructions for ARMv4 targets.  */
d2485 2
d2644 5
d2707 15
d2873 58
d3154 18
d3291 2
a3292 1
	      && r_type != R_ARM_THM_JUMP24)
d3309 9
d4456 37
d5871 2
a5872 2
        {
          bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
d5874 2
a5875 2
          /* Ensure that we have a BX instruction.  */
          BFD_ASSERT ((insn & 0x0ffffff0) == 0x012fff10);
d5877 17
a5893 3
          /* Preserve Rm (lowest four bits) and the condition code
             (highest four bits). Other bits encode MOV PC,Rm.  */
          insn = (insn & 0xf000000f) | 0x01a0f000;
d5895 2
a5896 2
          bfd_put_32 (input_bfd, insn, hit_data);
        }
d9907 12
@


1.133
log
@	PR ld/5692
	* elf.c (bfd_elf_get_elf_syms): Revert 2008-01-31.  Instead abort
	on non-ELF input.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Skip glue
	processing on non-ELF input.
@
text
@d2068 1
a2068 1
struct elf32_arm_obj_tdata
d2079 2
a2080 2
#define elf32_arm_tdata(abfd) \
  ((struct elf32_arm_obj_tdata *) (abfd)->tdata.any)
d2082 7
a2088 2
#define elf32_arm_local_got_tls_type(abfd) \
  (elf32_arm_tdata (abfd)->local_got_tls_type)
d2093 2
a2094 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct elf32_arm_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d3153 1
a3153 1
      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d3287 1
a3287 1
  hdr = &elf_tdata (abfd)->symtab_hdr;
d3660 4
a3669 4
  /* Skip if this bfd does not correspond to an ELF image.  */
  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    return TRUE;
  
d3842 1
a3842 1
  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
d3945 2
a3946 1
  elf32_arm_tdata (output_bfd)->no_enum_size_warning = no_enum_warn;
d4531 3
a4533 1
  /* Some relocation type map to different relocations depending on the
d4557 1
a4557 1
  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
d6324 1
a6324 1
  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
d6613 1
a6613 2
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
d6871 1
a6871 1
		       && !elf32_arm_tdata (obfd)->no_enum_size_warning)
d6967 1
a6967 2
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
d7361 1
a7361 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d7495 2
d7512 1
a7512 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d7837 1
a7837 1
	  if (bfd_get_flavour (sub) != bfd_target_elf_flavour)
d7844 1
d8530 1
a8530 6
      /* FIXME: Here and elsewhere the test for an ELF input BFD is
	 not sufficiently strict.  Since we use elf32_arm_tdata and
	 elf32_arm_section_data, we should only allow those targets
	 that in fact have such data.  This of course is the set of
	 targets defined in this file.  */
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d8561 1
a8561 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d8607 1
a8607 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
@


1.132
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d8527 5
d8609 3
@


1.131
log
@PR ld/5398
* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Do not complain if
  there is no glue bfd, just return.
@
text
@d7354 3
@


1.130
log
@	include/elf/
	* vxworks.h: New.

	bfd/
	* elf-vxworks.h (elf_vxworks_add_dynamic_entries): Declare.
	(elf_vxworks_finish_dynamic_entry): Declare.
	* elf-vxworks.c: Include elf/vxworks.h.
	(elf_vxworks_add_dynamic_entries): New.
	(elf_vxworks_finish_dynamic_entry): New.
	* Makefile.am (elf-vxworks.lo): Add dependency.
	* Makefile.in (elf-vxworks.lo): Add dependency.
	* elf32-i386.c (elf_i386_size_dynamic_sections,
	elf_i386_finish_dynamic_sections): Call
	elf_vxworks_add_dynamic_entries and
	elf_vxworks_finish_dynamic_entry.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections,
	sparc_finish_dyn): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections,
	sh_elf_finish_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elf32-arm.c (elf32_arm_size_dynamic_sections,
	elf32_arm_finish_dynamic_sections): Likewise.

	ld/
	* ld-vxworks/tls-2.d: New.
	* ld-vxworks/tls-2.s: New.
@
text
@d3119 2
a3120 2
  /* Here we have a bfd that is to be included on the link.  We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
a3121 1
  check_use_blx (globals);
d3124 2
a3125 1
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);
d3134 6
@


1.129
log
@	* coff-arm.c (arm_emit_base_file_entry): Check fwrite return value.
	Return status.  Adjust callers.
	* coff-mcore.c (mcore_emit_base_file_entry): Likewise.
	* coff-ppc.c (write_base_file_entry): New function.
	(coff_ppc_relocate_section): Use it.
	* elf32-arm.c (find_thumb_glue): Check asprintf return status.
	(find_arm_glue): Likewise.
	* vms-misc.c (_bfd_vms_output_flush): Check fwrite return value.
@
text
@d8726 3
d9071 3
@


1.128
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d2523 4
a2526 3
  if (hash == NULL)
    asprintf (error_message, _("unable to find THUMB glue '%s' for '%s'"),
	      tmp_name, name);
d2557 4
a2560 3
  if (myh == NULL)
    asprintf (error_message, _("unable to find ARM glue '%s' for '%s'"),
	      tmp_name, name);
@


1.127
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a7473 1
  struct elf_link_hash_entry **sym_hashes_end;
a7500 5
  sym_hashes_end = sym_hashes
    + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);

  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.126
log
@bfd:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* elf32-arm.c (elf32_arm_compare_mapping): Compare first on vma,
	then on type.

binutils/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* binutils-all/ar.exp (long_filenames): Delete temporary files on
	the host.
	* binutils-all/arm/objdump.exp: Only check "which $OBJDUMP" if
	host is local.
	* binutils-all/objcopy.exp: Use ${srecfile} to get the name of the
	srec file to be passed to binutils_run.
	(objcopy_test_readelf): Use remote_exec.
	* binutils-all/readelf.exp (readelf_find_size): Use remote_exec.
	(readelf_test): Likewise.
	(readelf_wi_test): Likewise.
	* lib/utils-lib.exp (run_dump_test): Only check "which $binary" if
	host is local.  Use remote_exec.  Use $tempfile not
	tmpdir/bintest.o.

gas:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* as.c (main): Flush stderr before printing listings to ensure
	consistent output order across platforms.

gas/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* lib/gas-defs.exp (gas_version): Use remote_* functions instead
	of exec.
	(gas_host_run): New.
	(gas_run): Use gas_host_run.
	(gas_start): Likewise.
	(run_dump_test): Likewise.
	(objdump): Use gas_host_run.
	(objdump_start_no_subdir): Likewise.
	* lib/gas-dg.exp (gas-dg-test): Use "remote_file host delete".
	* lib/run: Remove.
	* gas/macros/macros.exp: Download app4b.s to host.
	* gas/i386/i386.exp (gas_64_check): Use gas_host_run.
	(gas_32_check): Likewise.
	* gas/maxq10/maxq10.exp (gas_64_check): Likewise
	(gas_32_check): Likewise.
	* gas/maxq20/maxq20.exp (gas_64_check): Likewise
	(gas_32_check): Likewise.
	* gas/sparc/sparc.exp (gas_64_check): Likewise.
	* gas/cfi/cfi.exp: Likewise.
	* gas/elf/elf.exp (run_list_test): Likewise.  Use temporary file
	for readelf output in place of pipe.
	* gas/all/gas.exp: Download incbin.dat to host.
	(do_comment): Allow \r\r\n.

ld:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ldlang.c (sort_sections_by_lma): Sort by internal id after lma
	for stable sort.

ld/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ld-elfcomm/elfcomm.exp: Use run_host_cmd.  Only check "which
	$CC" if host is local.
	* ld-checks/checks.exp: Use run_host_cmd.
	* ld-elf/exclude.exp: Likewise.
	* ld-elf/elf.exp: Download merge.ld if host is remote.
	* ld-elf/binutils.exp (binutils_test): Use remote_exec.
	* ld-elf/tls_common.exp: Use run_host_cmd.
	* lib/ld-lib.exp (ld_version): Only check "which $ld" if host is
	local.  Use remote_exec.
	(run_host_cmd): New.
	(run_host_cmd_yesno): New.
	(default_ld_relocate): Use run_host_cmd_yesno.
	(default_ld_link): Likewise.
	(default_ld_simple_link): Use run_host_cmd.
	(default_ld_compile): Only check "which $ccprog" if host is local.
	Use remote_file and remote_exec.
	(default_ld_assemble): Only check "which $as" if host is local.
	Use run_host_cmd.
	(default_ld_nm): Use remote_exec, remote_upload and remote_file.
	(run_dump_test): Use remote_exec, remote_upload and remote_file.
	Only check "which $binary" if host is local.
	(run_ld_link_tests): Use remote_exec, remote_upload and
	remote_file.
	* ld-selective/selective.exp: Only check "which $CXX" if host is
	local.  Use remote_exec.
	* ld-scripts/phdrs.exp: Only check "which $objdump" if host is
	local.  Use run_host_cmd.
	* ld-scripts/phdrs2.exp: Likewise.
	* ld-scripts/weak.exp: Likewise.
	* ld-undefined/weak-undef.exp: Likewise.
	* ld-scripts/crossref.exp: Only check "which $CC" if host is local.
	Use run_host_cmd.
	* ld-scripts/map-address.exp: Upload map_address.map if host is
	remote.
	* ld-srec/srec.exp (run_srec_tests): Use run_host_cmd.  Only check
	"which $CC" and "which $CXX" if host is local.
	* ld-undefined/undefined.exp: Only check "which $CC" if host is
	local.  Use remote_file and run_host_cmd.
	* config/default.exp: Use remote_exec to create tmpdir.
@
text
@d7798 3
a7800 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
@


1.125
log
@2007-08-06  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (elf32_arm_link_hash_entry): Add
	plt_maybe_thumb_refcount.
	(elf32_arm_link_hash_newfunc): Set plt_maybe_thumb_refcount.
	(elf32_arm_copy_indirect_symbol): Ditto.
	(elf32_arm_adjust_dynamic_symbol): Ditto.
	(bfd_elf32_arm_process_before_allocation): Handle R_ARM_THM_JUMP24.
	(arm_add_to_rel): Ditto.
	(elf32_arm_final_link_relocate): Merge R_ARM_THM_JUMP24 with
	R_ARM_THM_CALL.  Handle R_ARM_THM_JUMP19 against a PLT stub.
	(elf32_arm_gc_sweep_hook): Call check_use_blx.  Update plt counts
	for R_ARM_THM_JUMP24 and R_ARM_THM_JUMP19.
	(elf32_arm_check_relocs): Update plt counts for R_ARM_THM_JUMP24
	and R_ARM_THM_JUMP19.
	(allocate_dynrelocs): Use plt_maybe_thumb_refcount.
	(elf32_arm_finish_dynamic_symbol): Ditto.
	(elf32_arm_output_plt_map): Ditto.
@
text
@d9777 16
a9792 2
  return ((const elf32_arm_section_map *) a)->vma
	 > ((const elf32_arm_section_map *) b)->vma;
@


1.125.2.1
log
@PR ld/5398
* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Do not complain if
   there is no glue bfd, just return.
@
text
@d3117 2
a3118 2
  /* Here we have a bfd that is to be included on the link.  We have a
     hook to do reloc rummaging, before section sizes are nailed down.  */
d3120 1
d3123 1
a3123 2

  check_use_blx (globals);
a3131 6
  /* PR 5398: If we have not decided to include any loadable sections in
     the output then we will not have a glue owner bfd.  This is OK, it
     just means that there is nothing else for us to do here.  */
  if (globals->bfd_of_glue_owner == NULL)
    return TRUE;

@


1.124
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@d2132 4
d2274 1
d2430 2
d3172 2
a3173 1
	      && r_type != R_ARM_THM_CALL)
d3227 1
d3231 2
a3232 1
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC && !globals->use_blx
d5009 1
d5073 1
a5073 1
		if (globals->use_blx)
d5086 2
a5087 1
	    else if (sym_flags == STT_ARM_TFUNC && globals->use_blx)
d5100 1
a5100 1
 	    if (globals->use_blx)
d5140 1
a5140 1
	if ((lower_insn & 0x1800) == 0x0800)
a5166 73
    case R_ARM_THM_JUMP24:
      /* Thumb32 unconditional branch instruction.  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
	bfd_signed_vma signed_check;

	/* Need to refetch the addend, reconstruct the top three bits, and glue the
	   two pieces together.  */
	if (globals->use_rel)
	  {
	    bfd_vma S  = (upper_insn & 0x0400) >> 10;
	    bfd_vma hi = (upper_insn & 0x03ff);
	    bfd_vma I1 = (lower_insn & 0x2000) >> 13;
	    bfd_vma I2 = (lower_insn & 0x0800) >> 11;
	    bfd_vma lo = (lower_insn & 0x07ff);

	    I1 = !(I1 ^ S);
	    I2 = !(I2 ^ S);
	    S  = !S;

	    signed_addend = (S << 24) | (I1 << 23) | (I2 << 22) | (hi << 12) | (lo << 1);
	    signed_addend -= (1 << 24); /* Sign extend.  */
	  }

	/* ??? Should handle interworking?  GCC might someday try to
	   use this for tail calls.  */

      	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

	/* Put RELOCATION back into the insn.  */
	{
	  bfd_vma S  = (relocation & 0x01000000) >> 24;
	  bfd_vma I1 = (relocation & 0x00800000) >> 23;
	  bfd_vma I2 = (relocation & 0x00400000) >> 22;
	  bfd_vma hi = (relocation & 0x003ff000) >> 12;
	  bfd_vma lo = (relocation & 0x00000ffe) >>  1;

	  I1 = !(I1 ^ S);
	  I2 = !(I2 ^ S);

	  upper_insn = (upper_insn & (bfd_vma) 0xf800) | (S << 10) | hi;
	  lower_insn = (lower_insn & (bfd_vma) 0xd000) | (I1 << 13) | (I2 << 11) | lo;
	}

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }

d5197 11
d6219 2
a6220 1
  if (howto->type == R_ARM_THM_CALL)
d7354 2
d7406 2
d7429 5
a7433 1
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_THM_CALL)
d7635 2
d7672 4
d7677 4
d8031 1
d8046 1
d8124 1
d8166 5
a8170 1
	  if (!htab->use_blx && eh->plt_thumb_refcount > 0)
d8879 1
d8888 5
a8892 1
	      if (!htab->use_blx && eh->plt_thumb_refcount > 0)
d9622 5
a9626 1
      bfd_boolean thumb_stub;
d9628 1
a9628 2
      thumb_stub = eh->plt_thumb_refcount > 0 && !htab->use_blx;
      if (thumb_stub)
d9642 1
a9642 1
      if (thumb_stub || addr == 20)
@


1.123
log
@bfd:
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Copy type from
	input attributes if value has been copied.

ld/testsuite:
	* ld-arm/attr-merge-2a.s, ld-arm/attr-merge-2b.s,
	ld-arm/attr-merge-2.attr: New.
	* ld-arm/arm-elf.exp (armelftests): Add new test.
@
text
@d10136 1
@


1.122
log
@Switch sources over to use the GPL version 3
@
text
@d6937 17
@


1.121
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.120
log
@2007-06-29  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Suppress
	call veneers for call relocations against undefined symbols.
	(elf32_arm_final_link_relocate): Turn call to undefined symbol
	into a jump to the next instruction.

	ld/testuite/
	* ld-arm/arm-elf.exp (armelftests): Add callweak.
	* ld-arm/callweak.d: New test.
	* ld-arm/callweak.s: New test.
@
text
@a2066 16
#define NUM_KNOWN_ATTRIBUTES 32

typedef struct aeabi_attribute
{
  int type;
  unsigned int i;
  char *s;
} aeabi_attribute;

typedef struct aeabi_attribute_list
{
  struct aeabi_attribute_list *next;
  int tag;
  aeabi_attribute attr;
} aeabi_attribute_list;

a2073 3
  aeabi_attribute known_eabi_attributes[NUM_KNOWN_ATTRIBUTES];
  aeabi_attribute_list *other_eabi_attributes;

d3087 2
a3088 1
  if (elf32_arm_get_eabi_attr_int (globals->obfd, Tag_CPU_arch) > 2)
d3306 1
a3306 1
  aeabi_attribute *out_attr = elf32_arm_tdata (obfd)->known_eabi_attributes;
d4473 2
a4474 1
  int arch = elf32_arm_get_eabi_attr_int (globals->obfd, Tag_CPU_arch);
a6258 188

static int
uleb128_size (unsigned int i)
{
  int size;
  size = 1;
  while (i >= 0x80)
    {
      i >>= 7;
      size++;
    }
  return size;
}

/* Return TRUE if the attribute has the default value (0/"").  */
static bfd_boolean
is_default_attr (aeabi_attribute *attr)
{
  if ((attr->type & 1) && attr->i != 0)
    return FALSE;
  if ((attr->type & 2) && attr->s && *attr->s)
    return FALSE;

  return TRUE;
}

/* Return the size of a single attribute.  */
static bfd_vma
eabi_attr_size(int tag, aeabi_attribute *attr)
{
  bfd_vma size;

  if (is_default_attr (attr))
    return 0;

  size = uleb128_size (tag);
  if (attr->type & 1)
    size += uleb128_size (attr->i);
  if (attr->type & 2)
    size += strlen ((char *)attr->s) + 1;
  return size;
}
  
/* Returns the size of the eabi object attributess section.  */
bfd_vma
elf32_arm_eabi_attr_size (bfd *abfd)
{
  bfd_vma size;
  aeabi_attribute *attr;
  aeabi_attribute_list *list;
  int i;

  attr = elf32_arm_tdata (abfd)->known_eabi_attributes;
  size = 16; /* 'A' <size> "aeabi" 0x1 <size>.  */
  for (i = 4; i < NUM_KNOWN_ATTRIBUTES; i++)
    size += eabi_attr_size (i, &attr[i]);

  for (list = elf32_arm_tdata (abfd)->other_eabi_attributes;
       list;
       list = list->next)
    size += eabi_attr_size (list->tag, &list->attr);

  return size;
}

static bfd_byte *
write_uleb128 (bfd_byte *p, unsigned int val)
{
  bfd_byte c;
  do
    {
      c = val & 0x7f;
      val >>= 7;
      if (val)
	c |= 0x80;
      *(p++) = c;
    }
  while (val);
  return p;
}

/* Write attribute ATTR to butter P, and return a pointer to the following
   byte.  */
static bfd_byte *
write_eabi_attribute (bfd_byte *p, int tag, aeabi_attribute *attr)
{
  /* Suppress default entries.  */
  if (is_default_attr(attr))
    return p;

  p = write_uleb128 (p, tag);
  if (attr->type & 1)
    p = write_uleb128 (p, attr->i);
  if (attr->type & 2)
    {
      int len;

      len = strlen (attr->s) + 1;
      memcpy (p, attr->s, len);
      p += len;
    }

  return p;
}

/* Write the contents of the eabi attributes section to p.  */
void
elf32_arm_set_eabi_attr_contents (bfd *abfd, bfd_byte *contents, bfd_vma size)
{
  bfd_byte *p;
  aeabi_attribute *attr;
  aeabi_attribute_list *list;
  int i;

  p = contents;
  *(p++) = 'A';
  bfd_put_32 (abfd, size - 1, p);
  p += 4;
  memcpy (p, "aeabi", 6);
  p += 6;
  *(p++) = Tag_File;
  bfd_put_32 (abfd, size - 11, p);
  p += 4;

  attr = elf32_arm_tdata (abfd)->known_eabi_attributes;
  for (i = 4; i < NUM_KNOWN_ATTRIBUTES; i++)
    p = write_eabi_attribute (p, i, &attr[i]);

  for (list = elf32_arm_tdata (abfd)->other_eabi_attributes;
       list;
       list = list->next)
    p = write_eabi_attribute (p, list->tag, &list->attr);
}

/* Override final_link to handle EABI object attribute sections.  */

static bfd_boolean
elf32_arm_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
{
  asection *o;
  struct bfd_link_order *p;
  asection *attr_section = NULL;
  bfd_byte *contents;
  bfd_vma size = 0;

  /* elf32_arm_merge_private_bfd_data will already have merged the
     object attributes.  Remove the input sections from the link, and set
     the contents of the output secton.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (strcmp (o->name, ".ARM.attributes") == 0)
	{
	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      asection *input_section;

	      if (p->type != bfd_indirect_link_order)
		continue;
	      input_section = p->u.indirect.section;
	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &= ~SEC_HAS_CONTENTS;
	    }
	    
	  size = elf32_arm_eabi_attr_size (abfd);
	  bfd_set_section_size (abfd, o, size);
	  attr_section = o;
	  /* Skip this section later on.  */
	  o->map_head.link_order = NULL;
	}
    }
  /* Invoke the ELF linker to do all the work.  */
  if (!bfd_elf_final_link (abfd, info))
    return FALSE;

  if (attr_section)
    {
      contents = bfd_malloc(size);
      if (contents == NULL)
	return FALSE;
      elf32_arm_set_eabi_attr_contents (abfd, contents, size);
      bfd_set_section_contents (abfd, attr_section, contents, 0, size);
      free (contents);
    }
  return TRUE;
}


a6592 124
/* Allocate/find an object attribute.  */
static aeabi_attribute *
elf32_arm_new_eabi_attr (bfd *abfd, int tag)
{
  aeabi_attribute *attr;
  aeabi_attribute_list *list;
  aeabi_attribute_list *p;
  aeabi_attribute_list **lastp;


  if (tag < NUM_KNOWN_ATTRIBUTES)
    {
      /* Knwon tags are preallocated.  */
      attr = &elf32_arm_tdata (abfd)->known_eabi_attributes[tag];
    }
  else
    {
      /* Create a new tag.  */
      list = (aeabi_attribute_list *)
	bfd_alloc (abfd, sizeof (aeabi_attribute_list));
      memset (list, 0, sizeof (aeabi_attribute_list));
      list->tag = tag;
      /* Keep the tag list in order.  */
      lastp = &elf32_arm_tdata (abfd)->other_eabi_attributes;
      for (p = *lastp; p; p = p->next)
	{
	  if (tag < p->tag)
	    break;
	  lastp = &p->next;
	}
      list->next = *lastp;
      *lastp = list;
      attr = &list->attr;
    }

  return attr;
}

int
elf32_arm_get_eabi_attr_int (bfd *abfd, int tag)
{
  aeabi_attribute_list *p;

  if (tag < NUM_KNOWN_ATTRIBUTES)
    {
      /* Knwon tags are preallocated.  */
      return elf32_arm_tdata (abfd)->known_eabi_attributes[tag].i;
    }
  else
    {
      for (p = elf32_arm_tdata (abfd)->other_eabi_attributes;
	   p;
	   p = p->next)
	{
	  if (tag == p->tag)
	    return p->attr.i;
	  if (tag < p->tag)
	    break;
	}
      return 0;
    }
}

void
elf32_arm_add_eabi_attr_int (bfd *abfd, int tag, unsigned int i)
{
  aeabi_attribute *attr;

  attr = elf32_arm_new_eabi_attr (abfd, tag);
  attr->type = 1;
  attr->i = i;
}

static char *
attr_strdup (bfd *abfd, const char * s)
{
  char * p;
  int len;
  
  len = strlen (s) + 1;
  p = (char *)bfd_alloc(abfd, len);
  return memcpy (p, s, len);
}

void
elf32_arm_add_eabi_attr_string (bfd *abfd, int tag, const char *s)
{
  aeabi_attribute *attr;

  attr = elf32_arm_new_eabi_attr (abfd, tag);
  attr->type = 2;
  attr->s = attr_strdup (abfd, s);
}

void
elf32_arm_add_eabi_attr_compat (bfd *abfd, unsigned int i, const char *s)
{
  aeabi_attribute_list *list;
  aeabi_attribute_list *p;
  aeabi_attribute_list **lastp;

  list = (aeabi_attribute_list *)
    bfd_alloc (abfd, sizeof (aeabi_attribute_list));
  memset (list, 0, sizeof (aeabi_attribute_list));
  list->tag = Tag_compatibility;
  list->attr.type = 3;
  list->attr.i = i;
  list->attr.s = attr_strdup (abfd, s);

  lastp = &elf32_arm_tdata (abfd)->other_eabi_attributes;
  for (p = *lastp; p; p = p->next)
    {
      int cmp;
      if (p->tag != Tag_compatibility)
	break;
      cmp = strcmp(s, p->attr.s);
      if (cmp < 0 || (cmp == 0 && i < p->attr.i))
	break;
      lastp = &p->next;
    }
  list->next = *lastp;
  *lastp = list;
}

a6642 44
/* Copy the eabi object attribute from IBFD to OBFD.  */
static void
copy_eabi_attributes (bfd *ibfd, bfd *obfd)
{
  aeabi_attribute *in_attr;
  aeabi_attribute *out_attr;
  aeabi_attribute_list *list;
  int i;

  in_attr = &elf32_arm_tdata (ibfd)->known_eabi_attributes[4];
  out_attr = &elf32_arm_tdata (obfd)->known_eabi_attributes[4];
  for (i = 4; i < NUM_KNOWN_ATTRIBUTES; i++)
    {
      out_attr->type = in_attr->type;
      out_attr->i = in_attr->i;
      if (in_attr->s && *in_attr->s)
	out_attr->s = attr_strdup (obfd, in_attr->s);
      in_attr++;
      out_attr++;
    }

  for (list = elf32_arm_tdata (ibfd)->other_eabi_attributes;
       list;
       list = list->next)
    {
      in_attr = &list->attr;
      switch (in_attr->type)
	{
	case 1:
	  elf32_arm_add_eabi_attr_int (obfd, list->tag, in_attr->i);
	  break;
	case 2:
	  elf32_arm_add_eabi_attr_string (obfd, list->tag, in_attr->s);
	  break;
	case 3:
	  elf32_arm_add_eabi_attr_compat (obfd, in_attr->i, in_attr->s);
	  break;
	default:
	  abort();
	}
    }
}


d6694 2
a6695 2
  /* Copy EABI object attributes.  */
  copy_eabi_attributes (ibfd, obfd);
d6727 15
d6747 3
a6749 4
  aeabi_attribute *in_attr;
  aeabi_attribute *out_attr;
  aeabi_attribute_list *in_list;
  aeabi_attribute_list *out_list;
d6755 1
a6755 1
  if (!elf32_arm_tdata (obfd)->known_eabi_attributes[0].i)
d6758 1
a6758 1
      copy_eabi_attributes (ibfd, obfd);
d6762 1
a6762 1
      elf32_arm_tdata (obfd)->known_eabi_attributes[0].i = 1;
d6767 2
a6768 2
  in_attr = elf32_arm_tdata (ibfd)->known_eabi_attributes;
  out_attr = elf32_arm_tdata (obfd)->known_eabi_attributes;
d6784 1
a6784 1
  for (i = 4; i < NUM_KNOWN_ATTRIBUTES; i++)
d6796 1
a6796 1
	    out_attr[i].s = attr_strdup(obfd, in_attr[i].s);
d6938 5
a6942 2
  in_list = elf32_arm_tdata (ibfd)->other_eabi_attributes;
  out_list = elf32_arm_tdata (ibfd)->other_eabi_attributes;
d6944 1
a6944 51
    {
      in_attr = &in_list->attr;
      if (in_attr->i == 0)
	continue;
      if (in_attr->i == 1)
	{
	  _bfd_error_handler
	    (_("ERROR: %B: Must be processed by '%s' toolchain"),
	     ibfd, in_attr->s);
	  return FALSE;
	}
      if (!out_list || out_list->tag != Tag_compatibility
	  || strcmp (in_attr->s, out_list->attr.s) != 0)
	{
	  /* Add this compatibility tag to the output.  */
	  elf32_arm_add_eabi_attr_compat (obfd, in_attr->i, in_attr->s);
	  continue;
	}
      out_attr = &out_list->attr;
      /* Check all the input tags with the same identifier.  */
      for (;;)
	{
	  if (out_list->tag != Tag_compatibility
	      || in_attr->i != out_attr->i
	      || strcmp (in_attr->s, out_attr->s) != 0)
	    {
	      _bfd_error_handler
		(_("ERROR: %B: Incompatible object tag '%s':%d"),
		 ibfd, in_attr->s, in_attr->i);
	      return FALSE;
	    }
	  in_list = in_list->next;
	  if (in_list->tag != Tag_compatibility
	      || strcmp (in_attr->s, in_list->attr.s) != 0)
	    break;
	  in_attr = &in_list->attr;
	  out_list = out_list->next;
	  if (out_list)
	    out_attr = &out_list->attr;
	}

      /* Check the output doesn't have extra tags with this identifier.  */
      if (out_list && out_list->tag == Tag_compatibility
	  && strcmp (in_attr->s, out_list->attr.s) == 0)
	{
	  _bfd_error_handler
	    (_("ERROR: %B: Incompatible object tag '%s':%d"),
	     ibfd, in_attr->s, out_list->attr.i);
	  return FALSE;
	}
    }
a9396 4
  else if (strcmp(name, ".ARM.attributes") == 0)
    {
      hdr->sh_type = SHT_ARM_ATTRIBUTES;
    }
a9399 112
/* Parse an Arm EABI attributes section.  */
static void
elf32_arm_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
{
  bfd_byte *contents;
  bfd_byte *p;
  bfd_vma len;

  contents = bfd_malloc (hdr->sh_size);
  if (!contents)
    return;
  if (!bfd_get_section_contents (abfd, hdr->bfd_section, contents, 0,
				 hdr->sh_size))
    {
      free (contents);
      return;
    }
  p = contents;
  if (*(p++) == 'A')
    {
      len = hdr->sh_size - 1;
      while (len > 0)
	{
	  int namelen;
	  bfd_vma section_len;

	  section_len = bfd_get_32 (abfd, p);
	  p += 4;
	  if (section_len > len)
	    section_len = len;
	  len -= section_len;
	  namelen = strlen ((char *)p) + 1;
	  section_len -= namelen + 4;
	  if (strcmp((char *)p, "aeabi") != 0)
	    {
	      /* Vendor section.  Ignore it.  */
	      p += namelen + section_len;
	    }
	  else
	    {
	      p += namelen;
	      while (section_len > 0)
		{
		  int tag;
		  unsigned int n;
		  unsigned int val;
		  bfd_vma subsection_len;
		  bfd_byte *end;

		  tag = read_unsigned_leb128 (abfd, p, &n);
		  p += n;
		  subsection_len = bfd_get_32 (abfd, p);
		  p += 4;
		  if (subsection_len > section_len)
		    subsection_len = section_len;
		  section_len -= subsection_len;
		  subsection_len -= n + 4;
		  end = p + subsection_len;
		  switch (tag)
		    {
		    case Tag_File:
		      while (p < end)
			{
			  bfd_boolean is_string;

			  tag = read_unsigned_leb128 (abfd, p, &n);
			  p += n;
			  if (tag == 4 || tag == 5)
			    is_string = 1;
			  else if (tag < 32)
			    is_string = 0;
			  else
			    is_string = (tag & 1) != 0;
			  if (tag == Tag_compatibility)
			    {
			      val = read_unsigned_leb128 (abfd, p, &n);
			      p += n;
			      elf32_arm_add_eabi_attr_compat (abfd, val,
							      (char *)p);
			      p += strlen ((char *)p) + 1;
			    }
			  else if (is_string)
			    {
			      elf32_arm_add_eabi_attr_string (abfd, tag,
							      (char *)p);
			      p += strlen ((char *)p) + 1;
			    }
			  else
			    {
			      val = read_unsigned_leb128 (abfd, p, &n);
			      p += n;
			      elf32_arm_add_eabi_attr_int (abfd, tag, val);
			    }
			}
		      break;
		    case Tag_Section:
		    case Tag_Symbol:
		      /* Don't have anywhere convenient to attach these.
		         Fall through for now.  */
		    default:
		      /* Ignore things we don't kow about.  */
		      p += subsection_len;
		      subsection_len = 0;
		      break;
		    }
		}
	    }
	}
    }
  free (contents);
}

a9428 2
  if (hdr->sh_type == SHT_ARM_ATTRIBUTES)
    elf32_arm_parse_attributes(abfd, hdr);
a10155 1
#define bfd_elf32_bfd_final_link		elf32_arm_bfd_final_link
d10200 9
@


1.119
log
@bfd:
	* elf32-arm.c (copy_eabi_attributes): Copy type of attributes.

ld/testsuite:
	* ld-arm/attr-merge.s, ld-arm/attr-merge.attr: New.
	* ld-arm/arm-elf.exp (armelftests): Add new test.
@
text
@d3239 2
a3240 1
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC && !globals->use_blx)
d4816 8
a4823 5
	  /* It is not an error for an undefined weak reference to be
	     out of range.  Any program that branches to such a symbol
	     is going to crash anyway, so there is no point worrying
	     about getting the destination exactly right.  */
	  if (! h || h->root.type != bfd_link_hash_undefweak)
a4828 1
	    }
d4830 1
a4830 1
	  addend = (value & 2);
d4832 2
a4833 2
	  value = (signed_addend & howto->dst_mask)
	    | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
d4835 1
a4835 11
	  /* Set the H bit in the BLX instruction.  */
	  if (sym_flags == STT_ARM_TFUNC)
	    {
	      if (addend)
		value |= (1 << 24);
	      else
		value &= ~(bfd_vma)(1 << 24);
	    }
	  if (r_type == R_ARM_CALL)
	    {
	      /* Select the correct instruction (BL or BLX).  */
a4836 2
		value |= (1 << 28);
	      else
d4838 15
a4852 2
		  value &= ~(bfd_vma)(1 << 28);
		  value |= (1 << 24);
d5029 9
@


1.118
log
@2007-05-22  Paul Brook  <paul@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-pic-veneer.d: Update expected output.
	* ld-arm/arm-call.d: Ditto.

	bfd/
	* elf32-arm.c (output_arch_syminfo): Replace plt_shndx and plt_offset
	with sec and sec_shndx.
	(elf32_arm_ouput_plt_map_sym): Use them.
	(elf32_arm_output_arch_local_syms): Output mapping symbols for
	interworking glue.
@
text
@d6972 1
@


1.117
log
@2007-05-18  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (ARM2THUMB_V5_STATIC_GLUE_SIZE): Define.
	(a2t1v5_ldr_insn, a2t1v5_ldr_insn): New.
	(record_arm_to_thumb_glue): Add v5t non-pic glue.
	(elf32_arm_create_thumb_stub): Ditto.

	ld/testsuite/
	* ld-arm/arm-call.d: Update expected output.
@
text
@d10048 2
a10049 2
  int plt_shndx;
  bfd_vma plt_offset;
d10074 3
a10076 1
  sym.st_value = osi->plt_offset + offset;
d10080 2
a10081 2
  sym.st_shndx = osi->plt_shndx;
  if (!osi->func (osi->finfo, names[type], &sym, htab->splt, NULL))
d10162 1
a10162 1
/* Output mapping symbols for the PLT.  */
d10174 2
d10178 1
a10178 2
  if (!htab->splt || htab->splt->size == 0)
    return TRUE;
a10179 1
  check_use_blx(htab);
d10183 46
a10228 1
  osi.plt_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
d10230 1
a10230 2
  osi.plt_offset = htab->splt->output_section->vma;

@


1.116
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2585 7
d2607 4
d2759 2
d4203 9
@


1.115
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Correctly
	handle the Thumb-2 JUMP19 relocation.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add jump19 testcase.
	* ld-arm/jump19.d: New.
	* ld-arm/jump19.s: New.
@
text
@a8379 1
  unsigned int power_of_two;
d8492 1
a8492 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.114
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Don't create PLT entries
	for R_ARM_ABS12 relocs.
	(elf32_arm_finish_dynamic_symbol): Fix the loop that creates
	non-shared VxWorks PLT entries.

ld/testsuite/
	* ld-arm/vxworks1-lib.dd: Expect "push" instead of stmdb and
	"pop" instead of ldmia.  Don't require specific symbolic addresses
	for in-text addresses.  Expect data to be rendered as .words rather
	than disassembled.
	* ld-arm/vxworks1.dd: Likewise.
@
text
@d5216 2
a5217 3
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
d5225 1
a5225 1
	    bfd_vma upper = (upper_insn & 0x001f);
d5230 3
a5232 3
	    upper |= J2 << 6;
	    upper |= J1 << 7;
	    upper |= ~S << 8;
d5246 1
a5247 10
	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
d5259 1
a5259 1
	  upper_insn = (upper_insn & 0xfb30) | (S << 10) | hi;
@


1.113
log
@        bfd/
        * elf32-arm.c (bfd_elf32_arm_vfp11_erratum_scan): Don't
        attempt to scan if the bfd doesn't correspond to an ELF image.
        (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
@
text
@d8065 2
a8066 1
                    && r_type != R_ARM_REL32_NOI)
d9252 1
a9252 1
	      for (i = 0; i != htab->plt_entry_size / 4; i++)
@


1.112
log
@2007-05-03  Sandra Loosemore  <sandra@@codesourcery.com>

	bfd/
	* elf32-arm.c (allocate_dynrelocs): Fix typo in comment.
@
text
@d3651 4
d3826 5
a3830 1
  
@


1.111
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8746 1
a8746 1
      /* The only reloc thats uses pc_count are R_ARM_REL32 and
@


1.110
log
@2007-04-17  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf.c (_bfd_elf_is_function_type): New function.
	* elflink.c (_bfd_elf_merge_symbol): Use bed->is_function_type.
	(_bfd_elf_dynamic_symbol_p, _bfd_elf_symbol_refs_local_p,
	is_global_data_symbol_definition, elf_link_add_object_symbols): Ditto.
	* elf-bfd.h (elf_backend_data): Add is_function_type.
	(_bfd_elf_is_function_type): Add prototype.
	* elfxx-target.h (elf_backend_is_function_type): Add default
	definition.
	(elfNN_bed): Add elf_backend_is_function_type.
	* elf32-arm.c (elf32_arm_is_function_type): New function.
	(elf_backend_is_function_type): Define.

	ld/testsuite/
	* ld-arm/preempt-app.s: New test.
	* ld-arm/preempt-app.sym: New.
	* ld-arm/arm-elf.exp: Add preempt-app.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.109
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d10560 7
d10653 1
@


1.108
log
@2007-03-20  Paul Brook  <paul@@codesourcery.com>

	ld/
	* emultempl/armelf.em (pic_veneer): New variable.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_PIC_VENEER.
	(PARSE_AND_LIST_ARGS_CASES): Ditto.
	(PARSE_AND_LIST_LONGOPTS): Add "pic-veneer".
	(PARSE_AND_LIST_OPTIONS): Ditto.
	* ld.texinfo: Document --pic-veneer.

	ld/testsuite/
	* ld-arm/arm-elf.exp (ld-arm/arm-elf.exp): Add arm-pic-veneer.
	* ld-arm/arm-pic-veneer.d: New test.
	* ld-arm/arm-pic-veneer.s: New test.

	bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_link_hash_table): Add pic_veneer.
	(record_arm_to_thumb_glue): Use globals->pic_veneer.
	(elf32_arm_create_thumb_stub): Ditto.
	(bfd_elf32_arm_set_target_relocs): Set globals->pic_veneer.
@
text
@d1790 25
d10607 1
@


1.107
log
@	bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add "bfd *"
	argument and extra last argument.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_obj_tdata): Add no_enum_size_warning
	member.
	(bfd_elf32_arm_set_target_relocs): Add "bfd *" argument and
	extra last argument.  Set no_enum_size_warning appropriately.
	(elf32_arm_merge_eabi_attributes): Improve enum sizes
	diagnostic, suppressing it when no_enum_size_warning dictates.

	ld/
	* ld.texinfo: Document --no-enum-size-warning.
	* emultempl/armelf.em (no_enum_size_warning): New.
	(arm_elf_create_output_section_statements): Correct typo
	in comment.  Pass no_enum_size_warning to
	bfd_elf32_arm_set_target_relocs.
	(PARSE_AND_LIST_PROLOGUE): Define OPTION_NO_ENUM_SIZE_WARNING.
	(PARSE_AND_LIST_OPTIONS): Document --no-enum-size-warning.
	(PARSE_AND_LIST_ARGS_CASES): Add OPTION_NO_ENUM_SIZE_WARNING
	case.
@
text
@d2194 3
d2720 2
a2721 1
  if ((link_info->shared || globals->root.is_relocatable_executable))
d3875 1
a3875 1
				 int no_enum_warn)
d3896 1
d4135 2
a4136 1
      if ((info->shared || globals->root.is_relocatable_executable))
@


1.106
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d2067 3
d3864 2
a3865 1
bfd_elf32_arm_set_target_relocs (struct bfd_link_info *link_info,
d3870 2
a3871 1
                                 bfd_arm_vfp11_fix vfp11_fix)
d3892 2
d7203 2
a7204 1
		       && out_attr[i].i != in_attr[i].i)
d7206 2
d7209 3
a7211 1
		    (_("ERROR: %B: Conflicting enum sizes"), ibfd);
@


1.105
log
@2007-02-22  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elflink.c (gc_mark_hook_fn): Remove.
	(_bfd_elf_gc_mark): Rename gc_mark_hook_fn to elf_gc_mark_hook_fn.
	(bfd_elf_gc_sections): Ditto.  Call gc_mark_extra_sections.
	* elf-bfd.h (elf_gc_mark_hook_fn): Define.
	(elf_backend_data): Add gc_mark_extra_sections.
	* elfxx-target.h (elf_backend_gc_mark_extra_sections): Provide default
	definition.
	(elfNN_bed): Add elf_backend_gc_mark_extra_sections.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): New function.
	(elf_backend_gc_mark_extra_sections): Define.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add gc-unwind.h.
	* ld-arm/gc-unwind.s: New file.
	* ld-arm/gc-unwind.d: New file.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a4526 9
      /* r_symndx will be zero only for relocs against symbols
	 from removed linkonce sections, or sections discarded by
	 a linker script.  */
      if (r_symndx == 0)
	{
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  return bfd_reloc_ok;
	}

a6494 2
  if (info->relocatable && !globals->use_rel)
    return TRUE;
a6526 23
      if (info->relocatable && globals->use_rel)
	{
	  /* This is a relocatable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  arm_add_to_rel (input_bfd, contents + rel->r_offset,
				  howto,
				  (bfd_signed_vma) (sec->output_offset
						    + sym->st_value));
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d6541 3
a6543 2
	      if ((sec->flags & SEC_MERGE)
		       && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
d6593 28
a10610 1
#define elf_backend_rela_normal     0
a10673 2
#undef elf_backend_rela_normal
#define elf_backend_rela_normal		1
a10825 2
#undef elf_backend_rela_normal
#define elf_backend_rela_normal		0
@


1.104
log
@	* bfd-in2.h: Regenerate.
	* bfd-in.h (bfd_arm_vfp11_fix): New enum. Specify how VFP11
	instruction scanning should be done.
	(bfd_elf32_arm_init_maps, bfd_elf32_arm_vfp11_erratum_scan)
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Add prototypes.
	(bfd_elf32_arm_set_target_relocs): Add vfp11 fix type argument to
	prototype.
	* elf-bfd.h (elf_backend_write_section): Add struct bfd_link_info
	argument.
	* elf32-arm.c (VFP11_ERRATUM_VENEER_SECTION_NAME)
	(VFP11_ERRATUM_VENEER_ENTRY_NAME): Define macros.
	(elf32_vfp11_erratum_type): New enum.
	(elf32_vfp11_erratum_list): New struct. List of veneers or jumps to
	veneers.
	(_arm_elf_section_data): Add mapsize, erratumcount, erratumlist.
	(elf32_arm_link_hash_table): Add vfp11_erratum_glue_size,
	vfp11_fix and num_vfp11_fixes fields.
	(elf32_arm_link_hash_table_create): Initialise vfp11_fix,
	vfp11_erratum_glue_size, num_vfp11_fixes fields.
	(VFP11_ERRATUM_VENEER_SIZE): Define. Size of an (ARM) veneer.
	(bfd_elf32_arm_allocate_interworking_sections): Initialise erratum
	glue section.
	(elf32_arm_section_map_add): Add an code/data mapping symbol entry
	to a section's map.
	(record_vfp11_erratum_veneer): Create a single veneer, and its
	associated symbols.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Add vfp11 erratum glue.
	(bfd_elf32_arm_init_maps): Initialise mapping symbol table for input
	BFDs.
	(bfd_elf32_arm_set_vfp11_fix): Set the type of erratum workaround
	required.
	(bfd_arm_vfp11_pipe): Define VFP11 instruction pipes.
	(bfd_arm_vfp11_regno): Recode a register number from a VFP11 insn.
	(bfd_arm_vfp11_write_mask): Update write mask according to coded
	register number.
	(bfd_arm_vfp11_antidependency): New function.
	(bfd_arm_vfp11_insn_decode): Decode a VFP11 insn.
	(elf32_arm_compare_mapping): Declare.
	(bfd_elf32_arm_vfp11_erratum_scan): Scan the sections of an input
	BFD for potential erratum-triggering insns. Record results.
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Find out where veneers
	and branches to veneers have been placed in virtual memory after
	layout.
	(bfd_elf32_arm_set_target_relocs): Set vfp11_fix field in global
	hash table.
	(elf32_arm_output_symbol_hook): Remove.
	(elf32_arm_write_section): Output veneers, and branches to veneers.
	Use maps from input sections, not output sections, for code
	byte-swapping.
	* elf32-ppc.c (ppc_elf_write_section): Add dummy link_info argument.
	* elf32-score.c (_bfd_score_elf_write_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_write_section): Likewise.
@
text
@d8153 44
d10579 1
@


1.103
log
@2006-11-29  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_to_thumb_export_stub): Assert that output
	section is present.
	(allocate_dynrelocs): Only add export stub for symbols defined in
	this object.
@
text
@d1878 3
d1993 32
d2029 1
d2031 2
d2161 4
d2184 7
d2453 3
d2595 2
d2638 16
d2802 150
d3008 18
d3229 629
d3865 2
a3866 1
				 int use_blx)
d3886 1
d8913 10
a8922 4
    if (!bfd_elf32_arm_process_before_allocation (ibfd, info))
      /* xgettext:c-format */
      _bfd_error_handler (_("Errors encountered processing file %s"),
			  ibfd->filename);
a9961 57
/* Called for each symbol.  Builds a section map based on mapping symbols.
   Does not alter any of the symbols.  */

static bfd_boolean
elf32_arm_output_symbol_hook (struct bfd_link_info *info,
			      const char *name,
			      Elf_Internal_Sym *elfsym,
			      asection *input_sec,
			      struct elf_link_hash_entry *h)
{
  int mapcount;
  elf32_arm_section_map *map;
  elf32_arm_section_map *newmap;
  _arm_elf_section_data *arm_data;
  struct elf32_arm_link_hash_table *globals;

  globals = elf32_arm_hash_table (info);
  if (globals->vxworks_p
      && !elf_vxworks_link_output_symbol_hook (info, name, elfsym,
					       input_sec, h))
    return FALSE;

  /* Only do this on final link.  */
  if (info->relocatable)
    return TRUE;

  /* Only build a map if we need to byteswap code.  */
  if (!globals->byteswap_code)
    return TRUE;

  /* We only want mapping symbols.  */
  if (!bfd_is_arm_special_symbol_name (name, BFD_ARM_SPECIAL_SYM_TYPE_MAP))
    return TRUE;

  /* If this section has not been allocated an _arm_elf_section_data
     structure then we cannot record anything.  */
  arm_data = get_arm_elf_section_data (input_sec);
  if (arm_data == NULL)
    return TRUE;

  mapcount = arm_data->mapcount + 1;
  map = arm_data->map;

  /* TODO: This may be inefficient, but we probably don't usually have many
     mapping symbols per section.  */
  newmap = bfd_realloc (map, mapcount * sizeof (* map));
  if (newmap != NULL)
    {
      arm_data->map = newmap;
      arm_data->mapcount = mapcount;

      newmap[mapcount - 1].vma = elfsym->st_value;
      newmap[mapcount - 1].type = name[1];
    }

  return TRUE;
}
d10167 2
a10168 1
elf32_arm_write_section (bfd *output_bfd ATTRIBUTE_UNUSED, asection *sec,
d10171 1
a10171 1
  int mapcount;
d10173 1
d10175 1
d10178 1
a10178 1
  bfd_vma offset;
d10190 76
d10270 3
a10272 1
  qsort (map, mapcount, sizeof (* map), elf32_arm_compare_mapping);
d10274 23
a10296 8
  offset = sec->output_section->vma + sec->output_offset;
  ptr = map[0].vma - offset;
  for (i = 0; i < mapcount; i++)
    {
      if (i == mapcount - 1)
	end = sec->size;
      else
	end = map[i + 1].vma - offset;
d10298 10
a10307 15
      switch (map[i].type)
	{
	case 'a':
	  /* Byte swap code words.  */
	  while (ptr + 3 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 3];
	      contents[ptr + 3] = tmp;
	      tmp = contents[ptr + 1];
	      contents[ptr + 1] = contents[ptr + 2];
	      contents[ptr + 2] = tmp;
	      ptr += 4;
	    }
	  break;
d10309 3
a10311 8
	case 't':
	  /* Byte swap code halfwords.  */
	  while (ptr + 1 < end)
	    {
	      tmp = contents[ptr];
	      contents[ptr] = contents[ptr + 1];
	      contents[ptr + 1] = tmp;
	      ptr += 2;
d10313 2
a10314 7
	  break;

	case 'd':
	  /* Leave data alone.  */
	  break;
	}
      ptr = end;
d10319 1
a10542 1
#define elf_backend_link_output_symbol_hook	elf32_arm_output_symbol_hook
@


1.102
log
@2006-11-29  Paul Brook  <paul@@codesourcery.com>
	Julian Brown  <julian@@codesourcery.com>

	bfd/
	* elf32-arm.c (copy_eabi_attributes): Correct starting offset.
	(elf32_arm_merge_eabi_attributes): Mark output as initialized.
	Only set Tag_CPU_name and Tag_ABI_PCS_R9_use if input attribute
	is present.
@
text
@d3383 3
d7755 1
@


1.101
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	(bfd_elf32_arm_set_byteswap_code): New prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Don't take
	byteswap_code as an argument.  Revert 2006-11-01 change.
	(bfd_elf32_arm_set_byteswap_code): New.
	(elf32_arm_size_dynamic_sections): Call
	bfd_elf32_arm_process_before_allocation.
ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Only call
	bfd_elf32_arm_process_before_allocation if no dynamic sections.
@
text
@d6043 2
a6044 2
  in_attr = elf32_arm_tdata (ibfd)->known_eabi_attributes;
  out_attr = elf32_arm_tdata (obfd)->known_eabi_attributes;
d6175 1
a6175 1
  if (!elf32_arm_tdata (ibfd)->known_eabi_attributes[0].i)
d6179 5
a6186 4
  /* Use the Tag_null value to indicate the attributes have been
     initialized.  */
  elf32_arm_tdata (ibfd)->known_eabi_attributes[0].i = 1;

d6211 5
a6215 2
	  /* Use whichever has the greatest architecture requirements.  */
	  if (in_attr[Tag_CPU_arch].i > out_attr[Tag_CPU_arch].i)
d6267 2
a6268 1
	  if (out_attr[i].i != AEABI_R9_unused
@


1.100
log
@	* elf32-arm.c (find_thumb_glue): Add ERROR_MESSAGE argument; set it
	on error.
	(find_arm_glue): Likewise.
	(elf32_thumb_to_arm_stub, elf32_arm_create_thumb_stub)
	(elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate): Add
	ERROR_MESSAGE argument and pass it through.
	(elf32_arm_to_thumb_export_stub): Update.
	(elf32_arm_relocate_section): Use ERROR_MESSAGE and reloc_dangerous.
@
text
@d2829 1
a2829 2
					 struct bfd_link_info *link_info,
					 int byteswap_code)
d2852 1
a2852 1
  if (byteswap_code && !bfd_big_endian (abfd))
a2857 1
  globals->byteswap_code = byteswap_code;
d2933 3
a2935 13
	  /* If the call will go through a PLT entry then we do not
	     need glue.  We have to do a fairly complicated check
	     here, since we don't determine this finally (by setting
	     plt.offset) until later; this test should be kept in sync
	     with elf32_arm_adjust_dynamic_symbol.  */
	  if (globals->splt != NULL
	      && h->plt.refcount > 0
	      && (h->type == STT_FUNC
		  || h->type == STT_ARM_TFUNC
		  || h->needs_plt)
	      && !SYMBOL_CALLS_LOCAL (link_info, h)
	      && !(ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		   && h->root.type == bfd_link_hash_undefweak))
d7908 10
d8033 7
@


1.99
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2432 1
a2432 1
		 bfd *input_bfd)
d2452 2
a2453 3
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%B: unable to find THUMB glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);
d2465 1
a2465 1
	       bfd *input_bfd)
d2485 2
a2486 3
    /* xgettext:c-format */
    (*_bfd_error_handler) (_("%B: unable to find ARM glue '%s' for `%s'"),
			   input_bfd, tmp_name, name);
d3127 2
a3128 1
			 bfd_vma                val)
d3137 1
a3137 1
  myh = find_thumb_glue (info, name, input_bfd);
d3232 2
a3233 1
			     asection		    *s)
d3240 1
a3240 1
  myh = find_arm_glue (info, name, input_bfd);
d3318 2
a3319 1
			 bfd_vma                val)
d3340 1
a3340 1
				     sym_sec, val, s);
d3376 1
d3399 2
a3400 1
				     globals->obfd, sec, val, s);
d3581 2
a3582 1
			       bfd_boolean *                unresolved_reloc_p)
d3854 8
a3861 5
		  elf32_arm_to_thumb_stub (info, sym_name, input_bfd,
					   output_bfd, input_section,
					   hit_data, sym_sec, rel->r_offset,
					   signed_addend, value);
		  return bfd_reloc_ok;
d4153 2
a4154 1
		     hit_data, sym_sec, rel->r_offset, signed_addend, value))
d5665 1
d5799 1
a5799 1
					 &unresolved_reloc);
a5819 2
	  const char * msg = (const char *) 0;

d5843 1
a5843 1
	      msg = _("internal error: out of range error");
d5847 1
a5847 1
	      msg = _("internal error: unsupported relocation error");
d5851 1
a5851 1
	      msg = _("internal error: dangerous error");
d5855 1
a5855 1
	      msg = _("internal error: unknown error");
d5859 3
a5861 2
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
@


1.98
log
@	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Correct
	check for PLT usage.
@
text
@d3667 4
a3670 1
	return bfd_reloc_ok;
@


1.97
log
@bfd/
	* elf32-arm.c (bfd_elf32_arm_allocate_interworking_sect): Check,
	don't set, glue section size.
	(record_arm_to_thumb_glue): Set glue section size here.
	(record_thumb_to_arm_glue): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Formatting.
	(bfd_elf32_arm_process_before_allocation): Ignore exluded sections.

ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Run
	gld${EMULATION_NAME}_before_allocation later.
	* ldlang.c (lang_size_sections_1): Revert 2006-09-15 change.
@
text
@d2937 13
a2949 3
	  /* If the call will go through a PLT entry then we do not need
	     glue.  */
	  if (globals->splt != NULL && h->plt.offset != (bfd_vma) -1)
@


1.96
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Add support for
	R_ARM_MOVW_BREL_NC, R_ARM_MOVW_BREL, R_ARM_MOVT_BREL,
	R_ARM_THM_MOVW_BREL_NC, R_ARM_THM_MOVW_BREL and
	R_ARM_THM_MOVT_BREL relocations.
@
text
@d2568 1
a2568 1
      s->size = globals->arm_glue_size;
d2583 1
a2583 1
      s->size = globals->thumb_glue_size;
d2603 1
d2647 1
a2647 1
    globals->arm_glue_size += ARM2THUMB_PIC_GLUE_SIZE;
d2649 4
a2652 1
    globals->arm_glue_size += ARM2THUMB_STATIC_GLUE_SIZE;
d2728 1
d2756 2
a2757 1
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_CODE | SEC_READONLY;
d2776 2
a2777 2
      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	| SEC_CODE | SEC_READONLY;
d2874 3
@


1.95
log
@	bfd/
	* elf32-arm.c (elf32_arm_howto_table_1): Change offset for
	R_THM_CALL to 25 and remove FIXME comment.
	(using_thumb2): New function.
	(elf32_arm_final_link_relocate): Cope with Thumb-2 BL encoding.

	include/
	* elf/arm.h: Define TAG_CPU_ARCH_* constants.

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb1-bl, thumb2-bl,
	thumb2-bl-as-thumb1-bad and thumb2-bl-bad tests.
	* ld-arm/thumb1-bl.d: New.
	* ld-arm/thumb1-bl.s: New.
	* ld-arm/thumb2-bl-as-thumb1-bad.d: New.
	* ld-arm/thumb2-bl-as-thumb1-bad.s: New.
	* ld-arm/thumb2-bl-bad.d: New.
	* ld-arm/thumb2-bl-bad.s: New.
	* ld-arm/thumb2-bl.d: New.
	* ld-arm/thumb2-bl.s: New.
@
text
@d4835 7
d4850 1
a4851 2
	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;
d4857 8
a4864 1
	if (r_type == R_ARM_MOVT_ABS || r_type == R_ARM_MOVT_PREL)
d4878 8
d4900 1
a4901 2
	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;
d4907 8
a4914 1
	if (r_type == R_ARM_THM_MOVT_ABS || r_type == R_ARM_THM_MOVT_PREL)
@


1.94
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Add cases
	for R_ARM_ABS32_NOI and R_ARM_REL32_NOI.
	(elf32_arm_gc_sweep_hook): Likewise.
	(elf32_arm_check_relocs): Likewise.
	(allocate_dynrelocs): Likewise.
@
text
@a219 1
  /* FIXME: Has two more bits of offset in Thumb32.  */
d223 1
a223 1
	 23,			/* bitsize */
d3536 8
d4066 1
d4070 2
a4071 2
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
d4074 2
d4077 2
a4078 2
	/* Need to refetch the addend and squish the two 11 bit pieces
	   together.  */
d4081 12
a4092 4
	    bfd_vma upper = upper_insn & 0x7ff;
	    bfd_vma lower = lower_insn & 0x7ff;
	    upper = (upper ^ 0x400) - 0x400; /* Sign extend.  */
	    addend = (upper << 12) | (lower << 1);
d4169 9
d4189 11
a4199 3
	/* Put RELOCATION back into the insn.  */
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 12) & 0x7ff);
	lower_insn = (lower_insn & ~(bfd_vma) 0x7ff) | ((relocation >> 1) & 0x7ff);
@


1.93
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d3629 1
d3631 1
d3647 2
a3648 1
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
d3672 1
a3672 1
	  && (r_type != R_ARM_REL32
d3904 4
d3916 6
d6803 1
d6805 1
d6838 3
a6840 1
		  || r_type == R_ARM_REL32)
d6847 2
a6848 1
		      if (ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
d7026 1
d7028 1
d7059 4
a7062 1
		if (r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
d7087 1
a7087 1
		&& (r_type == R_ARM_ABS32
d7171 1
a7171 1
		if (r_type == R_ARM_REL32)
d7706 6
a7711 6
      /* The only reloc that uses pc_count is R_ARM_REL32, which will
	 appear on something like ".long foo - .".  We want calls to
	 protected symbols to resolve directly to the function rather
	 than going via the plt.  If people want function pointer
	 comparisons to work as expected then they should avoid
	 writing assembly like ".long foo - .".  */
@


1.92
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d3734 2
d3743 5
a3747 1
		     will not appear in the dynamic symbol table.)  */
d3749 1
a3749 1
		    symbol = elf_section_data (sym_sec->output_section)->dynindx;
d3751 13
a3763 1
		    symbol = elf_section_data (input_section->output_section)->dynindx;
d8572 2
a8573 1
      elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
d9516 1
@


1.91
log
@	* elfcode.h (elf_swap_symbol_in): Return bfd_boolean.  Don't abort
	on error.
	* elf-bfd.h (elf_size_info <swap_symbol_in>): Adjust decl.
	(bfd_elf32_swap_symbol_in, bfd_elf64_swap_symbol_in): Likewise.
	* elf.c (bfd_elf_get_elf_syms): Test return of swap_symbol_in,
	and report error.
	* elf32-arm.c (elf32_arm_swap_symbol_in): Return bfd_boolean.
@
text
@d6692 5
a6696 5
elf32_arm_gc_mark_hook (asection *                   sec,
			struct bfd_link_info *       info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *          rel,
			struct elf_link_hash_entry * h,
			Elf_Internal_Sym *           sym)
d6699 1
a6699 2
    {
      switch (ELF32_R_TYPE (rel->r_info))
d6703 2
a6704 19
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

	  default:
	    break;
          }
       }
     }
   else
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d6706 1
a6706 1
  return NULL;
@


1.90
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d9341 1
a9341 1
static void
d9347 2
a9348 1
  bfd_elf32_swap_symbol_in (abfd, psrc, pshn, dst);
d9358 1
@


1.89
log
@2006-09-08  Vladimir Prus  <vladimir@@codesourcery.com>

	* elf32-arm.c (elf32_arm_swap_symbol_out): Remove
	unconditional setting of low bit for Thumb symbol
	mistakenly left behind after check for external
	symbols was added.  Fix comment typo.
@
text
@d2224 1
a2224 1
    return strncmp (name, ".rel", 4) == 0 && strcmp (s->name, name + 4) == 0;
d2226 1
a2226 1
    return strncmp (name, ".rela", 5) == 0 && strcmp (s->name, name + 5) == 0;
d7941 1
a7941 1
      else if (strncmp (name, ".rel", 4) == 0)
d7955 1
a7955 1
      else if (strncmp (name, ".got", 4) != 0
d8683 2
a8684 6
  size_t len1, len2;

  len1 = sizeof (ELF_STRING_ARM_unwind) - 1;
  len2 = sizeof (ELF_STRING_ARM_unwind_once) - 1;
  return (strncmp (name, ELF_STRING_ARM_unwind, len1) == 0
	  || strncmp (name, ELF_STRING_ARM_unwind_once, len2) == 0);
d9655 5
a9659 5
  { ".dynamic",        8,  0, SHT_DYNAMIC,  0 },
  { ".dynstr",         7,  0, SHT_STRTAB,   0 },
  { ".dynsym",         7,  0, SHT_DYNSYM,   0 },
  { ".got",            4,  0, SHT_PROGBITS, 0 },
  { ".hash",           5,  0, SHT_HASH,     0 },
d9663 4
a9666 4
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
@


1.88
log
@	bfd/
        * elf32-arm.c (elf32_arm_howto_table_1): Adjust entries for
        R_ARM_THM_ALU_PREL_11_0 and R_ARM_THM_PC12 relocations.
        (elf32_arm_final_link_relocate): Handle R_ARM_THM_ALU_PREL_11_0
        and R_ARM_THM_PC12 relocations.
@
text
@d9388 1
a9388 1
             the thumbness of underfined symbols can well be different at
a9393 2

      newsym.st_value |= 1;
@


1.87
log
@	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Only copy
	plt_thumb_refcount from indirect symbols.
@
text
@d838 1
a838 1
	 complain_overflow_signed,/* complain_on_overflow */
d842 2
a843 2
	 0x040070ff,		/* src_mask */
	 0x040070ff,		/* dst_mask */
d852 1
a852 1
	 complain_overflow_signed,/* complain_on_overflow */
d856 2
a857 2
	 0x040070ff,		/* src_mask */
	 0x040070ff,		/* dst_mask */
d3948 75
@


1.86
log
@	bfd/
	* elf32-arm.c (elf32_arm_link_hash_table): Correct typo in
	comment for target1_is_rel.
@
text
@d2359 5
a2363 3
  /* Copy over PLT info.  */
  edir->plt_thumb_refcount += eind->plt_thumb_refcount;
  eind->plt_thumb_refcount = 0;
d2365 5
a2369 5
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
@


1.85
log
@Add comment missing from previous patch.
@
text
@d2131 1
a2131 1
       Nonzero if R_ARM_TARGET1 means R_ARM_ABS32.  */
@


1.84
log
@2006-08-18  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_link_hash_entry): Add export_glue.
	(elf32_arm_link_hash_newfunc): Initialize export_glue.
	(record_arm_to_thumb_glue): Return stub symbol.
	(elf32_arm_create_thumb_stub): New function.
	(elf32_arm_to_thumb_stub): Use it.
	(elf32_arm_to_thumb_export_stub): New function.
	(elf32_arm_begin_write_processing): New function.
	(allocate_dynrelocs): Allocate Arm stubs.
	(elf_backend_begin_write_processing): Define.
	(elf32_arm_symbian_begin_write_processing): Remove ATTRIBUTE_UNUSED.
	Call elf32_arm_begin_write_processing.

	ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Call
	gld${EMULATION_NAME}_before_allocation after setting interworking bfd.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add armthumb-lib.so.  Add
	-use-blx to mixed-lib.so
	* ld-arm/armthumb-lib.d: New file.
	* ld-arm/armthumb-lib.sym: New file.
@
text
@d3393 2
@


1.83
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d2095 4
d2210 1
d2589 3
a2591 1
static void
d2626 1
a2626 1
      return;
d2649 1
a2649 1
  return;
d3204 1
a3204 1
/* Arm code calling a Thumb function.  */
d3206 8
a3213 11
static int
elf32_arm_to_thumb_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
a3214 1
  unsigned long int tmp;
a3215 1
  asection * s;
d3222 1
a3222 1
    return FALSE;
a3229 5
  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);
d3283 41
d3343 57
d7563 30
d9455 2
d9598 1
a9598 2
					  struct bfd_link_info *link_info
					    ATTRIBUTE_UNUSED)
d9609 1
@


1.82
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@a2040 2
  bfd_size_type amt = sizeof (struct elf32_arm_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d2042 7
a2048 2
    return FALSE;
  return TRUE;
@


1.81
log
@2006-06-19  Vladimir Prus  <vladimir@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_swap_symbol_out): Don't set low
	bit for undefined symbols.

	ld/testsuite
	* ld-arm/arm-elf.exp: New test.
	* ld-arm/use-thumb-lib.s: New file.
	* ld-arm/use-thumb-lib.sym: New file.
@
text
@d9496 10
a9505 3
      m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
      m->next = elf_tdata (abfd)->segment_map;
      elf_tdata (abfd)->segment_map = m;
@


1.80
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d9175 13
@


1.79
log
@	* include/elf/arm.h: Correct names of R_ARM_LDC_G{0,1,2}
	to R_ARM_LDC_SB_G{0,1,2} respectively.

bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (R_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0,
	R_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1, R_ARM_ALU_PC_G2,
	R_ARM_LDR_PC_G1, R_ARM_LDR_PC_G2, R_ARM_LDRS_PC_G0,
	R_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G2, R_ARM_LDC_PC_G0,
	R_ARM_LDC_PC_G1, R_ARM_LDC_PC_G2, R_ARM_ALU_SB_G0_NC,
	R_ARM_ALU_SB_G0, R_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1,
	R_ARM_ALU_SB_G2, R_ARM_LDR_SB_G0, R_ARM_LDR_SB_G1,
	R_ARM_LDR_SB_G2, R_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G1,
	R_ARM_LDRS_SB_G2, R_ARM_LDC_SB_G0, R_ARM_LDC_SB_G1,
	R_ARM_LDC_SB_G2): New relocation types.
	(R_ARM_PC13): Rename to AAELF name R_ARM_LDR_PC_G0 and
	adjust HOWTO entry to be consistent with R_ARM_LDR_PC_G1
	and friends.
	(elf32_arm_howto_table_3): Delete; contents merged into
	elf32_arm_howto_table_2.
	(elf32_arm_howto_from_type): Adjust correspondingly.
	(elf32_arm_reloc_map): Extend with the above relocations.
	(calculate_group_reloc_mask): New function.
	(identify_add_or_sub): New function.
	(elf32_arm_final_link_relocate): Support for the above
	relocations.
	* reloc.c: Add enumeration entries for BFD_RELOC_ARM_...
	codes to correspond to the above relocations.

gas/
	* config/tc-arm.c (enum parse_operand_result): New.
	(struct group_reloc_table_entry): New.
	(enum group_reloc_type): New.
	(group_reloc_table): New array.
	(find_group_reloc_table_entry): New function.
	(parse_shifter_operand_group_reloc): New function.
	(parse_address_main): New function, incorporating code
	from the old parse_address function.  To be used via...
	(parse_address): wrapper for parse_address_main; and
	(parse_address_group_reloc): new function, likewise.
	(enum operand_parse_code): New codes OP_SHG, OP_ADDRGLDR,
	OP_ADDRGLDRS, OP_ADDRGLDC.
	(parse_operands): Support for these new operand codes.
	New macro po_misc_or_fail_no_backtrack.
	(encode_arm_cp_address): Preserve group relocations.
	(insns): Modify to use the above operand codes where group
	relocations are permitted.
	(md_apply_fix): Handle the group relocations
	ALU_PC_G0_NC through LDC_SB_G2.
	(tc_gen_reloc): Likewise.
	(arm_force_relocation): Leave group relocations for the linker.
	(arm_fix_adjustable): Likewise.

gas/testsuite/
	* gas/arm/group-reloc-alu.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.l: New test.
	* gas/arm/group-reloc-alu-encoding-bad.s: New test.
	* gas/arm/group-reloc-alu-parsing-bad.d: New test.
	* gas/arm/group-reloc-alu-parsing-bad.l: New test.
	* gas/arm/group-reloc-alu-parsing-bad.s: New test.
	* gas/arm/group-reloc-alu.s: New test.
	* gas/arm/group-reloc-ldc.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldc.s: New test.
	* gas/arm/group-reloc-ldr.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldr.s: New test.
	* gas/arm/group-reloc-ldrs.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldrs.s: New test.

ld/testsuite/
	* ld-arm/group-relocs-alu-bad.d: New test.
	* ld-arm/group-relocs-alu-bad.s: New test.
	* ld-arm/group-relocs.d: New test.
	* ld-arm/group-relocs-ldc-bad.d: New test.
	* ld-arm/group-relocs-ldc-bad.s: New test.
	* ld-arm/group-relocs-ldr-bad.d: New test.
	* ld-arm/group-relocs-ldr-bad.s: New test.
	* ld-arm/group-relocs-ldrs-bad.d: New test.
	* ld-arm/group-relocs-ldrs-bad.s: New test.
	* ld-arm/group-relocs.s: New test.
	* ld-arm/arm-elf.exp: Wire in new tests.
@
text
@d9220 2
a9221 1
elf32_arm_additional_program_headers (bfd *abfd)
@


1.78
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d133 1
a133 1
  HOWTO (R_ARM_PC13,		/* type */
d136 2
a137 2
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
d139 1
a139 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d141 1
a141 1
	 "R_ARM_PC13",		/* name */
d143 3
a145 3
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
a886 1
};
d888 381
a1268 2
/* Relocations 57 .. 83 are the "group relocations" which we do not
   support.  */
a1269 2
static reloc_howto_type elf32_arm_howto_table_2[] =
{
d1609 1
a1609 1
static reloc_howto_type elf32_arm_howto_table_3[4] =
a1673 4
  if (r_type >= R_ARM_MOVW_BREL_NC
      && r_type < R_ARM_MOVW_BREL_NC + NUM_ELEM (elf32_arm_howto_table_2))
    return &elf32_arm_howto_table_2[r_type - R_ARM_MOVW_BREL_NC];

d1676 1
a1676 1
    return &elf32_arm_howto_table_3[r_type - R_ARM_RREL32];
d1749 28
d3367 68
d4658 391
@


1.77
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf-bfd.h (elf_backend_data): Add elf_backend_output_arch_local_syms
	* elf32-arm.c (output_arch_syminfo): Define.
	(elf32_arm_ouput_plt_map_sym, elf32_arm_output_plt_map,
	elf32_arm_output_arch_local_syms): New functions.
	(elf_backend_output_arch_local_syms): Define.
	* elflink.c (bfd_elf_final_link): Call
	elf_backend_output_arch_local_syms.
	* elfxx-target.h (elf_backend_output_arch_local_syms): Provide default
	definition.
	(elfNN_bed): Add elf_backend_output_arch_local_syms.
ld/testsuite/
	* ld-arm/arm-app-abs32.d: Update expected output.
	* ld-arm/arm-app.d: Ditto.
	* ld-arm/arm-lib-plt32.d: Ditto.
	* ld-arm/arm-lib.d: Ditto.
	* ld-arm/mixed-app-v5.d: Ditto.
	* ld-arm/mixed-app.d: Ditto.
	* ld-arm/mixed-lib.d: Ditto.
@
text
@d65 1
a65 1
static const struct elf_backend_data elf32_arm_vxworks_bed;
d8409 1
@


1.76
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (put_arm_insn, put_thumb_insn): New functions.
	(elf32_thumb_to_arm_stub, elf32_arm_to_thumb_stub,
	elf32_arm_finish_dynamic_symbol): Use them.
@
text
@d7953 168
d8451 2
@


1.75
log
@2006-05-15  Paul Brook  <paul@@codesourcery.com>

bfd/
	* cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename ...
	(bfd_is_arm_special_symbol_name): ... to this.  Add type argument.
	Check symbol name is of specified type.
	* elf32-arm.c (elf32_arm_is_target_special_symbol,
	arm_elf_find_function, elf32_arm_output_symbol_hook): Use
	bfd_is_arm_special_symbol_name.
	* bfd-in.h (BFD_ARM_SPECIAL_SYM_TYPE_MAP,
	BFD_ARM_SPECIAL_SYM_TYPE_TAG, BFD_ARM_SPECIAL_SYM_TYPE_OTHER,
	BFD_ARM_SPECIAL_SYM_TYPE_ANY): Define.
	(bfd_is_arm_mapping_symbol_name): Remove prototype.
	(bfd_is_arm_special_symbol_name): Add prototype.
	* bfd-in2.h: Regenerate.
gas/
	* config/tc-arm.c (arm_adjust_symtab): Use
	bfd_is_arm_special_symbol_name.
ld/testsuite/
	* ld-arm/arm-be8.d: New test.
	* ld-arm/arm-be8.s: New test.
	* ld-arm/arm-elf.exp: Add arm-be8.
@
text
@d2658 29
d2743 2
a2744 2
      bfd_put_16 (output_bfd, (bfd_vma) t2a1_bx_pc_insn,
		  s->contents + my_offset);
d2746 2
a2747 2
      bfd_put_16 (output_bfd, (bfd_vma) t2a2_noop_insn,
		  s->contents + my_offset + 2);
d2765 3
a2767 3
      bfd_put_32 (output_bfd,
		  (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
		  s->contents + my_offset + 4);
d2852 6
a2857 6
	  bfd_put_32 (output_bfd, (bfd_vma) a2t1p_ldr_insn,
		      s->contents + my_offset);
	  bfd_put_32 (output_bfd, (bfd_vma) a2t2p_add_pc_insn,
		      s->contents + my_offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) a2t3p_bx_r12_insn,
		      s->contents + my_offset + 8);
d2869 2
a2870 2
	  bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
		      s->contents + my_offset);
d2872 2
a2873 2
	  bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
		      s->contents + my_offset + 4);
d7016 6
a7021 5
	  unsigned i;
	  for (i = 0; i < htab->plt_entry_size / 4; ++i)
	    bfd_put_32 (output_bfd, 
			elf32_arm_symbian_plt_entry[i],
			splt->contents + h->plt.offset + 4 * i);
d7026 1
a7026 1
			  + h->plt.offset + 4 * (i - 1));
d7041 1
d7067 1
d7073 1
a7073 1
	      for (i = 0; i != htab->plt_entry_size / 4; i++)
d7080 4
a7083 2
		  bfd_put_32 (output_bfd, val,
			      htab->splt->contents + h->plt.offset + i * 4);
d7100 4
a7103 2
		  bfd_put_32 (output_bfd, val,
			      htab->splt->contents + h->plt.offset + i * 4);
d7136 4
a7139 4
		  bfd_put_16 (output_bfd, elf32_arm_plt_thumb_stub[0],
			      splt->contents + h->plt.offset - 4);
		  bfd_put_16 (output_bfd, elf32_arm_plt_thumb_stub[1],
			      splt->contents + h->plt.offset - 2);
d7142 12
a7153 12
	      bfd_put_32 (output_bfd,
			  elf32_arm_plt_entry[0]
			  | ((got_displacement & 0x0ff00000) >> 20),
			  splt->contents + h->plt.offset + 0);
	      bfd_put_32 (output_bfd,
			  elf32_arm_plt_entry[1]
			  | ((got_displacement & 0x000ff000) >> 12),
			  splt->contents + h->plt.offset + 4);
	      bfd_put_32 (output_bfd,
			  elf32_arm_plt_entry[2]
			  | (got_displacement & 0x00000fff),
			  splt->contents + h->plt.offset + 8);
d7155 1
a7155 2
	      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
			  splt->contents + h->plt.offset + 12);
d7465 6
a7470 3
	      bfd_put_32 (output_bfd, plt0_entry[0], splt->contents + 0);
	      bfd_put_32 (output_bfd, plt0_entry[1], splt->contents + 4);
	      bfd_put_32 (output_bfd, plt0_entry[2], splt->contents + 8);
d7485 8
a7492 4
	      bfd_put_32 (output_bfd, plt0_entry[0], splt->contents + 0);
	      bfd_put_32 (output_bfd, plt0_entry[1], splt->contents + 4);
	      bfd_put_32 (output_bfd, plt0_entry[2], splt->contents + 8);
	      bfd_put_32 (output_bfd, plt0_entry[3], splt->contents + 12);
@


1.74
log
@2006-05-11  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_reloc_map): Add MOVW and MOVT relocs.
	(elf32_arm_final_link_relocate): Handle MOVW and MOVT relocs.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* reloc.c: Ditto.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
gas/
	* config/tc-arm.c (parse_half): New function.
	(operand_parse_code): Remove OP_Iffff.  Add OP_HALF.
	(parse_operands): Ditto.
	(do_mov16): Reject invalid relocations.
	(do_t_mov16): Ditto.  Use Thumb reloc numbers.
	(insns): Replace Iffff with HALF.
	(md_apply_fix): Add MOVW and MOVT relocs.
	(tc_gen_reloc): Ditto.
	* doc/c-arm.texi: Document relocation operators
ld/testsuite/
	* ld-arm/arm-elf.exp: Add arm-movwt.
	* ld-arm/arm-movwt.d: New test.
	* ld-arm/arm-movwt.s: New test.
	* ld-arm/arm.ld: Add .far.
@
text
@d6113 2
a6114 1
  return bfd_is_arm_mapping_symbol_name (sym->name);
d6150 1
a6150 1
	  /* Skip $a and $t symbols.  */
d6152 2
a6153 1
	      && bfd_is_arm_mapping_symbol_name (q->symbol.name))
d7884 1
a7884 1
  if (! bfd_is_arm_mapping_symbol_name (name))
@


1.73
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d1369 8
d4091 70
d5732 8
d5950 8
d5974 1
a5974 6
		if (r_type == R_ARM_PC24
		    || r_type == R_ARM_CALL
		    || r_type == R_ARM_JUMP24
		    || r_type == R_ARM_PREL31
		    || r_type == R_ARM_PLT32
		    || r_type == R_ARM_THM_CALL)
@


1.72
log
@2006-05-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton bit
	for R_ARM_REL32.
gas/
	* config/tc-arm.c (arm_optimize_expr): New function.
	* config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld-arm/thumb-rel32.d: New test.
	* ld-arm/thumb-rel32.s: New test.
@
text
@d7825 4
a7828 2
  _arm_elf_section_data *sdata;
  bfd_size_type amt = sizeof (*sdata);
d7830 5
a7834 4
  sdata = bfd_zalloc (abfd, amt);
  if (sdata == NULL)
    return FALSE;
  sec->used_by_bfd = sdata;
@


1.71
log
@2006-04-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2467
	* elf.c (_bfd_elf_close_and_cleanup): Check elf_tdata (abfd)
	is NULL first.

	* elf32-arm.c (elf32_arm_close_and_cleanup): Check if
	abfd->sections is NULL.
	(elf32_arm_bfd_free_cached_info): New.
	(bfd_elf32_bfd_free_cached_info): Defined.

	* elfxx-target.h (bfd_elfNN_bfd_free_cached_info): Default it
	to _bfd_free_cached_info.

	* libbfd-in.h (_bfd_free_cached_info): New.
	* libbfd: Regenerated.

	* opncls.c (_bfd_delete_bfd): Check if abfd->memory is NULL.
	(_bfd_free_cached_info): New.
@
text
@d3277 3
a3281 1
	  value += addend;
@


1.70
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d7939 4
a7942 1
  bfd_map_over_sections (abfd, unrecord_section_via_map_over_sections, NULL);
d7947 11
d8117 1
@


1.70.6.1
log
@2006-05-02  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton bit
	for R_ARM_REL32.
gas/
	* config/tc-arm.c (arm_optimize_expr): New function.
	* config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld-arm/thumb-rel32.d: New test.
	* ld-arm/thumb-rel32.s: New test.
@
text
@a3276 3
	  value += addend;
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
d3279 1
@


1.70.2.1
log
@2006-05-01  Paul Brook  <paul@@codesourcery.com>

	* bfd/elf32-arm.c (elf32_arm_final_link_relocate): Set thumb funciton
	bit for R_ARM_REL32.
	* gas/config/tc-arm.c (arm_optimize_expr): New function.
	* gas/config/tc-arm.h (md_optimize_expr): Define
	(arm_optimize_expr): Add prototype.
	(TC_FORCE_RELOCATION_SUB_SAME): Define.
	* ld/testsuite/ld-arm/arm-elf.exp: Add thumb-rel32.
	* ld/testsuite/ld-arm/thumb-rel32.d: New test.
	* ld/testsuite/ld-arm/thumb-rel32.s: New test.
@
text
@a3276 3
	  value += addend;
	  if (sym_flags == STT_ARM_TFUNC)
	    value |= 1;
d3279 1
@


1.70.2.2
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>

	* bfd/elf32-arm.c (elf32_arm_reloc_map): Add MOVW and MOVT relocs.
	(elf32_arm_final_link_relocate): Handle MOVW and MOVT relocs.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* bfd/reloc.c: Ditto.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/libbfd.h: Regenerate.
	* bfd/libcoff.h: Regenerate.
	* gas/config/tc-arm.c (parse_half): New function.
	(operand_parse_code): Remove OP_Iffff.  Add OP_HALF.
	(parse_operands): Ditto.
	(do_mov16): Reject invalid relocations.
	(do_t_mov16): Ditto.  Use Thumb reloc numbers.
	(insns): Replace Iffff with HALF.
	(md_apply_fix): Add MOVW and MOVT relocs.
	(tc_gen_reloc): Ditto.
	* gas/doc/c-arm.texi: Document relocation operators
	* ld/testsuite/ld-arm/arm-elf.exp: Add arm-movwt.
	* ld/testsuite/ld-arm/arm-movwt.d: New test.
	* ld/testsuite/ld-arm/arm-movwt.s: New test.
	* ld/testsuite/ld-arm/arm.ld: Add .far.
@
text
@a1368 8
    {BFD_RELOC_ARM_MOVW,	     R_ARM_MOVW_ABS_NC},
    {BFD_RELOC_ARM_MOVT,	     R_ARM_MOVT_ABS},
    {BFD_RELOC_ARM_MOVW_PCREL,	     R_ARM_MOVW_PREL_NC},
    {BFD_RELOC_ARM_MOVT_PCREL,	     R_ARM_MOVT_PREL},
    {BFD_RELOC_ARM_THUMB_MOVW,	     R_ARM_THM_MOVW_ABS_NC},
    {BFD_RELOC_ARM_THUMB_MOVT,	     R_ARM_THM_MOVT_ABS},
    {BFD_RELOC_ARM_THUMB_MOVW_PCREL, R_ARM_THM_MOVW_PREL_NC},
    {BFD_RELOC_ARM_THUMB_MOVT_PCREL, R_ARM_THM_MOVT_PREL},
a4082 70
    case R_ARM_MOVW_ABS_NC:
    case R_ARM_MOVT_ABS:
    case R_ARM_MOVW_PREL_NC:
    case R_ARM_MOVT_PREL:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);

	if (globals->use_rel)
	  {
	    addend = ((insn >> 4) & 0xf000) | (insn & 0xfff);
	    signed_addend = (addend ^ 0x10000) - 0x10000;
	  }
	value += signed_addend;
	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;

	if (r_type == R_ARM_MOVW_PREL_NC || r_type == R_ARM_MOVT_PREL)
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);

	if (r_type == R_ARM_MOVT_ABS || r_type == R_ARM_MOVT_PREL)
	  value >>= 16;

	insn &= 0xfff0f000;
	insn |= value & 0xfff;
	insn |= (value & 0xf000) << 4;
	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_THM_MOVW_ABS_NC:
    case R_ARM_THM_MOVT_ABS:
    case R_ARM_THM_MOVW_PREL_NC:
    case R_ARM_THM_MOVT_PREL:
      {
	bfd_vma insn;
	
	insn = bfd_get_16 (input_bfd, hit_data) << 16;
	insn |= bfd_get_16 (input_bfd, hit_data + 2);

	if (globals->use_rel)
	  {
	    addend = ((insn >> 4)  & 0xf000)
		   | ((insn >> 15) & 0x0800)
		   | ((insn >> 4)  & 0x0700)
		   | (insn         & 0x00ff);
	    signed_addend = (addend ^ 0x10000) - 0x10000;
	  }
	value += signed_addend;
	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;

	if (r_type == R_ARM_THM_MOVW_PREL_NC || r_type == R_ARM_THM_MOVT_PREL)
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);

	if (r_type == R_ARM_THM_MOVT_ABS || r_type == R_ARM_THM_MOVT_PREL)
	  value >>= 16;

	insn &= 0xfbf08f00;
	insn |= (value & 0xf000) << 4;
	insn |= (value & 0x0800) << 15;
	insn |= (value & 0x0700) << 4;
	insn |= (value & 0x00ff);

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);
      }
      return bfd_reloc_ok;

a5653 8
	case R_ARM_MOVW_ABS_NC:
	case R_ARM_MOVT_ABS:
	case R_ARM_MOVW_PREL_NC:
	case R_ARM_MOVT_PREL:
	case R_ARM_THM_MOVW_ABS_NC:
	case R_ARM_THM_MOVT_ABS:
	case R_ARM_THM_MOVW_PREL_NC:
	case R_ARM_THM_MOVT_PREL:
a5863 8
	  case R_ARM_MOVW_ABS_NC:
	  case R_ARM_MOVT_ABS:
	  case R_ARM_MOVW_PREL_NC:
	  case R_ARM_MOVT_PREL:
	  case R_ARM_THM_MOVW_ABS_NC:
	  case R_ARM_THM_MOVT_ABS:
	  case R_ARM_THM_MOVW_PREL_NC:
	  case R_ARM_THM_MOVT_PREL:
d5880 6
a5885 1
		if (r_type != R_ARM_ABS32 && r_type != R_ARM_REL32)
@


1.70.2.3
log
@2006-05-15  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename ...
	(bfd_is_arm_special_symbol_name): ... to this.  Add type argument.
	Check symbol name is of specified type.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol,
	arm_elf_find_function, elf32_arm_output_symbol_hook): Use
	bfd_is_arm_special_symbol_name.
	* bfd/bfd-in.h (BFD_ARM_SPECIAL_SYM_TYPE_MAP,
	BFD_ARM_SPECIAL_SYM_TYPE_TAG, BFD_ARM_SPECIAL_SYM_TYPE_OTHER,
	BFD_ARM_SPECIAL_SYM_TYPE_ANY): Define.
	(bfd_is_arm_mapping_symbol_name): Remove prototype.
	(bfd_is_arm_special_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* gas/config/tc-arm.c (arm_adjust_symtab): Use
	bfd_is_arm_special_symbol_name.
	* ld/testsuite/ld-arm/arm-be8.d: New test.
	* ld/testsuite/ld-arm/arm-be8.s: New test.
	* ld/testsuite/ld-arm/arm-elf.exp: Add arm-be8.
@
text
@d6113 1
a6113 2
  return bfd_is_arm_special_symbol_name (sym->name,
					 BFD_ARM_SPECIAL_SYM_TYPE_ANY);
d6149 1
a6149 1
	  /* Skip mapping symbols.  */
d6151 1
a6151 2
	      && bfd_is_arm_special_symbol_name (q->symbol.name,
		    BFD_ARM_SPECIAL_SYM_TYPE_ANY))
d7882 1
a7882 1
  if (!bfd_is_arm_special_symbol_name (name, BFD_ARM_SPECIAL_SYM_TYPE_MAP))
@


1.70.2.4
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

	Backport form mainline.
	* bfd/elf32-arm.c (put_arm_insn, put_thumb_insn): New functions.
	(elf32_thumb_to_arm_stub, elf32_arm_to_thumb_stub,
	elf32_arm_finish_dynamic_symbol): Use them.
@
text
@a2657 29

/* Store an Arm insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_arm_insn (struct elf32_arm_link_hash_table *htab,
	     bfd * output_bfd, bfd_vma val, void * ptr)
{
    if (htab->byteswap_code != bfd_little_endian (output_bfd))
      bfd_putl32 (val, ptr);
    else
      bfd_putb32 (val, ptr);
}


/* Store a 16-bit Thumb insn into an output section not processed by
   elf32_arm_write_section.  */

static void
put_thumb_insn (struct elf32_arm_link_hash_table *htab,
	       bfd * output_bfd, bfd_vma val, void * ptr)
{
    if (htab->byteswap_code != bfd_little_endian (output_bfd))
      bfd_putl16 (val, ptr);
    else
      bfd_putb16 (val, ptr);
}


d2714 2
a2715 2
      put_thumb_insn (globals, output_bfd, (bfd_vma) t2a1_bx_pc_insn,
		      s->contents + my_offset);
d2717 2
a2718 2
      put_thumb_insn (globals, output_bfd, (bfd_vma) t2a2_noop_insn,
		      s->contents + my_offset + 2);
d2736 3
a2738 3
      put_arm_insn (globals, output_bfd,
		    (bfd_vma) t2a3_b_insn | ((ret_offset >> 2) & 0x00FFFFFF),
		    s->contents + my_offset + 4);
d2823 6
a2828 6
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t1p_ldr_insn,
			s->contents + my_offset);
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t2p_add_pc_insn,
			s->contents + my_offset + 4);
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t3p_bx_r12_insn,
			s->contents + my_offset + 8);
d2840 2
a2841 2
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t1_ldr_insn,
			s->contents + my_offset);
d2843 2
a2844 2
	  put_arm_insn (globals, output_bfd, (bfd_vma) a2t2_bx_r12_insn,
			s->contents + my_offset + 4);
d6987 5
a6991 6
	  put_arm_insn (htab, output_bfd, 
		      elf32_arm_symbian_plt_entry[0],
		      splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd, 
		      elf32_arm_symbian_plt_entry[1],
		      splt->contents + h->plt.offset + 4);
d6996 1
a6996 1
			  + h->plt.offset + 4);
a7010 1
	  bfd_byte * ptr;
a7035 1
	  ptr = htab->splt->contents + h->plt.offset;
d7041 1
a7041 1
	      for (i = 0; i != htab->plt_entry_size / 4; i++, ptr += 4)
d7048 2
a7049 4
		  if (i == 2 || i == 5)
		    bfd_put_32 (output_bfd, val, ptr);
		  else
		    put_arm_insn (htab, output_bfd, val, ptr);
d7066 2
a7067 4
		  if (i == 2 || i == 5)
		    bfd_put_32 (output_bfd, val, ptr);
		  else
		    put_arm_insn (htab, output_bfd, val, ptr);
d7100 4
a7103 4
		  put_thumb_insn (htab, output_bfd,
				  elf32_arm_plt_thumb_stub[0], ptr - 4);
		  put_thumb_insn (htab, output_bfd,
				  elf32_arm_plt_thumb_stub[1], ptr - 2);
d7106 12
a7117 12
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[0]
			    | ((got_displacement & 0x0ff00000) >> 20),
			    ptr + 0);
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[1]
			    | ((got_displacement & 0x000ff000) >> 12),
			    ptr+ 4);
	      put_arm_insn (htab, output_bfd,
			    elf32_arm_plt_entry[2]
			    | (got_displacement & 0x00000fff),
			    ptr + 8);
d7119 2
a7120 1
	      bfd_put_32 (output_bfd, elf32_arm_plt_entry[3], ptr + 12);
d7430 3
a7432 6
	      put_arm_insn (htab, output_bfd, plt0_entry[0],
			    splt->contents + 0);
	      put_arm_insn (htab, output_bfd, plt0_entry[1],
			    splt->contents + 4);
	      put_arm_insn (htab, output_bfd, plt0_entry[2],
			    splt->contents + 8);
d7447 4
a7450 8
	      put_arm_insn (htab, output_bfd, plt0_entry[0],
			    splt->contents + 0);
	      put_arm_insn (htab, output_bfd, plt0_entry[1],
			    splt->contents + 4);
	      put_arm_insn (htab, output_bfd, plt0_entry[2],
			    splt->contents + 8);
	      put_arm_insn (htab, output_bfd, plt0_entry[3],
			    splt->contents + 12);
@


1.70.2.5
log
@2006-05-24  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* bfd/elf-bfd.h (elf_backend_data): Add
	elf_backend_output_arch_local_syms
	* bfd/elf32-arm.c (output_arch_syminfo): Define.
	(elf32_arm_ouput_plt_map_sym, elf32_arm_output_plt_map,
	elf32_arm_output_arch_local_syms): New functions.
	(elf_backend_output_arch_local_syms): Define.
	* bfd/elflink.c (bfd_elf_final_link): Call
	elf_backend_output_arch_local_syms.
	* bfd/elfxx-target.h (elf_backend_output_arch_local_syms): Provide
	default definition.
	(elfNN_bed): Add elf_backend_output_arch_local_syms.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app.d: Ditto.
	* ld/testsuite/ld-arm/arm-lib-plt32.d: Ditto.
	* ld/testsuite/ld-arm/arm-lib.d: Ditto.
	* ld/testsuite/ld-arm/mixed-app-v5.d: Ditto.
	* ld/testsuite/ld-arm/mixed-app.d: Ditto.
	* ld/testsuite/ld-arm/mixed-lib.d: Ditto.
@
text
@a7952 168
typedef struct
{
  void *finfo;
  struct bfd_link_info *info;
  int plt_shndx;
  bfd_vma plt_offset;
  bfd_boolean (*func) (void *, const char *, Elf_Internal_Sym *,
		       asection *, struct elf_link_hash_entry *);
} output_arch_syminfo;

enum map_symbol_type
{
  ARM_MAP_ARM,
  ARM_MAP_THUMB,
  ARM_MAP_DATA
};


/* Output a single PLT mapping symbol.  */

static bfd_boolean
elf32_arm_ouput_plt_map_sym (output_arch_syminfo *osi,
			     enum map_symbol_type type,
			     bfd_vma offset)
{
  static const char *names[3] = {"$a", "$t", "$d"};
  struct elf32_arm_link_hash_table *htab;
  Elf_Internal_Sym sym;

  htab = elf32_arm_hash_table (osi->info);
  sym.st_value = osi->plt_offset + offset;
  sym.st_size = 0;
  sym.st_other = 0;
  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
  sym.st_shndx = osi->plt_shndx;
  if (!osi->func (osi->finfo, names[type], &sym, htab->splt, NULL))
    return FALSE;
  return TRUE;
}


/* Output mapping symbols for PLT entries associated with H.  */

static bfd_boolean
elf32_arm_output_plt_map (struct elf_link_hash_entry *h, void *inf)
{
  output_arch_syminfo *osi = (output_arch_syminfo *) inf;
  struct elf32_arm_link_hash_table *htab;
  struct elf32_arm_link_hash_entry *eh;
  bfd_vma addr;

  htab = elf32_arm_hash_table (osi->info);

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->plt.offset == (bfd_vma) -1)
    return TRUE;

  eh = (struct elf32_arm_link_hash_entry *) h;
  addr = h->plt.offset;
  if (htab->symbian_p)
    {
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 4))
	return FALSE;
    }
  else if (htab->vxworks_p)
    {
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 8))
	return FALSE;
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr + 12))
	return FALSE;
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 20))
	return FALSE;
    }
  else
    {
      bfd_boolean thumb_stub;

      thumb_stub = eh->plt_thumb_refcount > 0 && !htab->use_blx;
      if (thumb_stub)
	{
	  if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_THUMB, addr - 4))
	    return FALSE;
	}
#ifdef FOUR_WORD_PLT
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
	return FALSE;
      if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_DATA, addr + 12))
	return FALSE;
#else
      /* A three-word PLT with no Thumb thunk contains only Arm code, 
	 so only need to output a mapping symbol for the first PLT entry and
	 entries with thumb thunks.  */
      if (thumb_stub || addr == 20)
	{
	  if (!elf32_arm_ouput_plt_map_sym (osi, ARM_MAP_ARM, addr))
	    return FALSE;
	}
#endif
    }

  return TRUE;
}


/* Output mapping symbols for the PLT.  */

static bfd_boolean
elf32_arm_output_arch_local_syms (bfd *output_bfd,
    struct bfd_link_info *info,
    void *finfo, bfd_boolean (*func) (void *, const char *,
				    Elf_Internal_Sym *,
				    asection *,
				    struct elf_link_hash_entry *))
{
  output_arch_syminfo osi;
  struct elf32_arm_link_hash_table *htab;

  htab = elf32_arm_hash_table (info);
  if (!htab->splt || htab->splt->size == 0)
    return TRUE;

  check_use_blx(htab);
  osi.finfo = finfo;
  osi.info = info;
  osi.func = func;
  osi.plt_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
      htab->splt->output_section);
  osi.plt_offset = htab->splt->output_section->vma;

  /* Output mapping symbols for the plt header.  SymbianOS does not have a
     plt header.  */
  if (htab->vxworks_p)
    {
      /* VxWorks shared libraries have no PLT header.  */
      if (!info->shared)
	{
	  if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, 0))
	    return FALSE;
	  if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_DATA, 12))
	    return FALSE;
	}
    }
  else if (!htab->symbian_p)
    {
      if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_ARM, 0))
	return FALSE;
#ifndef FOUR_WORD_PLT
      if (!elf32_arm_ouput_plt_map_sym (&osi, ARM_MAP_DATA, 16))
	return FALSE;
#endif
    }

  elf_link_hash_traverse (&htab->root, elf32_arm_output_plt_map, (void *) &osi);
  return TRUE;
}

a8264 2
#define elf_backend_output_arch_local_syms \
  elf32_arm_output_arch_local_syms
@


1.70.2.6
log
@Support for ARM "group relocations" numbers 4, and 57 through 83.

	* include/elf/arm.h: Correct names of R_ARM_LDC_G{0,1,2}
	to R_ARM_LDC_SB_G{0,1,2} respectively.

	bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (R_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0,
	R_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1, R_ARM_ALU_PC_G2,
	R_ARM_LDR_PC_G1, R_ARM_LDR_PC_G2, R_ARM_LDRS_PC_G0,
	R_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G2, R_ARM_LDC_PC_G0,
	R_ARM_LDC_PC_G1, R_ARM_LDC_PC_G2, R_ARM_ALU_SB_G0_NC,
	R_ARM_ALU_SB_G0, R_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1,
	R_ARM_ALU_SB_G2, R_ARM_LDR_SB_G0, R_ARM_LDR_SB_G1,
	R_ARM_LDR_SB_G2, R_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G1,
	R_ARM_LDRS_SB_G2, R_ARM_LDC_SB_G0, R_ARM_LDC_SB_G1,
	R_ARM_LDC_SB_G2): New relocation types.
	(R_ARM_PC13): Rename to AAELF name R_ARM_LDR_PC_G0 and
	adjust HOWTO entry to be consistent with R_ARM_LDR_PC_G1
	and friends.
	(elf32_arm_howto_table_3): Delete; contents merged into
	elf32_arm_howto_table_2.
	(elf32_arm_howto_from_type): Adjust correspondingly.
	(elf32_arm_reloc_map): Extend with the above relocations.
	(calculate_group_reloc_mask): New function.
	(identify_add_or_sub): New function.
	(elf32_arm_final_link_relocate): Support for the above
	relocations.
	* reloc.c: Add enumeration entries for BFD_RELOC_ARM_...
	codes to correspond to the above relocations.

	gas/
	* config/tc-arm.c (enum parse_operand_result): New.
	(struct group_reloc_table_entry): New.
	(enum group_reloc_type): New.
	(group_reloc_table): New array.
	(find_group_reloc_table_entry): New function.
	(parse_shifter_operand_group_reloc): New function.
	(parse_address_main): New function, incorporating code
	from the old parse_address function.  To be used via...
	(parse_address): wrapper for parse_address_main; and
	(parse_address_group_reloc): new function, likewise.
	(enum operand_parse_code): New codes OP_SHG, OP_ADDRGLDR,
	OP_ADDRGLDRS, OP_ADDRGLDC.
	(parse_operands): Support for these new operand codes.
	New macro po_misc_or_fail_no_backtrack.
	(encode_arm_cp_address): Preserve group relocations.
	(insns): Modify to use the above operand codes where group
	relocations are permitted.
	(md_apply_fix): Handle the group relocations
	ALU_PC_G0_NC through LDC_SB_G2.
	(tc_gen_reloc): Likewise.
	(arm_force_relocation): Leave group relocations for the linker.
	(arm_fix_adjustable): Likewise.

	gas/testsuite/
	* gas/arm/group-reloc-alu.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.d: New test.
	* gas/arm/group-reloc-alu-encoding-bad.l: New test.
	* gas/arm/group-reloc-alu-encoding-bad.s: New test.
	* gas/arm/group-reloc-alu-parsing-bad.d: New test.
	* gas/arm/group-reloc-alu-parsing-bad.l: New test.
	* gas/arm/group-reloc-alu-parsing-bad.s: New test.
	* gas/arm/group-reloc-alu.s: New test.
	* gas/arm/group-reloc-ldc.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldc-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldc-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldc.s: New test.
	* gas/arm/group-reloc-ldr.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldr-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldr-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldr.s: New test.
	* gas/arm/group-reloc-ldrs.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.d: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.l: New test.
	* gas/arm/group-reloc-ldrs-encoding-bad.s: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.d: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.l: New test.
	* gas/arm/group-reloc-ldrs-parsing-bad.s: New test.
	* gas/arm/group-reloc-ldrs.s: New test.

	ld/testsuite/
	* ld-arm/group-relocs-alu-bad.d: New test.
	* ld-arm/group-relocs-alu-bad.s: New test.
	* ld-arm/group-relocs.d: New test.
	* ld-arm/group-relocs-ldc-bad.d: New test.
	* ld-arm/group-relocs-ldc-bad.s: New test.
	* ld-arm/group-relocs-ldr-bad.d: New test.
	* ld-arm/group-relocs-ldr-bad.s: New test.
	* ld-arm/group-relocs-ldrs-bad.d: New test.
	* ld-arm/group-relocs-ldrs-bad.s: New test.
	* ld-arm/group-relocs.s: New test.
	* ld-arm/arm-elf.exp: Wire in new tests.
@
text
@d133 1
a133 1
  HOWTO (R_ARM_LDR_PC_G0,	/* type */
d136 2
a137 2
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
d139 1
a139 1
	 complain_overflow_dont,/* complain_on_overflow */
d141 1
a141 1
	 "R_ARM_LDR_PC_G0",     /* name */
d143 3
a145 3
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d887 1
d889 2
a890 381
  /* Group relocations.  */

  HOWTO (R_ARM_ALU_PC_G0_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G0_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G1_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G1_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G0",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G1",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_PC_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_PC_G2",   	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G0_NC,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G0_NC", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G1_NC,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G1_NC", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ALU_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ALU_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDR_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDR_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDRS_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDRS_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G0,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G0", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G1,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G1", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_LDC_SB_G2,   	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_LDC_SB_G2", 	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* End of group relocations.  */
d892 2
d1233 1
a1233 1
static reloc_howto_type elf32_arm_howto_table_2[4] =
d1298 4
d1304 1
a1304 1
    return &elf32_arm_howto_table_2[r_type - R_ARM_RREL32];
a1376 28
    {BFD_RELOC_ARM_ALU_PC_G0_NC, R_ARM_ALU_PC_G0_NC},
    {BFD_RELOC_ARM_ALU_PC_G0, R_ARM_ALU_PC_G0},
    {BFD_RELOC_ARM_ALU_PC_G1_NC, R_ARM_ALU_PC_G1_NC},
    {BFD_RELOC_ARM_ALU_PC_G1, R_ARM_ALU_PC_G1},
    {BFD_RELOC_ARM_ALU_PC_G2, R_ARM_ALU_PC_G2},
    {BFD_RELOC_ARM_LDR_PC_G0, R_ARM_LDR_PC_G0},
    {BFD_RELOC_ARM_LDR_PC_G1, R_ARM_LDR_PC_G1},
    {BFD_RELOC_ARM_LDR_PC_G2, R_ARM_LDR_PC_G2},
    {BFD_RELOC_ARM_LDRS_PC_G0, R_ARM_LDRS_PC_G0},
    {BFD_RELOC_ARM_LDRS_PC_G1, R_ARM_LDRS_PC_G1},
    {BFD_RELOC_ARM_LDRS_PC_G2, R_ARM_LDRS_PC_G2},
    {BFD_RELOC_ARM_LDC_PC_G0, R_ARM_LDC_PC_G0},
    {BFD_RELOC_ARM_LDC_PC_G1, R_ARM_LDC_PC_G1},
    {BFD_RELOC_ARM_LDC_PC_G2, R_ARM_LDC_PC_G2},
    {BFD_RELOC_ARM_ALU_SB_G0_NC, R_ARM_ALU_SB_G0_NC},
    {BFD_RELOC_ARM_ALU_SB_G0, R_ARM_ALU_SB_G0},
    {BFD_RELOC_ARM_ALU_SB_G1_NC, R_ARM_ALU_SB_G1_NC},
    {BFD_RELOC_ARM_ALU_SB_G1, R_ARM_ALU_SB_G1},
    {BFD_RELOC_ARM_ALU_SB_G2, R_ARM_ALU_SB_G2},
    {BFD_RELOC_ARM_LDR_SB_G0, R_ARM_LDR_SB_G0},
    {BFD_RELOC_ARM_LDR_SB_G1, R_ARM_LDR_SB_G1},
    {BFD_RELOC_ARM_LDR_SB_G2, R_ARM_LDR_SB_G2},
    {BFD_RELOC_ARM_LDRS_SB_G0, R_ARM_LDRS_SB_G0},
    {BFD_RELOC_ARM_LDRS_SB_G1, R_ARM_LDRS_SB_G1},
    {BFD_RELOC_ARM_LDRS_SB_G2, R_ARM_LDRS_SB_G2},
    {BFD_RELOC_ARM_LDC_SB_G0, R_ARM_LDC_SB_G0},
    {BFD_RELOC_ARM_LDC_SB_G1, R_ARM_LDC_SB_G1},
    {BFD_RELOC_ARM_LDC_SB_G2, R_ARM_LDC_SB_G2}
a2966 68
/* For a given value of n, calculate the value of G_n as required to
   deal with group relocations.  We return it in the form of an
   encoded constant-and-rotation, together with the final residual.  If n is
   specified as less than zero, then final_residual is filled with the
   input value and no further action is performed.  */

static bfd_vma
calculate_group_reloc_mask (bfd_vma value, int n, bfd_vma *final_residual)
{
  int current_n;
  bfd_vma g_n;
  bfd_vma encoded_g_n = 0;
  bfd_vma residual = value; /* Also known as Y_n.  */

  for (current_n = 0; current_n <= n; current_n++)
    {
      int shift;

      /* Calculate which part of the value to mask.  */
      if (residual == 0)
        shift = 0;
      else
        {
          int msb;

          /* Determine the most significant bit in the residual and
             align the resulting value to a 2-bit boundary.  */
          for (msb = 30; msb >= 0; msb -= 2)
            if (residual & (3 << msb))
              break;

          /* The desired shift is now (msb - 6), or zero, whichever
             is the greater.  */
          shift = msb - 6;
          if (shift < 0)
            shift = 0;
        }

      /* Calculate g_n in 32-bit as well as encoded constant+rotation form.  */
      g_n = residual & (0xff << shift);
      encoded_g_n = (g_n >> shift)
                    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);

      /* Calculate the residual for the next time around.  */
      residual &= ~g_n;
    }

  *final_residual = residual;

  return encoded_g_n;
}

/* Given an ARM instruction, determine whether it is an ADD or a SUB.
   Returns 1 if it is an ADD, -1 if it is a SUB, and 0 otherwise.  */
static int
identify_add_or_sub(bfd_vma insn)
{
  int opcode = insn & 0x1e00000;

  if (opcode == 1 << 23) /* ADD */
    return 1;

  if (opcode == 1 << 22) /* SUB */
    return -1;

  return 0;
}

a4189 391
    case R_ARM_ALU_PC_G0_NC:
    case R_ARM_ALU_PC_G1_NC:
    case R_ARM_ALU_PC_G0:
    case R_ARM_ALU_PC_G1:
    case R_ARM_ALU_PC_G2:
    case R_ARM_ALU_SB_G0_NC:
    case R_ARM_ALU_SB_G1_NC:
    case R_ARM_ALU_SB_G0:
    case R_ARM_ALU_SB_G1:
    case R_ARM_ALU_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
        bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
        /* sb should be the origin of the *segment* containing the symbol.
           It is not clear how to obtain this OS-dependent value, so we
           make an arbitrary choice of zero.  */
        bfd_vma sb = 0;
        bfd_vma residual;
        bfd_vma g_n;
	bfd_signed_vma signed_value;
        int group = 0;

        /* Determine which group of bits to select.  */
        switch (r_type)
          {
          case R_ARM_ALU_PC_G0_NC:
          case R_ARM_ALU_PC_G0:
          case R_ARM_ALU_SB_G0_NC:
          case R_ARM_ALU_SB_G0:
            group = 0;
            break;

          case R_ARM_ALU_PC_G1_NC:
          case R_ARM_ALU_PC_G1:
          case R_ARM_ALU_SB_G1_NC:
          case R_ARM_ALU_SB_G1:
            group = 1;
            break;

          case R_ARM_ALU_PC_G2:
          case R_ARM_ALU_SB_G2:
            group = 2;
            break;

          default:
            abort();
          }

        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
	if (globals->use_rel)
          {
            int negative;
            bfd_vma constant = insn & 0xff;
            bfd_vma rotation = (insn & 0xf00) >> 8;

            if (rotation == 0)
              signed_addend = constant;
            else
              {
                /* Compensate for the fact that in the instruction, the
                   rotation is stored in multiples of 2 bits.  */
                rotation *= 2;

                /* Rotate "constant" right by "rotation" bits.  */
                signed_addend = (constant >> rotation) |
                                (constant << (8 * sizeof (bfd_vma) - rotation));
              }

            /* Determine if the instruction is an ADD or a SUB.
               (For REL, this determines the sign of the addend.)  */
            negative = identify_add_or_sub (insn);
            if (negative == 0)
              {
                (*_bfd_error_handler)
                  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
                  input_bfd, input_section,
                  (long) rel->r_offset, howto->name);
                return bfd_reloc_overflow;	  
    	      }

            signed_addend *= negative;
          }

	/* Compute the value (X) to go in the place.  */
        if (r_type == R_ARM_ALU_PC_G0_NC
            || r_type == R_ARM_ALU_PC_G1_NC
            || r_type == R_ARM_ALU_PC_G0
            || r_type == R_ARM_ALU_PC_G1
            || r_type == R_ARM_ALU_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* If the target symbol is a Thumb function, then set the
           Thumb bit in the address.  */
	if (sym_flags == STT_ARM_TFUNC)
	  signed_value |= 1;

        /* Calculate the value of the relevant G_n, in encoded
           constant-with-rotation format.  */
        g_n = calculate_group_reloc_mask (abs (signed_value), group,
                                          &residual);

        /* Check for overflow if required.  */
        if ((r_type == R_ARM_ALU_PC_G0
             || r_type == R_ARM_ALU_PC_G1
             || r_type == R_ARM_ALU_PC_G2
             || r_type == R_ARM_ALU_SB_G0
             || r_type == R_ARM_ALU_SB_G1
             || r_type == R_ARM_ALU_SB_G2) && residual != 0)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and the ADD/SUB part of the opcode; take care
           not to destroy the S bit.  */
        insn &= 0xff1ff000;

        /* Set the opcode according to whether the value to go in the
           place is negative.  */
        if (signed_value < 0)
          insn |= 1 << 22;
        else
          insn |= 1 << 23;

        /* Encode the offset.  */
        insn |= g_n;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDR_PC_G0:
    case R_ARM_LDR_PC_G1:
    case R_ARM_LDR_PC_G2:
    case R_ARM_LDR_SB_G0:
    case R_ARM_LDR_SB_G1:
    case R_ARM_LDR_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
        bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
	bfd_signed_vma signed_value;
        int group = 0;

        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDR_PC_G0:
          case R_ARM_LDR_SB_G0:
            group = 0;
            break;

          case R_ARM_LDR_PC_G1:
          case R_ARM_LDR_SB_G1:
            group = 1;
            break;

          case R_ARM_LDR_PC_G2:
          case R_ARM_LDR_SB_G2:
            group = 2;
            break;

          default:
            abort();
          }

        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
	if (globals->use_rel)
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * (insn & 0xfff);
          }

	/* Compute the value (X) to go in the place.  */
        if (r_type == R_ARM_LDR_PC_G0
            || r_type == R_ARM_LDR_PC_G1
            || r_type == R_ARM_LDR_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  */
        if (residual >= 0x1000)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7ff000;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;

        /* Encode the offset.  */
        insn |= residual;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDRS_PC_G0:
    case R_ARM_LDRS_PC_G1:
    case R_ARM_LDRS_PC_G2:
    case R_ARM_LDRS_SB_G0:
    case R_ARM_LDRS_SB_G1:
    case R_ARM_LDRS_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
        bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
	bfd_signed_vma signed_value;
        int group = 0;

        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDRS_PC_G0:
          case R_ARM_LDRS_SB_G0:
            group = 0;
            break;

          case R_ARM_LDRS_PC_G1:
          case R_ARM_LDRS_SB_G1:
            group = 1;
            break;

          case R_ARM_LDRS_PC_G2:
          case R_ARM_LDRS_SB_G2:
            group = 2;
            break;

          default:
            abort();
          }

        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
	if (globals->use_rel)
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
          }

	/* Compute the value (X) to go in the place.  */
        if (r_type == R_ARM_LDRS_PC_G0
            || r_type == R_ARM_LDRS_PC_G1
            || r_type == R_ARM_LDRS_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  */
        if (residual >= 0x100)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7ff0f0;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;

        /* Encode the offset.  */
        insn |= ((residual & 0xf0) << 4) | (residual & 0xf);

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

    case R_ARM_LDC_PC_G0:
    case R_ARM_LDC_PC_G1:
    case R_ARM_LDC_PC_G2:
    case R_ARM_LDC_SB_G0:
    case R_ARM_LDC_SB_G1:
    case R_ARM_LDC_SB_G2:
      {
	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
        bfd_vma pc = input_section->output_section->vma
		     + input_section->output_offset + rel->r_offset;
        bfd_vma sb = 0; /* See note above.  */
        bfd_vma residual;
	bfd_signed_vma signed_value;
        int group = 0;

        /* Determine which groups of bits to calculate.  */
        switch (r_type)
          {
          case R_ARM_LDC_PC_G0:
          case R_ARM_LDC_SB_G0:
            group = 0;
            break;

          case R_ARM_LDC_PC_G1:
          case R_ARM_LDC_SB_G1:
            group = 1;
            break;

          case R_ARM_LDC_PC_G2:
          case R_ARM_LDC_SB_G2:
            group = 2;
            break;

          default:
            abort();
          }

        /* If REL, extract the addend from the insn.  If RELA, it will
           have already been fetched for us.  */
	if (globals->use_rel)
          {
            int negative = (insn & (1 << 23)) ? 1 : -1;
            signed_addend = negative * ((insn & 0xff) << 2);
          }

	/* Compute the value (X) to go in the place.  */
        if (r_type == R_ARM_LDC_PC_G0
            || r_type == R_ARM_LDC_PC_G1
            || r_type == R_ARM_LDC_PC_G2)
          /* PC relative.  */
          signed_value = value - pc + signed_addend;
        else
          /* Section base relative.  */
          signed_value = value - sb + signed_addend;

        /* Calculate the value of the relevant G_{n-1} to obtain
           the residual at that stage.  */
        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);

        /* Check for overflow.  (The absolute value to go in the place must be
           divisible by four and, after having been divided by four, must
           fit in eight bits.)  */
        if ((residual & 0x3) != 0 || residual >= 0x400)
          {
            (*_bfd_error_handler)
              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
              input_bfd, input_section,
              (long) rel->r_offset, abs (signed_value), howto->name);
            return bfd_reloc_overflow;
          }

        /* Mask out the value and U bit.  */
        insn &= 0xff7fff00;

        /* Set the U bit if the value to go in the place is non-negative.  */
        if (signed_value >= 0)
          insn |= 1 << 23;

        /* Encode the offset.  */
        insn |= residual >> 2;

	bfd_put_32 (input_bfd, insn, hit_data);
      }
      return bfd_reloc_ok;

@


1.70.2.7
log
@2006-06-19  Vladimir Prus  <vladimir@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_swap_symbol_out): Don't set low
	bit for undefined symbols.

	ld/testsuite
	* ld-arm/arm-elf.exp: New test.
	* ld-arm/use-thumb-lib.s: New file.
	* ld-arm/use-thumb-lib.sym: New file.
@
text
@a9157 13
      if (newsym.st_shndx != SHN_UNDEF)
        {
          /* Do this only for defined symbols. At link type, the static
             linker will simulate the work of dynamic linker of resolving
             symbols and will carry over the thumbness of found symbols to
             the output symbol table. It's not clear how it happens, but
             the thumbness of underfined symbols can well be different at
             runtime, and writing '1' for them will be confusing for users
             and possibly for dynamic linker itself.
          */
          newsym.st_value |= 1;
        }

@


1.70.2.8
log
@2006-08-18  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	bfd/
	* elf32-arm.c (elf32_arm_link_hash_entry): Add export_glue.
	(elf32_arm_link_hash_newfunc): Initialize export_glue.
	(record_arm_to_thumb_glue): Return stub symbol.
	(elf32_arm_create_thumb_stub): New function.
	(elf32_arm_to_thumb_stub): Use it.
	(elf32_arm_to_thumb_export_stub): New function.
	(elf32_arm_begin_write_processing): New function.
	(allocate_dynrelocs): Allocate Arm stubs.
	(elf_backend_begin_write_processing): Define.
	(elf32_arm_symbian_begin_write_processing): Remove ATTRIBUTE_UNUSED.
	Call elf32_arm_begin_write_processing.

	ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Call
	gld${EMULATION_NAME}_before_allocation after setting interworking bfd.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add armthumb-lib.so.  Add
	-use-blx to mixed-lib.so
	* ld-arm/armthumb-lib.d: New file.
	* ld-arm/armthumb-lib.sym: New file.
@
text
@a2091 4

    /* The symbol marking the real symbol location for exported thumb
       symbols with Arm stubs.  */
    struct elf_link_hash_entry *export_glue;
a2202 1
      ret->export_glue = NULL;
d2581 1
a2581 3
/* Allocate space and symbols for calling a Thumb function from Arm mode.
   returns the symbol identifying teh stub.  */
static struct elf_link_hash_entry *
d2616 1
a2616 1
      return myh;
d2639 1
a2639 1
  return myh;
d3194 1
a3194 1
/* Populate an Arm to Thumb stub.  Returns the stub symbol.  */
d3196 11
a3206 8
static struct elf_link_hash_entry *
elf32_arm_create_thumb_stub (struct bfd_link_info * info,
			     const char *           name,
			     bfd *                  input_bfd,
			     bfd *                  output_bfd,
			     asection *             sym_sec,
			     bfd_vma                val,
			     asection		    *s)
d3208 1
d3210 1
d3217 1
a3217 1
    return NULL;
d3225 5
a3282 41
  return myh;
}

/* Arm code calling a Thumb function.  */

static int
elf32_arm_to_thumb_stub (struct bfd_link_info * info,
			 const char *           name,
			 bfd *                  input_bfd,
			 bfd *                  output_bfd,
			 asection *             input_section,
			 bfd_byte *             hit_data,
			 asection *             sym_sec,
			 bfd_vma                offset,
			 bfd_signed_vma         addend,
			 bfd_vma                val)
{
  unsigned long int tmp;
  bfd_vma my_offset;
  asection * s;
  long int ret_offset;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_table * globals;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  myh = elf32_arm_create_thumb_stub (info, name, input_bfd, output_bfd,
				     sym_sec, val, s);
  if (!myh)
    return FALSE;

  my_offset = myh->root.u.def.value;
a3301 57
/* Populate Arm stub for an exported Thumb function.  */

static bfd_boolean
elf32_arm_to_thumb_export_stub (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info * info = (struct bfd_link_info *) inf;
  asection * s;
  struct elf_link_hash_entry * myh;
  struct elf32_arm_link_hash_entry *eh;
  struct elf32_arm_link_hash_table * globals;
  asection *sec;
  bfd_vma val;

  eh = elf32_arm_hash_entry(h);
  /* Allocate stubs for exported Thumb functions on v4t.  */
  if (eh->export_glue == NULL)
    return TRUE;

  globals = elf32_arm_hash_table (info);

  BFD_ASSERT (globals != NULL);
  BFD_ASSERT (globals->bfd_of_glue_owner != NULL);

  s = bfd_get_section_by_name (globals->bfd_of_glue_owner,
			       ARM2THUMB_GLUE_SECTION_NAME);
  BFD_ASSERT (s != NULL);
  BFD_ASSERT (s->contents != NULL);
  BFD_ASSERT (s->output_section != NULL);

  sec = eh->export_glue->root.u.def.section;
  val = eh->export_glue->root.u.def.value + sec->output_offset
	+ sec->output_section->vma;
  myh = elf32_arm_create_thumb_stub (info, h->root.root.string,
				     h->root.u.def.section->owner,
				     globals->obfd, sec, val, s);
  BFD_ASSERT (myh);
  return TRUE;
}

/* Generate Arm stubs for exported Thumb symbols.  */
static void
elf32_arm_begin_write_processing (bfd *abfd ATTRIBUTE_UNUSED, 
				  struct bfd_link_info *link_info)
{
  struct elf32_arm_link_hash_table * globals;

  if (!link_info)
    return;

  globals = elf32_arm_hash_table (link_info);
  if (globals->use_blx)
    return;

  elf_link_hash_traverse (&globals->root, elf32_arm_to_thumb_export_stub,
			  link_info);
}

a7464 30
  /* Allocate stubs for exported Thumb functions on v4t.  */
  if (!htab->use_blx && h->dynindx != -1
      && ELF_ST_TYPE (h->type) == STT_ARM_TFUNC
      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
    {
      struct elf_link_hash_entry * th;
      struct bfd_link_hash_entry * bh;
      struct elf_link_hash_entry * myh;
      char name[1024];
      asection *s;
      bh = NULL;
      /* Create a new symbol to regist the real location of the function.  */
      s = h->root.u.def.section;
      sprintf(name, "__real_%s", h->root.root.string);
      _bfd_generic_link_add_one_symbol (info, s->owner,
					name, BSF_GLOBAL, s,
					h->root.u.def.value,
					NULL, TRUE, FALSE, &bh);

      myh = (struct elf_link_hash_entry *) bh;
      myh->type = ELF_ST_INFO (STB_LOCAL, STT_ARM_TFUNC);
      myh->forced_local = 1;
      eh->export_glue = myh;
      th = record_arm_to_thumb_glue (info, h);
      /* Point the symbol at the stub.  */
      h->type = ELF_ST_INFO (ELF_ST_BIND (h->type), STT_FUNC);
      h->root.u.def.section = th->root.u.def.section;
      h->root.u.def.value = th->root.u.def.value & ~1;
    }

a9306 2
#define elf_backend_begin_write_processing \
    elf32_arm_begin_write_processing
d9448 2
a9449 1
					  struct bfd_link_info *link_info)
a9459 1
  elf32_arm_begin_write_processing(abfd, link_info);
@


1.70.2.9
log
@	bfd/
	* elf32-arm.c (elf32_arm_link_hash_table): Correct typo in
	comment for target1_is_rel.
@
text
@d2128 1
a2128 1
       Nonzero if R_ARM_TARGET1 means R_ARM_REL32.  */
@


1.70.2.10
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Add cases
	for R_ARM_ABS32_NOI and R_ARM_REL32_NOI.
	(elf32_arm_gc_sweep_hook): Likewise.
	(elf32_arm_check_relocs): Likewise.
	(allocate_dynrelocs): Likewise.
@
text
@a3621 1
    case R_ARM_ABS32_NOI:
a3622 1
    case R_ARM_REL32_NOI:
d3638 1
a3638 2
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
           && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI)
d3662 1
a3662 1
	  && ((r_type != R_ARM_REL32 && r_type != R_ARM_REL32_NOI)
a3875 4
	case R_ARM_ABS32_NOI:
	  value += addend;
	  break;

a3883 6
	case R_ARM_REL32_NOI:
	  value += addend;
	  value -= (input_section->output_section->vma
		    + input_section->output_offset + rel->r_offset);
	  break;

a6707 1
	case R_ARM_ABS32_NOI:
a6708 1
	case R_ARM_REL32_NOI:
d6741 1
a6741 3
		  || r_type == R_ARM_REL32
                  || r_type == R_ARM_ABS32_NOI
                  || r_type == R_ARM_REL32_NOI)
d6748 1
a6748 2
		      if (ELF32_R_TYPE (rel->r_info) == R_ARM_REL32
                          || ELF32_R_TYPE (rel->r_info) == R_ARM_REL32_NOI)
a6925 1
	  case R_ARM_ABS32_NOI:
a6926 1
	  case R_ARM_REL32_NOI:
d6957 1
a6957 4
		if (r_type != R_ARM_ABS32
                    && r_type != R_ARM_REL32
                    && r_type != R_ARM_ABS32_NOI
                    && r_type != R_ARM_REL32_NOI)
d6982 1
a6982 1
		&& ((r_type == R_ARM_ABS32 || r_type == R_ARM_ABS32_NOI)
d7066 1
a7066 1
		if (r_type == R_ARM_REL32 || r_type == R_ARM_REL32_NOI)
d7601 6
a7606 6
      /* The only relocs that use pc_count are R_ARM_REL32 and
         R_ARM_REL32_NOI, which will appear on something like
         ".long foo - .".  We want calls to protected symbols to resolve
         directly to the function rather than going via the plt.  If people
         want function pointer comparisons to work as expected then they
         should avoid writing assembly like ".long foo - .".  */
@


1.70.2.11
log
@	bfd/
	* elf32-arm.c (elf32_arm_howto_table_1): Change offset for
	R_THM_CALL to 25 and remove FIXME comment.
	(using_thumb2): New function.
	(elf32_arm_final_link_relocate): Cope with Thumb-2 BL encoding.

	ld/testsuite/
	* arm-elf.exp: Add thumb1-bl, thumb2-bl, thumb2-bl-as-thumb1-bad
	and thumb2-bl-bad tests.
	* thumb1-bl.d: New.
	* thumb1-bl.s: New.
	* thumb2-bl-as-thumb1-bad.d: New.
	* thumb2-bl-as-thumb1-bad.s: New.
	* thumb2-bl-bad.d: New.
	* thumb2-bl-bad.s: New.
	* thumb2-bl.d: New.
	* thumb2-bl.s: New.
@
text
@d220 1
d224 1
a224 1
	 25,			/* bitsize */
a3529 8
/* Determine if we're dealing with a Thumb-2 object.  */

static int using_thumb2 (struct elf32_arm_link_hash_table *globals)
{
  int arch = elf32_arm_get_eabi_attr_int (globals->obfd, Tag_CPU_arch);
  return arch == 8 || arch >= 10;
}

a3958 1
        bfd_vma reloc_sign;
d3962 2
a3963 2
	bfd_signed_vma reloc_signed_max;
	bfd_signed_vma reloc_signed_min;
a3965 2
	int bitsize;
	int thumb2 = using_thumb2 (globals);
d3967 2
a3968 2
	/* Fetch the addend.  We use the Thumb-2 encoding (backwards compatible
           with Thumb-1) involving the J1 and J2 bits.  */
d3971 4
a3974 12
            bfd_vma s = (upper_insn & (1 << 10)) >> 10;
            bfd_vma upper = upper_insn & 0x3ff;
            bfd_vma lower = lower_insn & 0x7ff;
	    bfd_vma j1 = (lower_insn & (1 << 13)) >> 13;
	    bfd_vma j2 = (lower_insn & (1 << 11)) >> 11;
            bfd_vma i1 = j1 ^ s ? 0 : 1;
            bfd_vma i2 = j2 ^ s ? 0 : 1;

            addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
            /* Sign extend.  */
            addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);

a4050 9
	/* Calculate the permissable maximum and minimum values for
	   this relocation according to whether we're relocating for
	   Thumb-2 or not.  */
	bitsize = howto->bitsize;
	if (!thumb2)
	  bitsize -= 2;
	reloc_signed_max = ((1 << (bitsize - 1)) - 1) >> howto->rightshift;
	reloc_signed_min = ~reloc_signed_max;

d4062 3
a4064 11
	/* Put RELOCATION back into the insn.  Assumes two's complement.
	   We use the Thumb-2 encoding, which is safe even if dealing with
	   a Thumb-1 instruction by virtue of our overflow check above.  */
        reloc_sign = (signed_check < 0) ? 1 : 0;
	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff)
                     | ((relocation >> 12) & 0x3ff)
                     | (reloc_sign << 10);
	lower_insn = (lower_insn & ~(bfd_vma) 0x2fff) 
                     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
                     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
                     | ((relocation >> 1) & 0x7ff);
@


1.70.2.12
log
@        bfd/
        * elf32-arm.c (elf32_arm_final_link_relocate): Add support for
        R_ARM_MOVW_BREL_NC, R_ARM_MOVW_BREL, R_ARM_MOVT_BREL,
        R_ARM_THM_MOVW_BREL_NC, R_ARM_THM_MOVW_BREL and
        R_ARM_THM_MOVT_BREL relocations.
@
text
@a4734 7
    /* Until we properly support segment-base-relative addressing then
       we assume the segment base to be zero, as for the group relocations.
       Thus R_ARM_MOVW_BREL_NC has the same semantics as R_ARM_MOVW_ABS_NC
       and R_ARM_MOVT_BREL has the same semantics as R_ARM_MOVT_ABS.  */
    case R_ARM_MOVW_BREL_NC:
    case R_ARM_MOVW_BREL:
    case R_ARM_MOVT_BREL:
a4742 1

d4744 2
d4751 1
a4751 8
	if (r_type == R_ARM_MOVW_BREL && value >= 0x10000)
          return bfd_reloc_overflow;

	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;

	if (r_type == R_ARM_MOVT_ABS || r_type == R_ARM_MOVT_PREL
            || r_type == R_ARM_MOVT_BREL)
a4764 8
    /* Until we properly support segment-base-relative addressing then
       we assume the segment base to be zero, as for the above relocations.
       Thus R_ARM_THM_MOVW_BREL_NC has the same semantics as
       R_ARM_THM_MOVW_ABS_NC and R_ARM_THM_MOVT_BREL has the same semantics
       as R_ARM_THM_MOVT_ABS.  */
    case R_ARM_THM_MOVW_BREL_NC:
    case R_ARM_THM_MOVW_BREL:
    case R_ARM_THM_MOVT_BREL:
a4778 1

d4780 2
d4787 1
a4787 8
	if (r_type == R_ARM_THM_MOVW_BREL && value >= 0x10000)
          return bfd_reloc_overflow;

	if (sym_flags == STT_ARM_TFUNC)
	  value |= 1;

	if (r_type == R_ARM_THM_MOVT_ABS || r_type == R_ARM_THM_MOVT_PREL
            || r_type == R_ARM_THM_MOVT_BREL)
@


1.70.2.13
log
@        bfd/
        * elf32-arm.c (elf32_arm_howto_table_1): Adjust entries for
        R_ARM_THM_ALU_PREL_11_0 and R_ARM_THM_PC12 relocations.
        (elf32_arm_final_link_relocate): Handle R_ARM_THM_ALU_PREL_11_0
        and R_ARM_THM_PC12 relocations.
@
text
@d837 1
a837 1
	 complain_overflow_dont,/* complain_on_overflow */
d841 2
a842 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
d851 1
a851 1
	 complain_overflow_dont,/* complain_on_overflow */
d855 2
a856 2
	 0x0fffffff,		/* src_mask */
	 0x0fffffff,		/* dst_mask */
a3960 75
    case R_ARM_THM_ALU_PREL_11_0:
      /* Corresponds to: addw.w reg, pc, #offset (and similarly for subw).  */
      {
	bfd_vma insn;
	bfd_signed_vma relocation;

	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
             | bfd_get_16 (input_bfd, hit_data + 2);

        if (globals->use_rel)
          {
            signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
                          | ((insn & (1 << 26)) >> 15);
            if (insn & 0xf00000)
              signed_addend = -signed_addend;
          }

	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

        value = abs (relocation);

        if (value >= 0x1000)
          return bfd_reloc_overflow;

	insn = (insn & 0xfb0f8f00) | (value & 0xff)
             | ((value & 0x700) << 4)
             | ((value & 0x800) << 15);
        if (relocation < 0)
          insn |= 0xa00000;

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);

        return bfd_reloc_ok;
      }

    case R_ARM_THM_PC12:
      /* Corresponds to: ldr.w reg, [pc, #offset].  */
      {
	bfd_vma insn;
	bfd_signed_vma relocation;

	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
             | bfd_get_16 (input_bfd, hit_data + 2);

        if (globals->use_rel)
          {
            signed_addend = insn & 0xfff;
            if (!(insn & (1 << 23)))
              signed_addend = -signed_addend;
          }

	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

        value = abs (relocation);

        if (value >= 0x1000)
          return bfd_reloc_overflow;

	insn = (insn & 0xff7ff000) | value;
        if (relocation >= 0)
          insn |= (1 << 23);

	bfd_put_16 (input_bfd, insn >> 16, hit_data);
	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);

        return bfd_reloc_ok;
      }

@


1.70.2.14
log
@        bfd/
        * elf32-arm.c (elf32_arm_howto_table_1): Correct masks for
        R_ARM_THM_PC12 relocation.
@
text
@d855 2
a856 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
@


1.70.2.15
log
@2006-09-05  Vladimir Prus  <vladimir@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_swap_symbol_out): Remove
	unconditionall setting of low bit for Thumb symbol
	mistakenly left behind after check for external
	symbols was added.

	ld/testsuite/
	* ld-arm/use-thumb-lib.sym: Use regexps instead of
	absolute addresses, for robustness.
@
text
@d9455 2
@


1.70.2.16
log
@        bfd/
        * elf32-arm.c (using_thumb2): Use TAG_CPU_* constants.

        include/
        * elf/arm.h: Define TAG_CPU_ARCH_* constants.
@
text
@d3534 1
a3534 1
  return arch == TAG_CPU_ARCH_V6T2 || arch >= TAG_CPU_ARCH_V7;
@


1.70.2.17
log
@2006-10-28  Paul Brook  <paul@@codesourcery.com>
	Julian Brown  <julian@@codesourcery.com>

	bfd/
	* elf32-arm.c (copy_eabi_attributes): Correct starting offset.
	(elf32_arm_merge_eabi_attributes): Mark output as initialized.
	Only set Tag_CPU_name and Tag_ABI_PCS_R9_use if input attribute
	is present.
@
text
@d6000 2
a6001 2
  in_attr = &elf32_arm_tdata (ibfd)->known_eabi_attributes[4];
  out_attr = &elf32_arm_tdata (obfd)->known_eabi_attributes[4];
d6132 1
a6132 1
  if (!elf32_arm_tdata (obfd)->known_eabi_attributes[0].i)
a6135 5

      /* Use the Tag_null value to indicate the attributes have been
	 initialized.  */
      elf32_arm_tdata (obfd)->known_eabi_attributes[0].i = 1;

d6139 4
d6167 2
a6168 5
	  /* Use whichever has the greatest architecture requirements.  We
	     won't necessarily have both the above tags, so make sure input
	     name is non-NULL.  */
	  if (in_attr[Tag_CPU_arch].i > out_attr[Tag_CPU_arch].i
	      && in_attr[i].s)
d6220 1
a6220 2
	  if (in_attr[i].i != out_attr[i].i
	      && out_attr[i].i != AEABI_R9_unused
@


1.70.2.18
log
@2006-10-30  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_to_thumb_export_stub): Assert that output
	section is present.
	(allocate_dynrelocs): Only add export stub for symbols definind in
	this object.
@
text
@a3368 3

  BFD_ASSERT (sec->output_section != NULL);

a7726 1
      && h->def_regular
@


1.69
log
@	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Iterate over all
	in_list elements, not just the first.
@
text
@d1970 2
a1971 1
				      elf32_arm_link_hash_newfunc))
@


1.68
log
@2006-03-10  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (INTERWORK_FLAG): Handle EABIv5.
	(elf32_arm_print_private_bfd_data): Ditto.
binutils/
	* readelf.c (decode_ARM_machine_flags):  Handle EABIv5.
gas/
	* config/tc-arm.c (md_begin): Handle EABIv5.
	(arm_eabis): Add EF_ARM_EABI_VER5.
	* doc/c-arm.texi: Document -meabi=5.
include/elf/
	* arm.h (EF_ARM_EABI_VER5): Define.
@
text
@d5149 6
a5154 4
	_bfd_error_handler
	  (_("Warning: %B: Unknown EABI object attribute %d"),
	   ibfd, in_list->tag);
      break;
@


1.67
log
@* elf32-arm.c(elf32_arm_finish_dynamic_sections): Use unsigned char type.
@
text
@d1455 2
a1456 1
/* In lieu of proper flags, assume all EABIv4 objects are interworkable.  */
d1458 1
a1458 1
  (EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags) == EF_ARM_EABI_VER4 \
d5157 15
d5270 2
a5271 1
  if (EF_ARM_EABI_VERSION (in_flags) != EF_ARM_EABI_VERSION (out_flags))
d5482 1
d5484 3
@


1.66
log
@bfd/
	* configure.in (bfd_elf32_bigarm_vec): Include elf-vxworks.lo.
	(bfd_elf32_bigarm_symbian_vec): Likewise.
	(bfd_elf32_bigarm_vxworks_vec): Likewise.
	(bfd_elf32_littlearm_vec): Likewise.
	(bfd_elf32_littlearm_symbian_vec): Likewise.
	(bfd_elf32_littlearm_vxworks_vec): Likewise.
	* configure: Regenerate.
	* elf32-arm.c: Include libiberty.h and elf-vxworks.h.
	(RELOC_SECTION, RELOC_SIZE, SWAP_RELOC_IN, SWAP_RELOC_OUT): New macros.
	(elf32_arm_vxworks_bed): Add forward declaration.
	(elf32_arm_howto_table_1): Fix the masks for R_ASM_ABS12.
	(elf32_arm_vxworks_exec_plt0_entry): New table.
	(elf32_arm_vxworks_exec_plt_entry): Likewise.
	(elf32_arm_vxworks_shared_plt_entry): Likewise.
	(elf32_arm_link_hash_table): Add vxworks_p and srelplt2 fields.
	(reloc_section_p): New function.
	(create_got_section): Use RELOC_SECTION.
	(elf32_arm_create_dynamic_sections): Likewise.  Call
	elf_vxworks_create_dynamic_sections for VxWorks targets.
	Choose between the two possible values of plt_header_size
	and plt_entry_size.
	(elf32_arm_link_hash_table_create): Initialize vxworks_p and srelplt2.
	(elf32_arm_abs12_reloc): New function.
	(elf32_arm_final_link_relocate): Call it.  Allow the creation of
	dynamic R_ARM_ABS12 relocs on VxWorks.  Use reloc_section_p,
	RELOC_SIZE, SWAP_RELOC_OUT and RELOC_SECTION.  Initialize the
	r_addend fields of relocs.  On rela targets, skip any code that
	adjusts in-place addends.  When using _bfd_link_final_relocate
	to perform a final relocation, pass rel->r_addend as the addend
	argument.
	(elf32_arm_merge_private_bfd_data): If one of the bfds is a VxWorks
	object, ignore flags that are not standard on VxWorks.
	(elf32_arm_check_relocs): Allow the creation of dynamic R_ARM_ABS12
	relocs on VxWorks.  Use reloc_section_p.
	(elf32_arm_adjust_dynamic_symbol): Use RELOC_SECTION and RELOC_SIZE.
	(allocate_dynrelocs): Use RELOC_SIZE.  Account for the size of
	.rela.plt.unloaded relocs on VxWorks targets.
	(elf32_arm_size_dynamic_sections): Use RELOC_SIZE.  Check for
	.rela.plt.unloaded as well as .rel(a).plt.  Add DT_RELA* tags
	instead of DT_REL* tags on RELA targets.
	(elf32_arm_finish_dynamic_symbol): Use RELOC_SECTION, RELOC_SIZE
	and SWAP_RELOC_OUT.  Initialize r_addend fields.  Handle VxWorks
	PLT entries.  Do not make _GLOBAL_OFFSET_TABLE_ absolute on VxWorks.
	(elf32_arm_finish_dynamic_sections): Use RELOC_SECTION, RELOC_SIZE
	and SWAP_RELOC_OUT.  Initialize r_addend fields.  Handle DT_RELASZ
	like DT_RELSZ.  Handle the VxWorks form of initial PLT entry.
	Correct the .rela.plt.unreloaded symbol indexes.
	(elf32_arm_output_symbol_hook): Call the VxWorks version of this
	hook on VxWorks targets.
	(elf32_arm_vxworks_link_hash_table_create): Set vxworks_p to true.
	Minor formatting tweak.
	(elf32_arm_vxworks_final_write_processing): New function.
	(elf_backend_add_symbol_hook): Override for VxWorks and reset
	for Symbian.
	(elf_backend_final_write_processing): Likewise.
	(elf_backend_emit_relocs): Likewise.
	(elf_backend_want_plt_sym): Likewise.
	(ELF_MAXPAGESIZE): Likewise.
	(elf_backend_may_use_rel_p): Minor formatting tweak.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elf_backend_rela_normal): Likewise.
	* Makefile.in (elf32-arm.lo): Depend on elf-vxworks.h.

gas/
	* config/tc-arm.c (md_apply_fix): Install a value of zero into a
	BFD_RELOC_ARM_OFFSET_IMM field if we're going to generate a RELA
	R_ARM_ABS12 reloc.
	(tc_gen_reloc): Keep the original fx_offset for RELA pc-relative
	relocs, but adjust by md_pcrel_from_section.  Create R_ARM_ABS12
	relocations for BFD_RELOC_ARM_OFFSET_IMM on RELA targets.

gas/testsuite/
	* gas/arm/abs12.s, gas/arm/abs12.d: New test.
	* gas/arm/pic.d: Skip for *-*-vxworks*...
	* gas/arm/pic_vxworks.d: ...use this version instead.
	* gas/arm/unwind_vxworks.d: Fix expected output.

ld/
	* emulparams/armelf_vxworks.sh: Include vxworks.sh.
	(MAXPAGESIZE): Define.
	* emulparams/vxworks.sh: Undefine.
	* Makefile.am (earmelf_vxworks.c): Depend on vxworks.sh and vxworks.em.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-arm/vxworks1.dd, ld-arm/vxworks1.ld, ld-arm/vxworks1-lib.dd,
	* ld-arm/vxworks1-lib.nd, ld-arm/vxworks1-lib.rd,
	* ld-arm/vxworks1-lib.s, ld-arm/vxworks1.rd, ld-arm/vxworks1.s,
	* ld-arm/vxworks1-static.d, ld-arm/vxworks2.s, ld-arm/vxworks2.sd,
	* ld-arm/vxworks2-static.sd: New tests.
	* ld-arm/arm-elf.exp: Run them.
@
text
@d7354 1
a7354 1
	  char *p;
@


1.65
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d23 1
d26 1
d33 26
d65 2
d173 2
a174 2
	 0x000008ff,		/* src_mask */
	 0x000008ff,		/* dst_mask */
d1524 32
d1733 3
d1751 3
d1799 14
a1812 1
/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up
d1833 2
a1834 1
  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rel.got",
d1846 2
a1847 2
/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and
   .rel.bss sections in DYNOBJ, and set up shortcuts to them in our
d1863 2
a1864 1
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rel.plt");
d1867 22
a1888 1
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");
d1982 1
d1998 1
d2914 14
d3014 4
d3052 1
a3052 1
					   (bfd_vma) 0);
d3088 1
a3088 4
	      BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			  && strcmp (bfd_get_section_name (input_bfd,
							   input_section),
				     name + 4) == 0);
d3097 1
a3120 1
	      relocate = TRUE;
d3145 4
d3152 2
a3153 2
	  loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rel);
	  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d3167 3
a3316 12
    case R_ARM_ABS12:
      /* Support ldr and str instruction for the arm */
      /* Also thumb b (unconditional branch).  ??? Really?  */
      value += addend;

      if ((long) value > 0x7ff || (long) value < -0x800)
	return bfd_reloc_overflow;

      value |= (bfd_get_32 (input_bfd, hit_data) & 0xfffff000);
      bfd_put_32 (input_bfd, value, hit_data);
      return bfd_reloc_ok;

d3708 1
a3708 1
				       (bfd_vma) 0);
d3721 1
a3721 1
				       (bfd_vma) 0);
d3751 1
a3751 1
		 When doing a dynamic link, we create a .rel.got relocation
d3797 2
a3798 1
	      bfd_put_32 (output_bfd, value, sgot->contents + off);
d3806 2
a3807 1
		  srelgot = bfd_get_section_by_name (dynobj, ".rel.got");
d3810 1
d3816 2
a3817 2
		  loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d3830 1
a3830 1
				       (bfd_vma) 0);
d3836 2
a3837 1
				       contents, rel->r_offset, value, (bfd_vma) 0);
d3862 1
d3867 3
a3869 1
		bfd_put_32 (output_bfd, 0, globals->sgot->contents + off);
d3872 2
a3873 2
		loc += globals->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d3886 1
a3886 1
					 (bfd_vma) 0);
d3947 1
a3947 1
		loc += globals->srelgot->reloc_count * sizeof (Elf32_External_Rel);
d3954 1
d3956 2
a3957 1
				       + globals->sgot->output_offset + cur_off);
a3958 1
		    bfd_put_32 (output_bfd, 0, globals->sgot->contents + cur_off);
d3960 5
a3964 1
		    bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d3966 1
a3966 1
		    loc += sizeof (Elf32_External_Rel);
d3973 1
a3973 3
			bfd_put_32 (output_bfd, 0,
				    globals->sgot->contents + cur_off + 4);

d3977 7
a3983 1
			bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d3985 1
a3985 1
			loc += sizeof (Elf32_External_Rel);
d4008 4
d4017 2
a4018 5
		    if (indx == 0)
		      bfd_put_32 (output_bfd, value - dtpoff_base (info),
				  globals->sgot->contents + cur_off);
		    else
		      bfd_put_32 (output_bfd, 0,
d4021 1
a4021 1
		    bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
d4023 1
a4023 1
		    loc += sizeof (Elf32_External_Rel);
d4044 1
a4044 1
					 (bfd_vma) 0);
d4060 2
a4061 1
				       contents, rel->r_offset, value, (bfd_vma) 0);
d5265 4
a5268 1
  if (EF_ARM_EABI_VERSION (in_flags) == EF_ARM_EABI_UNKNOWN)
d5823 7
d5904 1
a5904 3
		    BFD_ASSERT (strncmp (name, ".rel", 4) == 0
			        && strcmp (bfd_get_section_name (abfd, sec),
					   name + 4) == 0);
d6239 1
a6239 1
     .rel.bss section we are going to use.  */
d6244 1
a6244 1
      srel = bfd_get_section_by_name (dynobj, ".rel.bss");
d6246 1
a6246 1
      srel->size += sizeof (Elf32_External_Rel);
d6360 18
a6377 2
	  /* We also need to make an entry in the .rel.plt section.  */
	  htab->srelplt->size += sizeof (Elf32_External_Rel);
d6442 1
a6442 1
		htab->srelgot->size += sizeof (Elf32_External_Rel);
d6445 1
a6445 1
		htab->srelgot->size += sizeof (Elf32_External_Rel);
d6448 1
a6448 1
		htab->srelgot->size += sizeof (Elf32_External_Rel);
d6454 1
a6454 1
	    htab->srelgot->size += sizeof (Elf32_External_Rel);
d6558 1
a6558 1
      sreloc->size += p->count * sizeof (Elf32_External_Rel);
d6654 1
a6654 1
		  srel->size += p->count * sizeof (Elf32_External_Rel);
d6685 1
a6685 1
		srel->size += sizeof (Elf32_External_Rel);
d6699 1
a6699 1
	htab->srelgot->size += sizeof (Elf32_External_Rel);
d6734 2
a6735 2
                 than .rel.plt.  */
	      if (strcmp (name, ".rel.plt") != 0)
d6753 2
a6754 2
	     output file.  This is mostly to handle .rel.bss and
	     .rel.plt.  We must create both sections in
d6794 2
a6795 1
	      || !add_dynamic_entry (DT_PLTREL, DT_REL)
d6802 14
a6815 4
	  if (   !add_dynamic_entry (DT_REL, 0)
	      || !add_dynamic_entry (DT_RELSZ, 0)
	      || !add_dynamic_entry (DT_RELENT, sizeof (Elf32_External_Rel)))
	    return FALSE;
d6864 1
a6864 1
      srel = bfd_get_section_by_name (dynobj, ".rel.plt");
d6891 1
a6891 1
	  bfd_vma got_offset;
d6909 9
a6917 11
	  /* Calculate the displacement between the PLT slot and the
	     entry in the GOT.  The eight-byte offset accounts for the
	     value produced by adding to pc in the first instruction
	     of the PLT stub.  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      + got_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - h->plt.offset
			      - 8);
d6919 4
a6922 1
	  BFD_ASSERT ((got_displacement & 0xf0000000) == 0);
d6924 12
a6935 1
	  if (!htab->use_blx && eh->plt_thumb_refcount > 0)
d6937 33
a6969 4
	      bfd_put_16 (output_bfd, elf32_arm_plt_thumb_stub[0],
			  splt->contents + h->plt.offset - 4);
	      bfd_put_16 (output_bfd, elf32_arm_plt_thumb_stub[1],
			  splt->contents + h->plt.offset - 2);
d6971 9
d6981 20
a7000 6
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[0] | ((got_displacement & 0x0ff00000) >> 20),
		      splt->contents + h->plt.offset + 0);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[1] | ((got_displacement & 0x000ff000) >> 12),
		      splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[2] | (got_displacement & 0x00000fff),
		      splt->contents + h->plt.offset + 8);
d7002 2
a7003 2
	  bfd_put_32 (output_bfd, elf32_arm_plt_entry[3],
		      splt->contents + h->plt.offset + 12);
d7005 1
d7013 3
a7015 4
	  /* Fill in the entry in the .rel.plt section.  */
	  rel.r_offset = (sgot->output_section->vma
			  + sgot->output_offset
			  + got_offset);
d7019 2
a7020 2
      loc = srel->contents + plt_index * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d7044 1
d7049 1
a7049 1
      srel = bfd_get_section_by_name (dynobj, ".rel.got");
d7052 2
d7056 1
a7056 1
		      + (h->got.offset &~ (bfd_vma) 1));
d7068 5
d7077 1
a7077 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d7081 2
a7082 2
      loc = srel->contents + srel->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d7097 1
a7097 1
				   ".rel.bss");
d7100 1
d7105 2
a7106 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rel);
      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
d7109 3
a7111 1
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
d7113 1
a7113 1
      || h == htab->root.hgot)
d7185 1
a7185 1
	      name = ".rel.plt";
d7205 2
a7206 1
	      s = bfd_get_section_by_name (output_bfd, ".rel.plt");
d7213 1
d7222 1
a7222 1
		     the linker script arranges for .rel.plt to follow all
d7225 2
a7226 1
		  s = bfd_get_section_by_name (output_bfd, ".rel.plt");
a7235 1
	    case DT_RELASZ:
d7298 36
a7333 1
	  bfd_vma got_displacement;
a7334 11
	  /* Calculate the displacement between the PLT slot and &GOT[0].  */
	  got_displacement = (sgot->output_section->vma
			      + sgot->output_offset
			      - splt->output_section->vma
			      - splt->output_offset
			      - 16);

	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[1], splt->contents +  4);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[2], splt->contents +  8);
	  bfd_put_32 (output_bfd, elf32_arm_plt0_entry[3], splt->contents + 12);
d7336 3
a7338 3
	  /* The displacement value goes in the otherwise-unused last word of
	     the second entry.  */
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 28);
d7340 1
a7340 1
	  bfd_put_32 (output_bfd, got_displacement,        splt->contents + 16);
d7342 1
d7348 27
d7744 1
a7744 1
			      struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d7752 6
a7762 1
  globals = elf32_arm_hash_table (info);
d8143 1
a8143 1
	= (struct elf32_arm_link_hash_table *)ret;
d8145 1
d8150 7
d8163 9
d8174 1
a8174 1
#define elf_backend_may_use_rel_p   0
d8176 1
a8176 1
#define elf_backend_may_use_rela_p  1
d8178 1
a8178 1
#define elf_backend_default_use_rela_p 1
d8180 5
a8184 1
#define elf_backend_rela_normal     1
d8296 1
d8304 4
d8321 1
a8321 1
#define elf_backend_may_use_rel_p   1
d8323 1
a8323 1
#define elf_backend_may_use_rela_p  0
d8325 1
a8325 1
#define elf_backend_default_use_rela_p 0
d8327 5
a8331 1
#define elf_backend_rela_normal     0
@


1.64
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d6869 1
a6869 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.63
log
@2006-01-27  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (elf32_arm_get_symbol_type): Allow STT_TLS thumb
	objects.
@
text
@d6336 1
a6336 1
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
d6338 14
a6351 1
	eh->relocs_copied = NULL;
@


1.62
log
@* elf32-arm.c (elf32_arm_output_symbol_hook): Install new entry	into the
newly (re)allocated map array.
@
text
@d5374 1
a5374 1
      if (type != STT_OBJECT)
@


1.61
log
@2005-12-12  Paul Brook  <paul@@codesourcery.com>

bfd/
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(check_use_blx): New function.
	(bfd_elf32_arm_process_before_allocation): Don't allocate glue if
	using BLX.
	(elf32_arm_final_link_relocate): Perform bl<->blx conversion for
	R_ARM_CALL and R_ARM_THM.
	(elf32_arm_get_eabi_attr_int): New function.
	(elf32_arm_size_dynamic_sections): Call check_use_blx.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_PCREL_CALL and BFD_RELOC_ARM_PCREL_JUMP.
gas/
	* config/tc-arm.c (do_branch): Generate EABI branch relocations.
	(do_bl): New function.
	(do_blx): Generate BFD_RELOC_ARM_PCREL_CALL relocation.
	(do_t_blx): Generate BFD_RELOC_THUMB_PCREL_BRANCH23.
	(insns): Use do_bl.
	(md_pcrel_from_section): Add BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(md_apply_fix): Merge BFD_RELOC_ARM_PCREL_BRANCH and
	BFD_RELOC_ARM_PCREL_BLX cases.  Handle BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	(tc_gen_reloc): Handle BFD_RELOC_ARM_PCREL_CALL and
	BFD_RELOC_ARM_PCREL_JUMP.
	gas/testsuite/
	* gas/arm/pic.d: Allow R_ARM_CALL relocations.
include/elf/
	* arm.h (elf32_arm_get_eabi_attr_int): Add prototype.
ld/testsuite/
	* ld-arm/arm-call.d: New test.
	* ld-arm/arm-call1.s: New file.
	* ld-arm/arm-call1.s: New file.
	* ld-arm/arm-elf.exp: Add arm-call and mixed-app-v5.
	* ld-arm/arm.ld: Add .glue_7 and .ARM.attribues.
	* ld-arm/mixed-app-v5.d: New file.
	* ld-arm/mixed-app.r: Tweak expected output.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d7462 1
d7471 2
a7472 2
      map[mapcount - 1].vma = elfsym->st_value;
      map[mapcount - 1].type = name[1];
@


1.60
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d1300 2
d2290 6
d2317 1
d2415 2
a2416 1
	      if (ELF_ST_TYPE(h->type) == STT_ARM_TFUNC)
d2424 1
a2424 1
	      if (ELF_ST_TYPE (h->type) != STT_ARM_TFUNC)
d3058 1
a3058 1
	  else
d3114 24
a3137 8
	  /* If necessary set the H bit in the BLX instruction.  */
	  if (r_type == R_ARM_XPC25 && ((value & 2) == 2))
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask))
	      | (1 << 24);
	  else
	    value = (signed_addend & howto->dst_mask)
	      | (bfd_get_32 (input_bfd, hit_data) & (~ howto->dst_mask));
a3232 1
	bfd_boolean thumb_plt_call = FALSE;
d3266 6
a3271 1
		if (elf32_thumb_to_arm_stub
d3278 5
d3295 1
a3295 5
 		if ((lower_insn & (0x3 << 11)) == 0x3 << 11)
		  {
		    lower_insn = (lower_insn & ~(0x3 << 11)) | 0x1 << 11;
		    thumb_plt_call = TRUE;
		  }
d3322 1
a3322 3
	if ((r_type == R_ARM_THM_XPC22
	     && ((lower_insn & 0x1800) == 0x0800))
	    || thumb_plt_call)
d4506 25
d6438 1
@


1.59
log
@* elf32-arm.c (find_arm_elf_section_entry): New function.
  (get_arm_elf_section_data): Use it.
  (unrecord_section_with_arm_elf_section_data): Use it.
@
text
@d1796 1
a1796 1
elf32_arm_copy_indirect_symbol (const struct elf_backend_data *bed,
d1812 1
a1812 4
	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d1836 3
a1838 10
  /* If the direct symbol already has an associated PLT entry, the
     indirect symbol should not.  If it doesn't, swap refcount information
     from the indirect symbol.  */
  if (edir->plt_thumb_refcount == 0)
    {
      edir->plt_thumb_refcount = eind->plt_thumb_refcount;
      eind->plt_thumb_refcount = 0;
    }
  else
    BFD_ASSERT (eind->plt_thumb_refcount == 0);
d1847 1
a1847 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.58
log
@2005-10-08  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c: Move #include "elf/arm.h" after libbfd.h.
	(NUM_KNOWN_ATTRIBUTES): Define.
	(aeabi_attribute, aeabi_attribute_list): Define.
	(elf32_arm_obj_tdata): Add known_eabi_attributes and
	other_eabi_attributes.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, attr_strdup, elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_compat, copy_eabi_attributes,
	elf32_arm_merge_eabi_attributes): New functions.
	(elf32_arm_copy_private_bfd_data): Copy EABI object attributes.
	(elf32_arm_fake_sections): Handle .ARM.attributes.
	(elf32_arm_parse_attributes): New function.
	(elf32_arm_section_from_shdr): Use it.
	(bfd_elf32_bfd_final_link): Define.
gas/
	* config/tc-arm.c: Don't provide fallback default for CPU_DEFAULT.
	(arm_arch_used, thumb_arch_used, selected_cpu, selected_cpu_name):
	New variables.
	(arm_cpu_option_table): Add canonical_name.
	(arm_cpus): Populate canonical_name field.
	(s_arm_eabi_attribute, s_arm_arch, s_arm_cpu, s_arm_fpu,
	aeabi_set_public_attributes, arm_md_end): New functions.
	(md_pseudo_table): Add "cpu", "arch", "fpu" and "eabi_attribute".
	(md_assemble): Set thumb_arch_used and arm_arch_used.
	(md_begin): Set defaut cpu if CPU_DEFAULT not defined.
	* config/tc-arm.h (md_end): Define.
	* doc/c-arm.texi: Document .cpu, .arch, .fpu and .eabi_attribute.
gas/testsuite/
	* gas/arm/eabi_attr_1.s: New test.
	* gas/arm/eabi_attr_1.d: New test.
	* gas/arm/arm7t.d: Only disassemble code sections.
	* gas/arm/bignum1.d: Ignore Arm object attribute sections.
	* gas/arm/mapping.d: Ditto.
	* gas/arm/unwind.d: Ditto.
	* gas/elf/section0.d: Ditto.
	* gas/elf/section1.d: Ditto.
	* gas/elf/elf.exp: Set target_machine for Arm EABI based targets.
	* gas/elf/section2.e-armeabi: New file.
include/elf/
	* arm.h: Add prototypes for BFD object attribute routines.
ld/testsuite/
	* ld-arm/arm-rel31.d: Ignore Arm object attribute sections.
	* ld-arm/arm-target1-abs.d: Ditto.
	* ld-arm/arm-target1-rel.d: Ditto.
	* ld-arm/arm-target2-abs.d: Ditto.
	* ld-arm/arm-target2-got-rel.d: Ditto.
	* ld-arm/arm-target2-rel.d: Ditto.
@
text
@d7314 2
a7315 2
static _arm_elf_section_data *
get_arm_elf_section_data (asection * sec)
d7324 1
d7328 5
a7332 1
	return elf32_arm_section_data (sec);
d7334 1
a7334 9
      if (last_entry->prev != NULL
	  && last_entry->prev->sec == sec)
	{
	  last_entry = last_entry->prev;
	  return elf32_arm_section_data (sec);
	}
    }
 
  for (entry = sections_with_arm_elf_section_data; entry; entry = entry->next)
d7336 18
a7353 4
      {
	last_entry = entry;
	return elf32_arm_section_data (sec);
      }
d7355 4
a7358 1
  return NULL;
d7366 12
a7377 12
  for (entry = sections_with_arm_elf_section_data; entry; entry = entry->next)
    if (entry->sec == sec)
      {
	if (entry->prev != NULL)
	  entry->prev->next = entry->next;
	if (entry->next != NULL)
	  entry->next->prev = entry->prev;
	if (entry == sections_with_arm_elf_section_data)
	  sections_with_arm_elf_section_data = entry->next;
	free (entry);
	break;
      }
@


1.57
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@a20 1
#include "elf/arm.h"
d25 1
d1532 16
d1554 3
d3931 188
d4449 99
d4598 43
d4692 283
d4997 3
d7126 4
d7133 112
d7274 2
d7703 1
@


1.56
log
@* elf32-arm.c (get_arm_elf_section_data): Cache the last pointer matched so
that the typical case of scanning for the previous section to last one can be
handled quickly.
@
text
@d5121 2
d5128 2
a5129 2
		    head = ((struct elf32_arm_relocs_copied **)
			    &elf_section_data (s)->local_dynrel);
d5790 1
a5790 4
	  for (p = *((struct elf32_arm_relocs_copied **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
@


1.55
log
@	* elf32-arm.c (elf32_arm_section_from_shdr): Accept SHT_ARM_PREEMPTMAP
	and SHT_ARM_ATTRIBUTES.
@
text
@d6566 1
d6568 17
d6587 5
a6591 1
      return elf32_arm_section_data (sec);
@


1.54
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d6513 2
@


1.53
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d4178 6
a4183 3
	    (_("%B(%A+0x%lx): warning: unresolvable relocation %d against symbol `%s'"),
	     input_bfd, input_section, (long) rel->r_offset,
	     r_type, h->root.root.string);
@


1.52
log
@2005-08-15  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (elf32_arm_howto_table_1): Make R_ARM_PLT32 the same as
	R_ARM_PC24.
@
text
@d5391 7
@


1.51
log
@PR 1147
elf32-arm.c (bfd_elf32_close_and_cleanup): Define.
  (elf32_arm_close_and_cleanup): New function - walk over the sections in the
    bfd that is being closed removing them from the list of recorded sections.
  (unrecord_section_via_map_over_sections): New helper function.
  (record_section_with_arm_elf_section_data): Call bfd_malloc instead of
    bfd_alloc.  Remove unneeded abfd parameter.
  (elf32_arm_new_section_hook): Do not pass bfd to record_section_with_arm_elf_section_data.
elfxx-target.h (bfd_elfNN_close_and_cleanup): Only define if not already
  defined by the target.
@
text
@d438 1
a438 1
         26,                    /* bitsize */
d444 1
a444 1
         TRUE,			/* partial_inplace */
@


1.50
log
@PR 1147
* elf32-arm.c (struct _arm_elf_section_data): Turn into a typedef and make the
  mapcount field unsigned.
(struct section_list): New: Used to keep track of which sections have an
  _arm_elf_section_data structure.
(record_section_with_arm_elf_section_data): New function.
(get_arm_elf_section_data): New function.
(unrecord_section_with_arm_elf_section_data): New function.
(elf32_arm_output_symbol_hook): Use get_arm_elf_section_data.
(elf32_arm_new_section_hook): Call record_section_with_arm_elf_section_data.
(elf32_arm_write_section): Use get_arm_elf_section_data and
  unrecord_section_with_arm_elf_section_data.
@
text
@d6535 1
a6535 1
record_section_with_arm_elf_section_data (bfd * abfd, asection * sec)
d6539 1
a6539 1
  entry = bfd_alloc (abfd, sizeof (* entry));
d6645 1
a6645 1
  record_section_with_arm_elf_section_data (abfd, sec);
d6742 16
d6916 1
@


1.49
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1518 1
a1518 1
struct _arm_elf_section_data
d1521 1
a1521 1
  int mapcount;
d1523 2
a1524 1
};
d1527 1
a1527 1
  ((struct _arm_elf_section_data *) elf_section_data (sec))
d4404 1
a4404 1
     cannot actually cause any incompatibility.  Do not short-circuit
d6515 65
d6592 2
d6609 8
a6616 2
  mapcount = ++(elf32_arm_section_data (input_sec)->mapcount);
  map = elf32_arm_section_data (input_sec)->map;
d6619 9
a6627 2
  map = bfd_realloc (map, mapcount * sizeof (elf32_arm_section_map));
  elf32_arm_section_data (input_sec)->map = map;
a6628 2
  map[mapcount - 1].vma = elfsym->st_value;
  map[mapcount - 1].type = name[1];
a6631 1

d6637 1
a6637 1
  struct _arm_elf_section_data *sdata;
d6645 2
d6669 1
d6677 8
a6684 2
  mapcount = elf32_arm_section_data (sec)->mapcount;
  map = elf32_arm_section_data (sec)->map;
d6689 1
a6689 2
  qsort (map, mapcount, sizeof (elf32_arm_section_map),
	 elf32_arm_compare_mapping);
d6733 1
d6735 4
@


1.48
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a5854 1
      bfd_boolean strip;
a5862 2
      strip = FALSE;

d5865 2
a5866 11
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
d5870 1
a5870 14
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rel.bss and
		 .rel.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
d5882 2
a5883 1
      else if (strncmp (name, ".got", 4) != 0)
d5889 1
a5889 1
      if (strip)
d5891 9
d5904 3
d5909 1
a5909 1
      if (s->contents == NULL && s->size != 0)
@


1.47
log
@(elf32_arm_size_dynamic_sections): Fix a typo and touchup logic like i386/ppc.
@
text
@a6964 18
static const struct bfd_elf_special_section *
elf32_arm_symbian_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf32_arm_symbian_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d7017 2
a7018 2
#undef elf_backend_get_sec_type_attr
#define elf_backend_get_sec_type_attr elf32_arm_symbian_get_sec_type_attr
@


1.46
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@d5935 1
a5935 1
      if (!info->shared)
a5967 1
	  info->flags |= DF_TEXTREL;
d5970 1
a5970 1
#undef add_synamic_entry
@


1.45
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d6945 1
a6945 1
static struct bfd_elf_special_section const
d6969 1
a6969 1
  const struct bfd_elf_special_section const *ssect;
@


1.44
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d6946 1
a6946 1
  symbian_special_sections_d[]=
a6954 10
  { NULL,              0,  0, 0,            0 }
};

static struct bfd_elf_special_section const
  symbian_special_sections_g[]=
{
  /* In a BPABI executable, the dynamic linking sections do not go in
     the loadable read-only segment.  The post-linker may wish to
     refer to these sections, but they are not part of the final
     program image.  */
a6955 10
  { NULL,              0,  0, 0,            0 }
};

static struct bfd_elf_special_section const
  symbian_special_sections_h[]=
{
  /* In a BPABI executable, the dynamic linking sections do not go in
     the loadable read-only segment.  The post-linker may wish to
     refer to these sections, but they are not part of the final
     program image.  */
a6956 6
  { NULL,              0,  0, 0,            0 }
};

static struct bfd_elf_special_section const
  symbian_special_sections_i[]=
{
d6961 2
d6966 2
a6967 2
static struct bfd_elf_special_section const
  symbian_special_sections_f[]=
d6969 1
a6969 6
  /* These sections do not need to be writable as the SymbianOS
     postlinker will arrange things so that no dynamic relocation is
     required.  */
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
};
d6971 9
a6979 9
static struct bfd_elf_special_section const
  symbian_special_sections_p[]=
{
  /* These sections do not need to be writable as the SymbianOS
     postlinker will arrange things so that no dynamic relocation is
     required.  */
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
};
d6981 2
a6982 31
static struct bfd_elf_special_section const *
  elf32_arm_symbian_special_sections[27]=
{
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  symbian_special_sections_d,	/* 'd' */
  NULL,				/* 'e' */
  symbian_special_sections_f,	/* 'f' */
  symbian_special_sections_g,	/* 'g' */
  symbian_special_sections_h,	/* 'h' */
  symbian_special_sections_i,	/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  symbian_special_sections_p,	/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  NULL,				/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d7036 2
a7037 2
#undef elf_backend_special_sections
#define elf_backend_special_sections elf32_arm_symbian_special_sections
@


1.43
log
@	* elf32-arm.c (elf32_arm_reloc_type_lookup)
	(elf32_arm_nabi_grok_prstatus, elf32_arm_nabi_grok_psinfo):
	Use ISO C90 function declaration style.
@
text
@d4915 6
a4920 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.42
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@a36 7
static reloc_howto_type * elf32_arm_reloc_type_lookup
  PARAMS ((bfd * abfd, bfd_reloc_code_real_type code));
static bfd_boolean elf32_arm_nabi_grok_prstatus
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
static bfd_boolean elf32_arm_nabi_grok_psinfo
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));

d1340 2
a1341 3
elf32_arm_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1353 1
a1353 3
elf32_arm_nabi_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d1383 1
a1383 3
elf32_arm_nabi_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
@


1.41
log
@	* bfd/elf32-arm.c: Make all #ifndef OLD_ARM_ABI blocks
	unconditional.
	* include/elf/arm.h: Make all #ifndef OLD_ARM_ABI blocks
	unconditional, delete all #ifdef OLD_ARM_ABI blocks.
@
text
@d5292 13
d6826 1
@


1.40
log
@include/elf:
	* arm.h: Import complete list of official relocation names
	and numbers from AAELF.  Define FAKE_RELOCs for old names.
	Remove a few old names no longer used anywhere.

bfd:
	* elf32-arm.c: Wherever possible, use official reloc names
	from AAELF.
	(elf32_arm_howto_table, elf32_arm_tls_gd32_howto)
	(elf32_arm_tls_ldo32_howto, elf32_arm_tls_ldm32_howto)
	(elf32_arm_tls_le32_howto, elf32_arm_tls_ie32_howto)
	(elf32_arm_vtinherit_howto, elf32_arm_vtentry_howto)
	(elf32_arm_pc11_howto, elf32_arm_thm_pc9_howto, elf32_arm_got_prel)
	(elf32_arm_r_howto): Replace with elf32_arm_howto_table_1,
	elf32_arm_howto_table_2, and elf32_arm_howto_table_3.
	Add many new relocations from AAELF.
	(elf32_arm_howto_from_type): Update to match.
	(elf32_arm_reloc_map): Add entries for R_ARM_THM_JUMP24,
	R_ARM_THM_JUMP11, R_ARM_THM_JUMP19, R_ARM_THM_JUMP8,
	R_ARM_THM_JUMP6, R_ARM_GNU_VTINHERIT, and R_ARM_GNU_VTENTRY.
	(elf32_arm_reloc_type_lookup): Use elf32_arm_howto_from_type.
	(elf32_arm_final_link_relocate): Add support for
	R_ARM_THM_JUMP24, R_ARM_THM_JUMP19, R_ARM_THM_JUMP6.  Remove
	case entries redundant with default.

	* reloc.c: Reorganize ARM relocations.  Add Thumb
	assembler-internal relocations BFD_RELOC_ARM_T32_OFFSET_U8,
	BFD_RELOC_ARM_T32_OFFSET_IMM, BFD_RELOC_ARM_T32_IMMEDIATE.
	Add visible relocations BFD_RELOC_THUMB_PCREL_BRANCH7,
	BFD_RELOC_THUMB_BRANCH20, BFD_RELOC_THUMB_BRANCH25.
	Delete unused relocations BFD_RELOC_ARM_GOT12, BFD_RELOC_ARM_COPY.
	* bfd-in2.h, libbfd.h: Regenerate.

opcodes:
	* arm-dis.c (thumb_opcodes): Add disassembly for V6T2 16-bit
	instructions.  Adjust disassembly of some opcodes to match
	unified syntax.
	(thumb32_opcodes): New table.
	(print_insn_thumb): Rename print_insn_thumb16; don't handle
	two-halfword branches here.
	(print_insn_thumb32): New function.
	(print_insn): Choose among print_insn_arm, print_insn_thumb16,
	and print_insn_thumb32.  Be consistent about order of
	halfwords when printing 32-bit instructions.

gas:
	* hash.c (hash_lookup): Add len parameter.  All callers changed.
	(hash_find_n): New interface.
	* hash.h: Prototype hash_find_n.
	* sb.c: Include as.h.
	(scrub_from_sb, sb_to_scrub, scrub_position): New statics.
	(sb_scrub_and_add_sb): New interface.
	* sb.h: Prototype sb_scrub_and_add_sb.
	* input-scrub.c (input_scrub_include_sb): Use sb_scrub_and_add_sb.

	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Remove
	reference to BFD_RELOC_ARM_GOT12 which is never generated.
	* config/tc-arm.c: Rewrite, adding Thumb-2 support.

gas/testsuite:
	* gas/arm/arm.exp: Convert all existing "gas_test" tests to
	"run_dump_test" tests.  Run more tests unconditionally.  Run new tests.
	* gas/arm/arch4t.s, gas/arm/arch6zk.s, gas/arm/arm3.s, gas/arm/arm6.s
	* gas/arm/arm7dm.s, gas/arm/bignum1.s, gas/arm/float.s
	* gas/arm/immed.s, gas/arm/iwmmxt.s, gas/arm/offset.s, gas/arm/thumb.s:
	Adjust to work as a dump test.
	* gas/arm/arch4t.d, gas/arm/arch6zk.d, gas/arm/arm3.d, gas/arm/arm6.d
	* gas/arm/arm7dm.d, gas/arm/bignum1.d, gas/arm/float.d
	* gas/arm/immed.d, gas/arm/iwmmxt.d, gas/arm/offset.d, gas/arm/thumb.d:
	New files.

	* gas/arm/armv1-bad.l, gas/arm/armv1-bad.s: Remove tests for
	diagnostics that don't happen in the first pass anymore.

	* gas/arm/iwmmxt-bad.l, gas/arm/r15-bad.l, gas/arm/req.l
	* gas/arm/vfp-bad.l:
	Update expected diagnostics.
	* gas/arm/pic.d: Update expected reloc name.
	* gas/arm/thumbv6.d: CPY no longer appears in disassembly.
	* gas/arm/r15-bad.s: Avoid two-argument mul.
	* gas/arm/req.s: Adjust comments.
	* gas/arm/maverick.d, gas/arm/maverick.s: Avoid inappropriate
	use of PC.

	* gas/arm/macro-1.d, gas/arm/macro1.s
	* gas/arm/t16-bad.l, gas/arm/t16-bad.s
	* gas/arm/tcompat.d, gas/arm/tcompat.s
	* gas/arm/tcompat2.d, gas/arm/tcompat2.s
	* gas/arm/thumb32.d, gas/arm/thumb32.s
	New test pair.

ld/testsuite:
	* ld-arm/mixed-app.d: Adjust expected disassembly a little.
@
text
@a2357 1
#ifndef OLD_ARM_ABI
a2359 1
#endif
a2402 1
#ifndef OLD_ARM_ABI
a2404 1
#endif
a2450 1
#ifndef OLD_ARM_ABI
a2478 1
#endif
a2748 2

#ifndef OLD_ARM_ABI
a2769 2
#endif /* OLD_ARM_ABI */

a2832 1
#ifndef OLD_ARM_ABI
a2837 1
#endif /* OLD_ARM_ABI */
a2888 1
#ifndef OLD_ARM_ABI
a2892 1
#endif
a2933 1
#ifndef OLD_ARM_ABI
a2936 1
#endif
a3033 1
#ifndef OLD_ARM_ABI
a3036 1
#endif
a3038 1
#ifndef OLD_ARM_ABI
a3050 1
#endif
a3105 1
#ifndef OLD_ARM_ABI
a3111 1
#endif
a3127 1
#ifndef OLD_ARM_ABI
a3142 1
#endif
a3196 1
#ifndef OLD_ARM_ABI
a3197 1
#endif
d3221 1
a3221 1
#ifndef OLD_ARM_ABI
a3233 1
#endif
a3292 1
#ifndef OLD_ARM_ABI
d3301 1
a3301 1
#endif
a3512 1
#ifndef OLD_ARM_ABI
a3537 1
#endif
a3580 1
#ifndef OLD_ARM_ABI
a3581 1
#endif
a3977 1
#ifndef OLD_ARM_ABI
a3979 1
#endif
a4788 1
#ifndef OLD_ARM_ABI
a4789 1
#endif
a4792 1
#ifndef OLD_ARM_ABI
a4793 1
#endif
a4815 1
#ifndef OLD_ARM_ABI
a4818 1
#endif
a4914 1
#ifndef OLD_ARM_ABI
a4915 1
#endif
a4933 1
#ifndef OLD_ARM_ABI
a4934 1
#endif
a5013 1
#ifndef OLD_ARM_ABI
a5016 1
#endif
a5034 1
#ifndef OLD_ARM_ABI
a5037 1
#endif
@


1.39
log
@ldlang.c (print_assignment): Do not rely upon a valid result having a section
  associated with it.
elf32-arm.c (elf32_arm_final_link_relocate): Gracefully handle the situation
  where a symbols's section is not known but a section relative R_ARM_RELATIVE
  reloc has to be generated for the Symbian OS.
@
text
@d48 1
a48 1
static reloc_howto_type elf32_arm_howto_table[] =
d109 1
a109 1
  /* 8 bit absolute */
d197 2
a198 1
  HOWTO (R_ARM_THM_PC22,	/* type */
d206 1
a206 1
	 "R_ARM_THM_PC22",	/* name */
d226 1
a226 1
  HOWTO (R_ARM_AMP_VCALL9,	/* type */
d229 2
a230 2
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
d234 1
a234 1
	 "R_ARM_AMP_VCALL9",	/* name */
d236 3
a238 3
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d400 1
a400 1
  HOWTO (R_ARM_GOTOFF,		/* type */
d408 1
a408 1
         "R_ARM_GOTOFF",	/* name */
d484 5
a488 5
  HOWTO (R_ARM_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
d490 1
a490 1
	 complain_overflow_dont,/* complain_on_overflow */
d492 1
a492 1
	 "R_ARM_unknown_30",	/* name */
d494 3
a496 3
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d498 1
a498 1
  HOWTO (R_ARM_NONE,		/* type */
d500 2
a501 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d506 1
a506 1
	 "R_ARM_unknown_31",	/* name */
d508 2
a509 2
	 0,			/* src_mask */
	 0,			/* dst_mask */
d665 199
d866 183
a1048 2
static reloc_howto_type elf32_arm_tls_gd32_howto = 
  HOWTO (R_ARM_TLS_GD32,	/* type */
d1051 1
a1051 1
         32,                    /* bitsize */
d1054 35
a1088 7
         complain_overflow_bitfield,/* complain_on_overflow */
         NULL,			/* special_function */
         "R_ARM_TLS_GD32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */
d1090 2
a1091 2
static reloc_howto_type elf32_arm_tls_ldo32_howto = 
  HOWTO (R_ARM_TLS_LDO32,	/* type */
d1098 2
a1099 2
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LDO32",	/* name */
d1103 1
a1103 1
         FALSE);                /* pcrel_offset */
a1104 1
static reloc_howto_type elf32_arm_tls_ldm32_howto = 
d1117 1
a1117 1
         FALSE);                /* pcrel_offset */
d1119 1
a1119 2
static reloc_howto_type elf32_arm_tls_le32_howto = 
  HOWTO (R_ARM_TLS_LE32,	/* type */
d1127 1
a1127 1
         "R_ARM_TLS_LE32",	/* name */
d1131 1
a1131 1
         FALSE);                /* pcrel_offset */
a1132 1
static reloc_howto_type elf32_arm_tls_ie32_howto = 
d1145 1
a1145 1
         FALSE);                /* pcrel_offset */
d1147 1
a1147 3
  /* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf32_arm_vtinherit_howto =
  HOWTO (R_ARM_GNU_VTINHERIT, /* type */
d1150 1
a1150 1
         0,                     /* bitsize */
d1153 7
a1159 7
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_ARM_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE);                /* pcrel_offset */
d1161 5
a1165 23
  /* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf32_arm_vtentry_howto =
  HOWTO (R_ARM_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_ARM_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE);                /* pcrel_offset */

  /* 12 bit pc relative */
static reloc_howto_type elf32_arm_thm_pc11_howto =
  HOWTO (R_ARM_THM_PC11,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 TRUE,			/* pc_relative */
d1167 1
a1167 1
	 complain_overflow_signed,	/* complain_on_overflow */
d1169 1
a1169 1
	 "R_ARM_THM_PC11",	/* name */
d1171 3
a1173 3
	 0x000007ff,		/* src_mask */
	 0x000007ff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */
d1175 5
a1179 7
  /* 12 bit pc relative */
static reloc_howto_type elf32_arm_thm_pc9_howto =
  HOWTO (R_ARM_THM_PC9,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
d1181 1
a1181 1
	 complain_overflow_signed,	/* complain_on_overflow */
d1183 1
a1183 1
	 "R_ARM_THM_PC9",	/* name */
d1185 3
a1187 3
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */
d1189 1
a1189 3
/* Place relative GOT-indirect.  */
static reloc_howto_type elf32_arm_got_prel =
  HOWTO (R_ARM_GOT_PREL,	/* type */
d1192 2
a1193 2
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
d1195 1
a1195 1
	 complain_overflow_dont,	/* complain_on_overflow */
d1197 1
a1197 1
	 "R_ARM_GOT_PREL",	/* name */
d1199 10
a1208 3
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */
d1210 1
a1210 2
/* Currently unused relocations.  */
static reloc_howto_type elf32_arm_r_howto[4] =
d1272 2
a1273 7
  if (r_type < NUM_ELEM (elf32_arm_howto_table))
    return &elf32_arm_howto_table[r_type];
    
  switch (r_type)
    {
    case R_ARM_GOT_PREL:
      return &elf32_arm_got_prel;
d1275 7
a1281 2
    case R_ARM_GNU_VTINHERIT:
      return &elf32_arm_vtinherit_howto;
d1283 1
a1283 38
    case R_ARM_GNU_VTENTRY:
      return &elf32_arm_vtentry_howto;

    case R_ARM_THM_PC11:
      return &elf32_arm_thm_pc11_howto;

    case R_ARM_THM_PC9:
      return &elf32_arm_thm_pc9_howto;
      
    case R_ARM_TLS_GD32:
      return &elf32_arm_tls_gd32_howto;
      break;

    case R_ARM_TLS_LDO32:
      return &elf32_arm_tls_ldo32_howto;
      break;

    case R_ARM_TLS_LDM32:
      return &elf32_arm_tls_ldm32_howto;
      break;

    case R_ARM_TLS_IE32:
      return &elf32_arm_tls_ie32_howto;
      break;

    case R_ARM_TLS_LE32:
      return &elf32_arm_tls_le32_howto;
      break;

    case R_ARM_RREL32:
    case R_ARM_RABS32:
    case R_ARM_RPC24:
    case R_ARM_RBASE:
      return &elf32_arm_r_howto[r_type - R_ARM_RREL32];

    default:
      return NULL;
    }
d1315 6
a1320 2
    {BFD_RELOC_THUMB_PCREL_BRANCH23, R_ARM_THM_PC22},
    {BFD_RELOC_ARM_COPY,             R_ARM_COPY},
d1324 1
a1324 1
    {BFD_RELOC_ARM_GOTOFF,           R_ARM_GOTOFF},
d1342 2
d1352 3
d1356 1
a1356 36
  switch (code)
    {
    case BFD_RELOC_VTABLE_INHERIT:
      return & elf32_arm_vtinherit_howto;

    case BFD_RELOC_VTABLE_ENTRY:
      return & elf32_arm_vtentry_howto;

    case BFD_RELOC_THUMB_PCREL_BRANCH12:
      return & elf32_arm_thm_pc11_howto;

    case BFD_RELOC_THUMB_PCREL_BRANCH9:
      return & elf32_arm_thm_pc9_howto;

    case BFD_RELOC_ARM_TLS_GD32:
      return & elf32_arm_tls_gd32_howto;

    case BFD_RELOC_ARM_TLS_LDO32:
      return & elf32_arm_tls_ldo32_howto;

    case BFD_RELOC_ARM_TLS_LDM32:
      return & elf32_arm_tls_ldm32_howto;

    case BFD_RELOC_ARM_TLS_IE32:
      return & elf32_arm_tls_ie32_howto;

    case BFD_RELOC_ARM_TLS_LE32:
      return & elf32_arm_tls_le32_howto;

    default:
      for (i = 0; i < NUM_ELEM (elf32_arm_reloc_map); i ++)
	if (elf32_arm_reloc_map[i].bfd_reloc_val == code)
	  return & elf32_arm_howto_table[elf32_arm_reloc_map[i].elf_reloc_val];

      return NULL;
   }
d2362 1
a2362 1
	      && r_type != R_ARM_THM_PC22)
d2416 1
a2416 1
	    case R_ARM_THM_PC22:
d3224 1
a3224 1
    case R_ARM_THM_PC22:
d3342 147
a3488 2
    case R_ARM_THM_PC11:
    case R_ARM_THM_PC9:
d3496 4
d3525 5
a3529 1
	relocation &= howto->dst_mask;
d3573 1
a3573 13
    case R_ARM_COPY:
      return bfd_reloc_notsupported;

    case R_ARM_GLOB_DAT:
      return bfd_reloc_notsupported;

    case R_ARM_JUMP_SLOT:
      return bfd_reloc_notsupported;

    case R_ARM_RELATIVE:
      return bfd_reloc_notsupported;

    case R_ARM_GOTOFF:
a3933 24
    case R_ARM_SBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_AMP_VCALL9:
      return bfd_reloc_notsupported;

    case R_ARM_RSBREL32:
      return bfd_reloc_notsupported;

    case R_ARM_THM_RPC22:
      return bfd_reloc_notsupported;

    case R_ARM_RREL32:
      return bfd_reloc_notsupported;

    case R_ARM_RABS32:
      return bfd_reloc_notsupported;

    case R_ARM_RPC24:
      return bfd_reloc_notsupported;

    case R_ARM_RBASE:
      return bfd_reloc_notsupported;

d3964 1
a3964 1
  if (howto->type == R_ARM_THM_PC22)
d4859 1
a4859 1
	case R_ARM_THM_PC22:
d4873 1
a4873 1
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_THM_PC22)
d5043 1
a5043 1
	  case R_ARM_GOTOFF:
d5063 1
a5063 1
	  case R_ARM_THM_PC22:
d5087 1
a5087 1
		    || r_type == R_ARM_THM_PC22)
d5094 1
a5094 1
		if (r_type == R_ARM_THM_PC22)
@


1.38
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d2695 4
a2698 1
		  symbol = elf_section_data (sym_sec->output_section)->dynindx;
@


1.37
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d6541 2
a6542 2
static struct bfd_elf_special_section const 
  elf32_arm_symbian_special_sections[]=
d6551 10
d6562 10
d6573 6
d6583 9
d6593 9
d6606 32
@


1.36
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1417 6
a1422 1
  htab->srelgot = bfd_make_section (dynobj, ".rel.got");
a1423 4
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
d1901 3
a1903 1
      sec = bfd_make_section (abfd, ARM2THUMB_GLUE_SECTION_NAME);
a1905 1
	  || !bfd_set_section_flags (abfd, sec, flags)
d1921 3
a1923 1
      sec = bfd_make_section (abfd, THUMB2ARM_GLUE_SECTION_NAME);
a1925 1
	  || !bfd_set_section_flags (abfd, sec, flags)
a4695 1
		        sreloc = bfd_make_section (dynobj, name);
d4703 3
a4706 1
			    || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.35
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.34
log
@Update the FSF address in the copyright/GPL notice
@
text
@d5508 1
a5508 1
	  _bfd_strip_section_from_output (info, s);
@


1.33
log
@2005-05-01  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Treat
	R_ARM_PLT32 the same as R_ARM_PC24.
	(arm_add_to_rel): Ditto.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.32
log
@	* bfd/bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): New field, 'use_blx'.
	(elf32_arm_link_hash_table_create): Initialise fix_v4bx, use_blx.
	(bfd_elf32_arm_set_target_relocs): Handle use_blx.
	(elf32_arm_final_link_relocate): Use Thumb BLX for R_ARM_THM_PC22
	relocations if requested to.
	(allocate_dynrelocs): Don't count size of omitted Thumb stubs based on
	use_blx rather than symbian_p.
	(elf32_arm_finish_dynamic_symbol): Don't output Thumb PLT stubs if
	use_blx is in effect.
	(elf32_arm_symbian_link_hash_table_create): Enable use_blx by default
	for SymbianOS.
	* ld/ld.texinfo: Document --use-blx.
	* ld/emultempl/armelf.em (use_blx): New variable.
	(arm_elf_create_output_section_statements): Communicate value of
	use_blx to bfd.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_USE_BLX.
	(PARSE_AND_LIST_OPTIONS): Add --use-blx option.
	(PARSE_AND_LIST_ARGS_CASES): Add OPTION_USE_BLX case.
@
text
@d2076 1
d2097 1
a2097 1
	      break;
d3561 1
@


1.31
log
@2005-04-08  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (ARM2THUMB_GLUE_SIZE): Rename...
	(ARM2THUMB_STATIC_GLUE_SIZE): ... to this.
	(ARM2THUMB_PIC_GLUE_SIZE): Define.
	(a2t1p_ldr_insn, a2t2p_add_pc_insn, a2t3p_bx_r12_insn): Add.
	(elf32_arm_to_thumb_stub): Create PIC stubs.
	(record_arm_to_thumb_glue): Use different stub size for relocatable
	images.
@
text
@d1327 3
d1565 2
d2133 2
a2134 1
                                 int fix_v4bx)
d2153 1
d2903 1
d2953 13
a2965 2
	    /* Target the Thumb stub before the ARM PLT entry.  */
	    value -= 4;
d2989 3
a2991 2
	if (r_type == R_ARM_THM_XPC22
	    && ((lower_insn & 0x1800) == 0x0800))
d5082 1
a5082 1
	  if (!htab->symbian_p && eh->plt_thumb_refcount > 0)
d5655 1
a5655 1
	  if (eh->plt_thumb_refcount > 0)
d6528 2
@


1.30
log
@	* bfd/bfd-in.h (bfd_is_arm_mapping_symbol_name): Rename from
	bfd_elf32_is_arm_mapping_symbol_name.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): Rename from
	bfd_elf32_is_arm_mapping_symbol_name.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename
	bfd_elf32_is_arm_mapping_symbol_name to bfd_is_arm_mapping_symbol_name.
	(arm_elf_find_function): Likewise.
	(elf32_arm_output_symbol_hook): Likewise.
	* gas/config/tc-arm.c (arm_adjust_symtab): Likewise.
@
text
@d1639 1
a1639 1
/* ARM->Thumb glue:
d1646 1
a1646 1
   .word func    @@ behave as if you saw a ARM_32 reloc.  */
d1648 11
a1658 1
#define ARM2THUMB_GLUE_SIZE 12
d1663 5
d1787 4
a1790 1
  globals->arm_glue_size += ARM2THUMB_GLUE_SIZE;
d2363 25
a2387 2
      bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
		  s->contents + my_offset);
d2389 2
a2390 2
      bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
		  s->contents + my_offset + 4);
d2392 4
a2395 3
      /* It's a thumb address.  Add the low order bit.  */
      bfd_put_32 (output_bfd, val | a2t3_func_addr_insn,
		  s->contents + my_offset + 8);
@


1.29
log
@	* bfd/bfd-in.h (bfd_elf32_is_arm_mapping_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename call to
	bfd_elf32_is_arm_mapping_symbol_name.
	(elf32_arm_output_symbol_hook): Likewise.
	(arm_elf_find_function): Likewise, and include STT_NOTYPE in test for
	mapping symbols.
	(is_arm_mapping_symbol_name): Function moved from here...
	* bfd/cpu-arm.c (bfd_elf32_is_arm_mapping_symbol_name): ...to here,
	renamed and made global.
	* gas/config/tc-arm.c (mapping_state): Change documentation in function
	comment to cross-reference spec instead. Change type of mapping symbols
	to BSF_NO_TYPE.
	(arm_adjust_symtab): Don't change type of mapping symbols here.
	* gas/testsuite/gas/arm/mapping.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Likewise.
	* ld/testsuite/ld-arm/arm-app.d: Likewise.
	* ld/testsuite/ld-arm/mixed-app.d: Likewise.
@
text
@d4713 1
a4713 1
  return bfd_elf32_is_arm_mapping_symbol_name (sym->name);
d4751 1
a4751 1
	      && bfd_elf32_is_arm_mapping_symbol_name (q->symbol.name))
d6080 1
a6080 1
  if (! bfd_elf32_is_arm_mapping_symbol_name (name))
@


1.28
log
@bfd/
	* bfd-in2.h, libbfd.h: Regenerated.
	* reloc.c: Add ARM TLS relocations.
	* elf32-arm.c (elf32_arm_howto_table): Add dynamic TLS
	relocations.
	(elf32_arm_tls_gd32_howto, elf32_arm_tls_ldo32_howto)
	(elf32_arm_tls_ldm32_howto, elf32_arm_tls_le32_howto)
	(elf32_arm_tls_ie32_howto): New.
	(elf32_arm_howto_from_type): Support TLS relocations.
	(elf32_arm_reloc_map): Likewise.
	(elf32_arm_reloc_type_lookup): Likewise.
	(TCB_SIZE): Define.
	(struct elf32_arm_obj_tdata): New.
	(elf32_arm_tdata, elf32_arm_local_got_tls_type): Define.
	(elf32_arm_mkobject): New function.
	(struct elf32_arm_relocs_copied): Add pc_count.
	(elf32_arm_hash_entry, GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD)
	(GOT_TLS_IE): Define.
	(struct elf32_arm_link_hash_table): Add tls_ldm_got.
	(elf32_arm_link_hash_newfunc): Initialize tls_type.
	(elf32_arm_copy_indirect_symbol): Copy pc_count and tls_type.
	(elf32_arm_link_hash_table_create): Initialize tls_ldm_got.
	(dtpoff_base, tpoff): New functions.
	(elf32_arm_final_link_relocate): Handle TLS relocations.
	(IS_ARM_TLS_RELOC): Define.
	(elf32_arm_relocate_section): Warn about TLS mismatches.
	(elf32_arm_gc_sweep_hook): Handle TLS relocations and pc_count.
	(elf32_arm_check_relocs): Detect invalid symbol indexes.  Handle
	TLS relocations and pc_count.
	(elf32_arm_adjust_dynamic_symbol): Check non_got_ref.
	(allocate_dynrelocs): Handle TLS.  Bind REL32 relocs to local
	calls.
	(elf32_arm_size_dynamic_sections): Handle TLS.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define.
gas/
	* config/tc-arm.c (arm_parse_reloc): Add TLS relocations.
	(md_apply_fix3): Mark TLS symbols.
	(tc_gen_reloc): Handle TLS relocations.
	(arm_fix_adjustable): Ignore TLS relocations.
	(s_arm_elf_cons): Support expressions after decorated symbols.
gas/testuite/
	* gas/arm/tls.s, gas/arm/tls.d: New files.
	* gas/arm/arm.exp: Run TLS test.
include/elf/
	* arm.h: Add TLS relocations.
ld/testsuite/
	* ld-arm/tls-lib.s, ld-arm/tls-lib.d, ld-arm/tls-lib.r,
	ld-arm/tls-app.s, ld-arm/tls-app.d, ld-arm/tls-app.r: New files.
	* ld-arm/arm-lib.ld, ld-arm/arm-dyn.ld: Increase data segment
	alignment.
	* ld-arm/arm-elf.exp: Run TLS tests.
@
text
@a4707 9
static bfd_boolean
is_arm_mapping_symbol_name (const char * name)
{
  return (name != NULL)
    && (name[0] == '$')
    && ((name[1] == 'a') || (name[1] == 't') || (name[1] == 'd'))
    && (name[2] == 0);
}

d4713 1
a4713 1
  return is_arm_mapping_symbol_name (sym->name);
d4748 1
d4751 1
a4751 1
	      && is_arm_mapping_symbol_name (q->symbol.name))
a4753 1
	case STT_NOTYPE:
d6080 1
a6080 1
  if (! is_arm_mapping_symbol_name (name))
@


1.27
log
@	* elf32-arm.c (elf32_arm_check_relocs): Increment count for all
	relocation types.  Don't count relocations which will use a PLT.
@
text
@d297 1
a297 1
  /* These next three relocs are not defined, but we need to fill the space.  */
d299 13
a311 13
  HOWTO (R_ARM_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_unknown_17",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d313 13
a325 13
  HOWTO (R_ARM_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_unknown_18",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d327 13
a339 13
  HOWTO (R_ARM_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_unknown_19",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d666 75
d903 20
d977 10
a986 1
    {BFD_RELOC_ARM_TARGET2,	     R_ARM_TARGET2}
d1010 15
d1215 27
d1248 2
a1249 2
/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */
d1258 2
d1262 2
d1280 6
d1348 6
d1385 1
d1487 1
d1513 7
d1566 1
d2403 29
d3183 216
d3518 10
d3566 1
d3610 1
d3664 2
d3678 18
d4275 4
a4278 4
elf32_arm_gc_sweep_hook (bfd *                     abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *    info ATTRIBUTE_UNUSED,
			 asection *                sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
d4320 2
d4334 4
d4373 2
d4446 8
d4467 2
d4470 45
a4514 7
	    if (h != NULL)
	      {
		h->got.refcount++;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;
d4516 9
a4524 5
		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;
d4526 4
a4529 12
		    size = symtab_hdr->sh_info;
		    size *= (sizeof (bfd_signed_vma) + sizeof (char));
		    local_got_refcounts = bfd_zalloc (abfd, size);
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		  }
		local_got_refcounts[r_symndx] += 1;
	      }
	    if (r_type == R_ARM_GOT32)
	      break;
	    /* Fall through.  */
d4680 1
d4683 2
d4911 5
d5083 2
d5099 17
a5115 1
	  s->size += 4;
d5117 25
a5141 4
	  if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	       || h->root.type != bfd_link_hash_undefweak)
	      && (info->shared
		  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d5159 22
a5180 1
      /* Discard relocs on undefined weak syms with non-default
d5345 1
d5353 9
a5361 2
	      s->size += 4;
	      if (info->shared)
d5369 12
d5651 3
a5653 1
  if (h->got.offset != (bfd_vma) -1)
d6348 2
@


1.26
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Don't fail for
	unresolved symbols in R_ARM_NONE relocations.
@
text
@d4099 3
a4101 12
		&& ((r_type != R_ARM_PC24
		     && r_type != R_ARM_PLT32
#ifndef OLD_ARM_ABI
		     && r_type != R_ARM_CALL
		     && r_type != R_ARM_JUMP24
		     && r_type != R_ARM_PREL31
#endif
		     && r_type != R_ARM_REL32
		     && r_type != R_ARM_THM_PC22)
		    || (h != NULL
			&& (! info->symbolic
			    || !h->def_regular))))
d4181 1
a4181 3
		if (r_type == R_ARM_ABS32
		    || r_type == R_ARM_REL32)
		  p->count += 1;
@


1.26.2.1
log
@	Backport:
	2005-09-09  Richard Earnshaw  <richard.earnshaw@@arm.com>
	* bfd/elf32-arm.c (elf32_arm_section_from_shdr): Accept
	SHT_ARM_PREEMPTMAP and SHT_ARM_ATTRIBUTES.

	2005-09-09  Richard Earnshaw  <richard.earnshaw@@arm.com>
	* include/elf/arm.h (SHT_ARM_PREEMPTMAP, SHT_ARM_ATTRIBUTES): New
	defines.
@
text
@a5472 2
    case SHT_ARM_PREEMPTMAP:
    case SHT_ARM_ATTRIBUTES:
@


1.25
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Add
	UNRESOLVED_RELOC_P argument.  Set it appropriately.
	(elf32_arm_relocate_section): Update call to
	elf32_arm_final_link_relocate.  Don't clobber RELOCATION; use
	unresolved_reloc instead.
@
text
@d2314 3
@


1.24
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d2245 2
a2246 1
			       struct elf_link_hash_entry * h)
d2349 1
d2377 2
d2701 1
d2865 1
d2919 2
d3136 1
a3226 1
	  bfd_boolean unresolved_reloc;
a3231 60

	  if (unresolved_reloc || relocation != 0)
	    {
	      /* In these cases, we don't need the relocation value.
	         We check specially because in some obscure cases
	         sec->output_section will be NULL.  */
	      switch (r_type)
		{
	        case R_ARM_PC24:
#ifndef OLD_ARM_ABI
		case R_ARM_CALL:
		case R_ARM_JUMP24:
		case R_ARM_PREL31:
#endif
	        case R_ARM_ABS32:
		case R_ARM_THM_PC22:
	        case R_ARM_PLT32:

	          if (info->shared
	              && ((!info->symbolic && h->dynindx != -1)
	                  || !h->def_regular)
		      && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	              && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_ARM_ABS32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && h->def_dynamic))
		      )
	            relocation = 0;
		  break;

	        case R_ARM_GOTPC:
	          relocation = 0;
		  break;

	        case R_ARM_GOT32:
#ifndef OLD_ARM_ABI
		case R_ARM_GOT_PREL:
#endif
	          if ((WILL_CALL_FINISH_DYNAMIC_SYMBOL
		       (elf_hash_table (info)->dynamic_sections_created,
			info->shared, h))
		      && (!info->shared
	                  || (!info->symbolic && h->dynindx != -1)
	                  || !h->def_regular))
	            relocation = 0;
		  break;

	        default:
		  if (unresolved_reloc)
		    _bfd_error_handler
		      (_("%B(%A): warning: unresolvable relocation %d against symbol `%s'"),
		       input_bfd, input_section,
		       r_type,
		       h->root.root.string);
		  break;
		}
	    }
d3248 16
a3263 1
					  ELF_ST_TYPE (sym->st_info)), h);
@


1.23
log
@	* elf32-arm.c (elf32_arm_modify_segment_map): New function.
	(elf32_arm_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Define.
	(elf_backend_additional_program_headers): Likewise.
	(elf32_arm_symbian_modify_segment_map): Use
	elf32_arm_modify_segment_map.

	* binutils/readelf.c (get_arm_segment_type): New function.
	(get_segment_type): Use it.

	* arm.h (PT_ARM_EXIDX): Define.
@
text
@d5489 3
a5491 2
/* Handle an ARM specific section when reading an object file.
   This is called when elf.c finds a section with an unknown type.  */
d5496 2
a5497 1
			     const char *name)
d5513 1
a5513 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.22
log
@2005-02-11  Paul Brook  <paul@@codesourcery.com>

	* elf-bfd.h (struct elf_link_hash_table): Add
	is_relocatable_executable.
	* elf.c (_bfd_elf_link_hash_table_init): Initialize it.
	* elflink.c (bfd_elf_link_record_dynamic_symbol): Create local dynamic
	symbols in relocatable executables.
	(bfd_elf_record_link_assignment): Create dynamic section symbols in
	relocatable executables.
	(_bfd_elf_link_renumber_dynsyms): Ditto.
	(bfd_elf_final_link): Ditto.
	* elf32-arm.c (elf32_arm_final_link_relocate): Copy absolute
	relocations into relocatable executables.
	(elf32_arm_check_relocs): Crate dynamic sections for relocatable
	executables.  Also copy absolute relocations.
	(elf32_arm_adjust_dynamic_symbol): Don't create copy relocations
	in relocatable executables.
	(allocate_dynrelocs): Copy relocations for relocatable executables.
	Output dynamic symbols for symbols defined in linker scripts.
@
text
@d5713 49
d5832 3
d5969 1
a5969 2
				      struct bfd_link_info *info 
				        ATTRIBUTE_UNUSED)
d5986 2
a5987 1
  return TRUE;
@


1.22.2.1
log
@	* elf32-arm.c (elf32_arm_modify_segment_map): New function.
	(elf32_arm_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Define.
	(elf_backend_additional_program_headers): Likewise.
	(elf32_arm_symbian_modify_segment_map): Use
	elf32_arm_modify_segment_map.

	* binutils/readelf.c (get_arm_segment_type): New function.
	(get_segment_type): Use it.

	* arm.h (PT_ARM_EXIDX): Define.
@
text
@a5712 49
/* Add the PT_ARM_EXIDX program header.  */

static bfd_boolean
elf32_arm_modify_segment_map (bfd *abfd, 
			      struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map *m;
  asection *sec;

  sec = bfd_get_section_by_name (abfd, ".ARM.exidx");
  if (sec != NULL && (sec->flags & SEC_LOAD) != 0)
    {
      /* If there is already a PT_ARM_EXIDX header, then we do not
	 want to add another one.  This situation arises when running
	 "strip"; the input binary already has the header.  */
      m = elf_tdata (abfd)->segment_map;
      while (m && m->p_type != PT_ARM_EXIDX)
	m = m->next;
      if (!m)
	{
	  m = bfd_zalloc (abfd, sizeof (struct elf_segment_map));
	  if (m == NULL)
	    return FALSE;
	  m->p_type = PT_ARM_EXIDX;
	  m->count = 1;
	  m->sections[0] = sec;

	  m->next = elf_tdata (abfd)->segment_map;
	  elf_tdata (abfd)->segment_map = m;
	}
    }

  return TRUE;
}

/* We may add a PT_ARM_EXIDX program header.  */

static int
elf32_arm_additional_program_headers (bfd *abfd)
{
  asection *sec;

  sec = bfd_get_section_by_name (abfd, ".ARM.exidx");
  if (sec != NULL && (sec->flags & SEC_LOAD) != 0)
    return 1;
  else
    return 0;
}

a5782 3
#define elf_backend_modify_segment_map		elf32_arm_modify_segment_map
#define elf_backend_additional_program_headers \
  elf32_arm_additional_program_headers
d5917 2
a5918 1
				      struct bfd_link_info *info)
d5935 1
a5935 2
  /* Also call the generic arm routine.  */
  return elf32_arm_modify_segment_map (abfd, info);
@


1.22.2.2
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Add
	UNRESOLVED_RELOC_P argument.  Set it appropriately.
	(elf32_arm_relocate_section): Update call to
	elf32_arm_final_link_relocate.  Don't clobber RELOCATION; use
	unresolved_reloc instead.
@
text
@d2245 1
a2245 2
			       struct elf_link_hash_entry * h,
			       bfd_boolean *                unresolved_reloc_p)
a2347 1
	  *unresolved_reloc_p = FALSE;
a2374 2
	  *unresolved_reloc_p = FALSE;

a2696 1
	    *unresolved_reloc_p = FALSE;
a2859 1
      *unresolved_reloc_p = FALSE;
a2912 2
	  else
	    *unresolved_reloc_p = FALSE;
a3127 1
      bfd_boolean                  unresolved_reloc = FALSE;
d3218 1
d3224 60
d3300 1
a3300 16
					  ELF_ST_TYPE (sym->st_info)), h,
					 &unresolved_reloc);

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
          && !((input_section->flags & SEC_DEBUGGING) != 0
               && h->def_dynamic))
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): warning: unresolvable relocation %d against symbol `%s'"),
	     input_bfd, input_section, (long) rel->r_offset,
	     r_type, h->root.root.string);
	  return FALSE;
	}
@


1.22.2.3
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Don't fail for
	unresolved symbols in R_ARM_NONE relocations.
@
text
@a2313 3
      /* We don't need to find a value for this symbol.  It's just a
	 marker.  */
      *unresolved_reloc_p = FALSE;
@


1.22.2.4
log
@	* elf32-arm.c (elf32_arm_check_relocs): Increment count for all
	relocation types.  Don't count relocations which will use a PLT.
@
text
@d4099 12
a4110 3
		&& (r_type == R_ARM_ABS32
		    || (h != NULL && ! h->needs_plt
			&& (! info->symbolic || ! h->def_regular))))
d4190 3
a4192 1
		p->count += 1;
@


1.22.2.5
log
@2005-05-01  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Treat
	R_ARM_PLT32 the same as R_ARM_PC24.
	(arm_add_to_rel): Ditto.
@
text
@a1880 1
	    case R_ARM_PLT32:
d1901 1
a1901 1
	      abort ();
a3080 1
	case R_ARM_PLT32:
@


1.22.2.3.2.1
log
@	* elf32-arm.c (elf32_arm_check_relocs): Increment count for all
	relocation types.  Don't count relocations which will use a PLT.
@
text
@d4099 12
a4110 3
		&& (r_type == R_ARM_ABS32
		    || (h != NULL && ! h->needs_plt
			&& (! info->symbolic || ! h->def_regular))))
d4190 3
a4192 1
		p->count += 1;
@


1.22.2.3.2.2
log
@	* bfd/bfd-in2.h, libbfd.h: Regenerated.
	* bfd/reloc.c: Add ARM TLS relocations.
	* bfd/elf32-arm.c (elf32_arm_howto_table): Add dynamic TLS
	relocations.
	(elf32_arm_tls_gd32_howto, elf32_arm_tls_ldo32_howto)
	(elf32_arm_tls_ldm32_howto, elf32_arm_tls_le32_howto)
	(elf32_arm_tls_ie32_howto): New.
	(elf32_arm_howto_from_type): Support TLS relocations.
	(elf32_arm_reloc_map): Likewise.
	(elf32_arm_reloc_type_lookup): Likewise.
	(TCB_SIZE): Define.
	(struct elf32_arm_obj_tdata): New.
	(elf32_arm_tdata, elf32_arm_local_got_tls_type): Define.
	(elf32_arm_mkobject): New function.
	(struct elf32_arm_relocs_copied): Add pc_count.
	(elf32_arm_hash_entry, GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD)
	(GOT_TLS_IE): Define.
	(struct elf32_arm_link_hash_table): Add tls_ldm_got.
	(elf32_arm_link_hash_newfunc): Initialize tls_type.
	(elf32_arm_copy_indirect_symbol): Copy pc_count and tls_type.
	(elf32_arm_link_hash_table_create): Initialize tls_ldm_got.
	(dtpoff_base, tpoff): New functions.
	(elf32_arm_final_link_relocate): Handle TLS relocations.
	(IS_ARM_TLS_RELOC): Define.
	(elf32_arm_relocate_section): Warn about TLS mismatches.
	(elf32_arm_gc_sweep_hook): Handle TLS relocations and pc_count.
	(elf32_arm_check_relocs): Detect invalid symbol indexes.  Handle
	TLS relocations and pc_count.
	(elf32_arm_adjust_dynamic_symbol): Check non_got_ref.
	(allocate_dynrelocs): Handle TLS.  Bind REL32 relocs to local
	calls.
	(elf32_arm_size_dynamic_sections): Handle TLS.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define.

	* gas/config/tc-arm.c (arm_parse_reloc): Add TLS relocations.
	(md_apply_fix3): Mark TLS symbols.
	(tc_gen_reloc): Handle TLS relocations.
	(arm_fix_adjustable): Ignore TLS relocations.
	(s_arm_elf_cons): Support expressions after decorated symbols.

	* gas/testsuite/gas/arm/tls.s, gas/testsuite/gas/arm/tls.d: New files.
	* gas/testsuite/gas/arm/arm.exp: Run TLS test.

	* include/elf/arm.h: Add TLS relocations.

	* ld/testsuite/ld-arm/tls-lib.s, ld/testsuite/ld-arm/tls-lib.d,
	ld/testsuite/ld-arm/tls-lib.r, ld/testsuite/ld-arm/tls-app.s,
	ld/testsuite/ld-arm/tls-app.d, ld/testsuite/ld-arm/tls-app.r: New files.
	* ld/testsuite/ld-arm/arm-lib.ld, ld/testsuite/ld-arm/arm-dyn.ld:
	Increase data segment alignment.
	* ld/testsuite/ld-arm/arm-elf.exp: Run TLS tests.
@
text
@d297 1
a297 1
  /* Dynamic TLS relocations.  */
d299 13
a311 13
  HOWTO (R_ARM_TLS_DTPMOD32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_DTPMOD32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d313 13
a325 13
  HOWTO (R_ARM_TLS_DTPOFF32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_DTPOFF32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d327 13
a339 13
  HOWTO (R_ARM_TLS_TPOFF32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_TPOFF32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
a665 75
static reloc_howto_type elf32_arm_tls_gd32_howto = 
  HOWTO (R_ARM_TLS_GD32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         NULL,			/* special_function */
         "R_ARM_TLS_GD32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */

static reloc_howto_type elf32_arm_tls_ldo32_howto = 
  HOWTO (R_ARM_TLS_LDO32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LDO32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */

static reloc_howto_type elf32_arm_tls_ldm32_howto = 
  HOWTO (R_ARM_TLS_LDM32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LDM32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */

static reloc_howto_type elf32_arm_tls_le32_howto = 
  HOWTO (R_ARM_TLS_LE32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LE32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */

static reloc_howto_type elf32_arm_tls_ie32_howto = 
  HOWTO (R_ARM_TLS_IE32,	/* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         32,                    /* bitsize */
         FALSE,                  /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_bitfield,/* complain_on_overflow */
         NULL,			/* special_function */
         "R_ARM_TLS_IE32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE);                /* pcrel_offset */

a827 20
      
    case R_ARM_TLS_GD32:
      return &elf32_arm_tls_gd32_howto;
      break;

    case R_ARM_TLS_LDO32:
      return &elf32_arm_tls_ldo32_howto;
      break;

    case R_ARM_TLS_LDM32:
      return &elf32_arm_tls_ldm32_howto;
      break;

    case R_ARM_TLS_IE32:
      return &elf32_arm_tls_ie32_howto;
      break;

    case R_ARM_TLS_LE32:
      return &elf32_arm_tls_le32_howto;
      break;
d882 1
a882 10
    {BFD_RELOC_ARM_TARGET2,	     R_ARM_TARGET2},
    {BFD_RELOC_ARM_PLT32,            R_ARM_PLT32},
    {BFD_RELOC_ARM_TLS_GD32,	     R_ARM_TLS_GD32},
    {BFD_RELOC_ARM_TLS_LDO32,	     R_ARM_TLS_LDO32},
    {BFD_RELOC_ARM_TLS_LDM32,	     R_ARM_TLS_LDM32},
    {BFD_RELOC_ARM_TLS_DTPMOD32,     R_ARM_TLS_DTPMOD32},
    {BFD_RELOC_ARM_TLS_DTPOFF32,     R_ARM_TLS_DTPOFF32},
    {BFD_RELOC_ARM_TLS_TPOFF32,      R_ARM_TLS_TPOFF32},
    {BFD_RELOC_ARM_TLS_IE32,         R_ARM_TLS_IE32},
    {BFD_RELOC_ARM_TLS_LE32,         R_ARM_TLS_LE32},
a905 15
    case BFD_RELOC_ARM_TLS_GD32:
      return & elf32_arm_tls_gd32_howto;

    case BFD_RELOC_ARM_TLS_LDO32:
      return & elf32_arm_tls_ldo32_howto;

    case BFD_RELOC_ARM_TLS_LDM32:
      return & elf32_arm_tls_ldm32_howto;

    case BFD_RELOC_ARM_TLS_IE32:
      return & elf32_arm_tls_ie32_howto;

    case BFD_RELOC_ARM_TLS_LE32:
      return & elf32_arm_tls_le32_howto;

a1095 27
/* The size of the thread control block.  */
#define TCB_SIZE	8

struct elf32_arm_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
};

#define elf32_arm_tdata(abfd) \
  ((struct elf32_arm_obj_tdata *) (abfd)->tdata.any)

#define elf32_arm_local_got_tls_type(abfd) \
  (elf32_arm_tdata (abfd)->local_got_tls_type)

static bfd_boolean
elf32_arm_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct elf32_arm_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

d1102 2
a1103 2
/* This structure keeps track of the number of relocs we have copied
   for a given symbol.  */
a1111 2
    /* Number of PC-relative relocs copied in this section.  */
    bfd_size_type pc_count;
a1113 2
#define elf32_arm_hash_entry(ent) ((struct elf32_arm_link_hash_entry *)(ent))

a1129 6

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	4
    unsigned char tls_type;
a1191 6
    /* Data for R_ARM_TLS_LDM32 relocations.  */
    union {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } tls_ldm_got;
    
a1222 1
      ret->tls_type = GOT_UNKNOWN;
a1323 1
		    q->pc_count += p->pc_count;
a1348 7
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

a1394 1
  ret->tls_ldm_got.refcount = 0;
a2230 29
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);
  bfd_vma base;

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  base = align_power ((bfd_vma) TCB_SIZE, htab->tls_sec->alignment_power);
  return address - htab->tls_sec->vma + base;
}

a2981 216
    case R_ARM_TLS_LDO32:
      value = value - dtpoff_base (info);

      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value, (bfd_vma) 0);

    case R_ARM_TLS_LDM32:
      {
	bfd_vma off;

	if (globals->sgot == NULL)
	  abort ();

	off = globals->tls_ldm_got.offset;

	if ((off & 1) != 0)
	  off &= ~1;
	else
	  {
	    /* If we don't know the module number, create a relocation
	       for it.  */
	    if (info->shared)
	      {
		Elf_Internal_Rela outrel;
		bfd_byte *loc;

		if (globals->srelgot == NULL)
		  abort ();

		outrel.r_offset = (globals->sgot->output_section->vma
				   + globals->sgot->output_offset + off);
		outrel.r_info = ELF32_R_INFO (0, R_ARM_TLS_DTPMOD32);

		bfd_put_32 (output_bfd, 0, globals->sgot->contents + off);

		loc = globals->srelgot->contents;
		loc += globals->srelgot->reloc_count++ * sizeof (Elf32_External_Rel);
		bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
	      }
	    else
	      bfd_put_32 (output_bfd, 1, globals->sgot->contents + off);

	    globals->tls_ldm_got.offset |= 1;
	  }

	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off 
	  - (input_section->output_section->vma + input_section->output_offset + rel->r_offset);

	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 (bfd_vma) 0);
      }

    case R_ARM_TLS_GD32:
    case R_ARM_TLS_IE32:
      {
	bfd_vma off;
	int indx;
	char tls_type;

	if (globals->sgot == NULL)
	  abort ();

	indx = 0;
	if (h != NULL)
	  {
	    bfd_boolean dyn;
	    dyn = globals->root.dynamic_sections_created;
	    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		&& (!info->shared
		    || !SYMBOL_REFERENCES_LOCAL (info, h)))
	      {
		*unresolved_reloc_p = FALSE;
		indx = h->dynindx;
	      }
	    off = h->got.offset;
	    tls_type = ((struct elf32_arm_link_hash_entry *) h)->tls_type;
	  }
	else
	  {
	    if (local_got_offsets == NULL)
	      abort ();
	    off = local_got_offsets[r_symndx];
	    tls_type = elf32_arm_local_got_tls_type (input_bfd)[r_symndx];
	  }

	if (tls_type == GOT_UNKNOWN)
	  abort ();

	if ((off & 1) != 0)
	  off &= ~1;
	else
	  {
	    bfd_boolean need_relocs = FALSE;
	    Elf_Internal_Rela outrel;
	    bfd_byte *loc = NULL;
	    int cur_off = off;

	    /* The GOT entries have not been initialized yet.  Do it
	       now, and emit any relocations.  If both an IE GOT and a
	       GD GOT are necessary, we emit the GD first.  */

	    if ((info->shared || indx != 0)
		&& (h == NULL
		    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		    || h->root.type != bfd_link_hash_undefweak))
	      {
		need_relocs = TRUE;
		if (globals->srelgot == NULL)
		  abort ();
		loc = globals->srelgot->contents;
		loc += globals->srelgot->reloc_count * sizeof (Elf32_External_Rel);
	      }

	    if (tls_type & GOT_TLS_GD)
	      {
		if (need_relocs)
		  {
		    outrel.r_offset = (globals->sgot->output_section->vma
				       + globals->sgot->output_offset + cur_off);
		    outrel.r_info = ELF32_R_INFO (indx, R_ARM_TLS_DTPMOD32);
		    bfd_put_32 (output_bfd, 0, globals->sgot->contents + cur_off);

		    bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
		    globals->srelgot->reloc_count++;
		    loc += sizeof (Elf32_External_Rel);

		    if (indx == 0)
		      bfd_put_32 (output_bfd, value - dtpoff_base (info),
				  globals->sgot->contents + cur_off + 4);
		    else
		      {
			bfd_put_32 (output_bfd, 0,
				    globals->sgot->contents + cur_off + 4);

			outrel.r_info = ELF32_R_INFO (indx,
						      R_ARM_TLS_DTPOFF32);
			outrel.r_offset += 4;
			bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
			globals->srelgot->reloc_count++;
			loc += sizeof (Elf32_External_Rel);
		      }
		  }
		else
		  {
		    /* If we are not emitting relocations for a
		       general dynamic reference, then we must be in a
		       static link or an executable link with the
		       symbol binding locally.  Mark it as belonging
		       to module 1, the executable.  */
		    bfd_put_32 (output_bfd, 1,
				globals->sgot->contents + cur_off);
		    bfd_put_32 (output_bfd, value - dtpoff_base (info),
				globals->sgot->contents + cur_off + 4);
		  }

		cur_off += 8;
	      }

	    if (tls_type & GOT_TLS_IE)
	      {
		if (need_relocs)
		  {
		    outrel.r_offset = (globals->sgot->output_section->vma
				       + globals->sgot->output_offset
				       + cur_off);
		    outrel.r_info = ELF32_R_INFO (indx, R_ARM_TLS_TPOFF32);

		    if (indx == 0)
		      bfd_put_32 (output_bfd, value - dtpoff_base (info),
				  globals->sgot->contents + cur_off);
		    else
		      bfd_put_32 (output_bfd, 0,
				  globals->sgot->contents + cur_off);

		    bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
		    globals->srelgot->reloc_count++;
		    loc += sizeof (Elf32_External_Rel);
		  }
		else
		  bfd_put_32 (output_bfd, tpoff (info, value),
			      globals->sgot->contents + cur_off);
		cur_off += 4;
	      }

	    if (h != NULL)
	      h->got.offset |= 1;
	    else
	      local_got_offsets[r_symndx] |= 1;
	  }

	if ((tls_type & GOT_TLS_GD) && r_type != R_ARM_TLS_GD32)
	  off += 8;
	value = globals->sgot->output_section->vma + globals->sgot->output_offset + off 
	  - (input_section->output_section->vma + input_section->output_offset + rel->r_offset);

	return _bfd_final_link_relocate (howto, input_bfd, input_section,
					 contents, rel->r_offset, value,
					 (bfd_vma) 0);
      }

    case R_ARM_TLS_LE32:
      if (info->shared)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): R_ARM_TLS_LE32 relocation not permitted in shared object"),
	     input_bfd, input_section,
	     (long) rel->r_offset, howto->name);
	  return FALSE;	  
	}
      else
	value = tpoff (info, value);
      
      return _bfd_final_link_relocate (howto, input_bfd, input_section,
				       contents, rel->r_offset, value, (bfd_vma) 0);

a3100 10
#define IS_ARM_TLS_RELOC(R_TYPE)	\
  ((R_TYPE) == R_ARM_TLS_GD32		\
   || (R_TYPE) == R_ARM_TLS_LDO32	\
   || (R_TYPE) == R_ARM_TLS_LDM32	\
   || (R_TYPE) == R_ARM_TLS_DTPOFF32	\
   || (R_TYPE) == R_ARM_TLS_DTPMOD32	\
   || (R_TYPE) == R_ARM_TLS_TPOFF32	\
   || (R_TYPE) == R_ARM_TLS_LE32	\
   || (R_TYPE) == R_ARM_TLS_IE32)

a3138 1
      char                         sym_type;
a3181 1
	  sym_type = ELF32_ST_TYPE (sym->st_info);
a3234 2

	  sym_type = h->type;
a3246 18
      if (r_symndx != 0
	  && r_type != R_ARM_NONE
	  && (h == NULL
	      || h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && IS_ARM_TLS_RELOC (r_type) != (sym_type == STT_TLS))
	{
	  (*_bfd_error_handler)
	    ((sym_type == STT_TLS
	      ? _("%B(%A+0x%lx): %s used with TLS symbol %s")
	      : _("%B(%A+0x%lx): %s used with non-TLS symbol %s")),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     name);
	}

d3826 4
a3829 4
elf32_arm_gc_sweep_hook (bfd *                     abfd,
			 struct bfd_link_info *    info,
			 asection *                sec,
			 const Elf_Internal_Rela * relocs)
a3870 2
	case R_ARM_TLS_GD32:
	case R_ARM_TLS_IE32:
a3882 4
	case R_ARM_TLS_LDM32:
	  elf32_arm_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

a3917 2
		      if (ELF32_R_TYPE (rel->r_info) == R_ARM_REL32)
			p->pc_count -= 1;
a3988 8

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"), abfd,
				 r_symndx);
	  return FALSE;
	}

a4001 2
	  case R_ARM_TLS_GD32:
	  case R_ARM_TLS_IE32:
d4003 7
a4009 2
	    {
	      int tls_type, old_tls_type;
d4011 5
a4015 6
	      switch (r_type)
		{
		case R_ARM_TLS_GD32: tls_type = GOT_TLS_GD; break;
		case R_ARM_TLS_IE32: tls_type = GOT_TLS_IE; break;
		default: tls_type = GOT_NORMAL; break;
		}
d4017 12
a4028 50
	      if (h != NULL)
		{
		  h->got.refcount++;
		  old_tls_type = elf32_arm_hash_entry (h)->tls_type;
		}
	      else
		{
		  bfd_signed_vma *local_got_refcounts;

		  /* This is a global offset table entry for a local symbol.  */
		  local_got_refcounts = elf_local_got_refcounts (abfd);
		  if (local_got_refcounts == NULL)
		    {
		      bfd_size_type size;
		      
		      size = symtab_hdr->sh_info;
		      size *= (sizeof (bfd_signed_vma) + sizeof(char));
		      local_got_refcounts = bfd_zalloc (abfd, size);
		      if (local_got_refcounts == NULL)
			return FALSE;
		      elf_local_got_refcounts (abfd) = local_got_refcounts;
		      elf32_arm_local_got_tls_type (abfd)
			= (char *) (local_got_refcounts + symtab_hdr->sh_info);
		    }
		  local_got_refcounts[r_symndx] += 1;
		  old_tls_type = elf32_arm_local_got_tls_type (abfd) [r_symndx];
		}

	      /* We will already have issued an error message if there is a
		 TLS / non-TLS mismatch, based on the symbol type.  We don't
		 support any linker relaxations.  So just combine any TLS
		 types needed.  */
	      if (old_tls_type != GOT_UNKNOWN && old_tls_type != GOT_NORMAL
		  && tls_type != GOT_NORMAL)
		tls_type |= old_tls_type;

	      if (old_tls_type != tls_type)
		{
		  if (h != NULL)
		    elf32_arm_hash_entry (h)->tls_type = tls_type;
		  else
		    elf32_arm_local_got_tls_type (abfd) [r_symndx] = tls_type;
		}
	    }
	    /* Fall through */

	  case R_ARM_TLS_LDM32:
	    if (r_type == R_ARM_TLS_LDM32)
		htab->tls_ldm_got.refcount++;
	    /* Fall through */
a4178 1
		    p->pc_count = 0;
a4180 2
		if (r_type == R_ARM_REL32)
		  p->pc_count += 1;
a4406 5
  /* If there are no non-GOT references, we do not need a copy
     relocation.  */
  if (!h->non_got_ref)
    return TRUE;

a4573 2
      int tls_type = elf32_arm_hash_entry (h)->tls_type;
      int indx;
d4588 1
a4588 17

	  if (tls_type == GOT_UNKNOWN)
	    abort ();

	  if (tls_type == GOT_NORMAL)
	    /* Non-TLS symbols need one GOT slot.  */
	    s->size += 4;
	  else
	    {
	      if (tls_type & GOT_TLS_GD)
		/* R_ARM_TLS_GD32 needs 2 consecutive GOT slots.  */
		s->size += 8;
	      if (tls_type & GOT_TLS_IE)
		/* R_ARM_TLS_IE32 needs one GOT slot.  */
		s->size += 4;
	    }

d4590 4
a4593 25

	  indx = 0;
	  if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
	      && (!info->shared
		  || !SYMBOL_REFERENCES_LOCAL (info, h)))
	    indx = h->dynindx;

	  if (tls_type != GOT_NORMAL
	      && (info->shared || indx != 0)
	      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  || h->root.type != bfd_link_hash_undefweak))
	    {
	      if (tls_type & GOT_TLS_IE)
		htab->srelgot->size += sizeof (Elf32_External_Rel);

	      if (tls_type & GOT_TLS_GD)
		htab->srelgot->size += sizeof (Elf32_External_Rel);

	      if ((tls_type & GOT_TLS_GD) && indx != 0)
		htab->srelgot->size += sizeof (Elf32_External_Rel);
	    }
	  else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		    || h->root.type != bfd_link_hash_undefweak)
		   && (info->shared
	    	   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d4611 1
a4611 22
      /* The only reloc that uses pc_count is R_ARM_REL32, which will
	 appear on something like ".long foo - .".  We want calls to
	 protected symbols to resolve directly to the function rather
	 than going via the plt.  If people want function pointer
	 comparisons to work as expected then they should avoid
	 writing assembly like ".long foo - .".  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf32_arm_relocs_copied **pp;

	  for (pp = &eh->relocs_copied; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
a4775 1
      local_tls_type = elf32_arm_local_got_tls_type (ibfd);
d4783 2
a4784 9
	      if (*local_tls_type & GOT_TLS_GD)
		/* TLS_GD relocs need an 8-byte structure in the GOT.  */
		s->size += 8;
	      if (*local_tls_type & GOT_TLS_IE)
		s->size += 4;
	      if (*local_tls_type == GOT_NORMAL)
		s->size += 4;

	      if (info->shared || *local_tls_type == GOT_TLS_GD)
a4791 12
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate two GOT entries and one dynamic relocation (if necessary)
	 for R_ARM_TLS_LDM32 relocations.  */
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 8;
      if (info->shared)
	htab->srelgot->size += sizeof (Elf32_External_Rel);
    }
  else
    htab->tls_ldm_got.offset = -1;

d5062 1
a5062 3
  if (h->got.offset != (bfd_vma) -1
      && (elf32_arm_hash_entry (h)->tls_type & GOT_TLS_GD) == 0
      && (elf32_arm_hash_entry (h)->tls_type & GOT_TLS_IE) == 0)
a5754 2
#define bfd_elf32_mkobject		        elf32_arm_mkobject

@


1.22.2.3.2.3
log
@2005-03-29  Julian Brown  <julian@@codesourcery.com>

	* elf32-arm.c (elf32_arm_final_link_relocate): Use blx to get to
	symbian plt entries from thumb mode.
@
text
@a2853 1
	bfd_boolean thumb_plt_call = FALSE;
d2903 2
a2904 14
 	    if (globals->symbian_p)
 	      {
 		/* On SymbianOS, we are guaranteed to be using at least ARMv5t.
 		   Convert the BL to a BLX instruction to call the ARM-mode PLT
 		   entry.  */
 		if ((lower_insn & (0x3 << 11)) == 0x3 << 11)
		  {
		    lower_insn = (lower_insn & ~(0x3 << 11)) | 0x1 << 11;
		    thumb_plt_call = TRUE;
		  }
 	      }
 	    else
 	      /* Target the Thumb stub before the ARM PLT entry.  */
 	      value -= PLT_THUMB_STUB_SIZE;
d2928 2
a2929 3
	if ((r_type == R_ARM_THM_XPC22
	     && ((lower_insn & 0x1800) == 0x0800))
	    || thumb_plt_call)
@


1.22.2.3.2.4
log
@	* bfd/bfd-in.h (bfd_is_arm_mapping_symbol_name): Add prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_is_target_special_symbol): Rename call to
	bfd_is_arm_mapping_symbol_name.
	(elf32_arm_output_symbol_hook): Likewise.
	(arm_elf_find_function): Likewise, and include STT_NOTYPE in test for
	mapping symbols.
	(is_arm_mapping_symbol_name): Function moved from here...
	* bfd/cpu-arm.c (bfd_is_arm_mapping_symbol_name): ...to here,
	renamed and made global.
	* gas/config/tc-arm.c (mapping_state): Change documentation in
	function comment to cross-reference spec instead. Change type of
	mapping symbols to BSF_NO_TYPE.
	(arm_adjust_symtab): Don't change type of mapping symbols here.
	* gas/testsuite/gas/arm/mapping.d: Update expected output.
	* ld/testsuite/ld-arm/arm-app-abs32.d: Likewise.
	* ld/testsuite/ld-arm/arm-app.d: Likewise.
	* ld/testsuite/ld-arm/mixed-app.d: Likewise.
@
text
@d4722 9
d4736 1
a4736 1
  return bfd_is_arm_mapping_symbol_name (sym->name);
a4770 1
	case STT_NOTYPE:
d4773 1
a4773 1
	      && bfd_is_arm_mapping_symbol_name (q->symbol.name))
d4776 1
d6101 1
a6101 1
  if (! bfd_is_arm_mapping_symbol_name (name))
@


1.22.2.3.2.5
log
@2005-04-08  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (ARM2THUMB_GLUE_SIZE): Rename...
	(ARM2THUMB_STATIC_GLUE_SIZE): ... to this.
	(ARM2THUMB_PIC_GLUE_SIZE): Define.
	(a2t1p_ldr_insn, a2t2p_add_pc_insn, a2t3p_bx_r12_insn): Add.
	(elf32_arm_to_thumb_stub): Create PIC stubs.
	(record_arm_to_thumb_glue): Use different stub size for relocatable
	images.
@
text
@d1639 1
a1639 1
/* ARM->Thumb glue (static images):
d1646 1
a1646 1
   .word func    @@ behave as if you saw a ARM_32 reloc.  
d1648 1
a1648 11
   (relocatable images)
   .arm
   __func_from_arm:
   ldr r12, __func_offset
   add r12, r12, pc
   bx  r12
   __func_offset:
   .word func - .
   */

#define ARM2THUMB_STATIC_GLUE_SIZE 12
a1652 5
#define ARM2THUMB_PIC_GLUE_SIZE 16
static const insn32 a2t1p_ldr_insn = 0xe59fc004;
static const insn32 a2t2p_add_pc_insn = 0xe08cc00f;
static const insn32 a2t3p_bx_r12_insn = 0xe12fff1c;

d1772 1
a1772 4
  if ((link_info->shared || globals->root.is_relocatable_executable))
    globals->arm_glue_size += ARM2THUMB_PIC_GLUE_SIZE;
  else
    globals->arm_glue_size += ARM2THUMB_STATIC_GLUE_SIZE;
d2345 2
a2346 25
      if ((info->shared || globals->root.is_relocatable_executable))
	{
	  /* For relocatable objects we can't use absolute addresses,
	     so construct the address from a relative offset.  */
	  /* TODO: If the offset is small it's probably worth
	     constructing the address with adds.  */
	  bfd_put_32 (output_bfd, (bfd_vma) a2t1p_ldr_insn,
		      s->contents + my_offset);
	  bfd_put_32 (output_bfd, (bfd_vma) a2t2p_add_pc_insn,
		      s->contents + my_offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) a2t3p_bx_r12_insn,
		      s->contents + my_offset + 8);
	  /* Adjust the offset by 4 for the position of the add,
	     and 8 for the pipeline offset.  */
	  ret_offset = (val - (s->output_offset
			       + s->output_section->vma
			       + my_offset + 12))
		       | 1;
	  bfd_put_32 (output_bfd, ret_offset,
		      s->contents + my_offset + 12);
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) a2t1_ldr_insn,
		      s->contents + my_offset);
d2348 2
a2349 2
	  bfd_put_32 (output_bfd, (bfd_vma) a2t2_bx_r12_insn,
		      s->contents + my_offset + 4);
d2351 3
a2353 4
	  /* It's a thumb address.  Add the low order bit.  */
	  bfd_put_32 (output_bfd, val | a2t3_func_addr_insn,
		      s->contents + my_offset + 8);
	}
@


1.22.2.3.2.6
log
@	Thumb32 assembler.

	* include/elf/arm.h: Import full set of relocation names from
	latest AAELF.  Make the primary name of all relocations be the one
	AAELF specifies.  Provide aliases under the traditional names.
	Kill FIRST_INVALID_RELOC_* and LAST_INVALID_RELOC_*.
	* bfd/reloc.c: Reorganize ARM relocations.  Remove ARM relocations
	that are never generated.  Document more of the relocations.  Add
	relocations for Thumb32.
	* bfd/libbfd.h, bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c: Reorganize howto tables.  Implement Thumb32
	relocations.
	* ld/testsuite/ld-arm/mixed-app.d: Adjust expectations for
	renamed relocations.

	* gas/hash.c (hash_find_n): New interface.
	* gas/hash.h: Prototype it.

	* gas/config/tc-arm.c: Rewrite and reorganize.  Implement 32-bit
	Thumb instructions.
	* gas/testsuite/gas/arm: Convert all "gas_test" style tests to
	"run_dump_test" style tests, for more thorough testing.  Make
	adjustments to expectations where necessary.
	* gas/testsuite/gas/arm/t16-bad.s, gas/testsuite/gas/arm/tcompat.s
	* gas/testsuite/gas/arm/tcompat2.s, gas/testsuite/gas/arm/thumb32.s:
	New test cases.

	* opcodes/arm-dis.c: Add support for Thumb32 instructions and
	16-bit V6T2 instructions.
@
text
@d48 1
a48 1
static reloc_howto_type elf32_arm_howto_table_1[] =
d109 1
a109 1
  /* 8 bit absolute - R_ARM_LDR_PC_G0 in AAELF */
d197 1
a197 2
  /* FIXME: Has two more bits of offset in Thumb32.  */
  HOWTO (R_ARM_THM_CALL,	/* type */
d205 1
a205 1
	 "R_ARM_THM_CALL",	/* name */
d225 1
a225 1
  HOWTO (R_ARM_BREL_ADJ,	/* type */
d228 2
a229 2
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d233 1
a233 1
	 "R_ARM_BREL_ADJ",	/* name */
d235 3
a237 3
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d399 1
a399 1
  HOWTO (R_ARM_GOTOFF32,	/* type */
d407 1
a407 1
         "R_ARM_GOTOFF32",	/* name */
d483 5
a487 5
  HOWTO (R_ARM_THM_JUMP24,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
d489 1
a489 1
	 complain_overflow_signed,/* complain_on_overflow */
d491 1
a491 1
	 "R_ARM_THM_JUMP24",	/* name */
d493 3
a495 3
	 0x07ff2fff,		/* src_mask */
	 0x07ff2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
d497 1
a497 1
  HOWTO (R_ARM_BASE_ABS,	/* type */
d499 2
a500 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d505 1
a505 1
	 "R_ARM_BASE_ABS",	/* name */
d507 2
a508 2
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
a663 199

  HOWTO (R_ARM_MOVW_ABS_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_ABS_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVT_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVW_PREL_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_PREL_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_MOVT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_ABS_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_ABS_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_PREL_NC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_PREL_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP19,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 19,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_ARM_THM_JUMP19",	/* name */
	 FALSE,			/* partial_inplace */
	 0x043f2fff,		/* src_mask */
	 0x043f2fff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP6,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP6",	/* name */
	 FALSE,			/* partial_inplace */
	 0x02f8,		/* src_mask */
	 0x02f8,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* These are declared as 13-bit signed relocations because we can
     address -4095 .. 4095(base) by altering ADDW to SUBW or vice
     versa.  */
  HOWTO (R_ARM_THM_ALU_PREL_11_0,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_ALU_PREL_11_0",/* name */
	 FALSE,			/* partial_inplace */
	 0x040070ff,		/* src_mask */
	 0x040070ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_PC12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_PC12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040070ff,		/* src_mask */
	 0x040070ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_ABS32_NOI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_ABS32_NOI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_REL32_NOI,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_REL32_NOI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d666 2
a667 168
/* Relocations 57 .. 83 are the "group relocations" which we do not
   support.  */

static reloc_howto_type elf32_arm_howto_table_2[] =
{
  HOWTO (R_ARM_MOVW_BREL_NC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_BREL_NC",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVT_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVT_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_MOVW_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_MOVW_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_BREL_NC,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_BREL_NC",/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVT_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVT_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_THM_MOVW_BREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_MOVW_BREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x040f70ff,		/* src_mask */
	 0x040f70ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (90),   /* unallocated */
  EMPTY_HOWTO (91),
  EMPTY_HOWTO (92),
  EMPTY_HOWTO (93),

  HOWTO (R_ARM_PLT32_ABS,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_PLT32_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_GOT_ABS,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_ABS",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),			/* pcrel_offset */

  HOWTO (R_ARM_GOT_PREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_PREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_GOT_BREL12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOT_BREL12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_ARM_GOTOFF12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_GOTOFF12",	/* name */
	 FALSE,			/* partial_inplace */
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (R_ARM_GOTRELAX),  /* reserved for future GOT-load optimizations */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_ARM_GNU_VTENTRY,     /* type */
d670 1
a670 1
         0,                     /* bitsize */
d673 7
a679 7
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_ARM_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */
d681 2
a682 45
  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_ARM_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_ARM_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP11,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP11",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000007ff,		/* src_mask */
	 0x000007ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_ARM_THM_JUMP8,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_ARM_THM_JUMP8",	/* name */
	 FALSE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* TLS relocations */
  HOWTO (R_ARM_TLS_GD32,	/* type */
d689 2
a690 2
         NULL,			/* special_function */
         "R_ARM_TLS_GD32",	/* name */
d694 1
a694 1
         FALSE),                /* pcrel_offset */
d696 1
d709 1
a709 1
         FALSE),                /* pcrel_offset */
d711 2
a712 1
  HOWTO (R_ARM_TLS_LDO32,	/* type */
d720 1
a720 1
         "R_ARM_TLS_LDO32",	/* name */
d724 1
a724 1
         FALSE),                /* pcrel_offset */
d726 1
d739 17
a755 1
         FALSE),                /* pcrel_offset */
d757 3
a759 1
  HOWTO (R_ARM_TLS_LE32,	/* type */
d762 1
a762 1
         32,                    /* bitsize */
d765 7
a771 7
         complain_overflow_bitfield,/* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_ARM_TLS_LE32",	/* name */
         TRUE,			/* partial_inplace */
         0xffffffff,		/* src_mask */
         0xffffffff,		/* dst_mask */
         FALSE),                /* pcrel_offset */
d773 7
a779 5
  HOWTO (R_ARM_TLS_LDO12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
d781 1
a781 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d783 1
a783 1
	 "R_ARM_TLS_LDO12",	/* name */
d785 3
a787 3
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d789 7
a795 5
  HOWTO (R_ARM_TLS_LE12,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
d797 1
a797 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d799 1
a799 1
	 "R_ARM_TLS_LE12",	/* name */
d801 3
a803 3
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d805 3
a807 1
  HOWTO (R_ARM_TLS_IE12GP,	/* type */
d810 2
a811 2
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
d813 1
a813 1
	 complain_overflow_bitfield,/* complain_on_overflow */
d815 1
a815 1
	 "R_ARM_TLS_IE12GP",	/* name */
d817 3
a819 4
	 0x00000fff,		/* src_mask */
	 0x00000fff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};
d821 2
a822 7
/* 112-127 private relocations
   128 R_ARM_ME_TOO, obsolete
   129-255 unallocated in AAELF.

   249-255 extended, currently unused, relocations:  */

static reloc_howto_type elf32_arm_howto_table_3[4] =
d884 10
a893 2
  if (r_type < NUM_ELEM (elf32_arm_howto_table_1))
    return &elf32_arm_howto_table_1[r_type];
d895 28
a922 7
  if (r_type >= R_ARM_MOVW_BREL_NC
      && r_type < R_ARM_MOVW_BREL_NC + NUM_ELEM (elf32_arm_howto_table_2))
    return &elf32_arm_howto_table_2[r_type - R_ARM_MOVW_BREL_NC];

  if (r_type >= R_ARM_RREL32
      && r_type < R_ARM_RREL32 + NUM_ELEM (elf32_arm_howto_table_2))
    return &elf32_arm_howto_table_3[r_type - R_ARM_RREL32];
d924 9
a932 1
  return NULL;
d964 2
a965 6
    {BFD_RELOC_THUMB_PCREL_BRANCH25, R_ARM_THM_JUMP24},
    {BFD_RELOC_THUMB_PCREL_BRANCH23, R_ARM_THM_CALL},
    {BFD_RELOC_THUMB_PCREL_BRANCH12, R_ARM_THM_JUMP11},
    {BFD_RELOC_THUMB_PCREL_BRANCH20, R_ARM_THM_JUMP19},
    {BFD_RELOC_THUMB_PCREL_BRANCH9,  R_ARM_THM_JUMP8},
    {BFD_RELOC_THUMB_PCREL_BRANCH7,  R_ARM_THM_JUMP6},
d969 1
a969 1
    {BFD_RELOC_ARM_GOTOFF,           R_ARM_GOTOFF32},
a986 2
    {BFD_RELOC_VTABLE_INHERIT,	     R_ARM_GNU_VTINHERIT},
    {BFD_RELOC_VTABLE_ENTRY,	     R_ARM_GNU_VTENTRY},
a994 3
  for (i = 0; i < NUM_ELEM (elf32_arm_reloc_map); i ++)
    if (elf32_arm_reloc_map[i].bfd_reloc_val == code)
      return elf32_arm_howto_from_type (elf32_arm_reloc_map[i].elf_reloc_val);
d996 36
a1031 1
  return NULL;
d2029 1
a2029 1
	      && r_type != R_ARM_THM_CALL)
d2082 1
a2082 1
	    case R_ARM_THM_CALL:
d2885 1
a2885 1
    case R_ARM_THM_CALL:
d3004 2
a3005 147
    case R_ARM_THM_JUMP24:
      /* Thumb32 unconditional branch instruction.  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
	bfd_signed_vma signed_check;

	/* Need to refetch the addend, reconstruct the top three bits, and glue the
	   two pieces together.  */
	if (globals->use_rel)
	  {
	    bfd_vma S  = (upper_insn & 0x0400) >> 10;
	    bfd_vma hi = (upper_insn & 0x03ff);
	    bfd_vma I1 = (lower_insn & 0x2000) >> 13;
	    bfd_vma I2 = (lower_insn & 0x0800) >> 11;
	    bfd_vma lo = (lower_insn & 0x07ff);

	    I1 = !(I1 ^ S);
	    I2 = !(I2 ^ S);
	    S  = !S;

	    signed_addend = (S << 24) | (I1 << 23) | (I2 << 22) | (hi << 12) | (lo << 1);
	    signed_addend -= (1 << 24); /* Sign extend.  */
	  }

	/* ??? Should handle interworking?  GCC might someday try to
	   use this for tail calls.  */

      	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

	/* Put RELOCATION back into the insn.  */
	{
	  bfd_vma S  = (relocation & 0x01000000) >> 24;
	  bfd_vma I1 = (relocation & 0x00800000) >> 23;
	  bfd_vma I2 = (relocation & 0x00400000) >> 22;
	  bfd_vma hi = (relocation & 0x003ff000) >> 12;
	  bfd_vma lo = (relocation & 0x00000ffe) >>  1;

	  I1 = !(I1 ^ S);
	  I2 = !(I2 ^ S);

	  upper_insn = (upper_insn & (bfd_vma) 0xf800) | (S << 10) | hi;
	  lower_insn = (lower_insn & (bfd_vma) 0xd000) | (I1 << 13) | (I2 << 11) | lo;
	}

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }

    case R_ARM_THM_JUMP19:
      /* Thumb32 conditional branch instruction.  */
      {
	bfd_vma relocation;
	bfd_boolean overflow = FALSE;
	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
	bfd_signed_vma reloc_signed_max = ((1 << (howto->bitsize - 1)) - 1) >> howto->rightshift;
	bfd_signed_vma reloc_signed_min = ~ reloc_signed_max;
	bfd_vma check;
	bfd_signed_vma signed_check;

	/* Need to refetch the addend, reconstruct the top three bits,
	   and squish the two 11 bit pieces together.  */
	if (globals->use_rel)
	  {
	    bfd_vma S     = (upper_insn & 0x0400) >> 10;
	    bfd_vma upper = (upper_insn & 0x001f);
	    bfd_vma J1    = (lower_insn & 0x2000) >> 13;
	    bfd_vma J2    = (lower_insn & 0x0800) >> 11;
	    bfd_vma lower = (lower_insn & 0x07ff);

	    upper |= J2 << 6;
	    upper |= J1 << 7;
	    upper |= ~S << 8;
	    upper -= 0x0100; /* Sign extend.  */

	    addend = (upper << 12) | (lower << 1);
	    signed_addend = addend;
	  }

	/* ??? Should handle interworking?  GCC might someday try to
	   use this for tail calls.  */

      	relocation = value + signed_addend;
	relocation -= (input_section->output_section->vma
		       + input_section->output_offset
		       + rel->r_offset);

	check = relocation >> howto->rightshift;

	/* If this is a signed value, the rightshift just dropped
	   leading 1 bits (assuming twos complement).  */
	if ((bfd_signed_vma) relocation >= 0)
	  signed_check = check;
	else
	  signed_check = check | ~((bfd_vma) -1 >> howto->rightshift);

	/* Assumes two's complement.  */
	if (signed_check > reloc_signed_max || signed_check < reloc_signed_min)
	  overflow = TRUE;

	/* Put RELOCATION back into the insn.  */
	{
	  bfd_vma S  = (relocation & 0x00100000) >> 20;
	  bfd_vma J2 = (relocation & 0x00080000) >> 19;
	  bfd_vma J1 = (relocation & 0x00040000) >> 18;
	  bfd_vma hi = (relocation & 0x0003f000) >> 12;
	  bfd_vma lo = (relocation & 0x00000ffe) >>  1;

	  upper_insn = (upper_insn & 0xfb30) | (S << 10) | hi;
	  lower_insn = (lower_insn & 0xd000) | (J1 << 13) | (J2 << 11) | lo;
	}

	/* Put the relocated value back in the object file:  */
	bfd_put_16 (input_bfd, upper_insn, hit_data);
	bfd_put_16 (input_bfd, lower_insn, hit_data + 2);

	return (overflow ? bfd_reloc_overflow : bfd_reloc_ok);
      }

    case R_ARM_THM_JUMP11:
    case R_ARM_THM_JUMP8:
    case R_ARM_THM_JUMP6:
a3012 4
	/* CZB cannot jump backward.  */
	if (r_type == R_ARM_THM_JUMP6)
	  reloc_signed_min = 0;

d3038 1
a3038 5

	if (r_type == R_ARM_THM_JUMP6)
	  relocation = ((relocation & 0x0020) << 4) | ((relocation & 0x001f) << 3);
	else
	  relocation &= howto->dst_mask;
d3082 13
a3094 1
    case R_ARM_GOTOFF32:
d3455 24
d3509 1
a3509 1
  if (howto->type == R_ARM_THM_CALL)
d4403 1
a4403 1
	case R_ARM_THM_CALL:
d4417 1
a4417 1
		  if (ELF32_R_TYPE (rel->r_info) == R_ARM_THM_CALL)
d4587 1
a4587 1
	  case R_ARM_GOTOFF32:
d4607 1
a4607 1
	  case R_ARM_THM_CALL:
d4631 1
a4631 1
		    || r_type == R_ARM_THM_CALL)
d4638 1
a4638 1
		if (r_type == R_ARM_THM_CALL)
@


1.22.2.3.2.7
log
@2005-05-01  Paul Brook  <paul@@codesourcery.com>

	* bfd/elf32-arm.c (bfd_elf32_arm_process_before_allocation): Treat
	R_ARM_PLT32 the same as R_ARM_PC24.
	(arm_add_to_rel): Ditto.
@
text
@a2395 1
	    case R_ARM_PLT32:
d2416 1
a2416 1
	      abort ();
a3995 1
	case R_ARM_PLT32:
@


1.22.2.3.2.8
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Gracefully handle
	the situation where a symbol's section is not known but a section
	relative R_ARM_RELATIVE reloc has to be generated for the Symbian
	OS.
@
text
@d3010 1
a3010 4
		  if (sym_sec)
		    symbol = elf_section_data (sym_sec->output_section)->dynindx;
		  else
		    symbol = elf_section_data (input_section->output_section)->dynindx;
@


1.21
log
@2005-02-10  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (elf32_arm_final_link_relocate): Handle R_ARM_THM_PC9.
@
text
@d2353 4
a2356 3
      /* When generating a shared object, these relocations are copied
	 into the output file to be resolved at run time.  */
      if (info->shared
d3990 9
d4119 5
a4123 5
	    /* If we are creating a shared library, and this is a reloc
               against a global symbol, or a non PC relative reloc
               against a local symbol, then we need to copy the reloc
               into the shared library.  However, if we are linking with
               -Bsymbolic, we do not need to copy a reloc against a
d4131 1
a4131 1
	    if (info->shared
d4391 1
d4393 1
d4458 4
a4461 2
     be handled correctly by relocate_section.  */
  if (info->shared)
d4654 1
a4654 1
  if (info->shared)
d4661 10
d5873 1
@


1.20
log
@	* elf32-arm.c (elf32_arm_symbian_special_sections): Do not set
	SHF_WRITE for .init_array, .fini_array, and .preinit_array.
@
text
@d2739 1
@


1.19
log
@	* elf-bfd.h (struct elf_backend_data): Add minpagesize.
	* elf32-arm.c (ELF_MINPAGESIZE): Define.
	* elf32-ppc.c (ELF_MINPAGESIZE): Define.
	* elfcode.h (elf_object_p): Use minpagesize instead of
	maxpagesize.
	* elfxx-target.h (ELF_MINPAGESIZE): Default to ELF_MAXPAGESIZE.
	(elfNN_bed): Include ELF_MINPAGESIZE.
@
text
@a5851 4
/* In a BPABI executable, the dynamic linking sections do not go in
   the loadable read-only segment.  The post-linker may wish to refer
   to these sections, but they are not part of the final program
   image.  */
d5855 4
d5864 6
@


1.18
log
@	* bfd/bin-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bin-in2.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): Add fix_v4bx flag.
	(bfd_elf32_arm_set_target_relocs): Add formal parameter fix_v4bx for
	passing flag value from ld. Set flag value in global hash table entry.
	(elf32_arm_final_link_relocate): Add code to implement R_ARM_V4BX
	relocation.
	* ld/emultempl/armelf.em (fix_v4bx): New variable.
	(arm_elf_create_output_section_statements): Communicate fix_v4bx flag
	value to bfd.
	(PARSE_AND_LIST_PROLOGUE): Add option token OPTION_FIX_V4BX.
	(PARSE_AND_LIST_LONGOPTS): Add option --fix-v4bx.
	(PARSE_AND_LIST_OPTIONS): Add option --fix-v4bx.
	(PARSE_AND_LIST_ARGS_CASES): Add option OPTION_FIX_V4BX.
	* ld/NEWS: Mention --fix-v4bx.
	* ld/ld.texinfo: Document --fix-v4bx.
@
text
@d5724 1
@


1.17
log
@	* elf32-arm.c (elf_backend_default_use_rela_p): Define to zero for
	SymbianOS.

	* emulparams/armsymbian.sh (OTHER_READONLY_SECTIONS): Define, so
	as to include .ARM.exidx$${Base,Limit}.
	* ld/scripttempl/armbpabi.sc: Move .plt to end of text segment.
	Define IMAGE$$ER_RO$${Base,Limit} and SHT$$INIT_ARRAY$${Base,Limit}.
	Put .init_array, .fini_array, etc. into the read-only data
	segment.
@
text
@d1168 3
d1937 2
a1938 1
				 char * target2_type)
d1956 1
d2993 16
@


1.16
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d5920 1
a5920 1
#define elf_backend_default_use_rela_p 1
@


1.15
log
@2005-01-06  Paul Brook  <paul@@codesourcery.com>

bfd/
	* config.bfd: Add entry for arm-*-vxworks and arm-*-windiss.
	* configure.in: Add bfd_elf32_{big,little}arm_vxworks_vec.
	* configure: Regenerate.
	* elf32-arm.c: Add VxWorks target bfd.
	(USE_REL): Remove.
	(elf32_arm_link_hash_table): Add use_rel.
	(elf32_arm_link_hash_table_create, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section): Replace USE_REL with runtime check.
	Correct offset calculation for RELA case.
	(elf_backend_may_use_rel_p, elf_backend_may_use_rela_p,
	elf_backend_default_use_rela_p, elf_backend_rela_normal): Define.
	(elf32_arm_vxworks_link_hash_table_create): New function.
	* targets.c (bfd_elf32_bigarm_vxworks_vec): Add declaration.
	(bfd_elf32_littlearm_vxworks_vec): Ditto.
	(_bfd_target_vector): Add bfd_elf32_{big,little}arm_vxworks_vec.
gas/
	* config/tc-arm.c (FPU_DEFAULT): Define for TE_VXWORKS.
	(md_begin): Handle TE_VXWORKS for FP defaults.
	(md_apply_fix3): Correct rela offsets.
	(elf32_arm_target_format): Add VxWorks targets.
ld/
	* Makefie.am: Add earmelf_vxworks.
	* Makefile.in: Regenerate.
	* configure.tgt: Make arm-*-vxworks a separate case.
	* emulparams/armelf_vxworks.sh: New function.
@
text
@a3845 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
d3859 2
d3863 9
d3882 1
a3882 2
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
a3883 1
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d3906 1
a3906 2
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
a3911 1
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.14
log
@	* elf32-arm.c (elf32_arm_symbian_plt_entry): Fix comment typo.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
a30 2
#define USE_REL	1

a987 4
#ifndef USE_REL
#define USE_REL	0
#endif

d1177 3
d1389 1
d2289 3
a2291 2
#if USE_REL
  addend = bfd_get_32 (input_bfd, hit_data) & howto->src_mask;
d2293 8
a2300 5
  if (addend & ((howto->src_mask + 1) >> 1))
    {
      signed_addend = -1;
      signed_addend &= ~ howto->src_mask;
      signed_addend |= addend;
d2303 1
a2303 4
    signed_addend = addend;
#else
  addend = signed_addend = rel->r_addend;
#endif
d2510 5
a2514 1
	  value += (signed_addend << howto->size);
d2608 7
a2614 6
#if USE_REL
      /* Need to refetch addend.  */
      addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
      /* ??? Need to determine shift amount from operand size.  */
      addend >>= howto->rightshift;
#endif
a2640 1
#if USE_REL
d2643 8
a2650 8
	{
	  bfd_vma upper = upper_insn & 0x7ff;
	  bfd_vma lower = lower_insn & 0x7ff;
	  upper = (upper ^ 0x400) - 0x400; /* Sign extend.  */
	  addend = (upper << 12) | (lower << 1);
	  signed_addend = addend;
	}
#endif
d2741 1
a2741 4
#if USE_REL
	/* Need to refetch addend.  */
	addend = bfd_get_16 (input_bfd, hit_data) & howto->src_mask;
	if (addend & ((howto->src_mask + 1) >> 1))
d2743 14
a2756 3
	    signed_addend = -1;
	    signed_addend &= ~ howto->src_mask;
	    signed_addend |= addend;
a2757 7
	else
	  signed_addend = addend;
	/* The value in the insn has been right shifted.  We need to
	   undo this, so that we can perform the address calculation
	   in terms of bytes.  */
	signed_addend <<= howto->rightshift;
#endif
d2787 6
a2792 5
#if USE_REL
	/* Extract the addend.  */
	addend = (insn & 0xff) << ((insn & 0xf00) >> 7);
	signed_addend = addend;
#endif
a2992 1
#if USE_REL
a3065 1
#endif /* USE_REL */
d3085 2
a3086 2
#if !USE_REL
  if (info->relocatable)
a3087 1
#endif
a3088 1
  globals = elf32_arm_hash_table (info);
d3117 1
a3117 2
#if USE_REL
      if (info->relocatable)
a3137 1
#endif
d3148 1
a3148 6
#if USE_REL
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
	  if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
d3150 8
a3157 2
	      asection *msec;
	      bfd_vma addend, value;
d3159 8
a3166 8
	      if (howto->rightshift)
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}
d3168 1
a3168 1
	      value = bfd_get_32 (input_bfd, contents + rel->r_offset);
d3170 5
a3174 5
	      /* Get the (signed) value from the instruction.  */
	      addend = value & howto->src_mask;
	      if (addend & ((howto->src_mask + 1) >> 1))
		{
		  bfd_signed_vma mask;
d3176 11
a3186 3
		  mask = -1;
		  mask &= ~ howto->src_mask;
		  addend |= mask;
a3187 7
	      msec = sec;
	      addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      value = (value & ~ howto->dst_mask) | (addend & howto->dst_mask);
	      bfd_put_32 (input_bfd, value, contents + rel->r_offset);
d3189 2
a3190 3
#else
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
#endif
d5737 4
a5740 3
#if !USE_REL
#define elf_backend_rela_normal     1
#endif
d5746 47
d5910 9
@


1.13
log
@2004-12-01  Paul Brook  <paul@@codesourcery.com>

	* elf32-arm.c (elf32_arm_copy_private_bfd_data): Set EI_OSABI.
	(elf32_arm_post_process_headers): Set EI_OSABI depending on ABI
	version.
@
text
@d1078 1
a1078 1
    0xe51ff004,         /* ldr   pr, [pc, #-4] */
@


1.12
log
@2004-11-30  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (struct elf32_arm_link_hash_table): Remove
	no_pipeline_knowledge
	(elf32_arm_link_hash_table_create): Ditto.
	(bfd_elf32_arm_process_before_allocation): Ditto.
	(elf32_arm_final_link_relocate): Ditto.  Remove oabi relocation
	handling.
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	* bfd-in2.h: Regenerate.
ld/
	* emultempl/armelf.em: Ignore -p and -no-pipeline-knowledge.
@
text
@d3431 4
d5359 4
a5362 1
  i_ehdrp->e_ident[EI_OSABI]      = ARM_ELF_OS_ABI_VERSION;
@


1.11
log
@2004-11-24  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (elf32_arm_swap_symbol_in): New function.
	(elf32_arm_swap_symbol_out): New function.
	(elf32_arm_size_info): Add.
	(elf_backend_size_info): Define.
ld/testsuite/
	* ld-arm/mixed-lib.sym: Update for THUMB_FUNC change.
@
text
@a1163 4
    /* A boolean indicating whether knowledge of the ARM's pipeline
       length should be applied by the linker.  */
    int no_pipeline_knowledge;

a1380 1
  ret->no_pipeline_knowledge = 0;
a1768 1
					 int no_pipeline_knowledge,
a1790 2
  globals->no_pipeline_knowledge = no_pipeline_knowledge;

d2489 23
a2511 55
	  if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
	      || strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0)
	    {
	      /* The old way of doing things.  Trearing the addend as a
		 byte sized field and adding in the pipeline offset.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += addend;

	      if (! globals->no_pipeline_knowledge)
		value -= 8;
	    }
	  else
	    {
	      /* The ARM ELF ABI says that this reloc is computed as: S - P + A
		 where:
		  S is the address of the symbol in the relocation.
		  P is address of the instruction being relocated.
		  A is the addend (extracted from the instruction) in bytes.

		 S is held in 'value'.
		 P is the base address of the section containing the
		   instruction plus the offset of the reloc into that
		   section, ie:
		     (input_section->output_section->vma +
		      input_section->output_offset +
		      rel->r_offset).
		 A is the addend, converted into bytes, ie:
		     (signed_addend * 4)

		 Note: None of these operations have knowledge of the pipeline
		 size of the processor, thus it is up to the assembler to
		 encode this information into the addend.  */
	      value -= (input_section->output_section->vma
			+ input_section->output_offset);
	      value -= rel->r_offset;
	      value += (signed_addend << howto->size);

	      /* Previous versions of this code also used to add in the
		 pipeline offset here.  This is wrong because the linker is
		 not supposed to know about such things, and one day it might
		 change.  In order to support old binaries that need the old
		 behaviour however, so we attempt to detect which ABI was
		 used to create the reloc.  */
	      if (! globals->no_pipeline_knowledge)
		{
		  Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form */

		  i_ehdrp = elf_elfheader (input_bfd);

		  if (i_ehdrp->e_ident[EI_OSABI] == 0)
		    value -= 8;
		}
	    }
a2695 17
	if (! globals->no_pipeline_knowledge)
	  {
	    Elf_Internal_Ehdr * i_ehdrp; /* Elf file header, internal form.  */

	    i_ehdrp = elf_elfheader (input_bfd);

	    /* Previous versions of this code also used to add in the pipline
	       offset here.  This is wrong because the linker is not supposed
	       to know about such things, and one day it might change.  In order
	       to support old binaries that need the old behaviour however, so
	       we attempt to detect which ABI was used to create the reloc.  */
	    if (   strcmp (bfd_get_target (input_bfd), "elf32-littlearm-oabi") == 0
		|| strcmp (bfd_get_target (input_bfd), "elf32-bigarm-oabi") == 0
		|| i_ehdrp->e_ident[EI_OSABI] == 0)
	      relocation += 4;
	  }

@


1.10
log
@	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Warning fix.
	* elf32-iq2000.c (iq2000_reloc_type_lookup): C90 function decl.
	* nlmcode.h (nlm_write_object_contents): Warning fix.
@
text
@d5665 76
d5780 1
@


1.9
log
@bfd/
	* elf32-arm.c (PLT_THUMB_STUB_SIZE): Define.
	(elf32_arm_plt_thumb_stub): New.
	(struct elf32_arm_link_hash_entry): Add plt_thumb_refcount
	and plt_got_offset.
	(elf32_arm_link_hash_traverse): Fix typo.
	(elf32_arm_link_hash_table): Add obfd.
	(elf32_arm_link_hash_newfunc): Initialize new fields.
	(elf32_arm_copy_indirect_symbol): Copy plt_thumb_refcount.
	(elf32_arm_link_hash_table_create): Initialize obfd.
	(record_arm_to_thumb_glue): Mark the glue as a local ARM function.
	(record_thumb_to_arm_glue): Mark the glue as a local Thumb function.
	(bfd_elf32_arm_get_bfd_for_interworking): Verify that the
	interworking BFD is not dynamic.
	(bfd_elf32_arm_process_before_allocation): Handle R_ARM_PLT32.  Do
	not emit glue for PLT references.
	(elf32_arm_final_link_relocate): Handle Thumb functions.  Do not
	emit glue for PLT references.  Support the Thumb PLT prefix.
	(elf32_arm_gc_sweep_hook): Handle R_ARM_THM_PC22 and
	plt_thumb_refcount.
	(elf32_arm_check_relocs): Likewise.
	(elf32_arm_adjust_dynamic_symbol): Handle Thumb functions and
	plt_thumb_refcount.
	(allocate_dynrelocs): Handle Thumb PLT references.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(elf32_arm_symbol_processing): New function.
	(elf_backend_symbol_processing): Define.
opcodes/
	* arm-dis.c (WORD_ADDRESS): Define.
	(print_insn): Use it.  Correct big-endian end-of-section handling.
gas/testsuite/
	* gas/arm/mapping.d: Expect F markers for Thumb code.
	* gas/arm/unwind.d: Update big-endian pattern.
ld/
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Don't use
	a dynamic object for stubs.
ld/testsuite/
	* ld-arm/mixed-app.d, ld-arm/mixed-app.r, ld-arm/mixed-app.s,
	ld-arm/mixed-app.sym, ld-arm/mixed-lib.d, ld-arm/mixed-lib.r,
	ld-arm/mixed-lib.s, ld-arm/mixed-lib.sym, ld-arm/arm-dyn.ld,
	ld-arm/arm-lib.ld: New files.
	* ld-arm/arm-app-abs32.d, ld-arm/arm-app-abs32.r, ld-arm/arm-app.d,
	ld-arm/arm-app.r, ld-arm/arm-lib-plt32.d, ld-arm/arm-lib-plt32.r,
	ld-arm/arm-lib.d, ld-arm/arm-lib.r, ld-arm/arm-static-app.d,
	ld-arm/arm-static-app.r: Update for big-endian.
	* ld-arm/arm-elf.exp: Run the new tests.
@
text
@d5317 2
a5318 2
			  else if (dyn.d_un.d_val == 0
				   || hdr->sh_offset < dyn.d_un.d_val)
@


1.8
log
@	* elf32-arm.c (elf32_arm_relocate_section): Use
	arm_real_reloc_type.
@
text
@d1066 8
d1127 9
d1142 1
a1142 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *))) (func), \
d1198 3
d1225 5
a1229 1
    ret->relocs_copied = NULL;
d1342 11
d1398 1
d1598 4
a1618 1
  char bind;
d1656 2
a1657 2
  bind = ELF_ST_BIND (myh->type);
  myh->type = ELF_ST_INFO (bind, STT_ARM_TFUNC);
d1755 3
d1841 1
d1880 5
d2425 2
d2705 5
a2709 2
	       function call at all, but rather a long jump.  */
	    if (sym_flags != STT_ARM_TFUNC && sym_flags != STT_SECTION)
d2720 10
d2977 7
d3949 3
d3960 1
d3963 5
a3967 1
		h->plt.refcount -= 1;
a3971 2
		  eh = (struct elf32_arm_link_hash_entry *) h;

d4030 1
d4044 2
d4100 2
d4123 2
a4124 1
		    || r_type == R_ARM_PLT32)
d4130 3
d4156 2
a4157 1
		     && r_type != R_ARM_REL32)
d4406 1
d4418 2
d4423 1
a4423 1
  if (h->type == STT_FUNC
d4437 1
d4444 9
a4452 6
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_ARM_PC24 or similar reloc to a non-function sym
       in check_relocs.  We can't decide accurately between function
       and non-function syms in check-relocs; Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;
d4537 2
d4575 8
d4593 6
d4605 6
a4610 3
	    /* We also need to make an entry in the .got.plt section, which
	       will be placed in the .got section by the linker script.  */
	    htab->sgotplt->size += 4;
a4656 1
  eh = (struct elf32_arm_link_hash_entry *) h;
d4981 1
d4985 1
a5003 7
      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = ((h->plt.offset - htab->plt_header_size) 
		   / htab->plt_entry_size);

d5018 7
d5035 10
a5044 4
	  /* Get the offset into the .got table of the entry that
	     corresponds to this function.  Each .got entry is 4 bytes.
	     The first three are reserved.  */
	  got_offset = (plt_index + 3) * 4;
d5047 3
a5049 1
	     entry in the GOT.  */
d5060 8
d5653 12
d5703 1
a5835 1

@


1.7
log
@	* bfd/elf32-arm.c (elf32_arm_final_link_relocate): Resolve
	R_ARM_PREL31 relocations to PLT entries.
	(elf32_arm_relocate_section, elf32_arm_gc_sweep_hook): Ditto.
	(elf32_arm_check_relocs): Ditto.
@
text
@d3067 1
d3074 1
d3094 1
d3100 1
a3100 1
      elf32_arm_info_to_howto (input_bfd, & bfd_reloc, rel);
@


1.6
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): Correct logic for
	R_ARM_RELATIVE on Symbian OS.
@
text
@d2291 1
a2291 5
      if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	   && r_type != R_ARM_PREL31
#endif
	   )
d2313 2
a2314 5
	  && ((r_type != R_ARM_REL32
#ifndef OLD_ARM_ABI
	      && r_type != R_ARM_PREL31
#endif
	      ) || !SYMBOL_CALLS_LOCAL (info, h))
d2322 1
d3197 1
a3888 3
#ifndef OLD_ARM_ABI
		  || r_type == R_ARM_PREL31
#endif
d4037 1
a4151 3
#ifndef OLD_ARM_ABI
		    || r_type == R_ARM_PREL31
#endif
@


1.5
log
@	* elf32-arm.c (elf32_arm_begin_write_processing): Do not use a K&R
	declaration.
	(elf32_arm_symbian_modify_segment_map): Likewise.
@
text
@d2384 12
a2395 9
		/* On Symbian OS, the data segment and text segement
		   can be relocated independently.  Therefore, we must
		   indicate the segment to which this relocation is
		   relative.  The BPABI allows us to use any symbol in
		   the right segment; we just use the section symbol
		   as it is convenient.  (We cannot use the symbol
		   given by "h" directly as it will not appear in the
		   dynamic symbol table.)  */
		symbol = input_section->output_section->target_index;
@


1.4
log
@	From David Poole <daveml@@mbuf.com>:
	* elf32-arm.c (elf32_arm_readonly_dynrelocs): New function.
	(elf32_arm_size_dynamic_sections): Call it.
@
text
@a5626 7
static bfd_boolean
elf32_arm_symbian_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));
static void
elf32_arm_symbian_begin_write_processing
  PARAMS ((bfd *, bfd_boolean));

d5628 3
a5630 3
elf32_arm_symbian_begin_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker;
d5644 3
a5646 3
elf32_arm_symbian_modify_segment_map (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
@


1.3
log
@	* elf32-arm.c (elf32_arm_final_link_relocate): When generating an
	R_ARM_RELATIVE relocation for Symbian OS, mention the section
	symbol in the relocation.
@
text
@d4610 29
d4847 6
@


1.2
log
@	* elf32-arm.c (elf32_arm_symbian_begin_write_processing): Clear
	D_PAGED.
	(elf32_arm_symbian_modify_segment_map): Don't
	reset includes_filehdr and includes_phdrs here.
@
text
@d2379 2
d2383 16
a2398 1
	      outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
@


1.1
log
@./
	* configure.in (arm-*-oabi*, thumb-*-oabi*): Remove.
	* configure: Regenerated.
bfd/
	* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Replace
	elfarm-nabi with elf32-arm.  Remove elfarm-oabi.
	(elf32-arm.lo): Replace elfarm-nabi.lo rule.  Remove elf32-arm.h
	dependency.
	* config.bfd: Move arm-*-oabi* and thumb-*-oabi* from obsolete list
	to a new removed list.  Remove normal configuration stanzas.
	* configure.in: (bfd_elf32_bigarm_vec, bfd_elf32_bigarm_symbian_vec)
	(bfd_elf32_littlearm_symbian_vec, bfd_elf32_littlearm_vec): Replace
	elfarm-nabi.lo with elf32-arm.lo.
	(bfd_elf32_bigarm_oabi_vec, bfd_elf32_littlearm_oabi_vec): Remove.
	* elf32-arm.c: Renamed from elfarm-nabi.c.  Inline elf32-arm.h.
	* elf32-arm.h: Remove.
	* elfarm-oabi.c: Remove.
	* targets.c (_bfd_target_vector): Remove bfd_elf32_bigarm_oabi_vec
	and bfd_elf32_littlearm_oabi_vec.
	* aclocal.m4, Makefile.in, configure, doc/Makefile.in: Regenerated.
gas/
	* configure.in: Remove arm-*-oabi and thumb-*-oabi.
	* config/tc-arm.c (target_oabi): Delete.
	(md_apply_fix3, elf32_arm_target_format): Remove target_oabi checks.
	(arm_opts): Remove moabi.
	* doc/as.texinfo (Overview): Remove documentation of -moabi.
	* doc/c-arm.texi (ARM Options): Likewise.
	* configure: Regenerated.
ld/
	* Makefile.am (ALL_EMULATIONS): Remove earmelf_oabi.o.
	(earmelf_oabi.c): Remove rule.
	* configure.tgt: Remove arm-*-oabi and thumb-*-oabi.
	* emulparams/armelf_oabi.sh, emultempl/armelf_oabi.em: Delete files.
	* Makefile.in: Regenerated.
@
text
@d5578 19
a5605 10
  /* The first PT_LOAD segment will have the program headers and file
     headers in it by default -- but BPABI object files should not
     include these headers in any loadable segment.  */
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
    if (m->p_type == PT_LOAD)
      {
	m->includes_filehdr = 0;
	m->includes_phdrs = 0;
      }

d5637 4
@

