head	1.97;
access;
symbols
	sid-snapshot-20180601:1.97
	sid-snapshot-20180501:1.97
	sid-snapshot-20180401:1.97
	sid-snapshot-20180301:1.97
	sid-snapshot-20180201:1.97
	sid-snapshot-20180101:1.97
	sid-snapshot-20171201:1.97
	sid-snapshot-20171101:1.97
	sid-snapshot-20171001:1.97
	sid-snapshot-20170901:1.97
	sid-snapshot-20170801:1.97
	sid-snapshot-20170701:1.97
	sid-snapshot-20170601:1.97
	sid-snapshot-20170501:1.97
	sid-snapshot-20170401:1.97
	sid-snapshot-20170301:1.97
	sid-snapshot-20170201:1.97
	sid-snapshot-20170101:1.97
	sid-snapshot-20161201:1.97
	sid-snapshot-20161101:1.97
	sid-snapshot-20160901:1.97
	sid-snapshot-20160801:1.97
	sid-snapshot-20160701:1.97
	sid-snapshot-20160601:1.97
	sid-snapshot-20160501:1.97
	sid-snapshot-20160401:1.97
	sid-snapshot-20160301:1.97
	sid-snapshot-20160201:1.97
	sid-snapshot-20160101:1.97
	sid-snapshot-20151201:1.97
	sid-snapshot-20151101:1.97
	sid-snapshot-20151001:1.97
	sid-snapshot-20150901:1.97
	sid-snapshot-20150801:1.97
	sid-snapshot-20150701:1.97
	sid-snapshot-20150601:1.97
	sid-snapshot-20150501:1.97
	sid-snapshot-20150401:1.97
	sid-snapshot-20150301:1.97
	sid-snapshot-20150201:1.97
	sid-snapshot-20150101:1.97
	sid-snapshot-20141201:1.97
	sid-snapshot-20141101:1.97
	sid-snapshot-20141001:1.97
	sid-snapshot-20140901:1.97
	sid-snapshot-20140801:1.97
	sid-snapshot-20140701:1.97
	sid-snapshot-20140601:1.97
	sid-snapshot-20140501:1.97
	sid-snapshot-20140401:1.97
	sid-snapshot-20140301:1.97
	sid-snapshot-20140201:1.97
	sid-snapshot-20140101:1.97
	sid-snapshot-20131201:1.97
	sid-snapshot-20131101:1.97
	sid-snapshot-20131001:1.97
	binutils-2_24-branch:1.97.0.4
	binutils-2_24-branchpoint:1.97
	binutils-2_21_1:1.77.2.3
	sid-snapshot-20130901:1.97
	gdb_7_6_1-2013-08-30-release:1.97
	sid-snapshot-20130801:1.97
	sid-snapshot-20130701:1.97
	sid-snapshot-20130601:1.97
	sid-snapshot-20130501:1.97
	gdb_7_6-2013-04-26-release:1.97
	sid-snapshot-20130401:1.97
	binutils-2_23_2:1.95.4.1
	gdb_7_6-branch:1.97.0.2
	gdb_7_6-2013-03-12-branchpoint:1.97
	sid-snapshot-20130301:1.97
	sid-snapshot-20130201:1.97
	sid-snapshot-20130101:1.96
	sid-snapshot-20121201:1.96
	gdb_7_5_1-2012-11-29-release:1.95
	binutils-2_23_1:1.95
	sid-snapshot-20121101:1.96
	binutils-2_23:1.95
	sid-snapshot-20121001:1.95
	sid-snapshot-20120901:1.95
	gdb_7_5-2012-08-17-release:1.95
	sid-snapshot-20120801:1.95
	binutils-2_23-branch:1.95.0.4
	binutils-2_23-branchpoint:1.95
	gdb_7_5-branch:1.95.0.2
	gdb_7_5-2012-07-18-branchpoint:1.95
	sid-snapshot-20120701:1.95
	sid-snapshot-20120601:1.95
	sid-snapshot-20120501:1.94
	binutils-2_22_branch:1.90.0.6
	gdb_7_4_1-2012-04-26-release:1.90
	sid-snapshot-20120401:1.93
	sid-snapshot-20120301:1.92
	sid-snapshot-20120201:1.91
	gdb_7_4-2012-01-24-release:1.90
	sid-snapshot-20120101:1.90
	gdb_7_4-branch:1.90.0.4
	gdb_7_4-2011-12-13-branchpoint:1.90
	sid-snapshot-20111201:1.90
	binutils-2_22:1.90
	sid-snapshot-20111101:1.90
	sid-snapshot-20111001:1.90
	binutils-2_22-branch:1.90.0.2
	binutils-2_22-branchpoint:1.90
	gdb_7_3_1-2011-09-04-release:1.78
	sid-snapshot-20110901:1.89
	sid-snapshot-20110801:1.87
	gdb_7_3-2011-07-26-release:1.78
	sid-snapshot-20110701:1.85
	sid-snapshot-20110601:1.83
	sid-snapshot-20110501:1.81
	gdb_7_3-branch:1.78.0.2
	gdb_7_3-2011-04-01-branchpoint:1.78
	sid-snapshot-20110401:1.78
	sid-snapshot-20110301:1.78
	sid-snapshot-20110201:1.78
	sid-snapshot-20110101:1.78
	binutils-2_21:1.77
	sid-snapshot-20101201:1.77
	binutils-2_21-branch:1.77.0.2
	binutils-2_21-branchpoint:1.77
	sid-snapshot-20101101:1.77
	sid-snapshot-20101001:1.76
	binutils-2_20_1:1.74.2.1
	gdb_7_2-2010-09-02-release:1.76
	sid-snapshot-20100901:1.76
	sid-snapshot-20100801:1.76
	gdb_7_2-branch:1.76.0.4
	gdb_7_2-2010-07-07-branchpoint:1.76
	sid-snapshot-20100701:1.76
	sid-snapshot-20100601:1.76
	sid-snapshot-20100501:1.76
	sid-snapshot-20100401:1.76
	gdb_7_1-2010-03-18-release:1.76
	sid-snapshot-20100301:1.76
	gdb_7_1-branch:1.76.0.2
	gdb_7_1-2010-02-18-branchpoint:1.76
	sid-snapshot-20100201:1.76
	sid-snapshot-20100101:1.76
	gdb_7_0_1-2009-12-22-release:1.75
	sid-snapshot-20091201:1.76
	sid-snapshot-20091101:1.75
	binutils-2_20:1.74.2.1
	gdb_7_0-2009-10-06-release:1.75
	sid-snapshot-20091001:1.75
	gdb_7_0-branch:1.75.0.2
	gdb_7_0-2009-09-16-branchpoint:1.75
	arc-sim-20090309:1.64
	binutils-arc-20081103-branch:1.66.0.8
	binutils-arc-20081103-branchpoint:1.66
	binutils-2_20-branch:1.74.0.2
	binutils-2_20-branchpoint:1.74
	sid-snapshot-20090901:1.73
	sid-snapshot-20090801:1.70
	msnyder-checkpoint-072509-branch:1.69.0.4
	msnyder-checkpoint-072509-branchpoint:1.69
	sid-snapshot-20090701:1.69
	dje-cgen-play1-branch:1.69.0.2
	dje-cgen-play1-branchpoint:1.69
	sid-snapshot-20090601:1.69
	sid-snapshot-20090501:1.68
	sid-snapshot-20090401:1.66
	arc-20081103-branch:1.66.0.6
	arc-20081103-branchpoint:1.66
	arc-insight_6_8-branch:1.64.0.10
	arc-insight_6_8-branchpoint:1.64
	insight_6_8-branch:1.64.0.8
	insight_6_8-branchpoint:1.64
	sid-snapshot-20090301:1.66
	binutils-2_19_1:1.65
	sid-snapshot-20090201:1.66
	sid-snapshot-20090101:1.66
	reverse-20081226-branch:1.66.0.4
	reverse-20081226-branchpoint:1.66
	sid-snapshot-20081201:1.66
	multiprocess-20081120-branch:1.66.0.2
	multiprocess-20081120-branchpoint:1.66
	sid-snapshot-20081101:1.66
	binutils-2_19:1.65
	sid-snapshot-20081001:1.65
	reverse-20080930-branch:1.65.0.4
	reverse-20080930-branchpoint:1.65
	binutils-2_19-branch:1.65.0.2
	binutils-2_19-branchpoint:1.65
	sid-snapshot-20080901:1.65
	sid-snapshot-20080801:1.64
	reverse-20080717-branch:1.64.0.6
	reverse-20080717-branchpoint:1.64
	sid-snapshot-20080701:1.64
	msnyder-reverse-20080609-branch:1.64.0.4
	msnyder-reverse-20080609-branchpoint:1.64
	drow-reverse-20070409-branch:1.57.0.4
	drow-reverse-20070409-branchpoint:1.57
	sid-snapshot-20080601:1.64
	sid-snapshot-20080501:1.64
	sid-snapshot-20080403:1.64
	sid-snapshot-20080401:1.64
	gdb_6_8-2008-03-27-release:1.64
	sid-snapshot-20080301:1.64
	gdb_6_8-branch:1.64.0.2
	gdb_6_8-2008-02-26-branchpoint:1.64
	sid-snapshot-20080201:1.63
	sid-snapshot-20080101:1.63
	sid-snapshot-20071201:1.63
	sid-snapshot-20071101:1.63
	gdb_6_7_1-2007-10-29-release:1.63
	gdb_6_7-2007-10-10-release:1.63
	sid-snapshot-20071001:1.63
	gdb_6_7-branch:1.63.0.4
	gdb_6_7-2007-09-07-branchpoint:1.63
	binutils-2_18:1.63
	binutils-2_18-branch:1.63.0.2
	binutils-2_18-branchpoint:1.63
	insight_6_6-20070208-release:1.57
	binutils-csl-coldfire-4_1-32:1.53
	binutils-csl-sourcerygxx-4_1-32:1.53
	gdb_6_6-2006-12-18-release:1.57
	binutils-csl-innovasic-fido-3_4_4-33:1.53
	binutils-csl-sourcerygxx-3_4_4-32:1.45
	binutils-csl-coldfire-4_1-30:1.53
	binutils-csl-sourcerygxx-4_1-30:1.53
	binutils-csl-coldfire-4_1-28:1.53
	binutils-csl-sourcerygxx-4_1-29:1.53
	binutils-csl-sourcerygxx-4_1-28:1.53
	gdb_6_6-branch:1.57.0.2
	gdb_6_6-2006-11-15-branchpoint:1.57
	binutils-csl-arm-2006q3-27:1.53
	binutils-csl-sourcerygxx-4_1-27:1.53
	binutils-csl-arm-2006q3-26:1.53
	binutils-csl-sourcerygxx-4_1-26:1.53
	binutils-csl-sourcerygxx-4_1-25:1.53
	binutils-csl-sourcerygxx-4_1-24:1.53
	binutils-csl-sourcerygxx-4_1-23:1.53
	insight_6_5-20061003-release:1.53
	gdb-csl-symbian-6_4_50_20060226-12:1.52
	binutils-csl-sourcerygxx-4_1-21:1.53
	binutils-csl-arm-2006q3-21:1.53
	binutils-csl-sourcerygxx-4_1-22:1.53
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.53
	binutils-csl-sourcerygxx-4_1-20:1.53
	binutils-csl-arm-2006q3-19:1.53
	binutils-csl-sourcerygxx-4_1-19:1.53
	binutils-csl-sourcerygxx-4_1-18:1.53
	binutils-csl-renesas-4_1-9:1.53
	gdb-csl-sourcerygxx-3_4_4-25:1.51
	binutils-csl-sourcerygxx-3_4_4-25:1.45
	nickrob-async-20060828-mergepoint:1.53
	gdb-csl-symbian-6_4_50_20060226-11:1.52
	binutils-csl-renesas-4_1-8:1.53
	binutils-csl-renesas-4_1-7:1.53
	binutils-csl-renesas-4_1-6:1.53
	gdb-csl-sourcerygxx-4_1-17:1.52
	binutils-csl-sourcerygxx-4_1-17:1.53
	gdb-csl-20060226-branch-local-2:1.52
	gdb-csl-sourcerygxx-4_1-14:1.52
	binutils-csl-sourcerygxx-4_1-14:1.53
	binutils-csl-sourcerygxx-4_1-15:1.53
	gdb-csl-sourcerygxx-4_1-13:1.52
	binutils-csl-sourcerygxx-4_1-13:1.53
	binutils-2_17:1.53
	gdb-csl-sourcerygxx-4_1-12:1.52
	binutils-csl-sourcerygxx-4_1-12:1.53
	gdb-csl-sourcerygxx-3_4_4-21:1.52
	binutils-csl-sourcerygxx-3_4_4-21:1.53
	gdb_6_5-20060621-release:1.53
	binutils-csl-wrs-linux-3_4_4-24:1.45
	binutils-csl-wrs-linux-3_4_4-23:1.45
	gdb-csl-sourcerygxx-4_1-9:1.52
	binutils-csl-sourcerygxx-4_1-9:1.53
	gdb-csl-sourcerygxx-4_1-8:1.52
	binutils-csl-sourcerygxx-4_1-8:1.53
	gdb-csl-sourcerygxx-4_1-7:1.52
	binutils-csl-sourcerygxx-4_1-7:1.53
	gdb-csl-arm-2006q1-6:1.52
	binutils-csl-arm-2006q1-6:1.53
	gdb-csl-sourcerygxx-4_1-6:1.52
	binutils-csl-sourcerygxx-4_1-6:1.53
	binutils-csl-wrs-linux-3_4_4-22:1.45
	gdb-csl-symbian-6_4_50_20060226-10:1.52
	gdb-csl-symbian-6_4_50_20060226-9:1.52
	gdb-csl-symbian-6_4_50_20060226-8:1.52
	gdb-csl-coldfire-4_1-11:1.52
	binutils-csl-coldfire-4_1-11:1.53
	gdb-csl-sourcerygxx-3_4_4-19:1.52
	binutils-csl-sourcerygxx-3_4_4-19:1.53
	gdb-csl-coldfire-4_1-10:1.52
	gdb_6_5-branch:1.53.0.14
	gdb_6_5-2006-05-14-branchpoint:1.53
	binutils-csl-coldfire-4_1-10:1.53
	gdb-csl-sourcerygxx-4_1-5:1.52
	binutils-csl-sourcerygxx-4_1-5:1.53
	nickrob-async-20060513-branch:1.53.0.12
	nickrob-async-20060513-branchpoint:1.53
	gdb-csl-sourcerygxx-4_1-4:1.52
	binutils-csl-sourcerygxx-4_1-4:1.53
	msnyder-reverse-20060502-branch:1.53.0.10
	msnyder-reverse-20060502-branchpoint:1.53
	binutils-csl-wrs-linux-3_4_4-21:1.45
	gdb-csl-morpho-4_1-4:1.52
	binutils-csl-morpho-4_1-4:1.53
	gdb-csl-sourcerygxx-3_4_4-17:1.52
	binutils-csl-sourcerygxx-3_4_4-17:1.53
	binutils-csl-wrs-linux-3_4_4-20:1.45
	readline_5_1-import-branch:1.53.0.8
	readline_5_1-import-branchpoint:1.53
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.52
	binutils-2_17-branch:1.53.0.6
	binutils-2_17-branchpoint:1.53
	gdb-csl-symbian-20060226-branch:1.52.0.6
	gdb-csl-symbian-20060226-branchpoint:1.52
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.52
	msnyder-reverse-20060331-branch:1.53.0.4
	msnyder-reverse-20060331-branchpoint:1.53
	binutils-csl-2_17-branch:1.53.0.2
	binutils-csl-2_17-branchpoint:1.53
	gdb-csl-available-20060303-branch:1.52.0.4
	gdb-csl-available-20060303-branchpoint:1.52
	gdb-csl-20060226-branch:1.52.0.2
	gdb-csl-20060226-branchpoint:1.52
	gdb_6_4-20051202-release:1.51
	msnyder-fork-checkpoint-branch:1.51.0.6
	msnyder-fork-checkpoint-branchpoint:1.51
	gdb-csl-gxxpro-6_3-branch:1.51.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.51
	gdb_6_4-branch:1.51.0.2
	gdb_6_4-2005-11-01-branchpoint:1.51
	gdb-csl-arm-20051020-branch:1.50.0.2
	gdb-csl-arm-20051020-branchpoint:1.50
	binutils-csl-gxxpro-3_4-branch:1.45.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.45
	binutils-2_16_1:1.45
	msnyder-tracepoint-checkpoint-branch:1.49.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.49
	gdb-csl-arm-20050325-2005-q1b:1.45
	binutils-csl-arm-2005q1b:1.45
	binutils-2_16:1.45
	gdb-csl-arm-20050325-2005-q1a:1.45
	binutils-csl-arm-2005q1a:1.45
	csl-arm-20050325-branch:1.45.0.6
	csl-arm-20050325-branchpoint:1.45
	binutils-csl-arm-2005q1-branch:1.45.0.4
	binutils-csl-arm-2005q1-branchpoint:1.45
	binutils-2_16-branch:1.45.0.2
	binutils-2_16-branchpoint:1.45
	csl-arm-2004-q3d:1.42
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	csl-arm-2004-q3:1.41
	drow_intercu-merge-20040921:1.41
	drow_intercu-merge-20040915:1.40
	jimb-gdb_6_2-e500-branch:1.37.0.6
	jimb-gdb_6_2-e500-branchpoint:1.37
	gdb_6_2-20040730-release:1.37
	gdb_6_2-branch:1.37.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.37
	gdb_6_1_1-20040616-release:1.34
	binutils-2_15:1.34.6.1
	binutils-2_15-branchpoint:1.34
	csl-arm-2004-q1a:1.35
	csl-arm-2004-q1:1.35
	gdb_6_1-2004-04-05-release:1.34
	drow_intercu-merge-20040402:1.35
	drow_intercu-merge-20040327:1.35
	ezannoni_pie-20040323-branch:1.35.0.2
	ezannoni_pie-20040323-branchpoint:1.35
	cagney_tramp-20040321-mergepoint:1.34
	cagney_tramp-20040309-branch:1.34.0.12
	cagney_tramp-20040309-branchpoint:1.34
	gdb_6_1-branch:1.34.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.34
	drow_intercu-20040221-branch:1.34.0.8
	drow_intercu-20040221-branchpoint:1.34
	binutils-2_15-branch:1.34.0.6
	cagney_bfdfile-20040213-branch:1.34.0.4
	cagney_bfdfile-20040213-branchpoint:1.34
	drow-cplus-merge-20040208:1.34
	carlton_dictionary-20040126-merge:1.34
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	drow-cplus-merge-20040113:1.34
	csl-arm-2003-q4:1.34
	drow-cplus-merge-20031224:1.34
	drow-cplus-merge-20031220:1.34
	carlton_dictionary-20031215-merge:1.34
	drow-cplus-merge-20031214:1.34
	carlton-dictionary-20031111-merge:1.33
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.32.0.6
	kettenis_sparc-20030918-branchpoint:1.32
	carlton_dictionary-20030917-merge:1.32
	ezannoni_pie-20030916-branchpoint:1.32
	ezannoni_pie-20030916-branch:1.32.0.4
	cagney_x86i386-20030821-branch:1.32.0.2
	cagney_x86i386-20030821-branchpoint:1.32
	carlton_dictionary-20030805-merge:1.32
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.30.0.22
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.30
	binutils-2_14:1.30
	cagney_convert-20030606-branch:1.30.0.18
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.16
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.12
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	binutils-2_14-branch:1.30.0.8
	binutils-2_14-branchpoint:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.6
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.4
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.2
	cagney_framebase-20030330-mergepoint:1.29
	cagney_framebase-20030326-branch:1.29.0.14
	cagney_framebase-20030326-branchpoint:1.29
	cagney_lazyid-20030317-branch:1.29.0.12
	cagney_lazyid-20030317-branchpoint:1.29
	kettenis-i386newframe-20030316-mergepoint:1.29
	offbyone-20030313-branch:1.29.0.10
	offbyone-20030313-branchpoint:1.29
	kettenis-i386newframe-20030308-branch:1.29.0.8
	kettenis-i386newframe-20030308-branchpoint:1.29
	carlton_dictionary-20030305-merge:1.29
	cagney_offbyone-20030303-branch:1.29.0.6
	cagney_offbyone-20030303-branchpoint:1.29
	carlton_dictionary-20030207-merge:1.29
	interps-20030202-branch:1.29.0.4
	interps-20030202-branchpoint:1.29
	cagney-unwind-20030108-branch:1.29.0.2
	cagney-unwind-20030108-branchpoint:1.29
	binutils-2_13_2_1:1.25.2.2
	binutils-2_13_2:1.25.2.2
	carlton_dictionary-20021223-merge:1.29
	gdb_5_3-2002-12-12-release:1.25
	carlton_dictionary-20021115-merge:1.27
	binutils-2_13_1:1.25.2.2
	kseitz_interps-20021105-merge:1.27
	kseitz_interps-20021103-merge:1.27
	drow-cplus-merge-20021020:1.26
	drow-cplus-merge-20021025:1.26
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.26
	drow-cplus-branch:1.25.0.14
	drow-cplus-branchpoint:1.25
	kseitz_interps-20020930-merge:1.25
	carlton_dictionary-20020927-merge:1.25
	carlton_dictionary-branch:1.25.0.12
	carlton_dictionary-20020920-branchpoint:1.25
	sid-20020905-branchpoint:1.25
	sid-20020905-branch:1.25.0.10
	gdb_5_3-branch:1.25.0.8
	gdb_5_3-2002-09-04-branchpoint:1.25
	kseitz_interps-20020829-merge:1.25
	cagney_sysregs-20020825-branch:1.25.0.6
	cagney_sysregs-20020825-branchpoint:1.25
	readline_4_3-import-branch:1.25.0.4
	readline_4_3-import-branchpoint:1.25
	binutils-2_13:1.25
	gdb_5_2_1-2002-07-23-release:1.19
	binutils-2_13-branchpoint:1.25
	binutils-2_13-branch:1.25.0.2
	kseitz_interps-20020528-branch:1.23.0.2
	kseitz_interps-20020528-branchpoint:1.23
	cagney_regbuf-20020515-branch:1.21.0.4
	cagney_regbuf-20020515-branchpoint:1.21
	binutils-2_12_1:1.18.2.1
	jimb-macro-020506-branch:1.21.0.2
	jimb-macro-020506-branchpoint:1.21
	gdb_5_2-2002-04-29-release:1.19
	binutils-2_12:1.18
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	binutils-2_12-branch:1.18.0.2
	binutils-2_12-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	insight-precleanup-2001-01-01:1.5
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.4
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.97
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.97
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2012.10.21.03.23.37;	author hp;	state Exp;
branches;
next	1.95;

1.95
date	2012.05.05.04.51.15;	author amodra;	state Exp;
branches
	1.95.4.1;
next	1.94;

1.94
date	2012.04.24.05.12.38;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2012.03.23.09.27.42;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2012.02.13.18.08.50;	author rth;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.31.17.54.36;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.16.01.15.19;	author hjl;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2011.08.05.03.17.11;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2011.07.14.06.22.57;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2011.07.09.06.20.51;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2011.06.13.00.59.15;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.10.14.04.24;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2011.05.17.13.02.18;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.15.23.44.07;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2011.04.24.10.02.13;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.20.00.22.08;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.20.00.11.32;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.13.01.06.16;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2010.10.14.01.31.27;	author davek;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2009.11.23.14.41.30;	author pbrook;	state Exp;
branches;
next	1.75;

1.75
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2009.08.26.04.33.42;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2009.08.26.01.21.56;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2009.07.31.02.25.56;	author hp;	state Exp;
branches;
next	1.69;

1.69
date	2009.05.04.12.09.29;	author davek;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.16.23.06.59;	author rsandifo;	state Exp;
branches;
next	1.67;

1.67
date	2009.04.07.20.04.08;	author hjl;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.03.09.40.48;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.17.03.12.49;	author amodra;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2007.07.27.01.04.29;	author msnyder;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.26.21.58.44;	author msnyder;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.26.21.53.35;	author msnyder;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.24.23.38.13;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.30.23.25.50;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.23.02.35.38;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.27.03.06.27;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.24.11.24.31;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.04.01.19.04;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2005.05.04.15.53.35;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.04.11.00.23;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.04.07.19.30;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.11.22.21.23;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.03.13.54.30;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.03.03.30.49;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.01.01.11.16;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.21.15.28.30;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.13.03.16.00;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.27.14.20.49;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.29.14.13.44;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.24.04.46.24;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.22.22.58.02;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.02.22.59.59;	author amodra;	state Exp;
branches
	1.34.6.1
	1.34.8.1;
next	1.33;

1.33
date	2003.10.31.05.32.45;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.25.09.40.44;	author amodra;	state Exp;
branches
	1.25.2.1
	1.25.12.1
	1.25.14.1;
next	1.24;

1.24
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.22.05.06.18;	author hjl;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.05.15.00.18.57;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.15.02.10.34;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.09.21.02.12.28;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.11.18.10.20;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.24.16.36.04;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.24.03.56.28;	author ths;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.17.09.50.05;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.02.23.05.54;	author cwilson;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.05.22.40.16;	author wilson;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.10.22.59.29;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.03.19.26.07;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.14.18.13.40;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.13.22.10.36;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.19.49.41;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.04.13.25.23;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.95.4.1
date	2013.01.21.13.48.37;	author amodra;	state Exp;
branches;
next	;

1.90.2.1
date	2012.05.11.12.24.32;	author nickc;	state Exp;
branches;
next	;

1.77.2.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2011.04.27.07.17.41;	author amodra;	state Exp;
branches;
next	1.77.2.3;

1.77.2.3
date	2011.05.29.04.51.17;	author amodra;	state Exp;
branches;
next	;

1.74.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.65.2.1
date	2009.03.02.13.32.54;	author amodra;	state Exp;
branches;
next	;

1.34.6.1
date	2004.03.22.23.14.32;	author amodra;	state Exp;
branches;
next	;

1.34.8.1
date	2004.03.27.17.37.38;	author drow;	state Exp;
branches;
next	1.34.8.2;

1.34.8.2
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	1.34.8.3;

1.34.8.3
date	2004.09.21.20.44.07;	author drow;	state Exp;
branches;
next	;

1.25.2.1
date	2002.10.11.08.56.14;	author amodra;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.10.28.18.45.45;	author drow;	state Exp;
branches;
next	;

1.25.12.1
date	2002.10.11.22.22.50;	author carlton;	state Exp;
branches;
next	1.25.12.2;

1.25.12.2
date	2002.10.25.23.49.49;	author carlton;	state Exp;
branches;
next	1.25.12.3;

1.25.12.3
date	2002.12.23.19.37.55;	author carlton;	state Exp;
branches;
next	1.25.12.4;

1.25.12.4
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.25.12.5;

1.25.12.5
date	2003.06.27.21.49.29;	author carlton;	state Exp;
branches;
next	1.25.12.6;

1.25.12.6
date	2003.08.05.17.12.55;	author carlton;	state Exp;
branches;
next	1.25.12.7;

1.25.12.7
date	2003.11.11.23.50.27;	author carlton;	state Exp;
branches;
next	1.25.12.8;

1.25.12.8
date	2003.12.15.23.59.50;	author carlton;	state Exp;
branches;
next	;

1.25.14.1
date	2002.10.26.17.12.00;	author drow;	state Exp;
branches;
next	1.25.14.2;

1.25.14.2
date	2003.12.14.20.26.49;	author drow;	state Exp;
branches;
next	;

1.23.2.1
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.11.03.22.01.37;	author ezannoni;	state Exp;
branches;
next	;

1.21.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.18.2.1
date	2002.04.04.14.53.01;	author amodra;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.18;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.97
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* linker.c -- BFD linker routines
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Written by Steve Chamberlain and Ian Lance Taylor, Cygnus Support

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "bfdlink.h"
#include "genlink.h"

/*
SECTION
	Linker Functions

@@cindex Linker
	The linker uses three special entry points in the BFD target
	vector.  It is not necessary to write special routines for
	these entry points when creating a new BFD back end, since
	generic versions are provided.  However, writing them can
	speed up linking and make it use significantly less runtime
	memory.

	The first routine creates a hash table used by the other
	routines.  The second routine adds the symbols from an object
	file to the hash table.  The third routine takes all the
	object files and links them together to create the output
	file.  These routines are designed so that the linker proper
	does not need to know anything about the symbols in the object
	files that it is linking.  The linker merely arranges the
	sections as directed by the linker script and lets BFD handle
	the details of symbols and relocs.

	The second routine and third routines are passed a pointer to
	a <<struct bfd_link_info>> structure (defined in
	<<bfdlink.h>>) which holds information relevant to the link,
	including the linker hash table (which was created by the
	first routine) and a set of callback functions to the linker
	proper.

	The generic linker routines are in <<linker.c>>, and use the
	header file <<genlink.h>>.  As of this writing, the only back
	ends which have implemented versions of these routines are
	a.out (in <<aoutx.h>>) and ECOFF (in <<ecoff.c>>).  The a.out
	routines are used as examples throughout this section.

@@menu
@@* Creating a Linker Hash Table::
@@* Adding Symbols to the Hash Table::
@@* Performing the Final Link::
@@end menu

INODE
Creating a Linker Hash Table, Adding Symbols to the Hash Table, Linker Functions, Linker Functions
SUBSECTION
	Creating a linker hash table

@@cindex _bfd_link_hash_table_create in target vector
@@cindex target vector (_bfd_link_hash_table_create)
	The linker routines must create a hash table, which must be
	derived from <<struct bfd_link_hash_table>> described in
	<<bfdlink.c>>.  @@xref{Hash Tables}, for information on how to
	create a derived hash table.  This entry point is called using
	the target vector of the linker output file.

	The <<_bfd_link_hash_table_create>> entry point must allocate
	and initialize an instance of the desired hash table.  If the
	back end does not require any additional information to be
	stored with the entries in the hash table, the entry point may
	simply create a <<struct bfd_link_hash_table>>.  Most likely,
	however, some additional information will be needed.

	For example, with each entry in the hash table the a.out
	linker keeps the index the symbol has in the final output file
	(this index number is used so that when doing a relocatable
	link the symbol index used in the output file can be quickly
	filled in when copying over a reloc).  The a.out linker code
	defines the required structures and functions for a hash table
	derived from <<struct bfd_link_hash_table>>.  The a.out linker
	hash table is created by the function
	<<NAME(aout,link_hash_table_create)>>; it simply allocates
	space for the hash table, initializes it, and returns a
	pointer to it.

	When writing the linker routines for a new back end, you will
	generally not know exactly which fields will be required until
	you have finished.  You should simply create a new hash table
	which defines no additional fields, and then simply add fields
	as they become necessary.

INODE
Adding Symbols to the Hash Table, Performing the Final Link, Creating a Linker Hash Table, Linker Functions
SUBSECTION
	Adding symbols to the hash table

@@cindex _bfd_link_add_symbols in target vector
@@cindex target vector (_bfd_link_add_symbols)
	The linker proper will call the <<_bfd_link_add_symbols>>
	entry point for each object file or archive which is to be
	linked (typically these are the files named on the command
	line, but some may also come from the linker script).  The
	entry point is responsible for examining the file.  For an
	object file, BFD must add any relevant symbol information to
	the hash table.  For an archive, BFD must determine which
	elements of the archive should be used and adding them to the
	link.

	The a.out version of this entry point is
	<<NAME(aout,link_add_symbols)>>.

@@menu
@@* Differing file formats::
@@* Adding symbols from an object file::
@@* Adding symbols from an archive::
@@end menu

INODE
Differing file formats, Adding symbols from an object file, Adding Symbols to the Hash Table, Adding Symbols to the Hash Table
SUBSUBSECTION
	Differing file formats

	Normally all the files involved in a link will be of the same
	format, but it is also possible to link together different
	format object files, and the back end must support that.  The
	<<_bfd_link_add_symbols>> entry point is called via the target
	vector of the file to be added.  This has an important
	consequence: the function may not assume that the hash table
	is the type created by the corresponding
	<<_bfd_link_hash_table_create>> vector.  All the
	<<_bfd_link_add_symbols>> function can assume about the hash
	table is that it is derived from <<struct
	bfd_link_hash_table>>.

	Sometimes the <<_bfd_link_add_symbols>> function must store
	some information in the hash table entry to be used by the
	<<_bfd_final_link>> function.  In such a case the output bfd
	xvec must be checked to make sure that the hash table was
	created by an object file of the same format.

	The <<_bfd_final_link>> routine must be prepared to handle a
	hash entry without any extra information added by the
	<<_bfd_link_add_symbols>> function.  A hash entry without
	extra information will also occur when the linker script
	directs the linker to create a symbol.  Note that, regardless
	of how a hash table entry is added, all the fields will be
	initialized to some sort of null value by the hash table entry
	initialization function.

	See <<ecoff_link_add_externals>> for an example of how to
	check the output bfd before saving information (in this
	case, the ECOFF external symbol debugging information) in a
	hash table entry.

INODE
Adding symbols from an object file, Adding symbols from an archive, Differing file formats, Adding Symbols to the Hash Table
SUBSUBSECTION
	Adding symbols from an object file

	When the <<_bfd_link_add_symbols>> routine is passed an object
	file, it must add all externally visible symbols in that
	object file to the hash table.  The actual work of adding the
	symbol to the hash table is normally handled by the function
	<<_bfd_generic_link_add_one_symbol>>.  The
	<<_bfd_link_add_symbols>> routine is responsible for reading
	all the symbols from the object file and passing the correct
	information to <<_bfd_generic_link_add_one_symbol>>.

	The <<_bfd_link_add_symbols>> routine should not use
	<<bfd_canonicalize_symtab>> to read the symbols.  The point of
	providing this routine is to avoid the overhead of converting
	the symbols into generic <<asymbol>> structures.

@@findex _bfd_generic_link_add_one_symbol
	<<_bfd_generic_link_add_one_symbol>> handles the details of
	combining common symbols, warning about multiple definitions,
	and so forth.  It takes arguments which describe the symbol to
	add, notably symbol flags, a section, and an offset.  The
	symbol flags include such things as <<BSF_WEAK>> or
	<<BSF_INDIRECT>>.  The section is a section in the object
	file, or something like <<bfd_und_section_ptr>> for an undefined
	symbol or <<bfd_com_section_ptr>> for a common symbol.

	If the <<_bfd_final_link>> routine is also going to need to
	read the symbol information, the <<_bfd_link_add_symbols>>
	routine should save it somewhere attached to the object file
	BFD.  However, the information should only be saved if the
	<<keep_memory>> field of the <<info>> argument is TRUE, so
	that the <<-no-keep-memory>> linker switch is effective.

	The a.out function which adds symbols from an object file is
	<<aout_link_add_object_symbols>>, and most of the interesting
	work is in <<aout_link_add_symbols>>.  The latter saves
	pointers to the hash tables entries created by
	<<_bfd_generic_link_add_one_symbol>> indexed by symbol number,
	so that the <<_bfd_final_link>> routine does not have to call
	the hash table lookup routine to locate the entry.

INODE
Adding symbols from an archive, , Adding symbols from an object file, Adding Symbols to the Hash Table
SUBSUBSECTION
	Adding symbols from an archive

	When the <<_bfd_link_add_symbols>> routine is passed an
	archive, it must look through the symbols defined by the
	archive and decide which elements of the archive should be
	included in the link.  For each such element it must call the
	<<add_archive_element>> linker callback, and it must add the
	symbols from the object file to the linker hash table.  (The
	callback may in fact indicate that a replacement BFD should be
	used, in which case the symbols from that BFD should be added
	to the linker hash table instead.)

@@findex _bfd_generic_link_add_archive_symbols
	In most cases the work of looking through the symbols in the
	archive should be done by the
	<<_bfd_generic_link_add_archive_symbols>> function.  This
	function builds a hash table from the archive symbol table and
	looks through the list of undefined symbols to see which
	elements should be included.
	<<_bfd_generic_link_add_archive_symbols>> is passed a function
	to call to make the final decision about adding an archive
	element to the link and to do the actual work of adding the
	symbols to the linker hash table.

	The function passed to
	<<_bfd_generic_link_add_archive_symbols>> must read the
	symbols of the archive element and decide whether the archive
	element should be included in the link.  If the element is to
	be included, the <<add_archive_element>> linker callback
	routine must be called with the element as an argument, and
	the element's symbols must be added to the linker hash table
	just as though the element had itself been passed to the
	<<_bfd_link_add_symbols>> function.  The <<add_archive_element>>
	callback has the option to indicate that it would like to
	replace the element archive with a substitute BFD, in which
	case it is the symbols of that substitute BFD that must be
	added to the linker hash table instead.

	When the a.out <<_bfd_link_add_symbols>> function receives an
	archive, it calls <<_bfd_generic_link_add_archive_symbols>>
	passing <<aout_link_check_archive_element>> as the function
	argument. <<aout_link_check_archive_element>> calls
	<<aout_link_check_ar_symbols>>.  If the latter decides to add
	the element (an element is only added if it provides a real,
	non-common, definition for a previously undefined or common
	symbol) it calls the <<add_archive_element>> callback and then
	<<aout_link_check_archive_element>> calls
	<<aout_link_add_symbols>> to actually add the symbols to the
	linker hash table - possibly those of a substitute BFD, if the
	<<add_archive_element>> callback avails itself of that option.

	The ECOFF back end is unusual in that it does not normally
	call <<_bfd_generic_link_add_archive_symbols>>, because ECOFF
	archives already contain a hash table of symbols.  The ECOFF
	back end searches the archive itself to avoid the overhead of
	creating a new hash table.

INODE
Performing the Final Link, , Adding Symbols to the Hash Table, Linker Functions
SUBSECTION
	Performing the final link

@@cindex _bfd_link_final_link in target vector
@@cindex target vector (_bfd_final_link)
	When all the input files have been processed, the linker calls
	the <<_bfd_final_link>> entry point of the output BFD.  This
	routine is responsible for producing the final output file,
	which has several aspects.  It must relocate the contents of
	the input sections and copy the data into the output sections.
	It must build an output symbol table including any local
	symbols from the input files and the global symbols from the
	hash table.  When producing relocatable output, it must
	modify the input relocs and write them into the output file.
	There may also be object format dependent work to be done.

	The linker will also call the <<write_object_contents>> entry
	point when the BFD is closed.  The two entry points must work
	together in order to produce the correct output file.

	The details of how this works are inevitably dependent upon
	the specific object file format.  The a.out
	<<_bfd_final_link>> routine is <<NAME(aout,final_link)>>.

@@menu
@@* Information provided by the linker::
@@* Relocating the section contents::
@@* Writing the symbol table::
@@end menu

INODE
Information provided by the linker, Relocating the section contents, Performing the Final Link, Performing the Final Link
SUBSUBSECTION
	Information provided by the linker

	Before the linker calls the <<_bfd_final_link>> entry point,
	it sets up some data structures for the function to use.

	The <<input_bfds>> field of the <<bfd_link_info>> structure
	will point to a list of all the input files included in the
	link.  These files are linked through the <<link_next>> field
	of the <<bfd>> structure.

	Each section in the output file will have a list of
	<<link_order>> structures attached to the <<map_head.link_order>>
	field (the <<link_order>> structure is defined in
	<<bfdlink.h>>).  These structures describe how to create the
	contents of the output section in terms of the contents of
	various input sections, fill constants, and, eventually, other
	types of information.  They also describe relocs that must be
	created by the BFD backend, but do not correspond to any input
	file; this is used to support -Ur, which builds constructors
	while generating a relocatable object file.

INODE
Relocating the section contents, Writing the symbol table, Information provided by the linker, Performing the Final Link
SUBSUBSECTION
	Relocating the section contents

	The <<_bfd_final_link>> function should look through the
	<<link_order>> structures attached to each section of the
	output file.  Each <<link_order>> structure should either be
	handled specially, or it should be passed to the function
	<<_bfd_default_link_order>> which will do the right thing
	(<<_bfd_default_link_order>> is defined in <<linker.c>>).

	For efficiency, a <<link_order>> of type
	<<bfd_indirect_link_order>> whose associated section belongs
	to a BFD of the same format as the output BFD must be handled
	specially.  This type of <<link_order>> describes part of an
	output section in terms of a section belonging to one of the
	input files.  The <<_bfd_final_link>> function should read the
	contents of the section and any associated relocs, apply the
	relocs to the section contents, and write out the modified
	section contents.  If performing a relocatable link, the
	relocs themselves must also be modified and written out.

@@findex _bfd_relocate_contents
@@findex _bfd_final_link_relocate
	The functions <<_bfd_relocate_contents>> and
	<<_bfd_final_link_relocate>> provide some general support for
	performing the actual relocations, notably overflow checking.
	Their arguments include information about the symbol the
	relocation is against and a <<reloc_howto_type>> argument
	which describes the relocation to perform.  These functions
	are defined in <<reloc.c>>.

	The a.out function which handles reading, relocating, and
	writing section contents is <<aout_link_input_section>>.  The
	actual relocation is done in <<aout_link_input_section_std>>
	and <<aout_link_input_section_ext>>.

INODE
Writing the symbol table, , Relocating the section contents, Performing the Final Link
SUBSUBSECTION
	Writing the symbol table

	The <<_bfd_final_link>> function must gather all the symbols
	in the input files and write them out.  It must also write out
	all the symbols in the global hash table.  This must be
	controlled by the <<strip>> and <<discard>> fields of the
	<<bfd_link_info>> structure.

	The local symbols of the input files will not have been
	entered into the linker hash table.  The <<_bfd_final_link>>
	routine must consider each input file and include the symbols
	in the output file.  It may be convenient to do this when
	looking through the <<link_order>> structures, or it may be
	done by stepping through the <<input_bfds>> list.

	The <<_bfd_final_link>> routine must also traverse the global
	hash table to gather all the externally visible symbols.  It
	is possible that most of the externally visible symbols may be
	written out when considering the symbols of each input file,
	but it is still necessary to traverse the hash table since the
	linker script may have defined some symbols that are not in
	any of the input files.

	The <<strip>> field of the <<bfd_link_info>> structure
	controls which symbols are written out.  The possible values
	are listed in <<bfdlink.h>>.  If the value is <<strip_some>>,
	then the <<keep_hash>> field of the <<bfd_link_info>>
	structure is a hash table of symbols to keep; each symbol
	should be looked up in this hash table, and only symbols which
	are present should be included in the output file.

	If the <<strip>> field of the <<bfd_link_info>> structure
	permits local symbols to be written out, the <<discard>> field
	is used to further controls which local symbols are included
	in the output file.  If the value is <<discard_l>>, then all
	local symbols which begin with a certain prefix are discarded;
	this is controlled by the <<bfd_is_local_label_name>> entry point.

	The a.out backend handles symbols by calling
	<<aout_link_write_symbols>> on each input BFD and then
	traversing the global hash table with the function
	<<aout_link_write_other_symbol>>.  It builds a string table
	while writing out the symbols, which is written to the output
	file at the end of <<NAME(aout,final_link)>>.
*/

static bfd_boolean generic_link_add_object_symbols
  (bfd *, struct bfd_link_info *, bfd_boolean collect);
static bfd_boolean generic_link_add_symbols
  (bfd *, struct bfd_link_info *, bfd_boolean);
static bfd_boolean generic_link_check_archive_element_no_collect
  (bfd *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean generic_link_check_archive_element_collect
  (bfd *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean generic_link_check_archive_element
  (bfd *, struct bfd_link_info *, bfd_boolean *, bfd_boolean);
static bfd_boolean generic_link_add_symbol_list
  (bfd *, struct bfd_link_info *, bfd_size_type count, asymbol **,
   bfd_boolean);
static bfd_boolean generic_add_output_symbol
  (bfd *, size_t *psymalloc, asymbol *);
static bfd_boolean default_data_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
static bfd_boolean default_indirect_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *,
   bfd_boolean);

/* The link hash table structure is defined in bfdlink.h.  It provides
   a base hash table which the backend specific hash tables are built
   upon.  */

/* Routine to create an entry in the link hash table.  */

struct bfd_hash_entry *
_bfd_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *)
          bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry)
    {
      struct bfd_link_hash_entry *h = (struct bfd_link_hash_entry *) entry;

      /* Initialize the local fields.  */
      memset ((char *) &h->root + sizeof (h->root), 0,
	      sizeof (*h) - sizeof (h->root));
    }

  return entry;
}

/* Initialize a link hash table.  The BFD argument is the one
   responsible for creating this table.  */

bfd_boolean
_bfd_link_hash_table_init
  (struct bfd_link_hash_table *table,
   bfd *abfd ATTRIBUTE_UNUSED,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *),
   unsigned int entsize)
{
  table->undefs = NULL;
  table->undefs_tail = NULL;
  table->type = bfd_link_generic_hash_table;

  return bfd_hash_table_init (&table->table, newfunc, entsize);
}

/* Look up a symbol in a link hash table.  If follow is TRUE, we
   follow bfd_link_hash_indirect and bfd_link_hash_warning links to
   the real symbol.  */

struct bfd_link_hash_entry *
bfd_link_hash_lookup (struct bfd_link_hash_table *table,
		      const char *string,
		      bfd_boolean create,
		      bfd_boolean copy,
		      bfd_boolean follow)
{
  struct bfd_link_hash_entry *ret;

  ret = ((struct bfd_link_hash_entry *)
	 bfd_hash_lookup (&table->table, string, create, copy));

  if (follow && ret != NULL)
    {
      while (ret->type == bfd_link_hash_indirect
	     || ret->type == bfd_link_hash_warning)
	ret = ret->u.i.link;
    }

  return ret;
}

/* Look up a symbol in the main linker hash table if the symbol might
   be wrapped.  This should only be used for references to an
   undefined symbol, not for definitions of a symbol.  */

struct bfd_link_hash_entry *
bfd_wrapped_link_hash_lookup (bfd *abfd,
			      struct bfd_link_info *info,
			      const char *string,
			      bfd_boolean create,
			      bfd_boolean copy,
			      bfd_boolean follow)
{
  bfd_size_type amt;

  if (info->wrap_hash != NULL)
    {
      const char *l;
      char prefix = '\0';

      l = string;
      if (*l == bfd_get_symbol_leading_char (abfd) || *l == info->wrap_char)
	{
	  prefix = *l;
	  ++l;
	}

#undef WRAP
#define WRAP "__wrap_"

      if (bfd_hash_lookup (info->wrap_hash, l, FALSE, FALSE) != NULL)
	{
	  char *n;
	  struct bfd_link_hash_entry *h;

	  /* This symbol is being wrapped.  We want to replace all
             references to SYM with references to __wrap_SYM.  */

	  amt = strlen (l) + sizeof WRAP + 1;
	  n = (char *) bfd_malloc (amt);
	  if (n == NULL)
	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, WRAP);
	  strcat (n, l);
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
	  free (n);
	  return h;
	}

#undef WRAP

#undef  REAL
#define REAL "__real_"

      if (*l == '_'
	  && CONST_STRNEQ (l, REAL)
	  && bfd_hash_lookup (info->wrap_hash, l + sizeof REAL - 1,
			      FALSE, FALSE) != NULL)
	{
	  char *n;
	  struct bfd_link_hash_entry *h;

	  /* This is a reference to __real_SYM, where SYM is being
             wrapped.  We want to replace all references to __real_SYM
             with references to SYM.  */

	  amt = strlen (l + sizeof REAL - 1) + 2;
	  n = (char *) bfd_malloc (amt);
	  if (n == NULL)
	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, l + sizeof REAL - 1);
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
	  free (n);
	  return h;
	}

#undef REAL
    }

  return bfd_link_hash_lookup (info->hash, string, create, copy, follow);
}

/* Traverse a generic link hash table.  Differs from bfd_hash_traverse
   in the treatment of warning symbols.  When warning symbols are
   created they replace the real symbol, so you don't get to see the
   real symbol in a bfd_hash_travere.  This traversal calls func with
   the real symbol.  */

void
bfd_link_hash_traverse
  (struct bfd_link_hash_table *htab,
   bfd_boolean (*func) (struct bfd_link_hash_entry *, void *),
   void *info)
{
  unsigned int i;

  htab->table.frozen = 1;
  for (i = 0; i < htab->table.size; i++)
    {
      struct bfd_link_hash_entry *p;

      p = (struct bfd_link_hash_entry *) htab->table.table[i];
      for (; p != NULL; p = (struct bfd_link_hash_entry *) p->root.next)
	if (!(*func) (p->type == bfd_link_hash_warning ? p->u.i.link : p, info))
	  goto out;
    }
 out:
  htab->table.frozen = 0;
}

/* Add a symbol to the linker hash table undefs list.  */

void
bfd_link_add_undef (struct bfd_link_hash_table *table,
		    struct bfd_link_hash_entry *h)
{
  BFD_ASSERT (h->u.undef.next == NULL);
  if (table->undefs_tail != NULL)
    table->undefs_tail->u.undef.next = h;
  if (table->undefs == NULL)
    table->undefs = h;
  table->undefs_tail = h;
}

/* The undefs list was designed so that in normal use we don't need to
   remove entries.  However, if symbols on the list are changed from
   bfd_link_hash_undefined to either bfd_link_hash_undefweak or
   bfd_link_hash_new for some reason, then they must be removed from the
   list.  Failure to do so might result in the linker attempting to add
   the symbol to the list again at a later stage.  */

void
bfd_link_repair_undef_list (struct bfd_link_hash_table *table)
{
  struct bfd_link_hash_entry **pun;

  pun = &table->undefs;
  while (*pun != NULL)
    {
      struct bfd_link_hash_entry *h = *pun;

      if (h->type == bfd_link_hash_new
	  || h->type == bfd_link_hash_undefweak)
	{
	  *pun = h->u.undef.next;
	  h->u.undef.next = NULL;
	  if (h == table->undefs_tail)
	    {
	      if (pun == &table->undefs)
		table->undefs_tail = NULL;
	      else
		/* pun points at an u.undef.next field.  Go back to
		   the start of the link_hash_entry.  */
		table->undefs_tail = (struct bfd_link_hash_entry *)
		  ((char *) pun - ((char *) &h->u.undef.next - (char *) h));
	      break;
	    }
	}
      else
	pun = &h->u.undef.next;
    }
}

/* Routine to create an entry in a generic link hash table.  */

struct bfd_hash_entry *
_bfd_generic_link_hash_newfunc (struct bfd_hash_entry *entry,
				struct bfd_hash_table *table,
				const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry)
    {
      struct generic_link_hash_entry *ret;

      /* Set local fields.  */
      ret = (struct generic_link_hash_entry *) entry;
      ret->written = FALSE;
      ret->sym = NULL;
    }

  return entry;
}

/* Create a generic link hash table.  */

struct bfd_link_hash_table *
_bfd_generic_link_hash_table_create (bfd *abfd)
{
  struct generic_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct generic_link_hash_table);

  ret = (struct generic_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
  if (! _bfd_link_hash_table_init (&ret->root, abfd,
				   _bfd_generic_link_hash_newfunc,
				   sizeof (struct generic_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }
  return &ret->root;
}

void
_bfd_generic_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct generic_link_hash_table *ret
    = (struct generic_link_hash_table *) hash;

  bfd_hash_table_free (&ret->root.table);
  free (ret);
}

/* Grab the symbols for an object file when doing a generic link.  We
   store the symbols in the outsymbols field.  We need to keep them
   around for the entire link to ensure that we only read them once.
   If we read them multiple times, we might wind up with relocs and
   the hash table pointing to different instances of the symbol
   structure.  */

bfd_boolean
bfd_generic_link_read_symbols (bfd *abfd)
{
  if (bfd_get_outsymbols (abfd) == NULL)
    {
      long symsize;
      long symcount;

      symsize = bfd_get_symtab_upper_bound (abfd);
      if (symsize < 0)
	return FALSE;
      bfd_get_outsymbols (abfd) = (struct bfd_symbol **) bfd_alloc (abfd,
                                                                    symsize);
      if (bfd_get_outsymbols (abfd) == NULL && symsize != 0)
	return FALSE;
      symcount = bfd_canonicalize_symtab (abfd, bfd_get_outsymbols (abfd));
      if (symcount < 0)
	return FALSE;
      bfd_get_symcount (abfd) = symcount;
    }

  return TRUE;
}

/* Generic function to add symbols to from an object file to the
   global hash table.  This version does not automatically collect
   constructors by name.  */

bfd_boolean
_bfd_generic_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  return generic_link_add_symbols (abfd, info, FALSE);
}

/* Generic function to add symbols from an object file to the global
   hash table.  This version automatically collects constructors by
   name, as the collect2 program does.  It should be used for any
   target which does not provide some other mechanism for setting up
   constructors and destructors; these are approximately those targets
   for which gcc uses collect2 and do not support stabs.  */

bfd_boolean
_bfd_generic_link_add_symbols_collect (bfd *abfd, struct bfd_link_info *info)
{
  return generic_link_add_symbols (abfd, info, TRUE);
}

/* Indicate that we are only retrieving symbol values from this
   section.  We want the symbols to act as though the values in the
   file are absolute.  */

void
_bfd_generic_link_just_syms (asection *sec,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  sec->sec_info_type = SEC_INFO_TYPE_JUST_SYMS;
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
}

/* Copy the type of a symbol assiciated with a linker hast table entry.
   Override this so that symbols created in linker scripts get their
   type from the RHS of the assignment.
   The default implementation does nothing.  */
void
_bfd_generic_copy_link_hash_symbol_type (bfd *abfd ATTRIBUTE_UNUSED,
    struct bfd_link_hash_entry * hdest ATTRIBUTE_UNUSED,
    struct bfd_link_hash_entry * hsrc ATTRIBUTE_UNUSED)
{
}

/* Add symbols from an object file to the global hash table.  */

static bfd_boolean
generic_link_add_symbols (bfd *abfd,
			  struct bfd_link_info *info,
			  bfd_boolean collect)
{
  bfd_boolean ret;

  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      ret = generic_link_add_object_symbols (abfd, info, collect);
      break;
    case bfd_archive:
      ret = (_bfd_generic_link_add_archive_symbols
	     (abfd, info,
	      (collect
	       ? generic_link_check_archive_element_collect
	       : generic_link_check_archive_element_no_collect)));
      break;
    default:
      bfd_set_error (bfd_error_wrong_format);
      ret = FALSE;
    }

  return ret;
}

/* Add symbols from an object file to the global hash table.  */

static bfd_boolean
generic_link_add_object_symbols (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean collect)
{
  bfd_size_type symcount;
  struct bfd_symbol **outsyms;

  if (!bfd_generic_link_read_symbols (abfd))
    return FALSE;
  symcount = _bfd_generic_link_get_symcount (abfd);
  outsyms = _bfd_generic_link_get_symbols (abfd);
  return generic_link_add_symbol_list (abfd, info, symcount, outsyms, collect);
}

/* We build a hash table of all symbols defined in an archive.  */

/* An archive symbol may be defined by multiple archive elements.
   This linked list is used to hold the elements.  */

struct archive_list
{
  struct archive_list *next;
  unsigned int indx;
};

/* An entry in an archive hash table.  */

struct archive_hash_entry
{
  struct bfd_hash_entry root;
  /* Where the symbol is defined.  */
  struct archive_list *defs;
};

/* An archive hash table itself.  */

struct archive_hash_table
{
  struct bfd_hash_table table;
};

/* Create a new entry for an archive hash table.  */

static struct bfd_hash_entry *
archive_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *table,
		      const char *string)
{
  struct archive_hash_entry *ret = (struct archive_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct archive_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct archive_hash_entry));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct archive_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->defs = NULL;
    }

  return &ret->root;
}

/* Initialize an archive hash table.  */

static bfd_boolean
archive_hash_table_init
  (struct archive_hash_table *table,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *),
   unsigned int entsize)
{
  return bfd_hash_table_init (&table->table, newfunc, entsize);
}

/* Look up an entry in an archive hash table.  */

#define archive_hash_lookup(t, string, create, copy) \
  ((struct archive_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))

/* Allocate space in an archive hash table.  */

#define archive_hash_allocate(t, size) bfd_hash_allocate (&(t)->table, (size))

/* Free an archive hash table.  */

#define archive_hash_table_free(t) bfd_hash_table_free (&(t)->table)

/* Generic function to add symbols from an archive file to the global
   hash file.  This function presumes that the archive symbol table
   has already been read in (this is normally done by the
   bfd_check_format entry point).  It looks through the undefined and
   common symbols and searches the archive symbol table for them.  If
   it finds an entry, it includes the associated object file in the
   link.

   The old linker looked through the archive symbol table for
   undefined symbols.  We do it the other way around, looking through
   undefined symbols for symbols defined in the archive.  The
   advantage of the newer scheme is that we only have to look through
   the list of undefined symbols once, whereas the old method had to
   re-search the symbol table each time a new object file was added.

   The CHECKFN argument is used to see if an object file should be
   included.  CHECKFN should set *PNEEDED to TRUE if the object file
   should be included, and must also call the bfd_link_info
   add_archive_element callback function and handle adding the symbols
   to the global hash table.  CHECKFN must notice if the callback
   indicates a substitute BFD, and arrange to add those symbols instead
   if it does so.  CHECKFN should only return FALSE if some sort of
   error occurs.

   For some formats, such as a.out, it is possible to look through an
   object file but not actually include it in the link.  The
   archive_pass field in a BFD is used to avoid checking the symbols
   of an object files too many times.  When an object is included in
   the link, archive_pass is set to -1.  If an object is scanned but
   not included, archive_pass is set to the pass number.  The pass
   number is incremented each time a new object file is included.  The
   pass number is used because when a new object file is included it
   may create new undefined symbols which cause a previously examined
   object file to be included.  */

bfd_boolean
_bfd_generic_link_add_archive_symbols
  (bfd *abfd,
   struct bfd_link_info *info,
   bfd_boolean (*checkfn) (bfd *, struct bfd_link_info *, bfd_boolean *))
{
  carsym *arsyms;
  carsym *arsym_end;
  register carsym *arsym;
  int pass;
  struct archive_hash_table arsym_hash;
  unsigned int indx;
  struct bfd_link_hash_entry **pundef;

  if (! bfd_has_map (abfd))
    {
      /* An empty archive is a special case.  */
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
      bfd_set_error (bfd_error_no_armap);
      return FALSE;
    }

  arsyms = bfd_ardata (abfd)->symdefs;
  arsym_end = arsyms + bfd_ardata (abfd)->symdef_count;

  /* In order to quickly determine whether an symbol is defined in
     this archive, we build a hash table of the symbols.  */
  if (! archive_hash_table_init (&arsym_hash, archive_hash_newfunc,
				 sizeof (struct archive_hash_entry)))
    return FALSE;
  for (arsym = arsyms, indx = 0; arsym < arsym_end; arsym++, indx++)
    {
      struct archive_hash_entry *arh;
      struct archive_list *l, **pp;

      arh = archive_hash_lookup (&arsym_hash, arsym->name, TRUE, FALSE);
      if (arh == NULL)
	goto error_return;
      l = ((struct archive_list *)
	   archive_hash_allocate (&arsym_hash, sizeof (struct archive_list)));
      if (l == NULL)
	goto error_return;
      l->indx = indx;
      for (pp = &arh->defs; *pp != NULL; pp = &(*pp)->next)
	;
      *pp = l;
      l->next = NULL;
    }

  /* The archive_pass field in the archive itself is used to
     initialize PASS, sine we may search the same archive multiple
     times.  */
  pass = abfd->archive_pass + 1;

  /* New undefined symbols are added to the end of the list, so we
     only need to look through it once.  */
  pundef = &info->hash->undefs;
  while (*pundef != NULL)
    {
      struct bfd_link_hash_entry *h;
      struct archive_hash_entry *arh;
      struct archive_list *l;

      h = *pundef;

      /* When a symbol is defined, it is not necessarily removed from
	 the list.  */
      if (h->type != bfd_link_hash_undefined
	  && h->type != bfd_link_hash_common)
	{
	  /* Remove this entry from the list, for general cleanliness
	     and because we are going to look through the list again
	     if we search any more libraries.  We can't remove the
	     entry if it is the tail, because that would lose any
	     entries we add to the list later on (it would also cause
	     us to lose track of whether the symbol has been
	     referenced).  */
	  if (*pundef != info->hash->undefs_tail)
	    *pundef = (*pundef)->u.undef.next;
	  else
	    pundef = &(*pundef)->u.undef.next;
	  continue;
	}

      /* Look for this symbol in the archive symbol map.  */
      arh = archive_hash_lookup (&arsym_hash, h->root.string, FALSE, FALSE);
      if (arh == NULL)
	{
	  /* If we haven't found the exact symbol we're looking for,
	     let's look for its import thunk */
	  if (info->pei386_auto_import)
	    {
	      bfd_size_type amt = strlen (h->root.string) + 10;
	      char *buf = (char *) bfd_malloc (amt);
	      if (buf == NULL)
		return FALSE;

	      sprintf (buf, "__imp_%s", h->root.string);
	      arh = archive_hash_lookup (&arsym_hash, buf, FALSE, FALSE);
	      free(buf);
	    }
	  if (arh == NULL)
	    {
	      pundef = &(*pundef)->u.undef.next;
	      continue;
	    }
	}
      /* Look at all the objects which define this symbol.  */
      for (l = arh->defs; l != NULL; l = l->next)
	{
	  bfd *element;
	  bfd_boolean needed;

	  /* If the symbol has gotten defined along the way, quit.  */
	  if (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common)
	    break;

	  element = bfd_get_elt_at_index (abfd, l->indx);
	  if (element == NULL)
	    goto error_return;

	  /* If we've already included this element, or if we've
	     already checked it on this pass, continue.  */
	  if (element->archive_pass == -1
	      || element->archive_pass == pass)
	    continue;

	  /* If we can't figure this element out, just ignore it.  */
	  if (! bfd_check_format (element, bfd_object))
	    {
	      element->archive_pass = -1;
	      continue;
	    }

	  /* CHECKFN will see if this element should be included, and
	     go ahead and include it if appropriate.  */
	  if (! (*checkfn) (element, info, &needed))
	    goto error_return;

	  if (! needed)
	    element->archive_pass = pass;
	  else
	    {
	      element->archive_pass = -1;

	      /* Increment the pass count to show that we may need to
		 recheck object files which were already checked.  */
	      ++pass;
	    }
	}

      pundef = &(*pundef)->u.undef.next;
    }

  archive_hash_table_free (&arsym_hash);

  /* Save PASS in case we are called again.  */
  abfd->archive_pass = pass;

  return TRUE;

 error_return:
  archive_hash_table_free (&arsym_hash);
  return FALSE;
}

/* See if we should include an archive element.  This version is used
   when we do not want to automatically collect constructors based on
   the symbol name, presumably because we have some other mechanism
   for finding them.  */

static bfd_boolean
generic_link_check_archive_element_no_collect (
					       bfd *abfd,
					       struct bfd_link_info *info,
					       bfd_boolean *pneeded)
{
  return generic_link_check_archive_element (abfd, info, pneeded, FALSE);
}

/* See if we should include an archive element.  This version is used
   when we want to automatically collect constructors based on the
   symbol name, as collect2 does.  */

static bfd_boolean
generic_link_check_archive_element_collect (bfd *abfd,
					    struct bfd_link_info *info,
					    bfd_boolean *pneeded)
{
  return generic_link_check_archive_element (abfd, info, pneeded, TRUE);
}

/* See if we should include an archive element.  Optionally collect
   constructors.  */

static bfd_boolean
generic_link_check_archive_element (bfd *abfd,
				    struct bfd_link_info *info,
				    bfd_boolean *pneeded,
				    bfd_boolean collect)
{
  asymbol **pp, **ppend;

  *pneeded = FALSE;

  if (!bfd_generic_link_read_symbols (abfd))
    return FALSE;

  pp = _bfd_generic_link_get_symbols (abfd);
  ppend = pp + _bfd_generic_link_get_symcount (abfd);
  for (; pp < ppend; pp++)
    {
      asymbol *p;
      struct bfd_link_hash_entry *h;

      p = *pp;

      /* We are only interested in globally visible symbols.  */
      if (! bfd_is_com_section (p->section)
	  && (p->flags & (BSF_GLOBAL | BSF_INDIRECT | BSF_WEAK)) == 0)
	continue;

      /* We are only interested if we know something about this
	 symbol, and it is undefined or common.  An undefined weak
	 symbol (type bfd_link_hash_undefweak) is not considered to be
	 a reference when pulling files out of an archive.  See the
	 SVR4 ABI, p. 4-27.  */
      h = bfd_link_hash_lookup (info->hash, bfd_asymbol_name (p), FALSE,
				FALSE, TRUE);
      if (h == NULL
	  || (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common))
	continue;

      /* P is a symbol we are looking for.  */

      if (! bfd_is_com_section (p->section))
	{
	  bfd_size_type symcount;
	  asymbol **symbols;
	  bfd *oldbfd = abfd;

	  /* This object file defines this symbol, so pull it in.  */
	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, bfd_asymbol_name (p),
					&abfd))
	    return FALSE;
	  /* Potentially, the add_archive_element hook may have set a
	     substitute BFD for us.  */
	  if (abfd != oldbfd
	      && !bfd_generic_link_read_symbols (abfd))
	    return FALSE;
	  symcount = _bfd_generic_link_get_symcount (abfd);
	  symbols = _bfd_generic_link_get_symbols (abfd);
	  if (! generic_link_add_symbol_list (abfd, info, symcount,
					      symbols, collect))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}

      /* P is a common symbol.  */

      if (h->type == bfd_link_hash_undefined)
	{
	  bfd *symbfd;
	  bfd_vma size;
	  unsigned int power;

	  symbfd = h->u.undef.abfd;
	  if (symbfd == NULL)
	    {
	      /* This symbol was created as undefined from outside
		 BFD.  We assume that we should link in the object
		 file.  This is for the -u option in the linker.  */
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, bfd_asymbol_name (p),
					    &abfd))
		return FALSE;
	      /* Potentially, the add_archive_element hook may have set a
		 substitute BFD for us.  But no symbols are going to get
		 registered by anything we're returning to from here.  */
	      *pneeded = TRUE;
	      return TRUE;
	    }

	  /* Turn the symbol into a common symbol but do not link in
	     the object file.  This is how a.out works.  Object
	     formats that require different semantics must implement
	     this function differently.  This symbol is already on the
	     undefs list.  We add the section to a common section
	     attached to symbfd to ensure that it is in a BFD which
	     will be linked in.  */
	  h->type = bfd_link_hash_common;
	  h->u.c.p = (struct bfd_link_hash_common_entry *)
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
	  if (h->u.c.p == NULL)
	    return FALSE;

	  size = bfd_asymbol_value (p);
	  h->u.c.size = size;

	  power = bfd_log2 (size);
	  if (power > 4)
	    power = 4;
	  h->u.c.p->alignment_power = power;

	  if (p->section == bfd_com_section_ptr)
	    h->u.c.p->section = bfd_make_section_old_way (symbfd, "COMMON");
	  else
	    h->u.c.p->section = bfd_make_section_old_way (symbfd,
							  p->section->name);
	  h->u.c.p->section->flags |= SEC_ALLOC;
	}
      else
	{
	  /* Adjust the size of the common symbol if necessary.  This
	     is how a.out works.  Object formats that require
	     different semantics must implement this function
	     differently.  */
	  if (bfd_asymbol_value (p) > h->u.c.size)
	    h->u.c.size = bfd_asymbol_value (p);
	}
    }

  /* This archive element is not needed.  */
  return TRUE;
}

/* Add the symbols from an object file to the global hash table.  ABFD
   is the object file.  INFO is the linker information.  SYMBOL_COUNT
   is the number of symbols.  SYMBOLS is the list of symbols.  COLLECT
   is TRUE if constructors should be automatically collected by name
   as is done by collect2.  */

static bfd_boolean
generic_link_add_symbol_list (bfd *abfd,
			      struct bfd_link_info *info,
			      bfd_size_type symbol_count,
			      asymbol **symbols,
			      bfd_boolean collect)
{
  asymbol **pp, **ppend;

  pp = symbols;
  ppend = symbols + symbol_count;
  for (; pp < ppend; pp++)
    {
      asymbol *p;

      p = *pp;

      if ((p->flags & (BSF_INDIRECT
		       | BSF_WARNING
		       | BSF_GLOBAL
		       | BSF_CONSTRUCTOR
		       | BSF_WEAK)) != 0
	  || bfd_is_und_section (bfd_get_section (p))
	  || bfd_is_com_section (bfd_get_section (p))
	  || bfd_is_ind_section (bfd_get_section (p)))
	{
	  const char *name;
	  const char *string;
	  struct generic_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

	  string = name = bfd_asymbol_name (p);
	  if (((p->flags & BSF_INDIRECT) != 0
	       || bfd_is_ind_section (p->section))
	      && pp + 1 < ppend)
	    {
	      pp++;
	      string = bfd_asymbol_name (*pp);
	    }
	  else if ((p->flags & BSF_WARNING) != 0
		   && pp + 1 < ppend)
	    {
	      /* The name of P is actually the warning string, and the
		 next symbol is the one to warn about.  */
	      pp++;
	      name = bfd_asymbol_name (*pp);
	    }

	  bh = NULL;
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, name, p->flags, bfd_get_section (p),
		  p->value, string, FALSE, collect, &bh)))
	    return FALSE;
	  h = (struct generic_link_hash_entry *) bh;

	  /* If this is a constructor symbol, and the linker didn't do
             anything with it, then we want to just pass the symbol
             through to the output file.  This will happen when
             linking with -r.  */
	  if ((p->flags & BSF_CONSTRUCTOR) != 0
	      && (h == NULL || h->root.type == bfd_link_hash_new))
	    {
	      p->udata.p = NULL;
	      continue;
	    }

	  /* Save the BFD symbol so that we don't lose any backend
	     specific information that may be attached to it.  We only
	     want this one if it gives more information than the
	     existing one; we don't want to replace a defined symbol
	     with an undefined one.  This routine may be called with a
	     hash table other than the generic hash table, so we only
	     do this if we are certain that the hash table is a
	     generic one.  */
	  if (info->output_bfd->xvec == abfd->xvec)
	    {
	      if (h->sym == NULL
		  || (! bfd_is_und_section (bfd_get_section (p))
		      && (! bfd_is_com_section (bfd_get_section (p))
			  || bfd_is_und_section (bfd_get_section (h->sym)))))
		{
		  h->sym = p;
		  /* BSF_OLD_COMMON is a hack to support COFF reloc
		     reading, and it should go away when the COFF
		     linker is switched to the new version.  */
		  if (bfd_is_com_section (bfd_get_section (p)))
		    p->flags |= BSF_OLD_COMMON;
		}
	    }

	  /* Store a back pointer from the symbol to the hash
	     table entry for the benefit of relaxation code until
	     it gets rewritten to not use asymbol structures.
	     Setting this is also used to check whether these
	     symbols were set up by the generic linker.  */
	  p->udata.p = h;
	}
    }

  return TRUE;
}

/* We use a state table to deal with adding symbols from an object
   file.  The first index into the state table describes the symbol
   from the object file.  The second index into the state table is the
   type of the symbol in the hash table.  */

/* The symbol from the object file is turned into one of these row
   values.  */

enum link_row
{
  UNDEF_ROW,		/* Undefined.  */
  UNDEFW_ROW,		/* Weak undefined.  */
  DEF_ROW,		/* Defined.  */
  DEFW_ROW,		/* Weak defined.  */
  COMMON_ROW,		/* Common.  */
  INDR_ROW,		/* Indirect.  */
  WARN_ROW,		/* Warning.  */
  SET_ROW		/* Member of set.  */
};

/* apparently needed for Hitachi 3050R(HI-UX/WE2)? */
#undef FAIL

/* The actions to take in the state table.  */

enum link_action
{
  FAIL,		/* Abort.  */
  UND,		/* Mark symbol undefined.  */
  WEAK,		/* Mark symbol weak undefined.  */
  DEF,		/* Mark symbol defined.  */
  DEFW,		/* Mark symbol weak defined.  */
  COM,		/* Mark symbol common.  */
  REF,		/* Mark defined symbol referenced.  */
  CREF,		/* Possibly warn about common reference to defined symbol.  */
  CDEF,		/* Define existing common symbol.  */
  NOACT,	/* No action.  */
  BIG,		/* Mark symbol common using largest size.  */
  MDEF,		/* Multiple definition error.  */
  MIND,		/* Multiple indirect symbols.  */
  IND,		/* Make indirect symbol.  */
  CIND,		/* Make indirect symbol from existing common symbol.  */
  SET,		/* Add value to set.  */
  MWARN,	/* Make warning symbol.  */
  WARN,		/* Issue warning.  */
  CWARN,	/* Warn if referenced, else MWARN.  */
  CYCLE,	/* Repeat with symbol pointed to.  */
  REFC,		/* Mark indirect symbol referenced and then CYCLE.  */
  WARNC		/* Issue warning and then CYCLE.  */
};

/* The state table itself.  The first index is a link_row and the
   second index is a bfd_link_hash_type.  */

static const enum link_action link_action[8][8] =
{
  /* current\prev    new    undef  undefw def    defw   com    indr   warn  */
  /* UNDEF_ROW 	*/  {UND,   NOACT, UND,   REF,   REF,   NOACT, REFC,  WARNC },
  /* UNDEFW_ROW	*/  {WEAK,  NOACT, NOACT, REF,   REF,   NOACT, REFC,  WARNC },
  /* DEF_ROW 	*/  {DEF,   DEF,   DEF,   MDEF,  DEF,   CDEF,  MDEF,  CYCLE },
  /* DEFW_ROW 	*/  {DEFW,  DEFW,  DEFW,  NOACT, NOACT, NOACT, NOACT, CYCLE },
  /* COMMON_ROW	*/  {COM,   COM,   COM,   CREF,  COM,   BIG,   REFC,  WARNC },
  /* INDR_ROW	*/  {IND,   IND,   IND,   MDEF,  IND,   CIND,  MIND,  CYCLE },
  /* WARN_ROW   */  {MWARN, WARN,  WARN,  CWARN, CWARN, WARN,  CWARN, NOACT },
  /* SET_ROW	*/  {SET,   SET,   SET,   SET,   SET,   SET,   CYCLE, CYCLE }
};

/* Most of the entries in the LINK_ACTION table are straightforward,
   but a few are somewhat subtle.

   A reference to an indirect symbol (UNDEF_ROW/indr or
   UNDEFW_ROW/indr) is counted as a reference both to the indirect
   symbol and to the symbol the indirect symbol points to.

   A reference to a warning symbol (UNDEF_ROW/warn or UNDEFW_ROW/warn)
   causes the warning to be issued.

   A common definition of an indirect symbol (COMMON_ROW/indr) is
   treated as a multiple definition error.  Likewise for an indirect
   definition of a common symbol (INDR_ROW/com).

   An indirect definition of a warning (INDR_ROW/warn) does not cause
   the warning to be issued.

   If a warning is created for an indirect symbol (WARN_ROW/indr) no
   warning is created for the symbol the indirect symbol points to.

   Adding an entry to a set does not count as a reference to a set,
   and no warning is issued (SET_ROW/warn).  */

/* Return the BFD in which a hash entry has been defined, if known.  */

static bfd *
hash_entry_bfd (struct bfd_link_hash_entry *h)
{
  while (h->type == bfd_link_hash_warning)
    h = h->u.i.link;
  switch (h->type)
    {
    default:
      return NULL;
    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      return h->u.undef.abfd;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      return h->u.def.section->owner;
    case bfd_link_hash_common:
      return h->u.c.p->section->owner;
    }
  /*NOTREACHED*/
}

/* Add a symbol to the global hash table.
   ABFD is the BFD the symbol comes from.
   NAME is the name of the symbol.
   FLAGS is the BSF_* bits associated with the symbol.
   SECTION is the section in which the symbol is defined; this may be
     bfd_und_section_ptr or bfd_com_section_ptr.
   VALUE is the value of the symbol, relative to the section.
   STRING is used for either an indirect symbol, in which case it is
     the name of the symbol to indirect to, or a warning symbol, in
     which case it is the warning string.
   COPY is TRUE if NAME or STRING must be copied into locally
     allocated memory if they need to be saved.
   COLLECT is TRUE if we should automatically collect gcc constructor
     or destructor names as collect2 does.
   HASHP, if not NULL, is a place to store the created hash table
     entry; if *HASHP is not NULL, the caller has already looked up
     the hash table entry, and stored it in *HASHP.  */

bfd_boolean
_bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
				  bfd *abfd,
				  const char *name,
				  flagword flags,
				  asection *section,
				  bfd_vma value,
				  const char *string,
				  bfd_boolean copy,
				  bfd_boolean collect,
				  struct bfd_link_hash_entry **hashp)
{
  enum link_row row;
  struct bfd_link_hash_entry *h;
  bfd_boolean cycle;

  BFD_ASSERT (section != NULL);

  if (bfd_is_ind_section (section)
      || (flags & BSF_INDIRECT) != 0)
    row = INDR_ROW;
  else if ((flags & BSF_WARNING) != 0)
    row = WARN_ROW;
  else if ((flags & BSF_CONSTRUCTOR) != 0)
    row = SET_ROW;
  else if (bfd_is_und_section (section))
    {
      if ((flags & BSF_WEAK) != 0)
	row = UNDEFW_ROW;
      else
	row = UNDEF_ROW;
    }
  else if ((flags & BSF_WEAK) != 0)
    row = DEFW_ROW;
  else if (bfd_is_com_section (section))
    row = COMMON_ROW;
  else
    row = DEF_ROW;

  if (hashp != NULL && *hashp != NULL)
    h = *hashp;
  else
    {
      if (row == UNDEF_ROW || row == UNDEFW_ROW)
	h = bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE);
      else
	h = bfd_link_hash_lookup (info->hash, name, TRUE, copy, FALSE);
      if (h == NULL)
	{
	  if (hashp != NULL)
	    *hashp = NULL;
	  return FALSE;
	}
    }

  if (info->notice_all
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
    {
      if (! (*info->callbacks->notice) (info, h,
					abfd, section, value, flags, string))
	return FALSE;
    }

  if (hashp != NULL)
    *hashp = h;

  do
    {
      enum link_action action;

      cycle = FALSE;
      action = link_action[(int) row][(int) h->type];
      switch (action)
	{
	case FAIL:
	  abort ();

	case NOACT:
	  /* Do nothing.  */
	  break;

	case UND:
	  /* Make a new undefined symbol.  */
	  h->type = bfd_link_hash_undefined;
	  h->u.undef.abfd = abfd;
	  bfd_link_add_undef (info->hash, h);
	  break;

	case WEAK:
	  /* Make a new weak undefined symbol.  */
	  h->type = bfd_link_hash_undefweak;
	  h->u.undef.abfd = abfd;
	  break;

	case CDEF:
	  /* We have found a definition for a symbol which was
	     previously common.  */
	  BFD_ASSERT (h->type == bfd_link_hash_common);
	  if (! ((*info->callbacks->multiple_common)
		 (info, h, abfd, bfd_link_hash_defined, 0)))
	    return FALSE;
	  /* Fall through.  */
	case DEF:
	case DEFW:
	  {
	    enum bfd_link_hash_type oldtype;

	    /* Define a symbol.  */
	    oldtype = h->type;
	    if (action == DEFW)
	      h->type = bfd_link_hash_defweak;
	    else
	      h->type = bfd_link_hash_defined;
	    h->u.def.section = section;
	    h->u.def.value = value;

	    /* If we have been asked to, we act like collect2 and
	       identify all functions that might be global
	       constructors and destructors and pass them up in a
	       callback.  We only do this for certain object file
	       types, since many object file types can handle this
	       automatically.  */
	    if (collect && name[0] == '_')
	      {
		const char *s;

		/* A constructor or destructor name starts like this:
		   _+GLOBAL_[_.$][ID][_.$] where the first [_.$] and
		   the second are the same character (we accept any
		   character there, in case a new object file format
		   comes along with even worse naming restrictions).  */

#define CONS_PREFIX "GLOBAL_"
#define CONS_PREFIX_LEN (sizeof CONS_PREFIX - 1)

		s = name + 1;
		while (*s == '_')
		  ++s;
		if (s[0] == 'G' && CONST_STRNEQ (s, CONS_PREFIX))
		  {
		    char c;

		    c = s[CONS_PREFIX_LEN + 1];
		    if ((c == 'I' || c == 'D')
			&& s[CONS_PREFIX_LEN] == s[CONS_PREFIX_LEN + 2])
		      {
			/* If this is a definition of a symbol which
                           was previously weakly defined, we are in
                           trouble.  We have already added a
                           constructor entry for the weak defined
                           symbol, and now we are trying to add one
                           for the new symbol.  Fortunately, this case
                           should never arise in practice.  */
			if (oldtype == bfd_link_hash_defweak)
			  abort ();

			if (! ((*info->callbacks->constructor)
			       (info, c == 'I',
				h->root.string, abfd, section, value)))
			  return FALSE;
		      }
		  }
	      }
	  }

	  break;

	case COM:
	  /* We have found a common definition for a symbol.  */
	  if (h->type == bfd_link_hash_new)
	    bfd_link_add_undef (info->hash, h);
	  h->type = bfd_link_hash_common;
	  h->u.c.p = (struct bfd_link_hash_common_entry *)
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
	  if (h->u.c.p == NULL)
	    return FALSE;

	  h->u.c.size = value;

	  /* Select a default alignment based on the size.  This may
             be overridden by the caller.  */
	  {
	    unsigned int power;

	    power = bfd_log2 (value);
	    if (power > 4)
	      power = 4;
	    h->u.c.p->alignment_power = power;
	  }

	  /* The section of a common symbol is only used if the common
             symbol is actually allocated.  It basically provides a
             hook for the linker script to decide which output section
             the common symbols should be put in.  In most cases, the
             section of a common symbol will be bfd_com_section_ptr,
             the code here will choose a common symbol section named
             "COMMON", and the linker script will contain *(COMMON) in
             the appropriate place.  A few targets use separate common
             sections for small symbols, and they require special
             handling.  */
	  if (section == bfd_com_section_ptr)
	    {
	      h->u.c.p->section = bfd_make_section_old_way (abfd, "COMMON");
	      h->u.c.p->section->flags |= SEC_ALLOC;
	    }
	  else if (section->owner != abfd)
	    {
	      h->u.c.p->section = bfd_make_section_old_way (abfd,
							    section->name);
	      h->u.c.p->section->flags |= SEC_ALLOC;
	    }
	  else
	    h->u.c.p->section = section;
	  break;

	case REF:
	  /* A reference to a defined symbol.  */
	  if (h->u.undef.next == NULL && info->hash->undefs_tail != h)
	    h->u.undef.next = h;
	  break;

	case BIG:
	  /* We have found a common definition for a symbol which
	     already had a common definition.  Use the maximum of the
	     two sizes, and use the section required by the larger symbol.  */
	  BFD_ASSERT (h->type == bfd_link_hash_common);
	  if (! ((*info->callbacks->multiple_common)
		 (info, h, abfd, bfd_link_hash_common, value)))
	    return FALSE;
	  if (value > h->u.c.size)
	    {
	      unsigned int power;

	      h->u.c.size = value;

	      /* Select a default alignment based on the size.  This may
		 be overridden by the caller.  */
	      power = bfd_log2 (value);
	      if (power > 4)
		power = 4;
	      h->u.c.p->alignment_power = power;

	      /* Some systems have special treatment for small commons,
		 hence we want to select the section used by the larger
		 symbol.  This makes sure the symbol does not go in a
		 small common section if it is now too large.  */
	      if (section == bfd_com_section_ptr)
		{
		  h->u.c.p->section
		    = bfd_make_section_old_way (abfd, "COMMON");
		  h->u.c.p->section->flags |= SEC_ALLOC;
		}
	      else if (section->owner != abfd)
		{
		  h->u.c.p->section
		    = bfd_make_section_old_way (abfd, section->name);
		  h->u.c.p->section->flags |= SEC_ALLOC;
		}
	      else
		h->u.c.p->section = section;
	    }
	  break;

	case CREF:
	  /* We have found a common definition for a symbol which
	     was already defined.  */
	  if (! ((*info->callbacks->multiple_common)
		 (info, h, abfd, bfd_link_hash_common, value)))
	    return FALSE;
	  break;

	case MIND:
	  /* Multiple indirect symbols.  This is OK if they both point
	     to the same symbol.  */
	  if (strcmp (h->u.i.link->root.string, string) == 0)
	    break;
	  /* Fall through.  */
	case MDEF:
	  /* Handle a multiple definition.  */
	  if (! ((*info->callbacks->multiple_definition)
		 (info, h, abfd, section, value)))
	    return FALSE;
	  break;

	case CIND:
	  /* Create an indirect symbol from an existing common symbol.  */
	  BFD_ASSERT (h->type == bfd_link_hash_common);
	  if (! ((*info->callbacks->multiple_common)
		 (info, h, abfd, bfd_link_hash_indirect, 0)))
	    return FALSE;
	  /* Fall through.  */
	case IND:
	  /* Create an indirect symbol.  */
	  {
	    struct bfd_link_hash_entry *inh;

	    /* STRING is the name of the symbol we want to indirect
	       to.  */
	    inh = bfd_wrapped_link_hash_lookup (abfd, info, string, TRUE,
						copy, FALSE);
	    if (inh == NULL)
	      return FALSE;
	    if (inh->type == bfd_link_hash_indirect
		&& inh->u.i.link == h)
	      {
		(*_bfd_error_handler)
		  (_("%B: indirect symbol `%s' to `%s' is a loop"),
		   abfd, name, string);
		bfd_set_error (bfd_error_invalid_operation);
		return FALSE;
	      }
	    if (inh->type == bfd_link_hash_new)
	      {
		inh->type = bfd_link_hash_undefined;
		inh->u.undef.abfd = abfd;
		bfd_link_add_undef (info->hash, inh);
	      }

	    /* If the indirect symbol has been referenced, we need to
	       push the reference down to the symbol we are
	       referencing.  */
	    if (h->type != bfd_link_hash_new)
	      {
		row = UNDEF_ROW;
		cycle = TRUE;
	      }

	    h->type = bfd_link_hash_indirect;
	    h->u.i.link = inh;
	  }
	  break;

	case SET:
	  /* Add an entry to a set.  */
	  if (! (*info->callbacks->add_to_set) (info, h, BFD_RELOC_CTOR,
						abfd, section, value))
	    return FALSE;
	  break;

	case WARNC:
	  /* Issue a warning and cycle.  */
	  if (h->u.i.warning != NULL)
	    {
	      if (! (*info->callbacks->warning) (info, h->u.i.warning,
						 h->root.string, abfd,
						 NULL, 0))
		return FALSE;
	      /* Only issue a warning once.  */
	      h->u.i.warning = NULL;
	    }
	  /* Fall through.  */
	case CYCLE:
	  /* Try again with the referenced symbol.  */
	  h = h->u.i.link;
	  cycle = TRUE;
	  break;

	case REFC:
	  /* A reference to an indirect symbol.  */
	  if (h->u.undef.next == NULL && info->hash->undefs_tail != h)
	    h->u.undef.next = h;
	  h = h->u.i.link;
	  cycle = TRUE;
	  break;

	case WARN:
	  /* Issue a warning.  */
	  if (! (*info->callbacks->warning) (info, string, h->root.string,
					     hash_entry_bfd (h), NULL, 0))
	    return FALSE;
	  break;

	case CWARN:
	  /* Warn if this symbol has been referenced already,
	     otherwise add a warning.  A symbol has been referenced if
	     the u.undef.next field is not NULL, or it is the tail of the
	     undefined symbol list.  The REF case above helps to
	     ensure this.  */
	  if (h->u.undef.next != NULL || info->hash->undefs_tail == h)
	    {
	      if (! (*info->callbacks->warning) (info, string, h->root.string,
						 hash_entry_bfd (h), NULL, 0))
		return FALSE;
	      break;
	    }
	  /* Fall through.  */
	case MWARN:
	  /* Make a warning symbol.  */
	  {
	    struct bfd_link_hash_entry *sub;

	    /* STRING is the warning to give.  */
	    sub = ((struct bfd_link_hash_entry *)
		   ((*info->hash->table.newfunc)
		    (NULL, &info->hash->table, h->root.string)));
	    if (sub == NULL)
	      return FALSE;
	    *sub = *h;
	    sub->type = bfd_link_hash_warning;
	    sub->u.i.link = h;
	    if (! copy)
	      sub->u.i.warning = string;
	    else
	      {
		char *w;
		size_t len = strlen (string) + 1;

		w = (char *) bfd_hash_allocate (&info->hash->table, len);
		if (w == NULL)
		  return FALSE;
		memcpy (w, string, len);
		sub->u.i.warning = w;
	      }

	    bfd_hash_replace (&info->hash->table,
			      (struct bfd_hash_entry *) h,
			      (struct bfd_hash_entry *) sub);
	    if (hashp != NULL)
	      *hashp = sub;
	  }
	  break;
	}
    }
  while (cycle);

  return TRUE;
}

/* Generic final link routine.  */

bfd_boolean
_bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd *sub;
  asection *o;
  struct bfd_link_order *p;
  size_t outsymalloc;
  struct generic_write_global_symbol_info wginfo;

  bfd_get_outsymbols (abfd) = NULL;
  bfd_get_symcount (abfd) = 0;
  outsymalloc = 0;

  /* Mark all sections which will be included in the output file.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    for (p = o->map_head.link_order; p != NULL; p = p->next)
      if (p->type == bfd_indirect_link_order)
	p->u.indirect.section->linker_mark = TRUE;

  /* Build the output symbol table.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    if (! _bfd_generic_link_output_symbols (abfd, sub, info, &outsymalloc))
      return FALSE;

  /* Accumulate the global symbols.  */
  wginfo.info = info;
  wginfo.output_bfd = abfd;
  wginfo.psymalloc = &outsymalloc;
  _bfd_generic_link_hash_traverse (_bfd_generic_hash_table (info),
				   _bfd_generic_link_write_global_symbol,
				   &wginfo);

  /* Make sure we have a trailing NULL pointer on OUTSYMBOLS.  We
     shouldn't really need one, since we have SYMCOUNT, but some old
     code still expects one.  */
  if (! generic_add_output_symbol (abfd, &outsymalloc, NULL))
    return FALSE;

  if (info->relocatable)
    {
      /* Allocate space for the output relocs for each section.  */
      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  o->reloc_count = 0;
	  for (p = o->map_head.link_order; p != NULL; p = p->next)
	    {
	      if (p->type == bfd_section_reloc_link_order
		  || p->type == bfd_symbol_reloc_link_order)
		++o->reloc_count;
	      else if (p->type == bfd_indirect_link_order)
		{
		  asection *input_section;
		  bfd *input_bfd;
		  long relsize;
		  arelent **relocs;
		  asymbol **symbols;
		  long reloc_count;

		  input_section = p->u.indirect.section;
		  input_bfd = input_section->owner;
		  relsize = bfd_get_reloc_upper_bound (input_bfd,
						       input_section);
		  if (relsize < 0)
		    return FALSE;
		  relocs = (arelent **) bfd_malloc (relsize);
		  if (!relocs && relsize != 0)
		    return FALSE;
		  symbols = _bfd_generic_link_get_symbols (input_bfd);
		  reloc_count = bfd_canonicalize_reloc (input_bfd,
							input_section,
							relocs,
							symbols);
		  free (relocs);
		  if (reloc_count < 0)
		    return FALSE;
		  BFD_ASSERT ((unsigned long) reloc_count
			      == input_section->reloc_count);
		  o->reloc_count += reloc_count;
		}
	    }
	  if (o->reloc_count > 0)
	    {
	      bfd_size_type amt;

	      amt = o->reloc_count;
	      amt *= sizeof (arelent *);
	      o->orelocation = (struct reloc_cache_entry **) bfd_alloc (abfd, amt);
	      if (!o->orelocation)
		return FALSE;
	      o->flags |= SEC_RELOC;
	      /* Reset the count so that it can be used as an index
		 when putting in the output relocs.  */
	      o->reloc_count = 0;
	    }
	}
    }

  /* Handle all the link order information for the sections.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  switch (p->type)
	    {
	    case bfd_section_reloc_link_order:
	    case bfd_symbol_reloc_link_order:
	      if (! _bfd_generic_reloc_link_order (abfd, info, o, p))
		return FALSE;
	      break;
	    case bfd_indirect_link_order:
	      if (! default_indirect_link_order (abfd, info, o, p, TRUE))
		return FALSE;
	      break;
	    default:
	      if (! _bfd_default_link_order (abfd, info, o, p))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

/* Add an output symbol to the output BFD.  */

static bfd_boolean
generic_add_output_symbol (bfd *output_bfd, size_t *psymalloc, asymbol *sym)
{
  if (bfd_get_symcount (output_bfd) >= *psymalloc)
    {
      asymbol **newsyms;
      bfd_size_type amt;

      if (*psymalloc == 0)
	*psymalloc = 124;
      else
	*psymalloc *= 2;
      amt = *psymalloc;
      amt *= sizeof (asymbol *);
      newsyms = (asymbol **) bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
      if (newsyms == NULL)
	return FALSE;
      bfd_get_outsymbols (output_bfd) = newsyms;
    }

  bfd_get_outsymbols (output_bfd) [bfd_get_symcount (output_bfd)] = sym;
  if (sym != NULL)
    ++ bfd_get_symcount (output_bfd);

  return TRUE;
}

/* Handle the symbols for an input BFD.  */

bfd_boolean
_bfd_generic_link_output_symbols (bfd *output_bfd,
				  bfd *input_bfd,
				  struct bfd_link_info *info,
				  size_t *psymalloc)
{
  asymbol **sym_ptr;
  asymbol **sym_end;

  if (!bfd_generic_link_read_symbols (input_bfd))
    return FALSE;

  /* Create a filename symbol if we are supposed to.  */
  if (info->create_object_symbols_section != NULL)
    {
      asection *sec;

      for (sec = input_bfd->sections; sec != NULL; sec = sec->next)
	{
	  if (sec->output_section == info->create_object_symbols_section)
	    {
	      asymbol *newsym;

	      newsym = bfd_make_empty_symbol (input_bfd);
	      if (!newsym)
		return FALSE;
	      newsym->name = input_bfd->filename;
	      newsym->value = 0;
	      newsym->flags = BSF_LOCAL | BSF_FILE;
	      newsym->section = sec;

	      if (! generic_add_output_symbol (output_bfd, psymalloc,
					       newsym))
		return FALSE;

	      break;
	    }
	}
    }

  /* Adjust the values of the globally visible symbols, and write out
     local symbols.  */
  sym_ptr = _bfd_generic_link_get_symbols (input_bfd);
  sym_end = sym_ptr + _bfd_generic_link_get_symcount (input_bfd);
  for (; sym_ptr < sym_end; sym_ptr++)
    {
      asymbol *sym;
      struct generic_link_hash_entry *h;
      bfd_boolean output;

      h = NULL;
      sym = *sym_ptr;
      if ((sym->flags & (BSF_INDIRECT
			 | BSF_WARNING
			 | BSF_GLOBAL
			 | BSF_CONSTRUCTOR
			 | BSF_WEAK)) != 0
	  || bfd_is_und_section (bfd_get_section (sym))
	  || bfd_is_com_section (bfd_get_section (sym))
	  || bfd_is_ind_section (bfd_get_section (sym)))
	{
	  if (sym->udata.p != NULL)
	    h = (struct generic_link_hash_entry *) sym->udata.p;
	  else if ((sym->flags & BSF_CONSTRUCTOR) != 0)
	    {
	      /* This case normally means that the main linker code
                 deliberately ignored this constructor symbol.  We
                 should just pass it through.  This will screw up if
                 the constructor symbol is from a different,
                 non-generic, object file format, but the case will
                 only arise when linking with -r, which will probably
                 fail anyhow, since there will be no way to represent
                 the relocs in the output format being used.  */
	      h = NULL;
	    }
	  else if (bfd_is_und_section (bfd_get_section (sym)))
	    h = ((struct generic_link_hash_entry *)
		 bfd_wrapped_link_hash_lookup (output_bfd, info,
					       bfd_asymbol_name (sym),
					       FALSE, FALSE, TRUE));
	  else
	    h = _bfd_generic_link_hash_lookup (_bfd_generic_hash_table (info),
					       bfd_asymbol_name (sym),
					       FALSE, FALSE, TRUE);

	  if (h != NULL)
	    {
	      /* Force all references to this symbol to point to
		 the same area in memory.  It is possible that
		 this routine will be called with a hash table
		 other than a generic hash table, so we double
		 check that.  */
	      if (info->output_bfd->xvec == input_bfd->xvec)
		{
		  if (h->sym != NULL)
		    *sym_ptr = sym = h->sym;
		}

	      switch (h->root.type)
		{
		default:
		case bfd_link_hash_new:
		  abort ();
		case bfd_link_hash_undefined:
		  break;
		case bfd_link_hash_undefweak:
		  sym->flags |= BSF_WEAK;
		  break;
		case bfd_link_hash_indirect:
		  h = (struct generic_link_hash_entry *) h->root.u.i.link;
		  /* fall through */
		case bfd_link_hash_defined:
		  sym->flags |= BSF_GLOBAL;
		  sym->flags &=~ BSF_CONSTRUCTOR;
		  sym->value = h->root.u.def.value;
		  sym->section = h->root.u.def.section;
		  break;
		case bfd_link_hash_defweak:
		  sym->flags |= BSF_WEAK;
		  sym->flags &=~ BSF_CONSTRUCTOR;
		  sym->value = h->root.u.def.value;
		  sym->section = h->root.u.def.section;
		  break;
		case bfd_link_hash_common:
		  sym->value = h->root.u.c.size;
		  sym->flags |= BSF_GLOBAL;
		  if (! bfd_is_com_section (sym->section))
		    {
		      BFD_ASSERT (bfd_is_und_section (sym->section));
		      sym->section = bfd_com_section_ptr;
		    }
		  /* We do not set the section of the symbol to
		     h->root.u.c.p->section.  That value was saved so
		     that we would know where to allocate the symbol
		     if it was defined.  In this case the type is
		     still bfd_link_hash_common, so we did not define
		     it, so we do not want to use that section.  */
		  break;
		}
	    }
	}

      /* This switch is straight from the old code in
	 write_file_locals in ldsym.c.  */
      if (info->strip == strip_all
	  || (info->strip == strip_some
	      && bfd_hash_lookup (info->keep_hash, bfd_asymbol_name (sym),
				  FALSE, FALSE) == NULL))
	output = FALSE;
      else if ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
	{
	  /* If this symbol is marked as occurring now, rather
	     than at the end, output it now.  This is used for
	     COFF C_EXT FCN symbols.  FIXME: There must be a
	     better way.  */
	  if (bfd_asymbol_bfd (sym) == input_bfd
	      && (sym->flags & BSF_NOT_AT_END) != 0)
	    output = TRUE;
	  else
	    output = FALSE;
	}
      else if (bfd_is_ind_section (sym->section))
	output = FALSE;
      else if ((sym->flags & BSF_DEBUGGING) != 0)
	{
	  if (info->strip == strip_none)
	    output = TRUE;
	  else
	    output = FALSE;
	}
      else if (bfd_is_und_section (sym->section)
	       || bfd_is_com_section (sym->section))
	output = FALSE;
      else if ((sym->flags & BSF_LOCAL) != 0)
	{
	  if ((sym->flags & BSF_WARNING) != 0)
	    output = FALSE;
	  else
	    {
	      switch (info->discard)
		{
		default:
		case discard_all:
		  output = FALSE;
		  break;
		case discard_sec_merge:
		  output = TRUE;
		  if (info->relocatable
		      || ! (sym->section->flags & SEC_MERGE))
		    break;
		  /* FALLTHROUGH */
		case discard_l:
		  if (bfd_is_local_label (input_bfd, sym))
		    output = FALSE;
		  else
		    output = TRUE;
		  break;
		case discard_none:
		  output = TRUE;
		  break;
		}
	    }
	}
      else if ((sym->flags & BSF_CONSTRUCTOR))
	{
	  if (info->strip != strip_all)
	    output = TRUE;
	  else
	    output = FALSE;
	}
      else if (sym->flags == 0
	       && (sym->section->owner->flags & BFD_PLUGIN) != 0)
	/* LTO doesn't set symbol information.  We get here with the
	   generic linker for a symbol that was "common" but no longer
	   needs to be global.  */
	output = FALSE;
      else
	abort ();

      /* If this symbol is in a section which is not being included
	 in the output file, then we don't want to output the
	 symbol.  */
      if (!bfd_is_abs_section (sym->section)
	  && bfd_section_removed_from_list (output_bfd,
					    sym->section->output_section))
	output = FALSE;

      if (output)
	{
	  if (! generic_add_output_symbol (output_bfd, psymalloc, sym))
	    return FALSE;
	  if (h != NULL)
	    h->written = TRUE;
	}
    }

  return TRUE;
}

/* Set the section and value of a generic BFD symbol based on a linker
   hash table entry.  */

static void
set_symbol_from_hash (asymbol *sym, struct bfd_link_hash_entry *h)
{
  switch (h->type)
    {
    default:
      abort ();
      break;
    case bfd_link_hash_new:
      /* This can happen when a constructor symbol is seen but we are
         not building constructors.  */
      if (sym->section != NULL)
	{
	  BFD_ASSERT ((sym->flags & BSF_CONSTRUCTOR) != 0);
	}
      else
	{
	  sym->flags |= BSF_CONSTRUCTOR;
	  sym->section = bfd_abs_section_ptr;
	  sym->value = 0;
	}
      break;
    case bfd_link_hash_undefined:
      sym->section = bfd_und_section_ptr;
      sym->value = 0;
      break;
    case bfd_link_hash_undefweak:
      sym->section = bfd_und_section_ptr;
      sym->value = 0;
      sym->flags |= BSF_WEAK;
      break;
    case bfd_link_hash_defined:
      sym->section = h->u.def.section;
      sym->value = h->u.def.value;
      break;
    case bfd_link_hash_defweak:
      sym->flags |= BSF_WEAK;
      sym->section = h->u.def.section;
      sym->value = h->u.def.value;
      break;
    case bfd_link_hash_common:
      sym->value = h->u.c.size;
      if (sym->section == NULL)
	sym->section = bfd_com_section_ptr;
      else if (! bfd_is_com_section (sym->section))
	{
	  BFD_ASSERT (bfd_is_und_section (sym->section));
	  sym->section = bfd_com_section_ptr;
	}
      /* Do not set the section; see _bfd_generic_link_output_symbols.  */
      break;
    case bfd_link_hash_indirect:
    case bfd_link_hash_warning:
      /* FIXME: What should we do here?  */
      break;
    }
}

/* Write out a global symbol, if it hasn't already been written out.
   This is called for each symbol in the hash table.  */

bfd_boolean
_bfd_generic_link_write_global_symbol (struct generic_link_hash_entry *h,
				       void *data)
{
  struct generic_write_global_symbol_info *wginfo =
      (struct generic_write_global_symbol_info *) data;
  asymbol *sym;

  if (h->written)
    return TRUE;

  h->written = TRUE;

  if (wginfo->info->strip == strip_all
      || (wginfo->info->strip == strip_some
	  && bfd_hash_lookup (wginfo->info->keep_hash, h->root.root.string,
			      FALSE, FALSE) == NULL))
    return TRUE;

  if (h->sym != NULL)
    sym = h->sym;
  else
    {
      sym = bfd_make_empty_symbol (wginfo->output_bfd);
      if (!sym)
	return FALSE;
      sym->name = h->root.root.string;
      sym->flags = 0;
    }

  set_symbol_from_hash (sym, &h->root);

  sym->flags |= BSF_GLOBAL;

  if (! generic_add_output_symbol (wginfo->output_bfd, wginfo->psymalloc,
				   sym))
    {
      /* FIXME: No way to return failure.  */
      abort ();
    }

  return TRUE;
}

/* Create a relocation.  */

bfd_boolean
_bfd_generic_reloc_link_order (bfd *abfd,
			       struct bfd_link_info *info,
			       asection *sec,
			       struct bfd_link_order *link_order)
{
  arelent *r;

  if (! info->relocatable)
    abort ();
  if (sec->orelocation == NULL)
    abort ();

  r = (arelent *) bfd_alloc (abfd, sizeof (arelent));
  if (r == NULL)
    return FALSE;

  r->address = link_order->offset;
  r->howto = bfd_reloc_type_lookup (abfd, link_order->u.reloc.p->reloc);
  if (r->howto == 0)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* Get the symbol to use for the relocation.  */
  if (link_order->type == bfd_section_reloc_link_order)
    r->sym_ptr_ptr = link_order->u.reloc.p->u.section->symbol_ptr_ptr;
  else
    {
      struct generic_link_hash_entry *h;

      h = ((struct generic_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (abfd, info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h == NULL
	  || ! h->written)
	{
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      r->sym_ptr_ptr = &h->sym;
    }

  /* If this is an inplace reloc, write the addend to the object file.
     Otherwise, store it in the reloc addend.  */
  if (! r->howto->partial_inplace)
    r->addend = link_order->u.reloc.p->addend;
  else
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      bfd_boolean ok;
      file_ptr loc;

      size = bfd_get_reloc_size (r->howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
      rstat = _bfd_relocate_contents (r->howto, abfd,
				      (bfd_vma) link_order->u.reloc.p->addend,
				      buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*info->callbacks->reloc_overflow)
		 (info, NULL,
		  (link_order->type == bfd_section_reloc_link_order
		   ? bfd_section_name (abfd, link_order->u.reloc.p->u.section)
		   : link_order->u.reloc.p->u.name),
		  r->howto->name, link_order->u.reloc.p->addend,
		  NULL, NULL, 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      loc = link_order->offset * bfd_octets_per_byte (abfd);
      ok = bfd_set_section_contents (abfd, sec, buf, loc, size);
      free (buf);
      if (! ok)
	return FALSE;

      r->addend = 0;
    }

  sec->orelocation[sec->reloc_count] = r;
  ++sec->reloc_count;

  return TRUE;
}

/* Allocate a new link_order for a section.  */

struct bfd_link_order *
bfd_new_link_order (bfd *abfd, asection *section)
{
  bfd_size_type amt = sizeof (struct bfd_link_order);
  struct bfd_link_order *new_lo;

  new_lo = (struct bfd_link_order *) bfd_zalloc (abfd, amt);
  if (!new_lo)
    return NULL;

  new_lo->type = bfd_undefined_link_order;

  if (section->map_tail.link_order != NULL)
    section->map_tail.link_order->next = new_lo;
  else
    section->map_head.link_order = new_lo;
  section->map_tail.link_order = new_lo;

  return new_lo;
}

/* Default link order processing routine.  Note that we can not handle
   the reloc_link_order types here, since they depend upon the details
   of how the particular backends generates relocs.  */

bfd_boolean
_bfd_default_link_order (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 struct bfd_link_order *link_order)
{
  switch (link_order->type)
    {
    case bfd_undefined_link_order:
    case bfd_section_reloc_link_order:
    case bfd_symbol_reloc_link_order:
    default:
      abort ();
    case bfd_indirect_link_order:
      return default_indirect_link_order (abfd, info, sec, link_order,
					  FALSE);
    case bfd_data_link_order:
      return default_data_link_order (abfd, info, sec, link_order);
    }
}

/* Default routine to handle a bfd_data_link_order.  */

static bfd_boolean
default_data_link_order (bfd *abfd,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec,
			 struct bfd_link_order *link_order)
{
  bfd_size_type size;
  size_t fill_size;
  bfd_byte *fill;
  file_ptr loc;
  bfd_boolean result;

  BFD_ASSERT ((sec->flags & SEC_HAS_CONTENTS) != 0);

  size = link_order->size;
  if (size == 0)
    return TRUE;

  fill = link_order->u.data.contents;
  fill_size = link_order->u.data.size;
  if (fill_size == 0)
    {
      fill = abfd->arch_info->fill (size, bfd_big_endian (abfd),
				    (sec->flags & SEC_CODE) != 0);
      if (fill == NULL)
	return FALSE;
    }
  else if (fill_size < size)
    {
      bfd_byte *p;
      fill = (bfd_byte *) bfd_malloc (size);
      if (fill == NULL)
	return FALSE;
      p = fill;
      if (fill_size == 1)
	memset (p, (int) link_order->u.data.contents[0], (size_t) size);
      else
	{
	  do
	    {
	      memcpy (p, link_order->u.data.contents, fill_size);
	      p += fill_size;
	      size -= fill_size;
	    }
	  while (size >= fill_size);
	  if (size != 0)
	    memcpy (p, link_order->u.data.contents, (size_t) size);
	  size = link_order->size;
	}
    }

  loc = link_order->offset * bfd_octets_per_byte (abfd);
  result = bfd_set_section_contents (abfd, sec, fill, loc, size);

  if (fill != link_order->u.data.contents)
    free (fill);
  return result;
}

/* Default routine to handle a bfd_indirect_link_order.  */

static bfd_boolean
default_indirect_link_order (bfd *output_bfd,
			     struct bfd_link_info *info,
			     asection *output_section,
			     struct bfd_link_order *link_order,
			     bfd_boolean generic_linker)
{
  asection *input_section;
  bfd *input_bfd;
  bfd_byte *contents = NULL;
  bfd_byte *new_contents;
  bfd_size_type sec_size;
  file_ptr loc;

  BFD_ASSERT ((output_section->flags & SEC_HAS_CONTENTS) != 0);

  input_section = link_order->u.indirect.section;
  input_bfd = input_section->owner;
  if (input_section->size == 0)
    return TRUE;

  BFD_ASSERT (input_section->output_section == output_section);
  BFD_ASSERT (input_section->output_offset == link_order->offset);
  BFD_ASSERT (input_section->size == link_order->size);

  if (info->relocatable
      && input_section->reloc_count > 0
      && output_section->orelocation == NULL)
    {
      /* Space has not been allocated for the output relocations.
	 This can happen when we are called by a specific backend
	 because somebody is attempting to link together different
	 types of object files.  Handling this case correctly is
	 difficult, and sometimes impossible.  */
      (*_bfd_error_handler)
	(_("Attempt to do relocatable link with %s input and %s output"),
	 bfd_get_target (input_bfd), bfd_get_target (output_bfd));
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  if (! generic_linker)
    {
      asymbol **sympp;
      asymbol **symppend;

      /* Get the canonical symbols.  The generic linker will always
	 have retrieved them by this point, but we are being called by
	 a specific linker, presumably because we are linking
	 different types of object files together.  */
      if (!bfd_generic_link_read_symbols (input_bfd))
	return FALSE;

      /* Since we have been called by a specific linker, rather than
	 the generic linker, the values of the symbols will not be
	 right.  They will be the values as seen in the input file,
	 not the values of the final link.  We need to fix them up
	 before we can relocate the section.  */
      sympp = _bfd_generic_link_get_symbols (input_bfd);
      symppend = sympp + _bfd_generic_link_get_symcount (input_bfd);
      for (; sympp < symppend; sympp++)
	{
	  asymbol *sym;
	  struct bfd_link_hash_entry *h;

	  sym = *sympp;

	  if ((sym->flags & (BSF_INDIRECT
			     | BSF_WARNING
			     | BSF_GLOBAL
			     | BSF_CONSTRUCTOR
			     | BSF_WEAK)) != 0
	      || bfd_is_und_section (bfd_get_section (sym))
	      || bfd_is_com_section (bfd_get_section (sym))
	      || bfd_is_ind_section (bfd_get_section (sym)))
	    {
	      /* sym->udata may have been set by
		 generic_link_add_symbol_list.  */
	      if (sym->udata.p != NULL)
		h = (struct bfd_link_hash_entry *) sym->udata.p;
	      else if (bfd_is_und_section (bfd_get_section (sym)))
		h = bfd_wrapped_link_hash_lookup (output_bfd, info,
						  bfd_asymbol_name (sym),
						  FALSE, FALSE, TRUE);
	      else
		h = bfd_link_hash_lookup (info->hash,
					  bfd_asymbol_name (sym),
					  FALSE, FALSE, TRUE);
	      if (h != NULL)
		set_symbol_from_hash (sym, h);
	    }
	}
    }

  if ((output_section->flags & (SEC_GROUP | SEC_LINKER_CREATED)) == SEC_GROUP
      && input_section->size != 0)
    {
      /* Group section contents are set by bfd_elf_set_group_contents.  */
      if (!output_bfd->output_has_begun)
	{
	  /* FIXME: This hack ensures bfd_elf_set_group_contents is called.  */
	  if (!bfd_set_section_contents (output_bfd, output_section, "", 0, 1))
	    goto error_return;
	}
      new_contents = output_section->contents;
      BFD_ASSERT (new_contents != NULL);
      BFD_ASSERT (input_section->output_offset == 0);
    }
  else
    {
      /* Get and relocate the section contents.  */
      sec_size = (input_section->rawsize > input_section->size
		  ? input_section->rawsize
		  : input_section->size);
      contents = (bfd_byte *) bfd_malloc (sec_size);
      if (contents == NULL && sec_size != 0)
	goto error_return;
      new_contents = (bfd_get_relocated_section_contents
		      (output_bfd, info, link_order, contents,
		       info->relocatable,
		       _bfd_generic_link_get_symbols (input_bfd)));
      if (!new_contents)
	goto error_return;
    }

  /* Output the section contents.  */
  loc = input_section->output_offset * bfd_octets_per_byte (output_bfd);
  if (! bfd_set_section_contents (output_bfd, output_section,
				  new_contents, loc, input_section->size))
    goto error_return;

  if (contents != NULL)
    free (contents);
  return TRUE;

 error_return:
  if (contents != NULL)
    free (contents);
  return FALSE;
}

/* A little routine to count the number of relocs in a link_order
   list.  */

unsigned int
_bfd_count_link_order_relocs (struct bfd_link_order *link_order)
{
  register unsigned int c;
  register struct bfd_link_order *l;

  c = 0;
  for (l = link_order; l != NULL; l = l->next)
    {
      if (l->type == bfd_section_reloc_link_order
	  || l->type == bfd_symbol_reloc_link_order)
	++c;
    }

  return c;
}

/*
FUNCTION
	bfd_link_split_section

SYNOPSIS
        bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);

DESCRIPTION
	Return nonzero if @@var{sec} should be split during a
	reloceatable or final link.

.#define bfd_link_split_section(abfd, sec) \
.       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
.

*/

bfd_boolean
_bfd_generic_link_split_section (bfd *abfd ATTRIBUTE_UNUSED,
				 asection *sec ATTRIBUTE_UNUSED)
{
  return FALSE;
}

/*
FUNCTION
	bfd_section_already_linked

SYNOPSIS
        bfd_boolean bfd_section_already_linked (bfd *abfd,
						asection *sec,
						struct bfd_link_info *info);

DESCRIPTION
	Check if @@var{data} has been already linked during a reloceatable
	or final link.  Return TRUE if it has.

.#define bfd_section_already_linked(abfd, sec, info) \
.       BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))
.

*/

/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each section, and
   arrange to discard it if a section of the same name has already
   been linked.  This code assumes that all relevant sections have the
   SEC_LINK_ONCE flag set; that is, it does not depend solely upon the
   section name.  bfd_section_already_linked is called via
   bfd_map_over_sections.  */

/* The hash table.  */

static struct bfd_hash_table _bfd_section_already_linked_table;

/* Support routines for the hash table used by section_already_linked,
   initialize the table, traverse, lookup, fill in an entry and remove
   the table.  */

void
bfd_section_already_linked_table_traverse
  (bfd_boolean (*func) (struct bfd_section_already_linked_hash_entry *,
			void *), void *info)
{
  bfd_hash_traverse (&_bfd_section_already_linked_table,
		     (bfd_boolean (*) (struct bfd_hash_entry *,
				       void *)) func,
		     info);
}

struct bfd_section_already_linked_hash_entry *
bfd_section_already_linked_table_lookup (const char *name)
{
  return ((struct bfd_section_already_linked_hash_entry *)
	  bfd_hash_lookup (&_bfd_section_already_linked_table, name,
			   TRUE, FALSE));
}

bfd_boolean
bfd_section_already_linked_table_insert
  (struct bfd_section_already_linked_hash_entry *already_linked_list,
   asection *sec)
{
  struct bfd_section_already_linked *l;

  /* Allocate the memory from the same obstack as the hash table is
     kept in.  */
  l = (struct bfd_section_already_linked *)
      bfd_hash_allocate (&_bfd_section_already_linked_table, sizeof *l);
  if (l == NULL)
    return FALSE;
  l->sec = sec;
  l->next = already_linked_list->entry;
  already_linked_list->entry = l;
  return TRUE;
}

static struct bfd_hash_entry *
already_linked_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED,
			struct bfd_hash_table *table,
			const char *string ATTRIBUTE_UNUSED)
{
  struct bfd_section_already_linked_hash_entry *ret =
    (struct bfd_section_already_linked_hash_entry *)
      bfd_hash_allocate (table, sizeof *ret);

  if (ret == NULL)
    return NULL;

  ret->entry = NULL;

  return &ret->root;
}

bfd_boolean
bfd_section_already_linked_table_init (void)
{
  return bfd_hash_table_init_n (&_bfd_section_already_linked_table,
				already_linked_newfunc,
				sizeof (struct bfd_section_already_linked_hash_entry),
				42);
}

void
bfd_section_already_linked_table_free (void)
{
  bfd_hash_table_free (&_bfd_section_already_linked_table);
}

/* Report warnings as appropriate for duplicate section SEC.
   Return FALSE if we decide to keep SEC after all.  */

bfd_boolean
_bfd_handle_already_linked (asection *sec,
			    struct bfd_section_already_linked *l,
			    struct bfd_link_info *info)
{
  switch (sec->flags & SEC_LINK_DUPLICATES)
    {
    default:
      abort ();

    case SEC_LINK_DUPLICATES_DISCARD:
      /* If we found an LTO IR match for this comdat group on
	 the first pass, replace it with the LTO output on the
	 second pass.  We can't simply choose real object
	 files over IR because the first pass may contain a
	 mix of LTO and normal objects and we must keep the
	 first match, be it IR or real.  */
      if (info->loading_lto_outputs
	  && (l->sec->owner->flags & BFD_PLUGIN) != 0)
	{
	  l->sec = sec;
	  return FALSE;
	}
      break;

    case SEC_LINK_DUPLICATES_ONE_ONLY:
      info->callbacks->einfo
	(_("%B: ignoring duplicate section `%A'\n"),
	 sec->owner, sec);
      break;

    case SEC_LINK_DUPLICATES_SAME_SIZE:
      if ((l->sec->owner->flags & BFD_PLUGIN) != 0)
	;
      else if (sec->size != l->sec->size)
	info->callbacks->einfo
	  (_("%B: duplicate section `%A' has different size\n"),
	   sec->owner, sec);
      break;

    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
      if ((l->sec->owner->flags & BFD_PLUGIN) != 0)
	;
      else if (sec->size != l->sec->size)
	info->callbacks->einfo
	  (_("%B: duplicate section `%A' has different size\n"),
	   sec->owner, sec);
      else if (sec->size != 0)
	{
	  bfd_byte *sec_contents, *l_sec_contents = NULL;

	  if (!bfd_malloc_and_get_section (sec->owner, sec, &sec_contents))
	    info->callbacks->einfo
	      (_("%B: could not read contents of section `%A'\n"),
	       sec->owner, sec);
	  else if (!bfd_malloc_and_get_section (l->sec->owner, l->sec,
						&l_sec_contents))
	    info->callbacks->einfo
	      (_("%B: could not read contents of section `%A'\n"),
	       l->sec->owner, l->sec);
	  else if (memcmp (sec_contents, l_sec_contents, sec->size) != 0)
	    info->callbacks->einfo
	      (_("%B: duplicate section `%A' has different contents\n"),
	       sec->owner, sec);

	  if (sec_contents)
	    free (sec_contents);
	  if (l_sec_contents)
	    free (l_sec_contents);
	}
      break;
    }

  /* Set the output_section field so that lang_add_section
     does not create a lang_input_section structure for this
     section.  Since there might be a symbol in the section
     being discarded, we must retain a pointer to the section
     which we are really going to use.  */
  sec->output_section = bfd_abs_section_ptr;
  sec->kept_section = l->sec;
  return TRUE;
}

/* This is used on non-ELF inputs.  */

bfd_boolean
_bfd_generic_section_already_linked (bfd *abfd ATTRIBUTE_UNUSED,
				     asection *sec,
				     struct bfd_link_info *info)
{
  const char *name;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;

  if ((sec->flags & SEC_LINK_ONCE) == 0)
    return FALSE;

  /* The generic linker doesn't handle section groups.  */
  if ((sec->flags & SEC_GROUP) != 0)
    return FALSE;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.  */

  name = bfd_get_section_name (abfd, sec);

  already_linked_list = bfd_section_already_linked_table_lookup (name);

  l = already_linked_list->entry;
  if (l != NULL)
    {
      /* The section has already been linked.  See if we should
	 issue a warning.  */
      return _bfd_handle_already_linked (sec, l, info);
    }

  /* This is the first section with this name.  Record it.  */
  if (!bfd_section_already_linked_table_insert (already_linked_list, sec))
    info->callbacks->einfo (_("%F%P: already_linked_table: %E\n"));
  return FALSE;
}

/* Choose a neighbouring section to S in OBFD that will be output, or
   the absolute section if ADDR is out of bounds of the neighbours.  */

asection *
_bfd_nearby_section (bfd *obfd, asection *s, bfd_vma addr)
{
  asection *next, *prev, *best;

  /* Find preceding kept section.  */
  for (prev = s->prev; prev != NULL; prev = prev->prev)
    if ((prev->flags & SEC_EXCLUDE) == 0
	&& !bfd_section_removed_from_list (obfd, prev))
      break;

  /* Find following kept section.  Start at prev->next because
     other sections may have been added after S was removed.  */
  if (s->prev != NULL)
    next = s->prev->next;
  else
    next = s->owner->sections;
  for (; next != NULL; next = next->next)
    if ((next->flags & SEC_EXCLUDE) == 0
	&& !bfd_section_removed_from_list (obfd, next))
      break;

  /* Choose better of two sections, based on flags.  The idea
     is to choose a section that will be in the same segment
     as S would have been if it was kept.  */
  best = next;
  if (prev == NULL)
    {
      if (next == NULL)
	best = bfd_abs_section_ptr;
    }
  else if (next == NULL)
    best = prev;
  else if (((prev->flags ^ next->flags)
	    & (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_LOAD)) != 0)
    {
      if (((next->flags ^ s->flags)
	   & (SEC_ALLOC | SEC_THREAD_LOCAL)) != 0
	  /* We prefer to choose a loaded section.  Section S
	     doesn't have SEC_LOAD set (it being excluded, that
	     part of the flag processing didn't happen) so we
	     can't compare that flag to those of NEXT and PREV.  */
	  || ((prev->flags & SEC_LOAD) != 0
	      && (next->flags & SEC_LOAD) == 0))
	best = prev;
    }
  else if (((prev->flags ^ next->flags) & SEC_READONLY) != 0)
    {
      if (((next->flags ^ s->flags) & SEC_READONLY) != 0)
	best = prev;
    }
  else if (((prev->flags ^ next->flags) & SEC_CODE) != 0)
    {
      if (((next->flags ^ s->flags) & SEC_CODE) != 0)
	best = prev;
    }
  else
    {
      /* Flags we care about are the same.  Prefer the following
	 section if that will result in a positive valued sym.  */
      if (addr < next->vma)
	best = prev;
    }

  return best;
}

/* Convert symbols in excluded output sections to use a kept section.  */

static bfd_boolean
fix_syms (struct bfd_link_hash_entry *h, void *data)
{
  bfd *obfd = (bfd *) data;

  if (h->type == bfd_link_hash_defined
      || h->type == bfd_link_hash_defweak)
    {
      asection *s = h->u.def.section;
      if (s != NULL
	  && s->output_section != NULL
	  && (s->output_section->flags & SEC_EXCLUDE) != 0
	  && bfd_section_removed_from_list (obfd, s->output_section))
	{
	  asection *op;

	  h->u.def.value += s->output_offset + s->output_section->vma;
	  op = _bfd_nearby_section (obfd, s->output_section, h->u.def.value);
	  h->u.def.value -= op->vma;
	  h->u.def.section = op;
	}
    }

  return TRUE;
}

void
_bfd_fix_excluded_sec_syms (bfd *obfd, struct bfd_link_info *info)
{
  bfd_link_hash_traverse (info->hash, fix_syms, obfd);
}

/*
FUNCTION
	bfd_generic_define_common_symbol

SYNOPSIS
	bfd_boolean bfd_generic_define_common_symbol
	  (bfd *output_bfd, struct bfd_link_info *info,
	   struct bfd_link_hash_entry *h);

DESCRIPTION
	Convert common symbol @@var{h} into a defined symbol.
	Return TRUE on success and FALSE on failure.

.#define bfd_define_common_symbol(output_bfd, info, h) \
.       BFD_SEND (output_bfd, _bfd_define_common_symbol, (output_bfd, info, h))
.
*/

bfd_boolean
bfd_generic_define_common_symbol (bfd *output_bfd,
				  struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  struct bfd_link_hash_entry *h)
{
  unsigned int power_of_two;
  bfd_vma alignment, size;
  asection *section;

  BFD_ASSERT (h != NULL && h->type == bfd_link_hash_common);

  size = h->u.c.size;
  power_of_two = h->u.c.p->alignment_power;
  section = h->u.c.p->section;

  /* Increase the size of the section to align the common symbol.
     The alignment must be a power of two.  */
  alignment = bfd_octets_per_byte (output_bfd) << power_of_two;
  BFD_ASSERT (alignment != 0 && (alignment & -alignment) == alignment);
  section->size += alignment - 1;
  section->size &= -alignment;

  /* Adjust the section's overall alignment if necessary.  */
  if (power_of_two > section->alignment_power)
    section->alignment_power = power_of_two;

  /* Change the symbol from common to defined.  */
  h->type = bfd_link_hash_defined;
  h->u.def.section = section;
  h->u.def.value = section->size;

  /* Increase the size of the section.  */
  section->size += size;

  /* Make sure the section is allocated in memory, and make sure that
     it is no longer a common section.  */
  section->flags |= SEC_ALLOC;
  section->flags &= ~SEC_IS_COMMON;
  return TRUE;
}

/*
FUNCTION
	bfd_find_version_for_sym

SYNOPSIS
	struct bfd_elf_version_tree * bfd_find_version_for_sym
	  (struct bfd_elf_version_tree *verdefs,
	   const char *sym_name, bfd_boolean *hide);

DESCRIPTION
	Search an elf version script tree for symbol versioning
	info and export / don't-export status for a given symbol.
	Return non-NULL on success and NULL on failure; also sets
	the output @@samp{hide} boolean parameter.

*/

struct bfd_elf_version_tree *
bfd_find_version_for_sym (struct bfd_elf_version_tree *verdefs,
			  const char *sym_name,
			  bfd_boolean *hide)
{
  struct bfd_elf_version_tree *t;
  struct bfd_elf_version_tree *local_ver, *global_ver, *exist_ver;
  struct bfd_elf_version_tree *star_local_ver, *star_global_ver;

  local_ver = NULL;
  global_ver = NULL;
  star_local_ver = NULL;
  star_global_ver = NULL;
  exist_ver = NULL;
  for (t = verdefs; t != NULL; t = t->next)
    {
      if (t->globals.list != NULL)
	{
	  struct bfd_elf_version_expr *d = NULL;

	  while ((d = (*t->match) (&t->globals, d, sym_name)) != NULL)
	    {
	      if (d->literal || strcmp (d->pattern, "*") != 0)
		global_ver = t;
	      else
		star_global_ver = t;
	      if (d->symver)
		exist_ver = t;
	      d->script = 1;
	      /* If the match is a wildcard pattern, keep looking for
		 a more explicit, perhaps even local, match.  */
	      if (d->literal)
		break;
	    }

	  if (d != NULL)
	    break;
	}

      if (t->locals.list != NULL)
	{
	  struct bfd_elf_version_expr *d = NULL;

	  while ((d = (*t->match) (&t->locals, d, sym_name)) != NULL)
	    {
	      if (d->literal || strcmp (d->pattern, "*") != 0)
		local_ver = t;
	      else
		star_local_ver = t;
	      /* If the match is a wildcard pattern, keep looking for
		 a more explicit, perhaps even global, match.  */
	      if (d->literal)
		{
		  /* An exact match overrides a global wildcard.  */
		  global_ver = NULL;
		  star_global_ver = NULL;
		  break;
		}
	    }

	  if (d != NULL)
	    break;
	}
    }

  if (global_ver == NULL && local_ver == NULL)
    global_ver = star_global_ver;

  if (global_ver != NULL)
    {
      /* If we already have a versioned symbol that matches the
	 node for this symbol, then we don't want to create a
	 duplicate from the unversioned symbol.  Instead hide the
	 unversioned symbol.  */
      *hide = exist_ver == global_ver;
      return global_ver;
    }

  if (local_ver == NULL)
    local_ver = star_local_ver;

  if (local_ver != NULL)
    {
      *hide = TRUE;
      return local_ver;
    }

  return NULL;
}

/*
FUNCTION
	bfd_hide_sym_by_version

SYNOPSIS
	bfd_boolean bfd_hide_sym_by_version
	  (struct bfd_elf_version_tree *verdefs, const char *sym_name);

DESCRIPTION
	Search an elf version script tree for symbol versioning
	info for a given symbol.  Return TRUE if the symbol is hidden.

*/

bfd_boolean
bfd_hide_sym_by_version (struct bfd_elf_version_tree *verdefs,
			 const char *sym_name)
{
  bfd_boolean hidden = FALSE;
  bfd_find_version_for_sym (verdefs, sym_name, &hidden);
  return hidden;
}
@


1.96
log
@	* linker.c (_bfd_generic_link_output_symbols): Handle a
	no-longer-global symbol entered as a BFD_PLUGIN.
@
text
@d2922 1
a2922 1
   been linked.  This code assumes that all relevant sections have the 
d3305 1
a3305 1
	bfd_find_version_for_sym 
@


1.95
log
@	PR ld/14052
	PR ld/13621
bfd/
	* linker.c (_bfd_nearby_section): Revert 2012-02-13 change.
ld/testsuite/
	* ld-elf/warn2.d: Revert 2012-02-13 change.
	* ld-elf/zerosize1.d, ld-elf/zerosize1.s: Delete.
@
text
@d2362 6
@


1.95.4.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a2361 6
      else if (sym->flags == 0
	       && (sym->section->owner->flags & BFD_PLUGIN) != 0)
	/* LTO doesn't set symbol information.  We get here with the
	   generic linker for a symbol that was "common" but no longer
	   needs to be global.  */
	output = FALSE;
@


1.94
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@a3200 5
  /* Refuse to choose a section for which we are out of bounds.  */
  /* ??? This may make most of the above moot.  */
  if (addr < best->vma || addr > best->vma + best->size)
    best = bfd_abs_section_ptr;

@


1.93
log
@	* linker.c (_bfd_nearby_section): New function, split out from..
	(fix_syms): ..here.
	* bfd-in.h (_bfd_nearby_section): Declare.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't use text_index_section or
	data_index_section with ld -q or ld -r output relocs against
	stripped output sections.  Instead use _bfd_nearby_section.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d813 1
@


1.92
log
@PR ld/13621

bfd/
	* linker.c (fix_syms): Force symbols outside any section into
	bfd_abs_section_ptr.
ld/testsuite/
	* ld-elf/warn2.d: Expect ABS section for Foo.
	* ld-elf/zerosize1.d, zerosize1.s: New test.
@
text
@d3133 75
d3224 1
a3224 1
	  asection *op, *op1;
d3227 1
a3227 65

	  /* Find preceding kept section.  */
	  for (op1 = s->output_section->prev; op1 != NULL; op1 = op1->prev)
	    if ((op1->flags & SEC_EXCLUDE) == 0
		&& !bfd_section_removed_from_list (obfd, op1))
	      break;

	  /* Find following kept section.  Start at prev->next because
	     other sections may have been added after S was removed.  */
	  if (s->output_section->prev != NULL)
	    op = s->output_section->prev->next;
	  else
	    op = s->output_section->owner->sections;
	  for (; op != NULL; op = op->next)
	    if ((op->flags & SEC_EXCLUDE) == 0
		&& !bfd_section_removed_from_list (obfd, op))
	      break;

	  /* Choose better of two sections, based on flags.  The idea
	     is to choose a section that will be in the same segment
	     as S would have been if it was kept.  */
	  if (op1 == NULL)
	    {
	      if (op == NULL)
		op = bfd_abs_section_ptr;
	    }
	  else if (op == NULL)
	    op = op1;
	  else if (((op1->flags ^ op->flags)
		    & (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_LOAD)) != 0)
	    {
	      if (((op->flags ^ s->flags)
		   & (SEC_ALLOC | SEC_THREAD_LOCAL)) != 0
		  /* We prefer to choose a loaded section.  Section S
		     doesn't have SEC_LOAD set (it being excluded, that
		     part of the flag processing didn't happen) so we
		     can't compare that flag to those of OP and OP1.  */
		  || ((op1->flags & SEC_LOAD) != 0
		      && (op->flags & SEC_LOAD) == 0))
		op = op1;
	    }
	  else if (((op1->flags ^ op->flags) & SEC_READONLY) != 0)
	    {
	      if (((op->flags ^ s->flags) & SEC_READONLY) != 0)
		op = op1;
	    }
	  else if (((op1->flags ^ op->flags) & SEC_CODE) != 0)
	    {
	      if (((op->flags ^ s->flags) & SEC_CODE) != 0)
		op = op1;
	    }
	  else
	    {
	      /* Flags we care about are the same.  Prefer the following
		 section if that will result in a positive valued sym.  */
	      if (h->u.def.value < op->vma)
		op = op1;
	    }

	  /* Refuse to choose a section for which we are out of bounds.  */
	  /* ??? This may make most of the above moot.  */
	  if (h->u.def.value < op->vma
	      || h->u.def.value > op->vma + op->size)
	    op = bfd_abs_section_ptr;

@


1.91
log
@Support arch-dependent fill

bfd/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* archures.c (bfd_arch_info): Add fill.
	(bfd_default_arch_struct): Add bfd_arch_default_fill.
	(bfd_arch_default_fill): New.

	* configure.in: Set bfd version to 2.22.52.
	* configure: Regenerated.

	* cpu-alpha.c: Add bfd_arch_default_fill to bfd_arch_info
	initializer.
	* cpu-arc.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-d10v.c: Likewise.
	* cpu-d30v.c: Likewise.
	* cpu-dlx.c: Likewise.
	* cpu-epiphany.c: Likewise.
	* cpu-fr30.c: Likewise.
	* cpu-frv.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-i370.c: Likewise.
	* cpu-i860.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-ia64.c: Likewise.
	* cpu-ip2k.c: Likewise.
	* cpu-iq2000.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m10200.c: Likewise.
	* cpu-m10300.c: Likewise.
	* cpu-m32c.c: Likewise.
	* cpu-m32r.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* cpu-m68hc12.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-m88k.c: Likewise.
	* cpu-mcore.c: Likewise.
	* cpu-mep.c: Likewise.
	* cpu-microblaze.c: Likewise.
	* cpu-mips.c: Likewise.
	* cpu-mmix.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-mt.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-openrisc.c: Likewise.
	* cpu-or32.c: Likewise.
	* cpu-pdp11.c: Likewise.
	* cpu-pj.c: Likewise.
	* cpu-plugin.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rl78.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-rx.c: Likewise.
	* cpu-s390.c: Likewise.
	* cpu-score.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-sparc.c: Likewise.
	* cpu-spu.c: Likewise.
	* cpu-tic30.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-tic54x.c: Likewise.
	* cpu-tic6x.c: Likewise.
	* cpu-tic80.c: Likewise.
	* cpu-tilegx.c: Likewise.
	* cpu-tilepro.c: Likewise.
	* cpu-v850.c: Likewise.
	* cpu-vax.c: Likewise.
	* cpu-w65.c: Likewise.
	* cpu-we32k.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* cpu-xstormy16.c: Likewise.
	* cpu-xtensa.c: Likewise.
	* cpu-z80.c: Likewise.
	* cpu-z8k.c: Likewise.

	* cpu-i386.c: Include "libiberty.h".
	(bfd_arch_i386_fill): New.
	Add bfd_arch_i386_fill to  bfd_arch_info initializer.

	* cpu-k1om.c: Add bfd_arch_i386_fill to  bfd_arch_info initializer.
	* cpu-l1om.c: Likewise.

	* linker.c (default_data_link_order): Call abfd->arch_info->fill
	if fill size is 0.

	* bfd-in2.h: Regenerated.

include/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* bfdlink.h (bfd_link_order): Update comments on data size.

ld/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* emulparams/elf32_x86_64.sh: Remove NOP.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_k1om.sh: Likewise.
	* emulparams/elf_l1om.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.

	* ldlang.c (zero_fill): Initialized to 0.

	* ldwrite.c (build_link_order): Set data size to linker odrder
	size when they are the same.

	* scripttempl/elf.sc: Don't specify fill if NOP is undefined.

ld/testsuite/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* ld-i386/tlsbindesc.dd: Update no-op padding.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
@
text
@d3211 6
@


1.90
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d2667 8
a2674 1
  if (fill_size != 0 && fill_size < size)
@


1.90.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
a812 1
  sec->sec_info_type = SEC_INFO_TYPE_JUST_SYMS;
@


1.89
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d3383 23
@


1.88
log
@	PR ld/12762
bfd/
	* elflink.c (_bfd_elf_section_already_linked): Return matched
	status.  Remove COFF comdat section handling.
	* linker.c (_bfd_generic_section_already_linked): Return matched
	status.  Don't set SEC_GROUP in l_flags for plugin entries.
	(bfd_section_already_linked): Update prototype.
	* targets.c (_section_already_linked): Likewise.
	* elf-bfd.h (_bfd_elf_section_already_linked): Likewise.
	* libbfd-in.h (_bfd_generic_section_already_linked): Likewise.
	(_bfd_nolink_section_already_linked): Update.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* plugin.c (add_symbols): Exclude comdat_key symbols from symbol
	table if already seen.
@
text
@d2892 1
a2892 1
						struct already_linked *data,
d2899 2
a2900 2
.#define bfd_section_already_linked(abfd, data, info) \
.       BFD_SEND (abfd, _section_already_linked, (abfd, data, info))
d2943 1
a2943 1
   struct already_linked *data)
d2953 1
a2953 1
  l->linked = *data;
d2991 2
a2992 1
/* This is used on non-ELF inputs.  */
d2995 3
a2997 3
_bfd_generic_section_already_linked (bfd *abfd,
				     struct already_linked *linked,
				     struct bfd_link_info *info)
d2999 1
a2999 9
  flagword flags;
  const char *name;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;
  struct coff_comdat_info *s_comdat;
  asection *sec;

  name = linked->comdat_key;
  if (name)
d3001 2
a3002 30
      sec = NULL;
      flags = SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
      s_comdat = NULL;
    }
  else
    {
      sec = linked->u.sec;
      flags = sec->flags;
      if ((flags & SEC_LINK_ONCE) == 0)
	return FALSE;

      s_comdat = bfd_coff_get_comdat_section (abfd, sec);

      /* FIXME: When doing a relocatable link, we may have trouble
	 copying relocations in other sections that refer to local symbols
	 in the section being discarded.  Those relocations will have to
	 be converted somehow; as of this writing I'm not sure that any of
	 the backends handle that correctly.

	 It is tempting to instead not discard link once sections when
	 doing a relocatable link (technically, they should be discarded
	 whenever we are building constructors).  However, that fails,
	 because the linker winds up combining all the link once sections
	 into a single large link once section, which defeats the purpose
	 of having link once sections in the first place.  */

      name = bfd_get_section_name (abfd, sec);
    }

  already_linked_list = bfd_section_already_linked_table_lookup (name);
d3004 9
a3012 9
  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      bfd_boolean skip = FALSE;
      bfd *l_owner;
      flagword l_flags;
      struct coff_comdat_info *l_comdat;
      asection *l_sec;

      if (l->linked.comdat_key)
d3014 2
a3015 4
	  l_sec = NULL;
	  l_owner = l->linked.u.abfd;
	  l_comdat = NULL;
	  l_flags = SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d3017 25
a3041 1
      else
d3043 20
a3062 4
	  l_sec = l->linked.u.sec;
	  l_owner = l_sec->owner;
	  l_flags = l_sec->flags;
	  l_comdat = bfd_coff_get_comdat_section (l_sec->owner, l_sec);
d3064 2
d3067 20
a3086 18
      /* We may have 3 different sections on the list: group section,
	 comdat section and linkonce section. SEC may be a linkonce or
	 comdat section. We always ignore group section. For non-COFF
	 inputs, we also ignore comdat section.

	 FIXME: Is that safe to match a linkonce section with a comdat
	 section for COFF inputs?  */
      if ((l_flags & SEC_GROUP) != 0)
	skip = TRUE;
      else if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
	{
	  if (s_comdat != NULL
	      && l_comdat != NULL
	      && strcmp (s_comdat->name, l_comdat->name) != 0)
	    skip = TRUE;
	}
      else if (l_comdat != NULL)
	skip = TRUE;
d3088 2
a3089 8
      if (!skip)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();
d3091 3
a3093 14
	    case SEC_LINK_DUPLICATES_DISCARD:
	      /* If we found an LTO IR match for this comdat group on
		 the first pass, replace it with the LTO output on the
		 second pass.  We can't simply choose real object
		 files over IR because the first pass may contain a
		 mix of LTO and normal objects and we must keep the
		 first match, be it IR or real.  */
	      if (info->loading_lto_outputs
		  && (l_owner->flags & BFD_PLUGIN) != 0)
		{
		  l->linked = *linked;
		  return FALSE;
		}
	      break;
d3095 12
a3106 5
	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      (*_bfd_error_handler)
		(_("%B: warning: ignoring duplicate section `%A'\n"),
		 abfd, sec);
	      break;
d3108 1
a3108 14
	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      /* FIXME: We should really dig out the contents of both
                 sections and memcmp them.  The COFF/PE spec says that
                 the Microsoft linker does not implement this
                 correctly, so I'm not going to bother doing it
                 either.  */
	      /* Fall through.  */
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (sec->size != l_sec->size)
		(*_bfd_error_handler)
		  (_("%B: warning: duplicate section `%A' has different size\n"),
		   abfd, sec);
	      break;
	    }
d3110 1
a3110 10
	  if (sec)
	    {
	      /* Set the output_section field so that lang_add_section
		 does not create a lang_input_section structure for this
		 section.  Since there might be a symbol in the section
		 being discarded, we must retain a pointer to the section
		 which we are really going to use.  */
	      sec->output_section = bfd_abs_section_ptr;
	      sec->kept_section = l_sec;
	    }
d3112 6
a3117 2
	  return TRUE;
	}
d3121 1
a3121 2
  if (! bfd_section_already_linked_table_insert (already_linked_list,
						 linked))
@


1.87
log
@	* linker.c (_bfd_generic_section_already_linked): Set l_flags.
	* elf-bfd.h (struct already_linked): Forward declare.
@
text
@d2891 3
a2893 3
        void bfd_section_already_linked (bfd *abfd,
					 struct already_linked *data,
					 struct bfd_link_info *info);
d2897 1
a2897 1
	or final link.
d2993 1
a2993 1
void
d3009 1
a3009 1
      flags = SEC_GROUP | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d3017 1
a3017 1
	return;
d3052 1
a3052 3
	  l_flags = (SEC_GROUP
		     | SEC_LINK_ONCE
		     | SEC_LINK_DUPLICATES_DISCARD);
d3101 1
a3101 1
		  return;
d3137 1
a3137 1
	  return;
d3145 1
@


1.86
log
@	PR ld/12942
bfd/
	* elflink.c (elf_link_add_object_symbols): Use elf_discarded_section
	rather than kept_section to determine whether a symbol is from
	a discarded section.
	* cofflink.c (coff_link_add_symbols): Make symbols from discarded
	sections appear undefined.

	* elf-bfd.h (_bfd_elf_section_already_linked): Replace
	"asection *" with "struct already_linked *".
	* libbfd-in.h (_bfd_nolink_section_already_linked): Likewise.
	(_bfd_generic_section_already_linked): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(struct already_linked): New.
	(struct bfd_section_already_linked): Use it.
	* elflink.c (_bfd_elf_section_already_linked): Replace.
	"asection *" with "struct already_linked *".  Replace the plugin
	dummy with the LTO output.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
	* targets.c (struct already_linked): Add forward declaration.
	(bfd_target): Replace "struct bfd_section *" with
	"struct already_linked *" in _section_already_linked.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

include/
	* bfdlink.h (bfd_link_info): Add loading_lto_outputs.

ld/
	* ldlang.c (section_already_linked): Pass "struct already_linked *"
	to bfd_section_already_linked.
	(lang_process): Set link_info.loading_lto_outputs before
	loading LTO outputs.
	* plugin.c: Include "libbfd.h".
	(add_symbols): Call bfd_section_already_linked with comdat_key.
@
text
@d3060 1
@


1.85
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2891 2
a2892 1
        void bfd_section_already_linked (bfd *abfd, asection *sec,
d2896 1
a2896 1
	Check if @@var{sec} has been already linked during a reloceatable
d2899 2
a2900 2
.#define bfd_section_already_linked(abfd, sec, info) \
.       BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))
d2943 1
a2943 1
   asection *sec)
d2953 1
a2953 1
  l->sec = sec;
d2994 2
a2995 1
_bfd_generic_section_already_linked (bfd *abfd, asection *sec,
d3002 2
d3005 28
a3032 16
  flags = sec->flags;
  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.  */
d3034 2
a3035 1
  name = bfd_get_section_name (abfd, sec);
d3042 20
a3061 4
      struct coff_comdat_info *s_comdat
	= bfd_coff_get_comdat_section (abfd, sec);
      struct coff_comdat_info *l_comdat
	= bfd_coff_get_comdat_section (l->sec->owner, l->sec);
d3070 1
a3070 1
      if ((l->sec->flags & SEC_GROUP) != 0)
d3092 12
d3120 1
a3120 1
	      if (sec->size != l->sec->size)
d3127 10
a3136 7
	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;
d3143 2
a3144 1
  if (! bfd_section_already_linked_table_insert (already_linked_list, sec))
@


1.84
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): If the
	backend does not provide a function for creating dynamic sections
	then fail.
	(bfd_elf_final_link): Issue a warning message if a dynamic section
	has the SHT_NOTE type.
	(bfd_elf_final_link): Do not look for dynamic strings in a section
	that does not have the SHT_STRTAB type or the name .dynstr.
	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Fail if the got
	section is not in the output binary.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_sections): Likewise.

	* ld-elf/elf.exp: Add test for linking a shared library with a
	broken linker script that marks dynamic sections as being notes.
	* ld-elf/note-3.s: New test source file.
	* ld-elf/note-3.t: New test linker script.
	* ld-elf/note-3.l: Expected output from the linker.
	* lib/ld-lib.exp (run_ld_link_tests): Improve description.
@
text
@d607 5
a611 5
/* Traverse a generic link hash table.  The only reason this is not a
   macro is to do better type checking.  This code presumes that an
   argument passed as a struct bfd_hash_entry * may be caught as a
   struct bfd_link_hash_entry * with no explicit cast required on the
   call.  */
d615 1
a615 1
  (struct bfd_link_hash_table *table,
d619 14
a632 3
  bfd_hash_traverse (&table->table,
		     (bfd_boolean (*) (struct bfd_hash_entry *, void *)) func,
		     info);
a2455 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct generic_link_hash_entry *) h->root.u.i.link;

a3105 3
  if (h->type == bfd_link_hash_warning)
    h = h->u.i.link;

@


1.83
log
@	PR ld/12760
include/
	* bfdlink.h (struct bfd_link_callbacks <notice>): Add "flags" and
	"string" param.
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Adjust "notice" call.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldmain.c (notice): Add "flags" and "string" param.
	* plugin.c (plugin_notice): Likewise.  Handle indirect, warning
	and constructor syms.
@
text
@d1569 2
@


1.82
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Remove u.undef.weak field.
bfd/
	* linker.c (_bfd_generic_link_add_one_symbol): Don't init u.undef.weak.
@
text
@d1610 2
a1611 1
      if (! (*info->callbacks->notice) (info, h, abfd, section, value))
@


1.81
log
@	PR ld/12365
	PR ld/12696
include/
	* bfdlink.h (ENUM_BITFIELD): Define.
	(struct bfd_link_hash_entry): Make "type" a bitfield.  Add "non_ir_ref".
	(struct bfd_link_callbacks <notice>): Pass bfd_link_hash_entry pointer
	rather than "name".
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Update "notice" call.
	* linker.c (_bfd_link_hash_newfunc): Clear bitfields.
	(_bfd_generic_link_add_one_symbol): Update "notice" call.
	* elflink.c (_bfd_elf_merge_symbol): Don't skip weak redefs when
	it is a redef of an IR symbol in a real BFD.
ld/
	* ldmain.c (notice): Delete "name" param, add "h".
	* plugin.c (plugin_notice): Likewise.  Set non_ir_ref.  Handle
	redefinitions of IR symbols in real BFDs.
	(plugin_multiple_definition, plugin_multiple_common): Delete.
	(non_ironly_hash, init_non_ironly_hash): Delete.
	(is_visible_from_outside): Traverse entry_symbol chain.
	(get_symbols): Use non_ir_ref flag rather than hash lookup.
@
text
@a1642 1
	  h->u.undef.weak = abfd;
@


1.80
log
@	PR ld/12365
bfd/
	* elfcode.h (elf_slurp_symbol_table): Put common plugin IR symbols
	in their own common section.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Don't lose flags
	if common section is pre-existing.
	(_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldfile.c (ldfile_try_open_bfd): Move code creating and switching
	to plugin IR BFD..
	* ldmain.c (add_archive_element): ..and similar code here..
	* plugin.c (plugin_maybe_claim): ..to here.  New function.
	(plugin_call_claim_file): Make static.
	(asymbol_from_plugin_symbol): Set ELF st_shndx for common syms.
	(plugin_multiple_common): New function.
	(plugin_call_all_symbols_read): Hook in plugin_multiple_common.
	* plugin.h (plugin_call_claim_file): Don't declare.
	(plugin_maybe_claim): Declare.
@
text
@d468 2
a469 4
      h->type = bfd_link_hash_new;
      memset (&h->u.undef.next, 0,
	      (sizeof (struct bfd_link_hash_entry)
	       - offsetof (struct bfd_link_hash_entry, u.undef.next)));
d1610 1
a1610 2
      if (! (*info->callbacks->notice) (info, h->root.string, abfd, section,
					value))
@


1.79
log
@	PR ld/12365
include/
	* bfdlink.h (struct bfd_link_callbacks): Modify multiple_definition
	and multiple_common parameters to pass in a bfd_link_hash_entry
	pointer rather than name,bfd etc. found in the hash entry.
bfd/
	* elflink.c (_bfd_elf_merge_symbol): Update multiple_common calls.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.  Call
	multiple_definition regardless of allow_multiple_definition.
	* simple.c (simple_dummy_multiple_definition): Update.
	* xcofflink.c (xcoff_link_add_symbols): Update multiple_definition
	calls.
ld/
	* ldmain.c (multiple_definition): Take a bfd_link_hash_entry
	pointer arg rather than "name", "obfd", "osec", "oval".  Add code
	removed from linker.c.  Hack around xcofflink.c oddity in
	passing NULL nbfd.
	(multiple_common): Similarly.
	* plugin.c (orig_allow_multiple_defs): Delete.
	(plugin_call_all_symbols_read): Don't twiddle allow_multiple_definition.
	(plugin_multiple_definition): Update.
@
text
@d1299 1
a1299 1
	  h->u.c.p->section->flags = SEC_ALLOC;
d1759 1
a1759 1
	      h->u.c.p->section->flags = SEC_ALLOC;
d1765 1
a1765 1
	      h->u.c.p->section->flags = SEC_ALLOC;
d1806 1
a1806 1
		  h->u.c.p->section->flags = SEC_ALLOC;
d1812 1
a1812 1
		  h->u.c.p->section->flags = SEC_ALLOC;
@


1.78
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009
d1654 1
a1654 3
		 (info, h->root.string,
		  h->u.c.p->section->owner, bfd_link_hash_common, h->u.c.size,
		  abfd, bfd_link_hash_defined, 0)))
d1783 1
a1783 3
		 (info, h->root.string,
		  h->u.c.p->section->owner, bfd_link_hash_common, h->u.c.size,
		  abfd, bfd_link_hash_common, value)))
d1820 5
a1824 17
	  {
	    bfd *obfd;

	    /* We have found a common definition for a symbol which
	       was already defined.  FIXME: It would nice if we could
	       report the BFD which defined an indirect symbol, but we
	       don't have anywhere to store the information.  */
	    if (h->type == bfd_link_hash_defined
		|| h->type == bfd_link_hash_defweak)
	      obfd = h->u.def.section->owner;
	    else
	      obfd = NULL;
	    if (! ((*info->callbacks->multiple_common)
		   (info, h->root.string, obfd, h->type, 0,
		    abfd, bfd_link_hash_common, value)))
	      return FALSE;
	  }
d1835 3
a1837 32
	  if (!info->allow_multiple_definition)
	    {
	      asection *msec = NULL;
	      bfd_vma mval = 0;

	      switch (h->type)
		{
		case bfd_link_hash_defined:
		  msec = h->u.def.section;
		  mval = h->u.def.value;
		  break;
	        case bfd_link_hash_indirect:
		  msec = bfd_ind_section_ptr;
		  mval = 0;
		  break;
		default:
		  abort ();
		}

	      /* Ignore a redefinition of an absolute symbol to the
		 same value; it's harmless.  */
	      if (h->type == bfd_link_hash_defined
		  && bfd_is_abs_section (msec)
		  && bfd_is_abs_section (section)
		  && value == mval)
		break;

	      if (! ((*info->callbacks->multiple_definition)
		     (info, h->root.string, msec->owner, msec, mval,
		      abfd, section, value)))
		return FALSE;
	    }
d1844 1
a1844 3
		 (info, h->root.string,
		  h->u.c.p->section->owner, bfd_link_hash_common, h->u.c.size,
		  abfd, bfd_link_hash_indirect, 0)))
@


1.77
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d1226 1
a1226 1
	  bfd *subsbfd = NULL;
d1229 3
a1231 2
	  if (! (*info->callbacks->add_archive_element)
				(info, abfd, bfd_asymbol_name (p), &subsbfd))
d1235 3
a1237 6
	  if (subsbfd)
	    {
	      abfd = subsbfd;
	      if (!bfd_generic_link_read_symbols (abfd))
		return FALSE;
	    }
a1257 1
	      bfd *subsbfd = NULL;
d1261 3
a1263 2
	      if (! (*info->callbacks->add_archive_element)
				(info, abfd, bfd_asymbol_name (p), &subsbfd))
@


1.77.2.1
log
@backport from mainline
@
text
@d1226 1
a1226 1
	  bfd *oldbfd = abfd;
d1229 2
a1230 3
	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, bfd_asymbol_name (p),
					&abfd))
d1234 6
a1239 3
	  if (abfd != oldbfd
	      && !bfd_generic_link_read_symbols (abfd))
	    return FALSE;
d1260 1
d1264 2
a1265 3
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, bfd_asymbol_name (p),
					    &abfd))
@


1.77.2.2
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d468 4
a471 2
      memset ((char *) &h->root + sizeof (h->root), 0,
	      sizeof (*h) - sizeof (h->root));
d1299 1
a1299 1
	  h->u.c.p->section->flags |= SEC_ALLOC;
d1612 2
a1613 1
      if (! (*info->callbacks->notice) (info, h, abfd, section, value))
d1654 3
a1656 1
		 (info, h, abfd, bfd_link_hash_defined, 0)))
d1761 1
a1761 1
	      h->u.c.p->section->flags |= SEC_ALLOC;
d1767 1
a1767 1
	      h->u.c.p->section->flags |= SEC_ALLOC;
d1785 3
a1787 1
		 (info, h, abfd, bfd_link_hash_common, value)))
d1810 1
a1810 1
		  h->u.c.p->section->flags |= SEC_ALLOC;
d1816 1
a1816 1
		  h->u.c.p->section->flags |= SEC_ALLOC;
d1824 17
a1840 5
	  /* We have found a common definition for a symbol which
	     was already defined.  */
	  if (! ((*info->callbacks->multiple_common)
		 (info, h, abfd, bfd_link_hash_common, value)))
	    return FALSE;
d1851 32
a1882 3
	  if (! ((*info->callbacks->multiple_definition)
		 (info, h, abfd, section, value)))
	    return FALSE;
d1889 3
a1891 1
		 (info, h, abfd, bfd_link_hash_indirect, 0)))
@


1.77.2.3
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1610 1
a1610 2
      if (! (*info->callbacks->notice) (info, h,
					abfd, section, value, flags, string))
d1643 1
@


1.76
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d226 4
a229 1
	symbols from the object file to the linker hash table.
d249 1
a249 1
	the elements symbols must be added to the linker hash table
d251 5
a255 1
	<<_bfd_link_add_symbols>> function.
d267 2
a268 1
	linker hash table.
d968 4
a971 2
   to the global hash table.  CHECKFN should only return FALSE if some
   sort of error occurs.
d1226 1
d1229 2
a1230 2
	  if (! (*info->callbacks->add_archive_element) (info, abfd,
							 bfd_asymbol_name (p)))
d1232 8
d1260 1
d1265 1
a1265 1
		  (info, abfd, bfd_asymbol_name (p)))
d1267 3
@


1.75
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d800 11
@


1.74
log
@update copyright dates
@
text
@d447 2
a448 1
      entry = bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d552 1
a552 1
	  n = bfd_malloc (amt);
d583 1
a583 1
	  n = bfd_malloc (amt);
d682 1
a682 1
      entry =
d711 1
a711 1
  ret = bfd_malloc (amt);
d752 2
a753 1
      bfd_get_outsymbols (abfd) = bfd_alloc (abfd, symsize);
d885 2
a886 1
    ret = bfd_hash_allocate (table, sizeof (struct archive_hash_entry));
d1057 1
a1057 1
	      char *buf = bfd_malloc (amt);
d1248 1
a1248 1
	  h->u.c.p =
d1697 1
a1697 1
	  h->u.c.p =
d1978 1
a1978 1
		w = bfd_hash_allocate (&info->hash->table, len);
d2065 1
a2065 1
		  relocs = bfd_malloc (relsize);
d2087 1
a2087 1
	      o->orelocation = bfd_alloc (abfd, amt);
d2141 1
a2141 1
      newsyms = bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
d2218 1
a2218 1
	    h = sym->udata.p;
d2457 2
a2458 1
  struct generic_write_global_symbol_info *wginfo = data;
d2515 1
a2515 1
  r = bfd_alloc (abfd, sizeof (arelent));
d2563 1
a2563 1
      buf = bfd_zmalloc (size);
d2678 1
a2678 1
      fill = bfd_malloc (size);
d2788 1
a2788 1
		h = sym->udata.p;
d2823 1
a2823 1
      contents = bfd_malloc (sec_size);
d2956 2
a2957 1
  l = bfd_hash_allocate (&_bfd_section_already_linked_table, sizeof *l);
d2972 2
a2973 1
    bfd_hash_allocate (table, sizeof *ret);
@


1.74.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d447 1
a447 2
      entry = (struct bfd_hash_entry *)
          bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d551 1
a551 1
	  n = (char *) bfd_malloc (amt);
d582 1
a582 1
	  n = (char *) bfd_malloc (amt);
d681 1
a681 1
      entry = (struct bfd_hash_entry *)
d710 1
a710 1
  ret = (struct generic_link_hash_table *) bfd_malloc (amt);
d751 1
a751 2
      bfd_get_outsymbols (abfd) = (struct bfd_symbol **) bfd_alloc (abfd,
                                                                    symsize);
d883 1
a883 2
    ret = (struct archive_hash_entry *)
        bfd_hash_allocate (table, sizeof (struct archive_hash_entry));
d1054 1
a1054 1
	      char *buf = (char *) bfd_malloc (amt);
d1245 1
a1245 1
	  h->u.c.p = (struct bfd_link_hash_common_entry *)
d1694 1
a1694 1
	  h->u.c.p = (struct bfd_link_hash_common_entry *)
d1975 1
a1975 1
		w = (char *) bfd_hash_allocate (&info->hash->table, len);
d2062 1
a2062 1
		  relocs = (arelent **) bfd_malloc (relsize);
d2084 1
a2084 1
	      o->orelocation = (struct reloc_cache_entry **) bfd_alloc (abfd, amt);
d2138 1
a2138 1
      newsyms = (asymbol **) bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
d2215 1
a2215 1
	    h = (struct generic_link_hash_entry *) sym->udata.p;
d2454 1
a2454 2
  struct generic_write_global_symbol_info *wginfo =
      (struct generic_write_global_symbol_info *) data;
d2511 1
a2511 1
  r = (arelent *) bfd_alloc (abfd, sizeof (arelent));
d2559 1
a2559 1
      buf = (bfd_byte *) bfd_zmalloc (size);
d2674 1
a2674 1
      fill = (bfd_byte *) bfd_malloc (size);
d2784 1
a2784 1
		h = (struct bfd_link_hash_entry *) sym->udata.p;
d2819 1
a2819 1
      contents = (bfd_byte *) bfd_malloc (sec_size);
d2952 1
a2952 2
  l = (struct bfd_section_already_linked *)
      bfd_hash_allocate (&_bfd_section_already_linked_table, sizeof *l);
d2967 1
a2967 2
    (struct bfd_section_already_linked_hash_entry *)
      bfd_hash_allocate (table, sizeof *ret);
@


1.73
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008
@


1.72
log
@	PR ld/10515
	* linker.c (bfd_find_version_for_sym): Revert warning.
@
text
@d2607 1
a2607 1
  struct bfd_link_order *new;
d2609 2
a2610 2
  new = bfd_zalloc (abfd, amt);
  if (!new)
d2613 1
a2613 1
  new->type = bfd_undefined_link_order;
d2616 1
a2616 1
    section->map_tail.link_order->next = new;
d2618 2
a2619 2
    section->map_head.link_order = new;
  section->map_tail.link_order = new;
d2621 1
a2621 1
  return new;
@


1.71
log
@	PR ld/10515
	* linker.c (bfd_find_version_for_sym): Override a "*" match by any
	other wildcard match.  Warn on multiple wildcard matches.
@
text
@a3279 1
  unsigned int match_count = 0;
a3293 1
	      ++match_count;
d3304 1
a3304 4
		{
		  match_count = 0;
		  break;
		}
a3316 1
	      ++match_count;
a3327 1
		  match_count = 0;
a3336 5
  if (match_count > 1)
    (*_bfd_error_handler)
      (_("warning: multiple wildcard version script matches for %s\n"),
       sym_name);

@


1.70
log
@	* linker.c (fix_syms): Consider SEC_LOAD when choosing section.
@
text
@d3274 2
a3275 2
		      const char *sym_name,
		      bfd_boolean *hide)
d3279 2
d3284 2
d3295 5
a3299 1
	      global_ver = t;
d3306 4
a3309 1
		break;
d3322 5
a3326 1
	      local_ver = t;
d3333 2
d3344 8
d3362 3
a3372 1

@


1.69
log
@bfd/ChangeLog

	* elflink.c (find_version_for_sym):  Remove from here, ...
	* linker.c (bfd_find_version_for_sym):  ... rename, replace
	here, make public and update all callers.
	* bfd-in2.h:  Regenerate.

ld/ChangeLog

	* NEWS:  Mention new feature.
	* ld.texinfo (--version-script):  Document extent of PE support.
	(WIN32):  Mention --version-script.  Extend auto-export description.
	* pe-dll.c (process_def_file):  Use version script info to filter
	symbols from auto-export.
	* testsuite/ld-pe/vers-script-1.d:  New file.
	* testsuite/ld-pe/vers-script-2.d:  New file.
	* testsuite/ld-pe/vers-script-3.d:  New file.
	* testsuite/ld-pe/vers-script-4.d:  New file.
	* testsuite/ld-pe/vers-script-1.ver:  New file.
	* testsuite/ld-pe/vers-script-2.ver:  New file.
	* testsuite/ld-pe/vers-script-3.ver:  New file.
	* testsuite/ld-pe/vers-script-4.ver:  New file.
	* testsuite/ld-pe/vers-script-dll.c:  New file.
	* testsuite/ld-pe/vers-script.exp:  New test script.
@
text
@d3152 1
a3152 1
		    & (SEC_ALLOC | SEC_THREAD_LOCAL)) != 0)
d3155 7
a3161 1
		   & (SEC_ALLOC | SEC_THREAD_LOCAL)) != 0)
@


1.68
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d3248 92
@


1.67
log
@2009-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (_bfd_elf_section_already_linked): Add `\n' for
	info->callbacks->einfo.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
@
text
@d3189 59
@


1.66
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d3098 1
a3098 1
    info->callbacks->einfo (_("%F%P: already_linked_table: %E"));
@


1.65
log
@bfd/
	* bfd.c (struct _bfd): Correct outsymbols comment.
	* bfd-in2.h: Regenerate.
	* linker.c (bfd_generic_link_read_symbols): Renamed from..
	(generic_link_read_symbols): ..this, and made global.

include/
	* bfdlink.h (bfd_generic_link_read_symbols): Declare.
ld/
	PR 6478
	* ldcref.c (check_local_sym_xref): Use bfd_generic_link_read_symbols.
	Don't free symbol pointer array.
	(check_refs): Likewise.
	* ldmain.c (warning_callback): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (process_def_file): Likewise.
	(pe_walk_relocs_of_symbol, generate_reloc): Likewise.
	* emultempl/pe.em (pe_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* emultempl/pep.em (pep_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* ldlang.h (lang_input_statement_type): Delete asymbols, symbol_count,
	passive_position, closed.
	* ldlang.c (new_afile): Don't set asymbols and symbol_count.
	* ldmain.c (add_archive_element): xcalloc lang_input_statement_type.
@
text
@d2799 30
a2828 12
  /* Get and relocate the section contents.  */
  sec_size = (input_section->rawsize > input_section->size
	      ? input_section->rawsize
	      : input_section->size);
  contents = bfd_malloc (sec_size);
  if (contents == NULL && sec_size != 0)
    goto error_return;
  new_contents = (bfd_get_relocated_section_contents
		  (output_bfd, info, link_order, contents, info->relocatable,
		   _bfd_generic_link_get_symbols (input_bfd)));
  if (!new_contents)
    goto error_return;
@


1.65.2.1
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d2799 12
a2810 30
  if ((output_section->flags & (SEC_GROUP | SEC_LINKER_CREATED)) == SEC_GROUP
      && input_section->size != 0)
    {
      /* Group section contents are set by bfd_elf_set_group_contents.  */
      if (!output_bfd->output_has_begun)
	{
	  /* FIXME: This hack ensures bfd_elf_set_group_contents is called.  */
	  if (!bfd_set_section_contents (output_bfd, output_section, "", 0, 1))
	    goto error_return;
	}
      new_contents = output_section->contents;
      BFD_ASSERT (new_contents != NULL);
      BFD_ASSERT (input_section->output_offset == 0);
    }
  else
    {
      /* Get and relocate the section contents.  */
      sec_size = (input_section->rawsize > input_section->size
		  ? input_section->rawsize
		  : input_section->size);
      contents = bfd_malloc (sec_size);
      if (contents == NULL && sec_size != 0)
	goto error_return;
      new_contents = (bfd_get_relocated_section_contents
		      (output_bfd, info, link_order, contents,
		       info->relocatable,
		       _bfd_generic_link_get_symbols (input_bfd)));
      if (!new_contents)
	goto error_return;
    }
@


1.64
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d740 2
a741 2
static bfd_boolean
generic_link_read_symbols (bfd *abfd)
d837 1
a837 1
  if (! generic_link_read_symbols (abfd))
d1167 1
a1167 1
  if (! generic_link_read_symbols (abfd))
d2162 1
a2162 1
  if (! generic_link_read_symbols (input_bfd))
d2755 1
a2755 1
      if (! generic_link_read_symbols (input_bfd))
@


1.63
log
@2007-07-26  Michael Snyder  <msnyder@@svkmacdonelllnx>

	* linker.c (bfd_section_already_linked_table_insert): Change
	return type from void to boolean.  Return FALSE on failure.
	(_bfd_generic_section_already_linked): Test return value of
	bfd_section_already_linked_table_insert, call fatal on error.

	* elflink.c (_bfd_elf_section_already_linked): Test return value
	of bfd_section_already_linked_table_insert, call fatal on error.

	* libbfd-in.h (bfd_section_already_linked_table_insert): Update
	return type to bfd_boolean.

	* libbfd.h: Regenerate.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007
d154 3
a156 3
	<<_bfd_final_link>> function.  In such a case the <<creator>>
	field of the hash table must be checked to make sure that the
	hash table was created by an object file of the same format.
d168 1
a168 1
	check the <<creator>> field before saving information (in this
d474 1
a474 1
   bfd *abfd,
a479 1
  table->creator = abfd->xvec;
d1361 1
a1361 1
	  if (info->hash->creator == abfd->xvec)
d2245 1
a2245 1
	      if (info->hash->creator == input_bfd->xvec)
@


1.62
log
@Fix bollixed check-in
@
text
@d2926 1
a2926 1
void
d2936 2
d2941 1
d2953 1
a2953 1
    return ret;
d2979 1
a2979 1
				     struct bfd_link_info *info ATTRIBUTE_UNUSED)
d3080 2
a3081 1
  bfd_section_already_linked_table_insert (already_linked_list, sec);
@


1.61
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* linker.c (already_linked_newfunc): Check for NULL return from
	bfd_hash_allocate.
@
text
@a2948 2
  ret->entry = NULL;

d2952 2
@


1.60
log
@warning fix
@
text
@d2951 3
@


1.59
log
@Switch sources over to use the GPL version 3
@
text
@d1319 1
a1319 1
	  name = bfd_asymbol_name (p);
a1331 1
	      string = name;
a1334 2
	  else
	    string = NULL;
@


1.58
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.57
log
@bfd/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* elf-bfd.h (elf_obj_tdata): Add symbuf.
	(_bfd_elf_section_already_linked): Add struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elf.c (assign_section_numbers): Updated to add
	struct bfd_link_info *.
	(bfd_elf_match_symbols_in_sections): Updated. Cache symbol
	buffer if info->reduce_memory_overheads is false.

	* elflink.c (match_group_member): Updated to add
	struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(elf_link_input_bfd): Likewise.
	(_bfd_elf_section_already_linked): Likewise.
	(bfd_elf_final_link): Free symbol buffer if
	info->reduce_memory_overheads is false.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* libbfd.h: Regenerated.

	* linker.c (bfd_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* targets.c (bfd_target): Add struct bfd_link_info * to
	_section_already_linked.
	* bfd-in2.h: Regenerated.

include/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* bfdlink.h (bfd_link_info): Add reduce_memory_overheads.

ld/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* ld.h (args_type): Remove reduce_memory_overheads.

	* ldlang.c (lang_map): Updated.
	(section_already_linked): Likewise.
	(print_input_section): Likewise.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d23 1
a24 1
#include "sysdep.h"
@


1.56
log
@	* linker.c (fix_syms): Choose best of previous and next
	section based on section flags and vma.
@
text
@d2879 2
a2880 1
        void bfd_section_already_linked (bfd *abfd, asection *sec);
d2886 2
a2887 2
.#define bfd_section_already_linked(abfd, sec) \
.       BFD_SEND (abfd, _section_already_linked, (abfd, sec))
d2973 2
a2974 1
_bfd_generic_section_already_linked (bfd *abfd, asection *sec)
@


1.55
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d3095 17
a3111 2
	  asection *op;
	  for (op = s->output_section->prev; op != NULL; op = op->prev)
d3115 5
a3119 1
	  if (op == NULL)
a3120 8
	      if (s->output_section->prev != NULL)
		op = s->output_section->prev->next;
	      else
		op = s->output_section->owner->sections;
	      for (; op != NULL; op = op->next)
		if ((op->flags & SEC_EXCLUDE) == 0
		    && !bfd_section_removed_from_list (obfd, op))
		  break;
d3124 27
a3150 1
	  h->u.def.value += s->output_offset + s->output_section->vma;
@


1.54
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3076 1
a3076 1
/* Convert symbols in excluded output sections to absolute.  */
d3095 18
d3114 2
a3115 1
	  h->u.def.section = bfd_abs_section_ptr;
@


1.53
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d565 1
a565 1
#undef REAL
d569 1
a569 1
	  && strncmp (l, REAL, sizeof REAL - 1) == 0
d1662 1
a1662 2
		if (s[0] == 'G'
		    && strncmp (s, CONS_PREFIX, CONS_PREFIX_LEN - 1) == 0)
@


1.52
log
@	* coff-h8300.c (h8300_reloc16_extra_cases): Use input section
	"output_offset" instead of link order "offset".
	* coff-h8500.c (extra_case): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z80.c (extra_case): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* linker.c (default_indirect_link_order): Likewise, "size" too.
	* ecoff.c (ecoff_indirect_link_order): Likewise.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d475 2
a476 1
				      const char *))
d483 1
a483 1
  return bfd_hash_table_init (&table->table, newfunc);
d713 2
a714 1
				   _bfd_generic_link_hash_newfunc))
d906 2
a907 1
				      const char *))
d909 1
a909 1
  return bfd_hash_table_init (&table->table, newfunc);
d987 2
a988 1
  if (! archive_hash_table_init (&arsym_hash, archive_hash_newfunc))
d2959 3
a2961 1
				already_linked_newfunc, 42);
@


1.51
log
@	* elflink.c (elf_link_input_bfd): Don't use linker_mark and
	SEC_EXCLUDE to test for sections dropped from output.  Instead,
	use bfd_section_removed_from_list on normal sections.  Don't
	attempt to handle symbols with unknown reserved section indices.
	* linker.c (_bfd_generic_link_output_symbols): Don't use
	linker_mark to test for symbols belonging to dropped sections.
	Do allow absolute symbols.
@
text
@a2719 3
  if (link_order->size == 0)
    return TRUE;

d2722 2
d2812 1
a2812 1
  loc = link_order->offset * bfd_octets_per_byte (output_bfd);
d2814 1
a2814 1
				  new_contents, loc, link_order->size))
@


1.50
log
@bfd/
	* elflink.c (fix_syms, _bfd_elf_fix_excluded_sec_syms): Move to..
	* linker.c (fix_syms, _bfd_fix_excluded_sec_syms): ..here.
	* bfd-in.h (_bfd_fix_excluded_sec_syms): Rename.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_finish): Call ld_emulation->finish unconditionally.
	(finish_default): New function.
	* ldemul.h (finish_default): Declare.
	* emultempl/aix.em (gld*_before_allocation): Call
	before_allocation_default rather than strip_excluded_output_sections.
	(ld_*_emulation): Init finish field to finish_default.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d2367 3
a2369 6
	 symbol.  .bss and similar sections won't have the linker_mark
	 field set.  We also check if its output section has been
	 removed from the output file.  */
      if (((sym->section->flags & SEC_HAS_CONTENTS) != 0
	   && ! sym->section->linker_mark)
	  || bfd_section_removed_from_list (output_bfd,
@


1.49
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3074 33
@


1.48
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.47
log
@Update the FSF address in the copyright/GPL notice
@
text
@d312 1
a312 1
	<<link_order>> structures attached to the <<link_order_head>>
d2012 1
a2012 1
    for (p = o->link_order_head; p != NULL; p = p->next)
d2041 1
a2041 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d2097 1
a2097 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d2617 2
a2618 2
  if (section->link_order_tail != NULL)
    section->link_order_tail->next = new;
d2620 2
a2621 2
    section->link_order_head = new;
  section->link_order_tail = new;
@


1.46
log
@2005-04-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* linker.c (_bfd_generic_link_output_symbols): Also check if
	the output section of an input section has been removed from
	the output file.

	* section.c (bfd_section_list_remove): Clear the next field
	of the removed section.
	(bfd_section_removed_from_list): New.
	* bfd-in2.h: Regenerated.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.45
log
@	* linker.c (_bfd_link_hash_newfunc): Set all local fields.
@
text
@d2366 8
a2373 6
	 in the output file, then we don't want to output the symbol.

	 Gross.  .bss and similar sections won't have the linker_mark
	 field set.  */
      if ((sym->section->flags & SEC_HAS_CONTENTS) != 0
	  && ! sym->section->linker_mark)
@


1.44
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Add u.undef.weak.
bfd/
	* linker.c (_bfd_generic_link_add_one_symbol): Set u.undef.weak.
	* elflink.c (elf_smash_syms): Restore symbols that were undefweak
	before the as-needed lib was loaded.  Abort on unexpected refs.
@
text
@d458 3
a460 1
      h->u.undef.next = NULL;
@


1.43
log
@include/
	* bfdlink.h (bfd_link_repair_undef_list): Declare.
bfd/
	* elf64-ppc.c (ppc64_elf_check_directives): Move undefs list fixup..
	* linker.c (bfd_link_repair_undef_list): ..to new function, but don't
	remove anything but new and undefweak.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Override any
	existing _DYNAMIC.
	(_bfd_elf_create_dynamic_sections): Formatting.
	(bfd_elf_record_link_assignment): Call bfd_link_repair_undef_list.
	(_bfd_elf_merge_symbol): Don't handle as-needed syms here.
	(struct elf_smash_data): New.
	(elf_smash_syms): New function.
	(elf_link_add_object_symbols): Call elf_smash_syms.  Don't add
	unneeded dynamic objects to loaded list.
	(elf_link_output_extsym): Don't handle as-needed here.  Strip
	bfd_link_hash_new symbols.
	* elf32-cris.c (elf_cris_discard_excess_program_dynamics): Don't
	delref when dynindx is already -1.
	* elf64-alpha.c (elf64_alpha_output_extsym): Strip bfd_link_hash_new
	symbols.
	* elfxx-mips.c (mips_elf_output_extsym): Likewise.
ld/
	* ld.texinfo: Clarify --as-needed operation.
@
text
@d1607 1
@


1.42
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
d626 39
@


1.41
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d2532 1
a2532 1
		 (info,
@


1.40
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d458 1
a458 1
      h->und_next = NULL;
d619 1
a619 1
  BFD_ASSERT (h->und_next == NULL);
d621 1
a621 1
    table->undefs_tail->und_next = h;
d993 1
a993 1
	    *pundef = (*pundef)->und_next;
d995 1
a995 1
	    pundef = &(*pundef)->und_next;
d1018 1
a1018 1
	      pundef = &(*pundef)->und_next;
d1067 1
a1067 1
      pundef = &(*pundef)->und_next;
d1697 2
a1698 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1884 2
a1885 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1900 1
a1900 1
	     the und_next field is not NULL, or it is the tail of the
d1903 1
a1903 1
	  if (h->und_next != NULL || info->hash->undefs_tail == h)
@


1.39
log
@2004-07-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 161/251
	* elf-bfd.h (bfd_elf_section_data): Add sec_group.
	(elf_sec_group): Defined.
	(bfd_elf_match_symbols_in_sections): New prototype.
	(_bfd_elf_setup_group_pointers): Likewise.

	* elf.c (bfd_elf_discard_group): Abort.
	(bfd_elf_set_group_contents): Also include relocation sections.
	Remove zero-fill for ld -r.
	(_bfd_elf_setup_group_pointers): New function.
	(elf_sort_elf_symbol): Likewise.
	(elf_sym_name_compare): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elfcode.h (elf_object_p): Call _bfd_elf_setup_group_pointers.

	* elflink.c (match_group_member): New.
	(elf_link_input_bfd): Check group member for discarded section.
	(try_match_symbols_in_sections): New function.
	(already_linked): Likewise.
	(_bfd_elf_section_already_linked): Support mixing comdat group
	and linkonce section.

	* libbfd-in.h (bfd_section_already_linked_table_traverse): New.
	* linker.c (bfd_section_already_linked_table_traverse): New.

	* libbfd.h: Regenerated.
@
text
@d1831 2
a1832 2
		  (_("%s: indirect symbol `%s' to `%s' is a loop"),
		   bfd_archive_filename (abfd), name, string);
d2995 3
a2997 8
	      if (s_comdat == NULL)
		(*_bfd_error_handler)
		  (_("%s: %s: warning: ignoring duplicate section `%s'\n"),
		   bfd_archive_filename (abfd), name);
	      else
		(*_bfd_error_handler)
		  (_("%s: %s: warning: ignoring duplicate `%s' section symbol `%s'\n"),
		   bfd_archive_filename (abfd), name, s_comdat->name);
d3010 2
a3011 2
		  (_("%s: %s: warning: duplicate section `%s' has different size\n"),
		   bfd_archive_filename (abfd), name);
@


1.38
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d2861 13
a2873 2
   initialize the table, lookup, fill in an entry and remove the
   table.  */
@


1.37
log
@bfd/
	* elf64-mmix.c (mmix_set_relaxable_size): Save original size in
	rawsize.
	(mmix_elf_perform_relocation): Adjust for above change.
	(mmix_elf_relocate_section): Likewise.
	(mmix_elf_relax_section): Likewise.  Use output_section->rawsize.
	(mmix_elf_get_section_contents): Delete.
	(bfd_elf64_get_section_contents): Delete.
	(mmix_elf_relocate_section): Zero stub area.
	* linker.c (default_indirect_link_order): Alloc max of section size
	and rawsize.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.
	* section.c (bfd_malloc_and_get_section): Likewise.
	(struct bfd_section): Update rawsize comment.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (lang_reset_memory_regions): Save last relax pass section
	size in rawsize.
@
text
@d2830 194
@


1.36
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2759 3
a2761 1
  sec_size = input_section->size;
@


1.35
log
@include/
	PR 51.
	* bfdlink.h (struct bfd_link_info): Add wrap_char.

bfd/
	PR 51.
	* linker.c (bfd_wrapped_link_hash_lookup): Handle info->wrap_char.

ld/
	PR 51.
	* emultempl/ppc64elf.em (ppc_create_output_section_statements): Set
	link_info.wrap_char.
@
text
@d2687 1
a2687 1
  BFD_ASSERT (input_section->_cooked_size == link_order->size);
d2759 1
a2759 1
  sec_size = bfd_section_size (input_bfd, input_section);
@


1.34
log
@Rename bfd_link_hash_entry field "next" -> "und_next".
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d526 1
d529 5
a533 2
      if (*l == bfd_get_symbol_leading_char (abfd))
	++l;
d551 1
a551 2
	  /* Note that symbol_leading_char may be '\0'.  */
	  n[0] = bfd_get_symbol_leading_char (abfd);
d582 1
a582 2
	  /* Note that symbol_leading_char may be '\0'.  */
	  n[0] = bfd_get_symbol_leading_char (abfd);
@


1.34.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
a525 1
      char prefix = '\0';
d528 2
a529 5
      if (*l == bfd_get_symbol_leading_char (abfd) || *l == info->wrap_char)
	{
	  prefix = *l;
	  ++l;
	}
d547 2
a548 1
	  n[0] = prefix;
d579 2
a580 1
	  n[0] = prefix;
@


1.34.8.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1831 2
a1832 2
		  (_("%B: indirect symbol `%s' to `%s' is a loop"),
		   abfd, name, string);
d2687 1
a2687 1
  BFD_ASSERT (input_section->size == link_order->size);
d2759 1
a2759 3
  sec_size = (input_section->rawsize > input_section->size
	      ? input_section->rawsize
	      : input_section->size);
a2827 200

/*
FUNCTION
	bfd_section_already_linked

SYNOPSIS
        void bfd_section_already_linked (bfd *abfd, asection *sec);

DESCRIPTION
	Check if @@var{sec} has been already linked during a reloceatable
	or final link.

.#define bfd_section_already_linked(abfd, sec) \
.       BFD_SEND (abfd, _section_already_linked, (abfd, sec))
.

*/

/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each section, and
   arrange to discard it if a section of the same name has already
   been linked.  This code assumes that all relevant sections have the 
   SEC_LINK_ONCE flag set; that is, it does not depend solely upon the
   section name.  bfd_section_already_linked is called via
   bfd_map_over_sections.  */

/* The hash table.  */

static struct bfd_hash_table _bfd_section_already_linked_table;

/* Support routines for the hash table used by section_already_linked,
   initialize the table, traverse, lookup, fill in an entry and remove
   the table.  */

void
bfd_section_already_linked_table_traverse
  (bfd_boolean (*func) (struct bfd_section_already_linked_hash_entry *,
			void *), void *info)
{
  bfd_hash_traverse (&_bfd_section_already_linked_table,
		     (bfd_boolean (*) (struct bfd_hash_entry *,
				       void *)) func,
		     info);
}

struct bfd_section_already_linked_hash_entry *
bfd_section_already_linked_table_lookup (const char *name)
{
  return ((struct bfd_section_already_linked_hash_entry *)
	  bfd_hash_lookup (&_bfd_section_already_linked_table, name,
			   TRUE, FALSE));
}

void
bfd_section_already_linked_table_insert
  (struct bfd_section_already_linked_hash_entry *already_linked_list,
   asection *sec)
{
  struct bfd_section_already_linked *l;

  /* Allocate the memory from the same obstack as the hash table is
     kept in.  */
  l = bfd_hash_allocate (&_bfd_section_already_linked_table, sizeof *l);
  l->sec = sec;
  l->next = already_linked_list->entry;
  already_linked_list->entry = l;
}

static struct bfd_hash_entry *
already_linked_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED,
			struct bfd_hash_table *table,
			const char *string ATTRIBUTE_UNUSED)
{
  struct bfd_section_already_linked_hash_entry *ret =
    bfd_hash_allocate (table, sizeof *ret);

  ret->entry = NULL;

  return &ret->root;
}

bfd_boolean
bfd_section_already_linked_table_init (void)
{
  return bfd_hash_table_init_n (&_bfd_section_already_linked_table,
				already_linked_newfunc, 42);
}

void
bfd_section_already_linked_table_free (void)
{
  bfd_hash_table_free (&_bfd_section_already_linked_table);
}

/* This is used on non-ELF inputs.  */

void
_bfd_generic_section_already_linked (bfd *abfd, asection *sec)
{
  flagword flags;
  const char *name;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;

  flags = sec->flags;
  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.  */

  name = bfd_get_section_name (abfd, sec);

  already_linked_list = bfd_section_already_linked_table_lookup (name);

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      bfd_boolean skip = FALSE;
      struct coff_comdat_info *s_comdat
	= bfd_coff_get_comdat_section (abfd, sec);
      struct coff_comdat_info *l_comdat
	= bfd_coff_get_comdat_section (l->sec->owner, l->sec);

      /* We may have 3 different sections on the list: group section,
	 comdat section and linkonce section. SEC may be a linkonce or
	 comdat section. We always ignore group section. For non-COFF
	 inputs, we also ignore comdat section.

	 FIXME: Is that safe to match a linkonce section with a comdat
	 section for COFF inputs?  */
      if ((l->sec->flags & SEC_GROUP) != 0)
	skip = TRUE;
      else if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
	{
	  if (s_comdat != NULL
	      && l_comdat != NULL
	      && strcmp (s_comdat->name, l_comdat->name) != 0)
	    skip = TRUE;
	}
      else if (l_comdat != NULL)
	skip = TRUE;

      if (!skip)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();

	    case SEC_LINK_DUPLICATES_DISCARD:
	      break;

	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      (*_bfd_error_handler)
		(_("%B: warning: ignoring duplicate section `%A'\n"),
		 abfd, sec);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      /* FIXME: We should really dig out the contents of both
                 sections and memcmp them.  The COFF/PE spec says that
                 the Microsoft linker does not implement this
                 correctly, so I'm not going to bother doing it
                 either.  */
	      /* Fall through.  */
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (sec->size != l->sec->size)
		(*_bfd_error_handler)
		  (_("%B: warning: duplicate section `%A' has different size\n"),
		   abfd, sec);
	      break;
	    }

	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;

	  return;
	}
    }

  /* This is the first section with this name.  Record it.  */
  bfd_section_already_linked_table_insert (already_linked_list, sec);
}
@


1.34.8.3
log
@Merge from mainline.
@
text
@d458 1
a458 1
      h->u.undef.next = NULL;
d619 1
a619 1
  BFD_ASSERT (h->u.undef.next == NULL);
d621 1
a621 1
    table->undefs_tail->u.undef.next = h;
d993 1
a993 1
	    *pundef = (*pundef)->u.undef.next;
d995 1
a995 1
	    pundef = &(*pundef)->u.undef.next;
d1018 1
a1018 1
	      pundef = &(*pundef)->u.undef.next;
d1067 1
a1067 1
      pundef = &(*pundef)->u.undef.next;
d1697 2
a1698 2
	  if (h->u.undef.next == NULL && info->hash->undefs_tail != h)
	    h->u.undef.next = h;
d1884 2
a1885 2
	  if (h->u.undef.next == NULL && info->hash->undefs_tail != h)
	    h->u.undef.next = h;
d1900 1
a1900 1
	     the u.undef.next field is not NULL, or it is the tail of the
d1903 1
a1903 1
	  if (h->u.undef.next != NULL || info->hash->undefs_tail == h)
@


1.34.6.1
log
@include/
	PR 51.
	* bfdlink.h (struct bfd_link_info): Add wrap_char.
bfd/
	PR 51.
	* linker.c (bfd_wrapped_link_hash_lookup): Handle info->wrap_char.
ld/
	PR 51.
	* emultempl/ppc64elf.em (ppc_create_output_section_statements): Set
	link_info.wrap_char.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
a525 1
      char prefix = '\0';
d528 2
a529 5
      if (*l == bfd_get_symbol_leading_char (abfd) || *l == info->wrap_char)
	{
	  prefix = *l;
	  ++l;
	}
d547 2
a548 1
	  n[0] = prefix;
d579 2
a580 1
	  n[0] = prefix;
@


1.33
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d458 1
a458 1
      h->next = NULL;
d617 1
a617 1
  BFD_ASSERT (h->next == NULL);
d619 1
a619 1
    table->undefs_tail->next = h;
d991 1
a991 1
	    *pundef = (*pundef)->next;
d993 1
a993 1
	    pundef = &(*pundef)->next;
d1016 1
a1016 1
	      pundef = &(*pundef)->next;
d1065 1
a1065 1
      pundef = &(*pundef)->next;
d1695 2
a1696 2
	  if (h->next == NULL && info->hash->undefs_tail != h)
	    h->next = h;
d1882 2
a1883 2
	  if (h->next == NULL && info->hash->undefs_tail != h)
	    h->next = h;
d1898 1
a1898 1
	     the next field is not NULL, or it is the tail of the
d1901 1
a1901 1
	  if (h->next != NULL || info->hash->undefs_tail == h)
@


1.32
log
@Convert to C90 and a few tweaks.
@
text
@d789 1
a789 1
  struct symbol_cache_entry **outsyms;
@


1.31
log
@Correct spelling of "relocatable".
@
text
@d409 2
a410 2
static bfd_boolean generic_link_read_symbols
  PARAMS ((bfd *));
d412 1
a412 3
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean collect));
static bfd_boolean generic_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean collect));
d414 1
a414 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
d416 1
a416 1
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
d418 1
a418 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded,
	   bfd_boolean collect));
d420 2
a421 6
  PARAMS ((bfd *, struct bfd_link_info *, bfd_size_type count, asymbol **,
	   bfd_boolean collect));
static bfd *hash_entry_bfd
  PARAMS ((struct bfd_link_hash_entry *));
static void set_symbol_from_hash
  PARAMS ((asymbol *, struct bfd_link_hash_entry *));
d423 1
a423 1
  PARAMS ((bfd *, size_t *psymalloc, asymbol *));
d425 1
a425 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   struct bfd_link_order *));
d427 2
a428 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   struct bfd_link_order *, bfd_boolean));
d437 3
a439 4
_bfd_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d445 1
a445 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d468 6
a473 6
_bfd_link_hash_table_init (table, abfd, newfunc)
     struct bfd_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d488 5
a492 6
bfd_link_hash_lookup (table, string, create, copy, follow)
     struct bfd_link_hash_table *table;
     const char *string;
     bfd_boolean create;
     bfd_boolean copy;
     bfd_boolean follow;
d499 1
a499 1
  if (follow && ret != (struct bfd_link_hash_entry *) NULL)
d514 6
a519 7
bfd_wrapped_link_hash_lookup (abfd, info, string, create, copy, follow)
     bfd *abfd;
     struct bfd_link_info *info;
     const char *string;
     bfd_boolean create;
     bfd_boolean copy;
     bfd_boolean follow;
d543 1
a543 1
	  n = (char *) bfd_malloc (amt);
d575 1
a575 1
	  n = (char *) bfd_malloc (amt);
d601 4
a604 4
bfd_link_hash_traverse (table, func, info)
     struct bfd_link_hash_table *table;
     bfd_boolean (*func) PARAMS ((struct bfd_link_hash_entry *, PTR));
     PTR info;
d607 1
a607 2
		     ((bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR)))
		      func),
d613 3
a615 4
INLINE void
bfd_link_add_undef (table, h)
     struct bfd_link_hash_table *table;
     struct bfd_link_hash_entry *h;
d618 1
a618 1
  if (table->undefs_tail != (struct bfd_link_hash_entry *) NULL)
d620 1
a620 1
  if (table->undefs == (struct bfd_link_hash_entry *) NULL)
d628 3
a630 4
_bfd_generic_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d636 1
a636 1
      entry = (struct bfd_hash_entry *)
d660 1
a660 2
_bfd_generic_link_hash_table_create (abfd)
     bfd *abfd;
d665 1
a665 1
  ret = (struct generic_link_hash_table *) bfd_malloc (amt);
d667 1
a667 1
    return (struct bfd_link_hash_table *) NULL;
d672 1
a672 1
      return (struct bfd_link_hash_table *) NULL;
d678 1
a678 2
_bfd_generic_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d695 1
a695 2
generic_link_read_symbols (abfd)
     bfd *abfd;
d697 1
a697 1
  if (bfd_get_outsymbols (abfd) == (asymbol **) NULL)
d705 1
a705 2
      bfd_get_outsymbols (abfd) =
	(asymbol **) bfd_alloc (abfd, (bfd_size_type) symsize);
d722 1
a722 3
_bfd_generic_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d735 1
a735 3
_bfd_generic_link_add_symbols_collect (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d745 2
a746 3
_bfd_generic_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d755 3
a757 4
generic_link_add_symbols (abfd, info, collect)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean collect;
d784 3
a786 4
generic_link_add_object_symbols (abfd, info, collect)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean collect;
a824 8
static struct bfd_hash_entry *archive_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean archive_hash_table_init
  PARAMS ((struct archive_hash_table *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));

d828 3
a830 4
archive_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d836 3
a838 4
  if (ret == (struct archive_hash_entry *) NULL)
    ret = ((struct archive_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct archive_hash_entry)));
  if (ret == (struct archive_hash_entry *) NULL)
d848 1
a848 1
      ret->defs = (struct archive_list *) NULL;
d851 1
a851 1
  return (struct bfd_hash_entry *) ret;
d857 5
a861 5
archive_hash_table_init (table, newfunc)
     struct archive_hash_table *table;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d914 4
a917 5
_bfd_generic_link_add_archive_symbols (abfd, info, checkfn)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean (*checkfn)
       PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
d930 1
a930 1
      if (bfd_openr_next_archived_file (abfd, (bfd *) NULL) == NULL)
d949 1
a949 1
      if (arh == (struct archive_hash_entry *) NULL)
d956 1
a956 3
      for (pp = &arh->defs;
	   *pp != (struct archive_list *) NULL;
	   pp = &(*pp)->next)
d970 1
a970 1
  while (*pundef != (struct bfd_link_hash_entry *) NULL)
d999 1
a999 1
      if (arh == (struct archive_hash_entry *) NULL)
d1006 1
a1006 1
	      char *buf = (char *) bfd_malloc (amt);
d1014 1
a1014 1
	  if (arh == (struct archive_hash_entry *) NULL)
d1021 1
a1021 1
      for (l = arh->defs; l != (struct archive_list *) NULL; l = l->next)
d1032 1
a1032 1
	  if (element == (bfd *) NULL)
d1086 4
a1089 4
generic_link_check_archive_element_no_collect (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
d1099 3
a1101 4
generic_link_check_archive_element_collect (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
d1110 4
a1113 5
generic_link_check_archive_element (abfd, info, pneeded, collect)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
     bfd_boolean collect;
d1143 1
a1143 1
      if (h == (struct bfd_link_hash_entry *) NULL
d1177 1
a1177 1
	  if (symbfd == (bfd *) NULL)
d1198 2
a1199 3
	    ((struct bfd_link_hash_common_entry *)
	     bfd_hash_allocate (&info->hash->table,
				sizeof (struct bfd_link_hash_common_entry)));
d1240 5
a1244 6
generic_link_add_symbol_list (abfd, info, symbol_count, symbols, collect)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_size_type symbol_count;
     asymbol **symbols;
     bfd_boolean collect;
d1318 1
a1318 1
	      if (h->sym == (asymbol *) NULL
d1337 1
a1337 1
	  p->udata.p = (PTR) h;
d1437 1
a1437 2
hash_entry_bfd (h)
     struct bfd_link_hash_entry *h;
d1476 10
a1485 12
_bfd_generic_link_add_one_symbol (info, abfd, name, flags, section, value,
				  string, copy, collect, hashp)
     struct bfd_link_info *info;
     bfd *abfd;
     const char *name;
     flagword flags;
     asection *section;
     bfd_vma value;
     const char *string;
     bfd_boolean copy;
     bfd_boolean collect;
     struct bfd_link_hash_entry **hashp;
d1529 2
a1530 3
      || (info->notice_hash != (struct bfd_hash_table *) NULL
	  && (bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE)
	      != (struct bfd_hash_entry *) NULL)))
d1537 1
a1537 1
  if (hashp != (struct bfd_link_hash_entry **) NULL)
d1575 1
a1575 1
		  abfd, bfd_link_hash_defined, (bfd_vma) 0)))
d1650 2
a1651 3
	    ((struct bfd_link_hash_common_entry *)
	     bfd_hash_allocate (&info->hash->table,
				sizeof (struct bfd_link_hash_common_entry)));
d1757 1
a1757 1
		   (info, h->root.string, obfd, h->type, (bfd_vma) 0,
d1811 1
a1811 1
		  abfd, bfd_link_hash_indirect, (bfd_vma) 0)))
d1823 1
a1823 1
	    if (inh == (struct bfd_link_hash_entry *) NULL)
d1868 1
a1868 2
						 (asection *) NULL,
						 (bfd_vma) 0))
d1891 1
a1891 2
					     hash_entry_bfd (h),
					     (asection *) NULL, (bfd_vma) 0))
d1904 1
a1904 3
						 hash_entry_bfd (h),
						 (asection *) NULL,
						 (bfd_vma) 0))
d1917 1
a1917 2
		    ((struct bfd_hash_entry *) NULL, &info->hash->table,
		     h->root.string)));
d1954 1
a1954 3
_bfd_generic_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1962 1
a1962 1
  bfd_get_outsymbols (abfd) = (asymbol **) NULL;
d1973 1
a1973 1
  for (sub = info->input_bfds; sub != (bfd *) NULL; sub = sub->link_next)
d1983 1
a1983 1
				   (PTR) &wginfo);
d1994 1
a1994 3
      for (o = abfd->sections;
	   o != (asection *) NULL;
	   o = o->next)
d1997 1
a1997 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d2017 1
a2017 1
		  relocs = (arelent **) bfd_malloc ((bfd_size_type) relsize);
d2039 1
a2039 1
	      o->orelocation = (arelent **) bfd_alloc (abfd, amt);
d2051 3
a2053 7
  for (o = abfd->sections;
       o != (asection *) NULL;
       o = o->next)
    {
      for (p = o->link_order_head;
	   p != (struct bfd_link_order *) NULL;
	   p = p->next)
d2080 1
a2080 4
generic_add_output_symbol (output_bfd, psymalloc, sym)
     bfd *output_bfd;
     size_t *psymalloc;
     asymbol *sym;
d2093 2
a2094 2
      newsyms = (asymbol **) bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
      if (newsyms == (asymbol **) NULL)
d2109 4
a2112 5
_bfd_generic_link_output_symbols (output_bfd, input_bfd, info, psymalloc)
     bfd *output_bfd;
     bfd *input_bfd;
     struct bfd_link_info *info;
     size_t *psymalloc;
d2121 1
a2121 1
  if (info->create_object_symbols_section != (asection *) NULL)
d2125 1
a2125 3
      for (sec = input_bfd->sections;
	   sec != (asection *) NULL;
	   sec = sec->next)
d2158 1
a2158 1
      h = (struct generic_link_hash_entry *) NULL;
d2170 1
a2170 1
	    h = (struct generic_link_hash_entry *) sym->udata.p;
d2193 1
a2193 1
	  if (h != (struct generic_link_hash_entry *) NULL)
d2202 1
a2202 1
		  if (h->sym != (asymbol *) NULL)
d2254 2
a2255 3
	      && (bfd_hash_lookup (info->keep_hash, bfd_asymbol_name (sym),
				   FALSE, FALSE)
		  == (struct bfd_hash_entry *) NULL)))
d2334 1
a2334 1
	  if (h != (struct generic_link_hash_entry *) NULL)
d2346 1
a2346 3
set_symbol_from_hash (sym, h)
     asymbol *sym;
     struct bfd_link_hash_entry *h;
d2407 2
a2408 3
_bfd_generic_link_write_global_symbol (h, data)
     struct generic_link_hash_entry *h;
     PTR data;
d2410 1
a2410 2
  struct generic_write_global_symbol_info *wginfo =
    (struct generic_write_global_symbol_info *) data;
d2427 1
a2427 1
  if (h->sym != (asymbol *) NULL)
d2455 4
a2458 5
_bfd_generic_reloc_link_order (abfd, info, sec, link_order)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     struct bfd_link_order *link_order;
d2464 1
a2464 1
  if (sec->orelocation == (arelent **) NULL)
d2467 2
a2468 2
  r = (arelent *) bfd_alloc (abfd, (bfd_size_type) sizeof (arelent));
  if (r == (arelent *) NULL)
d2490 1
a2490 1
      if (h == (struct generic_link_hash_entry *) NULL
d2494 1
a2494 2
		 (info, link_order->u.reloc.p->u.name,
		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
d2515 2
a2516 2
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == (bfd_byte *) NULL)
d2535 1
a2535 1
		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
d2543 1
a2543 2
      ok = bfd_set_section_contents (abfd, sec, (PTR) buf, loc,
				     (bfd_size_type) size);
d2560 1
a2560 3
bfd_new_link_order (abfd, section)
     bfd *abfd;
     asection *section;
d2565 1
a2565 1
  new = (struct bfd_link_order *) bfd_zalloc (abfd, amt);
d2571 1
a2571 1
  if (section->link_order_tail != (struct bfd_link_order *) NULL)
d2585 4
a2588 5
_bfd_default_link_order (abfd, info, sec, link_order)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     struct bfd_link_order *link_order;
d2608 4
a2611 5
default_data_link_order (abfd, info, sec, link_order)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec;
     struct bfd_link_order *link_order;
d2630 1
a2630 1
      fill = (bfd_byte *) bfd_malloc (size);
d2662 5
a2666 7
default_indirect_link_order (output_bfd, info, output_section, link_order,
			     generic_linker)
     bfd *output_bfd;
     struct bfd_link_info *info;
     asection *output_section;
     struct bfd_link_order *link_order;
     bfd_boolean generic_linker;
d2689 1
a2689 1
      && output_section->orelocation == (arelent **) NULL)
d2741 1
a2741 1
		h = (struct bfd_link_hash_entry *) sym->udata.p;
d2758 1
a2758 1
  contents = ((bfd_byte *) bfd_malloc (sec_size));
d2770 1
a2770 1
				  (PTR) new_contents, loc, link_order->size))
d2787 1
a2787 2
_bfd_count_link_order_relocs (link_order)
     struct bfd_link_order *link_order;
d2793 1
a2793 1
  for (l = link_order; l != (struct bfd_link_order *) NULL; l = l->next)
d2808 1
a2808 1
        bfd_boolean bfd_link_split_section(bfd *abfd, asection *sec);
d2821 2
a2822 3
_bfd_generic_link_split_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
@


1.30
log
@Fix memory leaks
@
text
@d91 1
a91 1
	(this index number is used so that when doing a relocateable
d280 1
a280 1
	hash table.  When producing relocateable output, it must
d320 1
a320 1
	while generating a relocateable object file.
d342 1
a342 1
	section contents.  If performing a relocateable link, the
d2046 1
a2046 1
  if (info->relocateable)
d2365 1
a2365 1
		  if (info->relocateable
d2537 1
a2537 1
  if (! info->relocateable)
d2770 1
a2770 1
  if (info->relocateable
d2780 1
a2780 1
	(_("Attempt to do relocateable link with %s input and %s output"),
d2845 1
a2845 1
		  (output_bfd, info, link_order, contents, info->relocateable,
@


1.29
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d2084 1
a2089 1
		  free (relocs);
@


1.28
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d639 1
a639 1
/* Routine to create an entry in an generic link hash table.  */
d672 1
a672 1
/* Create an generic link hash table.  */
@


1.27
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d203 1
a203 1
	<<keep_memory>> field of the <<info>> argument is true, so
d409 1
a409 1
static boolean generic_link_read_symbols
d411 12
a422 11
static boolean generic_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean collect));
static boolean generic_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean collect));
static boolean generic_link_check_archive_element_no_collect
  PARAMS ((bfd *, struct bfd_link_info *, boolean *pneeded));
static boolean generic_link_check_archive_element_collect
  PARAMS ((bfd *, struct bfd_link_info *, boolean *pneeded));
static boolean generic_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *pneeded, boolean collect));
static boolean generic_link_add_symbol_list
d424 3
a426 2
	   boolean collect));
static bfd *hash_entry_bfd PARAMS ((struct bfd_link_hash_entry *));
d429 1
a429 1
static boolean generic_add_output_symbol
d431 1
a431 1
static boolean default_data_link_order
d434 1
a434 1
static boolean default_indirect_link_order
d436 1
a436 1
	   struct bfd_link_order *, boolean));
d477 1
a477 1
boolean
d493 1
a493 1
/* Look up a symbol in a link hash table.  If follow is true, we
d501 3
a503 3
     boolean create;
     boolean copy;
     boolean follow;
d529 3
a531 3
     boolean create;
     boolean copy;
     boolean follow;
d546 1
a546 1
      if (bfd_hash_lookup (info->wrap_hash, l, false, false) != NULL)
d564 1
a564 1
	  h = bfd_link_hash_lookup (info->hash, n, create, true, follow);
d577 1
a577 1
			      false, false) != NULL)
d595 1
a595 1
	  h = bfd_link_hash_lookup (info->hash, n, create, true, follow);
d615 1
a615 1
     boolean (*func) PARAMS ((struct bfd_link_hash_entry *, PTR));
d619 1
a619 1
		     ((boolean (*) PARAMS ((struct bfd_hash_entry *, PTR)))
d665 1
a665 1
      ret->written = false;
d711 1
a711 1
static boolean
d722 1
a722 1
	return false;
d726 1
a726 1
	return false;
d729 1
a729 1
	return false;
d733 1
a733 1
  return true;
d740 1
a740 1
boolean
d745 1
a745 1
  return generic_link_add_symbols (abfd, info, false);
d755 1
a755 1
boolean
d760 1
a760 1
  return generic_link_add_symbols (abfd, info, true);
d778 1
a778 1
static boolean
d782 1
a782 1
     boolean collect;
d784 1
a784 1
  boolean ret;
d800 1
a800 1
      ret = false;
d808 1
a808 1
static boolean
d812 1
a812 1
     boolean collect;
d818 1
a818 1
    return false;
d853 1
a853 1
static boolean archive_hash_table_init
d892 1
a892 1
static boolean
d932 1
a932 1
   included.  CHECKFN should set *PNEEDED to true if the object file
d935 1
a935 1
   to the global hash table.  CHECKFN should only return false if some
d949 1
a949 1
boolean
d953 2
a954 2
     boolean (*checkfn) PARAMS ((bfd *, struct bfd_link_info *,
				 boolean *pneeded));
d968 1
a968 1
	return true;
d970 1
a970 1
      return false;
d979 1
a979 1
    return false;
d985 1
a985 1
      arh = archive_hash_lookup (&arsym_hash, arsym->name, true, false);
d1037 1
a1037 1
      arh = archive_hash_lookup (&arsym_hash, h->root.string, false, false);
d1047 1
a1047 1
		return false;
d1050 1
a1050 1
	      arh = archive_hash_lookup (&arsym_hash, buf, false, false);
d1063 1
a1063 1
	  boolean needed;
d1112 1
a1112 1
  return true;
d1116 1
a1116 1
  return false;
d1124 1
a1124 1
static boolean
d1128 1
a1128 1
     boolean *pneeded;
d1130 1
a1130 1
  return generic_link_check_archive_element (abfd, info, pneeded, false);
d1137 1
a1137 1
static boolean
d1141 1
a1141 1
     boolean *pneeded;
d1143 1
a1143 1
  return generic_link_check_archive_element (abfd, info, pneeded, true);
d1149 1
a1149 1
static boolean
d1153 2
a1154 2
     boolean *pneeded;
     boolean collect;
d1158 1
a1158 1
  *pneeded = false;
d1161 1
a1161 1
    return false;
d1182 2
a1183 2
      h = bfd_link_hash_lookup (info->hash, bfd_asymbol_name (p), false,
				false, true);
d1199 1
a1199 1
	    return false;
d1204 3
a1206 3
	    return false;
	  *pneeded = true;
	  return true;
d1225 3
a1227 3
		return false;
	      *pneeded = true;
	      return true;
d1243 1
a1243 1
	    return false;
d1272 1
a1272 1
  return true;
d1278 1
a1278 1
   is true if constructors should be automatically collected by name
d1281 1
a1281 1
static boolean
d1287 1
a1287 1
     boolean collect;
d1336 2
a1337 2
		  p->value, string, false, collect, &bh)))
	    return false;
d1384 1
a1384 1
  return true;
d1511 1
a1511 1
   COPY is true if NAME or STRING must be copied into locally
d1513 1
a1513 1
   COLLECT is true if we should automatically collect gcc constructor
d1519 1
a1519 1
boolean
d1529 2
a1530 2
     boolean copy;
     boolean collect;
d1535 1
a1535 1
  boolean cycle;
d1563 1
a1563 1
	h = bfd_wrapped_link_hash_lookup (abfd, info, name, true, copy, false);
d1565 1
a1565 1
	h = bfd_link_hash_lookup (info->hash, name, true, copy, false);
d1570 1
a1570 1
	  return false;
d1576 1
a1576 1
	  && (bfd_hash_lookup (info->notice_hash, name, false, false)
d1581 1
a1581 1
	return false;
d1591 1
a1591 1
      cycle = false;
d1623 1
a1623 1
	    return false;
d1683 1
a1683 1
			  return false;
d1701 1
a1701 1
	    return false;
d1756 1
a1756 1
	    return false;
d1807 1
a1807 1
	      return false;
d1849 1
a1849 1
		return false;
d1860 1
a1860 1
	    return false;
d1869 2
a1870 2
	    inh = bfd_wrapped_link_hash_lookup (abfd, info, string, true,
						copy, false);
d1872 1
a1872 1
	      return false;
d1880 1
a1880 1
		return false;
d1895 1
a1895 1
		cycle = true;
d1907 1
a1907 1
	    return false;
d1918 1
a1918 1
		return false;
d1926 1
a1926 1
	  cycle = true;
d1934 1
a1934 1
	  cycle = true;
d1942 1
a1942 1
	    return false;
d1957 1
a1957 1
		return false;
d1972 1
a1972 1
	      return false;
d1985 1
a1985 1
		  return false;
d2001 1
a2001 1
  return true;
d2006 1
a2006 1
boolean
d2025 1
a2025 1
	p->u.indirect.section->linker_mark = (unsigned int) true;
d2030 1
a2030 1
      return false;
d2044 1
a2044 1
    return false;
d2075 1
a2075 1
		    return false;
d2078 1
a2078 1
		    return false;
d2085 1
a2085 1
		    return false;
d2100 1
a2100 1
		return false;
d2123 1
a2123 1
		return false;
d2126 2
a2127 2
	      if (! default_indirect_link_order (abfd, info, o, p, true))
		return false;
d2131 1
a2131 1
		return false;
d2137 1
a2137 1
  return true;
d2142 1
a2142 1
static boolean
d2161 1
a2161 1
	return false;
d2169 1
a2169 1
  return true;
d2174 1
a2174 1
boolean
d2185 1
a2185 1
    return false;
d2202 1
a2202 1
		return false;
d2210 1
a2210 1
		return false;
d2225 1
a2225 1
      boolean output;
d2256 1
a2256 1
					       false, false, true));
d2260 1
a2260 1
					       false, false, true);
d2324 1
a2324 1
				   false, false)
d2326 1
a2326 1
	output = false;
d2335 1
a2335 1
	    output = true;
d2337 1
a2337 1
	    output = false;
d2340 1
a2340 1
	output = false;
d2344 1
a2344 1
	    output = true;
d2346 1
a2346 1
	    output = false;
d2350 1
a2350 1
	output = false;
d2354 1
a2354 1
	    output = false;
d2361 1
a2361 1
		  output = false;
d2364 1
a2364 1
		  output = true;
d2371 1
a2371 1
		    output = false;
d2373 1
a2373 1
		    output = true;
d2376 1
a2376 1
		  output = true;
d2384 1
a2384 1
	    output = true;
d2386 1
a2386 1
	    output = false;
d2398 1
a2398 1
	output = false;
d2403 1
a2403 1
	    return false;
d2405 1
a2405 1
	    h->written = true;
d2409 1
a2409 1
  return true;
d2478 1
a2478 1
boolean
d2491 1
a2491 1
    return true;
d2493 1
a2493 1
  h->written = true;
d2498 2
a2499 2
			      false, false) == NULL))
    return true;
d2507 1
a2507 1
	return false;
d2523 1
a2523 1
  return true;
d2528 1
a2528 1
boolean
d2544 1
a2544 1
    return false;
d2551 1
a2551 1
      return false;
d2564 1
a2564 1
					 false, false, true));
d2571 1
a2571 1
	    return false;
d2573 1
a2573 1
	  return false;
d2587 1
a2587 1
      boolean ok;
d2593 1
a2593 1
	return false;
d2614 1
a2614 1
	      return false;
d2623 1
a2623 1
	return false;
d2631 1
a2631 1
  return true;
d2663 1
a2663 1
boolean
d2679 1
a2679 1
					  false);
d2687 1
a2687 1
static boolean
d2698 1
a2698 1
  boolean result;
d2704 1
a2704 1
    return true;
d2713 1
a2713 1
	return false;
d2742 1
a2742 1
static boolean
d2749 1
a2749 1
     boolean generic_linker;
d2761 1
a2761 1
    return true;
d2783 1
a2783 1
      return false;
d2796 1
a2796 1
	return false;
d2828 1
a2828 1
						  false, false, true);
d2832 1
a2832 1
					  false, false, true);
d2858 1
a2858 1
  return true;
d2863 1
a2863 1
  return false;
d2892 1
a2892 1
        boolean bfd_link_split_section(bfd *abfd, asection *sec);
d2904 1
a2904 1
boolean
d2909 1
a2909 1
  return false;
@


1.26
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d452 2
a453 1
      entry = bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d649 2
a650 2
      entry = bfd_hash_allocate (table,
				 sizeof (struct generic_link_hash_entry));
d2023 1
a2023 1
	p->u.indirect.section->linker_mark = true;
@


1.25
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d1308 1
d1330 1
a1330 1
	  h = NULL;
d1333 1
a1333 2
		  p->value, string, false, collect,
		  (struct bfd_link_hash_entry **) &h)))
d1335 1
@


1.25.14.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1307 1
	  struct bfd_link_hash_entry *bh;
d1329 1
a1329 1
	  bh = NULL;
d1332 2
a1333 1
		  p->value, string, false, collect, &bh)))
a1334 1
	  h = (struct generic_link_hash_entry *) bh;
@


1.25.14.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d91 1
a91 1
	(this index number is used so that when doing a relocatable
d203 1
a203 1
	<<keep_memory>> field of the <<info>> argument is TRUE, so
d280 1
a280 1
	hash table.  When producing relocatable output, it must
d320 1
a320 1
	while generating a relocatable object file.
d342 1
a342 1
	section contents.  If performing a relocatable link, the
d409 26
a434 20
static bfd_boolean generic_link_add_object_symbols
  (bfd *, struct bfd_link_info *, bfd_boolean collect);
static bfd_boolean generic_link_add_symbols
  (bfd *, struct bfd_link_info *, bfd_boolean);
static bfd_boolean generic_link_check_archive_element_no_collect
  (bfd *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean generic_link_check_archive_element_collect
  (bfd *, struct bfd_link_info *, bfd_boolean *);
static bfd_boolean generic_link_check_archive_element
  (bfd *, struct bfd_link_info *, bfd_boolean *, bfd_boolean);
static bfd_boolean generic_link_add_symbol_list
  (bfd *, struct bfd_link_info *, bfd_size_type count, asymbol **,
   bfd_boolean);
static bfd_boolean generic_add_output_symbol
  (bfd *, size_t *psymalloc, asymbol *);
static bfd_boolean default_data_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
static bfd_boolean default_indirect_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *,
   bfd_boolean);
d443 4
a446 3
_bfd_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
d465 1
a465 1
      h->und_next = NULL;
d474 7
a480 7
bfd_boolean
_bfd_link_hash_table_init
  (struct bfd_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d490 1
a490 1
/* Look up a symbol in a link hash table.  If follow is TRUE, we
d495 6
a500 5
bfd_link_hash_lookup (struct bfd_link_hash_table *table,
		      const char *string,
		      bfd_boolean create,
		      bfd_boolean copy,
		      bfd_boolean follow)
d507 1
a507 1
  if (follow && ret != NULL)
d522 7
a528 6
bfd_wrapped_link_hash_lookup (bfd *abfd,
			      struct bfd_link_info *info,
			      const char *string,
			      bfd_boolean create,
			      bfd_boolean copy,
			      bfd_boolean follow)
d543 1
a543 1
      if (bfd_hash_lookup (info->wrap_hash, l, FALSE, FALSE) != NULL)
d552 1
a552 1
	  n = bfd_malloc (amt);
d561 1
a561 1
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
d574 1
a574 1
			      FALSE, FALSE) != NULL)
d584 1
a584 1
	  n = bfd_malloc (amt);
d592 1
a592 1
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
d610 4
a613 4
bfd_link_hash_traverse
  (struct bfd_link_hash_table *table,
   bfd_boolean (*func) (struct bfd_link_hash_entry *, void *),
   void *info)
d616 2
a617 1
		     (bfd_boolean (*) (struct bfd_hash_entry *, void *)) func,
d623 9
a631 8
void
bfd_link_add_undef (struct bfd_link_hash_table *table,
		    struct bfd_link_hash_entry *h)
{
  BFD_ASSERT (h->und_next == NULL);
  if (table->undefs_tail != NULL)
    table->undefs_tail->und_next = h;
  if (table->undefs == NULL)
d636 1
a636 1
/* Routine to create an entry in a generic link hash table.  */
d639 4
a642 3
_bfd_generic_link_hash_newfunc (struct bfd_hash_entry *entry,
				struct bfd_hash_table *table,
				const char *string)
d648 2
a649 2
      entry =
	bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry));
d662 1
a662 1
      ret->written = FALSE;
d669 1
a669 1
/* Create a generic link hash table.  */
d672 2
a673 1
_bfd_generic_link_hash_table_create (bfd *abfd)
d678 1
a678 1
  ret = bfd_malloc (amt);
d680 1
a680 1
    return NULL;
d685 1
a685 1
      return NULL;
d691 2
a692 1
_bfd_generic_link_hash_table_free (struct bfd_link_hash_table *hash)
d708 3
a710 2
static bfd_boolean
generic_link_read_symbols (bfd *abfd)
d712 1
a712 1
  if (bfd_get_outsymbols (abfd) == NULL)
d719 3
a721 2
	return FALSE;
      bfd_get_outsymbols (abfd) = bfd_alloc (abfd, symsize);
d723 1
a723 1
	return FALSE;
d726 1
a726 1
	return FALSE;
d730 1
a730 1
  return TRUE;
d737 4
a740 2
bfd_boolean
_bfd_generic_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d742 1
a742 1
  return generic_link_add_symbols (abfd, info, FALSE);
d752 4
a755 2
bfd_boolean
_bfd_generic_link_add_symbols_collect (bfd *abfd, struct bfd_link_info *info)
d757 1
a757 1
  return generic_link_add_symbols (abfd, info, TRUE);
d765 3
a767 2
_bfd_generic_link_just_syms (asection *sec,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED)
d775 5
a779 4
static bfd_boolean
generic_link_add_symbols (bfd *abfd,
			  struct bfd_link_info *info,
			  bfd_boolean collect)
d781 1
a781 1
  bfd_boolean ret;
d797 1
a797 1
      ret = FALSE;
d805 5
a809 4
static bfd_boolean
generic_link_add_object_symbols (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean collect)
d812 1
a812 1
  struct bfd_symbol **outsyms;
d815 1
a815 1
    return FALSE;
d848 8
d859 4
a862 3
archive_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *table,
		      const char *string)
d868 4
a871 3
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct archive_hash_entry));
  if (ret == NULL)
d881 1
a881 1
      ret->defs = NULL;
d884 1
a884 1
  return &ret->root;
d889 6
a894 6
static bfd_boolean
archive_hash_table_init
  (struct archive_hash_table *table,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d929 1
a929 1
   included.  CHECKFN should set *PNEEDED to TRUE if the object file
d932 1
a932 1
   to the global hash table.  CHECKFN should only return FALSE if some
d946 6
a951 5
bfd_boolean
_bfd_generic_link_add_archive_symbols
  (bfd *abfd,
   struct bfd_link_info *info,
   bfd_boolean (*checkfn) (bfd *, struct bfd_link_info *, bfd_boolean *))
d964 2
a965 2
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
	return TRUE;
d967 1
a967 1
      return FALSE;
d976 1
a976 1
    return FALSE;
d982 2
a983 2
      arh = archive_hash_lookup (&arsym_hash, arsym->name, TRUE, FALSE);
      if (arh == NULL)
d990 3
a992 1
      for (pp = &arh->defs; *pp != NULL; pp = &(*pp)->next)
d1006 1
a1006 1
  while (*pundef != NULL)
d1027 1
a1027 1
	    *pundef = (*pundef)->und_next;
d1029 1
a1029 1
	    pundef = &(*pundef)->und_next;
d1034 2
a1035 2
      arh = archive_hash_lookup (&arsym_hash, h->root.string, FALSE, FALSE);
      if (arh == NULL)
d1042 1
a1042 1
	      char *buf = bfd_malloc (amt);
d1044 1
a1044 1
		return FALSE;
d1047 1
a1047 1
	      arh = archive_hash_lookup (&arsym_hash, buf, FALSE, FALSE);
d1050 1
a1050 1
	  if (arh == NULL)
d1052 1
a1052 1
	      pundef = &(*pundef)->und_next;
d1057 1
a1057 1
      for (l = arh->defs; l != NULL; l = l->next)
d1060 1
a1060 1
	  bfd_boolean needed;
d1068 1
a1068 1
	  if (element == NULL)
d1101 1
a1101 1
      pundef = &(*pundef)->und_next;
d1109 1
a1109 1
  return TRUE;
d1113 1
a1113 1
  return FALSE;
d1121 5
a1125 5
static bfd_boolean
generic_link_check_archive_element_no_collect (
					       bfd *abfd,
					       struct bfd_link_info *info,
					       bfd_boolean *pneeded)
d1127 1
a1127 1
  return generic_link_check_archive_element (abfd, info, pneeded, FALSE);
d1134 5
a1138 4
static bfd_boolean
generic_link_check_archive_element_collect (bfd *abfd,
					    struct bfd_link_info *info,
					    bfd_boolean *pneeded)
d1140 1
a1140 1
  return generic_link_check_archive_element (abfd, info, pneeded, TRUE);
d1146 6
a1151 5
static bfd_boolean
generic_link_check_archive_element (bfd *abfd,
				    struct bfd_link_info *info,
				    bfd_boolean *pneeded,
				    bfd_boolean collect)
d1155 1
a1155 1
  *pneeded = FALSE;
d1158 1
a1158 1
    return FALSE;
d1179 3
a1181 3
      h = bfd_link_hash_lookup (info->hash, bfd_asymbol_name (p), FALSE,
				FALSE, TRUE);
      if (h == NULL
d1196 1
a1196 1
	    return FALSE;
d1201 3
a1203 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d1215 1
a1215 1
	  if (symbfd == NULL)
d1222 3
a1224 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d1236 3
a1238 2
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
d1240 1
a1240 1
	    return FALSE;
d1269 1
a1269 1
  return TRUE;
d1275 1
a1275 1
   is TRUE if constructors should be automatically collected by name
d1278 7
a1284 6
static bfd_boolean
generic_link_add_symbol_list (bfd *abfd,
			      struct bfd_link_info *info,
			      bfd_size_type symbol_count,
			      asymbol **symbols,
			      bfd_boolean collect)
d1333 2
a1334 2
		  p->value, string, FALSE, collect, &bh)))
	    return FALSE;
d1358 1
a1358 1
	      if (h->sym == NULL
d1377 1
a1377 1
	  p->udata.p = h;
d1381 1
a1381 1
  return TRUE;
d1477 2
a1478 1
hash_entry_bfd (struct bfd_link_hash_entry *h)
d1508 1
a1508 1
   COPY is TRUE if NAME or STRING must be copied into locally
d1510 1
a1510 1
   COLLECT is TRUE if we should automatically collect gcc constructor
d1516 13
a1528 11
bfd_boolean
_bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
				  bfd *abfd,
				  const char *name,
				  flagword flags,
				  asection *section,
				  bfd_vma value,
				  const char *string,
				  bfd_boolean copy,
				  bfd_boolean collect,
				  struct bfd_link_hash_entry **hashp)
d1532 1
a1532 1
  bfd_boolean cycle;
d1560 1
a1560 1
	h = bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE);
d1562 1
a1562 1
	h = bfd_link_hash_lookup (info->hash, name, TRUE, copy, FALSE);
d1567 1
a1567 1
	  return FALSE;
d1572 3
a1574 2
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
d1578 1
a1578 1
	return FALSE;
d1581 1
a1581 1
  if (hashp != NULL)
d1588 1
a1588 1
      cycle = FALSE;
d1619 2
a1620 2
		  abfd, bfd_link_hash_defined, 0)))
	    return FALSE;
d1680 1
a1680 1
			  return FALSE;
d1694 3
a1696 2
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
d1698 1
a1698 1
	    return FALSE;
d1740 2
a1741 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1753 1
a1753 1
	    return FALSE;
d1802 1
a1802 1
		   (info, h->root.string, obfd, h->type, 0,
d1804 1
a1804 1
	      return FALSE;
d1846 1
a1846 1
		return FALSE;
d1856 2
a1857 2
		  abfd, bfd_link_hash_indirect, 0)))
	    return FALSE;
d1866 4
a1869 4
	    inh = bfd_wrapped_link_hash_lookup (abfd, info, string, TRUE,
						copy, FALSE);
	    if (inh == NULL)
	      return FALSE;
d1877 1
a1877 1
		return FALSE;
d1892 1
a1892 1
		cycle = TRUE;
d1904 1
a1904 1
	    return FALSE;
d1913 3
a1915 2
						 NULL, 0))
		return FALSE;
d1923 1
a1923 1
	  cycle = TRUE;
d1928 2
a1929 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1931 1
a1931 1
	  cycle = TRUE;
d1937 3
a1939 2
					     hash_entry_bfd (h), NULL, 0))
	    return FALSE;
d1945 1
a1945 1
	     the und_next field is not NULL, or it is the tail of the
d1948 1
a1948 1
	  if (h->und_next != NULL || info->hash->undefs_tail == h)
d1951 4
a1954 2
						 hash_entry_bfd (h), NULL, 0))
		return FALSE;
d1966 2
a1967 1
		    (NULL, &info->hash->table, h->root.string)));
d1969 1
a1969 1
	      return FALSE;
d1982 1
a1982 1
		  return FALSE;
d1998 1
a1998 1
  return TRUE;
d2003 4
a2006 2
bfd_boolean
_bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)
d2014 1
a2014 1
  bfd_get_outsymbols (abfd) = NULL;
d2022 1
a2022 1
	p->u.indirect.section->linker_mark = TRUE;
d2025 1
a2025 1
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
d2027 1
a2027 1
      return FALSE;
d2035 1
a2035 1
				   &wginfo);
d2041 1
a2041 1
    return FALSE;
d2043 1
a2043 1
  if (info->relocatable)
d2046 3
a2048 1
      for (o = abfd->sections; o != NULL; o = o->next)
d2051 3
a2053 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d2072 2
a2073 2
		    return FALSE;
		  relocs = bfd_malloc (relsize);
d2075 1
a2075 1
		    return FALSE;
a2080 1
		  free (relocs);
d2082 1
a2082 1
		    return FALSE;
d2086 1
d2095 1
a2095 1
	      o->orelocation = bfd_alloc (abfd, amt);
d2097 1
a2097 1
		return FALSE;
d2107 7
a2113 3
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
d2120 1
a2120 1
		return FALSE;
d2123 2
a2124 2
	      if (! default_indirect_link_order (abfd, info, o, p, TRUE))
		return FALSE;
d2128 1
a2128 1
		return FALSE;
d2134 1
a2134 1
  return TRUE;
d2139 5
a2143 2
static bfd_boolean
generic_add_output_symbol (bfd *output_bfd, size_t *psymalloc, asymbol *sym)
d2156 3
a2158 3
      newsyms = bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
      if (newsyms == NULL)
	return FALSE;
d2166 1
a2166 1
  return TRUE;
d2171 6
a2176 5
bfd_boolean
_bfd_generic_link_output_symbols (bfd *output_bfd,
				  bfd *input_bfd,
				  struct bfd_link_info *info,
				  size_t *psymalloc)
d2182 1
a2182 1
    return FALSE;
d2185 1
a2185 1
  if (info->create_object_symbols_section != NULL)
d2189 3
a2191 1
      for (sec = input_bfd->sections; sec != NULL; sec = sec->next)
d2199 1
a2199 1
		return FALSE;
d2207 1
a2207 1
		return FALSE;
d2222 1
a2222 1
      bfd_boolean output;
d2224 1
a2224 1
      h = NULL;
d2236 1
a2236 1
	    h = sym->udata.p;
d2253 1
a2253 1
					       FALSE, FALSE, TRUE));
d2257 1
a2257 1
					       FALSE, FALSE, TRUE);
d2259 1
a2259 1
	  if (h != NULL)
d2268 1
a2268 1
		  if (h->sym != NULL)
d2320 4
a2323 3
	      && bfd_hash_lookup (info->keep_hash, bfd_asymbol_name (sym),
				  FALSE, FALSE) == NULL))
	output = FALSE;
d2332 1
a2332 1
	    output = TRUE;
d2334 1
a2334 1
	    output = FALSE;
d2337 1
a2337 1
	output = FALSE;
d2341 1
a2341 1
	    output = TRUE;
d2343 1
a2343 1
	    output = FALSE;
d2347 1
a2347 1
	output = FALSE;
d2351 1
a2351 1
	    output = FALSE;
d2358 1
a2358 1
		  output = FALSE;
d2361 2
a2362 2
		  output = TRUE;
		  if (info->relocatable
d2368 1
a2368 1
		    output = FALSE;
d2370 1
a2370 1
		    output = TRUE;
d2373 1
a2373 1
		  output = TRUE;
d2381 1
a2381 1
	    output = TRUE;
d2383 1
a2383 1
	    output = FALSE;
d2395 1
a2395 1
	output = FALSE;
d2400 3
a2402 3
	    return FALSE;
	  if (h != NULL)
	    h->written = TRUE;
d2406 1
a2406 1
  return TRUE;
d2413 3
a2415 1
set_symbol_from_hash (asymbol *sym, struct bfd_link_hash_entry *h)
d2475 4
a2478 3
bfd_boolean
_bfd_generic_link_write_global_symbol (struct generic_link_hash_entry *h,
				       void *data)
d2480 2
a2481 1
  struct generic_write_global_symbol_info *wginfo = data;
d2488 1
a2488 1
    return TRUE;
d2490 1
a2490 1
  h->written = TRUE;
d2495 2
a2496 2
			      FALSE, FALSE) == NULL))
    return TRUE;
d2498 1
a2498 1
  if (h->sym != NULL)
d2504 1
a2504 1
	return FALSE;
d2520 1
a2520 1
  return TRUE;
d2525 6
a2530 5
bfd_boolean
_bfd_generic_reloc_link_order (bfd *abfd,
			       struct bfd_link_info *info,
			       asection *sec,
			       struct bfd_link_order *link_order)
d2534 1
a2534 1
  if (! info->relocatable)
d2536 1
a2536 1
  if (sec->orelocation == NULL)
d2539 3
a2541 3
  r = bfd_alloc (abfd, sizeof (arelent));
  if (r == NULL)
    return FALSE;
d2548 1
a2548 1
      return FALSE;
d2561 2
a2562 2
					 FALSE, FALSE, TRUE));
      if (h == NULL
d2566 3
a2568 2
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
	    return FALSE;
d2570 1
a2570 1
	  return FALSE;
d2584 1
a2584 1
      bfd_boolean ok;
d2588 3
a2590 3
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;
d2608 1
a2608 1
		  NULL, NULL, 0)))
d2611 1
a2611 1
	      return FALSE;
d2616 2
a2617 1
      ok = bfd_set_section_contents (abfd, sec, buf, loc, size);
d2620 1
a2620 1
	return FALSE;
d2628 1
a2628 1
  return TRUE;
d2634 3
a2636 1
bfd_new_link_order (bfd *abfd, asection *section)
d2641 1
a2641 1
  new = bfd_zalloc (abfd, amt);
d2647 1
a2647 1
  if (section->link_order_tail != NULL)
d2660 6
a2665 5
bfd_boolean
_bfd_default_link_order (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 struct bfd_link_order *link_order)
d2676 1
a2676 1
					  FALSE);
d2684 6
a2689 5
static bfd_boolean
default_data_link_order (bfd *abfd,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec,
			 struct bfd_link_order *link_order)
d2695 1
a2695 1
  bfd_boolean result;
d2701 1
a2701 1
    return TRUE;
d2708 1
a2708 1
      fill = bfd_malloc (size);
d2710 1
a2710 1
	return FALSE;
d2739 8
a2746 6
static bfd_boolean
default_indirect_link_order (bfd *output_bfd,
			     struct bfd_link_info *info,
			     asection *output_section,
			     struct bfd_link_order *link_order,
			     bfd_boolean generic_linker)
d2758 1
a2758 1
    return TRUE;
d2767 1
a2767 1
  if (info->relocatable
d2769 1
a2769 1
      && output_section->orelocation == NULL)
d2777 1
a2777 1
	(_("Attempt to do relocatable link with %s input and %s output"),
d2780 1
a2780 1
      return FALSE;
d2793 1
a2793 1
	return FALSE;
d2821 1
a2821 1
		h = sym->udata.p;
d2825 1
a2825 1
						  FALSE, FALSE, TRUE);
d2829 1
a2829 1
					  FALSE, FALSE, TRUE);
d2838 1
a2838 1
  contents = bfd_malloc (sec_size);
d2842 1
a2842 1
		  (output_bfd, info, link_order, contents, info->relocatable,
d2850 1
a2850 1
				  new_contents, loc, link_order->size))
d2855 1
a2855 1
  return TRUE;
d2860 1
a2860 1
  return FALSE;
d2867 2
a2868 1
_bfd_count_link_order_relocs (struct bfd_link_order *link_order)
d2874 1
a2874 1
  for (l = link_order; l != NULL; l = l->next)
d2889 1
a2889 1
        bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
d2901 4
a2904 3
bfd_boolean
_bfd_generic_link_split_section (bfd *abfd ATTRIBUTE_UNUSED,
				 asection *sec ATTRIBUTE_UNUSED)
d2906 1
a2906 1
  return FALSE;
@


1.25.12.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a1307 1
	  struct bfd_link_hash_entry *bh;
d1329 1
a1329 1
	  bh = NULL;
d1332 2
a1333 1
		  p->value, string, false, collect, &bh)))
a1334 1
	  h = (struct generic_link_hash_entry *) bh;
@


1.25.12.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d452 1
a452 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d648 2
a649 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry));
d2022 1
a2022 1
	p->u.indirect.section->linker_mark = (unsigned int) true;
@


1.25.12.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d203 1
a203 1
	<<keep_memory>> field of the <<info>> argument is TRUE, so
d409 1
a409 1
static bfd_boolean generic_link_read_symbols
d411 11
a421 12
static bfd_boolean generic_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean collect));
static bfd_boolean generic_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean collect));
static bfd_boolean generic_link_check_archive_element_no_collect
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean generic_link_check_archive_element_collect
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean generic_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded,
	   bfd_boolean collect));
static bfd_boolean generic_link_add_symbol_list
d423 2
a424 3
	   bfd_boolean collect));
static bfd *hash_entry_bfd
  PARAMS ((struct bfd_link_hash_entry *));
d427 1
a427 1
static bfd_boolean generic_add_output_symbol
d429 1
a429 1
static bfd_boolean default_data_link_order
d432 1
a432 1
static bfd_boolean default_indirect_link_order
d434 1
a434 1
	   struct bfd_link_order *, bfd_boolean));
d475 1
a475 1
bfd_boolean
d491 1
a491 1
/* Look up a symbol in a link hash table.  If follow is TRUE, we
d499 3
a501 3
     bfd_boolean create;
     bfd_boolean copy;
     bfd_boolean follow;
d527 3
a529 3
     bfd_boolean create;
     bfd_boolean copy;
     bfd_boolean follow;
d544 1
a544 1
      if (bfd_hash_lookup (info->wrap_hash, l, FALSE, FALSE) != NULL)
d562 1
a562 1
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
d575 1
a575 1
			      FALSE, FALSE) != NULL)
d593 1
a593 1
	  h = bfd_link_hash_lookup (info->hash, n, create, TRUE, follow);
d613 1
a613 1
     bfd_boolean (*func) PARAMS ((struct bfd_link_hash_entry *, PTR));
d617 1
a617 1
		     ((bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR)))
d637 1
a637 1
/* Routine to create an entry in a generic link hash table.  */
d663 1
a663 1
      ret->written = FALSE;
d670 1
a670 1
/* Create a generic link hash table.  */
d709 1
a709 1
static bfd_boolean
d720 1
a720 1
	return FALSE;
d724 1
a724 1
	return FALSE;
d727 1
a727 1
	return FALSE;
d731 1
a731 1
  return TRUE;
d738 1
a738 1
bfd_boolean
d743 1
a743 1
  return generic_link_add_symbols (abfd, info, FALSE);
d753 1
a753 1
bfd_boolean
d758 1
a758 1
  return generic_link_add_symbols (abfd, info, TRUE);
d776 1
a776 1
static bfd_boolean
d780 1
a780 1
     bfd_boolean collect;
d782 1
a782 1
  bfd_boolean ret;
d798 1
a798 1
      ret = FALSE;
d806 1
a806 1
static bfd_boolean
d810 1
a810 1
     bfd_boolean collect;
d816 1
a816 1
    return FALSE;
d851 1
a851 1
static bfd_boolean archive_hash_table_init
d890 1
a890 1
static bfd_boolean
d930 1
a930 1
   included.  CHECKFN should set *PNEEDED to TRUE if the object file
d933 1
a933 1
   to the global hash table.  CHECKFN should only return FALSE if some
d947 1
a947 1
bfd_boolean
d951 2
a952 2
     bfd_boolean (*checkfn)
       PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
d966 1
a966 1
	return TRUE;
d968 1
a968 1
      return FALSE;
d977 1
a977 1
    return FALSE;
d983 1
a983 1
      arh = archive_hash_lookup (&arsym_hash, arsym->name, TRUE, FALSE);
d1035 1
a1035 1
      arh = archive_hash_lookup (&arsym_hash, h->root.string, FALSE, FALSE);
d1045 1
a1045 1
		return FALSE;
d1048 1
a1048 1
	      arh = archive_hash_lookup (&arsym_hash, buf, FALSE, FALSE);
d1061 1
a1061 1
	  bfd_boolean needed;
d1110 1
a1110 1
  return TRUE;
d1114 1
a1114 1
  return FALSE;
d1122 1
a1122 1
static bfd_boolean
d1126 1
a1126 1
     bfd_boolean *pneeded;
d1128 1
a1128 1
  return generic_link_check_archive_element (abfd, info, pneeded, FALSE);
d1135 1
a1135 1
static bfd_boolean
d1139 1
a1139 1
     bfd_boolean *pneeded;
d1141 1
a1141 1
  return generic_link_check_archive_element (abfd, info, pneeded, TRUE);
d1147 1
a1147 1
static bfd_boolean
d1151 2
a1152 2
     bfd_boolean *pneeded;
     bfd_boolean collect;
d1156 1
a1156 1
  *pneeded = FALSE;
d1159 1
a1159 1
    return FALSE;
d1180 2
a1181 2
      h = bfd_link_hash_lookup (info->hash, bfd_asymbol_name (p), FALSE,
				FALSE, TRUE);
d1197 1
a1197 1
	    return FALSE;
d1202 3
a1204 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d1223 3
a1225 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d1241 1
a1241 1
	    return FALSE;
d1270 1
a1270 1
  return TRUE;
d1276 1
a1276 1
   is TRUE if constructors should be automatically collected by name
d1279 1
a1279 1
static bfd_boolean
d1285 1
a1285 1
     bfd_boolean collect;
d1334 2
a1335 2
		  p->value, string, FALSE, collect, &bh)))
	    return FALSE;
d1382 1
a1382 1
  return TRUE;
d1509 1
a1509 1
   COPY is TRUE if NAME or STRING must be copied into locally
d1511 1
a1511 1
   COLLECT is TRUE if we should automatically collect gcc constructor
d1517 1
a1517 1
bfd_boolean
d1527 2
a1528 2
     bfd_boolean copy;
     bfd_boolean collect;
d1533 1
a1533 1
  bfd_boolean cycle;
d1561 1
a1561 1
	h = bfd_wrapped_link_hash_lookup (abfd, info, name, TRUE, copy, FALSE);
d1563 1
a1563 1
	h = bfd_link_hash_lookup (info->hash, name, TRUE, copy, FALSE);
d1568 1
a1568 1
	  return FALSE;
d1574 1
a1574 1
	  && (bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE)
d1579 1
a1579 1
	return FALSE;
d1589 1
a1589 1
      cycle = FALSE;
d1621 1
a1621 1
	    return FALSE;
d1681 1
a1681 1
			  return FALSE;
d1699 1
a1699 1
	    return FALSE;
d1754 1
a1754 1
	    return FALSE;
d1805 1
a1805 1
	      return FALSE;
d1847 1
a1847 1
		return FALSE;
d1858 1
a1858 1
	    return FALSE;
d1867 2
a1868 2
	    inh = bfd_wrapped_link_hash_lookup (abfd, info, string, TRUE,
						copy, FALSE);
d1870 1
a1870 1
	      return FALSE;
d1878 1
a1878 1
		return FALSE;
d1893 1
a1893 1
		cycle = TRUE;
d1905 1
a1905 1
	    return FALSE;
d1916 1
a1916 1
		return FALSE;
d1924 1
a1924 1
	  cycle = TRUE;
d1932 1
a1932 1
	  cycle = TRUE;
d1940 1
a1940 1
	    return FALSE;
d1955 1
a1955 1
		return FALSE;
d1970 1
a1970 1
	      return FALSE;
d1983 1
a1983 1
		  return FALSE;
d1999 1
a1999 1
  return TRUE;
d2004 1
a2004 1
bfd_boolean
d2023 1
a2023 1
	p->u.indirect.section->linker_mark = TRUE;
d2028 1
a2028 1
      return FALSE;
d2042 1
a2042 1
    return FALSE;
d2073 1
a2073 1
		    return FALSE;
d2076 1
a2076 1
		    return FALSE;
d2083 1
a2083 1
		    return FALSE;
d2098 1
a2098 1
		return FALSE;
d2121 1
a2121 1
		return FALSE;
d2124 2
a2125 2
	      if (! default_indirect_link_order (abfd, info, o, p, TRUE))
		return FALSE;
d2129 1
a2129 1
		return FALSE;
d2135 1
a2135 1
  return TRUE;
d2140 1
a2140 1
static bfd_boolean
d2159 1
a2159 1
	return FALSE;
d2167 1
a2167 1
  return TRUE;
d2172 1
a2172 1
bfd_boolean
d2183 1
a2183 1
    return FALSE;
d2200 1
a2200 1
		return FALSE;
d2208 1
a2208 1
		return FALSE;
d2223 1
a2223 1
      bfd_boolean output;
d2254 1
a2254 1
					       FALSE, FALSE, TRUE));
d2258 1
a2258 1
					       FALSE, FALSE, TRUE);
d2322 1
a2322 1
				   FALSE, FALSE)
d2324 1
a2324 1
	output = FALSE;
d2333 1
a2333 1
	    output = TRUE;
d2335 1
a2335 1
	    output = FALSE;
d2338 1
a2338 1
	output = FALSE;
d2342 1
a2342 1
	    output = TRUE;
d2344 1
a2344 1
	    output = FALSE;
d2348 1
a2348 1
	output = FALSE;
d2352 1
a2352 1
	    output = FALSE;
d2359 1
a2359 1
		  output = FALSE;
d2362 1
a2362 1
		  output = TRUE;
d2369 1
a2369 1
		    output = FALSE;
d2371 1
a2371 1
		    output = TRUE;
d2374 1
a2374 1
		  output = TRUE;
d2382 1
a2382 1
	    output = TRUE;
d2384 1
a2384 1
	    output = FALSE;
d2396 1
a2396 1
	output = FALSE;
d2401 1
a2401 1
	    return FALSE;
d2403 1
a2403 1
	    h->written = TRUE;
d2407 1
a2407 1
  return TRUE;
d2476 1
a2476 1
bfd_boolean
d2489 1
a2489 1
    return TRUE;
d2491 1
a2491 1
  h->written = TRUE;
d2496 2
a2497 2
			      FALSE, FALSE) == NULL))
    return TRUE;
d2505 1
a2505 1
	return FALSE;
d2521 1
a2521 1
  return TRUE;
d2526 1
a2526 1
bfd_boolean
d2542 1
a2542 1
    return FALSE;
d2549 1
a2549 1
      return FALSE;
d2562 1
a2562 1
					 FALSE, FALSE, TRUE));
d2569 1
a2569 1
	    return FALSE;
d2571 1
a2571 1
	  return FALSE;
d2585 1
a2585 1
      bfd_boolean ok;
d2591 1
a2591 1
	return FALSE;
d2612 1
a2612 1
	      return FALSE;
d2621 1
a2621 1
	return FALSE;
d2629 1
a2629 1
  return TRUE;
d2661 1
a2661 1
bfd_boolean
d2677 1
a2677 1
					  FALSE);
d2685 1
a2685 1
static bfd_boolean
d2696 1
a2696 1
  bfd_boolean result;
d2702 1
a2702 1
    return TRUE;
d2711 1
a2711 1
	return FALSE;
d2740 1
a2740 1
static bfd_boolean
d2747 1
a2747 1
     bfd_boolean generic_linker;
d2759 1
a2759 1
    return TRUE;
d2781 1
a2781 1
      return FALSE;
d2794 1
a2794 1
	return FALSE;
d2826 1
a2826 1
						  FALSE, FALSE, TRUE);
d2830 1
a2830 1
					  FALSE, FALSE, TRUE);
d2856 1
a2856 1
  return TRUE;
d2861 1
a2861 1
  return FALSE;
d2890 1
a2890 1
        bfd_boolean bfd_link_split_section(bfd *abfd, asection *sec);
d2902 1
a2902 1
bfd_boolean
d2907 1
a2907 1
  return FALSE;
@


1.25.12.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a2083 1
		  free (relocs);
d2089 1
@


1.25.12.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d91 1
a91 1
	(this index number is used so that when doing a relocatable
d280 1
a280 1
	hash table.  When producing relocatable output, it must
d320 1
a320 1
	while generating a relocatable object file.
d342 1
a342 1
	section contents.  If performing a relocatable link, the
d2046 1
a2046 1
  if (info->relocatable)
d2365 1
a2365 1
		  if (info->relocatable
d2537 1
a2537 1
  if (! info->relocatable)
d2770 1
a2770 1
  if (info->relocatable
d2780 1
a2780 1
	(_("Attempt to do relocatable link with %s input and %s output"),
d2845 1
a2845 1
		  (output_bfd, info, link_order, contents, info->relocatable,
@


1.25.12.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d409 4
d414 1
a414 3
  (bfd *, struct bfd_link_info *, bfd_boolean collect);
static bfd_boolean generic_link_add_symbols
  (bfd *, struct bfd_link_info *, bfd_boolean);
d416 1
a416 1
  (bfd *, struct bfd_link_info *, bfd_boolean *);
d418 1
a418 1
  (bfd *, struct bfd_link_info *, bfd_boolean *);
d420 2
a421 1
  (bfd *, struct bfd_link_info *, bfd_boolean *, bfd_boolean);
d423 6
a428 2
  (bfd *, struct bfd_link_info *, bfd_size_type count, asymbol **,
   bfd_boolean);
d430 1
a430 1
  (bfd *, size_t *psymalloc, asymbol *);
d432 2
a433 1
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);
d435 2
a436 2
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *,
   bfd_boolean);
d445 4
a448 3
_bfd_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table,
			const char *string)
d454 2
a455 1
      entry = bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d478 6
a483 6
_bfd_link_hash_table_init
  (struct bfd_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d498 6
a503 5
bfd_link_hash_lookup (struct bfd_link_hash_table *table,
		      const char *string,
		      bfd_boolean create,
		      bfd_boolean copy,
		      bfd_boolean follow)
d510 1
a510 1
  if (follow && ret != NULL)
d525 7
a531 6
bfd_wrapped_link_hash_lookup (bfd *abfd,
			      struct bfd_link_info *info,
			      const char *string,
			      bfd_boolean create,
			      bfd_boolean copy,
			      bfd_boolean follow)
d555 1
a555 1
	  n = bfd_malloc (amt);
d587 1
a587 1
	  n = bfd_malloc (amt);
d613 4
a616 4
bfd_link_hash_traverse
  (struct bfd_link_hash_table *table,
   bfd_boolean (*func) (struct bfd_link_hash_entry *, void *),
   void *info)
d619 2
a620 1
		     (bfd_boolean (*) (struct bfd_hash_entry *, void *)) func,
d626 4
a629 3
void
bfd_link_add_undef (struct bfd_link_hash_table *table,
		    struct bfd_link_hash_entry *h)
d632 1
a632 1
  if (table->undefs_tail != NULL)
d634 1
a634 1
  if (table->undefs == NULL)
d642 4
a645 3
_bfd_generic_link_hash_newfunc (struct bfd_hash_entry *entry,
				struct bfd_hash_table *table,
				const char *string)
d651 1
a651 1
      entry =
d675 2
a676 1
_bfd_generic_link_hash_table_create (bfd *abfd)
d681 1
a681 1
  ret = bfd_malloc (amt);
d683 1
a683 1
    return NULL;
d688 1
a688 1
      return NULL;
d694 2
a695 1
_bfd_generic_link_hash_table_free (struct bfd_link_hash_table *hash)
d712 2
a713 1
generic_link_read_symbols (bfd *abfd)
d715 1
a715 1
  if (bfd_get_outsymbols (abfd) == NULL)
d723 2
a724 1
      bfd_get_outsymbols (abfd) = bfd_alloc (abfd, symsize);
d741 3
a743 1
_bfd_generic_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d756 3
a758 1
_bfd_generic_link_add_symbols_collect (bfd *abfd, struct bfd_link_info *info)
d768 3
a770 2
_bfd_generic_link_just_syms (asection *sec,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED)
d779 4
a782 3
generic_link_add_symbols (bfd *abfd,
			  struct bfd_link_info *info,
			  bfd_boolean collect)
d809 4
a812 3
generic_link_add_object_symbols (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean collect)
d851 8
d862 4
a865 3
archive_hash_newfunc (struct bfd_hash_entry *entry,
		      struct bfd_hash_table *table,
		      const char *string)
d871 4
a874 3
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct archive_hash_entry));
  if (ret == NULL)
d884 1
a884 1
      ret->defs = NULL;
d887 1
a887 1
  return &ret->root;
d893 5
a897 5
archive_hash_table_init
  (struct archive_hash_table *table,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d950 5
a954 4
_bfd_generic_link_add_archive_symbols
  (bfd *abfd,
   struct bfd_link_info *info,
   bfd_boolean (*checkfn) (bfd *, struct bfd_link_info *, bfd_boolean *))
d967 1
a967 1
      if (bfd_openr_next_archived_file (abfd, NULL) == NULL)
d986 1
a986 1
      if (arh == NULL)
d993 3
a995 1
      for (pp = &arh->defs; *pp != NULL; pp = &(*pp)->next)
d1009 1
a1009 1
  while (*pundef != NULL)
d1038 1
a1038 1
      if (arh == NULL)
d1045 1
a1045 1
	      char *buf = bfd_malloc (amt);
d1053 1
a1053 1
	  if (arh == NULL)
d1060 1
a1060 1
      for (l = arh->defs; l != NULL; l = l->next)
d1071 1
a1071 1
	  if (element == NULL)
d1125 4
a1128 4
generic_link_check_archive_element_no_collect (
					       bfd *abfd,
					       struct bfd_link_info *info,
					       bfd_boolean *pneeded)
d1138 4
a1141 3
generic_link_check_archive_element_collect (bfd *abfd,
					    struct bfd_link_info *info,
					    bfd_boolean *pneeded)
d1150 5
a1154 4
generic_link_check_archive_element (bfd *abfd,
				    struct bfd_link_info *info,
				    bfd_boolean *pneeded,
				    bfd_boolean collect)
d1184 1
a1184 1
      if (h == NULL
d1218 1
a1218 1
	  if (symbfd == NULL)
d1239 3
a1241 2
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
d1282 6
a1287 5
generic_link_add_symbol_list (bfd *abfd,
			      struct bfd_link_info *info,
			      bfd_size_type symbol_count,
			      asymbol **symbols,
			      bfd_boolean collect)
d1361 1
a1361 1
	      if (h->sym == NULL
d1380 1
a1380 1
	  p->udata.p = h;
d1480 2
a1481 1
hash_entry_bfd (struct bfd_link_hash_entry *h)
d1520 12
a1531 10
_bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
				  bfd *abfd,
				  const char *name,
				  flagword flags,
				  asection *section,
				  bfd_vma value,
				  const char *string,
				  bfd_boolean copy,
				  bfd_boolean collect,
				  struct bfd_link_hash_entry **hashp)
d1575 3
a1577 2
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
d1584 1
a1584 1
  if (hashp != NULL)
d1622 1
a1622 1
		  abfd, bfd_link_hash_defined, 0)))
d1697 3
a1699 2
	    bfd_hash_allocate (&info->hash->table,
			       sizeof (struct bfd_link_hash_common_entry));
d1805 1
a1805 1
		   (info, h->root.string, obfd, h->type, 0,
d1859 1
a1859 1
		  abfd, bfd_link_hash_indirect, 0)))
d1871 1
a1871 1
	    if (inh == NULL)
d1916 2
a1917 1
						 NULL, 0))
d1940 2
a1941 1
					     hash_entry_bfd (h), NULL, 0))
d1954 3
a1956 1
						 hash_entry_bfd (h), NULL, 0))
d1969 2
a1970 1
		    (NULL, &info->hash->table, h->root.string)));
d2007 3
a2009 1
_bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)
d2017 1
a2017 1
  bfd_get_outsymbols (abfd) = NULL;
d2028 1
a2028 1
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
d2038 1
a2038 1
				   &wginfo);
d2049 3
a2051 1
      for (o = abfd->sections; o != NULL; o = o->next)
d2054 3
a2056 1
	  for (p = o->link_order_head; p != NULL; p = p->next)
d2076 1
a2076 1
		  relocs = bfd_malloc (relsize);
d2098 1
a2098 1
	      o->orelocation = bfd_alloc (abfd, amt);
d2110 7
a2116 3
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
d2143 4
a2146 1
generic_add_output_symbol (bfd *output_bfd, size_t *psymalloc, asymbol *sym)
d2159 2
a2160 2
      newsyms = bfd_realloc (bfd_get_outsymbols (output_bfd), amt);
      if (newsyms == NULL)
d2175 5
a2179 4
_bfd_generic_link_output_symbols (bfd *output_bfd,
				  bfd *input_bfd,
				  struct bfd_link_info *info,
				  size_t *psymalloc)
d2188 1
a2188 1
  if (info->create_object_symbols_section != NULL)
d2192 3
a2194 1
      for (sec = input_bfd->sections; sec != NULL; sec = sec->next)
d2227 1
a2227 1
      h = NULL;
d2239 1
a2239 1
	    h = sym->udata.p;
d2262 1
a2262 1
	  if (h != NULL)
d2271 1
a2271 1
		  if (h->sym != NULL)
d2323 3
a2325 2
	      && bfd_hash_lookup (info->keep_hash, bfd_asymbol_name (sym),
				  FALSE, FALSE) == NULL))
d2404 1
a2404 1
	  if (h != NULL)
d2416 3
a2418 1
set_symbol_from_hash (asymbol *sym, struct bfd_link_hash_entry *h)
d2479 3
a2481 2
_bfd_generic_link_write_global_symbol (struct generic_link_hash_entry *h,
				       void *data)
d2483 2
a2484 1
  struct generic_write_global_symbol_info *wginfo = data;
d2501 1
a2501 1
  if (h->sym != NULL)
d2529 5
a2533 4
_bfd_generic_reloc_link_order (bfd *abfd,
			       struct bfd_link_info *info,
			       asection *sec,
			       struct bfd_link_order *link_order)
d2539 1
a2539 1
  if (sec->orelocation == NULL)
d2542 2
a2543 2
  r = bfd_alloc (abfd, sizeof (arelent));
  if (r == NULL)
d2565 1
a2565 1
      if (h == NULL
d2569 2
a2570 1
		 (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))
d2591 2
a2592 2
      buf = bfd_zmalloc (size);
      if (buf == NULL)
d2611 1
a2611 1
		  NULL, NULL, 0)))
d2619 2
a2620 1
      ok = bfd_set_section_contents (abfd, sec, buf, loc, size);
d2637 3
a2639 1
bfd_new_link_order (bfd *abfd, asection *section)
d2644 1
a2644 1
  new = bfd_zalloc (abfd, amt);
d2650 1
a2650 1
  if (section->link_order_tail != NULL)
d2664 5
a2668 4
_bfd_default_link_order (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 struct bfd_link_order *link_order)
d2688 5
a2692 4
default_data_link_order (bfd *abfd,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec,
			 struct bfd_link_order *link_order)
d2711 1
a2711 1
      fill = bfd_malloc (size);
d2743 7
a2749 5
default_indirect_link_order (bfd *output_bfd,
			     struct bfd_link_info *info,
			     asection *output_section,
			     struct bfd_link_order *link_order,
			     bfd_boolean generic_linker)
d2772 1
a2772 1
      && output_section->orelocation == NULL)
d2824 1
a2824 1
		h = sym->udata.p;
d2841 1
a2841 1
  contents = bfd_malloc (sec_size);
d2853 1
a2853 1
				  new_contents, loc, link_order->size))
d2870 2
a2871 1
_bfd_count_link_order_relocs (struct bfd_link_order *link_order)
d2877 1
a2877 1
  for (l = link_order; l != NULL; l = l->next)
d2892 1
a2892 1
        bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
d2905 3
a2907 2
_bfd_generic_link_split_section (bfd *abfd ATTRIBUTE_UNUSED,
				 asection *sec ATTRIBUTE_UNUSED)
@


1.25.12.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d789 1
a789 1
  struct bfd_symbol **outsyms;
@


1.25.12.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d458 1
a458 1
      h->und_next = NULL;
d617 1
a617 1
  BFD_ASSERT (h->und_next == NULL);
d619 1
a619 1
    table->undefs_tail->und_next = h;
d991 1
a991 1
	    *pundef = (*pundef)->und_next;
d993 1
a993 1
	    pundef = &(*pundef)->und_next;
d1016 1
a1016 1
	      pundef = &(*pundef)->und_next;
d1065 1
a1065 1
      pundef = &(*pundef)->und_next;
d1695 2
a1696 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1882 2
a1883 2
	  if (h->und_next == NULL && info->hash->undefs_tail != h)
	    h->und_next = h;
d1898 1
a1898 1
	     the und_next field is not NULL, or it is the tail of the
d1901 1
a1901 1
	  if (h->und_next != NULL || info->hash->undefs_tail == h)
@


1.25.2.1
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a1307 1
	  struct bfd_link_hash_entry *bh;
d1329 1
a1329 1
	  bh = NULL;
d1332 2
a1333 1
		  p->value, string, false, collect, &bh)))
a1334 1
	  h = (struct generic_link_hash_entry *) bh;
@


1.25.2.2
log
@Merge from mainline.
@
text
@d452 1
a452 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d648 2
a649 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry));
d2022 1
a2022 1
	p->u.indirect.section->linker_mark = (unsigned int) true;
@


1.24
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d1977 1
d1979 1
a1979 2
		w = bfd_hash_allocate (&info->hash->table,
				       strlen (string) + 1);
d1982 1
a1982 1
		strcpy (w, string);
@


1.23
log
@2002-05-21  H.J. Lu  (hjl@@gnu.org)

	* linker.c (_bfd_generic_link_add_one_symbol): Allow multiple
	definition.
@
text
@d1677 1
a1677 2
			       (info,
				c == 'I' ? true : false,
d2393 1
a2393 1
	  && sym->section->linker_mark == false)
@


1.23.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1677 2
a1678 1
			       (info, c == 'I',
a1977 1
		size_t len = strlen (string) + 1;
d1979 2
a1980 1
		w = bfd_hash_allocate (&info->hash->table, len);
d1983 1
a1983 1
		memcpy (w, string, len);
d2394 1
a2394 1
	  && ! sym->section->linker_mark)
@


1.23.2.2
log
@merge from mainline
@
text
@d452 1
a452 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry));
d648 2
a649 2
      entry = (struct bfd_hash_entry *)
	bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry));
a1307 1
	  struct bfd_link_hash_entry *bh;
d1329 1
a1329 1
	  bh = NULL;
d1332 2
a1333 1
		  p->value, string, false, collect, &bh)))
a1334 1
	  h = (struct generic_link_hash_entry *) bh;
d2021 1
a2021 1
	p->u.indirect.section->linker_mark = (unsigned int) true;
@


1.22
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1816 4
a1819 3
	  {
	    asection *msec = NULL;
	    bfd_vma mval = 0;
d1821 20
a1840 9
	    switch (h->type)
	      {
	      case bfd_link_hash_defined:
		msec = h->u.def.section;
		mval = h->u.def.value;
		break;
	      case bfd_link_hash_indirect:
		msec = bfd_ind_section_ptr;
		mval = 0;
a1841 11
	      default:
		abort ();
	      }

	    /* Ignore a redefinition of an absolute symbol to the same
               value; it's harmless.  */
	    if (h->type == bfd_link_hash_defined
		&& bfd_is_abs_section (msec)
		&& bfd_is_abs_section (section)
		&& value == mval)
	      break;
d1843 5
a1847 5
	    if (! ((*info->callbacks->multiple_definition)
		   (info, h->root.string, msec->owner, msec, mval, abfd,
		    section, value)))
	      return false;
	  }
@


1.21
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d760 13
@


1.21.4.1
log
@merge from trunk
@
text
@a759 13
/* Indicate that we are only retrieving symbol values from this
   section.  We want the symbols to act as though the values in the
   file are absolute.  */

void
_bfd_generic_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
}

d1803 3
a1805 4
	  if (!info->allow_multiple_definition)
	    {
	      asection *msec = NULL;
	      bfd_vma mval = 0;
d1807 9
a1815 20
	      switch (h->type)
		{
		case bfd_link_hash_defined:
		  msec = h->u.def.section;
		  mval = h->u.def.value;
		  break;
	        case bfd_link_hash_indirect:
		  msec = bfd_ind_section_ptr;
		  mval = 0;
		  break;
		default:
		  abort ();
		}

	      /* Ignore a redefinition of an absolute symbol to the
		 same value; it's harmless.  */
	      if (h->type == bfd_link_hash_defined
		  && bfd_is_abs_section (msec)
		  && bfd_is_abs_section (section)
		  && value == mval)
d1817 3
d1821 13
a1833 5
	      if (! ((*info->callbacks->multiple_definition)
		     (info, h->root.string, msec->owner, msec, mval,
		      abfd, section, value)))
		return false;
	    }
@


1.20
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d678 1
a678 1
  ret = (struct generic_link_hash_table *) bfd_alloc (abfd, amt);
d688 11
@


1.19
log
@	Support arbitrary length fill patterns.
	* linker.c (bfd_new_link_order): Zero all fields with bfd_zalloc.
	(_bfd_default_link_order): Remove bfd_fill_link_order code.
	Call default_data_link_order.
	(default_fill_link_order): Delete.
	(default_data_link_order): New function.
	* elf32-mips.c (_bfd_mips_elf_final_link): Replace occurrences
	of bfd_fill_link_order with bfd_data_link_order.
	* elf64-alpha.c (elf64_alpha_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
@
text
@d1422 1
a1422 1
  /* WARN_ROW   */  {MWARN, WARN,  WARN,  CWARN, CWARN, WARN,  CWARN, MWARN },
d2458 3
@


1.18
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d429 1
a429 1
static boolean default_fill_link_order
d2611 3
a2613 1
  struct bfd_link_order *new = (struct bfd_link_order *) bfd_alloc (abfd, amt);
a2617 3
  new->offset = 0;
  new->size = 0;
  new->next = (struct bfd_link_order *) NULL;
a2638 2
  file_ptr loc;

a2648 2
    case bfd_fill_link_order:
      return default_fill_link_order (abfd, info, sec, link_order);
d2650 1
a2650 4
      loc = link_order->offset * bfd_octets_per_byte (abfd);
      return bfd_set_section_contents (abfd, sec,
				       (PTR) link_order->u.data.contents,
				       loc, link_order->size);
d2654 1
a2654 1
/* Default routine to handle a bfd_fill_link_order.  */
d2657 1
a2657 1
default_fill_link_order (abfd, info, sec, link_order)
d2664 2
a2665 3
  unsigned char *space;
  size_t i;
  unsigned int fill;
d2675 25
a2699 13
  space = (unsigned char *) bfd_malloc (size);
  if (space == NULL)
    return false;

  fill = link_order->u.fill.value;
  for (i = 0; i < size; i += 4)
    space[i] = fill >> 24;
  for (i = 1; i < size; i += 4)
    space[i] = fill >> 16;
  for (i = 2; i < size; i += 4)
    space[i] = fill >> 8;
  for (i = 3; i < size; i += 4)
    space[i] = fill;
d2702 1
a2702 1
  result = bfd_set_section_contents (abfd, sec, space, loc, size);
d2704 2
a2705 1
  free (space);
@


1.18.2.1
log
@Merge from mainline.
@
text
@d1422 1
a1422 1
  /* WARN_ROW   */  {MWARN, WARN,  WARN,  CWARN, CWARN, WARN,  CWARN, NOACT },
a2457 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct generic_link_hash_entry *) h->root.u.i.link;
@


1.17
log
@	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	* aoutx.h: Formatting fixes.
	* merge.c (_bfd_merged_section_offset): Break line at 80 chars.

	* linker.c: Replace bfd_get_filename with bfd_archive_filename
	in error message.
@
text
@a447 2
  struct bfd_link_hash_entry *ret = (struct bfd_link_hash_entry *) entry;

d450 6
a455 5
  if (ret == (struct bfd_link_hash_entry *) NULL)
    ret = ((struct bfd_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct bfd_link_hash_entry)));
  if (ret == (struct bfd_link_hash_entry *) NULL)
    return NULL;
d458 4
a461 2
  ret = ((struct bfd_link_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
a462 2
  if (ret)
    {
d464 2
a465 2
      ret->type = bfd_link_hash_new;
      ret->next = NULL;
d468 1
a468 1
  return (struct bfd_hash_entry *) ret;
a643 3
  struct generic_link_hash_entry *ret =
    (struct generic_link_hash_entry *) entry;

d646 7
a652 5
  if (ret == (struct generic_link_hash_entry *) NULL)
    ret = ((struct generic_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct generic_link_hash_entry)));
  if (ret == (struct generic_link_hash_entry *) NULL)
    return NULL;
d655 4
a658 3
  ret = ((struct generic_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
a659 2
  if (ret)
    {
d661 1
d666 1
a666 1
  return (struct bfd_hash_entry *) ret;
@


1.16
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1852 1
a1852 1
		   bfd_get_filename (abfd), name, string);
@


1.15
log
@2001-09-11  H.J. Lu  <hjl@@gnu.org>

	* inker.c (link_action): Change COMMON_ROW\defw from CREF to
	COM.
@
text
@d531 2
d552 2
a553 1
	  n = (char *) bfd_malloc (strlen (l) + sizeof WRAP + 1);
d584 2
a585 1
	  n = (char *) bfd_malloc (strlen (l + sizeof REAL - 1) + 2);
d678 1
d680 1
a680 2
  ret = ((struct generic_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct generic_link_hash_table)));
d711 2
a712 1
      bfd_get_outsymbols (abfd) = (asymbol **) bfd_alloc (abfd, symsize);
d789 3
d794 3
a796 4
  return generic_link_add_symbol_list (abfd, info,
				       _bfd_generic_link_get_symcount (abfd),
				       _bfd_generic_link_get_symbols (abfd),
				       collect);
d807 1
a807 1
  int indx;
d936 1
a936 1
  int indx;
d1015 1
a1015 1
	  /* If we haven't found the exact symbol we're looking for, 
d1019 2
a1020 1
	      char *buf = (char *) bfd_malloc (strlen (h->root.string) + 10);
d1851 1
a1851 1
		  (_("%s: indirect symbol `%s' to `%s' is a loop"),  
d2050 1
a2050 1
		  relocs = (arelent **) bfd_malloc ((size_t) relsize);
d2068 5
a2072 4
	      o->orelocation = ((arelent **)
				bfd_alloc (abfd,
					   (o->reloc_count
					    * sizeof (arelent *))));
d2125 1
d2131 3
a2133 2
      newsyms = (asymbol **) bfd_realloc (bfd_get_outsymbols (output_bfd),
					  *psymalloc * sizeof (asymbol *));
d2513 1
a2513 1
  r = (arelent *) bfd_alloc (abfd, sizeof (arelent));
d2559 1
d2566 2
a2567 1
				      link_order->u.reloc.p->addend, buf);
d2589 3
a2591 4
      ok = bfd_set_section_contents (abfd, sec, (PTR) buf,
				     (file_ptr)
                                     (link_order->offset *
                                      bfd_octets_per_byte (abfd)), size);
d2612 2
a2613 4
  struct bfd_link_order *new;

  new = ((struct bfd_link_order *)
	 bfd_alloc (abfd, sizeof (struct bfd_link_order)));
d2642 2
d2657 1
d2660 1
a2660 4
				       (file_ptr)
                                       (link_order->offset *
                                        bfd_octets_per_byte (abfd)),
				       link_order->size);
d2673 1
a2673 1
  size_t size;
d2682 1
a2682 1
  size = (size_t) link_order->size;
d2700 2
a2701 2
  loc = (file_ptr) (link_order->offset * bfd_octets_per_byte (abfd));
  result = bfd_set_section_contents (abfd, sec, space, loc, link_order->size);
d2722 2
d2807 3
a2809 3
  contents = ((bfd_byte *)
	      bfd_malloc (bfd_section_size (input_bfd, input_section)));
  if (contents == NULL && bfd_section_size (input_bfd, input_section) != 0)
d2818 1
d2820 1
a2820 5
				  (PTR) new_contents,
				  (file_ptr)
                                  (link_order->offset *
                                   bfd_octets_per_byte (output_bfd)),
                                  link_order->size))
@


1.14
log
@Apply H.J.'s patch to revert change to elfxx-target.h
Apply my patch to allow SREC as output format.
@
text
@d1414 1
a1414 1
  /* COMMON_ROW	*/  {COM,   COM,   COM,   CREF,  CREF,  BIG,   REFC,  WARNC },
@


1.13
log
@	* linker.c (_bfd_generic_link_add_archive_symbols): Replace alloca()
	by bfd_malloc().
@
text
@d486 2
@


1.12
log
@	* linker.c (default_fill_link_order): Handle four byte fill value.
@
text
@d1010 4
a1013 1
	      char *buf = alloca (strlen (h->root.string) + 10);
d1016 1
@


1.11
log
@2001-08-02  Paul Sokolovsky  <paul.sokolovsky@@technologist.com>
        * cofflink.c (coff_link_check_ar_symbols): also search for
        __imp__symbol as well as _symbol.
        * linker.c (_bfd_generic_link_add_archive_symbols): also
        search for __imp__symbol as well as _symbol.
@
text
@d2658 1
a2658 1
  char *space;
d2660 2
a2661 1
  int fill;
d2667 5
a2671 2
  space = (char *) bfd_malloc (size);
  if (space == NULL && size != 0)
d2675 5
a2679 1
  for (i = 0; i < size; i += 2)
d2681 1
a2681 1
  for (i = 1; i < size; i += 2)
d2683 4
a2686 5
  result = bfd_set_section_contents (abfd, sec, space,
				     (file_ptr)
                                     (link_order->offset *
                                      bfd_octets_per_byte (abfd)),
				     link_order->size);
@


1.10
log
@Fix ia64-linux fortran common linking problem.
	* linker.c (_bfd_generic_link_add_one_symbol, case BIG): Use
	the section of the bigger symbol.
@
text
@d1006 13
a1018 2
	  pundef = &(*pundef)->next;
	  continue;
a1019 1

@


1.9
log
@2001-05-10  H.J. Lu  <hjl@@gnu.org>

	* linker.c (_bfd_generic_link_add_one_symbol): Check loop on
	indirect symbols.
@
text
@d1701 1
a1701 1
	     two sizes.  */
d1720 19
@


1.8
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d1804 9
@


1.7
log
@Update copyright notices
@
text
@d2282 6
@


1.6
log
@2001-01-03  Kazu Hirata  <kazu@@hxi.com>

	* libbfd.c: Fix formatting.
	* linker.c: Likewise.
	* lynx-core.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.6.2.2
log
@Merge from mainline.
@
text
@a1803 9
	    if (inh->type == bfd_link_hash_indirect
		&& inh->u.i.link == h)
	      {
		(*_bfd_error_handler)
		  (_("%s: indirect symbol `%s' to `%s' is a loop"),  
		   bfd_get_filename (abfd), name, string);
		bfd_set_error (bfd_error_invalid_operation);
		return false;
	      }
@


1.5
log
@fix mis-applied patch
@
text
@d63 1
a63 1
@@menu	
d604 1
a604 1
void 
d1364 1
a1364 1
  FAIL,		/* Abort. */
d1467 1
a1467 1
     the hash table entry, and stored it in *HASHP. */
d2057 1
a2057 1
  
d2455 1
a2455 1
      
d2527 1
a2527 1
				     (file_ptr) 
d2597 1
a2597 1
				       (file_ptr) 
a2605 1
/*ARGSUSED*/
d2632 2
a2633 2
				     (file_ptr) 
                                     (link_order->offset * 
d2734 1
a2734 1
	}	  
d2752 2
a2753 2
                                  (link_order->offset * 
                                   bfd_octets_per_byte (output_bfd)), 
a2803 2


@


1.4
log
@Apply Tim walls octest vs bytes patch
@
text
@d2752 4
a2755 1
				  link_order->offset, link_order->size))
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d2527 3
a2529 1
				     (file_ptr) link_order->offset, size);
d2597 3
a2599 1
				       (file_ptr) link_order->offset,
d2633 3
a2635 1
				     (file_ptr) link_order->offset,
@


1.2
log
@Franz Sirl <Franz.Sirl-kernel@@lauterbach.com>
        * elf32-ppc.c (ppc_elf_relocate_section): Don't barf on out of
        range undefweak symbols.
        * hash.c: Add missing comma after @@xref{}
        * linker.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d1752 2
a1753 2
	    asection *msec;
	    bfd_vma mval;
d2606 1
a2606 1
     struct bfd_link_info *info;
d2801 2
a2802 2
     bfd *abfd;
     asection *sec;
@


1.1
log
@Initial revision
@
text
@d77 1
a77 1
	<<bfdlink.c>>.  @@xref{Hash Tables} for information on how to
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

