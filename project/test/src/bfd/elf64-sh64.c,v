head	1.96;
access;
symbols
	sid-snapshot-20180601:1.96
	sid-snapshot-20180501:1.96
	sid-snapshot-20180401:1.96
	sid-snapshot-20180301:1.96
	sid-snapshot-20180201:1.96
	sid-snapshot-20180101:1.96
	sid-snapshot-20171201:1.96
	sid-snapshot-20171101:1.96
	sid-snapshot-20171001:1.96
	sid-snapshot-20170901:1.96
	sid-snapshot-20170801:1.96
	sid-snapshot-20170701:1.96
	sid-snapshot-20170601:1.96
	sid-snapshot-20170501:1.96
	sid-snapshot-20170401:1.96
	sid-snapshot-20170301:1.96
	sid-snapshot-20170201:1.96
	sid-snapshot-20170101:1.96
	sid-snapshot-20161201:1.96
	sid-snapshot-20161101:1.96
	sid-snapshot-20160901:1.96
	sid-snapshot-20160801:1.96
	sid-snapshot-20160701:1.96
	sid-snapshot-20160601:1.96
	sid-snapshot-20160501:1.96
	sid-snapshot-20160401:1.96
	sid-snapshot-20160301:1.96
	sid-snapshot-20160201:1.96
	sid-snapshot-20160101:1.96
	sid-snapshot-20151201:1.96
	sid-snapshot-20151101:1.96
	sid-snapshot-20151001:1.96
	sid-snapshot-20150901:1.96
	sid-snapshot-20150801:1.96
	sid-snapshot-20150701:1.96
	sid-snapshot-20150601:1.96
	sid-snapshot-20150501:1.96
	sid-snapshot-20150401:1.96
	sid-snapshot-20150301:1.96
	sid-snapshot-20150201:1.96
	sid-snapshot-20150101:1.96
	sid-snapshot-20141201:1.96
	sid-snapshot-20141101:1.96
	sid-snapshot-20141001:1.96
	sid-snapshot-20140901:1.96
	sid-snapshot-20140801:1.96
	sid-snapshot-20140701:1.96
	sid-snapshot-20140601:1.96
	sid-snapshot-20140501:1.96
	sid-snapshot-20140401:1.96
	sid-snapshot-20140301:1.96
	sid-snapshot-20140201:1.96
	sid-snapshot-20140101:1.96
	sid-snapshot-20131201:1.96
	sid-snapshot-20131101:1.96
	sid-snapshot-20131001:1.96
	binutils-2_24-branch:1.96.0.2
	binutils-2_24-branchpoint:1.96
	binutils-2_21_1:1.86
	sid-snapshot-20130901:1.96
	gdb_7_6_1-2013-08-30-release:1.95
	sid-snapshot-20130801:1.96
	sid-snapshot-20130701:1.96
	sid-snapshot-20130601:1.96
	sid-snapshot-20130501:1.96
	gdb_7_6-2013-04-26-release:1.95
	sid-snapshot-20130401:1.96
	binutils-2_23_2:1.93
	gdb_7_6-branch:1.95.0.2
	gdb_7_6-2013-03-12-branchpoint:1.95
	sid-snapshot-20130301:1.95
	sid-snapshot-20130201:1.94
	sid-snapshot-20130101:1.94
	sid-snapshot-20121201:1.94
	gdb_7_5_1-2012-11-29-release:1.93
	binutils-2_23_1:1.93
	sid-snapshot-20121101:1.94
	binutils-2_23:1.93
	sid-snapshot-20121001:1.94
	sid-snapshot-20120901:1.93
	gdb_7_5-2012-08-17-release:1.93
	sid-snapshot-20120801:1.93
	binutils-2_23-branch:1.93.0.4
	binutils-2_23-branchpoint:1.93
	gdb_7_5-branch:1.93.0.2
	gdb_7_5-2012-07-18-branchpoint:1.93
	sid-snapshot-20120701:1.93
	sid-snapshot-20120601:1.91
	sid-snapshot-20120501:1.90
	binutils-2_22_branch:1.87.0.4
	gdb_7_4_1-2012-04-26-release:1.88
	sid-snapshot-20120401:1.89
	sid-snapshot-20120301:1.88
	sid-snapshot-20120201:1.88
	gdb_7_4-2012-01-24-release:1.88
	sid-snapshot-20120101:1.88
	gdb_7_4-branch:1.88.0.2
	gdb_7_4-2011-12-13-branchpoint:1.88
	sid-snapshot-20111201:1.88
	binutils-2_22:1.87
	sid-snapshot-20111101:1.88
	sid-snapshot-20111001:1.87
	binutils-2_22-branch:1.87.0.2
	binutils-2_22-branchpoint:1.87
	gdb_7_3_1-2011-09-04-release:1.86
	sid-snapshot-20110901:1.87
	sid-snapshot-20110801:1.87
	gdb_7_3-2011-07-26-release:1.86
	sid-snapshot-20110701:1.87
	sid-snapshot-20110601:1.86
	sid-snapshot-20110501:1.86
	gdb_7_3-branch:1.86.0.4
	gdb_7_3-2011-04-01-branchpoint:1.86
	sid-snapshot-20110401:1.86
	sid-snapshot-20110301:1.86
	sid-snapshot-20110201:1.86
	sid-snapshot-20110101:1.86
	binutils-2_21:1.86
	sid-snapshot-20101201:1.86
	binutils-2_21-branch:1.86.0.2
	binutils-2_21-branchpoint:1.86
	sid-snapshot-20101101:1.86
	sid-snapshot-20101001:1.85
	binutils-2_20_1:1.84
	gdb_7_2-2010-09-02-release:1.85
	sid-snapshot-20100901:1.85
	sid-snapshot-20100801:1.85
	gdb_7_2-branch:1.85.0.4
	gdb_7_2-2010-07-07-branchpoint:1.85
	sid-snapshot-20100701:1.85
	sid-snapshot-20100601:1.85
	sid-snapshot-20100501:1.85
	sid-snapshot-20100401:1.85
	gdb_7_1-2010-03-18-release:1.85
	sid-snapshot-20100301:1.85
	gdb_7_1-branch:1.85.0.2
	gdb_7_1-2010-02-18-branchpoint:1.85
	sid-snapshot-20100201:1.84
	sid-snapshot-20100101:1.84
	gdb_7_0_1-2009-12-22-release:1.84
	sid-snapshot-20091201:1.84
	sid-snapshot-20091101:1.84
	binutils-2_20:1.84
	gdb_7_0-2009-10-06-release:1.84
	sid-snapshot-20091001:1.84
	gdb_7_0-branch:1.84.0.4
	gdb_7_0-2009-09-16-branchpoint:1.84
	arc-sim-20090309:1.80
	binutils-arc-20081103-branch:1.81.0.14
	binutils-arc-20081103-branchpoint:1.81
	binutils-2_20-branch:1.84.0.2
	binutils-2_20-branchpoint:1.84
	sid-snapshot-20090901:1.83
	sid-snapshot-20090801:1.83
	msnyder-checkpoint-072509-branch:1.83.0.4
	msnyder-checkpoint-072509-branchpoint:1.83
	sid-snapshot-20090701:1.83
	dje-cgen-play1-branch:1.83.0.2
	dje-cgen-play1-branchpoint:1.83
	sid-snapshot-20090601:1.83
	sid-snapshot-20090501:1.82
	sid-snapshot-20090401:1.82
	arc-20081103-branch:1.81.0.12
	arc-20081103-branchpoint:1.81
	arc-insight_6_8-branch:1.80.0.6
	arc-insight_6_8-branchpoint:1.80
	insight_6_8-branch:1.80.0.4
	insight_6_8-branchpoint:1.80
	sid-snapshot-20090301:1.82
	binutils-2_19_1:1.81
	sid-snapshot-20090201:1.82
	sid-snapshot-20090101:1.82
	reverse-20081226-branch:1.82.0.2
	reverse-20081226-branchpoint:1.82
	sid-snapshot-20081201:1.82
	multiprocess-20081120-branch:1.81.0.10
	multiprocess-20081120-branchpoint:1.81
	sid-snapshot-20081101:1.81
	binutils-2_19:1.81
	sid-snapshot-20081001:1.81
	reverse-20080930-branch:1.81.0.8
	reverse-20080930-branchpoint:1.81
	binutils-2_19-branch:1.81.0.6
	binutils-2_19-branchpoint:1.81
	sid-snapshot-20080901:1.81
	sid-snapshot-20080801:1.81
	reverse-20080717-branch:1.81.0.4
	reverse-20080717-branchpoint:1.81
	sid-snapshot-20080701:1.81
	msnyder-reverse-20080609-branch:1.81.0.2
	msnyder-reverse-20080609-branchpoint:1.81
	drow-reverse-20070409-branch:1.74.0.2
	drow-reverse-20070409-branchpoint:1.74
	sid-snapshot-20080601:1.81
	sid-snapshot-20080501:1.81
	sid-snapshot-20080403:1.81
	sid-snapshot-20080401:1.81
	gdb_6_8-2008-03-27-release:1.80
	sid-snapshot-20080301:1.80
	gdb_6_8-branch:1.80.0.2
	gdb_6_8-2008-02-26-branchpoint:1.80
	sid-snapshot-20080201:1.80
	sid-snapshot-20080101:1.80
	sid-snapshot-20071201:1.80
	sid-snapshot-20071101:1.80
	gdb_6_7_1-2007-10-29-release:1.78
	gdb_6_7-2007-10-10-release:1.78
	sid-snapshot-20071001:1.80
	gdb_6_7-branch:1.78.0.4
	gdb_6_7-2007-09-07-branchpoint:1.78
	binutils-2_18:1.78
	binutils-2_18-branch:1.78.0.2
	binutils-2_18-branchpoint:1.78
	insight_6_6-20070208-release:1.71
	binutils-csl-coldfire-4_1-32:1.67
	binutils-csl-sourcerygxx-4_1-32:1.67
	gdb_6_6-2006-12-18-release:1.71
	binutils-csl-innovasic-fido-3_4_4-33:1.67
	binutils-csl-sourcerygxx-3_4_4-32:1.52
	binutils-csl-coldfire-4_1-30:1.67
	binutils-csl-sourcerygxx-4_1-30:1.67
	binutils-csl-coldfire-4_1-28:1.67
	binutils-csl-sourcerygxx-4_1-29:1.67
	binutils-csl-sourcerygxx-4_1-28:1.67
	gdb_6_6-branch:1.71.0.2
	gdb_6_6-2006-11-15-branchpoint:1.71
	binutils-csl-arm-2006q3-27:1.67
	binutils-csl-sourcerygxx-4_1-27:1.67
	binutils-csl-arm-2006q3-26:1.67
	binutils-csl-sourcerygxx-4_1-26:1.67
	binutils-csl-sourcerygxx-4_1-25:1.67
	binutils-csl-sourcerygxx-4_1-24:1.67
	binutils-csl-sourcerygxx-4_1-23:1.67
	insight_6_5-20061003-release:1.67
	gdb-csl-symbian-6_4_50_20060226-12:1.65
	binutils-csl-sourcerygxx-4_1-21:1.67
	binutils-csl-arm-2006q3-21:1.67
	binutils-csl-sourcerygxx-4_1-22:1.67
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.67
	binutils-csl-sourcerygxx-4_1-20:1.67
	binutils-csl-arm-2006q3-19:1.67
	binutils-csl-sourcerygxx-4_1-19:1.67
	binutils-csl-sourcerygxx-4_1-18:1.67
	binutils-csl-renesas-4_1-9:1.67
	gdb-csl-sourcerygxx-3_4_4-25:1.64
	binutils-csl-sourcerygxx-3_4_4-25:1.52
	nickrob-async-20060828-mergepoint:1.67
	gdb-csl-symbian-6_4_50_20060226-11:1.65
	binutils-csl-renesas-4_1-8:1.67
	binutils-csl-renesas-4_1-7:1.67
	binutils-csl-renesas-4_1-6:1.67
	gdb-csl-sourcerygxx-4_1-17:1.65
	binutils-csl-sourcerygxx-4_1-17:1.67
	gdb-csl-20060226-branch-local-2:1.65
	gdb-csl-sourcerygxx-4_1-14:1.65
	binutils-csl-sourcerygxx-4_1-14:1.67
	binutils-csl-sourcerygxx-4_1-15:1.67
	gdb-csl-sourcerygxx-4_1-13:1.65
	binutils-csl-sourcerygxx-4_1-13:1.67
	binutils-2_17:1.67
	gdb-csl-sourcerygxx-4_1-12:1.65
	binutils-csl-sourcerygxx-4_1-12:1.67
	gdb-csl-sourcerygxx-3_4_4-21:1.65
	binutils-csl-sourcerygxx-3_4_4-21:1.67
	gdb_6_5-20060621-release:1.67
	binutils-csl-wrs-linux-3_4_4-24:1.52
	binutils-csl-wrs-linux-3_4_4-23:1.52
	gdb-csl-sourcerygxx-4_1-9:1.65
	binutils-csl-sourcerygxx-4_1-9:1.67
	gdb-csl-sourcerygxx-4_1-8:1.65
	binutils-csl-sourcerygxx-4_1-8:1.67
	gdb-csl-sourcerygxx-4_1-7:1.65
	binutils-csl-sourcerygxx-4_1-7:1.67
	gdb-csl-arm-2006q1-6:1.65
	binutils-csl-arm-2006q1-6:1.67
	gdb-csl-sourcerygxx-4_1-6:1.65
	binutils-csl-sourcerygxx-4_1-6:1.67
	binutils-csl-wrs-linux-3_4_4-22:1.52
	gdb-csl-symbian-6_4_50_20060226-10:1.65
	gdb-csl-symbian-6_4_50_20060226-9:1.65
	gdb-csl-symbian-6_4_50_20060226-8:1.65
	gdb-csl-coldfire-4_1-11:1.65
	binutils-csl-coldfire-4_1-11:1.67
	gdb-csl-sourcerygxx-3_4_4-19:1.65
	binutils-csl-sourcerygxx-3_4_4-19:1.67
	gdb-csl-coldfire-4_1-10:1.65
	gdb_6_5-branch:1.67.0.14
	gdb_6_5-2006-05-14-branchpoint:1.67
	binutils-csl-coldfire-4_1-10:1.67
	gdb-csl-sourcerygxx-4_1-5:1.65
	binutils-csl-sourcerygxx-4_1-5:1.67
	nickrob-async-20060513-branch:1.67.0.12
	nickrob-async-20060513-branchpoint:1.67
	gdb-csl-sourcerygxx-4_1-4:1.65
	binutils-csl-sourcerygxx-4_1-4:1.67
	msnyder-reverse-20060502-branch:1.67.0.10
	msnyder-reverse-20060502-branchpoint:1.67
	binutils-csl-wrs-linux-3_4_4-21:1.52
	gdb-csl-morpho-4_1-4:1.65
	binutils-csl-morpho-4_1-4:1.67
	gdb-csl-sourcerygxx-3_4_4-17:1.65
	binutils-csl-sourcerygxx-3_4_4-17:1.67
	binutils-csl-wrs-linux-3_4_4-20:1.52
	readline_5_1-import-branch:1.67.0.8
	readline_5_1-import-branchpoint:1.67
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.65
	binutils-2_17-branch:1.67.0.6
	binutils-2_17-branchpoint:1.67
	gdb-csl-symbian-20060226-branch:1.65.0.4
	gdb-csl-symbian-20060226-branchpoint:1.65
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.65
	msnyder-reverse-20060331-branch:1.67.0.4
	msnyder-reverse-20060331-branchpoint:1.67
	binutils-csl-2_17-branch:1.67.0.2
	binutils-csl-2_17-branchpoint:1.67
	gdb-csl-available-20060303-branch:1.66.0.2
	gdb-csl-available-20060303-branchpoint:1.66
	gdb-csl-20060226-branch:1.65.0.2
	gdb-csl-20060226-branchpoint:1.65
	gdb_6_4-20051202-release:1.64
	msnyder-fork-checkpoint-branch:1.64.0.8
	msnyder-fork-checkpoint-branchpoint:1.64
	gdb-csl-gxxpro-6_3-branch:1.64.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.64
	gdb_6_4-branch:1.64.0.4
	gdb_6_4-2005-11-01-branchpoint:1.64
	gdb-csl-arm-20051020-branch:1.64.0.2
	gdb-csl-arm-20051020-branchpoint:1.64
	binutils-csl-gxxpro-3_4-branch:1.52.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.52
	binutils-2_16_1:1.52
	msnyder-tracepoint-checkpoint-branch:1.57.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.57
	gdb-csl-arm-20050325-2005-q1b:1.52
	binutils-csl-arm-2005q1b:1.52
	binutils-2_16:1.52
	gdb-csl-arm-20050325-2005-q1a:1.52
	binutils-csl-arm-2005q1a:1.52
	csl-arm-20050325-branch:1.52.0.6
	csl-arm-20050325-branchpoint:1.52
	binutils-csl-arm-2005q1-branch:1.52.0.4
	binutils-csl-arm-2005q1-branchpoint:1.52
	binutils-2_16-branch:1.52.0.2
	binutils-2_16-branchpoint:1.52
	csl-arm-2004-q3d:1.51
	gdb_6_3-20041109-release:1.50
	gdb_6_3-branch:1.50.0.2
	gdb_6_3-20041019-branchpoint:1.50
	csl-arm-2004-q3:1.50
	drow_intercu-merge-20040921:1.50
	drow_intercu-merge-20040915:1.48
	jimb-gdb_6_2-e500-branch:1.47.0.6
	jimb-gdb_6_2-e500-branchpoint:1.47
	gdb_6_2-20040730-release:1.47
	gdb_6_2-branch:1.47.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.47
	gdb_6_1_1-20040616-release:1.42
	binutils-2_15:1.42.6.1
	binutils-2_15-branchpoint:1.42
	csl-arm-2004-q1a:1.46
	csl-arm-2004-q1:1.46
	gdb_6_1-2004-04-05-release:1.42
	drow_intercu-merge-20040402:1.46
	drow_intercu-merge-20040327:1.45
	ezannoni_pie-20040323-branch:1.43.0.2
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.43
	cagney_tramp-20040309-branch:1.42.0.12
	cagney_tramp-20040309-branchpoint:1.42
	gdb_6_1-branch:1.42.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.42
	drow_intercu-20040221-branch:1.42.0.8
	drow_intercu-20040221-branchpoint:1.42
	binutils-2_15-branch:1.42.0.6
	cagney_bfdfile-20040213-branch:1.42.0.4
	cagney_bfdfile-20040213-branchpoint:1.42
	drow-cplus-merge-20040208:1.42
	carlton_dictionary-20040126-merge:1.42
	cagney_bigcore-20040122-branch:1.42.0.2
	cagney_bigcore-20040122-branchpoint:1.42
	drow-cplus-merge-20040113:1.42
	csl-arm-2003-q4:1.42
	drow-cplus-merge-20031224:1.42
	drow-cplus-merge-20031220:1.42
	carlton_dictionary-20031215-merge:1.42
	drow-cplus-merge-20031214:1.42
	carlton-dictionary-20031111-merge:1.40
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.35.0.6
	kettenis_sparc-20030918-branchpoint:1.35
	carlton_dictionary-20030917-merge:1.35
	ezannoni_pie-20030916-branchpoint:1.35
	ezannoni_pie-20030916-branch:1.35.0.4
	cagney_x86i386-20030821-branch:1.35.0.2
	cagney_x86i386-20030821-branchpoint:1.35
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.30.0.6
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.30
	binutils-2_14:1.28
	cagney_convert-20030606-branch:1.30.0.2
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.29.0.8
	cagney_writestrings-20030508-branchpoint:1.29
	jimb-ppc64-linux-20030528-branch:1.29.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.29
	carlton_dictionary-20030523-merge:1.29
	cagney_fileio-20030521-branch:1.29.0.4
	cagney_fileio-20030521-branchpoint:1.29
	kettenis_i386newframe-20030517-mergepoint:1.29
	jimb-ppc64-linux-20030509-branch:1.29.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.29
	kettenis_i386newframe-20030504-mergepoint:1.28
	carlton_dictionary-20030430-merge:1.28
	binutils-2_14-branch:1.28.0.2
	binutils-2_14-branchpoint:1.28
	kettenis_i386newframe-20030419-branch:1.27.0.2
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.26
	kettenis_i386newframe-20030406-branch:1.26.0.18
	kettenis_i386newframe-20030406-branchpoint:1.26
	cagney_frameaddr-20030403-branchpoint:1.26
	cagney_frameaddr-20030403-branch:1.26.0.16
	cagney_framebase-20030330-mergepoint:1.26
	cagney_framebase-20030326-branch:1.26.0.14
	cagney_framebase-20030326-branchpoint:1.26
	cagney_lazyid-20030317-branch:1.26.0.12
	cagney_lazyid-20030317-branchpoint:1.26
	kettenis-i386newframe-20030316-mergepoint:1.26
	offbyone-20030313-branch:1.26.0.10
	offbyone-20030313-branchpoint:1.26
	kettenis-i386newframe-20030308-branch:1.26.0.8
	kettenis-i386newframe-20030308-branchpoint:1.26
	carlton_dictionary-20030305-merge:1.26
	cagney_offbyone-20030303-branch:1.26.0.6
	cagney_offbyone-20030303-branchpoint:1.26
	carlton_dictionary-20030207-merge:1.26
	interps-20030202-branch:1.26.0.4
	interps-20030202-branchpoint:1.26
	cagney-unwind-20030108-branch:1.26.0.2
	cagney-unwind-20030108-branchpoint:1.26
	binutils-2_13_2_1:1.15.2.3
	binutils-2_13_2:1.15.2.3
	carlton_dictionary-20021223-merge:1.26
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.23
	binutils-2_13_1:1.15.2.2
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.22
	drow-cplus-merge-20021025:1.22
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.21
	drow-cplus-branch:1.19.0.12
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.10
	carlton_dictionary-20020920-branchpoint:1.19
	sid-20020905-branchpoint:1.19
	sid-20020905-branch:1.19.0.8
	gdb_5_3-branch:1.19.0.6
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	binutils-2_13:1.15
	gdb_5_2_1-2002-07-23-release:1.4
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	kseitz_interps-20020528-branch:1.7.0.6
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.4
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.1.2.5
	jimb-macro-020506-branch:1.7.0.2
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.4
	binutils-2_12:1.1.2.3
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	binutils-2_12-branch:1.1.0.2
	binutils-2_12-branchpoint:1.1
	binutils_latest_snapshot:1.96;
locks; strict;
comment	@ * @;


1.96
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.93;

1.93
date	2012.06.29.14.46.02;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2012.06.29.07.37.50;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2012.05.07.03.27.52;	author macro;	state Exp;
branches;
next	1.90;

1.90
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2012.03.13.06.04.36;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2011.10.19.07.17.19;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2011.06.13.00.59.13;	author amodra;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2010.10.25.15.54.15;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2009.05.21.14.15.49;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2008.11.25.13.03.56;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.15.13.55.54;	author hjl;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2007.03.07.08.54.35;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.31.14.28.03;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.22.01.02.38;	author kkojima;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.65;

1.65
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.25.02.32.11;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.18.01.28.25;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.08.06.20.04;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.08.00.26.52;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.04.01.53.40;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.20.18.12.10;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.07.13.22.53;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.05.14.33.58;	author hjl;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.04.15.53.26;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.04.11.00.18;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.21.15.28.26;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.17.07.14.29;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2004.09.16.14.52.07;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.26.06.13.40;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.03.25.12.48.41;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.20.23.16.42;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches
	1.42.6.1
	1.42.8.1
	1.42.12.1;
next	1.41;

1.41
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.15.06.23.55;	author kkojima;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.13.05.11.30;	author kkojima;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.25.06.19.20;	author kkojima;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.06.40.20;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.03.04.50.20;	author kkojima;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.09.02.27.06;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.23.21.09.02;	author amylaar;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.28.08.37.14;	author kkojima;	state Exp;
branches;
next	1.23;

1.23
date	2002.10.25.18.55.22;	author wilson;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.16.08.39.37;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.10.21.45.14;	author sclarke;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.23.08.26.13;	author amodra;	state Exp;
branches
	1.19.10.1
	1.19.12.1;
next	1.18;

1.18
date	2002.08.23.08.13.12;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.23.04.23.37;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.16.18.40.54;	author sclarke;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.07.01.08.06.45;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.25.06.21.53;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.08.12.27.33;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.04.05.28.52;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.16.04.58.12;	author amodra;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.22.10.03.03;	author jakub;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.19.12.40.28;	author jakub;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.11.06.17.43;	author aoliva;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.08.05.33.21;	author aoliva;	state Exp;
branches
	1.1.2.1;
next	;

1.87.2.1
date	2012.05.11.12.24.30;	author nickc;	state Exp;
branches;
next	;

1.42.6.1
date	2004.04.08.12.41.45;	author amodra;	state Exp;
branches;
next	;

1.42.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.42.8.2;

1.42.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.42.8.3;

1.42.8.3
date	2004.09.16.17.00.31;	author drow;	state Exp;
branches;
next	1.42.8.4;

1.42.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.42.12.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.27.2.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2003.05.18.09.43.46;	author kettenis;	state Exp;
branches;
next	;

1.19.10.1
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.19.10.2;

1.19.10.2
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.19.10.3;

1.19.10.3
date	2002.12.23.19.37.49;	author carlton;	state Exp;
branches;
next	1.19.10.4;

1.19.10.4
date	2003.04.16.19.56.44;	author carlton;	state Exp;
branches;
next	1.19.10.5;

1.19.10.5
date	2003.05.01.00.46.42;	author carlton;	state Exp;
branches;
next	1.19.10.6;

1.19.10.6
date	2003.05.23.18.40.27;	author carlton;	state Exp;
branches;
next	1.19.10.7;

1.19.10.7
date	2003.06.27.21.49.22;	author carlton;	state Exp;
branches;
next	1.19.10.8;

1.19.10.8
date	2003.08.05.17.12.51;	author carlton;	state Exp;
branches;
next	1.19.10.9;

1.19.10.9
date	2003.09.17.21.27.55;	author carlton;	state Exp;
branches;
next	1.19.10.10;

1.19.10.10
date	2003.11.11.23.50.23;	author carlton;	state Exp;
branches;
next	1.19.10.11;

1.19.10.11
date	2003.12.15.23.59.40;	author carlton;	state Exp;
branches;
next	;

1.19.12.1
date	2002.10.26.17.11.59;	author drow;	state Exp;
branches;
next	1.19.12.2;

1.19.12.2
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.11.08.56.13;	author amodra;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.12.15.22.31.45;	author drow;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.20.01.30.41;	author kseitz;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.1.2.1
date	2002.02.11.06.18.13;	author aoliva;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.02.19.13.10.27;	author jakub;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.02.22.10.06.17;	author jakub;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.04.27.08.30.12;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.96
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* SuperH SH64-specific support for 64-bit ELF
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define SH64_ELF64

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/sh.h"

/* Add a suffix for datalabel indirection symbols.  It must not match any
   other symbols; user symbols with or without version or other
   decoration.  It must only be used internally and not emitted by any
   means.  */
#define DATALABEL_SUFFIX " DL"

#define GOT_BIAS (-((long)-32768))

#define PLT_ENTRY_SIZE 64

/* Return size of a PLT entry.  */
#define elf_sh64_sizeof_plt(info) PLT_ENTRY_SIZE

/* Return offset of the PLT0 address in an absolute PLT entry.  */
#define elf_sh64_plt_plt0_offset(info) 32

/* Return offset of the linker in PLT0 entry.  */
#define elf_sh64_plt0_gotplt_offset(info) 0

/* Return offset of the trampoline in PLT entry */
#define elf_sh64_plt_temp_offset(info) 33 /* Add one because it's SHmedia.  */

/* Return offset of the symbol in PLT entry.  */
#define elf_sh64_plt_symbol_offset(info) 0

/* Return offset of the relocation in PLT entry.  */
#define elf_sh64_plt_reloc_offset(info) (info->shared ? 52 : 44)

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

/* The sh linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_sh64_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_sh64_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* sh ELF linker hash entry.  */

struct elf_sh64_link_hash_entry
{
  struct elf_link_hash_entry root;

  bfd_vma datalabel_got_offset;

  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_sh64_pcrel_relocs_copied *pcrel_relocs_copied;
};

/* Traverse an sh ELF linker hash table.  */

#define sh64_elf64_link_hash_traverse(table, func, info)	\
  (elf_link_hash_traverse					\
   ((table),							\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
    (info)))

static bfd_reloc_status_type sh_elf64_ignore_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type sh_elf64_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);

static reloc_howto_type sh_elf64_howto_table[] = {
  /* No relocation.  */
  HOWTO (R_SH_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
     src_mask to a non-zero value is similar to the COFF toolchain.  */
  HOWTO (R_SH_DIR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 sh_elf64_reloc,		/* special_function */
	 "R_SH_DIR32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit PC relative relocation.  */
  HOWTO (R_SH_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_REL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* For 32-bit sh, this is R_SH_DIR8WPN.  */
  EMPTY_HOWTO (3),

  /* For 32-bit sh, this is R_SH_IND12W.  */
  EMPTY_HOWTO (4),

  /* For 32-bit sh, this is R_SH_DIR8WPL.  */
  EMPTY_HOWTO (5),

  /* For 32-bit sh, this is R_SH_DIR8WPZ.  */
  EMPTY_HOWTO (6),

  /* For 32-bit sh, this is R_SH_DIR8BP.  */
  EMPTY_HOWTO (7),

  /* For 32-bit sh, this is R_SH_DIR8W.  */
  EMPTY_HOWTO (8),

  /* For 32-bit sh, this is R_SH_DIR8L.  */
  EMPTY_HOWTO (9),

  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),
  EMPTY_HOWTO (12),
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),
  EMPTY_HOWTO (22),
  EMPTY_HOWTO (23),
  EMPTY_HOWTO (24),

  /* The remaining relocs are a GNU extension used for relaxing.  The
     final pass of the linker never needs to do anything with any of
     these relocs.  Any required operations are handled by the
     relaxation code.  */

  /* A 16 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 32 bit switch table entry.  This is generated for an expression
     such as ``.long L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* For 32-bit sh, this is R_SH_USES.  */
  EMPTY_HOWTO (27),

  /* For 32-bit sh, this is R_SH_COUNT.  */
  EMPTY_HOWTO (28),

  /* For 32-bit sh, this is R_SH_ALIGN.  FIXME: For linker relaxation,
     this might be emitted.  When linker relaxation is implemented, we
     might want to use it.  */
  EMPTY_HOWTO (29),

  /* For 32-bit sh, this is R_SH_CODE.  FIXME: For linker relaxation,
     this might be emitted.  When linker relaxation is implemented, we
     might want to use it.  */
  EMPTY_HOWTO (30),

  /* For 32-bit sh, this is R_SH_DATA.  FIXME: For linker relaxation,
     this might be emitted.  When linker relaxation is implemented, we
     might want to use it.  */
  EMPTY_HOWTO (31),

  /* For 32-bit sh, this is R_SH_LABEL.  FIXME: For linker relaxation,
     this might be emitted.  When linker relaxation is implemented, we
     might want to use it.  */
  EMPTY_HOWTO (32),

  /* An 8 bit switch table entry.  This is generated for an expression
     such as ``.word L1 - L2''.  The offset holds the difference
     between the reloc address and L2.  */
  HOWTO (R_SH_SWITCH8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_SWITCH8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_SH_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_SH_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_SH_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_SH_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* For 32-bit sh, this is R_SH_LOOP_START.  */
  EMPTY_HOWTO (36),

  /* For 32-bit sh, this is R_SH_LOOP_END.  */
  EMPTY_HOWTO (37),

  EMPTY_HOWTO (38),
  EMPTY_HOWTO (39),
  EMPTY_HOWTO (40),
  EMPTY_HOWTO (41),
  EMPTY_HOWTO (42),
  EMPTY_HOWTO (43),
  EMPTY_HOWTO (44),

  /* Used in SHLLI.L and SHLRI.L.  */
  HOWTO (R_SH_DIR5U,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR5U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in SHARI, SHLLI et al.  */
  HOWTO (R_SH_DIR6U,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR6U",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in BxxI, LDHI.L et al.  */
  HOWTO (R_SH_DIR6S,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR6S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in ADDI, ANDI et al.  */
  HOWTO (R_SH_DIR10S,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10S",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in LD.UW, ST.W et al.  */
  HOWTO (R_SH_DIR10SW,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 11,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SW",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.  */
  HOWTO (R_SH_DIR10SL,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_DIR10SQ,	/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_DIR10SQ",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  EMPTY_HOWTO (52),
  EMPTY_HOWTO (53),
  EMPTY_HOWTO (54),
  EMPTY_HOWTO (55),
  EMPTY_HOWTO (56),
  EMPTY_HOWTO (57),
  EMPTY_HOWTO (58),
  EMPTY_HOWTO (59),
  EMPTY_HOWTO (60),
  EMPTY_HOWTO (61),
  EMPTY_HOWTO (62),
  EMPTY_HOWTO (63),
  EMPTY_HOWTO (64),
  EMPTY_HOWTO (65),
  EMPTY_HOWTO (66),
  EMPTY_HOWTO (67),
  EMPTY_HOWTO (68),
  EMPTY_HOWTO (69),
  EMPTY_HOWTO (70),
  EMPTY_HOWTO (71),
  EMPTY_HOWTO (72),
  EMPTY_HOWTO (73),
  EMPTY_HOWTO (74),
  EMPTY_HOWTO (75),
  EMPTY_HOWTO (76),
  EMPTY_HOWTO (77),
  EMPTY_HOWTO (78),
  EMPTY_HOWTO (79),
  EMPTY_HOWTO (80),
  EMPTY_HOWTO (81),
  EMPTY_HOWTO (82),
  EMPTY_HOWTO (83),
  EMPTY_HOWTO (84),
  EMPTY_HOWTO (85),
  EMPTY_HOWTO (86),
  EMPTY_HOWTO (87),
  EMPTY_HOWTO (88),
  EMPTY_HOWTO (89),
  EMPTY_HOWTO (90),
  EMPTY_HOWTO (91),
  EMPTY_HOWTO (92),
  EMPTY_HOWTO (93),
  EMPTY_HOWTO (94),
  EMPTY_HOWTO (95),
  EMPTY_HOWTO (96),
  EMPTY_HOWTO (97),
  EMPTY_HOWTO (98),
  EMPTY_HOWTO (99),
  EMPTY_HOWTO (100),
  EMPTY_HOWTO (101),
  EMPTY_HOWTO (102),
  EMPTY_HOWTO (103),
  EMPTY_HOWTO (104),
  EMPTY_HOWTO (105),
  EMPTY_HOWTO (106),
  EMPTY_HOWTO (107),
  EMPTY_HOWTO (108),
  EMPTY_HOWTO (109),
  EMPTY_HOWTO (110),
  EMPTY_HOWTO (111),
  EMPTY_HOWTO (112),
  EMPTY_HOWTO (113),
  EMPTY_HOWTO (114),
  EMPTY_HOWTO (115),
  EMPTY_HOWTO (116),
  EMPTY_HOWTO (117),
  EMPTY_HOWTO (118),
  EMPTY_HOWTO (119),
  EMPTY_HOWTO (120),
  EMPTY_HOWTO (121),
  EMPTY_HOWTO (122),
  EMPTY_HOWTO (123),
  EMPTY_HOWTO (124),
  EMPTY_HOWTO (125),
  EMPTY_HOWTO (126),
  EMPTY_HOWTO (127),
  EMPTY_HOWTO (128),
  EMPTY_HOWTO (129),
  EMPTY_HOWTO (130),
  EMPTY_HOWTO (131),
  EMPTY_HOWTO (132),
  EMPTY_HOWTO (133),
  EMPTY_HOWTO (134),
  EMPTY_HOWTO (135),
  EMPTY_HOWTO (136),
  EMPTY_HOWTO (137),
  EMPTY_HOWTO (138),
  EMPTY_HOWTO (139),
  EMPTY_HOWTO (140),
  EMPTY_HOWTO (141),
  EMPTY_HOWTO (142),
  EMPTY_HOWTO (143),
  EMPTY_HOWTO (144),
  EMPTY_HOWTO (145),
  EMPTY_HOWTO (146),
  EMPTY_HOWTO (147),
  EMPTY_HOWTO (148),
  EMPTY_HOWTO (149),
  EMPTY_HOWTO (150),
  EMPTY_HOWTO (151),
  EMPTY_HOWTO (152),
  EMPTY_HOWTO (153),
  EMPTY_HOWTO (154),
  EMPTY_HOWTO (155),
  EMPTY_HOWTO (156),
  EMPTY_HOWTO (157),
  EMPTY_HOWTO (158),
  EMPTY_HOWTO (159),

  /* Relocs for dynamic linking for 32-bit SH would follow.  We don't have
     any dynamic linking support for 64-bit SH at present.  */

  EMPTY_HOWTO (160),
  EMPTY_HOWTO (161),
  EMPTY_HOWTO (162),
  EMPTY_HOWTO (163),
  EMPTY_HOWTO (164),
  EMPTY_HOWTO (165),
  EMPTY_HOWTO (166),
  EMPTY_HOWTO (167),
  EMPTY_HOWTO (168),

  /* Back to SH5 relocations.  */
  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_LOW16",    	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOT_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTPLT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_LOW16",   /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTPLT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTPLT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTPLT_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_PLT_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_LOW16",    	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_PLT_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_PLT_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_PLT_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PLT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTOFF_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_LOW16",   /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTOFF_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTOFF_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTOFF_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTOFF_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_GOTPC_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_LOW16",    /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_GOTPC_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_MEDLOW16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_GOTPC_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_GOTPC_HI16,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPC_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),		       	/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.  */
  HOWTO (R_SH_GOT10BY4,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT10BY4",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in LD.L, FLD.S et al.  */
  HOWTO (R_SH_GOTPLT10BY4,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 12,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT10BY4",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_GOT10BY8,		/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOT10BY8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in FLD.D, FST.P et al.  */
  HOWTO (R_SH_GOTPLT10BY8,	/* type */
	 3,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GOTPLT10BY8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  HOWTO (R_SH_COPY64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_COPY64", 	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  HOWTO (R_SH_GLOB_DAT64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_GLOB_DAT64", 	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  HOWTO (R_SH_JMP_SLOT64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_JMP_SLOT64", 	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  HOWTO (R_SH_RELATIVE64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_RELATIVE64", 	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  EMPTY_HOWTO (197),
  EMPTY_HOWTO (198),
  EMPTY_HOWTO (199),
  EMPTY_HOWTO (200),
  EMPTY_HOWTO (201),
  EMPTY_HOWTO (202),
  EMPTY_HOWTO (203),
  EMPTY_HOWTO (204),
  EMPTY_HOWTO (205),
  EMPTY_HOWTO (206),
  EMPTY_HOWTO (207),
  EMPTY_HOWTO (208),
  EMPTY_HOWTO (209),
  EMPTY_HOWTO (210),
  EMPTY_HOWTO (211),
  EMPTY_HOWTO (212),
  EMPTY_HOWTO (213),
  EMPTY_HOWTO (214),
  EMPTY_HOWTO (215),
  EMPTY_HOWTO (216),
  EMPTY_HOWTO (217),
  EMPTY_HOWTO (218),
  EMPTY_HOWTO (219),
  EMPTY_HOWTO (220),
  EMPTY_HOWTO (221),
  EMPTY_HOWTO (222),
  EMPTY_HOWTO (223),
  EMPTY_HOWTO (224),
  EMPTY_HOWTO (225),
  EMPTY_HOWTO (226),
  EMPTY_HOWTO (227),
  EMPTY_HOWTO (228),
  EMPTY_HOWTO (229),
  EMPTY_HOWTO (230),
  EMPTY_HOWTO (231),
  EMPTY_HOWTO (232),
  EMPTY_HOWTO (233),
  EMPTY_HOWTO (234),
  EMPTY_HOWTO (235),
  EMPTY_HOWTO (236),
  EMPTY_HOWTO (237),
  EMPTY_HOWTO (238),
  EMPTY_HOWTO (239),
  EMPTY_HOWTO (240),
  EMPTY_HOWTO (241),

  /* Relocations for SHmedia code.  None of these are partial_inplace or
     use the field being relocated.  */

  /* The assembler will generate this reloc before a block of SHmedia
     instructions.  A section should be processed as assuming it contains
     data, unless this reloc is seen.  Note that a block of SHcompact
     instructions are instead preceded by R_SH_CODE.
     This is currently not implemented, but should be used for SHmedia
     linker relaxation.  */
  HOWTO (R_SH_SHMEDIA_CODE,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 sh_elf64_ignore_reloc,	/* special_function */
	 "R_SH_SHMEDIA_CODE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The assembler will generate this reloc at a PTA or PTB instruction,
     and the linker checks the right type of target, or changes a PTA to a
     PTB, if the original insn was PT.  */
  HOWTO (R_SH_PT_16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 18,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_PT_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in unexpanded MOVI.  */
  HOWTO (R_SH_IMMS16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMMS16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in SHORI.  */
  HOWTO (R_SH_IMMU16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMMU16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (x & 65536).  */
  HOWTO (R_SH_IMM_LOW16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_LOW16",    	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI ((x - $) & 65536).  */
  HOWTO (R_SH_IMM_LOW16_PCREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_LOW16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 16) & 65536).  */
  HOWTO (R_SH_IMM_MEDLOW16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDLOW16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 16) & 65536).  */
  HOWTO (R_SH_IMM_MEDLOW16_PCREL, /* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDLOW16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 32) & 65536).  */
  HOWTO (R_SH_IMM_MEDHI16,	/* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDHI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 32) & 65536).  */
  HOWTO (R_SH_IMM_MEDHI16_PCREL, /* type */
	 32,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_MEDHI16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Used in MOVI and SHORI ((x >> 48) & 65536).  */
  HOWTO (R_SH_IMM_HI16,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* Used in MOVI and SHORI (((x - $) >> 48) & 65536).  */
  HOWTO (R_SH_IMM_HI16_PCREL,	/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_IMM_HI16_PCREL", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffc00,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* For the .uaquad pseudo.  */
  HOWTO (R_SH_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_64", 		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 FALSE),	       	/* pcrel_offset */

  /* For the .uaquad pseudo, (x - $).  */
  HOWTO (R_SH_64_PCREL,		/* type */
	 48,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 TRUE,			/* pc_relative */
	 10,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_SH_64_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 ((bfd_vma) 0) - 1,	/* dst_mask */
	 TRUE),			/* pcrel_offset */

};

/* This function is used for relocs which are only used for relaxing,
   which the linker should otherwise ignore.  */

static bfd_reloc_status_type
sh_elf64_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol ATTRIBUTE_UNUSED,
		       void *data ATTRIBUTE_UNUSED, asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* This function is used for normal relocs.  This used to be like the COFF
   function, and is almost certainly incorrect for other ELF targets.

   See sh_elf_reloc in elf32-sh.c for the original.  */

static bfd_reloc_status_type
sh_elf64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
		void *data, asection *input_section, bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  unsigned long insn;
  bfd_vma sym_value;
  enum elf_sh_reloc_type r_type;
  bfd_vma addr = reloc_entry->address;
  bfd_byte *hit_data = addr + (bfd_byte *) data;

  r_type = (enum elf_sh_reloc_type) reloc_entry->howto->type;

  if (output_bfd != NULL)
    {
      /* Partial linking--do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol_in->section))
    sym_value = 0;
  else
    sym_value = (symbol_in->value +
		 symbol_in->section->output_section->vma +
		 symbol_in->section->output_offset);

  switch (r_type)
    {
    case R_SH_DIR32:
      insn = bfd_get_32 (abfd, hit_data);
      insn += sym_value + reloc_entry->addend;
      bfd_put_32 (abfd, insn, hit_data);
      break;

    default:
      abort ();
      break;
    }

  return bfd_reloc_ok;
}

/* This structure is used to map BFD reloc codes to SH ELF relocs.  */

struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

/* An array mapping BFD reloc codes to SH ELF relocs.  */

static const struct elf_reloc_map sh64_reloc_map[] =
{
  { BFD_RELOC_NONE, R_SH_NONE },
  { BFD_RELOC_32, R_SH_DIR32 },
  { BFD_RELOC_CTOR, R_SH_DIR32 },
  { BFD_RELOC_32_PCREL, R_SH_REL32 },
  { BFD_RELOC_8_PCREL, R_SH_SWITCH8 },
  { BFD_RELOC_SH_SWITCH16, R_SH_SWITCH16 },
  { BFD_RELOC_SH_SWITCH32, R_SH_SWITCH32 },
  { BFD_RELOC_VTABLE_INHERIT, R_SH_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_SH_GNU_VTENTRY },
  { BFD_RELOC_SH_GOT_LOW16, R_SH_GOT_LOW16 },
  { BFD_RELOC_SH_GOT_MEDLOW16, R_SH_GOT_MEDLOW16 },
  { BFD_RELOC_SH_GOT_MEDHI16, R_SH_GOT_MEDHI16 },
  { BFD_RELOC_SH_GOT_HI16, R_SH_GOT_HI16 },
  { BFD_RELOC_SH_GOTPLT_LOW16, R_SH_GOTPLT_LOW16 },
  { BFD_RELOC_SH_GOTPLT_MEDLOW16, R_SH_GOTPLT_MEDLOW16 },
  { BFD_RELOC_SH_GOTPLT_MEDHI16, R_SH_GOTPLT_MEDHI16 },
  { BFD_RELOC_SH_GOTPLT_HI16, R_SH_GOTPLT_HI16 },
  { BFD_RELOC_SH_PLT_LOW16, R_SH_PLT_LOW16 },
  { BFD_RELOC_SH_PLT_MEDLOW16, R_SH_PLT_MEDLOW16 },
  { BFD_RELOC_SH_PLT_MEDHI16, R_SH_PLT_MEDHI16 },
  { BFD_RELOC_SH_PLT_HI16, R_SH_PLT_HI16 },
  { BFD_RELOC_SH_GOTOFF_LOW16, R_SH_GOTOFF_LOW16 },
  { BFD_RELOC_SH_GOTOFF_MEDLOW16, R_SH_GOTOFF_MEDLOW16 },
  { BFD_RELOC_SH_GOTOFF_MEDHI16, R_SH_GOTOFF_MEDHI16 },
  { BFD_RELOC_SH_GOTOFF_HI16, R_SH_GOTOFF_HI16 },
  { BFD_RELOC_SH_GOTPC_LOW16, R_SH_GOTPC_LOW16 },
  { BFD_RELOC_SH_GOTPC_MEDLOW16, R_SH_GOTPC_MEDLOW16 },
  { BFD_RELOC_SH_GOTPC_MEDHI16, R_SH_GOTPC_MEDHI16 },
  { BFD_RELOC_SH_GOTPC_HI16, R_SH_GOTPC_HI16 },
  { BFD_RELOC_SH_COPY64, R_SH_COPY64 },
  { BFD_RELOC_SH_GLOB_DAT64, R_SH_GLOB_DAT64 },
  { BFD_RELOC_SH_JMP_SLOT64, R_SH_JMP_SLOT64 },
  { BFD_RELOC_SH_RELATIVE64, R_SH_RELATIVE64 },
  { BFD_RELOC_SH_GOT10BY4, R_SH_GOT10BY4 },
  { BFD_RELOC_SH_GOT10BY8, R_SH_GOT10BY8 },
  { BFD_RELOC_SH_GOTPLT10BY4, R_SH_GOTPLT10BY4 },
  { BFD_RELOC_SH_GOTPLT10BY8, R_SH_GOTPLT10BY8 },
  { BFD_RELOC_SH_PT_16, R_SH_PT_16 },
  { BFD_RELOC_SH_SHMEDIA_CODE, R_SH_SHMEDIA_CODE },
  { BFD_RELOC_SH_IMMU5, R_SH_DIR5U },
  { BFD_RELOC_SH_IMMS6, R_SH_DIR6S },
  { BFD_RELOC_SH_IMMU6, R_SH_DIR6U },
  { BFD_RELOC_SH_IMMS10, R_SH_DIR10S },
  { BFD_RELOC_SH_IMMS10BY2, R_SH_DIR10SW },
  { BFD_RELOC_SH_IMMS10BY4, R_SH_DIR10SL },
  { BFD_RELOC_SH_IMMS10BY8, R_SH_DIR10SQ },
  { BFD_RELOC_SH_IMMS16, R_SH_IMMS16 },
  { BFD_RELOC_SH_IMMU16, R_SH_IMMU16 },
  { BFD_RELOC_SH_IMM_LOW16, R_SH_IMM_LOW16 },
  { BFD_RELOC_SH_IMM_LOW16_PCREL, R_SH_IMM_LOW16_PCREL },
  { BFD_RELOC_SH_IMM_MEDLOW16, R_SH_IMM_MEDLOW16 },
  { BFD_RELOC_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDLOW16_PCREL },
  { BFD_RELOC_SH_IMM_MEDHI16, R_SH_IMM_MEDHI16 },
  { BFD_RELOC_SH_IMM_MEDHI16_PCREL, R_SH_IMM_MEDHI16_PCREL },
  { BFD_RELOC_SH_IMM_HI16, R_SH_IMM_HI16 },
  { BFD_RELOC_SH_IMM_HI16_PCREL, R_SH_IMM_HI16_PCREL },
  { BFD_RELOC_64, R_SH_64 },
  { BFD_RELOC_64_PCREL, R_SH_64_PCREL },
};

/* Given a BFD reloc code, return the howto structure for the
   corresponding SH ELf reloc.  */

static reloc_howto_type *
sh_elf64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < sizeof (sh64_reloc_map) / sizeof (struct elf_reloc_map); i++)
    {
      if (sh64_reloc_map[i].bfd_reloc_val == code)
	return &sh_elf64_howto_table[(int) sh64_reloc_map[i].elf_reloc_val];
    }

  return NULL;
}

static reloc_howto_type *
sh_elf64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (sh_elf64_howto_table) / sizeof (sh_elf64_howto_table[0]);
       i++)
    if (sh_elf64_howto_table[i].name != NULL
	&& strcasecmp (sh_elf64_howto_table[i].name, r_name) == 0)
      return &sh_elf64_howto_table[i];

  return NULL;
}

/* Given an ELF reloc, fill in the howto field of a relent.

   See sh_elf_info_to_howto in elf32-sh.c for the original.  */

static void
sh_elf64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r;

  r = ELF64_R_TYPE (dst->r_info);

  BFD_ASSERT (r <= (unsigned int) R_SH_64_PCREL);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC || r > R_SH_LAST_INVALID_RELOC);
  BFD_ASSERT (r < R_SH_DIR8WPN || r > R_SH_LAST_INVALID_RELOC_2);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_3 || r > R_SH_GOTPLT32);
  BFD_ASSERT (r < R_SH_FIRST_INVALID_RELOC_4 || r > R_SH_LAST_INVALID_RELOC_4);

  cache_ptr->howto = &sh_elf64_howto_table[r];
}

/* Relocate an SH ELF section.

   See sh_elf_info_to_howto in elf32-sh.c for the original.  */

static bfd_boolean
sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info, bfd *input_bfd,
			   asection *input_section, bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *sgotplt;
  asection *splt;
  asection *sreloc;
  bfd_vma disp, dropped;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  dynobj = elf_hash_table (info)->dynobj;
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;
  sgotplt = NULL;
  splt = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_vma addend = (bfd_vma)0;
      bfd_reloc_status_type r;
      int seen_stt_datalabel = 0;

      r_symndx = ELF64_R_SYM (rel->r_info);

      r_type = ELF64_R_TYPE (rel->r_info);

      if (r_type == (int) R_SH_NONE)
	continue;

      if (r_type < 0
	  || r_type > R_SH_64_PCREL
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
	  || (r_type >= (int) R_SH_DIR8WPN
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
	  || (r_type >= (int) R_SH_GNU_VTINHERIT
	      && r_type <= (int) R_SH_PSHL)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_2
	      && r_type <= R_SH_GOTPLT32)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_4
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_4))
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      howto = sh_elf64_howto_table + r_type;

      h = NULL;
      sym = NULL;
      sec = NULL;
      relocation = 0;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = ((sec->output_section->vma
			 + sec->output_offset
			 + sym->st_value)
			| ((sym->st_other & STO_SH5_ISA32) != 0));

	  /* A local symbol never has STO_SH5_ISA32, so we don't need
	     datalabel processing here.  Make sure this does not change
	     without notice.  */
	  if ((sym->st_other & STO_SH5_ISA32) != 0)
	    ((*info->callbacks->reloc_dangerous)
	     (info,
	      _("Unexpected STO_SH5_ISA32 on local symbol is not handled"),
	      input_bfd, input_section, rel->r_offset));

	  if (sec != NULL && discarded_section (sec))
	    /* Handled below.  */
	    ;
	  else if (info->relocatable)
	    {
	      /* This is a relocatable link.  We don't have to change
		 anything, unless the reloc is against a section symbol,
		 in which case we have to adjust according to where the
		 section symbol winds up in the output section.  */
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		goto final_link_relocate;

	      continue;
	    }
	  else if (! howto->partial_inplace)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	      relocation |= ((sym->st_other & STO_SH5_ISA32) != 0);
	    }
	  else if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;

	      if (howto->rightshift || howto->src_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

              addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
              msec = sec;
              addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      bfd_put_32 (input_bfd, addend, contents + rel->r_offset);
	      addend = 0;
	    }
	}
      else
	{
	  /* ??? Could we use the RELOC_FOR_GLOBAL_SYMBOL macro here ?  */

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    {
	      /* If the reference passes a symbol marked with
		 STT_DATALABEL, then any STO_SH5_ISA32 on the final value
		 doesn't count.  */
	      seen_stt_datalabel |= h->type == STT_DATALABEL;
	      h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      /* In these cases, we don't need the relocation value.
		 We check specially because in some obscure cases
		 sec->output_section will be NULL.  */
	      if (r_type == R_SH_GOTPC_LOW16
		  || r_type == R_SH_GOTPC_MEDLOW16
		  || r_type == R_SH_GOTPC_MEDHI16
		  || r_type == R_SH_GOTPC_HI16
		  || ((r_type == R_SH_PLT_LOW16
		       || r_type == R_SH_PLT_MEDLOW16
		       || r_type == R_SH_PLT_MEDHI16
		       || r_type == R_SH_PLT_HI16)
		      && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_SH_GOT_LOW16
		       || r_type == R_SH_GOT_MEDLOW16
		       || r_type == R_SH_GOT_MEDHI16
		       || r_type == R_SH_GOT_HI16)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  /* The cases above are those in which relocation is
		     overwritten in the switch block below.  The cases
		     below are those in which we must defer relocation
		     to run-time, because we can't resolve absolute
		     addresses when creating a shared library.  */
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && ((r_type == R_SH_64
			   && !(ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
				|| ELF_ST_VISIBILITY (h->other) == STV_HIDDEN))
			  || r_type == R_SH_64_PCREL)
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_SH_DIR32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */
			  || (input_section->flags & SEC_DEBUGGING) != 0))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && h->def_dynamic)))
		;
	      else if (sec->output_section != NULL)
		relocation = ((h->root.u.def.value
			       + sec->output_section->vma
			       + sec->output_offset)
			      /* A STO_SH5_ISA32 causes a "bitor 1" to the
				 symbol value, unless we've seen
				 STT_DATALABEL on the way to it.  */
			      | ((h->other & STO_SH5_ISA32) != 0
				 && ! seen_stt_datalabel));
	      else if (!info->relocatable
		       && (_bfd_elf_section_offset (output_bfd, info,
						    input_section,
						    rel->r_offset)
			   != (bfd_vma) -1))
		{
		  (*_bfd_error_handler)
		    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
		     input_bfd,
		     input_section,
		     (long) rel->r_offset,
		     howto->name,
		     h->root.root.string);
		}
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else if (!info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	    }
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      disp = (relocation
	      - input_section->output_section->vma
	      - input_section->output_offset
	      - rel->r_offset);
      dropped = 0;
      switch ((int)r_type)
	{
	case R_SH_PT_16:     dropped = disp & 2; break;
	case R_SH_DIR10SW: dropped = disp & 1; break;
	case R_SH_DIR10SL: dropped = disp & 3; break;
	case R_SH_DIR10SQ: dropped = disp & 7; break;
	}
      if (dropped != 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: error: unaligned relocation type %d at %08x reloc %08x\n"),
	     bfd_get_filename (input_bfd), (int)r_type, (unsigned)rel->r_offset, (unsigned)relocation);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      switch ((int)r_type)
	{
	case R_SH_64:
	case R_SH_64_PCREL:
	  if (info->shared
	      && (input_section->flags & SEC_ALLOC) != 0
	      && (r_type != R_SH_64_PCREL
		  || (h != NULL
		      && h->dynindx != -1
		      && (! info->symbolic
			  || !h->def_regular))))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_get_dynamic_reloc_section
		    (input_bfd, input_section, /*rela?*/ TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}

	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset
		= _bfd_elf_section_offset (output_bfd, info,
					   input_section, rel->r_offset);

	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;

	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (r_type == R_SH_64_PCREL)
		{
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
		  outrel.r_info = ELF64_R_INFO (h->dynindx, R_SH_64_PCREL);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  /* h->dynindx may be -1 if this symbol was marked to
		     become local.  */
		  if (h == NULL
		      || ((info->symbolic || h->dynindx == -1)
			  && h->def_regular))
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF64_R_INFO (0, R_SH_RELATIVE64);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      outrel.r_info = ELF64_R_INFO (h->dynindx, R_SH_64);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		}

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }
	  else if (r_type == R_SH_64)
	    addend = rel->r_addend;
	  goto final_link_relocate;

	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  if (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	      || ! info->shared
	      || info->symbolic
	      || h->dynindx == -1
	      || h->plt.offset == (bfd_vma) -1
	      || h->got.offset != (bfd_vma) -1)
	    goto force_got;

	  /* Relocation is to the entry for this symbol in the global
	     offset table extension for the procedure linkage table.  */
	  if (sgotplt == NULL)
	    {
	      sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
	      BFD_ASSERT (sgotplt != NULL);
	    }

	  relocation = (sgotplt->output_offset
			+ ((h->plt.offset / elf_sh64_sizeof_plt (info)
			    - 1 + 3) * 8));

	  relocation -= GOT_BIAS;

	  goto final_link_relocate;

	force_got:
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (h != NULL)
	    {
	      bfd_vma off;

	      off = h->got.offset;
	      if (seen_stt_datalabel)
		{
		  struct elf_sh64_link_hash_entry *hsh;

		  hsh = (struct elf_sh64_link_hash_entry *)h;
		  off = hsh->datalabel_got_offset;
		}
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->dynindx == -1
			  || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
			  || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
		      && h->def_regular))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 4, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  sgot->contents + off);
		      if (seen_stt_datalabel)
			{
			  struct elf_sh64_link_hash_entry *hsh;

			  hsh = (struct elf_sh64_link_hash_entry *)h;
			  hsh->datalabel_got_offset |= 1;
			}
		      else
			h->got.offset |= 1;
		    }
		}

	      relocation = sgot->output_offset + off;
	    }
	  else
	    {
	      bfd_vma off;

	      if (rel->r_addend)
		{
		  BFD_ASSERT (local_got_offsets != NULL
			      && (local_got_offsets[symtab_hdr->sh_info
						    + r_symndx]
				  != (bfd_vma) -1));

		  off = local_got_offsets[symtab_hdr->sh_info
					  + r_symndx];
		}
	      else
		{
		  BFD_ASSERT (local_got_offsets != NULL
			      && local_got_offsets[r_symndx] != (bfd_vma) -1);

		  off = local_got_offsets[r_symndx];
		}

	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation, sgot->contents + off);

		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      s = bfd_get_linker_section (dynobj, ".rela.got");
		      BFD_ASSERT (s != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_SH_RELATIVE64);
		      outrel.r_addend = relocation;
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  if (rel->r_addend)
		    local_got_offsets[symtab_hdr->sh_info + r_symndx] |= 1;
		  else
		    local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_offset + off;
	    }

 	  relocation -= GOT_BIAS;

	  goto final_link_relocate;

	case R_SH_GOTOFF_LOW16:
	case R_SH_GOTOFF_MEDLOW16:
	case R_SH_GOTOFF_MEDHI16:
	case R_SH_GOTOFF_HI16:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= sgot->output_section->vma;

	  relocation -= GOT_BIAS;

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_GOTPC_LOW16:
	case R_SH_GOTPC_MEDLOW16:
	case R_SH_GOTPC_MEDHI16:
	case R_SH_GOTPC_HI16:
	  /* Use global offset table as symbol value.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  relocation = sgot->output_section->vma;

	  relocation += GOT_BIAS;

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    goto final_link_relocate;

	  if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	    goto final_link_relocate;

	  if (h->plt.offset == (bfd_vma) -1)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      goto final_link_relocate;
	    }

	  if (splt == NULL)
	    {
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  relocation = (splt->output_section->vma
			+ splt->output_offset
			+ h->plt.offset);
	  relocation++;

	  addend = rel->r_addend;

	  goto final_link_relocate;

	case R_SH_DIR32:
	case R_SH_SHMEDIA_CODE:
	case R_SH_PT_16:
	case R_SH_DIR5U:
	case R_SH_DIR6S:
	case R_SH_DIR6U:
	case R_SH_DIR10S:
	case R_SH_DIR10SW:
	case R_SH_DIR10SL:
	case R_SH_DIR10SQ:
	case R_SH_IMMS16:
	case R_SH_IMMU16:
	case R_SH_IMM_LOW16:
	case R_SH_IMM_LOW16_PCREL:
	case R_SH_IMM_MEDLOW16:
	case R_SH_IMM_MEDLOW16_PCREL:
	case R_SH_IMM_MEDHI16:
	case R_SH_IMM_MEDHI16_PCREL:
	case R_SH_IMM_HI16:
	case R_SH_IMM_HI16_PCREL:
	  addend = rel->r_addend;
	  /* Fall through.  */
	case R_SH_REL32:
	final_link_relocate:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, addend);
	  break;

	default:
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;

	}

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else
		  {
		    name = (bfd_elf_string_from_elf_section
			    (input_bfd, symtab_hdr->sh_link, sym->st_name));
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section,
			rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   that uses sh_elf64_relocate_section.

   See sh_elf_relocate_section in elf32-sh.c for the original.  */

static bfd_byte *
sh_elf64_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
						       link_order, data,
						       relocatable,
						       symbols);

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
	  input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      Elf_Internal_Sym *isymp;
      Elf_Internal_Sym *isymend;
      asection **secpp;

      /* Read this BFD's local symbols.  */
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    goto error_return;
	}

      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
      if (internal_relocs == NULL)
	goto error_return;

      sections = (asection **) bfd_malloc (symtab_hdr->sh_info
					   * sizeof (asection *));
      if (sections == NULL && symtab_hdr->sh_info > 0)
	goto error_return;

      secpp = sections;
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isymp = isymbuf; isymp < isymend; ++isymp, ++secpp)
	{
	  asection *isec;

	  if (isymp->st_shndx == SHN_UNDEF)
	    isec = bfd_und_section_ptr;
	  else if (isymp->st_shndx == SHN_ABS)
	    isec = bfd_abs_section_ptr;
	  else if (isymp->st_shndx == SHN_COMMON)
	    isec = bfd_com_section_ptr;
	  else
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);

	  *secpp = isec;
	}

      if (! sh_elf64_relocate_section (output_bfd, link_info, input_bfd,
				       input_section, data, internal_relocs,
				       isymbuf, sections))
	goto error_return;

      if (sections != NULL)
	free (sections);
      if (internal_relocs != elf_section_data (input_section)->relocs)
	free (internal_relocs);
      if (isymbuf != NULL
	  && (unsigned char *) isymbuf != symtab_hdr->contents)
	free (isymbuf);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (internal_relocs != NULL
      && internal_relocs != elf_section_data (input_section)->relocs)
    free (internal_relocs);
  if (isymbuf != NULL
      && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  return NULL;
}

/* Set the SHF_SH5_ISA32 flag for ISA SHmedia code sections.  */

static bfd_boolean
sh64_elf64_fake_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			  Elf_Internal_Shdr *elf_section_hdr,
			  asection *asect)
{
  /* Code sections can only contain SH64 code, so mark them as such.  */
  if (bfd_get_section_flags (output_bfd, asect) & SEC_CODE)
    elf_section_hdr->sh_flags |= SHF_SH5_ISA32;

  return TRUE;
}

static bfd_boolean
sh_elf64_set_mach_from_flags (bfd *abfd)
{
  flagword flags = elf_elfheader (abfd)->e_flags;

  switch (flags & EF_SH_MACH_MASK)
    {
    case EF_SH5:
      /* Just one, but keep the switch construct to make additions easy.  */
      bfd_default_set_arch_mach (abfd, bfd_arch_sh, bfd_mach_sh5);
      break;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
  return TRUE;
}

/* Function to keep SH64 specific file flags.

   See sh64_elf_set_private_flags in elf32-sh64.c for the original.  */

static bfd_boolean
sh_elf64_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (! elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return sh_elf64_set_mach_from_flags (abfd);
}

/* Copy the SHF_SH5_ISA32 attribute that we keep on all sections with
   code, to keep attributes the same as for SHmedia in 32-bit ELF.  */

static bfd_boolean
sh_elf64_copy_private_data_internal (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Shdr **o_shdrp;
  asection *isec;
  asection *osec;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  o_shdrp = elf_elfsections (obfd);
  for (osec = obfd->sections; osec; osec = osec->next)
    {
      int oIndex = ((struct bfd_elf_section_data *) elf_section_data (osec))->this_idx;
      for (isec = ibfd->sections; isec; isec = isec->next)
	{
	  if (strcmp (osec->name, isec->name) == 0)
	    {
	      /* Note that we're not disallowing mixing data and code.  */
	      if ((elf_section_data (isec)->this_hdr.sh_flags
		   & SHF_SH5_ISA32) != 0)
		o_shdrp[oIndex]->sh_flags |= SHF_SH5_ISA32;
	      break;
	    }
	}
    }

  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  return sh_elf64_set_private_flags (obfd, elf_elfheader (ibfd)->e_flags);
}

static bfd_boolean
sh_elf64_copy_private_data (bfd *ibfd, bfd *obfd)
{
  return sh_elf64_copy_private_data_internal (ibfd, obfd);
}

static bfd_boolean
sh_elf64_merge_private_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags, new_flags;

  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (bfd_get_arch_size (ibfd) != bfd_get_arch_size (obfd))
    {
      const char *msg;

      if (bfd_get_arch_size (ibfd) == 32
	  && bfd_get_arch_size (obfd) == 64)
	msg = _("%s: compiled as 32-bit object and %s is 64-bit");
      else if (bfd_get_arch_size (ibfd) == 64
	       && bfd_get_arch_size (obfd) == 32)
	msg = _("%s: compiled as 64-bit object and %s is 32-bit");
      else
	msg = _("%s: object size does not match that of target %s");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd),
			     bfd_get_filename (obfd));
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  old_flags = elf_elfheader (obfd)->e_flags;
  new_flags = elf_elfheader (ibfd)->e_flags;
  if (! elf_flags_init (obfd))
    {
      /* This happens when ld starts out with a 'blank' output file.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = old_flags = new_flags;
    }
  /* We don't allow linking in anything else than SH64 code, and since
     this is a 64-bit ELF, we assume the 64-bit ABI is used.  Add code
     here as things change.  */
  else if ((new_flags & EF_SH_MACH_MASK) != EF_SH5)
    {
      (*_bfd_error_handler)
	("%s: does not use the SH64 64-bit ABI as previous modules do",
	 bfd_get_filename (ibfd));
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  sh_elf64_copy_private_data_internal (ibfd, obfd);

  /* I can't think of anything sane other than old_flags being EF_SH5 and
     that we need to preserve that.  */
  elf_elfheader (obfd)->e_flags = old_flags;

  return sh_elf64_set_mach_from_flags (obfd);
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
sh_elf64_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_SH_GNU_VTINHERIT:
      case R_SH_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
sh_elf64_check_relocs (bfd *abfd, struct bfd_link_info *info,
		       asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  dynobj = elf_hash_table (info)->dynobj;
  local_got_offsets = elf_local_got_offsets (abfd);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF64_R_TYPE (rel->r_info))
	    {
	    case R_SH_GOTPLT_LOW16:
	    case R_SH_GOTPLT_MEDLOW16:
	    case R_SH_GOTPLT_MEDHI16:
	    case R_SH_GOTPLT_HI16:
	    case R_SH_GOTPLT10BY4:
	    case R_SH_GOTPLT10BY8:
	    case R_SH_GOT_LOW16:
	    case R_SH_GOT_MEDLOW16:
	    case R_SH_GOT_MEDHI16:
	    case R_SH_GOT_HI16:
	    case R_SH_GOT10BY4:
	    case R_SH_GOT10BY8:
	    case R_SH_GOTOFF_LOW16:
	    case R_SH_GOTOFF_MEDLOW16:
	    case R_SH_GOTOFF_MEDHI16:
	    case R_SH_GOTOFF_HI16:
	    case R_SH_GOTPC_LOW16:
	    case R_SH_GOTPC_MEDLOW16:
	    case R_SH_GOTPC_MEDHI16:
	    case R_SH_GOTPC_HI16:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	      break;

	    default:
	      break;
	    }
	}

      switch (ELF64_R_TYPE (rel->r_info))
        {
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
        case R_SH_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
        case R_SH_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	force_got:
	case R_SH_GOT_LOW16:
	case R_SH_GOT_MEDLOW16:
	case R_SH_GOT_MEDHI16:
	case R_SH_GOT_HI16:
	case R_SH_GOT10BY4:
	case R_SH_GOT10BY8:
	  /* This symbol requires a global offset table entry.  */

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_linker_section (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY);
		  srelgot = bfd_make_section_anyway_with_flags (dynobj,
								".rela.got",
								flags);
		  if (srelgot == NULL
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      if (h->type == STT_DATALABEL)
		{
		  struct elf_sh64_link_hash_entry *hsh;

		  h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  hsh = (struct elf_sh64_link_hash_entry *)h;
		  if (hsh->datalabel_got_offset != (bfd_vma) -1)
		    break;

		  hsh->datalabel_got_offset = sgot->size;
		}
	      else
		{
		  if (h->got.offset != (bfd_vma) -1)
		    {
		      /* We have already allocated space in the .got.  */
		      break;
		    }
		  h->got.offset = sgot->size;
		}

	      /* Make sure this symbol is output as a dynamic symbol.  */
	      if (h->dynindx == -1)
		{
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
		    return FALSE;
		}

	      srelgot->size += sizeof (Elf64_External_Rela);
	    }
	  else
	    {
     	      /* This is a global offset table entry for a local
		 symbol.  */
	      if (local_got_offsets == NULL)
		{
		  size_t size;
		  register unsigned int i;

		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
		  /* Reserve space for both the datalabel and
		     codelabel local GOT offsets.  */
		  size *= 2;
		  local_got_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_got_offsets == NULL)
		    return FALSE;
		  elf_local_got_offsets (abfd) = local_got_offsets;
		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
		  for (; i < 2 * symtab_hdr->sh_info; i++)
		    local_got_offsets[i] = (bfd_vma) -1;
		}
	      if ((rel->r_addend & 1) != 0)
		{
		  if (local_got_offsets[symtab_hdr->sh_info
					+ r_symndx] != (bfd_vma) -1)
		    {
		      /* We have already allocated space in the .got.  */
		      break;
		    }
		  local_got_offsets[symtab_hdr->sh_info
				    + r_symndx] = sgot->size;
		}
	      else
		{
		  if (local_got_offsets[r_symndx] != (bfd_vma) -1)
		    {
		      /* We have already allocated space in the .got.  */
		      break;
		    }
		  local_got_offsets[r_symndx] = sgot->size;
		}

	      if (info->shared)
		{
		  /* If we are generating a shared object, we need to
		     output a R_SH_RELATIVE reloc so that the dynamic
		     linker can adjust this GOT entry.  */
		  srelgot->size += sizeof (Elf64_External_Rela);
		}
	    }

	  sgot->size += 8;

	  break;

	case R_SH_GOTPLT_LOW16:
	case R_SH_GOTPLT_MEDLOW16:
	case R_SH_GOTPLT_MEDHI16:
	case R_SH_GOTPLT_HI16:
	case R_SH_GOTPLT10BY4:
	case R_SH_GOTPLT10BY8:
	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */

	  if (h == NULL
	      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	      || ! info->shared
	      || info->symbolic
	      || h->dynindx == -1
	      || h->got.offset != (bfd_vma) -1)
	    goto force_got;

	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  h->needs_plt = 1;

	  break;

	case R_SH_PLT_LOW16:
	case R_SH_PLT_MEDLOW16:
	case R_SH_PLT_MEDHI16:
	case R_SH_PLT_HI16:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h == NULL)
	    continue;

	  if (ELF_ST_VISIBILITY (h->other) == STV_INTERNAL
	      || ELF_ST_VISIBILITY (h->other) == STV_HIDDEN)
	    break;

	  h->needs_plt = 1;

	  break;

	case R_SH_64:
	case R_SH_64_PCREL:
	  if (h != NULL)
	    h->non_got_ref = 1;

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  We account for that
	     possibility below by storing information in the
	     pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0
	      && (ELF32_R_TYPE (rel->r_info) != R_SH_64_PCREL
		  || (h != NULL
		      && (! info->symbolic
			  || !h->def_regular))))
	    {
	      /* When creating a shared object, we must copy these
		 reloc types into the output file.  We create a reloc
		 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      sreloc->size += sizeof (Elf64_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
		 global symbol, we count the number of PC relative
		 relocations we have entered for this symbol, so that
		 we can discard them again if the symbol is later
		 defined by a regular object.  Note that this function
		 is only called if we are using an elf_sh linker
		 hash table, which means that h is really a pointer to
		 an elf_sh_link_hash_entry.  */
	      if (h != NULL && info->symbolic
		  && ELF64_R_TYPE (rel->r_info) == R_SH_64_PCREL)
		{
		  struct elf_sh64_link_hash_entry *eh;
		  struct elf_sh64_pcrel_relocs_copied *p;

		  eh = (struct elf_sh64_link_hash_entry *) h;

		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
		    {
		      p = ((struct elf_sh64_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, sizeof *p));
		      if (p == NULL)
			return FALSE;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }

		  ++p->count;
		}
	    }

	  break;
        }
    }

  return TRUE;
}

static int
sh64_elf64_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_DATALABEL)
    return STT_DATALABEL;

  return type;
}

/* FIXME: This is a copy of sh64_elf_add_symbol_hook in elf32-sh64.c.
   Either file can presumably exist without the other, but do not differ
   in elf-size-ness.  How to share?

   Hook called by the linker routine which adds symbols from an object
   file.  We must make indirect symbols for undefined symbols marked with
   STT_DATALABEL, so relocations passing them will pick up that attribute
   and neutralize STO_SH5_ISA32 found on the symbol definition.

   There is a problem, though: We want to fill in the hash-table entry for
   this symbol and signal to the caller that no further processing is
   needed.  But we don't have the index for this hash-table entry.  We
   rely here on that the current entry is the first hash-entry with NULL,
   which seems brittle.  Also, iterating over the hash-table to find that
   entry is a linear operation on the number of symbols in this input
   file, and this function should take constant time, so that's not good
   too.  Only comfort is that DataLabel references should only be found in
   hand-written assembly code and thus be rare.  FIXME: Talk maintainers
   into adding an option to elf_add_symbol_hook (preferably) for the index
   or the hash entry, alternatively adding the index to Elf_Internal_Sym
   (not so good).  */

static bfd_boolean
sh64_elf64_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			    Elf_Internal_Sym *sym, const char **namep,
			    flagword *flagsp ATTRIBUTE_UNUSED,
			    asection **secp, bfd_vma *valp)
{
  /* We want to do this for relocatable as well as final linking.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_DATALABEL
      && is_elf_hash_table (info->hash))
    {
      struct elf_link_hash_entry *h;

      /* For relocatable links, we register the DataLabel sym in its own
	 right, and tweak the name when it's output.  Otherwise, we make
	 an indirect symbol of it.  */
      flagword flags
	= info->relocatable || info->emitrelocations
	? BSF_GLOBAL : BSF_GLOBAL | BSF_INDIRECT;

      char *dl_name
	= bfd_malloc (strlen (*namep) + sizeof (DATALABEL_SUFFIX));
      struct elf_link_hash_entry ** sym_hash = elf_sym_hashes (abfd);

      BFD_ASSERT (sym_hash != NULL);

      /* Allocation may fail.  */
      if (dl_name == NULL)
	return FALSE;

      strcpy (dl_name, *namep);
      strcat (dl_name, DATALABEL_SUFFIX);

      h = (struct elf_link_hash_entry *)
	bfd_link_hash_lookup (info->hash, dl_name, FALSE, FALSE, FALSE);

      if (h == NULL)
	{
	  /* No previous datalabel symbol.  Make one.  */
	  struct bfd_link_hash_entry *bh = NULL;
	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

	  if (! _bfd_generic_link_add_one_symbol (info, abfd, dl_name,
						  flags, *secp, *valp,
						  *namep, FALSE,
						  bed->collect, &bh))
	    {
	      free (dl_name);
	      return FALSE;
	    }

	  h = (struct elf_link_hash_entry *) bh;
	  h->non_elf = 0;
	  h->type = STT_DATALABEL;
	}
      else
	/* If a new symbol was created, it holds the allocated name.
	   Otherwise, we don't need it anymore and should deallocate it.  */
	free (dl_name);

      if (h->type != STT_DATALABEL
	  || ((info->relocatable || info->emitrelocations)
	      && h->root.type != bfd_link_hash_undefined)
	  || (! info->relocatable && !info->emitrelocations
	      && h->root.type != bfd_link_hash_indirect))
	{
	  /* Make sure we don't get confused on invalid input.  */
	  (*_bfd_error_handler)
	    (_("%s: encountered datalabel symbol in input"),
	     bfd_get_filename (abfd));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      /* Now find the hash-table slot for this entry and fill it in.  */
      while (*sym_hash != NULL)
	sym_hash++;
      *sym_hash = h;

      /* Signal to caller to skip this symbol - we've handled it.  */
      *namep = NULL;
    }

  return TRUE;
}

/* This hook function is called before the linker writes out a global
   symbol.  For relocatable links, DataLabel symbols will be present in
   linker output.  We cut off the special suffix on those symbols, so the
   right name appears in the output.

   When linking and emitting relocations, there can appear global symbols
   that are not referenced by relocs, but rather only implicitly through
   DataLabel references, a relation that is not visible to the linker.
   Since no stripping of global symbols in done when doing such linking,
   we don't need to look up and make sure to emit the main symbol for each
   DataLabel symbol.  */

static int
sh64_elf64_link_output_symbol_hook (struct bfd_link_info *info,
				    const char *cname,
				    Elf_Internal_Sym *sym,
				    asection *input_sec ATTRIBUTE_UNUSED,
				    struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  char *name = (char *) cname;

  if (info->relocatable || info->emitrelocations)
    {
      if (ELF_ST_TYPE (sym->st_info) == STT_DATALABEL)
	name[strlen (name) - strlen (DATALABEL_SUFFIX)] = 0;
    }

  return 1;
}

/* Set bit 0 on the entry address; it always points to SHmedia code.  This
   is mostly for symmetry with the 32-bit format, where code can be
   SHcompact and we need to make a distinction to make sure execution
   starts in the right ISA mode.  It is also convenient for a loader,
   which would otherwise have to set this bit when loading a TR register
   before jumping to the program entry.  */

static void
sh64_elf64_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
  /* FIXME: Perhaps we shouldn't do this if the entry address was supplied
     numerically, but we currently lack the infrastructure to recognize
     that: The entry symbol, and info whether it is numeric or a symbol
     name is kept private in the linker.  */
  if (elf_elfheader (abfd)->e_type == ET_EXEC)
    elf_elfheader (abfd)->e_entry |= 1;
}

/* First entry in an absolute procedure linkage table look like this.  */

static const bfd_byte elf_sh64_plt0_entry_be[PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x10, /* movi  .got.plt >> 48, r17 */
  0xc8, 0x00, 0x01, 0x10, /* shori (.got.plt >> 32) & 65535, r17 */
  0xc8, 0x00, 0x01, 0x10, /* shori (.got.plt >> 16) & 65535, r17 */
  0xc8, 0x00, 0x01, 0x10, /* shori .got.plt & 65535, r17 */
  0x8d, 0x10, 0x09, 0x90, /* ld.q  r17, 16, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x8d, 0x10, 0x05, 0x10, /* ld.q  r17, 8, r17 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
};

static const bfd_byte elf_sh64_plt0_entry_le[PLT_ENTRY_SIZE] =
{
  0x10, 0x01, 0x00, 0xcc, /* movi  .got.plt >> 16, r17 */
  0x10, 0x01, 0x00, 0xc8, /* shori (.got.plt >> 32) & 65535, r17 */
  0x10, 0x01, 0x00, 0xc8, /* shori (.got.plt >> 16) & 65535, r17 */
  0x10, 0x01, 0x00, 0xc8, /* shori .got.plt & 65535, r17 */
  0x90, 0x09, 0x10, 0x8d, /* ld.q  r17, 16, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0x10, 0x05, 0x10, 0x8d, /* ld.q  r17, 8, r17 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
};

/* Sebsequent entries in an absolute procedure linkage table look like
   this.  */

static const bfd_byte elf_sh64_plt_entry_be[PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x90, /* movi  nameN-in-GOT >> 48, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori (nameN-in-GOT >> 32) & 65535, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori (nameN-in-GOT >> 16) & 65535, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori nameN-in-GOT & 65535, r25 */
  0x8d, 0x90, 0x01, 0x90, /* ld.q  r25, 0, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0xcc, 0x00, 0x01, 0x90, /* movi  (.+8-.PLT0) >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori (.+4-.PLT0) & 65535, r25 */
  0x6b, 0xf5, 0x66, 0x00, /* ptrel r25, tr0 */
  0xcc, 0x00, 0x01, 0x50, /* movi  reloc-offset >> 16, r21 */
  0xc8, 0x00, 0x01, 0x50, /* shori reloc-offset & 65535, r21 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
};

static const bfd_byte elf_sh64_plt_entry_le[PLT_ENTRY_SIZE] =
{
  0x90, 0x01, 0x00, 0xcc, /* movi  nameN-in-GOT >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN-in-GOT & 65535, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN-in-GOT & 65535, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN-in-GOT & 65535, r25 */
  0x90, 0x01, 0x90, 0x8d, /* ld.q  r25, 0, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0x90, 0x01, 0x00, 0xcc, /* movi  (.+8-.PLT0) >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori (.+4-.PLT0) & 65535, r25 */
  0x00, 0x66, 0xf5, 0x6b, /* ptrel r25, tr0 */
  0x50, 0x01, 0x00, 0xcc, /* movi  reloc-offset >> 16, r21 */
  0x50, 0x01, 0x00, 0xc8, /* shori reloc-offset & 65535, r21 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
};

/* Entries in a PIC procedure linkage table look like this.  */

static const bfd_byte elf_sh64_pic_plt_entry_be[PLT_ENTRY_SIZE] =
{
  0xcc, 0x00, 0x01, 0x90, /* movi  nameN@@GOT >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori nameN@@GOT & 65535, r25 */
  0x40, 0xc3, 0x65, 0x90, /* ldx.q r12, r25, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0x6f, 0xf0, 0xff, 0xf0, /* nop */
  0xce, 0x00, 0x01, 0x10, /* movi  -GOT_BIAS, r17 */
  0x00, 0xc9, 0x45, 0x10, /* add   r12, r17, r17 */
  0x8d, 0x10, 0x09, 0x90, /* ld.q  r17, 16, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
  0x8d, 0x10, 0x05, 0x10, /* ld.q  r17, 8, r17 */
  0xcc, 0x00, 0x01, 0x50, /* movi  reloc-offset >> 16, r21 */
  0xc8, 0x00, 0x01, 0x50, /* shori reloc-offset & 65535, r21 */
  0x44, 0x01, 0xff, 0xf0, /* blink tr0, r63 */
};

static const bfd_byte elf_sh64_pic_plt_entry_le[PLT_ENTRY_SIZE] =
{
  0x90, 0x01, 0x00, 0xcc, /* movi  nameN@@GOT >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori nameN@@GOT & 65535, r25 */
  0x90, 0x65, 0xc3, 0x40, /* ldx.q r12, r25, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0xf0, 0xff, 0xf0, 0x6f, /* nop */
  0x10, 0x01, 0x00, 0xce, /* movi  -GOT_BIAS, r17 */
  0x10, 0x45, 0xc9, 0x00, /* add   r12, r17, r17 */
  0x90, 0x09, 0x10, 0x8d, /* ld.q  r17, 16, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
  0x10, 0x05, 0x10, 0x8d, /* ld.q  r17, 8, r17 */
  0x50, 0x01, 0x00, 0xcc, /* movi  reloc-offset >> 16, r21 */
  0x50, 0x01, 0x00, 0xc8, /* shori reloc-offset & 65535, r21 */
  0xf0, 0xff, 0x01, 0x44, /* blink tr0, r63 */
};

static const bfd_byte *elf_sh64_plt0_entry;
static const bfd_byte *elf_sh64_plt_entry;
static const bfd_byte *elf_sh64_pic_plt_entry;

/* Create an entry in an sh ELF linker hash table.  */

static struct bfd_hash_entry *
sh64_elf64_link_hash_newfunc (struct bfd_hash_entry *entry,
			      struct bfd_hash_table *table,
			      const char *string)
{
  struct elf_sh64_link_hash_entry *ret =
    (struct elf_sh64_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct elf_sh64_link_hash_entry *) NULL)
    ret = ((struct elf_sh64_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_sh64_link_hash_entry)));
  if (ret == (struct elf_sh64_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_sh64_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_sh64_link_hash_entry *) NULL)
    {
      ret->pcrel_relocs_copied = NULL;
      ret->datalabel_got_offset = (bfd_vma) -1;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an sh64 ELF linker hash table.  */

static struct bfd_link_hash_table *
sh64_elf64_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;

  ret = (struct elf_link_hash_table *) bfd_zmalloc (sizeof (* ret));
  if (ret == (struct elf_link_hash_table *) NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (ret, abfd,
				      sh64_elf64_link_hash_newfunc,
				      sizeof (struct elf_sh64_link_hash_entry),
				      GENERIC_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

inline static void
movi_shori_putval (bfd *output_bfd, unsigned long value, bfd_byte *addr)
{
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr)
	      | ((value >> 6) & 0x3fffc00),
	      addr);
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr + 4)
	      | ((value << 10) & 0x3fffc00),
	      addr + 4);
}

inline static void
movi_3shori_putval (bfd *output_bfd, bfd_vma value, bfd_byte *addr)
{
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr)
	      | ((value >> 38) & 0x3fffc00),
	      addr);
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr + 4)
	      | ((value >> 22) & 0x3fffc00),
	      addr + 4);
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr + 8)
	      | ((value >> 6) & 0x3fffc00),
	      addr + 8);
  bfd_put_32 (output_bfd,
	      bfd_get_32 (output_bfd, addr + 12)
	      | ((value << 10) & 0x3fffc00),
	      addr + 12);
}

/* Create dynamic sections when linking against a dynamic object.  */

static bfd_boolean
sh64_elf64_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  register asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign = 0;

  switch (bed->s->arch_size)
    {
    case 32:
      ptralign = 2;
      break;

    case 64:
      ptralign = 3;
      break;

    default:
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s,
	      (bfd_vma) 0, (const char *) NULL, FALSE, bed->collect, &bh)))
	return FALSE;

      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      elf_hash_table (info)->hplt = h;

      if (info->shared
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  s = bfd_make_section_anyway_with_flags (abfd,
					  bed->default_use_rela_p
					  ? ".rela.plt" : ".rel.plt",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (! _bfd_elf_create_got_section (abfd, info))
    return FALSE;

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      SEC_ALLOC | SEC_LINKER_CREATED);
      if (s == NULL)
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
	 normally needed.  We need to create it here, though, so that the
	 linker will map it to an output section.  We can't just create it
	 only if we need it, because we will not know whether we need it
	 until we have seen all the input files, and the first time the
	 main linker code calls BFD after examining all the input files
	 (size_dynamic_sections) the input sections have already been
	 mapped to the output sections.  If the section turns out not to
	 be needed, we can discard it later.  We will never need this
	 section when generating a shared object, since they do not use
	 copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section_anyway_with_flags (abfd,
						  (bed->default_use_rela_p
						   ? ".rela.bss" : ".rel.bss"),
						  flags | SEC_READONLY);
	  if (s == NULL
	      || ! bfd_set_section_alignment (abfd, s, ptralign))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
sh64_elf64_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (! info->shared
	  && !h->def_dynamic
	  && !h->ref_dynamic)
	{
	  /* This case can occur if we saw a PLT reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object.  In such a case, we don't actually need to build
	     a procedure linkage table, and we can just do a REL64
	     reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
	  return TRUE;
	}

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->size == 0)
	s->size += PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
	}

      h->plt.offset = s->size;

      /* Make room for this entry.  */
      s->size += elf_sh64_sizeof_plt (info);

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_linker_section (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->size += 8;

      /* We also need to make an entry in the .rela.plt section.  */

      s = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf64_External_Rela);

      return TRUE;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_linker_section (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_SH_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf64_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* This function is called via sh_elf_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

static bfd_boolean
sh64_elf64_discard_copies (struct elf_sh64_link_hash_entry *h,
			   void *ignore ATTRIBUTE_UNUSED)
{
  struct elf_sh64_pcrel_relocs_copied *s;

  /* We only discard relocs for symbols defined in a regular object.  */
  if (!h->root.def_regular)
    return TRUE;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->size -= s->count * sizeof (Elf64_External_Rela);

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
sh64_elf64_size_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }
  else
    {
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.  */
      s = bfd_get_linker_section (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    sh64_elf64_link_hash_traverse (elf_hash_table (info),
				   sh64_elf64_discard_copies, NULL);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strcmp (name, ".plt") == 0)
	{
	  /* Remember whether there is a PLT.  */
	  plt = s->size != 0;
	}
      else if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      asection *target;

	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = TRUE;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = TRUE;
		}

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".got")
	       && strcmp (name, ".dynbss") != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in sh64_elf64_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (info->executable)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,
					      sizeof (Elf64_External_Rela)))
	    return FALSE;
	}

      if (reltext)
	{
	  if (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
sh64_elf64_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srel;

      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_linker_section (dynobj, ".plt");
      sgot = bfd_get_linker_section (dynobj, ".got.plt");
      srel = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srel != NULL);

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / elf_sh64_sizeof_plt (info) - 1;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 8 bytes.
	 The first three are reserved.  */
      got_offset = (plt_index + 3) * 8;

      if (info->shared)
	got_offset -= GOT_BIAS;

      /* Fill in the entry in the procedure linkage table.  */
      if (! info->shared)
	{
	  if (elf_sh64_plt_entry == NULL)
	    {
	      elf_sh64_plt_entry = (bfd_big_endian (output_bfd) ?
				  elf_sh64_plt_entry_be : elf_sh64_plt_entry_le);
	    }
	  memcpy (splt->contents + h->plt.offset, elf_sh64_plt_entry,
		  elf_sh64_sizeof_plt (info));
	  movi_3shori_putval (output_bfd,
			      (sgot->output_section->vma
			       + sgot->output_offset
			       + got_offset),
			      (splt->contents + h->plt.offset
			       + elf_sh64_plt_symbol_offset (info)));

	  /* Set bottom bit because its for a branch to SHmedia */
	  movi_shori_putval (output_bfd,
			     -(h->plt.offset
			      + elf_sh64_plt_plt0_offset (info) + 8)
			     | 1,
			     (splt->contents + h->plt.offset
			      + elf_sh64_plt_plt0_offset (info)));
	}
      else
	{
	  if (elf_sh64_pic_plt_entry == NULL)
	    {
	      elf_sh64_pic_plt_entry = (bfd_big_endian (output_bfd) ?
				      elf_sh64_pic_plt_entry_be :
				      elf_sh64_pic_plt_entry_le);
	    }
	  memcpy (splt->contents + h->plt.offset, elf_sh64_pic_plt_entry,
		  elf_sh64_sizeof_plt (info));
	  movi_shori_putval (output_bfd, got_offset,
			     (splt->contents + h->plt.offset
			      + elf_sh64_plt_symbol_offset (info)));
	}

      if (info->shared)
	got_offset += GOT_BIAS;

      movi_shori_putval (output_bfd,
			 plt_index * sizeof (Elf64_External_Rela),
			 (splt->contents + h->plt.offset
			  + elf_sh64_plt_reloc_offset (info)));

      /* Fill in the entry in the global offset table.  */
      bfd_put_64 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset
		   + elf_sh64_plt_temp_offset (info)),
		  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + got_offset);
      rel.r_info = ELF64_R_INFO (h->dynindx, R_SH_JMP_SLOT64);
      rel.r_addend = 0;
      rel.r_addend = GOT_BIAS;
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srel;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      sgot = bfd_get_linker_section (dynobj, ".got");
      srel = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srel != NULL);

      rel.r_offset = (sgot->output_section->vma
		      + sgot->output_offset
		      + (h->got.offset &~ 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  Likewise if
	 the symbol was forced to be local because of a version file.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic || h->dynindx == -1)
	  && h->def_regular)
	{
	  rel.r_info = ELF64_R_INFO (0, R_SH_RELATIVE64);
	  rel.r_addend = (h->root.u.def.value
			  + h->root.u.def.section->output_section->vma
			  + h->root.u.def.section->output_offset);
	}
      else
	{
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  rel.r_info = ELF64_R_INFO (h->dynindx, R_SH_GLOB_DAT64);
	  rel.r_addend = 0;
	}

      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (s != NULL);

      rel.r_offset = (h->root.u.def.value
		      + h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset);
      rel.r_info = ELF64_R_INFO (h->dynindx, R_SH_COPY64);
      rel.r_addend = 0;
      loc = s->contents;
      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
sh64_elf64_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sgot;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_linker_section (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf64_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;
	  struct elf_link_hash_entry *h;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;

	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      if (dyn.d_un.d_val != 0)
		{
		  h = elf_link_hash_lookup (elf_hash_table (info), name,
					    FALSE, FALSE, TRUE);
		  if (h != NULL && (h->other & STO_SH5_ISA32))
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;

	    case DT_JMPREL:
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* My reading of the SVR4 ABI indicates that the
		 procedure linkage table relocs (DT_JMPREL) should be
		 included in the overall relocs (DT_RELA).  This is
		 what Solaris does.  However, UnixWare can not handle
		 that case.  Therefore, we override the DT_RELASZ entry
		 here to make it not include the JMPREL relocs.  Since
		 the linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      splt = bfd_get_linker_section (dynobj, ".plt");
      if (splt && splt->size > 0)
	{
	  if (info->shared)
	    {
	      if (elf_sh64_pic_plt_entry == NULL)
		{
		  elf_sh64_pic_plt_entry = (bfd_big_endian (output_bfd) ?
					  elf_sh64_pic_plt_entry_be :
					  elf_sh64_pic_plt_entry_le);
		}
	      memcpy (splt->contents, elf_sh64_pic_plt_entry,
		      elf_sh64_sizeof_plt (info));
	    }
	  else
	    {
	      if (elf_sh64_plt0_entry == NULL)
		{
		  elf_sh64_plt0_entry = (bfd_big_endian (output_bfd) ?
				       elf_sh64_plt0_entry_be :
				       elf_sh64_plt0_entry_le);
		}
	      memcpy (splt->contents, elf_sh64_plt0_entry, PLT_ENTRY_SIZE);
	      movi_3shori_putval (output_bfd,
				  sgot->output_section->vma
				  + sgot->output_offset,
				  splt->contents
				  + elf_sh64_plt0_gotplt_offset (info));
	    }

	  /* UnixWare sets the entsize of .plt to 8, although that doesn't
	     really seem like the right value.  */
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 8;
	}
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_64 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + 16);
    }

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 8;

  return TRUE;
}

/* Merge non visibility st_other attribute when the symbol comes from
   a dynamic object.  */
static void
sh64_elf64_merge_symbol_attribute (struct elf_link_hash_entry *h,
				   const Elf_Internal_Sym *isym,
				   bfd_boolean definition,
				   bfd_boolean dynamic ATTRIBUTE_UNUSED)
{
  if ((isym->st_other & ~ELF_ST_VISIBILITY (-1)) != 0)
    {
      unsigned char other;

      /* Take the balance of OTHER from the definition.  */
      other = (definition ? isym->st_other : h->other);
      other &= ~ ELF_ST_VISIBILITY (-1);
      h->other = other | ELF_ST_VISIBILITY (h->other);
    }

  return;
}

static const struct bfd_elf_special_section sh64_elf64_special_sections[]=
{
  { STRING_COMMA_LEN (".cranges"), 0, SHT_PROGBITS, 0 },
  { NULL,                       0, 0, 0,            0 }
};

#define TARGET_BIG_SYM		bfd_elf64_sh64_vec
#define TARGET_BIG_NAME		"elf64-sh64"
#define TARGET_LITTLE_SYM	bfd_elf64_sh64l_vec
#define TARGET_LITTLE_NAME	"elf64-sh64l"
#define ELF_ARCH		bfd_arch_sh
#define ELF_MACHINE_CODE	EM_SH
#define ELF_MAXPAGESIZE		128

#define elf_symbol_leading_char '_'

#define bfd_elf64_bfd_reloc_type_lookup	sh_elf64_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup \
					sh_elf64_reloc_name_lookup
#define elf_info_to_howto		sh_elf64_info_to_howto

/* Note: there's no relaxation at present.  */

#define elf_backend_relocate_section	sh_elf64_relocate_section
#define bfd_elf64_bfd_get_relocated_section_contents \
					sh_elf64_get_relocated_section_contents
#define elf_backend_object_p		sh_elf64_set_mach_from_flags
#define bfd_elf64_bfd_set_private_flags \
					sh_elf64_set_private_flags
#define bfd_elf64_bfd_copy_private_bfd_data \
					sh_elf64_copy_private_data
#define bfd_elf64_bfd_merge_private_bfd_data \
					sh_elf64_merge_private_data
#define elf_backend_fake_sections	sh64_elf64_fake_sections

#define elf_backend_gc_mark_hook        sh_elf64_gc_mark_hook
#define elf_backend_check_relocs        sh_elf64_check_relocs

#define elf_backend_can_gc_sections	1

#define elf_backend_get_symbol_type	sh64_elf64_get_symbol_type

#define elf_backend_add_symbol_hook	sh64_elf64_add_symbol_hook

#define elf_backend_link_output_symbol_hook \
	sh64_elf64_link_output_symbol_hook

#define	elf_backend_merge_symbol_attribute \
	sh64_elf64_merge_symbol_attribute

#define elf_backend_final_write_processing \
 	sh64_elf64_final_write_processing

#define elf_backend_create_dynamic_sections \
					sh64_elf64_create_dynamic_sections
#define bfd_elf64_bfd_link_hash_table_create \
					sh64_elf64_link_hash_table_create
#define elf_backend_adjust_dynamic_symbol \
					sh64_elf64_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
					sh64_elf64_size_dynamic_sections
#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_finish_dynamic_symbol \
					sh64_elf64_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					sh64_elf64_finish_dynamic_sections
#define elf_backend_special_sections	sh64_elf64_special_sections

#define elf_backend_want_got_plt	1
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size	24

#include "elf64-target.h"

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64nbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64l-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf64_bed			elf64_sh64_nbsd_bed

#include "elf64-target.h"

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64blin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64big-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64-linux"
#undef elf64_bed
#define	elf64_bed			elf64_sh64_linux_bed

#include "elf64-target.h"
@


1.95
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d2427 4
@


1.94
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d3072 1
a3072 1
  ret = (struct elf_link_hash_table *) bfd_malloc (sizeof (* ret));
@


1.93
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d3772 1
a3772 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.92
log
@	* elf32-sh.c (sh_elf_create_dynamic_sections): Don't create .rela
	section for bss type sections, except for .rela.bss.
	* elf-m10300.c (_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_create_dynamic_sections): Likewise.
	* elf32-lm32.c (lm32_elf_create_dynamic_sections): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
@
text
@d1800 1
a1800 1
	      sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
d1823 1
a1823 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d1917 1
a1917 1
		      s = bfd_get_section_by_name (dynobj, ".rela.got");
d1952 1
a1952 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d1977 1
a1977 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d2015 1
a2015 1
	      splt = bfd_get_section_by_name (dynobj, ".plt");
d2493 1
a2493 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d2500 1
a2500 1
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d2503 6
a2508 8
		  srelgot = bfd_make_section_with_flags (dynobj,
							 ".rela.got",
							 (SEC_ALLOC
							  | SEC_LOAD
							  | SEC_HAS_CONTENTS
							  | SEC_IN_MEMORY
							  | SEC_LINKER_CREATED
							  | SEC_READONLY));
d3160 1
a3160 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d3187 4
a3190 3
  s = bfd_make_section_with_flags (abfd,
				   bed->default_use_rela_p ? ".rela.plt" : ".rel.plt",
				   flags | SEC_READONLY);
d3206 2
a3207 2
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d3224 4
a3227 4
	  s = bfd_make_section_with_flags (abfd,
					   (bed->default_use_rela_p
					    ? ".rela.bss" : ".rel.bss"),
					   flags | SEC_READONLY);
d3286 1
a3286 1
      s = bfd_get_section_by_name (dynobj, ".plt");
d3314 1
a3314 1
      s = bfd_get_section_by_name (dynobj, ".got.plt");
d3320 1
a3320 1
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
d3364 1
a3364 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d3375 1
a3375 1
      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d3427 1
a3427 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d3440 1
a3440 1
      s = bfd_get_section_by_name (dynobj, ".rela.got");
d3609 3
a3611 3
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srel = bfd_get_section_by_name (dynobj, ".rela.plt");
d3712 2
a3713 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srel = bfd_get_section_by_name (dynobj, ".rela.got");
d3758 1
a3758 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
d3791 1
a3791 1
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d3793 1
a3793 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d3876 1
a3876 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.91
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@a3198 24
  {
    const char *secname;
    char *relname;
    flagword secflags;
    asection *sec;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
	secflags = bfd_get_section_flags (abfd, sec);
	if ((secflags & (SEC_DATA | SEC_LINKER_CREATED))
	    || ((secflags & SEC_HAS_CONTENTS) != SEC_HAS_CONTENTS))
	  continue;
	secname = bfd_get_section_name (abfd, sec);
	relname = (char *) bfd_malloc (strlen (secname) + 6);
	strcpy (relname, ".rela");
	strcat (relname, secname);
	s = bfd_make_section_with_flags (abfd, relname,
					 flags | SEC_READONLY);
	if (s == NULL
	    || ! bfd_set_section_alignment (abfd, s, ptralign))
	  return FALSE;
      }
  }

@


1.90
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1666 1
a1666 1
					 rel, relend, howto, contents);
@


1.89
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1517 1
a1517 1
	  if (sec != NULL && elf_discarded_section (sec))
d1664 1
a1664 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.88
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d3 1
a3 1
   2010, 2011 Free Software Foundation, Inc.
a3378 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d3396 1
a3396 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.87
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d1633 5
a1637 1
	      else if (!info->relocatable)
@


1.87.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1517 1
a1517 1
	  if (sec != NULL && discarded_section (sec))
d1660 1
a1660 1
      if (sec != NULL && discarded_section (sec))
@


1.86
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2010  Free Software Foundation, Inc.
a3424 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_sh64_link_hash_entry *) h->root.root.u.i.link;

@


1.85
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d1661 2
a1662 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.84
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
a91 7
/* sh ELF linker hash table.  */

struct elf_sh64_link_hash_table
{
  struct elf_link_hash_table root;
};

d94 3
a96 3
#define sh64_elf64_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
a99 5
/* Get the sh ELF linker hash table from a link_info structure.  */

#define sh64_elf64_hash_table(p) \
  ((struct elf_sh64_link_hash_table *) ((p)->hash))

d3075 1
a3075 1
  struct elf_sh64_link_hash_table *ret;
d3077 2
a3078 3
  ret = ((struct elf_sh64_link_hash_table *)
	 bfd_malloc (sizeof (struct elf_sh64_link_hash_table)));
  if (ret == (struct elf_sh64_link_hash_table *) NULL)
d3081 1
a3081 1
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
d3083 2
a3084 1
				      sizeof (struct elf_sh64_link_hash_entry)))
d3090 1
a3090 1
  return &ret->root.root;
d3488 1
a3488 1
    sh64_elf64_link_hash_traverse (sh64_elf64_hash_table (info),
@


1.83
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.82
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d2882 1
a2882 1
static bfd_boolean
d2897 1
a2897 1
  return TRUE;
@


1.81
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d1728 3
a1730 7
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
a1731 8

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
d2702 2
a2703 1
		  const char *name;
d2705 1
a2705 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a2706 21

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
@


1.80
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
a2197 2
	  else if (isymp->st_shndx > 0 && isymp->st_shndx < SHN_LORESERVE)
	    isec = bfd_section_from_elf_index (input_bfd, isymp->st_shndx);
d2203 1
a2203 4
	    {
	      /* Who knows?  */
	      isec = NULL;
	    }
@


1.79
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d2422 1
a2422 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a2439 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf64_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.78
log
@Switch sources over to use the GPL version 3
@
text
@d2511 3
a2513 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.77
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.76
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2319 3
@


1.75
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a3326 1
  unsigned int power_of_two;
d3466 1
a3466 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.74
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.73
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d1395 16
d4079 2
@


1.72
log
@2076-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-cris.c (INCLUDED_TARGET_FILE): Removed.
	(elf32_bed): Defined for elf32-us-cris.

	* elf64-sh64.c (elf64_bed): Defined for Linux.
	(INCLUDED_TARGET_FILE): Removed.

	* elfxx-target.h (elfNN_bed): Always define. Don't check
	INCLUDED_TARGET_FILE.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
a1489 1
      /* This is a final link.  */
d1493 1
d1512 4
a1515 1
	  if (info->relocatable)
a1520 1
	      sym = local_syms + r_symndx;
a1558 6
	  /* Section symbols are never (?) placed in the hash table, so
	     we can just ignore hash relocations when creating a
	     relocatable object file.  */
	  if (info->relocatable)
	    continue;

d1618 11
a1628 2
		relocation = 0;
	      else if (sec->output_section == NULL)
a1636 1
		  relocation = 0;
a1637 9
	      else
		relocation = ((h->root.u.def.value
			       + sec->output_section->vma
			       + sec->output_offset)
			      /* A STO_SH5_ISA32 causes a "bitor 1" to the
				 symbol value, unless we've seen
				 STT_DATALABEL on the way to it.  */
			      | ((h->other & STO_SH5_ISA32) != 0
				 && ! seen_stt_datalabel));
d1640 1
a1640 1
	    relocation = 0;
d1643 2
a1644 2
	    relocation = 0;
	  else
a1651 1
	      relocation = 0;
d1655 14
@


1.71
log
@	* elf32-sh64.c (sh64_elf_merge_symbol_attribute): Do merging
	only when the non visibility part of st_other is non-zero.
	* elf64-sh64.c (sh64_elf64_merge_symbol_attribute): Likewise.
@
text
@d4139 2
a4141 1
#define	INCLUDED_TARGET_FILE
@


1.70
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d4023 1
a4023 1
				   bfd_boolean dynamic)
d4025 1
a4025 1
  if (isym->st_other != 0 && dynamic)
@


1.69
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d4097 2
@


1.68
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2369 1
a2369 1
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
d2375 6
a2380 27
    {
      switch (ELF64_R_TYPE (rel->r_info))
	{
	case R_SH_GNU_VTINHERIT:
	case R_SH_GNU_VTENTRY:
	  break;

	default:
	  while (h->root.type == bfd_link_hash_indirect
		 && h->root.u.i.link)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d2382 1
a2382 13
  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
sh_elf64_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* No got and plt entries for 64-bit SH at present.  */
  return TRUE;
a4071 1
#define elf_backend_gc_sweep_hook       sh_elf64_gc_sweep_hook
@


1.67
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1712 1
a1712 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d2734 1
a2734 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d3594 1
a3594 1
      else if (strncmp (name, ".rela", 5) == 0)
d3627 1
a3627 1
      else if (strncmp (name, ".got", 4) != 0
d4073 2
a4074 2
  { ".cranges", 8, 0, SHT_PROGBITS, 0 },
  { NULL,       0, 0, 0,            0 }
@


1.66
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
d3141 3
a3143 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       sh64_elf64_link_hash_newfunc))
@


1.65
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3892 1
a3892 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.64
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d3243 1
@


1.63
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1626 6
a1631 3
		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
		     bfd_get_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
@


1.62
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d3437 7
@


1.61
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a3568 1
      bfd_boolean strip;
a3576 2
      strip = FALSE;

d3579 2
a3580 11
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
		 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
d3584 1
a3584 14
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
d3615 2
a3616 1
      else if (strncmp (name, ".got", 4) != 0)
d3622 1
a3622 1
      if (strip)
d3624 9
d3637 3
d3642 1
a3642 1
      if (s->contents == NULL && s->size != 0)
@


1.60
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a4076 18
static const struct bfd_elf_special_section *
sh64_elf64_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					sh64_elf64_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d4135 1
a4135 1
#define elf_backend_get_sec_type_attr	sh64_elf64_get_sec_type_attr
@


1.59
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d4071 1
a4071 1
static struct bfd_elf_special_section const sh64_elf64_special_sections[]=
d4080 1
a4080 1
  const struct bfd_elf_special_section const *ssect;
@


1.58
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d4071 1
a4071 2
static struct bfd_elf_special_section const
  sh64_special_sections_c[] =
d4074 1
a4074 1
  { NULL,        0, 0, 0,            0 }
d4077 2
a4078 2
static struct bfd_elf_special_section const *
  sh64_elf64_special_sections[27]=
d4080 14
a4093 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  sh64_special_sections_c,	/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  NULL,				/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d4153 1
a4153 1
#define elf_backend_special_sections	sh64_elf64_special_sections
@


1.57
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d2459 6
a2464 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.56
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d4066 2
a4067 1
static struct bfd_elf_special_section const sh64_elf64_special_sections[]=
d4070 33
a4102 1
  { NULL,       0, 0, 0,            0 }
@


1.55
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2533 8
a2540 1
		  srelgot = bfd_make_section (dynobj, ".rela.got");
a2541 7
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
a2734 1
		      sreloc = bfd_make_section (dynobj, name);
d2739 3
a2742 1
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
d3215 1
a3215 1
  s = bfd_make_section (abfd, ".plt");
a3216 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d3241 3
a3243 2
  s = bfd_make_section (abfd,
			bed->default_use_rela_p ? ".rela.plt" : ".rel.plt");
a3244 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3267 2
a3268 1
	s = bfd_make_section (abfd, relname);
a3269 1
	    || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3283 3
a3285 3
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
d3301 4
a3304 3
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
a3305 1
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
@


1.54
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.53
log
@Update the FSF address in the copyright/GPL notice
@
text
@d3643 1
a3643 1
	  _bfd_strip_section_from_output (info, s);
@


1.52
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.51
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
a110 6
static bfd_boolean sh_elf64_copy_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf64_copy_private_data_internal
  (bfd *, bfd *);
static bfd_boolean sh_elf64_merge_private_data
  (bfd *, bfd *);
a114 54
static reloc_howto_type *sh_elf64_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void sh_elf64_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean sh_elf64_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
static bfd_byte *sh_elf64_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
static bfd_boolean sh_elf64_set_mach_from_flags
  (bfd *);
static bfd_boolean sh_elf64_set_private_flags
  (bfd *, flagword);
static asection *sh_elf64_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean sh_elf64_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static bfd_boolean sh_elf64_check_relocs
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static int sh64_elf64_get_symbol_type
  (Elf_Internal_Sym *, int);
static bfd_boolean sh64_elf64_add_symbol_hook
  (bfd *, struct bfd_link_info *, Elf_Internal_Sym *, const char **,
   flagword *, asection **, bfd_vma *);
static bfd_boolean sh64_elf64_link_output_symbol_hook
  (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
static bfd_boolean sh64_elf64_fake_sections
  (bfd *, Elf_Internal_Shdr *, asection *);
static void sh64_elf64_final_write_processing
  (bfd *, bfd_boolean);
static struct bfd_hash_entry *sh64_elf64_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static struct bfd_link_hash_table *sh64_elf64_link_hash_table_create
  (bfd *);
inline static void movi_shori_putval
  (bfd *, unsigned long, char *);
inline static void movi_3shori_putval
  (bfd *, bfd_vma, char *);
static bfd_boolean sh64_elf64_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh64_elf64_adjust_dynamic_symbol
  (struct bfd_link_info *info, struct elf_link_hash_entry *);
static bfd_boolean sh64_elf64_discard_copies
  (struct elf_sh64_link_hash_entry *, void *);
static bfd_boolean sh64_elf64_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh64_elf64_finish_dynamic_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
static bfd_boolean sh64_elf64_finish_dynamic_sections
  (bfd *, struct bfd_link_info *);
d2215 1
a2215 1
bfd_boolean
d3143 1
a3143 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
d3156 1
a3156 1
movi_3shori_putval (bfd *output_bfd, bfd_vma value, char *addr)
@


1.50
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d2133 1
a2133 1
		  name = h->root.root.string;
d2144 3
a2146 2
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
@


1.49
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d3391 1
a3391 1
		  || h->weakdef != NULL
d3466 1
a3466 1
  if (h->weakdef != NULL)
d3468 4
a3471 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.48
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1656 1
a1656 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1664 1
a1664 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1680 1
a1680 2
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
d1747 1
a1747 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1806 1
a1806 2
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) != 0))
d1904 1
a1904 1
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2718 1
a2718 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2742 1
a2742 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d2749 1
a2749 1
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d2768 1
a2768 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d2932 1
a2932 1
	  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
d3291 1
a3291 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
d3390 1
a3390 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d3392 3
a3394 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d3400 1
a3400 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d3403 2
a3404 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
d3411 1
a3411 1
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
d3436 1
a3436 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3487 1
a3487 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d3514 1
a3514 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d3558 1
a3558 1
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3866 1
a3866 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3899 1
a3899 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3918 1
a3918 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.47
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1596 2
a1597 3
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
@


1.46
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2194 1
a2194 1
	  input_section->_raw_size);
d2622 1
a2622 1
		  hsh->datalabel_got_offset = sgot->_raw_size;
d2631 1
a2631 1
		  h->got.offset = sgot->_raw_size;
d2641 1
a2641 1
	      srelgot->_raw_size += sizeof (Elf64_External_Rela);
d2674 1
a2674 1
				    + r_symndx] = sgot->_raw_size;
d2683 1
a2683 1
		  local_got_offsets[r_symndx] = sgot->_raw_size;
d2691 1
a2691 1
		  srelgot->_raw_size += sizeof (Elf64_External_Rela);
d2695 1
a2695 1
	  sgot->_raw_size += 8;
d2812 1
a2812 1
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);
d3437 2
a3438 2
      if (s->_raw_size == 0)
	s->_raw_size += PLT_ENTRY_SIZE;
d3449 1
a3449 1
	  h->root.u.def.value = s->_raw_size;
d3452 1
a3452 1
      h->plt.offset = s->_raw_size;
d3455 1
a3455 1
      s->_raw_size += elf_sh64_sizeof_plt (info);
d3462 1
a3462 1
      s->_raw_size += 8;
d3468 1
a3468 1
      s->_raw_size += sizeof (Elf64_External_Rela);
d3523 1
a3523 1
      srel->_raw_size += sizeof (Elf64_External_Rela);
d3534 1
a3534 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d3543 1
a3543 1
  h->root.u.def.value = s->_raw_size;
d3546 1
a3546 1
  s->_raw_size += h->size;
d3572 1
a3572 1
    s->section->_raw_size -= s->count * sizeof (Elf64_External_Rela);
d3599 1
a3599 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d3612 1
a3612 1
	s->_raw_size = 0;
d3645 1
a3645 1
	  if (s->_raw_size == 0)
d3659 1
a3659 1
	  if (s->_raw_size == 0)
d3716 2
a3717 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d3986 1
a3986 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d4036 1
a4036 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d4052 1
a4052 6
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
d4060 1
a4060 1
      if (splt && splt->_raw_size > 0)
d4096 1
a4096 1
  if (sgot->_raw_size > 0)
@


1.45
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2565 1
a2565 1
          if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2572 1
a2572 1
          if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2637 1
a2637 1
		  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d2720 1
a2720 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d3302 1
a3302 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
d3428 1
a3428 1
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
@


1.44
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d144 1
a144 1
  (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *, const char **,
d2890 1
a2890 1
			    const Elf_Internal_Sym *sym, const char **namep,
@


1.43
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d3731 1
a3731 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d3737 4
a3740 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d3746 4
a3749 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf64_External_Rela)))
d3755 1
a3755 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
@


1.42
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d1706 2
a1707 3
	  else if (info->shared
		   && !info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE)
d1713 3
a1715 1
		      input_section, rel->r_offset, TRUE)))
@


1.42.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d144 1
a144 1
  (bfd *, struct bfd_link_info *, Elf_Internal_Sym *, const char **,
d1706 3
a1708 2
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1714 1
a1714 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
d2564 1
a2564 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2571 1
a2571 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2636 1
a2636 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2719 1
a2719 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2889 1
a2889 1
			    Elf_Internal_Sym *sym, const char **namep,
d3301 1
a3301 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d3427 1
a3427 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3730 1
a3730 1
	  if (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))
d3736 4
a3739 4
	  if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
d3745 4
a3748 4
	  if (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,
					      sizeof (Elf64_External_Rela)))
d3754 1
a3754 1
	  if (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))
@


1.42.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d144 1
a144 1
  (bfd *, struct bfd_link_info *, Elf_Internal_Sym *, const char **,
d1706 3
a1708 2
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1714 1
a1714 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
d2889 1
a2889 1
			    Elf_Internal_Sym *sym, const char **namep,
d3730 1
a3730 1
	  if (!_bfd_elf_add_dynamic_entry (info, DT_DEBUG, 0))
d3736 4
a3739 4
	  if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
d3745 4
a3748 4
	  if (!_bfd_elf_add_dynamic_entry (info, DT_RELA, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELASZ, 0)
	      || !_bfd_elf_add_dynamic_entry (info, DT_RELAENT,
					      sizeof (Elf64_External_Rela)))
d3754 1
a3754 1
	  if (!_bfd_elf_add_dynamic_entry (info, DT_TEXTREL, 0))
@


1.42.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2565 1
a2565 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d2572 1
a2572 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d2637 1
a2637 1
		  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2720 1
a2720 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3302 1
a3302 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d3428 1
a3428 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
@


1.42.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1596 3
a1598 2
		    (_("%B(%A+0x%lx): %s relocation against SEC_MERGE section"),
		     input_bfd, input_section,
d2194 1
a2194 1
	  input_section->size);
d2622 1
a2622 1
		  hsh->datalabel_got_offset = sgot->size;
d2631 1
a2631 1
		  h->got.offset = sgot->size;
d2641 1
a2641 1
	      srelgot->size += sizeof (Elf64_External_Rela);
d2674 1
a2674 1
				    + r_symndx] = sgot->size;
d2683 1
a2683 1
		  local_got_offsets[r_symndx] = sgot->size;
d2691 1
a2691 1
		  srelgot->size += sizeof (Elf64_External_Rela);
d2695 1
a2695 1
	  sgot->size += 8;
d2812 1
a2812 1
	      sreloc->size += sizeof (Elf64_External_Rela);
d3437 2
a3438 2
      if (s->size == 0)
	s->size += PLT_ENTRY_SIZE;
d3449 1
a3449 1
	  h->root.u.def.value = s->size;
d3452 1
a3452 1
      h->plt.offset = s->size;
d3455 1
a3455 1
      s->size += elf_sh64_sizeof_plt (info);
d3462 1
a3462 1
      s->size += 8;
d3468 1
a3468 1
      s->size += sizeof (Elf64_External_Rela);
d3523 1
a3523 1
      srel->size += sizeof (Elf64_External_Rela);
d3534 2
a3535 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d3544 1
a3544 1
  h->root.u.def.value = s->size;
d3547 1
a3547 1
  s->size += h->size;
d3573 1
a3573 1
    s->section->size -= s->count * sizeof (Elf64_External_Rela);
d3600 1
a3600 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d3613 1
a3613 1
	s->size = 0;
d3646 1
a3646 1
	  if (s->size == 0)
d3660 1
a3660 1
	  if (s->size == 0)
d3717 2
a3718 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d3987 1
a3987 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d4037 4
a4040 1
	      dyn.d_un.d_val = s->size;
d4056 6
a4061 1
		dyn.d_un.d_val -= s->size;
d4069 1
a4069 1
      if (splt && splt->size > 0)
d4105 1
a4105 1
  if (sgot->size > 0)
@


1.42.8.4
log
@Merge from mainline.
@
text
@d1656 2
a1657 1
			  || !h->def_regular))
d1665 2
a1666 1
			  || !h->def_regular)
d1682 2
a1683 1
			  && h->def_dynamic)))
d1750 2
a1751 1
			  || !h->def_regular))))
d1810 2
a1811 1
			  && h->def_regular))
d1909 1
a1909 1
		      && h->def_regular))
d2723 1
a2723 1
	  h->needs_plt = 1;
d2747 1
a2747 1
	  h->needs_plt = 1;
d2754 1
a2754 1
	    h->non_got_ref = 1;
d2773 2
a2774 1
			  || !h->def_regular))))
d2938 1
a2938 1
	  h->non_elf = 0;
d3297 1
a3297 1
      h->def_regular = 1;
d3396 8
a3403 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d3409 1
a3409 1
      || h->needs_plt)
d3412 2
a3413 2
	  && !h->def_dynamic
	  && !h->ref_dynamic)
d3420 1
a3420 1
	  BFD_ASSERT (h->needs_plt);
d3445 1
a3445 1
	  && !h->def_regular)
d3475 1
a3475 1
  if (h->u.weakdef != NULL)
d3477 4
a3480 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d3496 1
a3496 1
  if (!h->non_got_ref)
d3523 1
a3523 1
      h->needs_copy = 1;
d3567 1
a3567 1
  if (!h->root.def_regular)
d3875 1
a3875 1
      if (!h->def_regular)
d3908 1
a3908 1
	  && h->def_regular)
d3927 1
a3927 1
  if (h->needs_copy)
@


1.42.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1706 3
a1708 2
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d1714 1
a1714 3
		      input_section, rel->r_offset,
		      (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		       || ELF_ST_VISIBILITY (h->other)))))
@


1.41
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d147 2
a148 2
  (bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
   asection *);
d2985 1
a2985 2
sh64_elf64_link_output_symbol_hook (bfd *abfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info,
d2988 2
a2989 1
				    asection *input_sec ATTRIBUTE_UNUSED)
@


1.40
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d2895 1
a2895 1
      && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.39
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d1585 1
a1585 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.38
log
@[bfd]
	* elf32-sh.c (sh_elf_relocate_section): Handle R_SH_IMM_*_PCREL
	relocations.
	(sh_elf_check_relocs): Likewise.

	* elf32-sh64.c (elf_backend_merge_symbol_attribute): Define.
	(sh64_elf_merge_symbol_attribute): New.
	* elf64-sh64.c (elf_backend_merge_symbol_attribute): Define.
	(sh64_elf64_merge_symbol_attribute): New.

[ld/testsuite]
	* ld-sh/sh64/rd-sh64.exp: If the test matches *-dso.d, copy
	the output of linker to the file tmpdir/*-dso.so.
	* ld-sh/sh64/stobin-0-dso.d: New.
	* ld-sh/sh64/stobin-1.d: New.
	* ld-sh/sh64/stobin.s: New.
	* ld-sh/sh64/stolib.s: New.
@
text
@a4211 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.37
log
@	* elf64-sh64.c (sh_elf64_relocate_section): Tidy up for the
	renumbering of some relocation numbers.
@
text
@d4121 21
d4187 3
@


1.36
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d1535 4
a1538 2
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC_2)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_3
@


1.35
log
@Better handking for unresolved symbols
@
text
@d4121 2
a4122 4
  { ".cranges",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.34
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d1613 2
d1704 3
a1706 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
@


1.33
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d2920 1
a2920 1
	  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3241 1
a3241 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
@


1.32
log
@	* elf32-sh.c: Convert to C90.  Replace PTR with void *.
	* elf32-sh64-com.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sh64.h: Likewise.
	* elf64-sh64.c: Likewise.
@
text
@d4115 8
d4178 1
@


1.31
log
@Correct spelling of "relocatable".
@
text
@d102 1
a102 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d111 1
a111 1
  PARAMS ((bfd *, bfd *));
d113 1
a113 1
  PARAMS ((bfd *, bfd *));
d115 1
a115 1
  PARAMS ((bfd *, bfd *));
d117 1
a117 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d119 1
a119 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d121 1
a121 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d123 1
a123 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d125 2
a126 2
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d128 2
a129 2
  PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *,
	   bfd_byte *, bfd_boolean, asymbol **));
d131 1
a131 1
  PARAMS ((bfd *));
d133 1
a133 1
  PARAMS ((bfd *, flagword));
d135 2
a136 2
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d138 1
a138 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d140 1
a140 2
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d142 1
a142 1
  PARAMS ((Elf_Internal_Sym *, int));
d144 2
a145 2
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
d147 2
a148 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *));
d150 1
a150 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d152 1
a152 1
  PARAMS ((bfd *, bfd_boolean));
d154 1
a154 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d156 1
a156 1
  PARAMS ((bfd *));
d158 1
a158 1
  PARAMS ((bfd *, unsigned long, char *));
d160 1
a160 1
  PARAMS ((bfd *, bfd_vma, char *));
d162 1
a162 1
  PARAMS ((bfd *, struct bfd_link_info *));
d164 1
a164 1
  PARAMS ((struct bfd_link_info *info, struct elf_link_hash_entry *));
d166 1
a166 1
  PARAMS ((struct elf_sh64_link_hash_entry *, PTR));
d168 1
a168 1
  PARAMS ((bfd *, struct bfd_link_info *));
d170 2
a171 2
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
d173 1
a173 1
  PARAMS ((bfd *, struct bfd_link_info *));
d1301 5
a1305 9
sh_elf64_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
		     output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1318 3
a1320 9
sh_elf64_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1440 2
a1441 3
sh_elf64_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1459 2
a1460 4
sh_elf64_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1480 6
a1485 10
sh_elf64_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d2161 6
a2166 8
sh_elf64_get_relocated_section_contents (output_bfd, link_info, link_order,
					 data, relocatable, symbols)
     bfd *output_bfd;
     struct bfd_link_info *link_info;
     struct bfd_link_order *link_order;
     bfd_byte *data;
     bfd_boolean relocatable;
     asymbol **symbols;
d2209 1
a2209 1
			 (input_bfd, input_section, (PTR) NULL,
d2273 3
a2275 4
sh64_elf64_fake_sections (output_bfd, elf_section_hdr, asect)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *elf_section_hdr;
     asection *asect;
d2285 1
a2285 2
sh_elf64_set_mach_from_flags (abfd)
     bfd *abfd;
d2308 1
a2308 3
sh_elf64_set_private_flags (abfd, flags)
     bfd *    abfd;
     flagword flags;
d2322 1
a2322 3
sh_elf64_copy_private_data_internal (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
d2353 1
a2353 3
sh_elf64_copy_private_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
d2359 1
a2359 3
sh_elf64_merge_private_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2422 5
a2426 6
sh_elf64_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2463 4
a2466 5
sh_elf64_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d2477 2
a2478 5
sh_elf64_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d2851 1
a2851 3
sh64_elf64_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym * elf_sym;
     int type;
d2882 4
a2885 8
sh64_elf64_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d2979 5
a2983 6
sh64_elf64_link_output_symbol_hook (abfd, info, cname, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     const char *cname;
     Elf_Internal_Sym *sym;
     asection *input_sec ATTRIBUTE_UNUSED;
d3004 2
a3005 3
sh64_elf64_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d3149 3
a3151 4
sh64_elf64_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d3181 1
a3181 2
sh64_elf64_link_hash_table_create (abfd)
     bfd *abfd;
d3201 1
a3201 4
movi_shori_putval (output_bfd, value, addr)
     bfd *output_bfd;
     unsigned long value;
     char *addr;
d3214 1
a3214 4
movi_3shori_putval (output_bfd, value, addr)
     bfd *output_bfd;
     bfd_vma value;
     char *addr;
d3237 1
a3237 3
sh64_elf64_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d3379 2
a3380 3
sh64_elf64_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d3553 2
a3554 3
sh64_elf64_discard_copies (h, ignore)
     struct elf_sh64_link_hash_entry *h;
     PTR ignore ATTRIBUTE_UNUSED;
d3574 2
a3575 3
sh64_elf64_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d3615 1
a3615 2
				   sh64_elf64_discard_copies,
				   (PTR) NULL);
d3760 4
a3763 5
sh64_elf64_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3959 2
a3960 3
sh64_elf64_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
@


1.30
log
@	* elf32-sh.c (sh_elf_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewize.
@
text
@d1588 1
a1588 1
	  if (info->relocateable)
d1590 1
a1590 1
	      /* This is a relocateable link.  We don't have to change
d1634 2
a1635 2
	     relocateable object file.  */
	  if (info->relocateable)
d2181 1
a2181 1
					 data, relocateable, symbols)
d2186 1
a2186 1
     bfd_boolean relocateable;
d2198 1
a2198 1
  if (relocateable
d2202 1
a2202 1
						       relocateable,
d2530 1
a2530 1
  if (info->relocateable)
d2935 1
a2935 1
      /* For relocateable links, we register the DataLabel sym in its own
d2939 1
a2939 1
	= info->relocateable || info->emitrelocations
d2983 1
a2983 1
	  || ((info->relocateable || info->emitrelocations)
d2985 1
a2985 1
	  || (! info->relocateable && !info->emitrelocations
d3030 1
a3030 1
  if (info->relocateable || info->emitrelocations)
@


1.29
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d3646 1
a3646 1
      if (! info->shared)
d3780 1
a3780 1
      if (! info->shared)
@


1.28
log
@bfd:
        * archures.c (enum bfd_architecture): Amend comment to refer to SuperH.
        * cpu-sh.c: Likewise.
        * elf32-sh.c: Likewise.
        * reloc.c (bfd_reloc_code_real): Likewise.
        * elf32-sh64-com.c: Change comment to refer to SuperH.
        * elf32-sh64.c: Likewise.
        * elf64-sh64.c: Likewise.
        * bfd-in2.h (enum bfd_architecture): Regenerate.
binutils:
        * readelf.c (get_machine_name) <EM_SH>: Amend return value
        to refer to SuperH.
gas:
        * config/tc-sh.c: Amend comment to refer to SuperH.
        * config/tc-sh.h: Likewise.
        (LISTING_HEADER): Amend to refer to SuperH.
        * config/tc-sh64.c: Change comment to refer to SuperH.
        * config/tc-sh64.h (LISTING_HEADER): Change to refer to SuperH.
        * doc/as.texinfo [SH, GENERIC]: Amend / Change to refer to SuperH.
        * doc/c-sh.texi: Amend to refer to SuperH.
        Add SuperH architecture documentation references.
        * doc/c-sh64.texi: Change to refer to SuperH.
include/elf:
        * common.h (EM_SH): Amend comment to refer to SuperH.
ld/testsuite:
        * ld-sh/sh64/crange3-cmpct.rd (Machine): Change to refer to SuperH.
        * ld-sh/sh64/crange3-media.rd (Machine): Likewise.
@
text
@d2229 1
a2229 1
      internal_relocs = (_bfd_elf64_link_read_relocs
@


1.27
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d1 1
a1 1
/* Renesas SH64-specific support for 64-bit ELF
@


1.27.2.1
log
@Merge from mainline.
@
text
@d1 1
a1 1
/* SuperH SH64-specific support for 64-bit ELF
@


1.27.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2229 1
a2229 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.26
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1 2
a2 2
/* Hitachi SH64-specific support for 64-bit ELF
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.25
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
d102 1
a102 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d110 6
a115 3
static boolean sh_elf64_copy_private_data PARAMS ((bfd *, bfd *));
static boolean sh_elf64_copy_private_data_internal PARAMS ((bfd *, bfd *));
static boolean sh_elf64_merge_private_data PARAMS ((bfd *, bfd *));
d124 1
a124 1
static boolean sh_elf64_relocate_section
d129 5
a133 3
	   bfd_byte *, boolean, asymbol **));
static boolean sh_elf64_set_mach_from_flags PARAMS ((bfd *));
static boolean sh_elf64_set_private_flags PARAMS ((bfd *, flagword));
d137 1
a137 1
static boolean sh_elf64_gc_sweep_hook
d140 1
a140 1
static boolean sh_elf64_check_relocs
d143 3
a145 2
static int sh64_elf64_get_symbol_type PARAMS ((Elf_Internal_Sym *, int));
static boolean sh64_elf64_add_symbol_hook
d148 1
a148 1
static boolean sh64_elf64_link_output_symbol_hook
d151 1
a151 1
static boolean sh64_elf64_fake_sections
d153 2
a154 1
static void sh64_elf64_final_write_processing PARAMS ((bfd *, boolean));
d159 5
a163 3
inline static void movi_shori_putval PARAMS ((bfd *, unsigned long, char *));
inline static void movi_3shori_putval PARAMS ((bfd *, bfd_vma, char *));
static boolean sh64_elf64_create_dynamic_sections
d165 1
a165 1
static boolean sh64_elf64_adjust_dynamic_symbol
d167 1
a167 1
static boolean sh64_elf64_discard_copies
d169 1
a169 1
static boolean sh64_elf64_size_dynamic_sections
d171 1
a171 1
static boolean sh64_elf64_finish_dynamic_symbol
d174 1
a174 1
static boolean sh64_elf64_finish_dynamic_sections
d183 1
a183 1
	 false,			/* pc_relative */
d188 1
a188 1
	 false,			/* partial_inplace */
d191 1
a191 1
	 false),		/* pcrel_offset */
d193 1
a193 1
  /* 32 bit absolute relocation.  Setting partial_inplace to true and
d199 1
a199 1
	 false,			/* pc_relative */
d204 1
a204 1
	 true,			/* partial_inplace */
d207 1
a207 1
	 false),		/* pcrel_offset */
d214 1
a214 1
	 true,			/* pc_relative */
d219 1
a219 1
	 false,			/* partial_inplace */
d222 1
a222 1
	 true),			/* pcrel_offset */
d273 1
a273 1
	 false,			/* pc_relative */
d278 1
a278 1
	 false,			/* partial_inplace */
d281 1
a281 1
	 true),			/* pcrel_offset */
d290 1
a290 1
	 false,			/* pc_relative */
d295 1
a295 1
	 false,			/* partial_inplace */
d298 1
a298 1
	 true),			/* pcrel_offset */
d333 1
a333 1
	 false,			/* pc_relative */
d338 1
a338 1
	 false,			/* partial_inplace */
d341 1
a341 1
	 true),			/* pcrel_offset */
d348 1
a348 1
         false,                 /* pc_relative */
d353 1
a353 1
         false,                 /* partial_inplace */
d356 1
a356 1
         false),                /* pcrel_offset */
d363 1
a363 1
         false,                 /* pc_relative */
d368 1
a368 1
         false,                 /* partial_inplace */
d371 1
a371 1
         false),                /* pcrel_offset */
d392 1
a392 1
	 false,			/* pc_relative */
d397 1
a397 1
	 false,			/* partial_inplace */
d400 1
a400 1
	 false),	       	/* pcrel_offset */
d407 1
a407 1
	 false,			/* pc_relative */
d412 1
a412 1
	 false,			/* partial_inplace */
d415 1
a415 1
	 false),	       	/* pcrel_offset */
d422 1
a422 1
	 false,			/* pc_relative */
d427 1
a427 1
	 false,			/* partial_inplace */
d430 1
a430 1
	 false),	       	/* pcrel_offset */
d437 1
a437 1
	 false,			/* pc_relative */
d442 1
a442 1
	 false,			/* partial_inplace */
d445 1
a445 1
	 false),	       	/* pcrel_offset */
d452 1
a452 1
	 false,			/* pc_relative */
d457 1
a457 1
	 false,			/* partial_inplace */
d460 1
a460 1
	 false),	       	/* pcrel_offset */
d467 1
a467 1
	 false,			/* pc_relative */
d472 1
a472 1
	 false,			/* partial_inplace */
d475 1
a475 1
	 false),	       	/* pcrel_offset */
d482 1
a482 1
	 false,			/* pc_relative */
d487 1
a487 1
	 false,			/* partial_inplace */
d490 1
a490 1
	 false),	       	/* pcrel_offset */
d620 1
a620 1
	 false,			/* pc_relative */
d625 1
a625 1
	 false,			/* partial_inplace */
d628 1
a628 1
	 false),	       	/* pcrel_offset */
d635 1
a635 1
	 false,			/* pc_relative */
d640 1
a640 1
	 false,			/* partial_inplace */
d643 1
a643 1
	 false),	       	/* pcrel_offset */
d650 1
a650 1
	 false,			/* pc_relative */
d655 1
a655 1
	 false,			/* partial_inplace */
d658 1
a658 1
	 false),	       	/* pcrel_offset */
d665 1
a665 1
	 false,			/* pc_relative */
d670 1
a670 1
	 false,			/* partial_inplace */
d673 1
a673 1
	 false),	       	/* pcrel_offset */
d680 1
a680 1
	 false,			/* pc_relative */
d685 1
a685 1
	 false,			/* partial_inplace */
d688 1
a688 1
	 false),	       	/* pcrel_offset */
d695 1
a695 1
	 false,			/* pc_relative */
d700 1
a700 1
	 false,			/* partial_inplace */
d703 1
a703 1
	 false),	       	/* pcrel_offset */
d710 1
a710 1
	 false,			/* pc_relative */
d715 1
a715 1
	 false,			/* partial_inplace */
d718 1
a718 1
	 false),	       	/* pcrel_offset */
d725 1
a725 1
	 false,			/* pc_relative */
d730 1
a730 1
	 false,			/* partial_inplace */
d733 1
a733 1
	 false),	       	/* pcrel_offset */
d740 1
a740 1
	 true,			/* pc_relative */
d745 1
a745 1
	 false,			/* partial_inplace */
d748 1
a748 1
	 true),		       	/* pcrel_offset */
d755 1
a755 1
	 true,			/* pc_relative */
d760 1
a760 1
	 false,			/* partial_inplace */
d763 1
a763 1
	 true),		       	/* pcrel_offset */
d770 1
a770 1
	 true,			/* pc_relative */
d775 1
a775 1
	 false,			/* partial_inplace */
d778 1
a778 1
	 true),		       	/* pcrel_offset */
d785 1
a785 1
	 true,			/* pc_relative */
d790 1
a790 1
	 false,			/* partial_inplace */
d793 1
a793 1
	 true),		       	/* pcrel_offset */
d800 1
a800 1
	 false,			/* pc_relative */
d805 1
a805 1
	 false,			/* partial_inplace */
d808 1
a808 1
	 false),	       	/* pcrel_offset */
d815 1
a815 1
	 false,			/* pc_relative */
d820 1
a820 1
	 false,			/* partial_inplace */
d823 1
a823 1
	 false),	       	/* pcrel_offset */
d830 1
a830 1
	 false,			/* pc_relative */
d835 1
a835 1
	 false,			/* partial_inplace */
d838 1
a838 1
	 false),	       	/* pcrel_offset */
d845 1
a845 1
	 false,			/* pc_relative */
d850 1
a850 1
	 false,			/* partial_inplace */
d853 1
a853 1
	 false),	       	/* pcrel_offset */
d860 1
a860 1
	 true,			/* pc_relative */
d865 1
a865 1
	 false,			/* partial_inplace */
d868 1
a868 1
	 true),		       	/* pcrel_offset */
d875 1
a875 1
	 true,			/* pc_relative */
d880 1
a880 1
	 false,			/* partial_inplace */
d883 1
a883 1
	 true),		       	/* pcrel_offset */
d890 1
a890 1
	 true,			/* pc_relative */
d895 1
a895 1
	 false,			/* partial_inplace */
d898 1
a898 1
	 true),		       	/* pcrel_offset */
d905 1
a905 1
	 true,			/* pc_relative */
d910 1
a910 1
	 false,			/* partial_inplace */
d913 1
a913 1
	 true),		       	/* pcrel_offset */
d920 1
a920 1
	 false,			/* pc_relative */
d925 1
a925 1
	 false,			/* partial_inplace */
d928 1
a928 1
	 false),	       	/* pcrel_offset */
d935 1
a935 1
	 false,			/* pc_relative */
d940 1
a940 1
	 false,			/* partial_inplace */
d943 1
a943 1
	 false),	       	/* pcrel_offset */
d950 1
a950 1
	 false,			/* pc_relative */
d955 1
a955 1
	 false,			/* partial_inplace */
d958 1
a958 1
	 false),	       	/* pcrel_offset */
d965 1
a965 1
	 false,			/* pc_relative */
d970 1
a970 1
	 false,			/* partial_inplace */
d973 1
a973 1
	 false),	       	/* pcrel_offset */
d979 1
a979 1
	 false,			/* pc_relative */
d984 1
a984 1
	 false,			/* partial_inplace */
d987 1
a987 1
	 false),	       	/* pcrel_offset */
d993 1
a993 1
	 false,			/* pc_relative */
d998 1
a998 1
	 false,			/* partial_inplace */
d1001 1
a1001 1
	 false),	       	/* pcrel_offset */
d1007 1
a1007 1
	 false,			/* pc_relative */
d1012 1
a1012 1
	 false,			/* partial_inplace */
d1015 1
a1015 1
	 false),	       	/* pcrel_offset */
d1021 1
a1021 1
	 false,			/* pc_relative */
d1026 1
a1026 1
	 false,			/* partial_inplace */
d1029 1
a1029 1
	 false),	       	/* pcrel_offset */
d1090 1
a1090 1
	 false,			/* pc_relative */
d1095 1
a1095 1
	 false,			/* partial_inplace */
d1098 1
a1098 1
	 false),		/* pcrel_offset */
d1107 1
a1107 1
	 true,			/* pc_relative */
d1112 1
a1112 1
	 false,			/* partial_inplace */
d1115 1
a1115 1
	 true),			/* pcrel_offset */
d1122 1
a1122 1
	 false,			/* pc_relative */
d1127 1
a1127 1
	 false,			/* partial_inplace */
d1130 1
a1130 1
	 false),	       	/* pcrel_offset */
d1137 1
a1137 1
	 false,			/* pc_relative */
d1142 1
a1142 1
	 false,			/* partial_inplace */
d1145 1
a1145 1
	 false),	       	/* pcrel_offset */
d1152 1
a1152 1
	 false,			/* pc_relative */
d1157 1
a1157 1
	 false,			/* partial_inplace */
d1160 1
a1160 1
	 false),	       	/* pcrel_offset */
d1167 1
a1167 1
	 true,			/* pc_relative */
d1172 1
a1172 1
	 false,			/* partial_inplace */
d1175 1
a1175 1
	 true),			/* pcrel_offset */
d1182 1
a1182 1
	 false,			/* pc_relative */
d1187 1
a1187 1
	 false,			/* partial_inplace */
d1190 1
a1190 1
	 false),	       	/* pcrel_offset */
d1197 1
a1197 1
	 true,			/* pc_relative */
d1202 1
a1202 1
	 false,			/* partial_inplace */
d1205 1
a1205 1
	 true),			/* pcrel_offset */
d1212 1
a1212 1
	 false,			/* pc_relative */
d1217 1
a1217 1
	 false,			/* partial_inplace */
d1220 1
a1220 1
	 false),	       	/* pcrel_offset */
d1227 1
a1227 1
	 true,			/* pc_relative */
d1232 1
a1232 1
	 false,			/* partial_inplace */
d1235 1
a1235 1
	 true),			/* pcrel_offset */
d1242 1
a1242 1
	 false,			/* pc_relative */
d1247 1
a1247 1
	 false,			/* partial_inplace */
d1250 1
a1250 1
	 false),	       	/* pcrel_offset */
d1257 1
a1257 1
	 true,			/* pc_relative */
d1262 1
a1262 1
	 false,			/* partial_inplace */
d1265 1
a1265 1
	 true),			/* pcrel_offset */
d1272 1
a1272 1
	 false,			/* pc_relative */
d1277 1
a1277 1
	 false,			/* partial_inplace */
d1280 1
a1280 1
	 false),	       	/* pcrel_offset */
d1287 1
a1287 1
	 true,			/* pc_relative */
d1292 1
a1292 1
	 false,			/* partial_inplace */
d1295 1
a1295 1
	 true),			/* pcrel_offset */
d1494 1
a1494 1
static boolean
d1561 1
a1561 1
	  return false;
d1617 1
a1617 1
		  return false;
d1727 2
a1728 2
		      input_section, rel->r_offset, true)))
		return false;
d1751 1
a1751 1
	  return false;
d1768 1
a1768 1
	      boolean skip, relocate;
d1783 1
a1783 1
		    return false;
d1794 2
a1795 2
	      skip = false;
	      relocate = false;
d1802 1
a1802 1
		skip = true;
d1804 1
a1804 1
		skip = true, relocate = true;
d1826 1
a1826 1
		      relocate = true;
d2135 1
a2135 1
	  return false;
d2157 1
a2157 1
		      return false;
d2164 1
a2164 1
		  return false;
d2171 1
a2171 1
  return true;
d2186 1
a2186 1
     boolean relocateable;
d2231 1
a2231 1
			  (Elf_Internal_Rela *) NULL, false));
d2293 1
a2293 1
boolean
d2303 1
a2303 1
  return true;
d2306 1
a2306 1
static boolean
d2321 1
a2321 1
      return false;
d2323 1
a2323 1
  return true;
d2330 1
a2330 1
static boolean
d2339 1
a2339 1
  elf_flags_init (abfd) = true;
d2346 1
a2346 1
static boolean
d2357 1
a2357 1
    return true;
d2379 1
a2379 1
static boolean
d2387 1
a2387 1
static boolean
d2395 1
a2395 1
    return false;
d2399 1
a2399 1
    return true;
d2417 1
a2417 1
      return false;
d2425 1
a2425 1
      elf_flags_init (obfd) = true;
d2437 1
a2437 1
      return false;
d2494 1
a2494 1
static boolean
d2502 1
a2502 1
  return true;
d2509 1
a2509 1
static boolean
d2531 1
a2531 1
    return true;
d2581 1
a2581 1
		return false;
d2595 1
a2595 1
            return false;
d2602 1
a2602 1
            return false;
d2636 1
a2636 1
		    return false;
d2667 1
a2667 1
		    return false;
d2687 1
a2687 1
		    return false;
d2750 1
a2750 1
		return false;
d2818 1
a2818 1
		    return false;
d2837 1
a2837 1
			return false;
d2868 1
a2868 1
			return false;
d2883 1
a2883 1
  return true;
d2919 1
a2919 1
static boolean
d2950 1
a2950 1
	return false;
d2956 1
a2956 1
	bfd_link_hash_lookup (info->hash, dl_name, false, false, false);
d2966 1
a2966 1
						  *namep, false,
d2970 1
a2970 1
	      return false;
d2993 1
a2993 1
	  return false;
d3005 1
a3005 1
  return true;
d3020 1
a3020 1
static boolean
d3036 1
a3036 1
  return true;
d3049 1
a3049 1
     boolean linker ATTRIBUTE_UNUSED;
d3288 1
a3288 1
static boolean
d3310 1
a3310 1
      return false;
d3330 1
a3330 1
    return false;
d3341 2
a3342 2
	      (bfd_vma) 0, (const char *) NULL, false, bed->collect, &bh)))
	return false;
d3350 1
a3350 1
	return false;
d3358 1
a3358 1
    return false;
d3361 1
a3361 1
    return false;
d3383 1
a3383 1
	  return false;
d3398 1
a3398 1
	return false;
d3419 1
a3419 1
	    return false;
d3423 1
a3423 1
  return true;
d3432 1
a3432 1
static boolean
d3470 1
a3470 1
	  return true;
d3477 1
a3477 1
	    return false;
d3518 1
a3518 1
      return true;
d3530 1
a3530 1
      return true;
d3541 1
a3541 1
    return true;
d3546 1
a3546 1
    return true;
d3587 1
a3587 1
	return false;
d3597 1
a3597 1
  return true;
d3607 1
a3607 1
static boolean
d3619 1
a3619 1
    return true;
d3624 1
a3624 1
  return true;
d3629 1
a3629 1
static boolean
d3636 3
a3638 3
  boolean plt;
  boolean relocs;
  boolean reltext;
d3678 3
a3680 3
  plt = false;
  relocs = false;
  reltext = false;
d3684 1
a3684 1
      boolean strip;
d3693 1
a3693 1
      strip = false;
d3701 1
a3701 1
	      strip = true;
d3706 1
a3706 1
	      plt = true;
d3722 1
a3722 1
	      strip = true;
d3734 1
a3734 1
		  relocs = true;
d3747 1
a3747 1
		    reltext = true;
d3770 1
a3770 1
	return false;
d3783 1
a3783 1
	    return false;
d3792 1
a3792 1
	    return false;
d3801 1
a3801 1
	    return false;
d3807 1
a3807 1
	    return false;
d3811 1
a3811 1
  return true;
d3817 1
a3817 1
static boolean
d4012 1
a4012 1
  return true;
d4017 1
a4017 1
static boolean
d4065 1
a4065 1
					    false, false, true);
d4172 1
a4172 1
  return true;
@


1.24
log
@	* elf32-sh.c (sh_elf_relocate_section): Don't complain about
        unresolved debugging relocs in dynamic applications.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* ld-sh/refdbg-0-dso.d: New test.
	* ld-sh/refdbg-1.d: Likewise.
	* ld-sh/refdbg.s: Likewise.
	* ld-sh/refdbglib.s: Likewise.
@
text
@d1758 1
d1829 3
a1831 5
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					 (((Elf64_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d1980 1
a1980 1
		      asection *srelgot;
d1982 1
d1984 2
a1985 2
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);
d1992 3
a1994 5
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						(((Elf64_External_Rela *)
						  srelgot->contents)
						 + srelgot->reloc_count));
		      ++srelgot->reloc_count;
d3828 1
d3917 2
a3918 3
      bfd_elf64_swap_reloca_out (output_bfd, &rel,
				((Elf64_External_Rela *) srel->contents
				 + plt_index));
d3933 1
d3967 3
a3969 4
      bfd_elf64_swap_reloca_out (output_bfd, &rel,
				 ((Elf64_External_Rela *) srel->contents
				  + srel->reloc_count));
      ++srel->reloc_count;
d3976 1
d3993 3
a3995 4
      bfd_elf64_swap_reloca_out (output_bfd, &rel,
				 ((Elf64_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
@


1.23
log
@Add some string section merging support.
	* elf64-sh64.c (sh_elf64_relocate_section): Call
	_bfd_elf_rela_local_sym.  Handle relocs against STT_SECTION symbol
	of SHF_MERGE section.
@
text
@d1683 8
a1690 1
			  || (input_section->flags & SEC_DEBUGGING) != 0)))
@


1.22
log
@	* Makefile.am (BFD32_BACKENDS): Remove elfarmqnx-nabi.lo,
	elf32-i386-fbsd.lo, elf32-i386qnx.lo, elf32-ppcqnx.lo,
	elf32-sh-lin.lo, elf32-sh64-lin.lo, elf32-sh-nbsd.lo,
	elf32-sh64-nbsd.lo, elf32-shqnx.lo.  Add elf32-qnx.lo.
	(BFD32_BACKENDS_CFILES): Likewise for corresponding C files.
	(BFD64_BACKENDS): Remove elf64-sh64-lin.lo, elf64-sh64-nbsd.lo.
	(BFD64_BACKENDS_CFILES): Likewise for corresponding C files.
	(SOURCE_HFILES): Add elf32-qnx.h.
	(BUILD_HFILES): Add bfdver.h.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in Update bfd vector dependencies.
	* configure: Regenerate.
	* elf32-i386-fbsd.c: Delete.  Move code to elf32-i386.c.
	* elf32-i386qnx.c: Likewise.
	* elf32-ppcqnx.c: Delete.  Move code to elf32-ppc.c.
	* elf32-sh-nbsd.c: Delete.  Move code to elf32-sh.c.
	* elf32-sh-lin.c: Likewise.
	* elf32-shqnx.c: Likewise.
	* elf32-sh64-lin.c: Delete.  Move code to elf32-sh64.c.
	* elf32-sh64-nbsd.c: Likewise.
	* elf64-sh64-lin.c: Delete.  Move code to elf64-sh64.c.
	* elf64-sh64-nbsd.c: Likewise.
	* elfarmqnx-nabi.c: Delete.  Move code to elfarm-nabi.c.
	* elf32-arm.h (ELF_MAXPAGESIZE): Always define.
	* elf32-i386.c: Remove ELF_ARCH and ELF32_I386_C_INCLUDED tests.
	* elf32-ppc.c: Remove ELF32_PPC_C_INCLUDED tests.
	* elf32-qnx.h (elf_backend_set_nonloadable_filepos): Always define.
	(elf_backend_is_contained_by_filepos): Likewise.
	(elf_backend_copy_private_bfd_data_p): Likewise.
	Globalize and move functions to..
	* elf32-qnx.c: ..here.  New file.
	* elf32-sh.c: Remove ELF_ARCH and ELF32_SH_C_INCLUDED tests.  Don't
	emit target vectors when INCLUDE_SHMEDIA.
	* elf32-sh64.c: Remove ELF_ARCH test.  Move TARGET_* etc. defines to
	end of file.
	* elf64-sh64.c: Remove ELF_ARCH test.
	* elfarm-nabi.c: Remove ELFARM_NABI_C_INCLUDED test.
	* po/BLD-POTFILES.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d1591 29
@


1.21
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a4131 2

#ifndef ELF_ARCH
a4140 1
#endif /* ELF_ARCH */
d4194 31
@


1.20
log
@* elf32-sh.c (elf_sh_pic_plt_entry_be, elf_sh_pic_plt_entry_le):
Correct mistake in calculation of address of .got.
* elf64-sh64.c (elf_sh64_pic_plt_entry_be,
elf_sh64_pic_plt_entry_le): Likewise.
@
text
@d2918 3
d2924 1
a2924 2
						  get_elf_backend_data (abfd)->collect,
						  (struct bfd_link_hash_entry **) &h))
d2930 1
d3293 3
a3295 1
      struct elf_link_hash_entry *h = NULL;
d3298 1
a3298 3
	      (bfd_vma) 0, (const char *) NULL, false,
	      get_elf_backend_data (abfd)->collect,
	      (struct bfd_link_hash_entry **) &h)))
d3300 2
@


1.19
log
@	* elf32-sh.c (elf_sh_plt0_entry_be, elf_sh_plt0_entry_le): Copy
	contents of .got.plt[2] to tr0, not address of .got.plt.
	(sh_elf_finish_dynamic_symbol): Do not apply GOT_BIAS when
	patching absolute plt entry. For shmedia plt entry, set bottom bit
	of branch to plt0 as this is a branch to an shmedia instruction.
	* elf64-sh64.c (elf_sh64_plt0_entry_be, elf_sh64_plt0_entry_le):
	Copy contents of .got.plt[2] to tr0, not address of .got.plt.
	(elf_sh64_plt_entry_be, elf_sh64_plt_entry_le): Use ptrel to
	branch to plt0.
	(sh64_elf64_finish_dynamic_symbol): Do not apply GOT_BIAS when
	patching absolute plt entry. For shmedia plt entry, branch to
	plt0 is now ptrel, so use relative offset.  Set bottom bit of
	branch target as it is a branch to an shmedia instruction.
@
text
@d3111 1
a3111 1
  0x00, 0xcb, 0x45, 0x10, /* sub   r12, r17, r17 */
d3131 1
a3131 1
  0x10, 0x45, 0xcb, 0x00, /* sub   r12, r17, r17 */
@


1.19.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a2917 3
	  struct bfd_link_hash_entry *bh = NULL;
	  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d2921 2
a2922 1
						  bed->collect, &bh))
a2927 1
	  h = (struct elf_link_hash_entry *) bh;
d3111 1
a3111 1
  0x00, 0xc9, 0x45, 0x10, /* add   r12, r17, r17 */
d3131 1
a3131 1
  0x10, 0x45, 0xc9, 0x00, /* add   r12, r17, r17 */
d3290 1
a3290 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3293 3
a3295 1
	      (bfd_vma) 0, (const char *) NULL, false, bed->collect, &bh)))
a3296 2

      h = (struct elf_link_hash_entry *) bh;
d4127 2
d4138 1
a4191 31
#include "elf64-target.h"

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64nbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64l-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf64_bed			elf64_sh64_nbsd_bed

#include "elf64-target.h"

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64blin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64big-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64-linux"

#define	INCLUDED_TARGET_FILE
@


1.19.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 2
/* SuperH SH64-specific support for 64-bit ELF
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d102 1
a102 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
d110 3
a112 6
static bfd_boolean sh_elf64_copy_private_data
  (bfd *, bfd *);
static bfd_boolean sh_elf64_copy_private_data_internal
  (bfd *, bfd *);
static bfd_boolean sh_elf64_merge_private_data
  (bfd *, bfd *);
d114 1
a114 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d116 1
a116 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d118 1
a118 1
  (bfd *, bfd_reloc_code_real_type);
d120 4
a123 4
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean sh_elf64_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d125 4
a128 6
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
static bfd_boolean sh_elf64_set_mach_from_flags
  (bfd *);
static bfd_boolean sh_elf64_set_private_flags
  (bfd *, flagword);
d130 18
a147 18
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
static bfd_boolean sh_elf64_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static bfd_boolean sh_elf64_check_relocs
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static int sh64_elf64_get_symbol_type
  (Elf_Internal_Sym *, int);
static bfd_boolean sh64_elf64_add_symbol_hook
  (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *, const char **,
   flagword *, asection **, bfd_vma *);
static bfd_boolean sh64_elf64_link_output_symbol_hook
  (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
static bfd_boolean sh64_elf64_fake_sections
  (bfd *, Elf_Internal_Shdr *, asection *);
static void sh64_elf64_final_write_processing
  (bfd *, bfd_boolean);
d149 1
a149 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d151 16
a166 18
  (bfd *);
inline static void movi_shori_putval
  (bfd *, unsigned long, char *);
inline static void movi_3shori_putval
  (bfd *, bfd_vma, char *);
static bfd_boolean sh64_elf64_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh64_elf64_adjust_dynamic_symbol
  (struct bfd_link_info *info, struct elf_link_hash_entry *);
static bfd_boolean sh64_elf64_discard_copies
  (struct elf_sh64_link_hash_entry *, void *);
static bfd_boolean sh64_elf64_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
static bfd_boolean sh64_elf64_finish_dynamic_symbol
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
static bfd_boolean sh64_elf64_finish_dynamic_sections
  (bfd *, struct bfd_link_info *);
d174 1
a174 1
	 FALSE,			/* pc_relative */
d179 1
a179 1
	 FALSE,			/* partial_inplace */
d182 1
a182 1
	 FALSE),		/* pcrel_offset */
d184 1
a184 1
  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
d190 1
a190 1
	 FALSE,			/* pc_relative */
d195 1
a195 1
	 TRUE,			/* partial_inplace */
d198 1
a198 1
	 FALSE),		/* pcrel_offset */
d205 1
a205 1
	 TRUE,			/* pc_relative */
d210 1
a210 1
	 FALSE,			/* partial_inplace */
d213 1
a213 1
	 TRUE),			/* pcrel_offset */
d264 1
a264 1
	 FALSE,			/* pc_relative */
d269 1
a269 1
	 FALSE,			/* partial_inplace */
d272 1
a272 1
	 TRUE),			/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d286 1
a286 1
	 FALSE,			/* partial_inplace */
d289 1
a289 1
	 TRUE),			/* pcrel_offset */
d324 1
a324 1
	 FALSE,			/* pc_relative */
d329 1
a329 1
	 FALSE,			/* partial_inplace */
d332 1
a332 1
	 TRUE),			/* pcrel_offset */
d339 1
a339 1
         FALSE,                 /* pc_relative */
d344 1
a344 1
         FALSE,                 /* partial_inplace */
d347 1
a347 1
         FALSE),                /* pcrel_offset */
d354 1
a354 1
         FALSE,                 /* pc_relative */
d359 1
a359 1
         FALSE,                 /* partial_inplace */
d362 1
a362 1
         FALSE),                /* pcrel_offset */
d383 1
a383 1
	 FALSE,			/* pc_relative */
d388 1
a388 1
	 FALSE,			/* partial_inplace */
d391 1
a391 1
	 FALSE),	       	/* pcrel_offset */
d398 1
a398 1
	 FALSE,			/* pc_relative */
d403 1
a403 1
	 FALSE,			/* partial_inplace */
d406 1
a406 1
	 FALSE),	       	/* pcrel_offset */
d413 1
a413 1
	 FALSE,			/* pc_relative */
d418 1
a418 1
	 FALSE,			/* partial_inplace */
d421 1
a421 1
	 FALSE),	       	/* pcrel_offset */
d428 1
a428 1
	 FALSE,			/* pc_relative */
d433 1
a433 1
	 FALSE,			/* partial_inplace */
d436 1
a436 1
	 FALSE),	       	/* pcrel_offset */
d443 1
a443 1
	 FALSE,			/* pc_relative */
d448 1
a448 1
	 FALSE,			/* partial_inplace */
d451 1
a451 1
	 FALSE),	       	/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),	       	/* pcrel_offset */
d473 1
a473 1
	 FALSE,			/* pc_relative */
d478 1
a478 1
	 FALSE,			/* partial_inplace */
d481 1
a481 1
	 FALSE),	       	/* pcrel_offset */
d611 1
a611 1
	 FALSE,			/* pc_relative */
d616 1
a616 1
	 FALSE,			/* partial_inplace */
d619 1
a619 1
	 FALSE),	       	/* pcrel_offset */
d626 1
a626 1
	 FALSE,			/* pc_relative */
d631 1
a631 1
	 FALSE,			/* partial_inplace */
d634 1
a634 1
	 FALSE),	       	/* pcrel_offset */
d641 1
a641 1
	 FALSE,			/* pc_relative */
d646 1
a646 1
	 FALSE,			/* partial_inplace */
d649 1
a649 1
	 FALSE),	       	/* pcrel_offset */
d656 1
a656 1
	 FALSE,			/* pc_relative */
d661 1
a661 1
	 FALSE,			/* partial_inplace */
d664 1
a664 1
	 FALSE),	       	/* pcrel_offset */
d671 1
a671 1
	 FALSE,			/* pc_relative */
d676 1
a676 1
	 FALSE,			/* partial_inplace */
d679 1
a679 1
	 FALSE),	       	/* pcrel_offset */
d686 1
a686 1
	 FALSE,			/* pc_relative */
d691 1
a691 1
	 FALSE,			/* partial_inplace */
d694 1
a694 1
	 FALSE),	       	/* pcrel_offset */
d701 1
a701 1
	 FALSE,			/* pc_relative */
d706 1
a706 1
	 FALSE,			/* partial_inplace */
d709 1
a709 1
	 FALSE),	       	/* pcrel_offset */
d716 1
a716 1
	 FALSE,			/* pc_relative */
d721 1
a721 1
	 FALSE,			/* partial_inplace */
d724 1
a724 1
	 FALSE),	       	/* pcrel_offset */
d731 1
a731 1
	 TRUE,			/* pc_relative */
d736 1
a736 1
	 FALSE,			/* partial_inplace */
d739 1
a739 1
	 TRUE),		       	/* pcrel_offset */
d746 1
a746 1
	 TRUE,			/* pc_relative */
d751 1
a751 1
	 FALSE,			/* partial_inplace */
d754 1
a754 1
	 TRUE),		       	/* pcrel_offset */
d761 1
a761 1
	 TRUE,			/* pc_relative */
d766 1
a766 1
	 FALSE,			/* partial_inplace */
d769 1
a769 1
	 TRUE),		       	/* pcrel_offset */
d776 1
a776 1
	 TRUE,			/* pc_relative */
d781 1
a781 1
	 FALSE,			/* partial_inplace */
d784 1
a784 1
	 TRUE),		       	/* pcrel_offset */
d791 1
a791 1
	 FALSE,			/* pc_relative */
d796 1
a796 1
	 FALSE,			/* partial_inplace */
d799 1
a799 1
	 FALSE),	       	/* pcrel_offset */
d806 1
a806 1
	 FALSE,			/* pc_relative */
d811 1
a811 1
	 FALSE,			/* partial_inplace */
d814 1
a814 1
	 FALSE),	       	/* pcrel_offset */
d821 1
a821 1
	 FALSE,			/* pc_relative */
d826 1
a826 1
	 FALSE,			/* partial_inplace */
d829 1
a829 1
	 FALSE),	       	/* pcrel_offset */
d836 1
a836 1
	 FALSE,			/* pc_relative */
d841 1
a841 1
	 FALSE,			/* partial_inplace */
d844 1
a844 1
	 FALSE),	       	/* pcrel_offset */
d851 1
a851 1
	 TRUE,			/* pc_relative */
d856 1
a856 1
	 FALSE,			/* partial_inplace */
d859 1
a859 1
	 TRUE),		       	/* pcrel_offset */
d866 1
a866 1
	 TRUE,			/* pc_relative */
d871 1
a871 1
	 FALSE,			/* partial_inplace */
d874 1
a874 1
	 TRUE),		       	/* pcrel_offset */
d881 1
a881 1
	 TRUE,			/* pc_relative */
d886 1
a886 1
	 FALSE,			/* partial_inplace */
d889 1
a889 1
	 TRUE),		       	/* pcrel_offset */
d896 1
a896 1
	 TRUE,			/* pc_relative */
d901 1
a901 1
	 FALSE,			/* partial_inplace */
d904 1
a904 1
	 TRUE),		       	/* pcrel_offset */
d911 1
a911 1
	 FALSE,			/* pc_relative */
d916 1
a916 1
	 FALSE,			/* partial_inplace */
d919 1
a919 1
	 FALSE),	       	/* pcrel_offset */
d926 1
a926 1
	 FALSE,			/* pc_relative */
d931 1
a931 1
	 FALSE,			/* partial_inplace */
d934 1
a934 1
	 FALSE),	       	/* pcrel_offset */
d941 1
a941 1
	 FALSE,			/* pc_relative */
d946 1
a946 1
	 FALSE,			/* partial_inplace */
d949 1
a949 1
	 FALSE),	       	/* pcrel_offset */
d956 1
a956 1
	 FALSE,			/* pc_relative */
d961 1
a961 1
	 FALSE,			/* partial_inplace */
d964 1
a964 1
	 FALSE),	       	/* pcrel_offset */
d970 1
a970 1
	 FALSE,			/* pc_relative */
d975 1
a975 1
	 FALSE,			/* partial_inplace */
d978 1
a978 1
	 FALSE),	       	/* pcrel_offset */
d984 1
a984 1
	 FALSE,			/* pc_relative */
d989 1
a989 1
	 FALSE,			/* partial_inplace */
d992 1
a992 1
	 FALSE),	       	/* pcrel_offset */
d998 1
a998 1
	 FALSE,			/* pc_relative */
d1003 1
a1003 1
	 FALSE,			/* partial_inplace */
d1006 1
a1006 1
	 FALSE),	       	/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),	       	/* pcrel_offset */
d1081 1
a1081 1
	 FALSE,			/* pc_relative */
d1086 1
a1086 1
	 FALSE,			/* partial_inplace */
d1089 1
a1089 1
	 FALSE),		/* pcrel_offset */
d1098 1
a1098 1
	 TRUE,			/* pc_relative */
d1103 1
a1103 1
	 FALSE,			/* partial_inplace */
d1106 1
a1106 1
	 TRUE),			/* pcrel_offset */
d1113 1
a1113 1
	 FALSE,			/* pc_relative */
d1118 1
a1118 1
	 FALSE,			/* partial_inplace */
d1121 1
a1121 1
	 FALSE),	       	/* pcrel_offset */
d1128 1
a1128 1
	 FALSE,			/* pc_relative */
d1133 1
a1133 1
	 FALSE,			/* partial_inplace */
d1136 1
a1136 1
	 FALSE),	       	/* pcrel_offset */
d1143 1
a1143 1
	 FALSE,			/* pc_relative */
d1148 1
a1148 1
	 FALSE,			/* partial_inplace */
d1151 1
a1151 1
	 FALSE),	       	/* pcrel_offset */
d1158 1
a1158 1
	 TRUE,			/* pc_relative */
d1163 1
a1163 1
	 FALSE,			/* partial_inplace */
d1166 1
a1166 1
	 TRUE),			/* pcrel_offset */
d1173 1
a1173 1
	 FALSE,			/* pc_relative */
d1178 1
a1178 1
	 FALSE,			/* partial_inplace */
d1181 1
a1181 1
	 FALSE),	       	/* pcrel_offset */
d1188 1
a1188 1
	 TRUE,			/* pc_relative */
d1193 1
a1193 1
	 FALSE,			/* partial_inplace */
d1196 1
a1196 1
	 TRUE),			/* pcrel_offset */
d1203 1
a1203 1
	 FALSE,			/* pc_relative */
d1208 1
a1208 1
	 FALSE,			/* partial_inplace */
d1211 1
a1211 1
	 FALSE),	       	/* pcrel_offset */
d1218 1
a1218 1
	 TRUE,			/* pc_relative */
d1223 1
a1223 1
	 FALSE,			/* partial_inplace */
d1226 1
a1226 1
	 TRUE),			/* pcrel_offset */
d1233 1
a1233 1
	 FALSE,			/* pc_relative */
d1238 1
a1238 1
	 FALSE,			/* partial_inplace */
d1241 1
a1241 1
	 FALSE),	       	/* pcrel_offset */
d1248 1
a1248 1
	 TRUE,			/* pc_relative */
d1253 1
a1253 1
	 FALSE,			/* partial_inplace */
d1256 1
a1256 1
	 TRUE),			/* pcrel_offset */
d1263 1
a1263 1
	 FALSE,			/* pc_relative */
d1268 1
a1268 1
	 FALSE,			/* partial_inplace */
d1271 1
a1271 1
	 FALSE),	       	/* pcrel_offset */
d1278 1
a1278 1
	 TRUE,			/* pc_relative */
d1283 1
a1283 1
	 FALSE,			/* partial_inplace */
d1286 1
a1286 1
	 TRUE),			/* pcrel_offset */
d1294 9
a1302 5
sh_elf64_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol ATTRIBUTE_UNUSED,
		       void *data ATTRIBUTE_UNUSED, asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d1315 9
a1323 3
sh_elf64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
		void *data, asection *input_section, bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
d1443 3
a1445 2
sh_elf64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
d1463 4
a1466 2
sh_elf64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			Elf_Internal_Rela *dst)
d1485 11
a1495 7
static bfd_boolean
sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info, bfd *input_bfd,
			   asection *input_section, bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
d1545 2
a1546 4
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
	  || (r_type >= (int) R_SH_GNU_VTINHERIT
	      && r_type <= (int) R_SH_PSHL)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_2
d1552 1
a1552 1
	  return FALSE;
d1579 1
a1579 1
	  if (info->relocatable)
d1581 1
a1581 1
	      /* This is a relocatable link.  We don't have to change
a1590 29
	  else if (! howto->partial_inplace)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	      relocation |= ((sym->st_other & STO_SH5_ISA32) != 0);
	    }
	  else if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;

	      if (howto->rightshift || howto->src_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
		     (long) rel->r_offset, howto->name);
		  return FALSE;
		}

              addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
              msec = sec;
              addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      bfd_put_32 (input_bfd, addend, contents + rel->r_offset);
	      addend = 0;
	    }
a1593 2
	  /* ??? Could we use the RELOC_FOR_GLOBAL_SYMBOL macro here ?  */

d1596 2
a1597 2
	     relocatable object file.  */
	  if (info->relocatable)
d1654 1
a1654 8
			  || (input_section->flags & SEC_DEBUGGING) != 0))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
d1676 1
a1676 3
	  else if (info->shared
		   && !info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE)
d1682 2
a1683 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d1706 1
a1706 1
	  return FALSE;
d1722 1
a1722 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1737 1
a1737 1
		    return FALSE;
d1748 2
a1749 2
	      skip = FALSE;
	      relocate = FALSE;
d1756 1
a1756 1
		skip = TRUE;
d1758 1
a1758 1
		skip = TRUE, relocate = TRUE;
d1780 1
a1780 1
		      relocate = TRUE;
d1792 5
a1796 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d1945 1
a1945 1
		      asection *s;
a1946 1
		      bfd_byte *loc;
d1948 2
a1949 2
		      s = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (s != NULL);
d1956 5
a1960 3
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2092 1
a2092 1
	  return FALSE;
d2114 1
a2114 1
		      return FALSE;
d2121 1
a2121 1
		  return FALSE;
d2128 1
a2128 1
  return TRUE;
d2137 8
a2144 6
sh_elf64_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
d2155 1
a2155 1
  if (relocatable
d2159 1
a2159 1
						       relocatable,
d2186 3
a2188 3
      internal_relocs = (_bfd_elf_link_read_relocs
			 (input_bfd, input_section, NULL,
			  (Elf_Internal_Rela *) NULL, FALSE));
d2250 5
a2254 4
bfd_boolean
sh64_elf64_fake_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			  Elf_Internal_Shdr *elf_section_hdr,
			  asection *asect)
d2260 1
a2260 1
  return TRUE;
d2263 3
a2265 2
static bfd_boolean
sh_elf64_set_mach_from_flags (bfd *abfd)
d2278 1
a2278 1
      return FALSE;
d2280 1
a2280 1
  return TRUE;
d2287 4
a2290 2
static bfd_boolean
sh_elf64_set_private_flags (bfd *abfd, flagword flags)
d2296 1
a2296 1
  elf_flags_init (abfd) = TRUE;
d2303 4
a2306 2
static bfd_boolean
sh_elf64_copy_private_data_internal (bfd *ibfd, bfd *obfd)
d2314 1
a2314 1
    return TRUE;
d2336 4
a2339 2
static bfd_boolean
sh_elf64_copy_private_data (bfd *ibfd, bfd *obfd)
d2344 4
a2347 2
static bfd_boolean
sh_elf64_merge_private_data (bfd *ibfd, bfd *obfd)
d2352 1
a2352 1
    return FALSE;
d2356 1
a2356 1
    return TRUE;
d2374 1
a2374 1
      return FALSE;
d2382 1
a2382 1
      elf_flags_init (obfd) = TRUE;
d2394 1
a2394 1
      return FALSE;
d2410 6
a2415 5
sh_elf64_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
d2451 6
a2456 5
static bfd_boolean
sh_elf64_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
d2459 1
a2459 1
  return TRUE;
d2466 6
a2471 3
static bfd_boolean
sh_elf64_check_relocs (bfd *abfd, struct bfd_link_info *info,
		       asection *sec, const Elf_Internal_Rela *relocs)
d2487 2
a2488 2
  if (info->relocatable)
    return TRUE;
d2538 1
a2538 1
		return FALSE;
d2552 1
a2552 1
            return FALSE;
d2559 1
a2559 1
            return FALSE;
d2593 1
a2593 1
		    return FALSE;
d2624 1
a2624 1
		    return FALSE;
d2644 1
a2644 1
		    return FALSE;
d2707 1
a2707 1
		return FALSE;
d2775 1
a2775 1
		    return FALSE;
d2794 1
a2794 1
			return FALSE;
d2825 1
a2825 1
			return FALSE;
d2840 1
a2840 1
  return TRUE;
d2844 3
a2846 1
sh64_elf64_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
d2876 9
a2884 5
static bfd_boolean
sh64_elf64_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			    const Elf_Internal_Sym *sym, const char **namep,
			    flagword *flagsp ATTRIBUTE_UNUSED,
			    asection **secp, bfd_vma *valp)
d2888 1
a2888 1
      && is_elf_hash_table (info->hash))
d2892 1
a2892 1
      /* For relocatable links, we register the DataLabel sym in its own
d2896 1
a2896 1
	= info->relocatable || info->emitrelocations
d2907 1
a2907 1
	return FALSE;
d2913 1
a2913 1
	bfd_link_hash_lookup (info->hash, dl_name, FALSE, FALSE, FALSE);
d2919 1
a2919 1
	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2923 1
a2923 1
						  *namep, FALSE,
d2927 1
a2927 1
	      return FALSE;
d2940 1
a2940 1
	  || ((info->relocatable || info->emitrelocations)
d2942 1
a2942 1
	  || (! info->relocatable && !info->emitrelocations
d2950 1
a2950 1
	  return FALSE;
d2962 1
a2962 1
  return TRUE;
d2977 7
a2983 6
static bfd_boolean
sh64_elf64_link_output_symbol_hook (struct bfd_link_info *info,
				    const char *cname,
				    Elf_Internal_Sym *sym,
				    asection *input_sec ATTRIBUTE_UNUSED,
				    struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d2987 1
a2987 1
  if (info->relocatable || info->emitrelocations)
d2993 1
a2993 1
  return TRUE;
d3004 3
a3006 2
sh64_elf64_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
d3150 4
a3153 3
sh64_elf64_link_hash_newfunc (struct bfd_hash_entry *entry,
			      struct bfd_hash_table *table,
			      const char *string)
d3183 2
a3184 1
sh64_elf64_link_hash_table_create (bfd *abfd)
d3204 4
a3207 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
d3220 4
a3223 1
movi_3shori_putval (bfd *output_bfd, bfd_vma value, char *addr)
d3245 4
a3248 2
static bfd_boolean
sh64_elf64_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d3252 1
a3252 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3267 1
a3267 1
      return FALSE;
d3287 1
a3287 1
    return FALSE;
d3298 2
a3299 2
	      (bfd_vma) 0, (const char *) NULL, FALSE, bed->collect, &bh)))
	return FALSE;
d3307 1
a3307 1
	return FALSE;
d3315 1
a3315 1
    return FALSE;
d3318 1
a3318 1
    return FALSE;
d3340 1
a3340 1
	  return FALSE;
d3355 1
a3355 1
	return FALSE;
d3376 1
a3376 1
	    return FALSE;
d3380 1
a3380 1
  return TRUE;
d3389 4
a3392 3
static bfd_boolean
sh64_elf64_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
d3427 1
a3427 1
	  return TRUE;
d3434 1
a3434 1
	    return FALSE;
d3475 1
a3475 1
      return TRUE;
d3487 1
a3487 1
      return TRUE;
d3498 1
a3498 1
    return TRUE;
d3503 1
a3503 1
    return TRUE;
d3544 1
a3544 1
	return FALSE;
d3554 1
a3554 1
  return TRUE;
d3564 4
a3567 3
static bfd_boolean
sh64_elf64_discard_copies (struct elf_sh64_link_hash_entry *h,
			   void *ignore ATTRIBUTE_UNUSED)
d3576 1
a3576 1
    return TRUE;
d3581 1
a3581 1
  return TRUE;
d3586 4
a3589 3
static bfd_boolean
sh64_elf64_size_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
d3593 3
a3595 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d3603 1
a3603 1
      if (info->executable)
d3629 2
a3630 1
				   sh64_elf64_discard_copies, NULL);
d3635 3
a3637 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d3641 1
a3641 1
      bfd_boolean strip;
d3650 1
a3650 1
      strip = FALSE;
d3658 1
a3658 1
	      strip = TRUE;
d3663 1
a3663 1
	      plt = TRUE;
d3679 1
a3679 1
	      strip = TRUE;
d3691 1
a3691 1
		  relocs = TRUE;
d3704 1
a3704 1
		    reltext = TRUE;
d3727 1
a3727 1
	return FALSE;
d3737 1
a3737 1
      if (info->executable)
d3740 1
a3740 1
	    return FALSE;
d3749 1
a3749 1
	    return FALSE;
d3758 1
a3758 1
	    return FALSE;
d3764 1
a3764 1
	    return FALSE;
d3768 1
a3768 1
  return TRUE;
d3774 6
a3779 5
static bfd_boolean
sh64_elf64_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
a3793 1
      bfd_byte *loc;
d3882 3
a3884 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
a3898 1
      bfd_byte *loc;
d3932 4
a3935 3
      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
a3941 1
      bfd_byte *loc;
d3958 4
a3961 3
      loc = s->contents;
      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
d3969 1
a3969 1
  return TRUE;
d3974 4
a3977 3
static bfd_boolean
sh64_elf64_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
d4022 1
a4022 1
					    FALSE, FALSE, TRUE);
d4129 1
a4129 1
  return TRUE;
a4131 27
/* Merge non visibility st_other attribute when the symbol comes from
   a dynamic object.  */
static void
sh64_elf64_merge_symbol_attribute (struct elf_link_hash_entry *h,
				   const Elf_Internal_Sym *isym,
				   bfd_boolean definition,
				   bfd_boolean dynamic)
{
  if (isym->st_other != 0 && dynamic)
    {
      unsigned char other;

      /* Take the balance of OTHER from the definition.  */
      other = (definition ? isym->st_other : h->other);
      other &= ~ ELF_ST_VISIBILITY (-1);
      h->other = other | ELF_ST_VISIBILITY (h->other);
    }

  return;
}

static struct bfd_elf_special_section const sh64_elf64_special_sections[]=
{
  { ".cranges", 8, 0, SHT_PROGBITS, 0 },
  { NULL,       0, 0, 0,            0 }
};

a4171 3
#define	elf_backend_merge_symbol_attribute \
	sh64_elf64_merge_symbol_attribute

a4186 1
#define elf_backend_special_sections	sh64_elf64_special_sections
d4192 1
@


1.19.10.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a2917 3
	  struct bfd_link_hash_entry *bh = NULL;
	  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d2921 2
a2922 1
						  bed->collect, &bh))
a2927 1
	  h = (struct elf_link_hash_entry *) bh;
d3111 1
a3111 1
  0x00, 0xc9, 0x45, 0x10, /* add   r12, r17, r17 */
d3131 1
a3131 1
  0x10, 0x45, 0xc9, 0x00, /* add   r12, r17, r17 */
d3290 1
a3290 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3293 3
a3295 1
	      (bfd_vma) 0, (const char *) NULL, false, bed->collect, &bh)))
a3296 2

      h = (struct elf_link_hash_entry *) bh;
@


1.19.10.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a1590 29
	  else if (! howto->partial_inplace)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
	      relocation |= ((sym->st_other & STO_SH5_ISA32) != 0);
	    }
	  else if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;

	      if (howto->rightshift || howto->src_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
		     (long) rel->r_offset, howto->name);
		  return false;
		}

              addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
              msec = sec;
              addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      bfd_put_32 (input_bfd, addend, contents + rel->r_offset);
	      addend = 0;
	    }
d4132 2
d4143 1
a4196 31
#include "elf64-target.h"

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64nbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64l-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf64_bed			elf64_sh64_nbsd_bed

#include "elf64-target.h"

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64blin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64big-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64-linux"

#define	INCLUDED_TARGET_FILE
@


1.19.10.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d102 1
a102 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d110 3
a112 6
static bfd_boolean sh_elf64_copy_private_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean sh_elf64_copy_private_data_internal
  PARAMS ((bfd *, bfd *));
static bfd_boolean sh_elf64_merge_private_data
  PARAMS ((bfd *, bfd *));
d121 1
a121 1
static bfd_boolean sh_elf64_relocate_section
d126 3
a128 5
	   bfd_byte *, bfd_boolean, asymbol **));
static bfd_boolean sh_elf64_set_mach_from_flags
  PARAMS ((bfd *));
static bfd_boolean sh_elf64_set_private_flags
  PARAMS ((bfd *, flagword));
d132 1
a132 1
static bfd_boolean sh_elf64_gc_sweep_hook
d135 1
a135 1
static bfd_boolean sh_elf64_check_relocs
d138 2
a139 3
static int sh64_elf64_get_symbol_type
  PARAMS ((Elf_Internal_Sym *, int));
static bfd_boolean sh64_elf64_add_symbol_hook
d142 1
a142 1
static bfd_boolean sh64_elf64_link_output_symbol_hook
d145 1
a145 1
static bfd_boolean sh64_elf64_fake_sections
d147 1
a147 2
static void sh64_elf64_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
d152 3
a154 5
inline static void movi_shori_putval
  PARAMS ((bfd *, unsigned long, char *));
inline static void movi_3shori_putval
  PARAMS ((bfd *, bfd_vma, char *));
static bfd_boolean sh64_elf64_create_dynamic_sections
d156 1
a156 1
static bfd_boolean sh64_elf64_adjust_dynamic_symbol
d158 1
a158 1
static bfd_boolean sh64_elf64_discard_copies
d160 1
a160 1
static bfd_boolean sh64_elf64_size_dynamic_sections
d162 1
a162 1
static bfd_boolean sh64_elf64_finish_dynamic_symbol
d165 1
a165 1
static bfd_boolean sh64_elf64_finish_dynamic_sections
d174 1
a174 1
	 FALSE,			/* pc_relative */
d179 1
a179 1
	 FALSE,			/* partial_inplace */
d182 1
a182 1
	 FALSE),		/* pcrel_offset */
d184 1
a184 1
  /* 32 bit absolute relocation.  Setting partial_inplace to TRUE and
d190 1
a190 1
	 FALSE,			/* pc_relative */
d195 1
a195 1
	 TRUE,			/* partial_inplace */
d198 1
a198 1
	 FALSE),		/* pcrel_offset */
d205 1
a205 1
	 TRUE,			/* pc_relative */
d210 1
a210 1
	 FALSE,			/* partial_inplace */
d213 1
a213 1
	 TRUE),			/* pcrel_offset */
d264 1
a264 1
	 FALSE,			/* pc_relative */
d269 1
a269 1
	 FALSE,			/* partial_inplace */
d272 1
a272 1
	 TRUE),			/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d286 1
a286 1
	 FALSE,			/* partial_inplace */
d289 1
a289 1
	 TRUE),			/* pcrel_offset */
d324 1
a324 1
	 FALSE,			/* pc_relative */
d329 1
a329 1
	 FALSE,			/* partial_inplace */
d332 1
a332 1
	 TRUE),			/* pcrel_offset */
d339 1
a339 1
         FALSE,                 /* pc_relative */
d344 1
a344 1
         FALSE,                 /* partial_inplace */
d347 1
a347 1
         FALSE),                /* pcrel_offset */
d354 1
a354 1
         FALSE,                 /* pc_relative */
d359 1
a359 1
         FALSE,                 /* partial_inplace */
d362 1
a362 1
         FALSE),                /* pcrel_offset */
d383 1
a383 1
	 FALSE,			/* pc_relative */
d388 1
a388 1
	 FALSE,			/* partial_inplace */
d391 1
a391 1
	 FALSE),	       	/* pcrel_offset */
d398 1
a398 1
	 FALSE,			/* pc_relative */
d403 1
a403 1
	 FALSE,			/* partial_inplace */
d406 1
a406 1
	 FALSE),	       	/* pcrel_offset */
d413 1
a413 1
	 FALSE,			/* pc_relative */
d418 1
a418 1
	 FALSE,			/* partial_inplace */
d421 1
a421 1
	 FALSE),	       	/* pcrel_offset */
d428 1
a428 1
	 FALSE,			/* pc_relative */
d433 1
a433 1
	 FALSE,			/* partial_inplace */
d436 1
a436 1
	 FALSE),	       	/* pcrel_offset */
d443 1
a443 1
	 FALSE,			/* pc_relative */
d448 1
a448 1
	 FALSE,			/* partial_inplace */
d451 1
a451 1
	 FALSE),	       	/* pcrel_offset */
d458 1
a458 1
	 FALSE,			/* pc_relative */
d463 1
a463 1
	 FALSE,			/* partial_inplace */
d466 1
a466 1
	 FALSE),	       	/* pcrel_offset */
d473 1
a473 1
	 FALSE,			/* pc_relative */
d478 1
a478 1
	 FALSE,			/* partial_inplace */
d481 1
a481 1
	 FALSE),	       	/* pcrel_offset */
d611 1
a611 1
	 FALSE,			/* pc_relative */
d616 1
a616 1
	 FALSE,			/* partial_inplace */
d619 1
a619 1
	 FALSE),	       	/* pcrel_offset */
d626 1
a626 1
	 FALSE,			/* pc_relative */
d631 1
a631 1
	 FALSE,			/* partial_inplace */
d634 1
a634 1
	 FALSE),	       	/* pcrel_offset */
d641 1
a641 1
	 FALSE,			/* pc_relative */
d646 1
a646 1
	 FALSE,			/* partial_inplace */
d649 1
a649 1
	 FALSE),	       	/* pcrel_offset */
d656 1
a656 1
	 FALSE,			/* pc_relative */
d661 1
a661 1
	 FALSE,			/* partial_inplace */
d664 1
a664 1
	 FALSE),	       	/* pcrel_offset */
d671 1
a671 1
	 FALSE,			/* pc_relative */
d676 1
a676 1
	 FALSE,			/* partial_inplace */
d679 1
a679 1
	 FALSE),	       	/* pcrel_offset */
d686 1
a686 1
	 FALSE,			/* pc_relative */
d691 1
a691 1
	 FALSE,			/* partial_inplace */
d694 1
a694 1
	 FALSE),	       	/* pcrel_offset */
d701 1
a701 1
	 FALSE,			/* pc_relative */
d706 1
a706 1
	 FALSE,			/* partial_inplace */
d709 1
a709 1
	 FALSE),	       	/* pcrel_offset */
d716 1
a716 1
	 FALSE,			/* pc_relative */
d721 1
a721 1
	 FALSE,			/* partial_inplace */
d724 1
a724 1
	 FALSE),	       	/* pcrel_offset */
d731 1
a731 1
	 TRUE,			/* pc_relative */
d736 1
a736 1
	 FALSE,			/* partial_inplace */
d739 1
a739 1
	 TRUE),		       	/* pcrel_offset */
d746 1
a746 1
	 TRUE,			/* pc_relative */
d751 1
a751 1
	 FALSE,			/* partial_inplace */
d754 1
a754 1
	 TRUE),		       	/* pcrel_offset */
d761 1
a761 1
	 TRUE,			/* pc_relative */
d766 1
a766 1
	 FALSE,			/* partial_inplace */
d769 1
a769 1
	 TRUE),		       	/* pcrel_offset */
d776 1
a776 1
	 TRUE,			/* pc_relative */
d781 1
a781 1
	 FALSE,			/* partial_inplace */
d784 1
a784 1
	 TRUE),		       	/* pcrel_offset */
d791 1
a791 1
	 FALSE,			/* pc_relative */
d796 1
a796 1
	 FALSE,			/* partial_inplace */
d799 1
a799 1
	 FALSE),	       	/* pcrel_offset */
d806 1
a806 1
	 FALSE,			/* pc_relative */
d811 1
a811 1
	 FALSE,			/* partial_inplace */
d814 1
a814 1
	 FALSE),	       	/* pcrel_offset */
d821 1
a821 1
	 FALSE,			/* pc_relative */
d826 1
a826 1
	 FALSE,			/* partial_inplace */
d829 1
a829 1
	 FALSE),	       	/* pcrel_offset */
d836 1
a836 1
	 FALSE,			/* pc_relative */
d841 1
a841 1
	 FALSE,			/* partial_inplace */
d844 1
a844 1
	 FALSE),	       	/* pcrel_offset */
d851 1
a851 1
	 TRUE,			/* pc_relative */
d856 1
a856 1
	 FALSE,			/* partial_inplace */
d859 1
a859 1
	 TRUE),		       	/* pcrel_offset */
d866 1
a866 1
	 TRUE,			/* pc_relative */
d871 1
a871 1
	 FALSE,			/* partial_inplace */
d874 1
a874 1
	 TRUE),		       	/* pcrel_offset */
d881 1
a881 1
	 TRUE,			/* pc_relative */
d886 1
a886 1
	 FALSE,			/* partial_inplace */
d889 1
a889 1
	 TRUE),		       	/* pcrel_offset */
d896 1
a896 1
	 TRUE,			/* pc_relative */
d901 1
a901 1
	 FALSE,			/* partial_inplace */
d904 1
a904 1
	 TRUE),		       	/* pcrel_offset */
d911 1
a911 1
	 FALSE,			/* pc_relative */
d916 1
a916 1
	 FALSE,			/* partial_inplace */
d919 1
a919 1
	 FALSE),	       	/* pcrel_offset */
d926 1
a926 1
	 FALSE,			/* pc_relative */
d931 1
a931 1
	 FALSE,			/* partial_inplace */
d934 1
a934 1
	 FALSE),	       	/* pcrel_offset */
d941 1
a941 1
	 FALSE,			/* pc_relative */
d946 1
a946 1
	 FALSE,			/* partial_inplace */
d949 1
a949 1
	 FALSE),	       	/* pcrel_offset */
d956 1
a956 1
	 FALSE,			/* pc_relative */
d961 1
a961 1
	 FALSE,			/* partial_inplace */
d964 1
a964 1
	 FALSE),	       	/* pcrel_offset */
d970 1
a970 1
	 FALSE,			/* pc_relative */
d975 1
a975 1
	 FALSE,			/* partial_inplace */
d978 1
a978 1
	 FALSE),	       	/* pcrel_offset */
d984 1
a984 1
	 FALSE,			/* pc_relative */
d989 1
a989 1
	 FALSE,			/* partial_inplace */
d992 1
a992 1
	 FALSE),	       	/* pcrel_offset */
d998 1
a998 1
	 FALSE,			/* pc_relative */
d1003 1
a1003 1
	 FALSE,			/* partial_inplace */
d1006 1
a1006 1
	 FALSE),	       	/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),	       	/* pcrel_offset */
d1081 1
a1081 1
	 FALSE,			/* pc_relative */
d1086 1
a1086 1
	 FALSE,			/* partial_inplace */
d1089 1
a1089 1
	 FALSE),		/* pcrel_offset */
d1098 1
a1098 1
	 TRUE,			/* pc_relative */
d1103 1
a1103 1
	 FALSE,			/* partial_inplace */
d1106 1
a1106 1
	 TRUE),			/* pcrel_offset */
d1113 1
a1113 1
	 FALSE,			/* pc_relative */
d1118 1
a1118 1
	 FALSE,			/* partial_inplace */
d1121 1
a1121 1
	 FALSE),	       	/* pcrel_offset */
d1128 1
a1128 1
	 FALSE,			/* pc_relative */
d1133 1
a1133 1
	 FALSE,			/* partial_inplace */
d1136 1
a1136 1
	 FALSE),	       	/* pcrel_offset */
d1143 1
a1143 1
	 FALSE,			/* pc_relative */
d1148 1
a1148 1
	 FALSE,			/* partial_inplace */
d1151 1
a1151 1
	 FALSE),	       	/* pcrel_offset */
d1158 1
a1158 1
	 TRUE,			/* pc_relative */
d1163 1
a1163 1
	 FALSE,			/* partial_inplace */
d1166 1
a1166 1
	 TRUE),			/* pcrel_offset */
d1173 1
a1173 1
	 FALSE,			/* pc_relative */
d1178 1
a1178 1
	 FALSE,			/* partial_inplace */
d1181 1
a1181 1
	 FALSE),	       	/* pcrel_offset */
d1188 1
a1188 1
	 TRUE,			/* pc_relative */
d1193 1
a1193 1
	 FALSE,			/* partial_inplace */
d1196 1
a1196 1
	 TRUE),			/* pcrel_offset */
d1203 1
a1203 1
	 FALSE,			/* pc_relative */
d1208 1
a1208 1
	 FALSE,			/* partial_inplace */
d1211 1
a1211 1
	 FALSE),	       	/* pcrel_offset */
d1218 1
a1218 1
	 TRUE,			/* pc_relative */
d1223 1
a1223 1
	 FALSE,			/* partial_inplace */
d1226 1
a1226 1
	 TRUE),			/* pcrel_offset */
d1233 1
a1233 1
	 FALSE,			/* pc_relative */
d1238 1
a1238 1
	 FALSE,			/* partial_inplace */
d1241 1
a1241 1
	 FALSE),	       	/* pcrel_offset */
d1248 1
a1248 1
	 TRUE,			/* pc_relative */
d1253 1
a1253 1
	 FALSE,			/* partial_inplace */
d1256 1
a1256 1
	 TRUE),			/* pcrel_offset */
d1263 1
a1263 1
	 FALSE,			/* pc_relative */
d1268 1
a1268 1
	 FALSE,			/* partial_inplace */
d1271 1
a1271 1
	 FALSE),	       	/* pcrel_offset */
d1278 1
a1278 1
	 TRUE,			/* pc_relative */
d1283 1
a1283 1
	 FALSE,			/* partial_inplace */
d1286 1
a1286 1
	 TRUE),			/* pcrel_offset */
d1485 1
a1485 1
static bfd_boolean
d1552 1
a1552 1
	  return FALSE;
d1608 1
a1608 1
		  return FALSE;
d1683 1
a1683 8
			  || (input_section->flags & SEC_DEBUGGING) != 0))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
d1711 2
a1712 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d1735 1
a1735 1
	  return FALSE;
d1751 1
a1751 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1766 1
a1766 1
		    return FALSE;
d1777 2
a1778 2
	      skip = FALSE;
	      relocate = FALSE;
d1785 1
a1785 1
		skip = TRUE;
d1787 1
a1787 1
		skip = TRUE, relocate = TRUE;
d1809 1
a1809 1
		      relocate = TRUE;
d1821 5
a1825 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d1974 1
a1974 1
		      asection *s;
a1975 1
		      bfd_byte *loc;
d1977 2
a1978 2
		      s = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (s != NULL);
d1985 5
a1989 3
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2121 1
a2121 1
	  return FALSE;
d2143 1
a2143 1
		      return FALSE;
d2150 1
a2150 1
		  return FALSE;
d2157 1
a2157 1
  return TRUE;
d2172 1
a2172 1
     bfd_boolean relocateable;
d2217 1
a2217 1
			  (Elf_Internal_Rela *) NULL, FALSE));
d2279 1
a2279 1
bfd_boolean
d2289 1
a2289 1
  return TRUE;
d2292 1
a2292 1
static bfd_boolean
d2307 1
a2307 1
      return FALSE;
d2309 1
a2309 1
  return TRUE;
d2316 1
a2316 1
static bfd_boolean
d2325 1
a2325 1
  elf_flags_init (abfd) = TRUE;
d2332 1
a2332 1
static bfd_boolean
d2343 1
a2343 1
    return TRUE;
d2365 1
a2365 1
static bfd_boolean
d2373 1
a2373 1
static bfd_boolean
d2381 1
a2381 1
    return FALSE;
d2385 1
a2385 1
    return TRUE;
d2403 1
a2403 1
      return FALSE;
d2411 1
a2411 1
      elf_flags_init (obfd) = TRUE;
d2423 1
a2423 1
      return FALSE;
d2480 1
a2480 1
static bfd_boolean
d2488 1
a2488 1
  return TRUE;
d2495 1
a2495 1
static bfd_boolean
d2517 1
a2517 1
    return TRUE;
d2567 1
a2567 1
		return FALSE;
d2581 1
a2581 1
            return FALSE;
d2588 1
a2588 1
            return FALSE;
d2622 1
a2622 1
		    return FALSE;
d2653 1
a2653 1
		    return FALSE;
d2673 1
a2673 1
		    return FALSE;
d2736 1
a2736 1
		return FALSE;
d2804 1
a2804 1
		    return FALSE;
d2823 1
a2823 1
			return FALSE;
d2854 1
a2854 1
			return FALSE;
d2869 1
a2869 1
  return TRUE;
d2905 1
a2905 1
static bfd_boolean
d2936 1
a2936 1
	return FALSE;
d2942 1
a2942 1
	bfd_link_hash_lookup (info->hash, dl_name, FALSE, FALSE, FALSE);
d2952 1
a2952 1
						  *namep, FALSE,
d2956 1
a2956 1
	      return FALSE;
d2979 1
a2979 1
	  return FALSE;
d2991 1
a2991 1
  return TRUE;
d3006 1
a3006 1
static bfd_boolean
d3022 1
a3022 1
  return TRUE;
d3035 1
a3035 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d3274 1
a3274 1
static bfd_boolean
d3296 1
a3296 1
      return FALSE;
d3316 1
a3316 1
    return FALSE;
d3327 2
a3328 2
	      (bfd_vma) 0, (const char *) NULL, FALSE, bed->collect, &bh)))
	return FALSE;
d3336 1
a3336 1
	return FALSE;
d3344 1
a3344 1
    return FALSE;
d3347 1
a3347 1
    return FALSE;
d3369 1
a3369 1
	  return FALSE;
d3384 1
a3384 1
	return FALSE;
d3405 1
a3405 1
	    return FALSE;
d3409 1
a3409 1
  return TRUE;
d3418 1
a3418 1
static bfd_boolean
d3456 1
a3456 1
	  return TRUE;
d3463 1
a3463 1
	    return FALSE;
d3504 1
a3504 1
      return TRUE;
d3516 1
a3516 1
      return TRUE;
d3527 1
a3527 1
    return TRUE;
d3532 1
a3532 1
    return TRUE;
d3573 1
a3573 1
	return FALSE;
d3583 1
a3583 1
  return TRUE;
d3593 1
a3593 1
static bfd_boolean
d3605 1
a3605 1
    return TRUE;
d3610 1
a3610 1
  return TRUE;
d3615 1
a3615 1
static bfd_boolean
d3622 3
a3624 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d3664 3
a3666 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d3670 1
a3670 1
      bfd_boolean strip;
d3679 1
a3679 1
      strip = FALSE;
d3687 1
a3687 1
	      strip = TRUE;
d3692 1
a3692 1
	      plt = TRUE;
d3708 1
a3708 1
	      strip = TRUE;
d3720 1
a3720 1
		  relocs = TRUE;
d3733 1
a3733 1
		    reltext = TRUE;
d3756 1
a3756 1
	return FALSE;
d3769 1
a3769 1
	    return FALSE;
d3778 1
a3778 1
	    return FALSE;
d3787 1
a3787 1
	    return FALSE;
d3793 1
a3793 1
	    return FALSE;
d3797 1
a3797 1
  return TRUE;
d3803 1
a3803 1
static bfd_boolean
a3822 1
      bfd_byte *loc;
d3911 3
a3913 2
      loc = srel->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
a3927 1
      bfd_byte *loc;
d3961 4
a3964 3
      loc = srel->contents;
      loc += srel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
a3970 1
      bfd_byte *loc;
d3987 4
a3990 3
      loc = s->contents;
      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rel, loc);
d3998 1
a3998 1
  return TRUE;
d4003 1
a4003 1
static bfd_boolean
d4051 1
a4051 1
					    FALSE, FALSE, TRUE);
d4158 1
a4158 1
  return TRUE;
@


1.19.10.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1 2
a2 2
/* Renesas SH64-specific support for 64-bit ELF
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.19.10.5
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1 1
a1 1
/* SuperH SH64-specific support for 64-bit ELF
@


1.19.10.6
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2229 1
a2229 1
      internal_relocs = (_bfd_elf_link_read_relocs
@


1.19.10.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1588 1
a1588 1
	  if (info->relocatable)
d1590 1
a1590 1
	      /* This is a relocatable link.  We don't have to change
d1634 2
a1635 2
	     relocatable object file.  */
	  if (info->relocatable)
d2181 1
a2181 1
					 data, relocatable, symbols)
d2186 1
a2186 1
     bfd_boolean relocatable;
d2198 1
a2198 1
  if (relocatable
d2202 1
a2202 1
						       relocatable,
d2530 1
a2530 1
  if (info->relocatable)
d2935 1
a2935 1
      /* For relocatable links, we register the DataLabel sym in its own
d2939 1
a2939 1
	= info->relocatable || info->emitrelocations
d2983 1
a2983 1
	  || ((info->relocatable || info->emitrelocations)
d2985 1
a2985 1
	  || (! info->relocatable && !info->emitrelocations
d3030 1
a3030 1
  if (info->relocatable || info->emitrelocations)
d3646 1
a3646 1
      if (info->executable)
d3780 1
a3780 1
      if (info->executable)
@


1.19.10.8
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d102 1
a102 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \
d111 1
a111 1
  (bfd *, bfd *);
d113 1
a113 1
  (bfd *, bfd *);
d115 1
a115 1
  (bfd *, bfd *);
d117 1
a117 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d119 1
a119 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d121 1
a121 1
  (bfd *, bfd_reloc_code_real_type);
d123 1
a123 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d125 2
a126 2
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
d128 2
a129 2
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);
d131 1
a131 1
  (bfd *);
d133 1
a133 1
  (bfd *, flagword);
d135 2
a136 2
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);
d138 2
a139 1
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d141 2
a142 1
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
d144 1
a144 1
  (Elf_Internal_Sym *, int);
d146 2
a147 2
  (bfd *, struct bfd_link_info *, const Elf_Internal_Sym *, const char **,
   flagword *, asection **, bfd_vma *);
d149 2
a150 2
  (bfd *, struct bfd_link_info *, const char *, Elf_Internal_Sym *,
   asection *);
d152 1
a152 1
  (bfd *, Elf_Internal_Shdr *, asection *);
d154 1
a154 1
  (bfd *, bfd_boolean);
d156 1
a156 1
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
d158 1
a158 1
  (bfd *);
d160 1
a160 1
  (bfd *, unsigned long, char *);
d162 1
a162 1
  (bfd *, bfd_vma, char *);
d164 1
a164 1
  (bfd *, struct bfd_link_info *);
d166 1
a166 1
  (struct bfd_link_info *info, struct elf_link_hash_entry *);
d168 1
a168 1
  (struct elf_sh64_link_hash_entry *, void *);
d170 1
a170 1
  (bfd *, struct bfd_link_info *);
d172 2
a173 2
  (bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
   Elf_Internal_Sym *);
d175 1
a175 1
  (bfd *, struct bfd_link_info *);
d1303 9
a1311 5
sh_elf64_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol ATTRIBUTE_UNUSED,
		       void *data ATTRIBUTE_UNUSED, asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d1324 9
a1332 3
sh_elf64_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol_in,
		void *data, asection *input_section, bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
d1452 3
a1454 2
sh_elf64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
d1472 4
a1475 2
sh_elf64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			Elf_Internal_Rela *dst)
d1495 10
a1504 6
sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info, bfd *input_bfd,
			   asection *input_section, bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
d2180 8
a2187 6
sh_elf64_get_relocated_section_contents (bfd *output_bfd,
					 struct bfd_link_info *link_info,
					 struct bfd_link_order *link_order,
					 bfd_byte *data,
					 bfd_boolean relocatable,
					 asymbol **symbols)
d2230 1
a2230 1
			 (input_bfd, input_section, NULL,
d2294 4
a2297 3
sh64_elf64_fake_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			  Elf_Internal_Shdr *elf_section_hdr,
			  asection *asect)
d2307 2
a2308 1
sh_elf64_set_mach_from_flags (bfd *abfd)
d2331 3
a2333 1
sh_elf64_set_private_flags (bfd *abfd, flagword flags)
d2347 3
a2349 1
sh_elf64_copy_private_data_internal (bfd *ibfd, bfd *obfd)
d2380 3
a2382 1
sh_elf64_copy_private_data (bfd *ibfd, bfd *obfd)
d2388 3
a2390 1
sh_elf64_merge_private_data (bfd *ibfd, bfd *obfd)
d2453 6
a2458 5
sh_elf64_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
d2495 5
a2499 4
sh_elf64_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
d2510 5
a2514 2
sh_elf64_check_relocs (bfd *abfd, struct bfd_link_info *info,
		       asection *sec, const Elf_Internal_Rela *relocs)
d2887 3
a2889 1
sh64_elf64_get_symbol_type (Elf_Internal_Sym * elf_sym, int type)
d2920 8
a2927 4
sh64_elf64_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
			    const Elf_Internal_Sym *sym, const char **namep,
			    flagword *flagsp ATTRIBUTE_UNUSED,
			    asection **secp, bfd_vma *valp)
d3021 6
a3026 5
sh64_elf64_link_output_symbol_hook (bfd *abfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info,
				    const char *cname,
				    Elf_Internal_Sym *sym,
				    asection *input_sec ATTRIBUTE_UNUSED)
d3047 3
a3049 2
sh64_elf64_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
d3193 4
a3196 3
sh64_elf64_link_hash_newfunc (struct bfd_hash_entry *entry,
			      struct bfd_hash_table *table,
			      const char *string)
d3226 2
a3227 1
sh64_elf64_link_hash_table_create (bfd *abfd)
d3247 4
a3250 1
movi_shori_putval (bfd *output_bfd, unsigned long value, char *addr)
d3263 4
a3266 1
movi_3shori_putval (bfd *output_bfd, bfd_vma value, char *addr)
d3289 3
a3291 1
sh64_elf64_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d3433 3
a3435 2
sh64_elf64_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
d3608 3
a3610 2
sh64_elf64_discard_copies (struct elf_sh64_link_hash_entry *h,
			   void *ignore ATTRIBUTE_UNUSED)
d3630 3
a3632 2
sh64_elf64_size_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
d3672 2
a3673 1
				   sh64_elf64_discard_copies, NULL);
d3818 5
a3822 4
sh64_elf64_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym)
d4018 3
a4020 2
sh64_elf64_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
a4174 8
static struct bfd_elf_special_section const sh64_elf64_special_sections[]=
{
  { ".cranges",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a4229 1
#define elf_backend_special_sections	sh64_elf64_special_sections
@


1.19.10.9
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a1612 2
	  /* ??? Could we use the RELOC_FOR_GLOBAL_SYMBOL macro here ?  */

d1702 1
a1702 3
	  else if (info->shared
		   && !info->symbolic
		   && info->unresolved_syms_in_objects == RM_IGNORE)
d2920 1
a2920 1
	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3241 1
a3241 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
@


1.19.10.10
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1535 2
a1536 4
	      && r_type <= (int) R_SH_LAST_INVALID_RELOC)
	  || (r_type >= (int) R_SH_GNU_VTINHERIT
	      && r_type <= (int) R_SH_PSHL)
	  || (r_type >= (int) R_SH_FIRST_INVALID_RELOC_2
d1583 1
a1583 1
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
a4118 21
/* Merge non visibility st_other attribute when the symbol comes from
   a dynamic object.  */
static void
sh64_elf64_merge_symbol_attribute (struct elf_link_hash_entry *h,
				   const Elf_Internal_Sym *isym,
				   bfd_boolean definition,
				   bfd_boolean dynamic)
{
  if (isym->st_other != 0 && dynamic)
    {
      unsigned char other;

      /* Take the balance of OTHER from the definition.  */
      other = (definition ? isym->st_other : h->other);
      other &= ~ ELF_ST_VISIBILITY (-1);
      h->other = other | ELF_ST_VISIBILITY (h->other);
    }

  return;
}

d4121 4
a4124 2
  { ".cranges", 8, 0, SHT_PROGBITS, 0 },
  { NULL,       0, 0, 0,            0 }
a4166 3
#define	elf_backend_merge_symbol_attribute \
	sh64_elf64_merge_symbol_attribute

d4188 1
@


1.19.10.11
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d147 2
a148 2
  (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
   struct elf_link_hash_entry *);
d2895 1
a2895 1
      && is_elf_hash_table (info->hash))
d2985 2
a2986 1
sh64_elf64_link_output_symbol_hook (struct bfd_link_info *info,
d2989 1
a2989 2
				    asection *input_sec ATTRIBUTE_UNUSED,
				    struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
@


1.18
log
@	* elf32-sh.c (sh_elf_finish_dynamic_sections): Set LSB of DT_INIT
	value if .init is an SHmedia function.  Similarly for DT_FINI.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_sections): Likewise.
@
text
@d3022 1
a3022 1
  0x6b, 0xf1, 0x46, 0x00, /* ptabs r17, tr0 */
d3042 1
a3042 1
  0x00, 0x46, 0xf1, 0x6b, /* ptabs r17, tr0 */
d3068 3
a3070 3
  0xcc, 0x00, 0x01, 0x90, /* movi  .PLT0 >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori .PLT0 & 65535, r25 */
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
d3088 3
a3090 3
  0x90, 0x01, 0x00, 0xcc, /* movi  .PLT0 >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori .PLT0 & 65535, r25 */
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
d3811 2
a3812 1
      got_offset -= GOT_BIAS;
d3831 1
d3833 3
a3835 1
			     (splt->output_section->vma + splt->output_offset),
d3854 2
a3855 1
      got_offset += GOT_BIAS;
@


1.17
log
@	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero initialize
	dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
@
text
@d3993 1
d4000 19
@


1.16
log
@	* bfd/elf32-sh.c (sh_elf_gc_mark_hook): For sh64, skip indirect
	symbols when looking for section referred to by a relocation.
	* bfd/elf64-sh.c (sh_elf64_gc_mark_hook): Likewise.
@
text
@d3720 1
a3720 1
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
@


1.15
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d2426 3
@


1.15.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d3717 1
a3717 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
@


1.15.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a2914 3
	  struct bfd_link_hash_entry *bh = NULL;
	  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d2918 2
a2919 1
						  bed->collect, &bh))
a2924 1
	  h = (struct elf_link_hash_entry *) bh;
d3287 1
a3287 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3290 3
a3292 1
	      (bfd_vma) 0, (const char *) NULL, false, bed->collect, &bh)))
a3293 2

      h = (struct elf_link_hash_entry *) bh;
@


1.15.2.3
log
@Merge fixes from trunk.
@
text
@d1654 1
a1654 8
			  || (input_section->flags & SEC_DEBUGGING) != 0))
		  /* Dynamic relocs are not propagated for SEC_DEBUGGING
		     sections because such sections are not SEC_ALLOC and
		     thus ld.so will not process them.  */
		  || (sec->output_section == NULL
		      && ((input_section->flags & SEC_DEBUGGING) != 0
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC) != 0)))
@


1.14
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a2146 1
  Elf_Internal_Shdr *shndx_hdr;
d2151 1
a2151 4
  Elf64_External_Sym *external_syms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *internal_syms = NULL;
a2162 1
  shndx_hdr  = &elf_tdata (input_bfd)->symtab_shndx_hdr;
d2171 1
a2172 2
      Elf64_External_Sym *esym, *esymend;
      bfd_size_type amt;
d2174 2
a2175 3
      if (symtab_hdr->contents != NULL)
	external_syms = (Elf64_External_Sym *) symtab_hdr->contents;
      else
d2177 6
a2182 23
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf64_External_Sym);

	  external_syms = (Elf64_External_Sym *) bfd_malloc (amt);
	  if (external_syms == NULL && symtab_hdr->sh_info > 0)
	    goto error_return;

	  if (bfd_seek (input_bfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	      || (bfd_bread ((PTR) external_syms, amt, input_bfd) != amt))
	    goto error_return;
	}

      if (symtab_hdr->sh_info != 0 && shndx_hdr->sh_size != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf_External_Sym_Shndx);

	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (shndx_buf == NULL)
	    goto error_return;

	  if (bfd_seek (input_bfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread ((PTR) shndx_buf, amt, input_bfd) != amt)
a2191 6
      internal_syms = ((Elf_Internal_Sym *)
		       bfd_malloc (symtab_hdr->sh_info
				   * sizeof (Elf_Internal_Sym)));
      if (internal_syms == NULL && symtab_hdr->sh_info > 0)
	goto error_return;

a2196 1
      isymp = internal_syms;
d2198 2
a2199 5
      esym = external_syms;
      esymend = esym + symtab_hdr->sh_info;
      shndx = shndx_buf;
      for (; esym < esymend;
	   ++esym, ++isymp, ++secpp, shndx = (shndx ? shndx + 1 : NULL))
a2202 3
	  bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);

d2222 1
a2222 1
				       internal_syms, sections))
a2226 7
      sections = NULL;
      if (internal_syms != NULL)
	free (internal_syms);
      internal_syms = NULL;
      if (external_syms != NULL && symtab_hdr->contents == NULL)
	free (external_syms);
      external_syms = NULL;
d2229 3
a2231 1
      internal_relocs = NULL;
d2237 2
d2242 3
a2244 6
  if (external_syms != NULL && symtab_hdr->contents == NULL)
    free (external_syms);
  if (internal_syms != NULL)
    free (internal_syms);
  if (sections != NULL)
    free (sections);
@


1.13
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d130 1
a130 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d2453 6
a2458 6
sh_elf64_gc_mark_hook (abfd, info, rel, h, sym)
       bfd *abfd;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
d2484 1
a2484 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.12
log
@	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Make static.
@
text
@d2394 1
a2394 1
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
@


1.11
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d142 1
a142 1
extern boolean sh64_elf64_link_output_symbol_hook
d3016 1
a3016 1
boolean
@


1.10
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2237 2
a2238 2
	  bfd_elf64_swap_symbol_in (input_bfd, (const PTR *) esym,
				    (const PTR *) shndx, isymp);
@


1.9
log
@	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Remove
	ATTRIBUTE_UNUSED on used params.
	* elf32-vax.c (elf_vax_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
@
text
@d2237 2
a2238 1
	  bfd_elf64_swap_symbol_in (input_bfd, esym, shndx, isymp);
@


1.8
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d2484 1
a2484 5
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	return bfd_section_from_elf_index (abfd, sym->st_shndx);
@


1.7
log
@	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.
@
text
@d1345 2
a1346 2
    sym_value = 0;                           
  else 
d1617 1
a1617 1
		 sec->output_section will be NULL. */
d1759 1
a1759 1
	      
d2510 1
a2510 1
 
d2540 1
a2540 1
 
d2549 1
a2549 1
 
d2555 1
a2555 1
 
d2599 1
a2599 1
 
d2884 1
a2884 1
 
@


1.7.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d142 1
a142 1
static boolean sh64_elf64_link_output_symbol_hook
d1345 2
a1346 2
    sym_value = 0;
  else
d1617 1
a1617 1
		 sec->output_section will be NULL.  */
d1759 1
a1759 1

d2237 1
a2237 2
	  bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
d2484 5
a2488 1
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
d2510 1
a2510 1

d2540 1
a2540 1

d2549 1
a2549 1

d2555 1
a2555 1

d2599 1
a2599 1

d2884 1
a2884 1

d3019 1
a3019 1
static boolean
@


1.7.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d130 1
a130 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d2147 1
d2152 4
a2155 1
  Elf_Internal_Sym *isymbuf = NULL;
d2167 1
a2175 1
      Elf_Internal_Sym *isymend;
d2177 2
d2180 17
a2196 2
      /* Read this BFD's local symbols.  */
      if (symtab_hdr->sh_info != 0)
d2198 9
a2206 6
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
d2216 6
d2227 1
d2229 5
a2233 2
      isymend = isymbuf + symtab_hdr->sh_info;
      for (isymp = isymbuf; isymp < isymend; ++isymp, ++secpp)
d2237 3
d2259 1
a2259 1
				       isymbuf, sections))
d2264 7
d2273 1
a2273 3
      if (isymbuf != NULL
	  && (unsigned char *) isymbuf != symtab_hdr->contents)
	free (isymbuf);
a2278 2
  if (sections != NULL)
    free (sections);
d2282 6
a2287 3
  if (isymbuf != NULL
      && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
d2394 1
a2394 1
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
d2453 6
a2458 6
sh_elf64_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2484 3
a2486 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.7.6.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a2425 3
	  while (h->root.type == bfd_link_hash_indirect
		 && h->root.u.i.link)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d3019 1
a3019 1
  0x6b, 0xf1, 0x66, 0x00, /* ptabs r25, tr0 */
d3039 1
a3039 1
  0x00, 0x66, 0xf1, 0x6b, /* ptabs r25, tr0 */
d3065 3
a3067 3
  0xcc, 0x00, 0x01, 0x90, /* movi  (.+8-.PLT0) >> 16, r25 */
  0xc8, 0x00, 0x01, 0x90, /* shori (.+4-.PLT0) & 65535, r25 */
  0x6b, 0xf5, 0x66, 0x00, /* ptrel r25, tr0 */
d3085 3
a3087 3
  0x90, 0x01, 0x00, 0xcc, /* movi  (.+8-.PLT0) >> 16, r25 */
  0x90, 0x01, 0x00, 0xc8, /* shori (.+4-.PLT0) & 65535, r25 */
  0x00, 0x66, 0xf5, 0x6b, /* ptrel r25, tr0 */
d3717 1
a3717 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d3808 1
a3808 2
      if (info->shared)
	got_offset -= GOT_BIAS;
a3826 1
	  /* Set bottom bit because its for a branch to SHmedia */
d3828 1
a3828 3
			     -(h->plt.offset
			      + elf_sh64_plt_plt0_offset (info) + 8)
			     | 1,
d3847 1
a3847 2
      if (info->shared)
	got_offset += GOT_BIAS;
a3989 1
	  struct elf_link_hash_entry *h;
a3995 19
	      break;

	    case DT_INIT:
	      name = info->init_function;
	      goto get_sym;

	    case DT_FINI:
	      name = info->fini_function;
	    get_sym:
	      if (dyn.d_un.d_val != 0)
		{
		  h = elf_link_hash_lookup (elf_hash_table (info), name,
					    false, false, true);
		  if (h != NULL && (h->other & STO_SH5_ISA32))
		    {
		      dyn.d_un.d_val |= 1;
		      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
		    }
		}
@


1.7.6.4
log
@merge from mainline
@
text
@a1590 29
	  else if (! howto->partial_inplace)
	    {
	      relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
	      relocation |= ((sym->st_other & STO_SH5_ISA32) != 0);
	    }
	  else if ((sec->flags & SEC_MERGE)
		   && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      asection *msec;

	      if (howto->rightshift || howto->src_mask != 0xffffffff)
		{
		  (*_bfd_error_handler)
		    (_("%s(%s+0x%lx): %s relocation against SEC_MERGE section"),
		     bfd_archive_filename (input_bfd),
		     bfd_get_section_name (input_bfd, input_section),
		     (long) rel->r_offset, howto->name);
		  return false;
		}

              addend = bfd_get_32 (input_bfd, contents + rel->r_offset);
              msec = sec;
              addend =
		_bfd_elf_rel_local_sym (output_bfd, sym, &msec, addend)
		- relocation;
	      addend += msec->output_section->vma + msec->output_offset;
	      bfd_put_32 (input_bfd, addend, contents + rel->r_offset);
	      addend = 0;
	    }
a2917 3
	  struct bfd_link_hash_entry *bh = NULL;
	  struct elf_backend_data *bed = get_elf_backend_data (abfd);

d2921 2
a2922 1
						  bed->collect, &bh))
a2927 1
	  h = (struct elf_link_hash_entry *) bh;
d3111 1
a3111 1
  0x00, 0xc9, 0x45, 0x10, /* add   r12, r17, r17 */
d3131 1
a3131 1
  0x10, 0x45, 0xc9, 0x00, /* add   r12, r17, r17 */
d3290 1
a3290 3
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

d3293 3
a3295 1
	      (bfd_vma) 0, (const char *) NULL, false, bed->collect, &bh)))
a3296 2

      h = (struct elf_link_hash_entry *) bh;
d4127 2
d4138 1
a4191 31
#include "elf64-target.h"

/* NetBSD support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64nbsd_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64-nbsd"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lnbsd_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64l-nbsd"
#undef	ELF_MAXPAGESIZE
#define	ELF_MAXPAGESIZE			0x10000
#undef	elf_symbol_leading_char
#define	elf_symbol_leading_char		0

#define	elf64_bed			elf64_sh64_nbsd_bed

#include "elf64-target.h"

/* Linux support.  */
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf64_sh64blin_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf64-sh64big-linux"
#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_sh64lin_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-sh64-linux"

#define	INCLUDED_TARGET_FILE
@


1.7.4.1
log
@merge from trunk
@
text
@d142 1
a142 1
static boolean sh64_elf64_link_output_symbol_hook
d1345 2
a1346 2
    sym_value = 0;
  else
d1617 1
a1617 1
		 sec->output_section will be NULL.  */
d1759 1
a1759 1

d2237 1
a2237 2
	  bfd_elf64_swap_symbol_in (input_bfd, (const PTR) esym,
				    (const PTR) shndx, isymp);
d2484 5
a2488 1
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
d2510 1
a2510 1

d2540 1
a2540 1

d2549 1
a2549 1

d2555 1
a2555 1

d2599 1
a2599 1

d2884 1
a2884 1

d3019 1
a3019 1
static boolean
@


1.6
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d2932 2
a2933 1
  if (ELF_ST_TYPE (sym->st_info) == STT_DATALABEL)
@


1.5
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d3230 1
a3230 1
	 bfd_alloc (abfd, sizeof (struct elf_sh64_link_hash_table)));
d3237 1
a3237 1
      bfd_release (abfd, ret);
@


1.4
log
@	* elf64-sh64.c (sh_elf64_relocate_section): Fix a typo from my
	last patch.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d3610 3
@


1.3
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d1757 1
a1757 1
	      else if (outrel.r_offset == (bfd_vma) -1)
@


1.2
log
@* elf32-sh.c: Added missing prototypes.
* elf32-sh64.c: Likewise.
(sh_elf_align_loads): Mark unused args as such.
* elf64-sh64.c: Added missing prototypes.
(struct elf_sh64_link_hash_entry): Fix typo.
(sh_elf64_relocate_section): Fix info argument passed to
_bfd_elf_section_offset.
@
text
@d1749 1
d1757 2
d1764 1
a1764 4
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = false;
		}
a1767 1
		  relocate = false;
a1786 1
		      relocate = false;
@


1.1
log
@Contribute sh64-elf.
2002-01-23  Alexandre Oliva  <aoliva@@redhat.com>
* reloc.c (R_SH_GOTPLT32, R_SH_GOT_LOW16, R_SH_GOT_MEDLOW16,
R_SH_GOT_MEDHI16, R_SH_GOT_HI16, R_SH_GOTPLT_LOW16,
R_SH_GOTPLT_MEDLOW16, R_SH_GOTPLT_MEDHI16, R_SH_GOTPLT_HI16,
R_SH_PLT_LOW16, R_SH_PLT_MEDLOW16, R_SH_PLT_MEDHI16,
R_SH_PLT_HI16, R_SH_GOTOFF_LOW16, R_SH_GOTOFF_MEDLOW16,
R_SH_GOTOFF_MEDHI16, R_SH_GOTOFF_HI16, R_SH_GOTPC_LOW16,
R_SH_GOTPC_MEDLOW16, R_SH_GOTPC_MEDHI16, R_SH_GOTPC_HI16,
R_SH_GOT10BY4, R_SH_GOTPLT10BY4, R_SH_GOT10BY8, R_SH_GOTPLT10BY8,
R_SH_COPY64, R_SH_GLOB_DAT64, R_SH_JMP_SLOT64, R_SH_RELATIVE64):
New relocs.
* libbfd.h, bfd-in2.h: Rebuilt.
* elf32-sh.c (sh_elf_howto_table): Define new relocs.
(sh_reloc_map): Map them.
(PLT_ENTRY_SIZE, elf_sh_plt0_entry_be, elf_sh_plt0_entry_le,
elf_sh_plt_entry_be, elf_sh_plt_entry_le, elf_sh_pic_plt_entry_be,
elf_sh_pic_plt_entry_le, elf_sh_plt0_entry, elf_sh_plt_entry,
elf_sh_pic_plt_entry, elf_sh_sizeof_plt, elf_sh_plt_plt0_offset,
elf_sh_plt0_gotplt_offset, elf_sh_plt_temp_offset,
elf_sh_plt_symbol_offset, elf_sh_plt_reloc_offset,
movi_shori_putval) [INCLUDE_SHMEDIA]: New.
(elf_sh_link_hash_entry) [INCLUDE_SHMEDIA]: Add
datalabel_got_offset.
(sh_elf_link_hash_newfunc): Initialize it.
(sh_elf_relocate_section): Augment the scope of
seen_stt_datalabel.  Introduce GOTPLT support.	Extend GOTPC, PLT,
GOT and GOTOFF handling to new SHmedia relocation types.  Support
GOT_BIAS.
(sh_elf_check_relocs): Likewise.
(sh_elf_finish_dynamic_symbol) [TARGET_SHMEDIA]: Set up values in
PLT entries using movi_shori_putval.  Support GOT_BIAS.
(sh_elf_finish_dynamic_sections): Likewise.
* elf32-sh64.c (shmedia_prepare_reloc): Do not add addend to
relocation, it's now done by the caller.
(GOT_BIAS): New.
* elf64-sh64.c (GOT_BIAS, PLT_ENTRY_SIZE, elf_sh64_sizeof_plt,
elf_sh64_plt_plt0_offset, elf_sh64_plt0_gotplt_offset,
elf_sh64_plt_temp_offset, elf_sh64_plt_symbol_offset,
elf_sh64_plt_reloc_offset, ELF_DYNAMIC_INTERPRETER,
elf_sh64_pcrel_relocs_copied, elf_sh64_link_hash_entry,
elf_sh64_link_hash_table, sh64_elf64_link_hash_traverse,
sh64_elf64_hash_table): New.
(sh_elf64_howto_table): Introduce new relocs.
(sh_elf64_info_to_howto): Accept new PIC relocs.
(sh_elf64_relocate_section): Augment the scope of
seen_stt_datalabel.  Support new PIC relocs.
(sh_elf64_check_relocs): Support new PIC relocs.
(elf_sh64_plt0_entry_be, elf_sh64_plt0_entry_le,
elf_sh64_plt_entry_be, elf_sh64_plt_entry_le,
elf_sh64_pic_plt_entry_be, elf_sh64_pic_plt_entry_le,
elf_sh64_plt0_entry, elf_sh64_plt_entry, elf_sh64_pic_plt_entry,
sh64_elf64_link_hash_newfunc, sh64_elf64_link_hash_table_create,
movi_shori_putval, movi_3shori_putval,
sh64_elf64_create_dynamic_sections,
sh64_elf64_adjust_dynamic_symbol, sh64_elf64_discard_copies,
sh64_elf64_size_dynamic_sections,
sh64_elf64_finish_dynamic_symbol,
sh64_elf64_finish_dynamic_sections): New.
(elf_backend_create_dynamic-sections,
bfd_elf64_bfd_link_hash_table_create,
elf_backend_adjust_dynamic_symbol,
elf_backend_size_dynamic_sections,
elf_backend_finish_dynamic_symbol,
elf_backend_finish_dynamic_sections, elf_backend_want_got_plt,
elf_backend_plt_readonly, elf_backend_want_plt_sym,
elf_backend_got_header_size, elf_backend_plt_header_size):
Define.
2001-05-16  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-sh.c: Renumbered and renamed some SH5 relocations to
match official numbers and names; moved unmaching ones to the
range 0xf2-0xff.
* elf32-sh64.c, elf64-sh64.c: Likewise.
2001-03-12  DJ Delorie	<dj@@redhat.com>
* elf32-sh.c (sh_elf_relax_section): Don't relax SHmedia
sections.
2001-03-12  DJ Delorie	<dj@@redhat.com>
* elf32-sh64.c (shmedia_prepare_reloc): Validate relocs that must
be aligned.
* elf64-sh64.c (sh_elf64_relocate_section): Ditto.
2001-01-14  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (bfd_elf32_bfd_copy_private_section_data): Define.
(sh64_elf_fake_sections): Set type to SHT_SH5_CR_SORTED for a
.cranges section with SEC_SORT_ENTRIES set.
(sh64_backend_section_from_shdr): Set SEC_SORT_ENTRIES on an
incoming sorted .cranges section.
(sh64_bfd_elf_copy_private_section_data): New.
(sh64_elf_final_write_processing): Only sort .cranges and modify
start address if called by linker.
2001-01-08  Ben Elliston  <bje@@redhat.com>
* elf32-sh64.c (sh64_elf_final_write_processing): Activate
Hans-Peter Nilsson's set bit 0 patch from	2001-01-06.
* elf64-sh64.c (sh64_elf64_final_write_processing): Ditto.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh_elf64_howto_table): No open brace at start of
line.  Add comments before all entries.
<R_SH_PT_16, R_SH_SHMEDIA_CODE>: Correct and clarify describing
comment.
(sh_elf64_reloc): Correct head comment.
(sh_elf64_relocate_section): Correct spacing.
<relocating for a local symbol>: Do not honour STO_SH5_ISA32;
instead call reloc_dangerous callback.
<case R_SH_SHMEDIA_CODE>: New case.
(sh_elf64_gc_mark_hook): Correct spacing.
(sh_elf64_check_relocs): Ditto.
* elf32-sh64.c (shmedia_prepare_reloc) <case R_SH_SHMEDIA_CODE>:
New case.
* elf32-sh.c: Correct #endif comments for #ifndef-wrapped
functions.
(sh_elf_howto_table) <R_SH_PT_16, R_SH_SHMEDIA_CODE>: Correct,
clarify describing comment.  Add comments before all entries.
(sh_elf_relocate_section) <relocating for a local symbol>: Do not
honour STO_SH5_ISA32; instead call reloc_dangerous callback.
2001-01-06  Hans-Peter Nilsson	<hpn@@cygnus.com>
Sort .cranges section in final link.  Prepare to set bit 0 on
entry address.
* elf32-sh64.c (struct sh64_find_section_vma_data): New.
(sh64_elf_link_output_symbol_hook): Fix typo in prototype.
(sh64_elf_set_mach_from_flags): Set SEC_DEBUGGING on incoming
.cranges section.
(sh64_backend_section_from_shdr): New, to recognize
SHT_SH5_CR_SORTED on incoming .cranges section.
(elf_backend_section_from_shdr): Define.
(sh64_elf_final_write_processing): Sort outgoing .cranges
section.  (New, temporarily disabled:) Set bit 0 on entry address
according to ISA type.
(sh64_find_section_for_address): New.
(crange_qsort_cmpb, crange_qsort_cmpl, crange_bsearch_cmpb,
crange_bsearch_cmpl): Move here from opcodes/sh64-dis.c.
(sh64_address_in_cranges): Move here from opcodes/sh64-dis.c.  Use
bfd_malloc, not xmalloc.
(sh64_get_contents_type): Move here from opcodes/sh64-dis.c.  Make
global.
* elf32-sh64.c (sh64_elf64_final_write_processing): New, (but
temporarily disabled) setting bit 0 on entry address.
(elf_backend_final_write_processing): Define.
2001-01-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh.c (sh_elf_howto_table) <R_SH_PT_16>: Adjust fields to
be a proper relocation for PTA and PTB rather than a marker.
<R_SH_IMMU5, R_SH_IMMS6, R_SH_IMMU6, R_SH_IMMS10, R_SH_IMMS10BY2,
R_SH_IMMS10BY4, R_SH_IMMS10BY8, R_SH_IMMS16, R_SH_IMMU16,
R_SH_IMM_LOW16, R_SH_IMM_LOW16_PCREL, R_SH_IMM_MEDLOW16,
R_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDHI16, R_SH_IMM_MEDHI16_PCREL,
R_SH_IMM_HI16, R_SH_IMM_HI16_PCREL, R_SH_64, R_SH_64_PCREL>:
Zero src_mask.
* elf64-sh64.c: Ditto.
(sh_elf64_relocate_section) <case R_SH_PT_16>: New case.
* elf32-sh64.c: Include opcodes/sh64-opc.h
(shmedia_prepare_reloc): Take a bfd_link_info pointer as first
argument.  Drop const qualifiers from "bfd *" and "bfd_byte *"
parameters.  No unused parameters.  Caller changed.
<case R_SH_PT_16>: New case.
* Makefile.am (elf32-sh64.lo): Add dependency on sh64-opc.h.
* Makefile.in: Regenerate.
2000-12-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh64_elf64_fake_sections): Set SHF_SH5_ISA32 for
all code sections.
(sh_elf64_set_mach_from_flags): Change from EF_SH64 to EF_SH5.
(sh64_elf_merge_private_data): Ditto.
* elf32-sh64.c (sh64_elf_fake_sections): Use sh64_elf_section_data
to access stored section flags.
(sh64_elf_final_write_processing): Return immediately unless
called by linker.  Use sh64_elf_section_data (cranges) to get size
of linker-generated cranges entries.
(sh64_elf_copy_private_data): Add missing "return true".
(sh64_elf_set_mach_from_flags): Change from EF_SH64 to EF_SH5.
(sh_elf64_merge_private_data): Ditto.
2000-12-19  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf64-sh64.c (sh64_elf64_fake_sections): New, copy of
elf64-sh64.c:sh64_elf_fake_sections.
(elf_backend_fake_sections): Define as sh64_elf64_fake_sections.
2000-12-18  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (sh64_elf_copy_private_data_internal): Delete.
(sh64_elf_final_write_processing): New.
(elf_backend_final_write_processing): Define.
(sh64_elf_fake_sections): Get header flags from tdata field.
(sh64_elf_copy_private_data): Do not call
sh64_elf_copy_private_data_internal, just copy e_flags field.
(sh64_elf_merge_private_data): Do not call
sh64_elf_copy_private_data_internal.
2000-12-12  Hans-Peter Nilsson	<hpn@@cygnus.com>
Remove EF_SH64_ABI64, let ELF size make difference.
Remove SH64-specific BFD section flag.
* elf32-sh64.c (sh64_elf_fake_sections): Recognize section as
containing SHmedia through elf_section_data (asect)->tdata
non-zero, not using a BFD section flag.
(sh64_elf_set_mach_from_flags): Don't recognize EF_SH64_ABI64.
(sh64_elf_merge_private_data): Similar.
(elf_backend_section_flags): Don't define.
(sh64_elf_backend_section_flags): Delete.
* elf64-sh64.c (sh_elf64_set_mach_from_flags): Recognize EF_SH64,
not EF_SH64_ABI64.
(sh_elf64_merge_private_data): Similar.
* section.c (Section flags definitions): Don't define
SEC_SH_ISA_SHMEDIA.
(bfd-in2.h): Regenerate.
2000-12-09  Hans-Peter Nilsson	<hpn@@cygnus.com>
Make DataLabel references work with partial linking.
* elf32-sh64.c: Fix formatting.
(sh64_elf_link_output_symbol_hook): New.
(elf_backend_link_output_symbol_hook): Define to
sh64_elf_link_output_symbol_hook.
(sh64_elf_add_symbol_hook): Make DataLabel symbol just global
undefined if partial linking.  Adjust sanity check.
* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): New.
(elf_backend_link_output_symbol_hook): Define to
sh64_elf64_link_output_symbol_hook.
(sh64_elf64_add_symbol_hook): Make DataLabel symbol just global
undefined if partial linking.  Adjust sanity check.
2000-12-07  Hans-Peter Nilsson	<hpn@@cygnus.com>
Implement semantics for inter-file DataLabel references.
* elf64-sh64.c (DATALABEL_SUFFIX): Define.
(sh64_elf64_add_symbol_hook): New.
(sh_elf64_relocate_section): If passing an indirect symbol with
st_type STT_DATALABEL on the way to a symbol with st_other
STO_SH5_ISA32, do not bitor 1 to the relocation.
(elf_backend_add_symbol_hook): Define to
sh64_elf64_add_symbol_hook.
* elf64-sh32.c: Tweak comments.
(DATALABEL_SUFFIX): Define.
(sh64_elf_add_symbol_hook): New.
(elf_backend_add_symbol_hook): Define to sh64_elf_add_symbol_hook.
* elf32-sh.c (sh_elf_relocate_section): If passing an indirect
symbol with st_type STT_DATALABEL on the way to a symbol with
st_other STO_SH5_ISA32, do not bitor 1 to the relocation.
2000-12-05  Hans-Peter Nilsson	<hpn@@cygnus.com>
Pass through STT_DATALABEL.
* elf32-sh64.c (sh64_elf_get_symbol_type): New.
(elf_backend_get_symbol_type): Define.
* elf64-sh64.c (sh64_elf64_get_symbol_type): New.
(elf_backend_get_symbol_type): Define.
2000-11-30  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c: Tweak comments.
(sh64_elf_copy_private_data_internal): Add prototype.
(bfd_elf32_bfd_set_private_flags): Define.
(sh64_elf_copy_private_data_internal): Compare machine name, not
textual BFD target name, to check whether to copy section flag
SHF_SH5_ISA32.
(sh64_elf_merge_private_data): Validize bfd_get_arch_size.
Tweak section-contents-type-mismatch message.
(shmedia_prepare_reloc): Add ATTRIBUTE_UNUSED markers.
Validize reloc-types.
* elf64-sh64.c: New file.
* targets.c (bfd_elf64_sh64_vec, bfd_elf64_sh64l_vec): Declare.
* Makefile.am (BFD64_BACKENDS): Add elf64-sh64.lo.
(BFD64_BACKENDS_CFILES): Add elf64-sh64.c.
Regenerate dependencies.
* Makefile.in: Regenerate.
* config.bfd (sh64-*-elf*): Add bfd_elf64_sh64_vec and
bfd_elf64_sh64l_vec.
* configure.in: Handle bfd_elf64_sh64_vec and
bfd_elf64_sh64l_vec.
* configure: Regenerate.
* po/POTFILES.in: Regenerate.
* po/bfd.pot: Regenerate.
2000-11-29  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh64.c (sh64_elf_set_mach_from_flags): Do not recognize
anything else but EF_SH64 and EF_SH64_ABI64.
(sh64_elf_merge_private_data): Emit error for anything else but
EF_SH64 and EF_SH64_ABI64.
* config.bfd: Remove bfd_elf32_shblin_vec and bfd_elf32_shlin_vec
from targ_selvecs.
* configure.in: Add cofflink.lo to bfd_elf32_sh64_vec and
bfd_elf32_sh64l_vec as a temporary measure.
* configure: Regenerate.
2000-11-27  Hans-Peter Nilsson	<hpn@@cygnus.com>
* cpu-sh.c (arch_info_struct): Include sh5 item
unconditionalized.
* config.bfd (sh64-*-elf*): Do not set targ_cflags.
Add targ_selvecs bfd_elf32_sh_vec, bfd_elf32_shl_vec,
bfd_elf32_shblin_vec and bfd_elf32_shlin_vec.
* elf32-sh64.c: Tweak comments.
(sh64_elf_set_mach_from_flags): Recognize all machine flags that
are proper subsets of SH64 as bfd_mach_sh5.  Add EF_SH64_ABI64.
(sh64_elf_copy_private_data_internal): Wrap long line.
(sh64_elf_merge_private_data): Rewrite to allow objects from
SH64 subsets to be linked together.
(INCLUDE_SHMEDIA): Define.
* elf32-sh.c (sh_elf_relocate_section) <local symbol>:
Parenthesize plus-expression inside or-expression.
<global symbol>: Ditto.
(sh_elf_set_mach_from_flags): Remove code refusing
deleted EF_SH64_32BIT_ABI flag.
2000-11-26  Hans-Peter Nilsson	<hpn@@cygnus.com>
* elf32-sh.c (sh_elf_howto_table) <R_SH_IMM_LOW16_PCREL,
R_SH_IMM_MEDLOW16_PCREL, R_SH_IMM_MEDHI16_PCREL,
R_SH_IMM_HI16_PCREL, R_SH_64_PCREL>: Set pcrel_offset to true.
(sh_elf_relocate_section) <local symbol>: Or 1 in
calculation of relocation if sym->st_other & STO_SH5_ISA32.
<global symbol>: Ditto if h->other & STO_SH5_ISA32.
* elf32-sh64.c (shmedia_prepare_reloc): Add rel->r_addend to
relocation.
2000-11-24  Hans-Peter Nilsson	<hpn@@cygnus.com>
* Makefile.am (BFD32_BACKENDS): Add elf32-sh64.lo.
(BFD32_BACKENDS_CFILES): Add elf32-sh64.c.
Regenerate dependencies.
* Makefile.in: Regenerate.
* archures.c: Add bfd_mach_sh5.
* config.bfd: Map targ_cpu sh* to bfd_sh_arch.
Handle sh64-*-elf*.  Set targ_cflags to -DINCLUDE_SHMEDIA.
* configure.in: Handle bfd_elf32_sh64_vec and bfd_elf32_sh64l_vec.
* configure: Regenerate.
* reloc.c (BFD_RELOC_SH_SHMEDIA_CODE, BFD_RELOC_SH_IMMU5,
BFD_RELOC_SH_IMMS6, BFD_RELOC_SH_IMMS6BY32, BFD_RELOC_SH_IMMU6,
BFD_RELOC_SH_IMMS10, BFD_RELOC_SH_IMMS10BY2,
BFD_RELOC_SH_IMMS10BY4, BFD_RELOC_SH_IMMS10BY8,
BFD_RELOC_SH_IMMS16, BFD_RELOC_SH_IMMU16, BFD_RELOC_SH_IMM_LOW16,
BFD_RELOC_SH_IMM_LOW16_PCREL, BFD_RELOC_SH_IMM_MEDLOW16,
BFD_RELOC_SH_IMM_MEDLOW16_PCREL, BFD_RELOC_SH_IMM_MEDHI16,
BFD_RELOC_SH_IMM_MEDHI16_PCREL, BFD_RELOC_SH_IMM_HI16,
BFD_RELOC_SH_IMM_HI16_PCREL, BFD_RELOC_SH_PT_16): New relocations.
* cpu-sh.c [INCLUDE_SHMEDIA] (arch_info_struct): Define and link
in item for SH5.
* elf32-sh.c [INCLUDE_SHMEDIA] (sh_elf_howto_table): Add howto items
for SHmedia relocs.
[INCLUDE_SHMEDIA] (sh_rel): Add mappings for SHmedia relocs.
[INCLUDE_SHMEDIA] (sh_elf_relocate_section) [default]: Call
shmedia_prepare_reloc, goto final_link_relocate if it returns
non-zero, else fail as before.
(sh_elf_set_mach_from_flags): Provide function only if not defined
as macro.  Do not recognize objects with EF_SH64_32BIT_ABI set.
(sh_elf_set_private_flags): Provide function only if not defined
as a macro.
(sh_elf_copy_private_data): Similar.
(sh_elf_merge_private_data): Similar.
* section.c (SEC_SH_ISA_SHMEDIA): New.
* targets.c (bfd_elf32_sh64_vec, bfd_elf32_sh64l_vec): Declare.
* elf32-sh64.c: New file.
* libbfd.h: Regenerate.
* bfd-in2.h: Regenerate.
* po/POTFILES.in: Regenerate.
* po/bfd.pot: Regenerate.
* bfd-in2.h: Regenerate.
* libbfd.h: Regenerate.
@
text
@d87 1
a87 1
  struct elf_sh_pcrel_relocs_copied *pcrel_relocs_copied;
d148 19
d1751 2
a1752 4
		= _bfd_elf_section_offset (output_bfd,
					   &elf_hash_table (info)->stab_info,
					   input_section,
					   rel->r_offset);
@


1.1.2.1
log
@* elf32-sh.c: Added missing prototypes.
* elf32-sh64.c: Likewise.
(sh_elf_align_loads): Mark unused args as such.
* elf64-sh64.c: Added missing prototypes.
(struct elf_sh64_link_hash_entry): Fix typo.
(sh_elf64_relocate_section): Fix info argument passed to
_bfd_elf_section_offset.
@
text
@d87 1
a87 1
  struct elf_sh64_pcrel_relocs_copied *pcrel_relocs_copied;
a147 19
static struct bfd_hash_entry *sh64_elf64_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *sh64_elf64_link_hash_table_create
  PARAMS ((bfd *));
inline static void movi_shori_putval PARAMS ((bfd *, unsigned long, char *));
inline static void movi_3shori_putval PARAMS ((bfd *, bfd_vma, char *));
static boolean sh64_elf64_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean sh64_elf64_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *info, struct elf_link_hash_entry *));
static boolean sh64_elf64_discard_copies
  PARAMS ((struct elf_sh64_link_hash_entry *, PTR));
static boolean sh64_elf64_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean sh64_elf64_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static boolean sh64_elf64_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d1732 4
a1735 2
		= _bfd_elf_section_offset (output_bfd, info,
					   input_section, rel->r_offset);
@


1.1.2.2
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1748 1
	      relocate = false;
a1755 2
	      else if (outrel.r_offset == (bfd_vma) -1)
		skip = true, relocate = true;
d1761 4
a1764 1
		memset (&outrel, 0, sizeof outrel);
d1768 1
d1788 1
@


1.1.2.3
log
@	* elf64-sh64.c (sh_elf64_relocate_section): Fix a typo from my
	last patch.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d1757 1
a1757 1
	      else if (outrel.r_offset == (bfd_vma) -2)
@


1.1.2.4
log
@Merge from mainline.
@
text
@a3609 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_sh64_link_hash_entry *) h->root.root.u.i.link;

@


1.1.2.5
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d2932 1
a2932 2
  if (ELF_ST_TYPE (sym->st_info) == STT_DATALABEL
      && info->hash->creator->flavour == bfd_target_elf_flavour)
@


