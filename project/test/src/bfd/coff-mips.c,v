head	1.43;
access;
symbols
	sid-snapshot-20180601:1.43
	sid-snapshot-20180501:1.43
	sid-snapshot-20180401:1.43
	sid-snapshot-20180301:1.43
	sid-snapshot-20180201:1.43
	sid-snapshot-20180101:1.43
	sid-snapshot-20171201:1.43
	sid-snapshot-20171101:1.43
	sid-snapshot-20171001:1.43
	sid-snapshot-20170901:1.43
	sid-snapshot-20170801:1.43
	sid-snapshot-20170701:1.43
	sid-snapshot-20170601:1.43
	sid-snapshot-20170501:1.43
	sid-snapshot-20170401:1.43
	sid-snapshot-20170301:1.43
	sid-snapshot-20170201:1.43
	sid-snapshot-20170101:1.43
	sid-snapshot-20161201:1.43
	sid-snapshot-20161101:1.43
	sid-snapshot-20160901:1.43
	sid-snapshot-20160801:1.43
	sid-snapshot-20160701:1.43
	sid-snapshot-20160601:1.43
	sid-snapshot-20160501:1.43
	sid-snapshot-20160401:1.43
	sid-snapshot-20160301:1.43
	sid-snapshot-20160201:1.43
	sid-snapshot-20160101:1.43
	sid-snapshot-20151201:1.43
	sid-snapshot-20151101:1.43
	sid-snapshot-20151001:1.43
	sid-snapshot-20150901:1.43
	sid-snapshot-20150801:1.43
	sid-snapshot-20150701:1.43
	sid-snapshot-20150601:1.43
	sid-snapshot-20150501:1.43
	sid-snapshot-20150401:1.43
	sid-snapshot-20150301:1.43
	sid-snapshot-20150201:1.43
	sid-snapshot-20150101:1.43
	sid-snapshot-20141201:1.43
	sid-snapshot-20141101:1.43
	sid-snapshot-20141001:1.43
	sid-snapshot-20140901:1.43
	sid-snapshot-20140801:1.43
	sid-snapshot-20140701:1.43
	sid-snapshot-20140601:1.43
	sid-snapshot-20140501:1.43
	sid-snapshot-20140401:1.43
	sid-snapshot-20140301:1.43
	sid-snapshot-20140201:1.43
	sid-snapshot-20140101:1.43
	sid-snapshot-20131201:1.43
	sid-snapshot-20131101:1.43
	sid-snapshot-20131001:1.43
	binutils-2_24-branch:1.43.0.4
	binutils-2_24-branchpoint:1.43
	binutils-2_21_1:1.38
	sid-snapshot-20130901:1.43
	gdb_7_6_1-2013-08-30-release:1.43
	sid-snapshot-20130801:1.43
	sid-snapshot-20130701:1.43
	sid-snapshot-20130601:1.43
	sid-snapshot-20130501:1.43
	gdb_7_6-2013-04-26-release:1.43
	sid-snapshot-20130401:1.43
	binutils-2_23_2:1.42
	gdb_7_6-branch:1.43.0.2
	gdb_7_6-2013-03-12-branchpoint:1.43
	sid-snapshot-20130301:1.43
	sid-snapshot-20130201:1.43
	sid-snapshot-20130101:1.42
	sid-snapshot-20121201:1.42
	gdb_7_5_1-2012-11-29-release:1.42
	binutils-2_23_1:1.42
	sid-snapshot-20121101:1.42
	binutils-2_23:1.42
	sid-snapshot-20121001:1.42
	sid-snapshot-20120901:1.42
	gdb_7_5-2012-08-17-release:1.42
	sid-snapshot-20120801:1.42
	binutils-2_23-branch:1.42.0.4
	binutils-2_23-branchpoint:1.42
	gdb_7_5-branch:1.42.0.2
	gdb_7_5-2012-07-18-branchpoint:1.42
	sid-snapshot-20120701:1.41
	sid-snapshot-20120601:1.41
	sid-snapshot-20120501:1.41
	binutils-2_22_branch:1.41.0.6
	gdb_7_4_1-2012-04-26-release:1.41
	sid-snapshot-20120401:1.41
	sid-snapshot-20120301:1.41
	sid-snapshot-20120201:1.41
	gdb_7_4-2012-01-24-release:1.41
	sid-snapshot-20120101:1.41
	gdb_7_4-branch:1.41.0.4
	gdb_7_4-2011-12-13-branchpoint:1.41
	sid-snapshot-20111201:1.41
	binutils-2_22:1.41
	sid-snapshot-20111101:1.41
	sid-snapshot-20111001:1.41
	binutils-2_22-branch:1.41.0.2
	binutils-2_22-branchpoint:1.41
	gdb_7_3_1-2011-09-04-release:1.38
	sid-snapshot-20110901:1.41
	sid-snapshot-20110801:1.40
	gdb_7_3-2011-07-26-release:1.38
	sid-snapshot-20110701:1.39
	sid-snapshot-20110601:1.38
	sid-snapshot-20110501:1.38
	gdb_7_3-branch:1.38.0.12
	gdb_7_3-2011-04-01-branchpoint:1.38
	sid-snapshot-20110401:1.38
	sid-snapshot-20110301:1.38
	sid-snapshot-20110201:1.38
	sid-snapshot-20110101:1.38
	binutils-2_21:1.38
	sid-snapshot-20101201:1.38
	binutils-2_21-branch:1.38.0.10
	binutils-2_21-branchpoint:1.38
	sid-snapshot-20101101:1.38
	sid-snapshot-20101001:1.38
	binutils-2_20_1:1.38
	gdb_7_2-2010-09-02-release:1.38
	sid-snapshot-20100901:1.38
	sid-snapshot-20100801:1.38
	gdb_7_2-branch:1.38.0.8
	gdb_7_2-2010-07-07-branchpoint:1.38
	sid-snapshot-20100701:1.38
	sid-snapshot-20100601:1.38
	sid-snapshot-20100501:1.38
	sid-snapshot-20100401:1.38
	gdb_7_1-2010-03-18-release:1.38
	sid-snapshot-20100301:1.38
	gdb_7_1-branch:1.38.0.6
	gdb_7_1-2010-02-18-branchpoint:1.38
	sid-snapshot-20100201:1.38
	sid-snapshot-20100101:1.38
	gdb_7_0_1-2009-12-22-release:1.38
	sid-snapshot-20091201:1.38
	sid-snapshot-20091101:1.38
	binutils-2_20:1.38
	gdb_7_0-2009-10-06-release:1.38
	sid-snapshot-20091001:1.38
	gdb_7_0-branch:1.38.0.4
	gdb_7_0-2009-09-16-branchpoint:1.38
	arc-sim-20090309:1.34
	binutils-arc-20081103-branch:1.35.0.12
	binutils-arc-20081103-branchpoint:1.35
	binutils-2_20-branch:1.38.0.2
	binutils-2_20-branchpoint:1.38
	sid-snapshot-20090901:1.37
	sid-snapshot-20090801:1.37
	msnyder-checkpoint-072509-branch:1.37.0.4
	msnyder-checkpoint-072509-branchpoint:1.37
	sid-snapshot-20090701:1.37
	dje-cgen-play1-branch:1.37.0.2
	dje-cgen-play1-branchpoint:1.37
	sid-snapshot-20090601:1.37
	sid-snapshot-20090501:1.37
	sid-snapshot-20090401:1.36
	arc-20081103-branch:1.35.0.10
	arc-20081103-branchpoint:1.35
	arc-insight_6_8-branch:1.34.0.10
	arc-insight_6_8-branchpoint:1.34
	insight_6_8-branch:1.34.0.8
	insight_6_8-branchpoint:1.34
	sid-snapshot-20090301:1.36
	binutils-2_19_1:1.35
	sid-snapshot-20090201:1.35
	sid-snapshot-20090101:1.35
	reverse-20081226-branch:1.35.0.8
	reverse-20081226-branchpoint:1.35
	sid-snapshot-20081201:1.35
	multiprocess-20081120-branch:1.35.0.6
	multiprocess-20081120-branchpoint:1.35
	sid-snapshot-20081101:1.35
	binutils-2_19:1.35
	sid-snapshot-20081001:1.35
	reverse-20080930-branch:1.35.0.4
	reverse-20080930-branchpoint:1.35
	binutils-2_19-branch:1.35.0.2
	binutils-2_19-branchpoint:1.35
	sid-snapshot-20080901:1.35
	sid-snapshot-20080801:1.35
	reverse-20080717-branch:1.34.0.6
	reverse-20080717-branchpoint:1.34
	sid-snapshot-20080701:1.34
	msnyder-reverse-20080609-branch:1.34.0.4
	msnyder-reverse-20080609-branchpoint:1.34
	drow-reverse-20070409-branch:1.31.0.2
	drow-reverse-20070409-branchpoint:1.31
	sid-snapshot-20080601:1.34
	sid-snapshot-20080501:1.34
	sid-snapshot-20080403:1.34
	sid-snapshot-20080401:1.34
	gdb_6_8-2008-03-27-release:1.34
	sid-snapshot-20080301:1.34
	gdb_6_8-branch:1.34.0.2
	gdb_6_8-2008-02-26-branchpoint:1.34
	sid-snapshot-20080201:1.34
	sid-snapshot-20080101:1.33
	sid-snapshot-20071201:1.33
	sid-snapshot-20071101:1.33
	gdb_6_7_1-2007-10-29-release:1.33
	gdb_6_7-2007-10-10-release:1.33
	sid-snapshot-20071001:1.33
	gdb_6_7-branch:1.33.0.4
	gdb_6_7-2007-09-07-branchpoint:1.33
	binutils-2_18:1.33
	binutils-2_18-branch:1.33.0.2
	binutils-2_18-branchpoint:1.33
	insight_6_6-20070208-release:1.30
	binutils-csl-coldfire-4_1-32:1.30
	binutils-csl-sourcerygxx-4_1-32:1.30
	gdb_6_6-2006-12-18-release:1.30
	binutils-csl-innovasic-fido-3_4_4-33:1.30
	binutils-csl-sourcerygxx-3_4_4-32:1.28
	binutils-csl-coldfire-4_1-30:1.30
	binutils-csl-sourcerygxx-4_1-30:1.30
	binutils-csl-coldfire-4_1-28:1.30
	binutils-csl-sourcerygxx-4_1-29:1.30
	binutils-csl-sourcerygxx-4_1-28:1.30
	gdb_6_6-branch:1.30.0.32
	gdb_6_6-2006-11-15-branchpoint:1.30
	binutils-csl-arm-2006q3-27:1.30
	binutils-csl-sourcerygxx-4_1-27:1.30
	binutils-csl-arm-2006q3-26:1.30
	binutils-csl-sourcerygxx-4_1-26:1.30
	binutils-csl-sourcerygxx-4_1-25:1.30
	binutils-csl-sourcerygxx-4_1-24:1.30
	binutils-csl-sourcerygxx-4_1-23:1.30
	insight_6_5-20061003-release:1.30
	gdb-csl-symbian-6_4_50_20060226-12:1.30
	binutils-csl-sourcerygxx-4_1-21:1.30
	binutils-csl-arm-2006q3-21:1.30
	binutils-csl-sourcerygxx-4_1-22:1.30
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.30
	binutils-csl-sourcerygxx-4_1-20:1.30
	binutils-csl-arm-2006q3-19:1.30
	binutils-csl-sourcerygxx-4_1-19:1.30
	binutils-csl-sourcerygxx-4_1-18:1.30
	binutils-csl-renesas-4_1-9:1.30
	gdb-csl-sourcerygxx-3_4_4-25:1.30
	binutils-csl-sourcerygxx-3_4_4-25:1.28
	nickrob-async-20060828-mergepoint:1.30
	gdb-csl-symbian-6_4_50_20060226-11:1.30
	binutils-csl-renesas-4_1-8:1.30
	binutils-csl-renesas-4_1-7:1.30
	binutils-csl-renesas-4_1-6:1.30
	gdb-csl-sourcerygxx-4_1-17:1.30
	binutils-csl-sourcerygxx-4_1-17:1.30
	gdb-csl-20060226-branch-local-2:1.30
	gdb-csl-sourcerygxx-4_1-14:1.30
	binutils-csl-sourcerygxx-4_1-14:1.30
	binutils-csl-sourcerygxx-4_1-15:1.30
	gdb-csl-sourcerygxx-4_1-13:1.30
	binutils-csl-sourcerygxx-4_1-13:1.30
	binutils-2_17:1.30
	gdb-csl-sourcerygxx-4_1-12:1.30
	binutils-csl-sourcerygxx-4_1-12:1.30
	gdb-csl-sourcerygxx-3_4_4-21:1.30
	binutils-csl-sourcerygxx-3_4_4-21:1.30
	gdb_6_5-20060621-release:1.30
	binutils-csl-wrs-linux-3_4_4-24:1.28
	binutils-csl-wrs-linux-3_4_4-23:1.28
	gdb-csl-sourcerygxx-4_1-9:1.30
	binutils-csl-sourcerygxx-4_1-9:1.30
	gdb-csl-sourcerygxx-4_1-8:1.30
	binutils-csl-sourcerygxx-4_1-8:1.30
	gdb-csl-sourcerygxx-4_1-7:1.30
	binutils-csl-sourcerygxx-4_1-7:1.30
	gdb-csl-arm-2006q1-6:1.30
	binutils-csl-arm-2006q1-6:1.30
	gdb-csl-sourcerygxx-4_1-6:1.30
	binutils-csl-sourcerygxx-4_1-6:1.30
	binutils-csl-wrs-linux-3_4_4-22:1.28
	gdb-csl-symbian-6_4_50_20060226-10:1.30
	gdb-csl-symbian-6_4_50_20060226-9:1.30
	gdb-csl-symbian-6_4_50_20060226-8:1.30
	gdb-csl-coldfire-4_1-11:1.30
	binutils-csl-coldfire-4_1-11:1.30
	gdb-csl-sourcerygxx-3_4_4-19:1.30
	binutils-csl-sourcerygxx-3_4_4-19:1.30
	gdb-csl-coldfire-4_1-10:1.30
	gdb_6_5-branch:1.30.0.30
	gdb_6_5-2006-05-14-branchpoint:1.30
	binutils-csl-coldfire-4_1-10:1.30
	gdb-csl-sourcerygxx-4_1-5:1.30
	binutils-csl-sourcerygxx-4_1-5:1.30
	nickrob-async-20060513-branch:1.30.0.28
	nickrob-async-20060513-branchpoint:1.30
	gdb-csl-sourcerygxx-4_1-4:1.30
	binutils-csl-sourcerygxx-4_1-4:1.30
	msnyder-reverse-20060502-branch:1.30.0.26
	msnyder-reverse-20060502-branchpoint:1.30
	binutils-csl-wrs-linux-3_4_4-21:1.28
	gdb-csl-morpho-4_1-4:1.30
	binutils-csl-morpho-4_1-4:1.30
	gdb-csl-sourcerygxx-3_4_4-17:1.30
	binutils-csl-sourcerygxx-3_4_4-17:1.30
	binutils-csl-wrs-linux-3_4_4-20:1.28
	readline_5_1-import-branch:1.30.0.24
	readline_5_1-import-branchpoint:1.30
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.30
	binutils-2_17-branch:1.30.0.22
	binutils-2_17-branchpoint:1.30
	gdb-csl-symbian-20060226-branch:1.30.0.20
	gdb-csl-symbian-20060226-branchpoint:1.30
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.30
	msnyder-reverse-20060331-branch:1.30.0.18
	msnyder-reverse-20060331-branchpoint:1.30
	binutils-csl-2_17-branch:1.30.0.16
	binutils-csl-2_17-branchpoint:1.30
	gdb-csl-available-20060303-branch:1.30.0.14
	gdb-csl-available-20060303-branchpoint:1.30
	gdb-csl-20060226-branch:1.30.0.12
	gdb-csl-20060226-branchpoint:1.30
	gdb_6_4-20051202-release:1.30
	msnyder-fork-checkpoint-branch:1.30.0.10
	msnyder-fork-checkpoint-branchpoint:1.30
	gdb-csl-gxxpro-6_3-branch:1.30.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.30
	gdb_6_4-branch:1.30.0.6
	gdb_6_4-2005-11-01-branchpoint:1.30
	gdb-csl-arm-20051020-branch:1.30.0.4
	gdb-csl-arm-20051020-branchpoint:1.30
	binutils-csl-gxxpro-3_4-branch:1.28.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.28
	binutils-2_16_1:1.28
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.28
	binutils-csl-arm-2005q1b:1.28
	binutils-2_16:1.28
	gdb-csl-arm-20050325-2005-q1a:1.28
	binutils-csl-arm-2005q1a:1.28
	csl-arm-20050325-branch:1.28.0.6
	csl-arm-20050325-branchpoint:1.28
	binutils-csl-arm-2005q1-branch:1.28.0.4
	binutils-csl-arm-2005q1-branchpoint:1.28
	binutils-2_16-branch:1.28.0.2
	binutils-2_16-branchpoint:1.28
	csl-arm-2004-q3d:1.28
	gdb_6_3-20041109-release:1.27
	gdb_6_3-branch:1.27.0.2
	gdb_6_3-20041019-branchpoint:1.27
	csl-arm-2004-q3:1.27
	drow_intercu-merge-20040921:1.27
	drow_intercu-merge-20040915:1.27
	jimb-gdb_6_2-e500-branch:1.26.0.6
	jimb-gdb_6_2-e500-branchpoint:1.26
	gdb_6_2-20040730-release:1.26
	gdb_6_2-branch:1.26.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.26
	gdb_6_1_1-20040616-release:1.21
	binutils-2_15:1.21
	binutils-2_15-branchpoint:1.21
	csl-arm-2004-q1a:1.24
	csl-arm-2004-q1:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.20
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.18
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.14
	drow_intercu-20040221-branchpoint:1.21
	binutils-2_15-branch:1.21.0.12
	cagney_bfdfile-20040213-branch:1.21.0.10
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.8
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	csl-arm-2003-q4:1.21
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.20
	kettenis_sparc-20030918-branch:1.21.0.6
	kettenis_sparc-20030918-branchpoint:1.21
	carlton_dictionary-20030917-merge:1.21
	ezannoni_pie-20030916-branchpoint:1.21
	ezannoni_pie-20030916-branch:1.21.0.4
	cagney_x86i386-20030821-branch:1.21.0.2
	cagney_x86i386-20030821-branchpoint:1.21
	carlton_dictionary-20030805-merge:1.21
	carlton_dictionary-20030627-merge:1.21
	gdb_6_0-branch:1.20.0.36
	gdb_6_0-2003-06-23-branchpoint:1.20
	jimb-ppc64-linux-20030613-branch:1.20.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.20
	binutils-2_14:1.20
	cagney_convert-20030606-branch:1.20.0.32
	cagney_convert-20030606-branchpoint:1.20
	cagney_writestrings-20030508-branch:1.20.0.30
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.26
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	binutils-2_14-branch:1.20.0.22
	binutils-2_14-branchpoint:1.20
	kettenis_i386newframe-20030419-branch:1.20.0.20
	kettenis_i386newframe-20030419-branchpoint:1.20
	carlton_dictionary-20030416-merge:1.20
	cagney_frameaddr-20030409-mergepoint:1.20
	kettenis_i386newframe-20030406-branch:1.20.0.18
	kettenis_i386newframe-20030406-branchpoint:1.20
	cagney_frameaddr-20030403-branchpoint:1.20
	cagney_frameaddr-20030403-branch:1.20.0.16
	cagney_framebase-20030330-mergepoint:1.20
	cagney_framebase-20030326-branch:1.20.0.14
	cagney_framebase-20030326-branchpoint:1.20
	cagney_lazyid-20030317-branch:1.20.0.12
	cagney_lazyid-20030317-branchpoint:1.20
	kettenis-i386newframe-20030316-mergepoint:1.20
	offbyone-20030313-branch:1.20.0.10
	offbyone-20030313-branchpoint:1.20
	kettenis-i386newframe-20030308-branch:1.20.0.8
	kettenis-i386newframe-20030308-branchpoint:1.20
	carlton_dictionary-20030305-merge:1.20
	cagney_offbyone-20030303-branch:1.20.0.6
	cagney_offbyone-20030303-branchpoint:1.20
	carlton_dictionary-20030207-merge:1.20
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	binutils-2_13_2_1:1.19
	binutils-2_13_2:1.19
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.19
	binutils-2_13_1:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.14
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.12
	carlton_dictionary-20020920-branchpoint:1.19
	sid-20020905-branchpoint:1.19
	sid-20020905-branch:1.19.0.10
	gdb_5_3-branch:1.19.0.8
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.6
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.4
	readline_4_3-import-branchpoint:1.19
	binutils-2_13:1.19
	gdb_5_2_1-2002-07-23-release:1.15
	binutils-2_13-branchpoint:1.19
	binutils-2_13-branch:1.19.0.2
	kseitz_interps-20020528-branch:1.15.0.10
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.8
	cagney_regbuf-20020515-branchpoint:1.15
	binutils-2_12_1:1.15
	jimb-macro-020506-branch:1.15.0.6
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.15
	binutils-2_12:1.15
	gdb_5_2-branch:1.15.0.4
	gdb_5_2-2002-03-03-branchpoint:1.15
	binutils-2_12-branch:1.15.0.2
	binutils-2_12-branchpoint:1.15
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	binutils-2_11_2:1.9.2.1
	binutils-2_11_1:1.9.2.1
	binutils-2_11:1.9
	x86_64versiong3:1.9
	binutils-2_11-branch:1.9.0.2
	insight-precleanup-2001-01-01:1.8
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	gdb-premipsmulti-2000-06-06-branch:1.7.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.7
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.4
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.43
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.13.14.22.43;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.11.15.03.04;	author clm;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.36;

1.36
date	2009.02.18.18.23.06;	author davek;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.21.03.48.10;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.04.15.53.02;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.21.15.28.16;	author hjl;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.29.13.46.29;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.24.06.12.24;	author cgd;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.21.20.52.25;	author cgd;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches
	1.21.14.1;
next	1.20;

1.20
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.19.12.1
	1.19.14.1;
next	1.18;

1.18
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.05.04.22.27;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.05.03.43.09;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.25.12.12.23;	author amodra;	state Exp;
branches
	1.15.8.1
	1.15.10.1;
next	1.14;

1.14
date	2001.12.02.13.14.48;	author ths;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.23.11.45.52;	author kazu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.11.11.19.03.23;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.28.13.50.57;	author cpopetz;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.11.13.07.56;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	99.09.10.23.25.50;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.40;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.21.14.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.19.12.1
date	2002.12.23.19.37.27;	author carlton;	state Exp;
branches;
next	1.19.12.2;

1.19.12.2
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	;

1.19.14.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.15.8.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.15.10.1
date	2002.06.20.01.29.45;	author kseitz;	state Exp;
branches;
next	1.15.10.2;

1.15.10.2
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	;

1.9.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for MIPS Extended-Coff files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2011, 2012
   Free Software Foundation, Inc.
   Original version by Per Bothner.
   Full support added by Ian Lance Taylor, ian@@cygnus.com.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "coff/mips.h"
#include "libcoff.h"
#include "libecoff.h"

/* Prototypes for static functions.  */
static bfd_reloc_status_type
mips_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type
mips_refhi_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type
mips_reflo_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type
mips_gprel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);


/* ECOFF has COFF sections, but the debugging information is stored in
   a completely different format.  ECOFF targets use some of the
   swapping routines from coffswap.h, and some of the generic COFF
   routines in coffgen.c, but, unlike the real COFF targets, do not
   use coffcode.h itself.

   Get the generic COFF swapping routines, except for the reloc,
   symbol, and lineno ones.  Give them ECOFF names.  */
#define MIPSECOFF
#define NO_COFF_RELOCS
#define NO_COFF_SYMBOLS
#define NO_COFF_LINENOS
#define coff_swap_filehdr_in  mips_ecoff_swap_filehdr_in
#define coff_swap_filehdr_out mips_ecoff_swap_filehdr_out
#define coff_swap_aouthdr_in  mips_ecoff_swap_aouthdr_in
#define coff_swap_aouthdr_out mips_ecoff_swap_aouthdr_out
#define coff_swap_scnhdr_in   mips_ecoff_swap_scnhdr_in
#define coff_swap_scnhdr_out  mips_ecoff_swap_scnhdr_out

#include "coffswap.h"

/* Get the ECOFF swapping routines.  */
#define ECOFF_32
#include "ecoffswap.h"

/* How to process the various relocs types.  */

static reloc_howto_type mips_howto_table[] =
{
  /* Reloc type 0 is ignored.  The reloc reading code ensures that
     this is a reference to the .abs section, which will cause
     bfd_perform_relocation to do nothing.  */
  HOWTO (MIPS_R_IGNORE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "IGNORE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit reference to a symbol, normally from a data section.  */
  HOWTO (MIPS_R_REFHALF,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_generic_reloc,	/* special_function */
	 "REFHALF",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 32 bit reference to a symbol, normally from a data section.  */
  HOWTO (MIPS_R_REFWORD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_generic_reloc,	/* special_function */
	 "REFWORD",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 26 bit absolute jump address.  */
  HOWTO (MIPS_R_JMPADDR,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips_generic_reloc,	/* special_function */
	 "JMPADDR",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high 16 bits of a symbol value.  Handled by the function
     mips_refhi_reloc.  */
  HOWTO (MIPS_R_REFHI,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_refhi_reloc,	/* special_function */
	 "REFHI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The low 16 bits of a symbol value.  */
  HOWTO (MIPS_R_REFLO,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_reflo_reloc,	/* special_function */
	 "REFLO",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A reference to an offset from the gp register.  Handled by the
     function mips_gprel_reloc.  */
  HOWTO (MIPS_R_GPREL,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_gprel_reloc,	/* special_function */
	 "GPREL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A reference to a literal using an offset from the gp register.
     Handled by the function mips_gprel_reloc.  */
  HOWTO (MIPS_R_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_gprel_reloc,	/* special_function */
	 "LITERAL",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (8),
  EMPTY_HOWTO (9),
  EMPTY_HOWTO (10),
  EMPTY_HOWTO (11),

  /* FIXME: This relocation is used (internally only) to represent branches
     when assembling.  It should never appear in output files, and
     be removed.  (It used to be used for embedded-PIC support.)  */
  HOWTO (MIPS_R_PCREL16,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_generic_reloc,	/* special_function */
	 "PCREL16",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */
};

#define MIPS_HOWTO_COUNT \
  (sizeof mips_howto_table / sizeof mips_howto_table[0])

/* See whether the magic number matches.  */

static bfd_boolean
mips_ecoff_bad_format_hook (bfd * abfd, void * filehdr)
{
  struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;

  switch (internal_f->f_magic)
    {
    case MIPS_MAGIC_1:
      /* I don't know what endianness this implies.  */
      return TRUE;

    case MIPS_MAGIC_BIG:
    case MIPS_MAGIC_BIG2:
    case MIPS_MAGIC_BIG3:
      return bfd_big_endian (abfd);

    case MIPS_MAGIC_LITTLE:
    case MIPS_MAGIC_LITTLE2:
    case MIPS_MAGIC_LITTLE3:
      return bfd_little_endian (abfd);

    default:
      return FALSE;
    }
}

/* Reloc handling.  MIPS ECOFF relocs are packed into 8 bytes in
   external form.  They use a bit which indicates whether the symbol
   is external.  */

/* Swap a reloc in.  */

static void
mips_ecoff_swap_reloc_in (bfd *  abfd,
			  void * ext_ptr,
			  struct internal_reloc *intern)
{
  const RELOC *ext = (RELOC *) ext_ptr;

  intern->r_vaddr = H_GET_32 (abfd, ext->r_vaddr);
  if (bfd_header_big_endian (abfd))
    {
      intern->r_symndx = (((int) ext->r_bits[0]
			   << RELOC_BITS0_SYMNDX_SH_LEFT_BIG)
			  | ((int) ext->r_bits[1]
			     << RELOC_BITS1_SYMNDX_SH_LEFT_BIG)
			  | ((int) ext->r_bits[2]
			     << RELOC_BITS2_SYMNDX_SH_LEFT_BIG));
      intern->r_type = ((ext->r_bits[3] & RELOC_BITS3_TYPE_BIG)
			>> RELOC_BITS3_TYPE_SH_BIG);
      intern->r_extern = (ext->r_bits[3] & RELOC_BITS3_EXTERN_BIG) != 0;
    }
  else
    {
      intern->r_symndx = (((int) ext->r_bits[0]
			   << RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE)
			  | ((int) ext->r_bits[1]
			     << RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE)
			  | ((int) ext->r_bits[2]
			     << RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE));
      intern->r_type = (((ext->r_bits[3] & RELOC_BITS3_TYPE_LITTLE)
			 >> RELOC_BITS3_TYPE_SH_LITTLE)
			| ((ext->r_bits[3] & RELOC_BITS3_TYPEHI_LITTLE)
			   << RELOC_BITS3_TYPEHI_SH_LITTLE));
      intern->r_extern = (ext->r_bits[3] & RELOC_BITS3_EXTERN_LITTLE) != 0;
    }
}

/* Swap a reloc out.  */

static void
mips_ecoff_swap_reloc_out (bfd * abfd,
			   const struct internal_reloc * intern,
			   void * dst)
{
  RELOC *ext = (RELOC *) dst;
  long r_symndx;

  BFD_ASSERT (intern->r_extern
	      || (intern->r_symndx >= 0 && intern->r_symndx <= 12));

  r_symndx = intern->r_symndx;

  H_PUT_32 (abfd, intern->r_vaddr, ext->r_vaddr);
  if (bfd_header_big_endian (abfd))
    {
      ext->r_bits[0] = r_symndx >> RELOC_BITS0_SYMNDX_SH_LEFT_BIG;
      ext->r_bits[1] = r_symndx >> RELOC_BITS1_SYMNDX_SH_LEFT_BIG;
      ext->r_bits[2] = r_symndx >> RELOC_BITS2_SYMNDX_SH_LEFT_BIG;
      ext->r_bits[3] = (((intern->r_type << RELOC_BITS3_TYPE_SH_BIG)
			 & RELOC_BITS3_TYPE_BIG)
			| (intern->r_extern ? RELOC_BITS3_EXTERN_BIG : 0));
    }
  else
    {
      ext->r_bits[0] = r_symndx >> RELOC_BITS0_SYMNDX_SH_LEFT_LITTLE;
      ext->r_bits[1] = r_symndx >> RELOC_BITS1_SYMNDX_SH_LEFT_LITTLE;
      ext->r_bits[2] = r_symndx >> RELOC_BITS2_SYMNDX_SH_LEFT_LITTLE;
      ext->r_bits[3] = (((intern->r_type << RELOC_BITS3_TYPE_SH_LITTLE)
			 & RELOC_BITS3_TYPE_LITTLE)
			| ((intern->r_type >> RELOC_BITS3_TYPEHI_SH_LITTLE
			    & RELOC_BITS3_TYPEHI_LITTLE))
			| (intern->r_extern ? RELOC_BITS3_EXTERN_LITTLE : 0));
    }
}

/* Finish canonicalizing a reloc.  Part of this is generic to all
   ECOFF targets, and that part is in ecoff.c.  The rest is done in
   this backend routine.  It must fill in the howto field.  */

static void
mips_adjust_reloc_in (bfd *abfd,
		      const struct internal_reloc *intern,
		      arelent *rptr)
{
  if (intern->r_type > MIPS_R_PCREL16)
    abort ();

  if (! intern->r_extern
      && (intern->r_type == MIPS_R_GPREL
	  || intern->r_type == MIPS_R_LITERAL))
    rptr->addend += ecoff_data (abfd)->gp;

  /* If the type is MIPS_R_IGNORE, make sure this is a reference to
     the absolute section so that the reloc is ignored.  */
  if (intern->r_type == MIPS_R_IGNORE)
    rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;

  rptr->howto = &mips_howto_table[intern->r_type];
}

/* Make any adjustments needed to a reloc before writing it out.  None
   are needed for MIPS.  */

static void
mips_adjust_reloc_out (bfd *abfd ATTRIBUTE_UNUSED,
		       const arelent *rel ATTRIBUTE_UNUSED,
		       struct internal_reloc *intern ATTRIBUTE_UNUSED)
{
}

/* ECOFF relocs are either against external symbols, or against
   sections.  If we are producing relocatable output, and the reloc
   is against an external symbol, and nothing has given us any
   additional addend, the resulting reloc will also be against the
   same symbol.  In such a case, we don't want to change anything
   about the way the reloc is handled, since it will all be done at
   final link time.  Rather than put special case code into
   bfd_perform_relocation, all the reloc types use this howto
   function.  It just short circuits the reloc if producing
   relocatable output against an external symbol.  */

static bfd_reloc_status_type
mips_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		    arelent *reloc_entry,
		    asymbol *symbol,
		    void * data ATTRIBUTE_UNUSED,
		    asection *input_section,
		    bfd *output_bfd,
		    char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  return bfd_reloc_continue;
}

/* Do a REFHI relocation.  This has to be done in combination with a
   REFLO reloc, because there is a carry from the REFLO to the REFHI.
   Here we just save the information we need; we do the actual
   relocation when we see the REFLO.  MIPS ECOFF requires that the
   REFLO immediately follow the REFHI.  As a GNU extension, we permit
   an arbitrary number of HI relocs to be associated with a single LO
   reloc.  This extension permits gcc to output the HI and LO relocs
   itself.  */

struct mips_hi
{
  struct mips_hi *next;
  bfd_byte *addr;
  bfd_vma addend;
};

/* FIXME: This should not be a static variable.  */

static struct mips_hi *mips_refhi_list;

static bfd_reloc_status_type
mips_refhi_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		  arelent *reloc_entry,
		  asymbol *symbol,
		  void * data,
		  asection *input_section,
		  bfd *output_bfd,
		  char **error_message ATTRIBUTE_UNUSED)
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct mips_hi *n;

  /* If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    ret = bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Save the information, and let REFLO do the actual relocation.  */
  n = (struct mips_hi *) bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_refhi_list;
  mips_refhi_list = n;

  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Do a REFLO relocation.  This is a straightforward 16 bit inplace
   relocation; this function exists in order to do the REFHI
   relocation described above.  */

static bfd_reloc_status_type
mips_reflo_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		  arelent *reloc_entry,
		  asymbol *symbol,
		  void * data,
		  asection *input_section,
		  bfd *output_bfd,
		  char **error_message ATTRIBUTE_UNUSED)
{
  if (mips_refhi_list != NULL)
    {
      struct mips_hi *l;

      l = mips_refhi_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi *next;

	  /* Do the REFHI relocation.  Note that we actually don't
	     need to know anything about the REFLO itself, except
	     where to find the low 16 bits of the addend needed by the
	     REFHI.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff);
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* The low order 16 bits are always treated as a signed
	     value.  Therefore, a negative value in the low order bits
	     requires an adjustment in the high order bits.  We need
	     to make this adjustment in two ways: once for the bits we
	     took from the data, and once for the bits we are putting
	     back in to the data.  */
	  if ((vallo & 0x8000) != 0)
	    val -= 0x10000;
	  if ((val & 0x8000) != 0)
	    val += 0x10000;

	  insn = (insn &~ (unsigned) 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_refhi_list = NULL;
    }

  /* Now do the REFLO reloc in the usual way.  */
  return mips_generic_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
}

/* Do a GPREL relocation.  This is a 16 bit value which must become
   the offset from the gp register.  */

static bfd_reloc_status_type
mips_gprel_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		  arelent *reloc_entry,
		  asymbol *symbol,
		  void * data,
		  asection *input_section,
		  bfd *output_bfd,
		  char **error_message ATTRIBUTE_UNUSED)
{
  bfd_boolean relocatable;
  bfd_vma gp;
  bfd_vma relocation;
  unsigned long val;
  unsigned long insn;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ECOFF
     file.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != (bfd *) NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  if (bfd_is_und_section (symbol->section) && ! relocatable)
    return bfd_reloc_undefined;

  /* We have to figure out the gp value, so that we can adjust the
     symbol value correctly.  We look up the symbol _gp in the output
     BFD.  If we can't find it, we're stuck.  We cache it in the ECOFF
     target data.  We don't need to adjust the symbol value for an
     external symbol if we are producing relocatable output.  */
  gp = _bfd_get_gp_value (output_bfd);
  if (gp == 0
      && (! relocatable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
	{
	  /* Make up a value.  */
	  gp = symbol->section->output_section->vma + 0x4000;
	  _bfd_set_gp_value (output_bfd, gp);
	}
      else
	{
	  unsigned int count;
	  asymbol **sym;
	  unsigned int i;

	  count = bfd_get_symcount (output_bfd);
	  sym = bfd_get_outsymbols (output_bfd);

	  if (sym == (asymbol **) NULL)
	    i = count;
	  else
	    {
	      for (i = 0; i < count; i++, sym++)
		{
		  register const char *name;

		  name = bfd_asymbol_name (*sym);
		  if (*name == '_' && strcmp (name, "_gp") == 0)
		    {
		      gp = bfd_asymbol_value (*sym);
		      _bfd_set_gp_value (output_bfd, gp);
		      break;
		    }
		}
	    }

	  if (i >= count)
	    {
	      /* Only get the error once.  */
	      gp = 4;
	      _bfd_set_gp_value (output_bfd, gp);
	      *error_message =
		(char *) _("GP relative relocation when _gp not defined");
	      return bfd_reloc_dangerous;
	    }
	}
    }

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
  if (val & 0x8000)
    val -= 0x10000;

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  insn = (insn &~ (unsigned) 0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, (bfd_vma) insn, (bfd_byte *) data + reloc_entry->address);

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  /* Make sure it fit in 16 bits.  */
  if ((long) val >= 0x8000 || (long) val < -0x8000)
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
}

/* Get the howto structure for a generic reloc type.  */

static reloc_howto_type *
mips_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  int mips_type;

  switch (code)
    {
    case BFD_RELOC_16:
      mips_type = MIPS_R_REFHALF;
      break;
    case BFD_RELOC_32:
    case BFD_RELOC_CTOR:
      mips_type = MIPS_R_REFWORD;
      break;
    case BFD_RELOC_MIPS_JMP:
      mips_type = MIPS_R_JMPADDR;
      break;
    case BFD_RELOC_HI16_S:
      mips_type = MIPS_R_REFHI;
      break;
    case BFD_RELOC_LO16:
      mips_type = MIPS_R_REFLO;
      break;
    case BFD_RELOC_GPREL16:
      mips_type = MIPS_R_GPREL;
      break;
    case BFD_RELOC_MIPS_LITERAL:
      mips_type = MIPS_R_LITERAL;
      break;
    case BFD_RELOC_16_PCREL_S2:
      mips_type = MIPS_R_PCREL16;
      break;
    default:
      return (reloc_howto_type *) NULL;
    }

  return &mips_howto_table[mips_type];
}

static reloc_howto_type *
mips_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (mips_howto_table) / sizeof (mips_howto_table[0]);
       i++)
    if (mips_howto_table[i].name != NULL
	&& strcasecmp (mips_howto_table[i].name, r_name) == 0)
      return &mips_howto_table[i];

  return NULL;
}

/* A helper routine for mips_relocate_section which handles the REFHI
   relocations.  The REFHI relocation must be followed by a REFLO
   relocation, and the addend used is formed from the addends of both
   instructions.  */

static void
mips_relocate_hi (struct internal_reloc *refhi,
		  struct internal_reloc *reflo,
		  bfd *input_bfd,
		  asection *input_section,
		  bfd_byte *contents,
		  bfd_vma relocation)
{
  unsigned long insn;
  unsigned long val;
  unsigned long vallo;

  if (refhi == NULL)
    return;

  insn = bfd_get_32 (input_bfd,
		     contents + refhi->r_vaddr - input_section->vma);
  if (reflo == NULL)
    vallo = 0;
  else
    vallo = (bfd_get_32 (input_bfd,
			 contents + reflo->r_vaddr - input_section->vma)
	     & 0xffff);

  val = ((insn & 0xffff) << 16) + vallo;
  val += relocation;

  /* The low order 16 bits are always treated as a signed value.
     Therefore, a negative value in the low order bits requires an
     adjustment in the high order bits.  We need to make this
     adjustment in two ways: once for the bits we took from the data,
     and once for the bits we are putting back in to the data.  */
  if ((vallo & 0x8000) != 0)
    val -= 0x10000;

  if ((val & 0x8000) != 0)
    val += 0x10000;

  insn = (insn &~ (unsigned) 0xffff) | ((val >> 16) & 0xffff);
  bfd_put_32 (input_bfd, (bfd_vma) insn,
	      contents + refhi->r_vaddr - input_section->vma);
}

/* Relocate a section while linking a MIPS ECOFF file.  */

static bfd_boolean
mips_relocate_section (bfd *output_bfd,
		       struct bfd_link_info *info,
		       bfd *input_bfd,
		       asection *input_section,
		       bfd_byte *contents,
		       void * external_relocs)
{
  asection **symndx_to_section;
  struct ecoff_link_hash_entry **sym_hashes;
  bfd_vma gp;
  bfd_boolean gp_undefined;
  struct external_reloc *ext_rel;
  struct external_reloc *ext_rel_end;
  unsigned int i;
  bfd_boolean got_lo;
  struct internal_reloc lo_int_rel;
  bfd_size_type amt;

  BFD_ASSERT (input_bfd->xvec->byteorder
	      == output_bfd->xvec->byteorder);

  /* We keep a table mapping the symndx found in an internal reloc to
     the appropriate section.  This is faster than looking up the
     section by name each time.  */
  symndx_to_section = ecoff_data (input_bfd)->symndx_to_section;
  if (symndx_to_section == (asection **) NULL)
    {
      amt = NUM_RELOC_SECTIONS * sizeof (asection *);
      symndx_to_section = (asection **) bfd_alloc (input_bfd, amt);
      if (!symndx_to_section)
	return FALSE;

      symndx_to_section[RELOC_SECTION_NONE] = NULL;
      symndx_to_section[RELOC_SECTION_TEXT] =
	bfd_get_section_by_name (input_bfd, ".text");
      symndx_to_section[RELOC_SECTION_RDATA] =
	bfd_get_section_by_name (input_bfd, ".rdata");
      symndx_to_section[RELOC_SECTION_DATA] =
	bfd_get_section_by_name (input_bfd, ".data");
      symndx_to_section[RELOC_SECTION_SDATA] =
	bfd_get_section_by_name (input_bfd, ".sdata");
      symndx_to_section[RELOC_SECTION_SBSS] =
	bfd_get_section_by_name (input_bfd, ".sbss");
      symndx_to_section[RELOC_SECTION_BSS] =
	bfd_get_section_by_name (input_bfd, ".bss");
      symndx_to_section[RELOC_SECTION_INIT] =
	bfd_get_section_by_name (input_bfd, ".init");
      symndx_to_section[RELOC_SECTION_LIT8] =
	bfd_get_section_by_name (input_bfd, ".lit8");
      symndx_to_section[RELOC_SECTION_LIT4] =
	bfd_get_section_by_name (input_bfd, ".lit4");
      symndx_to_section[RELOC_SECTION_XDATA] = NULL;
      symndx_to_section[RELOC_SECTION_PDATA] = NULL;
      symndx_to_section[RELOC_SECTION_FINI] =
	bfd_get_section_by_name (input_bfd, ".fini");
      symndx_to_section[RELOC_SECTION_LITA] = NULL;
      symndx_to_section[RELOC_SECTION_ABS] = NULL;

      ecoff_data (input_bfd)->symndx_to_section = symndx_to_section;
    }

  sym_hashes = ecoff_data (input_bfd)->sym_hashes;

  gp = _bfd_get_gp_value (output_bfd);
  if (gp == 0)
    gp_undefined = TRUE;
  else
    gp_undefined = FALSE;

  got_lo = FALSE;

  ext_rel = (struct external_reloc *) external_relocs;
  ext_rel_end = ext_rel + input_section->reloc_count;
  for (i = 0; ext_rel < ext_rel_end; ext_rel++, i++)
    {
      struct internal_reloc int_rel;
      bfd_boolean use_lo = FALSE;
      bfd_vma addend;
      reloc_howto_type *howto;
      struct ecoff_link_hash_entry *h = NULL;
      asection *s = NULL;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      if (! got_lo)
	mips_ecoff_swap_reloc_in (input_bfd, ext_rel, &int_rel);
      else
	{
	  int_rel = lo_int_rel;
	  got_lo = FALSE;
	}

      BFD_ASSERT (int_rel.r_type
		  < sizeof mips_howto_table / sizeof mips_howto_table[0]);

      /* The REFHI reloc requires special handling.  It must be followed
	 by a REFLO reloc, and the addend is formed from both relocs.  */
      if (int_rel.r_type == MIPS_R_REFHI)
	{
	  struct external_reloc *lo_ext_rel;

	  /* As a GNU extension, permit an arbitrary number of REFHI
             relocs before the REFLO reloc.  This permits gcc to emit
	     the HI and LO relocs itself.  */
	  for (lo_ext_rel = ext_rel + 1;
	       lo_ext_rel < ext_rel_end;
	       lo_ext_rel++)
	    {
	      mips_ecoff_swap_reloc_in (input_bfd, lo_ext_rel,
					&lo_int_rel);
	      if (lo_int_rel.r_type != int_rel.r_type)
		break;
	    }

	  if (lo_ext_rel < ext_rel_end
	      && lo_int_rel.r_type == MIPS_R_REFLO
	      && int_rel.r_extern == lo_int_rel.r_extern
	      && int_rel.r_symndx == lo_int_rel.r_symndx)
	    {
	      use_lo = TRUE;
	      if (lo_ext_rel == ext_rel + 1)
		got_lo = TRUE;
	    }
	}

      howto = &mips_howto_table[int_rel.r_type];

      if (int_rel.r_extern)
	{
	  h = sym_hashes[int_rel.r_symndx];
	  /* If h is NULL, that means that there is a reloc against an
	     external symbol which we thought was just a debugging
	     symbol.  This should not happen.  */
	  if (h == (struct ecoff_link_hash_entry *) NULL)
	    abort ();
	}
      else
	{
	  if (int_rel.r_symndx < 0 || int_rel.r_symndx >= NUM_RELOC_SECTIONS)
	    s = NULL;
	  else
	    s = symndx_to_section[int_rel.r_symndx];

	  if (s == (asection *) NULL)
	    abort ();
	}

      /* The GPREL reloc uses an addend: the difference in the GP
	 values.  */
      if (int_rel.r_type != MIPS_R_GPREL
	  && int_rel.r_type != MIPS_R_LITERAL)
	addend = 0;
      else
	{
	  if (gp_undefined)
	    {
	      if (! ((*info->callbacks->reloc_dangerous)
		     (info, _("GP relative relocation used when GP not defined"),
		      input_bfd, input_section,
		      int_rel.r_vaddr - input_section->vma)))
		return FALSE;
	      /* Only give the error once per link.  */
	      gp = 4;
	      _bfd_set_gp_value (output_bfd, gp);
	      gp_undefined = FALSE;
	    }
	  if (! int_rel.r_extern)
	    {
	      /* This is a relocation against a section.  The current
		 addend in the instruction is the difference between
		 INPUT_SECTION->vma and the GP value of INPUT_BFD.  We
		 must change this to be the difference between the
		 final definition (which will end up in RELOCATION)
		 and the GP value of OUTPUT_BFD (which is in GP).  */
	      addend = ecoff_data (input_bfd)->gp - gp;
	    }
	  else if (! info->relocatable
		   || h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    {
	      /* This is a relocation against a defined symbol.  The
		 current addend in the instruction is simply the
		 desired offset into the symbol (normally zero).  We
		 are going to change this into a relocation against a
		 defined symbol, so we want the instruction to hold
		 the difference between the final definition of the
		 symbol (which will end up in RELOCATION) and the GP
		 value of OUTPUT_BFD (which is in GP).  */
	      addend = - gp;
	    }
	  else
	    {
	      /* This is a relocation against an undefined or common
		 symbol.  The current addend in the instruction is
		 simply the desired offset into the symbol (normally
		 zero).  We are generating relocatable output, and we
		 aren't going to define this symbol, so we just leave
		 the instruction alone.  */
	      addend = 0;
	    }
	}

      if (info->relocatable)
	{
	  /* We are generating relocatable output, and must convert
	     the existing reloc.  */
	  if (int_rel.r_extern)
	    {
	      if ((h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
		  && ! bfd_is_abs_section (h->root.u.def.section))
		{
		  const char *name;

		  /* This symbol is defined in the output.  Convert
		     the reloc from being against the symbol to being
		     against the section.  */

		  /* Clear the r_extern bit.  */
		  int_rel.r_extern = 0;

		  /* Compute a new r_symndx value.  */
		  s = h->root.u.def.section;
		  name = bfd_get_section_name (output_bfd,
					       s->output_section);

		  int_rel.r_symndx = -1;
		  switch (name[1])
		    {
		    case 'b':
		      if (strcmp (name, ".bss") == 0)
			int_rel.r_symndx = RELOC_SECTION_BSS;
		      break;
		    case 'd':
		      if (strcmp (name, ".data") == 0)
			int_rel.r_symndx = RELOC_SECTION_DATA;
		      break;
		    case 'f':
		      if (strcmp (name, ".fini") == 0)
			int_rel.r_symndx = RELOC_SECTION_FINI;
		      break;
		    case 'i':
		      if (strcmp (name, ".init") == 0)
			int_rel.r_symndx = RELOC_SECTION_INIT;
		      break;
		    case 'l':
		      if (strcmp (name, ".lit8") == 0)
			int_rel.r_symndx = RELOC_SECTION_LIT8;
		      else if (strcmp (name, ".lit4") == 0)
			int_rel.r_symndx = RELOC_SECTION_LIT4;
		      break;
		    case 'r':
		      if (strcmp (name, ".rdata") == 0)
			int_rel.r_symndx = RELOC_SECTION_RDATA;
		      break;
		    case 's':
		      if (strcmp (name, ".sdata") == 0)
			int_rel.r_symndx = RELOC_SECTION_SDATA;
		      else if (strcmp (name, ".sbss") == 0)
			int_rel.r_symndx = RELOC_SECTION_SBSS;
		      break;
		    case 't':
		      if (strcmp (name, ".text") == 0)
			int_rel.r_symndx = RELOC_SECTION_TEXT;
		      break;
		    }

		  if (int_rel.r_symndx == -1)
		    abort ();

		  /* Add the section VMA and the symbol value.  */
		  relocation = (h->root.u.def.value
				+ s->output_section->vma
				+ s->output_offset);

		  /* For a PC relative relocation, the object file
		     currently holds just the addend.  We must adjust
		     by the address to get the right value.  */
		  if (howto->pc_relative)
		    relocation -= int_rel.r_vaddr - input_section->vma;

		  h = NULL;
		}
	      else
		{
		  /* Change the symndx value to the right one for the
		     output BFD.  */
		  int_rel.r_symndx = h->indx;
		  if (int_rel.r_symndx == -1)
		    {
		      /* This symbol is not being written out.  */
		      if (! ((*info->callbacks->unattached_reloc)
			     (info, h->root.root.string, input_bfd,
			      input_section,
			      int_rel.r_vaddr - input_section->vma)))
			return FALSE;
		      int_rel.r_symndx = 0;
		    }
		  relocation = 0;
		}
	    }
	  else
	    {
	      /* This is a relocation against a section.  Adjust the
		 value by the amount the section moved.  */
	      relocation = (s->output_section->vma
			    + s->output_offset
			    - s->vma);
	    }

	  relocation += addend;
	  addend = 0;

	  /* Adjust a PC relative relocation by removing the reference
	     to the original address in the section and including the
	     reference to the new address.  */
	  if (howto->pc_relative)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   - input_section->vma);

	  /* Adjust the contents.  */
	  if (relocation == 0)
	    r = bfd_reloc_ok;
	  else
	    {
	      if (int_rel.r_type != MIPS_R_REFHI)
		r = _bfd_relocate_contents (howto, input_bfd, relocation,
					    (contents
					     + int_rel.r_vaddr
					     - input_section->vma));
	      else
		{
		  mips_relocate_hi (&int_rel,
				    use_lo ? &lo_int_rel : NULL,
				    input_bfd, input_section, contents,
				    relocation);
		  r = bfd_reloc_ok;
		}
	    }

	  /* Adjust the reloc address.  */
	  int_rel.r_vaddr += (input_section->output_section->vma
			      + input_section->output_offset
			      - input_section->vma);

	  /* Save the changed reloc information.  */
	  mips_ecoff_swap_reloc_out (input_bfd, &int_rel, ext_rel);
	}
      else
	{
	  /* We are producing a final executable.  */
	  if (int_rel.r_extern)
	    {
	      /* This is a reloc against a symbol.  */
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		{
		  asection *hsec;

		  hsec = h->root.u.def.section;
		  relocation = (h->root.u.def.value
				+ hsec->output_section->vma
				+ hsec->output_offset);
		}
	      else
		{
		  if (! ((*info->callbacks->undefined_symbol)
			 (info, h->root.root.string, input_bfd,
			  input_section,
			  int_rel.r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
		  relocation = 0;
		}
	    }
	  else
	    {
	      /* This is a reloc against a section.  */
	      relocation = (s->output_section->vma
			    + s->output_offset
			    - s->vma);

	      /* A PC relative reloc is already correct in the object
		 file.  Make it look like a pcrel_offset relocation by
		 adding in the start address.  */
	      if (howto->pc_relative)
		relocation += int_rel.r_vaddr;
	    }

	  if (int_rel.r_type != MIPS_R_REFHI)
	    r = _bfd_final_link_relocate (howto,
					  input_bfd,
					  input_section,
					  contents,
					  (int_rel.r_vaddr
					   - input_section->vma),
					  relocation,
					  addend);
	  else
	    {
	      mips_relocate_hi (&int_rel,
				use_lo ? &lo_int_rel : NULL,
				input_bfd, input_section, contents,
				relocation);
	      r = bfd_reloc_ok;
	    }
	}

      /* MIPS_R_JMPADDR requires peculiar overflow detection.  The
	 instruction provides a 28 bit address (the two lower bits are
	 implicit zeroes) which is combined with the upper four bits
	 of the instruction address.  */
      if (r == bfd_reloc_ok
	  && int_rel.r_type == MIPS_R_JMPADDR
	  && (((relocation
		+ addend
		+ (int_rel.r_extern ? 0 : s->vma))
	       & 0xf0000000)
	      != ((input_section->output_section->vma
		   + input_section->output_offset
		   + (int_rel.r_vaddr - input_section->vma))
		  & 0xf0000000)))
	r = bfd_reloc_overflow;

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (int_rel.r_extern)
		  name = NULL;
		else
		  name = bfd_section_name (input_bfd, s);
		if (! ((*info->callbacks->reloc_overflow)
		       (info, (h ? &h->root : NULL), name, howto->name,
			(bfd_vma) 0, input_bfd, input_section,
			int_rel.r_vaddr - input_section->vma)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* This is the ECOFF backend structure.  The backend field of the
   target vector points to this.  */

static const struct ecoff_backend_data mips_ecoff_backend_data =
{
  /* COFF backend structure.  */
  {
    (void (*) (bfd *,void *,int,int,int,int,void *)) bfd_void, /* aux_in */
    (void (*) (bfd *,void *,void *)) bfd_void, /* sym_in */
    (void (*) (bfd *,void *,void *)) bfd_void, /* lineno_in */
    (unsigned (*) (bfd *,void *,int,int,int,int,void *)) bfd_void,/*aux_out*/
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* sym_out */
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* lineno_out */
    (unsigned (*) (bfd *,void *,void *)) bfd_void, /* reloc_out */
    mips_ecoff_swap_filehdr_out, mips_ecoff_swap_aouthdr_out,
    mips_ecoff_swap_scnhdr_out,
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE,
    ECOFF_NO_LONG_SECTION_NAMES, 4, FALSE, 2,
    mips_ecoff_swap_filehdr_in, mips_ecoff_swap_aouthdr_in,
    mips_ecoff_swap_scnhdr_in, NULL,
    mips_ecoff_bad_format_hook, _bfd_ecoff_set_arch_mach_hook,
    _bfd_ecoff_mkobject_hook, _bfd_ecoff_styp_to_sec_flags,
    _bfd_ecoff_set_alignment_hook, _bfd_ecoff_slurp_symbol_table,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL
  },
  /* Supported architecture.  */
  bfd_arch_mips,
  /* Initial portion of armap string.  */
  "__________",
  /* The page boundary used to align sections in a demand-paged
     executable file.  E.g., 0x1000.  */
  0x1000,
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
     MIPS.  */
  FALSE,
  /* Bitsize of constructor entries.  */
  32,
  /* Reloc to use for constructor entries.  */
  &mips_howto_table[MIPS_R_REFWORD],
  {
    /* Symbol table magic number.  */
    magicSym,
    /* Alignment of debugging information.  E.g., 4.  */
    4,
    /* Sizes of external symbolic information.  */
    sizeof (struct hdr_ext),
    sizeof (struct dnr_ext),
    sizeof (struct pdr_ext),
    sizeof (struct sym_ext),
    sizeof (struct opt_ext),
    sizeof (struct fdr_ext),
    sizeof (struct rfd_ext),
    sizeof (struct ext_ext),
    /* Functions to swap in external symbolic data.  */
    ecoff_swap_hdr_in,
    ecoff_swap_dnr_in,
    ecoff_swap_pdr_in,
    ecoff_swap_sym_in,
    ecoff_swap_opt_in,
    ecoff_swap_fdr_in,
    ecoff_swap_rfd_in,
    ecoff_swap_ext_in,
    _bfd_ecoff_swap_tir_in,
    _bfd_ecoff_swap_rndx_in,
    /* Functions to swap out external symbolic data.  */
    ecoff_swap_hdr_out,
    ecoff_swap_dnr_out,
    ecoff_swap_pdr_out,
    ecoff_swap_sym_out,
    ecoff_swap_opt_out,
    ecoff_swap_fdr_out,
    ecoff_swap_rfd_out,
    ecoff_swap_ext_out,
    _bfd_ecoff_swap_tir_out,
    _bfd_ecoff_swap_rndx_out,
    /* Function to read in symbolic data.  */
    _bfd_ecoff_slurp_symbolic_info
  },
  /* External reloc size.  */
  RELSZ,
  /* Reloc swapping functions.  */
  mips_ecoff_swap_reloc_in,
  mips_ecoff_swap_reloc_out,
  /* Backend reloc tweaking.  */
  mips_adjust_reloc_in,
  mips_adjust_reloc_out,
  /* Relocate section contents while linking.  */
  mips_relocate_section,
  /* Do final adjustments to filehdr and aouthdr.  */
  NULL,
  /* Read an element from an archive at a given file position.  */
  _bfd_get_elt_at_filepos
};

/* Looking up a reloc type is MIPS specific.  */
#define _bfd_ecoff_bfd_reloc_type_lookup mips_bfd_reloc_type_lookup
#define _bfd_ecoff_bfd_reloc_name_lookup mips_bfd_reloc_name_lookup

/* Getting relocated section contents is generic.  */
#define _bfd_ecoff_bfd_get_relocated_section_contents \
  bfd_generic_get_relocated_section_contents

/* Handling file windows is generic.  */
#define _bfd_ecoff_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

/* Relaxing sections is MIPS specific.  */
#define _bfd_ecoff_bfd_relax_section bfd_generic_relax_section

/* GC of sections is not done.  */
#define _bfd_ecoff_bfd_gc_sections bfd_generic_gc_sections

/* Input section flags is not implemented.  */
#define _bfd_ecoff_bfd_lookup_section_flags bfd_generic_lookup_section_flags

/* Merging of sections is not done.  */
#define _bfd_ecoff_bfd_merge_sections bfd_generic_merge_sections

#define _bfd_ecoff_bfd_is_group_section bfd_generic_is_group_section
#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
#define _bfd_ecoff_section_already_linked \
  _bfd_coff_section_already_linked
#define _bfd_ecoff_bfd_define_common_symbol bfd_generic_define_common_symbol

extern const bfd_target ecoff_big_vec;

const bfd_target ecoff_little_vec =
{
  "ecoff-littlemips",		/* name */
  bfd_target_ecoff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, _bfd_ecoff_mkobject,  /* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
  {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & ecoff_big_vec,

  & mips_ecoff_backend_data
};

const bfd_target ecoff_big_vec =
{
  "ecoff-bigmips",		/* name */
  bfd_target_ecoff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16,
 {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
    bfd_generic_archive_p, _bfd_dummy_target},
 {bfd_false, _bfd_ecoff_mkobject, /* bfd_set_format */
    _bfd_generic_mkarchive, bfd_false},
 {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
    _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  & ecoff_little_vec,

  & mips_ecoff_backend_data
};

const bfd_target ecoff_biglittle_vec =
{
  "ecoff-biglittlemips",		/* name */
  bfd_target_ecoff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_CODE | SEC_DATA),
  0,				/* leading underscore */
  ' ',				/* ar_pad_char */
  15,				/* ar_max_namelen */
  0,				/* match priority.  */
  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
     bfd_getb32, bfd_getb_signed_32, bfd_putb32,
     bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, /* bfd_check_format */
     bfd_generic_archive_p, _bfd_dummy_target},
  {bfd_false, _bfd_ecoff_mkobject,  /* bfd_set_format */
     _bfd_generic_mkarchive, bfd_false},
  {bfd_false, _bfd_ecoff_write_object_contents, /* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

     BFD_JUMP_TABLE_GENERIC (_bfd_ecoff),
     BFD_JUMP_TABLE_COPY (_bfd_ecoff),
     BFD_JUMP_TABLE_CORE (_bfd_nocore),
     BFD_JUMP_TABLE_ARCHIVE (_bfd_ecoff),
     BFD_JUMP_TABLE_SYMBOLS (_bfd_ecoff),
     BFD_JUMP_TABLE_RELOCS (_bfd_ecoff),
     BFD_JUMP_TABLE_WRITE (_bfd_ecoff),
     BFD_JUMP_TABLE_LINK (_bfd_ecoff),
     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  & mips_ecoff_backend_data
};
@


1.42
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d48 1
a48 1
mips_gprel_reloc 
d1258 1
a1258 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, 
@


1.41
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2011
d38 12
a50 30
static bfd_boolean mips_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static void mips_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void mips_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void mips_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void mips_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
static bfd_reloc_status_type mips_generic_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_refhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_reflo_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_gprel_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static void mips_relocate_hi
  PARAMS ((struct internal_reloc *refhi, struct internal_reloc *reflo,
	   bfd *input_bfd, asection *input_section, bfd_byte *contents,
	   bfd_vma relocation));
static bfd_boolean mips_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static reloc_howto_type *mips_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d64 1
a64 1
#define coff_swap_filehdr_in mips_ecoff_swap_filehdr_in
d66 1
a66 1
#define coff_swap_aouthdr_in mips_ecoff_swap_aouthdr_in
d68 2
a69 2
#define coff_swap_scnhdr_in mips_ecoff_swap_scnhdr_in
#define coff_swap_scnhdr_out mips_ecoff_swap_scnhdr_out
d238 1
a238 3
mips_ecoff_bad_format_hook (abfd, filehdr)
     bfd *abfd;
     PTR filehdr;
d270 3
a272 4
mips_ecoff_swap_reloc_in (abfd, ext_ptr, intern)
     bfd *abfd;
     PTR ext_ptr;
     struct internal_reloc *intern;
d308 3
a310 4
mips_ecoff_swap_reloc_out (abfd, intern, dst)
     bfd *abfd;
     const struct internal_reloc *intern;
     PTR dst;
d348 3
a350 4
mips_adjust_reloc_in (abfd, intern, rptr)
     bfd *abfd;
     const struct internal_reloc *intern;
     arelent *rptr;
d372 3
a374 4
mips_adjust_reloc_out (abfd, rel, intern)
     bfd *abfd ATTRIBUTE_UNUSED;
     const arelent *rel ATTRIBUTE_UNUSED;
     struct internal_reloc *intern ATTRIBUTE_UNUSED;
d390 7
a396 14
mips_generic_reloc (abfd,
		    reloc_entry,
		    symbol,
		    data,
		    input_section,
		    output_bfd,
		    error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d430 7
a436 14
mips_refhi_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d489 7
a495 14
mips_reflo_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d550 7
a556 14
mips_gprel_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d683 2
a684 3
mips_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d744 6
a749 8
mips_relocate_hi (refhi, reflo, input_bfd, input_section, contents,
		  relocation)
     struct internal_reloc *refhi;
     struct internal_reloc *reflo;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma relocation;
d789 6
a794 8
mips_relocate_section (output_bfd, info, input_bfd, input_section,
		       contents, external_relocs)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     PTR external_relocs;
d874 1
a874 1
	mips_ecoff_swap_reloc_in (input_bfd, (PTR) ext_rel, &int_rel);
d897 1
a897 1
	      mips_ecoff_swap_reloc_in (input_bfd, (PTR) lo_ext_rel,
d1136 1
a1136 1
	  mips_ecoff_swap_reloc_out (input_bfd, &int_rel, (PTR) ext_rel);
d1249 7
a1255 7
    (void (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR))) bfd_void, /* aux_in */
    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_in */
    (void (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_in */
    (unsigned (*) PARAMS ((bfd *,PTR,int,int,int,int,PTR)))bfd_void,/*aux_out*/
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* sym_out */
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* lineno_out */
    (unsigned (*) PARAMS ((bfd *,PTR,PTR))) bfd_void, /* reloc_out */
d1412 1
a1412 1
  (PTR) &mips_ecoff_backend_data
d1456 1
a1456 1
  (PTR) &mips_ecoff_backend_data
d1501 1
a1501 1
  (PTR) &mips_ecoff_backend_data
@


1.40
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d1422 1
a1422 1
  _bfd_generic_section_already_linked
@


1.39
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1413 3
@


1.38
log
@update copyright dates
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
d1439 1
d1484 1
d1528 1
@


1.37
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
@


1.36
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d1420 1
@


1.35
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007, 2008
d1315 2
a1316 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
@


1.34
log
@	* ecoff.c (_bfd_ecoff_archive_p): Delete.
	* libecoff.h (_bfd_ecoff_archive_p): Delete.
	* coff-alpha.c (ecoffalpha_little_vec): Use bfd_generic_archive_p.
	* coff-mips.c (ecoff_little_vec, ecoff_big_vec): Likewise.
	(ecoff_biglittle_vec): Likewise.
@
text
@d88 1
d1322 1
a1322 1
    NULL, NULL
@


1.33
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2007
d1444 1
a1444 1
     _bfd_ecoff_archive_p, _bfd_dummy_target},
d1487 1
a1487 1
    _bfd_ecoff_archive_p, _bfd_dummy_target},
d1531 1
a1531 1
     _bfd_ecoff_archive_p, _bfd_dummy_target},
@


1.32
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.31
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d24 1
a25 1
#include "sysdep.h"
@


1.30
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d772 16
d1394 1
@


1.29
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.28
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.27
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1264 1
a1264 1
		  name = h->root.root.string;
d1268 2
a1269 2
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section,
@


1.26
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d1398 2
@


1.25
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a475 1
  bfd_size_type sz;
d502 1
a502 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a610 1
  bfd_size_type sz;
d700 1
a700 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.24
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d476 1
d503 2
a504 1
  if (reloc_entry->address > input_section->_cooked_size)
d613 1
d703 2
a704 1
  if (reloc_entry->address > input_section->_cooked_size)
@


1.23
log
@[ bfd/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * coff-mips.c (mips_relhi_reloc, mips_rello_reloc)
        (mips_switch_reloc, mips_read_relocs, mips_relax_section)
        (mips_relax_pcrel16, PCREL16_EXPANSION_ADJUSTMENT): Remove.
        (mips_relocate_hi): Remove now-unused 'adjust' and 'pcrel' arguments,
        and update comments to reflect current usage.
        (mips_howto_table): Remove entries for MIPS_R_RELHI, MIPS_R_RELLO,
        and MIPS_R_SWITCH, as well as several empty entries.  Update comment
        for MIPS_R_PCREL16.
        (mips_ecoff_swap_reloc_in, mips_ecoff_swap_reloc_out)
        (mips_adjust_reloc_out, mips_bfd_reloc_type_lookup): Remove support
        for MIPS_R_SWITCH, MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (mips_adjust_reloc_in): Likewise, adjust maximum accepted relocation
        type number to be MIPS_R_PCREL16.
        (mips_relocate_section): Remove support for link-time relaxation
        of branches used by embedded-PIC.  Remove support for MIPS_R_SWITCH,
        MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (_bfd_ecoff_bfd_relax_section): Redefine to bfd_generic_relax_section.
        * ecoff.c (ecoff_indirect_link_order): Remove support for link-time
        relaxation of branches used by embedded-PIC.
        * ecofflink.c (bfd_ecoff_debug_accumulate): Likewise.
        * libecoff.h (struct ecoff_section_tdata): Remove embedded-PIC
        related members, update comment.
        * pe-mips.c: Remove disabled (commented-out and #if 0'd)
        code related to embedded-PIC.
        * elfxx-mips.c (_bfd_mips_elf_read_ecoff_info): Remove
        initialization of now-removed 'adjust' member of
        'struct ecoff_debug_info'.

[ include/coff/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (MIPS_R_RELHI, MIPS_R_RELLO, MIPS_R_SWITCH): Remove
        (MIPS_R_PCREL16): Update comment.
        * ecoff.h (struct ecoff_value_adjust): Remove structure.
        (struct ecoff_debug_info): Remove 'adjust' member.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d1396 1
@


1.22
log
@[ bfd/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* coff-mips.c (bfd_mips_ecoff_create_embedded_relocs): Remove.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Remove.
	* bfd-in.h (bfd_mips_ecoff_create_embedded_relocs)
	(bfd_mips_elf32_create_embedded_relocs): Remove prototypes
	* bfd-in2.h: Regenerate.

[ ld/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* ld.texinfo: Remove MIPS --embedded-relocs documentation.
	* emulparams/elf32bmip.sh (EXTRA_EM_FILE): Remove definition.
	* emulparams/mipsidt.sh (TEMPLATE_NAME): Use generic.em.
	(EXTRA_EM_FILE): Use mipsecoff.em
	* emulparams/mipsidtl.sh (TEMPLATE_NAME): Use generic.em.
	(EXTRA_EM_FILE): Use mipsecoff.em
	* emultempl/mipsecoff.em: Restructure to be included as an
	extra emulation file.
	(check_sections, gld${EMULATION_NAME}_after_open)
	(gld${EMULATION_NAME}_after_allocation)
	(gld${EMULATION_NAME}_get_script)
	(ld_${EMULATION_NAME}_emulation): Remove
	(gld${EMULATION_NAME}_before_parse): Rename to...
	(mipsecoff_before_parse): This.
	(LDEMUL_BEFORE_PARSE): Define.
	* emultempl/mipself.em: Remove file.
	* scripttempl/mips.sc (.rel.sdata): Do not include in output.
	(__runtime_reloc_start, __runtime_reloc_stop): Stop providing
	these symbols.
	* Makefile.am: Remove dependencies on emultempl/mipself.em.
	* Makefile.in: Regenerate.

[ ld/testsuite/ChangeLog ]
2004-04-21  Chris Demetriou  <cgd@@broadcom.com>

	* ld-empic/run.c: Removed as part of MIPS --embedded-relocs removal.
	* ld-empic/empic.exp: Likewise.
	* ld-empic/relax.t: Likewise.
	* ld-empic/relax1.c: Likewise.
	* ld-empic/relax2.c: Likewise.
	* ld-empic/relax3.c: Likewise.
	* ld-empic/relax4.c: Likewise.
	* ld-empic/runtest1.c: Likewise.
	* ld-empic/runtest2.c: Likewise.
	* ld-empic/runtesti.s: Likewise.
	* ld-mips-elf/empic1-ln.d: Likewise.
	* ld-mips-elf/empic1-lp.d: Likewise.
	* ld-mips-elf/empic1-mn.d: Likewise.
	* ld-mips-elf/empic1-mp.d: Likewise.
	* ld-mips-elf/empic1-ref.s: Likewise.
	* ld-mips-elf/empic1-sn.d: Likewise.
	* ld-mips-elf/empic1-sp.d: Likewise.
	* ld-mips-elf/empic1-space.s: Likewise.
	* ld-mips-elf/empic1-tgt.s: Likewise.
	* ld-mips-elf/empic2-fwd-0.d: Likewise.
	* ld-mips-elf/empic2-fwd-1.d: Likewise.
	* ld-mips-elf/empic2-fwd-tgt.s: Likewise.
	* ld-mips-elf/empic2-ref.s: Likewise.
	* ld-mips-elf/empic2-rev-0.d: Likewise.
	* ld-mips-elf/empic2-rev-1.d: Likewise.
	* ld-mips-elf/empic2-rev-tgt.s: Likewise.
	* ld-mips-elf/empic2-space.s: Likewise.
	* ld-mips-elf/emrelocs-eb.d: Likewise.
	* ld-mips-elf/emrelocs-el.d: Likewise.
	* ld-mips-elf/emrelocs.ld: Likewise.
	* ld-mips-elf/emrelocs1.s: Likewise.
	* ld-mips-elf/emrelocs2.s: Likewise.
	* ld-mips-elf/mips-elf.exp: Don't run now-removed tests.
@
text
@a59 9
static bfd_reloc_status_type mips_relhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_rello_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_switch_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
d63 1
a63 1
	   size_t adjust, bfd_vma relocation, bfd_boolean pcrel));
a65 7
static bfd_boolean mips_read_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean mips_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean mips_relax_pcrel16
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   struct ecoff_link_hash_entry *, bfd_byte *, bfd_vma));
d230 3
a232 4
  /* This reloc is a Cygnus extension used when generating position
     independent code for embedded systems.  It represents a 16 bit PC
     relative reloc rightshifted twice as used in the MIPS branch
     instructions.  */
a245 66

  /* This reloc is a Cygnus extension used when generating position
     independent code for embedded systems.  It represents the high 16
     bits of a PC relative reloc.  The next reloc must be
     MIPS_R_RELLO, and the addend is formed from the addends of the
     two instructions, just as in MIPS_R_REFHI and MIPS_R_REFLO.  The
     final value is actually PC relative to the location of the
     MIPS_R_RELLO reloc, not the MIPS_R_RELHI reloc.  */
  HOWTO (MIPS_R_RELHI,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_relhi_reloc,	/* special_function */
	 "RELHI",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* This reloc is a Cygnus extension used when generating position
     independent code for embedded systems.  It represents the low 16
     bits of a PC relative reloc.  */
  HOWTO (MIPS_R_RELLO,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_rello_reloc,	/* special_function */
	 "RELLO",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (15),
  EMPTY_HOWTO (16),
  EMPTY_HOWTO (17),
  EMPTY_HOWTO (18),
  EMPTY_HOWTO (19),
  EMPTY_HOWTO (20),
  EMPTY_HOWTO (21),

  /* This reloc is a Cygnus extension used when generating position
     independent code for embedded systems.  It represents an entry in
     a switch table, which is the difference between two symbols in
     the .text section.  The symndx is actually the offset from the
     reloc address to the subtrahend.  See include/coff/mips.h for
     more details.  */
  HOWTO (MIPS_R_SWITCH,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_switch_reloc,	/* special_function */
	 "SWITCH",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE)			/* pcrel_offset */
a249 16

/* When the linker is doing relaxing, it may change an external PCREL16
   reloc.  This typically represents an instruction like
       bal foo
   We change it to
       .set  noreorder
       bal   $L1
       lui   $at,%hi(foo - $L1)
     $L1:
       addiu $at,%lo(foo - $L1)
       addu  $at,$at,$31
       jalr  $at
   PCREL16_EXPANSION_ADJUSTMENT is the number of bytes this changes the
   instruction by.  */

#define PCREL16_EXPANSION_ADJUSTMENT (4 * 4)
a321 19

  /* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or
     MIPS_R_RELLO reloc, r_symndx is actually the offset from the
     reloc address to the base of the difference (see
     include/coff/mips.h for more details).  We copy symndx into the
     r_offset field so as not to confuse ecoff_slurp_reloc_table in
     ecoff.c.  In adjust_reloc_in we then copy r_offset into the reloc
     addend.  */
  if (intern->r_type == MIPS_R_SWITCH
      || (! intern->r_extern
	  && (intern->r_type == MIPS_R_RELLO
	      || intern->r_type == MIPS_R_RELHI)))
    {
      BFD_ASSERT (! intern->r_extern);
      intern->r_offset = intern->r_symndx;
      if (intern->r_offset & 0x800000)
	intern->r_offset -= 0x1000000;
      intern->r_symndx = RELOC_SECTION_TEXT;
    }
d338 1
a338 14
  /* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELLO or
     MIPS_R_RELHI reloc, we actually want to write the contents of
     r_offset out as the symbol index.  This undoes the change made by
     mips_ecoff_swap_reloc_in.  */
  if (intern->r_type != MIPS_R_SWITCH
      && (intern->r_extern
	  || (intern->r_type != MIPS_R_RELHI
	      && intern->r_type != MIPS_R_RELLO)))
    r_symndx = intern->r_symndx;
  else
    {
      BFD_ASSERT (intern->r_symndx == RELOC_SECTION_TEXT);
      r_symndx = intern->r_offset & 0xffffff;
    }
d373 1
a373 1
  if (intern->r_type > MIPS_R_SWITCH)
a385 12
  /* If this is a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or
     MIPS_R_RELLO reloc, we want the addend field of the BFD relocto
     hold the value which was originally in the symndx field of the
     internal MIPS ECOFF reloc.  This value was copied into
     intern->r_offset by mips_swap_reloc_in, and here we copy it into
     the addend field.  */
  if (intern->r_type == MIPS_R_SWITCH
      || (! intern->r_extern
	  && (intern->r_type == MIPS_R_RELHI
	      || intern->r_type == MIPS_R_RELLO)))
    rptr->addend = intern->r_offset;

d395 2
a396 2
     const arelent *rel;
     struct internal_reloc *intern;
a397 10
  /* For a MIPS_R_SWITCH reloc, or an internal MIPS_R_RELHI or
     MIPS_R_RELLO reloc, we must copy rel->addend into
     intern->r_offset.  This will then be written out as the symbol
     index by mips_ecoff_swap_reloc_out.  This operation parallels the
     action of mips_adjust_reloc_in.  */
  if (intern->r_type == MIPS_R_SWITCH
      || (! intern->r_extern
	  && (intern->r_type == MIPS_R_RELHI
	      || intern->r_type == MIPS_R_RELLO)))
    intern->r_offset = rel->addend;
a729 203
/* Do a RELHI relocation.  We do this in conjunction with a RELLO
   reloc, just as REFHI and REFLO are done together.  RELHI and RELLO
   are Cygnus extensions used when generating position independent
   code for embedded systems.  */

/* FIXME: This should not be a static variable.  */

static struct mips_hi *mips_relhi_list;

static bfd_reloc_status_type
mips_relhi_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  bfd_reloc_status_type ret;
  bfd_vma relocation;
  struct mips_hi *n;

  /* If this is a reloc against a section symbol, then it is correct
     in the object file.  The only time we want to change this case is
     when we are relaxing, and that is handled entirely by
     mips_relocate_section and never calls this function.  */
  if ((symbol->flags & BSF_SECTION_SYM) != 0)
    {
      if (output_bfd != (bfd *) NULL)
	reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* This is an external symbol.  If we're relocating, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  ret = bfd_reloc_ok;
  if (bfd_is_und_section (symbol->section)
      && output_bfd == (bfd *) NULL)
    ret = bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Save the information, and let RELLO do the actual relocation.  */
  n = (struct mips_hi *) bfd_malloc ((bfd_size_type) sizeof *n);
  if (n == NULL)
    return bfd_reloc_outofrange;
  n->addr = (bfd_byte *) data + reloc_entry->address;
  n->addend = relocation;
  n->next = mips_relhi_list;
  mips_relhi_list = n;

  if (output_bfd != (bfd *) NULL)
    reloc_entry->address += input_section->output_offset;

  return ret;
}

/* Do a RELLO relocation.  This is a straightforward 16 bit PC
   relative relocation; this function exists in order to do the RELHI
   relocation described above.  */

static bfd_reloc_status_type
mips_rello_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  if (mips_relhi_list != NULL)
    {
      struct mips_hi *l;

      l = mips_relhi_list;
      while (l != NULL)
	{
	  unsigned long insn;
	  unsigned long val;
	  unsigned long vallo;
	  struct mips_hi *next;

	  /* Do the RELHI relocation.  Note that we actually don't
	     need to know anything about the RELLO itself, except
	     where to find the low 16 bits of the addend needed by the
	     RELHI.  */
	  insn = bfd_get_32 (abfd, l->addr);
	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
		   & 0xffff);
	  val = ((insn & 0xffff) << 16) + vallo;
	  val += l->addend;

	  /* If the symbol is defined, make val PC relative.  If the
	     symbol is not defined we don't want to do this, because
	     we don't want the value in the object file to incorporate
	     the address of the reloc.  */
	  if (! bfd_is_und_section (bfd_get_section (symbol))
	      && ! bfd_is_com_section (bfd_get_section (symbol)))
	    val -= (input_section->output_section->vma
		    + input_section->output_offset
		    + reloc_entry->address);

	  /* The low order 16 bits are always treated as a signed
	     value.  Therefore, a negative value in the low order bits
	     requires an adjustment in the high order bits.  We need
	     to make this adjustment in two ways: once for the bits we
	     took from the data, and once for the bits we are putting
	     back in to the data.  */
	  if ((vallo & 0x8000) != 0)
	    val -= 0x10000;
	  if ((val & 0x8000) != 0)
	    val += 0x10000;

	  insn = (insn &~ (unsigned) 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, (bfd_vma) insn, l->addr);

	  next = l->next;
	  free (l);
	  l = next;
	}

      mips_relhi_list = NULL;
    }

  /* If this is a reloc against a section symbol, then it is correct
     in the object file.  The only time we want to change this case is
     when we are relaxing, and that is handled entirely by
     mips_relocate_section and never calls this function.  */
  if ((symbol->flags & BSF_SECTION_SYM) != 0)
    {
      if (output_bfd != (bfd *) NULL)
	reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* bfd_perform_relocation does not handle pcrel_offset relocations
     correctly when generating a relocatable file, so handle them
     directly here.  */
  if (output_bfd != (bfd *) NULL)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* Now do the RELLO reloc in the usual way.  */
  return mips_generic_reloc (abfd, reloc_entry, symbol, data,
			      input_section, output_bfd, error_message);
}

/* This is the special function for the MIPS_R_SWITCH reloc.  This
   special reloc is normally correct in the object file, and only
   requires special handling when relaxing.  We don't want
   bfd_perform_relocation to tamper with it at all.  */

static bfd_reloc_status_type
mips_switch_reloc (abfd,
		   reloc_entry,
		   symbol,
		   data,
		   input_section,
		   output_bfd,
		   error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     char **error_message ATTRIBUTE_UNUSED;
{
  return bfd_reloc_ok;
}

a765 9
    case BFD_RELOC_PCREL_HI16_S:
      mips_type = MIPS_R_RELHI;
      break;
    case BFD_RELOC_PCREL_LO16:
      mips_type = MIPS_R_RELLO;
      break;
    case BFD_RELOC_GPREL32:
      mips_type = MIPS_R_SWITCH;
      break;
d774 3
a776 3
   and RELHI relocations.  The REFHI relocation must be followed by a
   REFLO relocation (and RELHI by a RELLO), and the addend used is
   formed from the addends of both instructions.  */
d779 2
a780 2
mips_relocate_hi (refhi, reflo, input_bfd, input_section, contents, adjust,
		  relocation, pcrel)
a785 1
     size_t adjust;
a786 1
     bfd_boolean pcrel;
d796 1
a796 1
		     contents + adjust + refhi->r_vaddr - input_section->vma);
d801 1
a801 1
			 contents + adjust + reflo->r_vaddr - input_section->vma)
a814 5
  if (pcrel)
    val -= (input_section->output_section->vma
	    + input_section->output_offset
	    + (reflo->r_vaddr - input_section->vma + adjust));

d820 1
a820 1
	      contents + adjust + refhi->r_vaddr - input_section->vma);
a838 2
  size_t adjust;
  long *offsets;
a898 7
  adjust = 0;

  if (ecoff_section_data (input_bfd, input_section) == NULL)
    offsets = NULL;
  else
    offsets = ecoff_section_data (input_bfd, input_section)->offsets;

d923 3
a925 5
      /* The REFHI and RELHI relocs requires special handling.  they
	 must be followed by a REFLO or RELLO reloc, respectively, and
	 the addend is formed from both relocs.  */
      if (int_rel.r_type == MIPS_R_REFHI
	  || int_rel.r_type == MIPS_R_RELHI)
d930 2
a931 2
             or RELHI relocs before the REFLO or RELLO reloc.  This
             permits gcc to emit the HI and LO relocs itself.  */
d943 1
a943 4
	      && (lo_int_rel.r_type
		  == (int_rel.r_type == MIPS_R_REFHI
		      ? MIPS_R_REFLO
		      : MIPS_R_RELLO))
a954 26
      /* The SWITCH reloc must be handled specially.  This reloc is
	 marks the location of a difference between two portions of an
	 object file.  The symbol index does not reference a symbol,
	 but is actually the offset from the reloc to the subtrahend
	 of the difference.  This reloc is correct in the object file,
	 and needs no further adjustment, unless we are relaxing.  If
	 we are relaxing, we may have to add in an offset.  Since no
	 symbols are involved in this reloc, we handle it completely
	 here.  */
      if (int_rel.r_type == MIPS_R_SWITCH)
	{
	  if (offsets != NULL
	      && offsets[i] != 0)
	    {
	      r = _bfd_relocate_contents (howto, input_bfd,
					  (bfd_vma) offsets[i],
					  (contents
					   + adjust
					   + int_rel.r_vaddr
					   - input_section->vma));
	      BFD_ASSERT (r == bfd_reloc_ok);
	    }

	  continue;
	}

a1029 85
      /* If we are relaxing, mips_relax_section may have set
	 offsets[i] to some value.  A value of 1 means we must expand
	 a PC relative branch into a multi-instruction of sequence,
	 and any other value is an addend.  */
      if (offsets != NULL
	  && offsets[i] != 0)
	{
	  BFD_ASSERT (! info->relocatable);
	  BFD_ASSERT (int_rel.r_type == MIPS_R_PCREL16
		      || int_rel.r_type == MIPS_R_RELHI
		      || int_rel.r_type == MIPS_R_RELLO);
	  if (offsets[i] != 1)
	    addend += offsets[i];
	  else
	    {
	      bfd_byte *here;

	      BFD_ASSERT (int_rel.r_extern
			  && int_rel.r_type == MIPS_R_PCREL16);

	      /* Move the rest of the instructions up.  */
	      here = (contents
		      + adjust
		      + int_rel.r_vaddr
		      - input_section->vma);
	      memmove (here + PCREL16_EXPANSION_ADJUSTMENT, here,
		       (size_t) (input_section->_raw_size
				 - (int_rel.r_vaddr - input_section->vma)));

	      /* Generate the new instructions.  */
	      if (! mips_relax_pcrel16 (info, input_bfd, input_section,
					h, here,
					(input_section->output_section->vma
					 + input_section->output_offset
					 + (int_rel.r_vaddr
					    - input_section->vma)
					 + adjust)))
		return FALSE;

	      /* We must adjust everything else up a notch.  */
	      adjust += PCREL16_EXPANSION_ADJUSTMENT;

	      /* mips_relax_pcrel16 handles all the details of this
		 relocation.  */
	      continue;
	    }
	}

      /* If we are relaxing, and this is a reloc against the .text
	 segment, we may need to adjust it if some branches have been
	 expanded.  The reloc types which are likely to occur in the
	 .text section are handled efficiently by mips_relax_section,
	 and thus do not need to be handled here.  */
      if (ecoff_data (input_bfd)->debug_info.adjust != NULL
	  && ! int_rel.r_extern
	  && int_rel.r_symndx == RELOC_SECTION_TEXT
	  && (strcmp (bfd_get_section_name (input_bfd, input_section),
		      ".text") != 0
	      || (int_rel.r_type != MIPS_R_PCREL16
		  && int_rel.r_type != MIPS_R_SWITCH
		  && int_rel.r_type != MIPS_R_RELHI
		  && int_rel.r_type != MIPS_R_RELLO)))
	{
	  bfd_vma adr;
	  struct ecoff_value_adjust *a;

	  /* We need to get the addend so that we know whether we need
	     to adjust the address.  */
	  BFD_ASSERT (int_rel.r_type == MIPS_R_REFWORD);

	  adr = bfd_get_32 (input_bfd,
			    (contents
			     + adjust
			     + int_rel.r_vaddr
			     - input_section->vma));

	  for (a = ecoff_data (input_bfd)->debug_info.adjust;
	       a != (struct ecoff_value_adjust *) NULL;
	       a = a->next)
	    {
	      if (adr >= a->start && adr < a->end)
		addend += a->adjust;
	    }
	}

d1107 1
a1107 43
		    {
		      relocation -= int_rel.r_vaddr - input_section->vma;

		      /* If we are converting a RELHI or RELLO reloc
			 from being against an external symbol to
			 being against a section, we must put a
			 special value into the r_offset field.  This
			 value is the old addend.  The r_offset for
			 both the RELHI and RELLO relocs are the same,
			 and we set both when we see RELHI.  */
		      if (int_rel.r_type == MIPS_R_RELHI)
			{
			  long addhi, addlo;

			  addhi = bfd_get_32 (input_bfd,
					      (contents
					       + adjust
					       + int_rel.r_vaddr
					       - input_section->vma));
			  addhi &= 0xffff;
			  if (addhi & 0x8000)
			    addhi -= 0x10000;
			  addhi <<= 16;

			  if (! use_lo)
			    addlo = 0;
			  else
			    {
			      addlo = bfd_get_32 (input_bfd,
						  (contents
						   + adjust
						   + lo_int_rel.r_vaddr
						   - input_section->vma));
			      addlo &= 0xffff;
			      if (addlo & 0x8000)
				addlo -= 0x10000;

			      lo_int_rel.r_offset = addhi + addlo;
			    }

			  int_rel.r_offset = addhi + addlo;
			}
		    }
d1143 2
a1144 8
	     reference to the new address.  However, external RELHI
	     and RELLO relocs are PC relative, but don't include any
	     reference to the address.  The addend is merely an
	     addend.  */
	  if (howto->pc_relative
	      && (! int_rel.r_extern
		  || (int_rel.r_type != MIPS_R_RELHI
		      && int_rel.r_type != MIPS_R_RELLO)))
d1154 1
a1154 2
	      if (int_rel.r_type != MIPS_R_REFHI
		  && int_rel.r_type != MIPS_R_RELHI)
a1156 1
					     + adjust
d1164 1
a1164 2
				    adjust, relocation,
				    int_rel.r_type == MIPS_R_RELHI);
d1214 1
a1214 6
		{
		  if (int_rel.r_type != MIPS_R_RELHI || ! use_lo)
		    relocation += int_rel.r_vaddr + adjust;
		  else
		    relocation += lo_int_rel.r_vaddr + adjust;
		}
d1217 1
a1217 2
	  if (int_rel.r_type != MIPS_R_REFHI
	      && int_rel.r_type != MIPS_R_RELHI)
d1223 1
a1223 2
					   - input_section->vma
					   + adjust),
d1230 2
a1231 3
				input_bfd, input_section, contents, adjust,
				relocation,
				int_rel.r_type == MIPS_R_RELHI);
d1248 1
a1248 2
		   + (int_rel.r_vaddr - input_section->vma)
		   + adjust)
a1280 489
/* Read in the relocs for a section.  */

static bfd_boolean
mips_read_relocs (abfd, sec)
     bfd *abfd;
     asection *sec;
{
  struct ecoff_section_tdata *section_tdata;
  bfd_size_type amt;

  section_tdata = ecoff_section_data (abfd, sec);
  if (section_tdata == (struct ecoff_section_tdata *) NULL)
    {
      amt = sizeof (struct ecoff_section_tdata);
      sec->used_by_bfd = (PTR) bfd_alloc (abfd, amt);
      if (sec->used_by_bfd == NULL)
	return FALSE;

      section_tdata = ecoff_section_data (abfd, sec);
      section_tdata->external_relocs = NULL;
      section_tdata->contents = NULL;
      section_tdata->offsets = NULL;
    }

  if (section_tdata->external_relocs == NULL)
    {
      amt = ecoff_backend (abfd)->external_reloc_size;
      amt *= sec->reloc_count;
      section_tdata->external_relocs = (PTR) bfd_alloc (abfd, amt);
      if (section_tdata->external_relocs == NULL && amt != 0)
	return FALSE;

      if (bfd_seek (abfd, sec->rel_filepos, SEEK_SET) != 0
	  || bfd_bread (section_tdata->external_relocs, amt, abfd) != amt)
	return FALSE;
    }

  return TRUE;
}

/* Relax a section when linking a MIPS ECOFF file.  This is used for
   embedded PIC code, which always uses PC relative branches which
   only have an 18 bit range on MIPS.  If a branch is not in range, we
   generate a long instruction sequence to compensate.  Each time we
   find a branch to expand, we have to check all the others again to
   make sure they are still in range.  This is slow, but it only has
   to be done when -relax is passed to the linker.

   This routine figures out which branches need to expand; the actual
   expansion is done in mips_relocate_section when the section
   contents are relocated.  The information is stored in the offsets
   field of the ecoff_section_tdata structure.  An offset of 1 means
   that the branch must be expanded into a multi-instruction PC
   relative branch (such an offset will only occur for a PC relative
   branch to an external symbol).  Any other offset must be a multiple
   of four, and is the amount to change the branch by (such an offset
   will only occur for a PC relative branch within the same section).

   We do not modify the section relocs or contents themselves so that
   if memory usage becomes an issue we can discard them and read them
   again.  The only information we must save in memory between this
   routine and the mips_relocate_section routine is the table of
   offsets.  */

static bfd_boolean
mips_relax_section (abfd, sec, info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *info;
     bfd_boolean *again;
{
  struct ecoff_section_tdata *section_tdata;
  bfd_byte *contents = NULL;
  long *offsets;
  struct external_reloc *ext_rel;
  struct external_reloc *ext_rel_end;
  unsigned int i;

  /* Assume we are not going to need another pass.  */
  *again = FALSE;

  /* If we are not generating an ECOFF file, this is much too
     confusing to deal with.  */
  if (info->hash->creator->flavour != bfd_get_flavour (abfd))
    return TRUE;

  /* If there are no relocs, there is nothing to do.  */
  if (sec->reloc_count == 0)
    return TRUE;

  /* We are only interested in PC relative relocs, and why would there
     ever be one from anything but the .text section?  */
  if (strcmp (bfd_get_section_name (abfd, sec), ".text") != 0)
    return TRUE;

  /* Read in the relocs, if we haven't already got them.  */
  section_tdata = ecoff_section_data (abfd, sec);
  if (section_tdata == (struct ecoff_section_tdata *) NULL
      || section_tdata->external_relocs == NULL)
    {
      if (! mips_read_relocs (abfd, sec))
	goto error_return;
      section_tdata = ecoff_section_data (abfd, sec);
    }

  if (sec->_cooked_size == 0)
    {
      /* We must initialize _cooked_size only the first time we are
	 called.  */
      sec->_cooked_size = sec->_raw_size;
    }

  contents = section_tdata->contents;
  offsets = section_tdata->offsets;

  /* Look for any external PC relative relocs.  Internal PC relative
     relocs are already correct in the object file, so they certainly
     can not overflow.  */
  ext_rel = (struct external_reloc *) section_tdata->external_relocs;
  ext_rel_end = ext_rel + sec->reloc_count;
  for (i = 0; ext_rel < ext_rel_end; ext_rel++, i++)
    {
      struct internal_reloc int_rel;
      struct ecoff_link_hash_entry *h;
      asection *hsec;
      bfd_signed_vma relocation;
      struct external_reloc *adj_ext_rel;
      unsigned int adj_i;
      unsigned long ext_count;
      struct ecoff_link_hash_entry **adj_h_ptr;
      struct ecoff_link_hash_entry **adj_h_ptr_end;
      struct ecoff_value_adjust *adjust;
      bfd_size_type amt;

      /* If we have already expanded this reloc, we certainly don't
	 need to do it again.  */
      if (offsets != (long *) NULL && offsets[i] == 1)
	continue;

      /* Quickly check that this reloc is external PCREL16.  */
      if (bfd_header_big_endian (abfd))
	{
	  if ((ext_rel->r_bits[3] & RELOC_BITS3_EXTERN_BIG) == 0
	      || (((ext_rel->r_bits[3] & RELOC_BITS3_TYPE_BIG)
		   >> RELOC_BITS3_TYPE_SH_BIG)
		  != MIPS_R_PCREL16))
	    continue;
	}
      else
	{
	  if ((ext_rel->r_bits[3] & RELOC_BITS3_EXTERN_LITTLE) == 0
	      || (((ext_rel->r_bits[3] & RELOC_BITS3_TYPE_LITTLE)
		   >> RELOC_BITS3_TYPE_SH_LITTLE)
		  != MIPS_R_PCREL16))
	    continue;
	}

      mips_ecoff_swap_reloc_in (abfd, (PTR) ext_rel, &int_rel);

      h = ecoff_data (abfd)->sym_hashes[int_rel.r_symndx];
      if (h == (struct ecoff_link_hash_entry *) NULL)
	abort ();

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	{
	  /* Just ignore undefined symbols.  These will presumably
	     generate an error later in the link.  */
	  continue;
	}

      /* Get the value of the symbol.  */
      hsec = h->root.u.def.section;
      relocation = (h->root.u.def.value
		    + hsec->output_section->vma
		    + hsec->output_offset);

      /* Subtract out the current address.  */
      relocation -= (sec->output_section->vma
		     + sec->output_offset
		     + (int_rel.r_vaddr - sec->vma));

      /* The addend is stored in the object file.  In the normal case
	 of ``bal symbol'', the addend will be -4.  It will only be
	 different in the case of ``bal symbol+constant''.  To avoid
	 always reading in the section contents, we don't check the
	 addend in the object file (we could easily check the contents
	 if we happen to have already read them in, but I fear that
	 this could be confusing).  This means we will screw up if
	 there is a branch to a symbol that is in range, but added to
	 a constant which puts it out of range; in such a case the
	 link will fail with a reloc overflow error.  Since the
	 compiler will never generate such code, it should be easy
	 enough to work around it by changing the assembly code in the
	 source file.  */
      relocation -= 4;

      /* Now RELOCATION is the number we want to put in the object
	 file.  See whether it fits.  */
      if (relocation >= -0x20000 && relocation < 0x20000)
	continue;

      /* Now that we know this reloc needs work, which will rarely
	 happen, go ahead and grab the section contents.  */
      if (contents == (bfd_byte *) NULL)
	{
	  if (info->keep_memory)
	    contents = (bfd_byte *) bfd_alloc (abfd, sec->_raw_size);
	  else
	    contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
	  if (contents == (bfd_byte *) NULL)
	    goto error_return;
	  if (! bfd_get_section_contents (abfd, sec, (PTR) contents,
					  (file_ptr) 0, sec->_raw_size))
	    goto error_return;
	  if (info->keep_memory)
	    section_tdata->contents = contents;
	}

      /* We only support changing the bal instruction.  It would be
	 possible to handle other PC relative branches, but some of
	 them (the conditional branches) would require a different
	 length instruction sequence which would complicate both this
	 routine and mips_relax_pcrel16.  It could be written if
	 somebody felt it were important.  Ignoring this reloc will
	 presumably cause a reloc overflow error later on.  */
      if (bfd_get_32 (abfd, contents + int_rel.r_vaddr - sec->vma)
	  != 0x0411ffff) /* bgezal $0,. == bal .  */
	continue;

      /* Bother.  We need to expand this reloc, and we will need to
	 make another relaxation pass since this change may put other
	 relocs out of range.  We need to examine the local branches
	 and we need to allocate memory to hold the offsets we must
	 add to them.  We also need to adjust the values of all
	 symbols in the object file following this location.  */

      sec->_cooked_size += PCREL16_EXPANSION_ADJUSTMENT;
      *again = TRUE;

      if (offsets == (long *) NULL)
	{
	  bfd_size_type size;

	  size = (bfd_size_type) sec->reloc_count * sizeof (long);
	  offsets = (long *) bfd_zalloc (abfd, size);
	  if (offsets == (long *) NULL)
	    goto error_return;
	  section_tdata->offsets = offsets;
	}

      offsets[i] = 1;

      /* Now look for all PC relative references that cross this reloc
	 and adjust their offsets.  */
      adj_ext_rel = (struct external_reloc *) section_tdata->external_relocs;
      for (adj_i = 0; adj_ext_rel < ext_rel_end; adj_ext_rel++, adj_i++)
	{
	  struct internal_reloc adj_int_rel;
	  bfd_vma start, stop;
	  int change;

	  mips_ecoff_swap_reloc_in (abfd, (PTR) adj_ext_rel, &adj_int_rel);

	  if (adj_int_rel.r_type == MIPS_R_PCREL16)
	    {
	      unsigned long insn;

	      /* We only care about local references.  External ones
		 will be relocated correctly anyhow.  */
	      if (adj_int_rel.r_extern)
		continue;

	      /* We are only interested in a PC relative reloc within
		 this section.  FIXME: Cross section PC relative
		 relocs may not be handled correctly; does anybody
		 care?  */
	      if (adj_int_rel.r_symndx != RELOC_SECTION_TEXT)
		continue;

	      start = adj_int_rel.r_vaddr;

	      insn = bfd_get_32 (abfd,
				 contents + adj_int_rel.r_vaddr - sec->vma);

	      stop = (insn & 0xffff) << 2;
	      if ((stop & 0x20000) != 0)
		stop -= 0x40000;
	      stop += adj_int_rel.r_vaddr + 4;
	    }
	  else if (adj_int_rel.r_type == MIPS_R_RELHI)
	    {
	      struct internal_reloc rello;
	      long addhi, addlo;

	      /* The next reloc must be MIPS_R_RELLO, and we handle
		 them together.  */
	      BFD_ASSERT (adj_ext_rel + 1 < ext_rel_end);

	      mips_ecoff_swap_reloc_in (abfd, (PTR) (adj_ext_rel + 1), &rello);

	      BFD_ASSERT (rello.r_type == MIPS_R_RELLO);

	      addhi = bfd_get_32 (abfd,
				   contents + adj_int_rel.r_vaddr - sec->vma);
	      addhi &= 0xffff;
	      if (addhi & 0x8000)
		addhi -= 0x10000;
	      addhi <<= 16;

	      addlo = bfd_get_32 (abfd, contents + rello.r_vaddr - sec->vma);
	      addlo &= 0xffff;
	      if (addlo & 0x8000)
		addlo -= 0x10000;

	      if (adj_int_rel.r_extern)
		{
		  /* The value we want here is
		       sym - RELLOaddr + addend
		     which we can express as
		       sym - (RELLOaddr - addend)
		     Therefore if we are expanding the area between
		     RELLOaddr and RELLOaddr - addend we must adjust
		     the addend.  This is admittedly ambiguous, since
		     we might mean (sym + addend) - RELLOaddr, but in
		     practice we don't, and there is no way to handle
		     that case correctly since at this point we have
		     no idea whether any reloc is being expanded
		     between sym and sym + addend.  */
		  start = rello.r_vaddr - (addhi + addlo);
		  stop = rello.r_vaddr;
		}
	      else
		{
		  /* An internal RELHI/RELLO pair represents the
		     difference between two addresses, $LC0 - foo.
		     The symndx value is actually the difference
		     between the reloc address and $LC0.  This lets us
		     compute $LC0, and, by considering the addend,
		     foo.  If the reloc we are expanding falls between
		     those two relocs, we must adjust the addend.  At
		     this point, the symndx value is actually in the
		     r_offset field, where it was put by
		     mips_ecoff_swap_reloc_in.  */
		  start = rello.r_vaddr - adj_int_rel.r_offset;
		  stop = start + addhi + addlo;
		}
	    }
	  else if (adj_int_rel.r_type == MIPS_R_SWITCH)
	    {
	      /* A MIPS_R_SWITCH reloc represents a word of the form
		   .word $L3-$LS12
		 The value in the object file is correct, assuming the
		 original value of $L3.  The symndx value is actually
		 the difference between the reloc address and $LS12.
		 This lets us compute the original value of $LS12 as
		   vaddr - symndx
		 and the original value of $L3 as
		   vaddr - symndx + addend
		 where addend is the value from the object file.  At
		 this point, the symndx value is actually found in the
		 r_offset field, since it was moved by
		 mips_ecoff_swap_reloc_in.  */
	      start = adj_int_rel.r_vaddr - adj_int_rel.r_offset;
	      stop = start + bfd_get_32 (abfd,
					 (contents
					  + adj_int_rel.r_vaddr
					  - sec->vma));
	    }
	  else
	    continue;

	  /* If the range expressed by this reloc, which is the
	     distance between START and STOP crosses the reloc we are
	     expanding, we must adjust the offset.  The sign of the
	     adjustment depends upon the direction in which the range
	     crosses the reloc being expanded.  */
	  if (start <= int_rel.r_vaddr && stop > int_rel.r_vaddr)
	    change = PCREL16_EXPANSION_ADJUSTMENT;
	  else if (start > int_rel.r_vaddr && stop <= int_rel.r_vaddr)
	    change = - PCREL16_EXPANSION_ADJUSTMENT;
	  else
	    change = 0;

	  offsets[adj_i] += change;

	  if (adj_int_rel.r_type == MIPS_R_RELHI)
	    {
	      adj_ext_rel++;
	      adj_i++;
	      offsets[adj_i] += change;
	    }
	}

      /* Find all symbols in this section defined by this object file
	 and adjust their values.  Note that we decide whether to
	 adjust the value based on the value stored in the ECOFF EXTR
	 structure, because the value stored in the hash table may
	 have been changed by an earlier expanded reloc and thus may
	 no longer correctly indicate whether the symbol is before or
	 after the expanded reloc.  */
      ext_count = ecoff_data (abfd)->debug_info.symbolic_header.iextMax;
      adj_h_ptr = ecoff_data (abfd)->sym_hashes;
      adj_h_ptr_end = adj_h_ptr + ext_count;
      for (; adj_h_ptr < adj_h_ptr_end; adj_h_ptr++)
	{
	  struct ecoff_link_hash_entry *adj_h;

	  adj_h = *adj_h_ptr;
	  if (adj_h != (struct ecoff_link_hash_entry *) NULL
	      && (adj_h->root.type == bfd_link_hash_defined
		  || adj_h->root.type == bfd_link_hash_defweak)
	      && adj_h->root.u.def.section == sec
	      && adj_h->esym.asym.value > int_rel.r_vaddr)
	    adj_h->root.u.def.value += PCREL16_EXPANSION_ADJUSTMENT;
	}

      /* Add an entry to the symbol value adjust list.  This is used
	 by bfd_ecoff_debug_accumulate to adjust the values of
	 internal symbols and FDR's.  */
      amt = sizeof (struct ecoff_value_adjust);
      adjust = (struct ecoff_value_adjust *) bfd_alloc (abfd, amt);
      if (adjust == (struct ecoff_value_adjust *) NULL)
	goto error_return;

      adjust->start = int_rel.r_vaddr;
      adjust->end = sec->vma + sec->_raw_size;
      adjust->adjust = PCREL16_EXPANSION_ADJUSTMENT;

      adjust->next = ecoff_data (abfd)->debug_info.adjust;
      ecoff_data (abfd)->debug_info.adjust = adjust;
    }

  if (contents != (bfd_byte *) NULL && ! info->keep_memory)
    free (contents);

  return TRUE;

 error_return:
  if (contents != (bfd_byte *) NULL && ! info->keep_memory)
    free (contents);
  return FALSE;
}

/* This routine is called from mips_relocate_section when a PC
   relative reloc must be expanded into the five instruction sequence.
   It handles all the details of the expansion, including resolving
   the reloc.  */

static bfd_boolean
mips_relax_pcrel16 (info, input_bfd, input_section, h, location, address)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *input_bfd;
     asection *input_section ATTRIBUTE_UNUSED;
     struct ecoff_link_hash_entry *h;
     bfd_byte *location;
     bfd_vma address;
{
  bfd_vma relocation;

  /* 0x0411ffff is bgezal $0,. == bal .  */
  BFD_ASSERT (bfd_get_32 (input_bfd, location) == 0x0411ffff);

  /* We need to compute the distance between the symbol and the
     current address plus eight.  */
  relocation = (h->root.u.def.value
		+ h->root.u.def.section->output_section->vma
		+ h->root.u.def.section->output_offset);
  relocation -= address + 8;

  /* If the lower half is negative, increment the upper 16 half.  */
  if ((relocation & 0x8000) != 0)
    relocation += 0x10000;

  bfd_put_32 (input_bfd, (bfd_vma) 0x04110001, location); /* bal .+8 */
  bfd_put_32 (input_bfd,
	      0x3c010000 | ((relocation >> 16) & 0xffff), /* lui $at,XX */
	      location + 4);
  bfd_put_32 (input_bfd,
	      0x24210000 | (relocation & 0xffff), /* addiu $at,$at,XX */
	      location + 8);
  bfd_put_32 (input_bfd,
	      (bfd_vma) 0x003f0821, location + 12); /* addu $at,$at,$ra */
  bfd_put_32 (input_bfd,
	      (bfd_vma) 0x0020f809, location + 16); /* jalr $at */

  return TRUE;
}

d1388 1
a1388 1
#define _bfd_ecoff_bfd_relax_section mips_relax_section
@


1.21
log
@Correct spelling of "relocatable".
@
text
@a2325 126

/* Given a .sdata section and a .rel.sdata in-memory section, store
   relocation information into the .rel.sdata section which can be
   used at runtime to relocate the section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  This
   function presumes that the object was compiled using
   -membedded-pic.  */

bfd_boolean
bfd_mips_ecoff_create_embedded_relocs (abfd, info, datasec, relsec, errmsg)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *datasec;
     asection *relsec;
     char **errmsg;
{
  struct ecoff_link_hash_entry **sym_hashes;
  struct ecoff_section_tdata *section_tdata;
  struct external_reloc *ext_rel;
  struct external_reloc *ext_rel_end;
  bfd_byte *p;
  bfd_size_type amt;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  sym_hashes = ecoff_data (abfd)->sym_hashes;

  if (! mips_read_relocs (abfd, datasec))
    return FALSE;

  amt = (bfd_size_type) datasec->reloc_count * 4;
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, amt);
  if (relsec->contents == NULL)
    return FALSE;

  p = relsec->contents;

  section_tdata = ecoff_section_data (abfd, datasec);
  ext_rel = (struct external_reloc *) section_tdata->external_relocs;
  ext_rel_end = ext_rel + datasec->reloc_count;
  for (; ext_rel < ext_rel_end; ext_rel++, p += 4)
    {
      struct internal_reloc int_rel;
      bfd_boolean text_relative;

      mips_ecoff_swap_reloc_in (abfd, (PTR) ext_rel, &int_rel);

      /* We are going to write a four byte word into the runtime reloc
	 section.  The word will be the address in the data section
	 which must be relocated.  This must be on a word boundary,
	 which means the lower two bits must be zero.  We use the
	 least significant bit to indicate how the value in the data
	 section must be relocated.  A 0 means that the value is
	 relative to the text section, while a 1 indicates that the
	 value is relative to the data section.  Given that we are
	 assuming the code was compiled using -membedded-pic, there
	 should not be any other possibilities.  */

      /* We can only relocate REFWORD relocs at run time.  */
      if (int_rel.r_type != MIPS_R_REFWORD)
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (int_rel.r_extern)
	{
	  struct ecoff_link_hash_entry *h;

	  h = sym_hashes[int_rel.r_symndx];
	  /* If h is NULL, that means that there is a reloc against an
	     external symbol which we thought was just a debugging
	     symbol.  This should not happen.  */
	  if (h == (struct ecoff_link_hash_entry *) NULL)
	    abort ();
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.section->flags & SEC_CODE) != 0)
	    text_relative = TRUE;
	  else
	    text_relative = FALSE;
	}
      else
	{
	  switch (int_rel.r_symndx)
	    {
	    case RELOC_SECTION_TEXT:
	      text_relative = TRUE;
	      break;
	    case RELOC_SECTION_SDATA:
	    case RELOC_SECTION_SBSS:
	    case RELOC_SECTION_LIT8:
	      text_relative = FALSE;
	      break;
	    default:
	      /* No other sections should appear in -membedded-pic
                 code.  */
	      *errmsg = _("reloc against unsupported section");
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	}

      if ((int_rel.r_offset & 3) != 0)
	{
	  *errmsg = _("reloc not properly aligned");
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      bfd_put_32 (abfd,
		  (int_rel.r_vaddr - datasec->vma + datasec->output_offset
		   + (text_relative ? 0 : 1)),
		  p);
    }

  return TRUE;
}
@


1.21.14.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d60 9
d72 1
a72 1
	   bfd_vma relocation));
d75 7
d246 4
a249 3
  /* FIXME: This relocation is used (internally only) to represent branches
     when assembling.  It should never appear in output files, and
     be removed.  (It used to be used for embedded-PIC support.)  */
d263 66
d333 16
d421 19
d456 14
a469 1
  r_symndx = intern->r_symndx;
d504 1
a504 1
  if (intern->r_type > MIPS_R_PCREL16)
d517 12
d538 2
a539 2
     const arelent *rel ATTRIBUTE_UNUSED;
     struct internal_reloc *intern ATTRIBUTE_UNUSED;
d541 10
d655 1
a655 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d853 1
a853 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d883 203
d1122 9
d1139 3
a1141 3
   relocations.  The REFHI relocation must be followed by a REFLO
   relocation, and the addend used is formed from the addends of both
   instructions.  */
d1144 2
a1145 2
mips_relocate_hi (refhi, reflo, input_bfd, input_section, contents,
		  relocation)
d1151 1
d1153 1
d1163 1
a1163 1
		     contents + refhi->r_vaddr - input_section->vma);
d1168 1
a1168 1
			 contents + reflo->r_vaddr - input_section->vma)
d1182 5
d1192 1
a1192 1
	      contents + refhi->r_vaddr - input_section->vma);
d1211 2
d1273 7
d1304 5
a1308 3
      /* The REFHI reloc requires special handling.  It must be followed
	 by a REFLO reloc, and the addend is formed from both relocs.  */
      if (int_rel.r_type == MIPS_R_REFHI)
d1313 2
a1314 2
             relocs before the REFLO reloc.  This permits gcc to emit
	     the HI and LO relocs itself.  */
d1326 4
a1329 1
	      && lo_int_rel.r_type == MIPS_R_REFLO
d1341 26
d1442 85
d1604 43
a1646 1
		    relocation -= int_rel.r_vaddr - input_section->vma;
d1682 8
a1689 2
	     reference to the new address.  */
	  if (howto->pc_relative)
d1699 2
a1700 1
	      if (int_rel.r_type != MIPS_R_REFHI)
d1703 1
d1711 2
a1712 1
				    relocation);
d1762 6
a1767 1
		relocation += int_rel.r_vaddr;
d1770 2
a1771 1
	  if (int_rel.r_type != MIPS_R_REFHI)
d1777 2
a1778 1
					   - input_section->vma),
d1785 3
a1787 2
				input_bfd, input_section, contents,
				relocation);
d1804 2
a1805 1
		   + (int_rel.r_vaddr - input_section->vma))
d1838 615
d2560 1
a2560 1
#define _bfd_ecoff_bfd_relax_section bfd_generic_relax_section
a2567 1
#define _bfd_ecoff_bfd_is_group_section bfd_generic_is_group_section
a2568 2
#define _bfd_ecoff_section_already_linked \
  _bfd_generic_section_already_linked
@


1.20
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d554 1
a554 1
   sections.  If we are producing relocateable output, and the reloc
d562 1
a562 1
   relocateable output against an external symbol.  */
d761 1
a761 1
  bfd_boolean relocateable;
d780 1
a780 1
    relocateable = TRUE;
d783 1
a783 1
      relocateable = FALSE;
d787 1
a787 1
  if (bfd_is_und_section (symbol->section) && ! relocateable)
d794 1
a794 1
     external symbol if we are producing relocateable output.  */
d797 1
a797 1
      && (! relocateable
d800 1
a800 1
      if (relocateable)
d864 1
a864 1
     are producing relocateable output, we don't want to do this for
d866 1
a866 1
  if (! relocateable
d873 1
a873 1
  if (relocateable)
d1049 1
a1049 1
     correctly when generating a relocateable file, so handle them
d1416 1
a1416 1
	  else if (! info->relocateable
d1435 1
a1435 1
		 zero).  We are generating relocateable output, and we
d1449 1
a1449 1
	  BFD_ASSERT (! info->relocateable);
d1527 1
a1527 1
      if (info->relocateable)
d1529 1
a1529 1
	  /* We are generating relocateable output, and must convert
d2351 1
a2351 1
  BFD_ASSERT (! info->relocateable);
@


1.19
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d38 44
a81 79
static boolean mips_ecoff_bad_format_hook PARAMS ((bfd *abfd, PTR filehdr));
static void mips_ecoff_swap_reloc_in PARAMS ((bfd *, PTR,
					      struct internal_reloc *));
static void mips_ecoff_swap_reloc_out PARAMS ((bfd *,
					       const struct internal_reloc *,
					       PTR));
static void mips_adjust_reloc_in PARAMS ((bfd *,
					  const struct internal_reloc *,
					  arelent *));
static void mips_adjust_reloc_out PARAMS ((bfd *, const arelent *,
					   struct internal_reloc *));
static bfd_reloc_status_type mips_generic_reloc PARAMS ((bfd *abfd,
							 arelent *reloc,
							 asymbol *symbol,
							 PTR data,
							 asection *section,
							 bfd *output_bfd,
							 char **error));
static bfd_reloc_status_type mips_refhi_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
static bfd_reloc_status_type mips_reflo_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
static bfd_reloc_status_type mips_gprel_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
static bfd_reloc_status_type mips_relhi_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
static bfd_reloc_status_type mips_rello_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
static bfd_reloc_status_type mips_switch_reloc PARAMS ((bfd *abfd,
							arelent *reloc,
							asymbol *symbol,
							PTR data,
							asection *section,
							bfd *output_bfd,
							char **error));
static void mips_relocate_hi PARAMS ((struct internal_reloc *refhi,
				      struct internal_reloc *reflo,
				      bfd *input_bfd,
				      asection *input_section,
				      bfd_byte *contents,
				      size_t adjust,
				      bfd_vma relocation,
				      boolean pcrel));
static boolean mips_relocate_section PARAMS ((bfd *, struct bfd_link_info *,
					      bfd *, asection *,
					      bfd_byte *, PTR));
static boolean mips_read_relocs PARAMS ((bfd *, asection *));
static boolean mips_relax_section PARAMS ((bfd *, asection *,
					   struct bfd_link_info *,
					   boolean *));
static boolean mips_relax_pcrel16 PARAMS ((struct bfd_link_info *, bfd *,
					   asection *,
					   struct ecoff_link_hash_entry *,
					   bfd_byte *, bfd_vma));
d120 1
a120 1
	 false,			/* pc_relative */
d125 1
a125 1
	 false,			/* partial_inplace */
d128 1
a128 1
	 false),		/* pcrel_offset */
d135 1
a135 1
	 false,			/* pc_relative */
d140 1
a140 1
	 true,			/* partial_inplace */
d143 1
a143 1
	 false),		/* pcrel_offset */
d150 1
a150 1
	 false,			/* pc_relative */
d155 1
a155 1
	 true,			/* partial_inplace */
d158 1
a158 1
	 false),		/* pcrel_offset */
d165 1
a165 1
	 false,			/* pc_relative */
d173 1
a173 1
	 true,			/* partial_inplace */
d176 1
a176 1
	 false),		/* pcrel_offset */
d184 1
a184 1
	 false,			/* pc_relative */
d189 1
a189 1
	 true,			/* partial_inplace */
d192 1
a192 1
	 false),		/* pcrel_offset */
d199 1
a199 1
	 false,			/* pc_relative */
d204 1
a204 1
	 true,			/* partial_inplace */
d207 1
a207 1
	 false),		/* pcrel_offset */
d215 1
a215 1
	 false,			/* pc_relative */
d220 1
a220 1
	 true,			/* partial_inplace */
d223 1
a223 1
	 false),		/* pcrel_offset */
d231 1
a231 1
	 false,			/* pc_relative */
d236 1
a236 1
	 true,			/* partial_inplace */
d239 1
a239 1
	 false),		/* pcrel_offset */
d254 1
a254 1
	 true,			/* pc_relative */
d259 1
a259 1
	 true,			/* partial_inplace */
d262 1
a262 1
	 true),			/* pcrel_offset */
d275 1
a275 1
	 true,			/* pc_relative */
d280 1
a280 1
	 true,			/* partial_inplace */
d283 1
a283 1
	 true),			/* pcrel_offset */
d292 1
a292 1
	 true,			/* pc_relative */
d297 1
a297 1
	 true,			/* partial_inplace */
d300 1
a300 1
	 true),			/* pcrel_offset */
d320 1
a320 1
	 true,			/* pc_relative */
d325 1
a325 1
	 true,			/* partial_inplace */
d328 1
a328 1
	 true)			/* pcrel_offset */
d352 1
a352 1
static boolean
d363 1
a363 1
      return true;
d376 1
a376 1
      return false;
d761 1
a761 1
  boolean relocateable;
d780 1
a780 1
    relocateable = true;
d783 1
a783 1
      relocateable = false;
d1153 1
a1153 1
     boolean pcrel;
d1197 1
a1197 1
static boolean
d1210 1
a1210 1
  boolean gp_undefined;
d1216 1
a1216 1
  boolean got_lo;
d1232 1
a1232 1
	return false;
d1267 1
a1267 1
    gp_undefined = true;
d1269 1
a1269 1
    gp_undefined = false;
d1271 1
a1271 1
  got_lo = false;
d1285 1
a1285 1
      boolean use_lo = false;
d1298 1
a1298 1
	  got_lo = false;
d1333 1
a1333 1
	      use_lo = true;
d1335 1
a1335 1
		got_lo = true;
d1400 1
a1400 1
		return false;
d1404 1
a1404 1
	      gp_undefined = false;
d1479 1
a1479 1
		return false;
d1662 1
a1662 1
			return false;
d1746 2
a1747 2
			  int_rel.r_vaddr - input_section->vma, true)))
		    return false;
d1828 1
a1828 1
		  return false;
d1835 1
a1835 1
  return true;
d1840 1
a1840 1
static boolean
d1854 1
a1854 1
	return false;
d1868 1
a1868 1
	return false;
d1872 1
a1872 1
	return false;
d1875 1
a1875 1
  return true;
d1902 1
a1902 1
static boolean
d1907 1
a1907 1
     boolean *again;
d1917 1
a1917 1
  *again = false;
d1922 1
a1922 1
    return true;
d1926 1
a1926 1
    return true;
d1931 1
a1931 1
    return true;
d2076 1
a2076 1
      *again = true;
d2274 1
a2274 1
  return true;
d2279 1
a2279 1
  return false;
d2287 1
a2287 1
static boolean
d2324 1
a2324 1
  return true;
d2336 1
a2336 1
boolean
d2356 1
a2356 1
    return true;
d2361 1
a2361 1
    return false;
d2366 1
a2366 1
    return false;
d2376 1
a2376 1
      boolean text_relative;
d2396 1
a2396 1
	  return false;
d2412 1
a2412 1
	    text_relative = true;
d2414 1
a2414 1
	    text_relative = false;
d2421 1
a2421 1
	      text_relative = true;
d2426 1
a2426 1
	      text_relative = false;
d2433 1
a2433 1
	      return false;
d2441 1
a2441 1
	  return false;
d2450 1
a2450 1
  return true;
d2469 1
a2469 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true, false, 4, false, 2,
d2485 2
a2486 2
  /* True if the .rdata section is part of the text segment, as on the
     Alpha.  False if .rdata is part of the data segment, as on the
d2488 1
a2488 1
  false,
@


1.19.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d38 79
a116 44
static bfd_boolean mips_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static void mips_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void mips_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void mips_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void mips_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
static bfd_reloc_status_type mips_generic_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_refhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_reflo_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_gprel_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_relhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_rello_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_switch_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static void mips_relocate_hi
  PARAMS ((struct internal_reloc *refhi, struct internal_reloc *reflo,
	   bfd *input_bfd, asection *input_section, bfd_byte *contents,
	   size_t adjust, bfd_vma relocation, bfd_boolean pcrel));
static bfd_boolean mips_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static bfd_boolean mips_read_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean mips_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean mips_relax_pcrel16
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   struct ecoff_link_hash_entry *, bfd_byte *, bfd_vma));
d155 1
a155 1
	 FALSE,			/* pc_relative */
d160 1
a160 1
	 FALSE,			/* partial_inplace */
d163 1
a163 1
	 FALSE),		/* pcrel_offset */
d170 1
a170 1
	 FALSE,			/* pc_relative */
d175 1
a175 1
	 TRUE,			/* partial_inplace */
d178 1
a178 1
	 FALSE),		/* pcrel_offset */
d185 1
a185 1
	 FALSE,			/* pc_relative */
d190 1
a190 1
	 TRUE,			/* partial_inplace */
d193 1
a193 1
	 FALSE),		/* pcrel_offset */
d200 1
a200 1
	 FALSE,			/* pc_relative */
d208 1
a208 1
	 TRUE,			/* partial_inplace */
d211 1
a211 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 TRUE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d234 1
a234 1
	 FALSE,			/* pc_relative */
d239 1
a239 1
	 TRUE,			/* partial_inplace */
d242 1
a242 1
	 FALSE),		/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 TRUE,			/* partial_inplace */
d258 1
a258 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 FALSE,			/* pc_relative */
d271 1
a271 1
	 TRUE,			/* partial_inplace */
d274 1
a274 1
	 FALSE),		/* pcrel_offset */
d289 1
a289 1
	 TRUE,			/* pc_relative */
d294 1
a294 1
	 TRUE,			/* partial_inplace */
d297 1
a297 1
	 TRUE),			/* pcrel_offset */
d310 1
a310 1
	 TRUE,			/* pc_relative */
d315 1
a315 1
	 TRUE,			/* partial_inplace */
d318 1
a318 1
	 TRUE),			/* pcrel_offset */
d327 1
a327 1
	 TRUE,			/* pc_relative */
d332 1
a332 1
	 TRUE,			/* partial_inplace */
d335 1
a335 1
	 TRUE),			/* pcrel_offset */
d355 1
a355 1
	 TRUE,			/* pc_relative */
d360 1
a360 1
	 TRUE,			/* partial_inplace */
d363 1
a363 1
	 TRUE)			/* pcrel_offset */
d387 1
a387 1
static bfd_boolean
d398 1
a398 1
      return TRUE;
d411 1
a411 1
      return FALSE;
d589 1
a589 1
   sections.  If we are producing relocatable output, and the reloc
d597 1
a597 1
   relocatable output against an external symbol.  */
d796 1
a796 1
  bfd_boolean relocatable;
d815 1
a815 1
    relocatable = TRUE;
d818 1
a818 1
      relocatable = FALSE;
d822 1
a822 1
  if (bfd_is_und_section (symbol->section) && ! relocatable)
d829 1
a829 1
     external symbol if we are producing relocatable output.  */
d832 1
a832 1
      && (! relocatable
d835 1
a835 1
      if (relocatable)
d899 1
a899 1
     are producing relocatable output, we don't want to do this for
d901 1
a901 1
  if (! relocatable
d908 1
a908 1
  if (relocatable)
d1084 1
a1084 1
     correctly when generating a relocatable file, so handle them
d1188 1
a1188 1
     bfd_boolean pcrel;
d1232 1
a1232 1
static bfd_boolean
d1245 1
a1245 1
  bfd_boolean gp_undefined;
d1251 1
a1251 1
  bfd_boolean got_lo;
d1267 1
a1267 1
	return FALSE;
d1302 1
a1302 1
    gp_undefined = TRUE;
d1304 1
a1304 1
    gp_undefined = FALSE;
d1306 1
a1306 1
  got_lo = FALSE;
d1320 1
a1320 1
      bfd_boolean use_lo = FALSE;
d1333 1
a1333 1
	  got_lo = FALSE;
d1368 1
a1368 1
	      use_lo = TRUE;
d1370 1
a1370 1
		got_lo = TRUE;
d1435 1
a1435 1
		return FALSE;
d1439 1
a1439 1
	      gp_undefined = FALSE;
d1451 1
a1451 1
	  else if (! info->relocatable
d1470 1
a1470 1
		 zero).  We are generating relocatable output, and we
d1484 1
a1484 1
	  BFD_ASSERT (! info->relocatable);
d1514 1
a1514 1
		return FALSE;
d1562 1
a1562 1
      if (info->relocatable)
d1564 1
a1564 1
	  /* We are generating relocatable output, and must convert
d1697 1
a1697 1
			return FALSE;
d1781 2
a1782 2
			  int_rel.r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d1863 1
a1863 1
		  return FALSE;
d1870 1
a1870 1
  return TRUE;
d1875 1
a1875 1
static bfd_boolean
d1889 1
a1889 1
	return FALSE;
d1903 1
a1903 1
	return FALSE;
d1907 1
a1907 1
	return FALSE;
d1910 1
a1910 1
  return TRUE;
d1937 1
a1937 1
static bfd_boolean
d1942 1
a1942 1
     bfd_boolean *again;
d1952 1
a1952 1
  *again = FALSE;
d1957 1
a1957 1
    return TRUE;
d1961 1
a1961 1
    return TRUE;
d1966 1
a1966 1
    return TRUE;
d2111 1
a2111 1
      *again = TRUE;
d2309 1
a2309 1
  return TRUE;
d2314 1
a2314 1
  return FALSE;
d2322 1
a2322 1
static bfd_boolean
d2359 1
a2359 1
  return TRUE;
d2371 1
a2371 1
bfd_boolean
d2386 1
a2386 1
  BFD_ASSERT (! info->relocatable);
d2391 1
a2391 1
    return TRUE;
d2396 1
a2396 1
    return FALSE;
d2401 1
a2401 1
    return FALSE;
d2411 1
a2411 1
      bfd_boolean text_relative;
d2431 1
a2431 1
	  return FALSE;
d2447 1
a2447 1
	    text_relative = TRUE;
d2449 1
a2449 1
	    text_relative = FALSE;
d2456 1
a2456 1
	      text_relative = TRUE;
d2461 1
a2461 1
	      text_relative = FALSE;
d2468 1
a2468 1
	      return FALSE;
d2476 1
a2476 1
	  return FALSE;
d2485 1
a2485 1
  return TRUE;
d2504 1
a2504 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
d2520 2
a2521 2
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
d2523 1
a2523 1
  FALSE,
@


1.19.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d38 79
a116 44
static bfd_boolean mips_ecoff_bad_format_hook
  PARAMS ((bfd *abfd, PTR filehdr));
static void mips_ecoff_swap_reloc_in
  PARAMS ((bfd *, PTR, struct internal_reloc *));
static void mips_ecoff_swap_reloc_out
  PARAMS ((bfd *, const struct internal_reloc *, PTR));
static void mips_adjust_reloc_in
  PARAMS ((bfd *, const struct internal_reloc *, arelent *));
static void mips_adjust_reloc_out
  PARAMS ((bfd *, const arelent *, struct internal_reloc *));
static bfd_reloc_status_type mips_generic_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_refhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_reflo_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_gprel_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_relhi_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_rello_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static bfd_reloc_status_type mips_switch_reloc
  PARAMS ((bfd *abfd, arelent *reloc, asymbol *symbol, PTR data,
	   asection *section, bfd *output_bfd, char **error));
static void mips_relocate_hi
  PARAMS ((struct internal_reloc *refhi, struct internal_reloc *reflo,
	   bfd *input_bfd, asection *input_section, bfd_byte *contents,
	   size_t adjust, bfd_vma relocation, bfd_boolean pcrel));
static bfd_boolean mips_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, PTR));
static bfd_boolean mips_read_relocs
  PARAMS ((bfd *, asection *));
static bfd_boolean mips_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean mips_relax_pcrel16
  PARAMS ((struct bfd_link_info *, bfd *, asection *,
	   struct ecoff_link_hash_entry *, bfd_byte *, bfd_vma));
d155 1
a155 1
	 FALSE,			/* pc_relative */
d160 1
a160 1
	 FALSE,			/* partial_inplace */
d163 1
a163 1
	 FALSE),		/* pcrel_offset */
d170 1
a170 1
	 FALSE,			/* pc_relative */
d175 1
a175 1
	 TRUE,			/* partial_inplace */
d178 1
a178 1
	 FALSE),		/* pcrel_offset */
d185 1
a185 1
	 FALSE,			/* pc_relative */
d190 1
a190 1
	 TRUE,			/* partial_inplace */
d193 1
a193 1
	 FALSE),		/* pcrel_offset */
d200 1
a200 1
	 FALSE,			/* pc_relative */
d208 1
a208 1
	 TRUE,			/* partial_inplace */
d211 1
a211 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 TRUE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d234 1
a234 1
	 FALSE,			/* pc_relative */
d239 1
a239 1
	 TRUE,			/* partial_inplace */
d242 1
a242 1
	 FALSE),		/* pcrel_offset */
d250 1
a250 1
	 FALSE,			/* pc_relative */
d255 1
a255 1
	 TRUE,			/* partial_inplace */
d258 1
a258 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 FALSE,			/* pc_relative */
d271 1
a271 1
	 TRUE,			/* partial_inplace */
d274 1
a274 1
	 FALSE),		/* pcrel_offset */
d289 1
a289 1
	 TRUE,			/* pc_relative */
d294 1
a294 1
	 TRUE,			/* partial_inplace */
d297 1
a297 1
	 TRUE),			/* pcrel_offset */
d310 1
a310 1
	 TRUE,			/* pc_relative */
d315 1
a315 1
	 TRUE,			/* partial_inplace */
d318 1
a318 1
	 TRUE),			/* pcrel_offset */
d327 1
a327 1
	 TRUE,			/* pc_relative */
d332 1
a332 1
	 TRUE,			/* partial_inplace */
d335 1
a335 1
	 TRUE),			/* pcrel_offset */
d355 1
a355 1
	 TRUE,			/* pc_relative */
d360 1
a360 1
	 TRUE,			/* partial_inplace */
d363 1
a363 1
	 TRUE)			/* pcrel_offset */
d387 1
a387 1
static bfd_boolean
d398 1
a398 1
      return TRUE;
d411 1
a411 1
      return FALSE;
d796 1
a796 1
  bfd_boolean relocateable;
d815 1
a815 1
    relocateable = TRUE;
d818 1
a818 1
      relocateable = FALSE;
d1188 1
a1188 1
     bfd_boolean pcrel;
d1232 1
a1232 1
static bfd_boolean
d1245 1
a1245 1
  bfd_boolean gp_undefined;
d1251 1
a1251 1
  bfd_boolean got_lo;
d1267 1
a1267 1
	return FALSE;
d1302 1
a1302 1
    gp_undefined = TRUE;
d1304 1
a1304 1
    gp_undefined = FALSE;
d1306 1
a1306 1
  got_lo = FALSE;
d1320 1
a1320 1
      bfd_boolean use_lo = FALSE;
d1333 1
a1333 1
	  got_lo = FALSE;
d1368 1
a1368 1
	      use_lo = TRUE;
d1370 1
a1370 1
		got_lo = TRUE;
d1435 1
a1435 1
		return FALSE;
d1439 1
a1439 1
	      gp_undefined = FALSE;
d1514 1
a1514 1
		return FALSE;
d1697 1
a1697 1
			return FALSE;
d1781 2
a1782 2
			  int_rel.r_vaddr - input_section->vma, TRUE)))
		    return FALSE;
d1863 1
a1863 1
		  return FALSE;
d1870 1
a1870 1
  return TRUE;
d1875 1
a1875 1
static bfd_boolean
d1889 1
a1889 1
	return FALSE;
d1903 1
a1903 1
	return FALSE;
d1907 1
a1907 1
	return FALSE;
d1910 1
a1910 1
  return TRUE;
d1937 1
a1937 1
static bfd_boolean
d1942 1
a1942 1
     bfd_boolean *again;
d1952 1
a1952 1
  *again = FALSE;
d1957 1
a1957 1
    return TRUE;
d1961 1
a1961 1
    return TRUE;
d1966 1
a1966 1
    return TRUE;
d2111 1
a2111 1
      *again = TRUE;
d2309 1
a2309 1
  return TRUE;
d2314 1
a2314 1
  return FALSE;
d2322 1
a2322 1
static bfd_boolean
d2359 1
a2359 1
  return TRUE;
d2371 1
a2371 1
bfd_boolean
d2391 1
a2391 1
    return TRUE;
d2396 1
a2396 1
    return FALSE;
d2401 1
a2401 1
    return FALSE;
d2411 1
a2411 1
      bfd_boolean text_relative;
d2431 1
a2431 1
	  return FALSE;
d2447 1
a2447 1
	    text_relative = TRUE;
d2449 1
a2449 1
	    text_relative = FALSE;
d2456 1
a2456 1
	      text_relative = TRUE;
d2461 1
a2461 1
	      text_relative = FALSE;
d2468 1
a2468 1
	      return FALSE;
d2476 1
a2476 1
	  return FALSE;
d2485 1
a2485 1
  return TRUE;
d2504 1
a2504 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE, FALSE, 4, FALSE, 2,
d2520 2
a2521 2
  /* TRUE if the .rdata section is part of the text segment, as on the
     Alpha.  FALSE if .rdata is part of the data segment, as on the
d2523 1
a2523 1
  FALSE,
@


1.19.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d554 1
a554 1
   sections.  If we are producing relocatable output, and the reloc
d562 1
a562 1
   relocatable output against an external symbol.  */
d761 1
a761 1
  bfd_boolean relocatable;
d780 1
a780 1
    relocatable = TRUE;
d783 1
a783 1
      relocatable = FALSE;
d787 1
a787 1
  if (bfd_is_und_section (symbol->section) && ! relocatable)
d794 1
a794 1
     external symbol if we are producing relocatable output.  */
d797 1
a797 1
      && (! relocatable
d800 1
a800 1
      if (relocatable)
d864 1
a864 1
     are producing relocatable output, we don't want to do this for
d866 1
a866 1
  if (! relocatable
d873 1
a873 1
  if (relocatable)
d1049 1
a1049 1
     correctly when generating a relocatable file, so handle them
d1416 1
a1416 1
	  else if (! info->relocatable
d1435 1
a1435 1
		 zero).  We are generating relocatable output, and we
d1449 1
a1449 1
	  BFD_ASSERT (! info->relocatable);
d1527 1
a1527 1
      if (info->relocatable)
d1529 1
a1529 1
	  /* We are generating relocatable output, and must convert
d2351 1
a2351 1
  BFD_ASSERT (! info->relocatable);
@


1.18
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d822 1
a822 2
  if (bfd_is_und_section (symbol->section)
      && relocateable == false)
d832 1
a832 1
      && (relocateable == false
d835 1
a835 1
      if (relocateable != false)
d901 1
a901 1
  if (relocateable == false
d908 1
a908 1
  if (relocateable != false)
@


1.17
log
@	* coff-alpha.c: Update copyright date.
	* coff-mips.c: Likewise.
	* xcoff-target.h: Likewise.
@
text
@d2119 1
a2119 1
	  offsets = (long *) bfd_alloc (abfd, size);
a2121 1
	  memset (offsets, 0, (size_t) size);
@


1.16
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d3 1
a3 1
   2000, 2001
@


1.15
log
@	* coff-alpha.c (alpha_relocate_section): Unify warning message
	for GP relative relocations without GP defined.
	* coff-mips.c (mips_relocate_section): Likewise.
@
text
@d2605 2
@


1.15.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d2119 1
a2119 1
	  offsets = (long *) bfd_zalloc (abfd, size);
d2122 1
a2603 2

#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
@


1.15.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d822 2
a823 1
  if (bfd_is_und_section (symbol->section) && ! relocateable)
d833 1
a833 1
      && (! relocateable
d836 1
a836 1
      if (relocateable)
d902 1
a902 1
  if (! relocateable
d909 1
a909 1
  if (relocateable)
@


1.15.8.1
log
@merge from trunk
@
text
@d3 1
a3 1
   2000, 2001, 2002
d2119 1
a2119 1
	  offsets = (long *) bfd_zalloc (abfd, size);
d2122 1
a2603 2

#define _bfd_ecoff_bfd_discard_group bfd_generic_discard_group
@


1.14
log
@	* coff-mips.c (mips_bfd_reloc_type_lookup): Replace
	BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	* pe-mips.c (mips_bfd_reloc_type_lookup): Likewise.
	* elf32-mips.c (mips_reloc_map): Likewise. Replace
	BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	* elf64-mips.c (mips_reloc_map): Likewise.
	* reloc.c (BFD_RELOC_MIPS_GPREL): Remove.
	(BFD_RELOC_MIPS_GPREL32): Remove.
	* config/tc-mips.c (macro_build): Replace BFD_RELOC_MIPS_GPREL
	by BFD_RELOC_GPREL16.
	(load_address): Likewise.
	(macro): Likewise.
	(md_apply_fix): Likewise. Replace BFD_RELOC_MIPS_GPREL32 by
	BFD_RELOC_GPREL32.
	(s_gpword): Replace BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	(tc_gen_reloc): Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	*config/tc-mips.h: Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
@
text
@d1433 1
a1433 1
		     (info, _("GP relative relocation when GP not defined"),
@


1.13
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d1149 1
a1149 1
    case BFD_RELOC_MIPS_GPREL:
@


1.12
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d369 1
a369 1
/* When the linker is doing relaxing, it may change a external PCREL16
@


1.11
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d429 1
a429 1
  intern->r_vaddr = bfd_h_get_32 (abfd, (bfd_byte *) ext->r_vaddr);
d506 1
a506 1
  bfd_h_put_32 (abfd, intern->r_vaddr, (bfd_byte *) ext->r_vaddr);
d694 1
a694 1
  n = (struct mips_hi *) bfd_malloc (sizeof *n);
d761 2
a762 2
	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, insn, l->addr);
d857 1
a857 1
		  register CONST char *name;
d906 2
a907 2
  insn = (insn &~ 0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
d985 1
a985 1
  n = (struct mips_hi *) bfd_malloc (sizeof *n);
d1062 2
a1063 2
	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
	  bfd_put_32 (abfd, insn, l->addr);
d1226 1
a1226 1
  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
d1254 1
d1265 2
a1266 4
      symndx_to_section = ((asection **)
			   bfd_alloc (input_bfd,
				      (NUM_RELOC_SECTIONS
				       * sizeof (asection *))));
d1882 1
d1887 2
a1888 2
      sec->used_by_bfd =
	(PTR) bfd_alloc (abfd, sizeof (struct ecoff_section_tdata));
d1900 4
a1903 8
      bfd_size_type external_relocs_size;

      external_relocs_size = (ecoff_backend (abfd)->external_reloc_size
			      * sec->reloc_count);

      section_tdata->external_relocs =
	(PTR) bfd_alloc (abfd, external_relocs_size);
      if (section_tdata->external_relocs == NULL && external_relocs_size != 0)
d1907 1
a1907 3
	  || (bfd_read (section_tdata->external_relocs, 1,
			external_relocs_size, abfd)
	      != external_relocs_size))
d2006 1
d2083 1
a2083 1
	    contents = (bfd_byte *) bfd_malloc ((size_t) sec->_raw_size);
d2116 1
a2116 1
	  size_t size;
d2118 1
a2118 1
	  size = sec->reloc_count * sizeof (long);
d2122 1
a2122 1
	  memset (offsets, 0, size);
d2295 2
a2296 2
      adjust = ((struct ecoff_value_adjust *)
		bfd_alloc (abfd, sizeof (struct ecoff_value_adjust)));
d2349 1
a2349 1
  bfd_put_32 (input_bfd, 0x04110001, location); /* bal .+8 */
d2356 4
a2359 2
  bfd_put_32 (input_bfd, 0x003f0821, location + 12); /* addu $at,$at,$ra */
  bfd_put_32 (input_bfd, 0x0020f809, location + 16); /* jalr $at */
d2386 1
d2400 2
a2401 1
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, datasec->reloc_count * 4);
@


1.10
log
@Update copyright notices
@
text
@d2603 3
@


1.9
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.9.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.8
log
@2000-11-11  Kazu Hirata  <kazu@@hxi.com>

	* coff-i960.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
@
text
@a117 1

@


1.7
log
@	* coff-mips.c (mips_ecoff_backend_data):  Add initialization of
	_bfd_coff_force_symnames in strings and
	_bfd_coff_debug_string_prefix_length to their default values.
	* coff-sh.c: (bfd_coff_small_swap_table): Ditto.
@
text
@a1102 1
/*ARGSUSED*/
d1197 1
a1197 1
  
d1206 1
a1206 1
 
d1507 1
a1507 1
		       
d1628 1
a1628 1
		      
d2106 1
a2106 1
	  != 0x0411ffff) /* bgezal $0,. == bal . */
d2182 1
a2182 1
	      
d2645 1
a2645 1
  
d2688 1
a2688 1
  
d2732 1
a2732 1
  
@


1.6
log
@Fit 64-bit nits.
@
text
@d2508 1
a2508 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true, false, 4,
@


1.5
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d913 1
a913 1
  if (val >= 0x8000 && val < 0xffff8000)
@


1.4
log
@	* ecoff.c (bfd_debug_section): Update initialization for new
	comdat_info field.
	(_bfd_ecoff_styp_to_sec_flags): Add section parameter.
	* libecoff.h (_bfd_ecoff_styp_to_sec_flags): Update declaration.

1999-09-10  H.J. Lu  <hjl@@gnu.org>

	* coff-alpha.c (alpha_ecoff_backend_data): Initialize the new
	_bfd_filnmlen field.
	* coff-mips.c (mips_ecoff_backend_data): Likewise.
@
text
@d1784 1
a1784 1
			  int_rel.r_vaddr - input_section->vma)))
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d2508 1
a2508 1
    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, true, false, 4,
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2604 2
d2645 2
d2688 2
d2732 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d276 4
a279 4
  { 8 },
  { 9 },
  { 10 },
  { 11 },
d337 7
a343 7
  { 15 },
  { 16 },
  { 17 },
  { 18 },
  { 19 },
  { 20 },
  { 21 },
d572 1
a572 1
     bfd *abfd;
d607 1
a607 1
     bfd *abfd;
d610 1
a610 1
     PTR data;
d613 1
a613 1
     char **error_message;
d654 1
a654 1
     bfd *abfd;
d660 1
a660 1
     char **error_message;
d936 1
a936 1
     bfd *abfd;
d942 1
a942 1
     char **error_message;
d1112 7
a1118 7
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1127 1
a1127 1
     bfd *abfd;
d2332 1
a2332 1
     struct bfd_link_info *info;
d2334 1
a2334 1
     asection *input_section;
d2514 2
a2515 1
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

