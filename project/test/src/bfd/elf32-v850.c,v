head	1.90;
access;
symbols
	sid-snapshot-20180601:1.90
	sid-snapshot-20180501:1.90
	sid-snapshot-20180401:1.90
	sid-snapshot-20180301:1.90
	sid-snapshot-20180201:1.90
	sid-snapshot-20180101:1.90
	sid-snapshot-20171201:1.90
	sid-snapshot-20171101:1.90
	sid-snapshot-20171001:1.90
	sid-snapshot-20170901:1.90
	sid-snapshot-20170801:1.90
	sid-snapshot-20170701:1.90
	sid-snapshot-20170601:1.90
	sid-snapshot-20170501:1.90
	sid-snapshot-20170401:1.90
	sid-snapshot-20170301:1.90
	sid-snapshot-20170201:1.90
	sid-snapshot-20170101:1.90
	sid-snapshot-20161201:1.90
	sid-snapshot-20161101:1.90
	sid-snapshot-20160901:1.90
	sid-snapshot-20160801:1.90
	sid-snapshot-20160701:1.90
	sid-snapshot-20160601:1.90
	sid-snapshot-20160501:1.90
	sid-snapshot-20160401:1.90
	sid-snapshot-20160301:1.90
	sid-snapshot-20160201:1.90
	sid-snapshot-20160101:1.90
	sid-snapshot-20151201:1.90
	sid-snapshot-20151101:1.90
	sid-snapshot-20151001:1.90
	sid-snapshot-20150901:1.90
	sid-snapshot-20150801:1.90
	sid-snapshot-20150701:1.90
	sid-snapshot-20150601:1.90
	sid-snapshot-20150501:1.90
	sid-snapshot-20150401:1.90
	sid-snapshot-20150301:1.90
	sid-snapshot-20150201:1.90
	sid-snapshot-20150101:1.90
	sid-snapshot-20141201:1.90
	sid-snapshot-20141101:1.90
	sid-snapshot-20141001:1.90
	sid-snapshot-20140901:1.90
	sid-snapshot-20140801:1.90
	sid-snapshot-20140701:1.90
	sid-snapshot-20140601:1.90
	sid-snapshot-20140501:1.90
	sid-snapshot-20140401:1.90
	sid-snapshot-20140301:1.90
	sid-snapshot-20140201:1.90
	sid-snapshot-20140101:1.90
	sid-snapshot-20131201:1.90
	sid-snapshot-20131101:1.90
	sid-snapshot-20131001:1.90
	binutils-2_24-branch:1.90.0.2
	binutils-2_24-branchpoint:1.90
	binutils-2_21_1:1.80.2.1
	sid-snapshot-20130901:1.90
	gdb_7_6_1-2013-08-30-release:1.87
	sid-snapshot-20130801:1.90
	sid-snapshot-20130701:1.90
	sid-snapshot-20130601:1.90
	sid-snapshot-20130501:1.90
	gdb_7_6-2013-04-26-release:1.87
	sid-snapshot-20130401:1.88
	binutils-2_23_2:1.83
	gdb_7_6-branch:1.87.0.2
	gdb_7_6-2013-03-12-branchpoint:1.87
	sid-snapshot-20130301:1.87
	sid-snapshot-20130201:1.87
	sid-snapshot-20130101:1.85
	sid-snapshot-20121201:1.85
	gdb_7_5_1-2012-11-29-release:1.83
	binutils-2_23_1:1.83
	sid-snapshot-20121101:1.83
	binutils-2_23:1.83
	sid-snapshot-20121001:1.83
	sid-snapshot-20120901:1.83
	gdb_7_5-2012-08-17-release:1.83
	sid-snapshot-20120801:1.83
	binutils-2_23-branch:1.83.0.4
	binutils-2_23-branchpoint:1.83
	gdb_7_5-branch:1.83.0.2
	gdb_7_5-2012-07-18-branchpoint:1.83
	sid-snapshot-20120701:1.83
	sid-snapshot-20120601:1.83
	sid-snapshot-20120501:1.82
	binutils-2_22_branch:1.81.0.8
	gdb_7_4_1-2012-04-26-release:1.81
	sid-snapshot-20120401:1.81
	sid-snapshot-20120301:1.81
	sid-snapshot-20120201:1.81
	gdb_7_4-2012-01-24-release:1.81
	sid-snapshot-20120101:1.81
	gdb_7_4-branch:1.81.0.6
	gdb_7_4-2011-12-13-branchpoint:1.81
	sid-snapshot-20111201:1.81
	binutils-2_22:1.81
	sid-snapshot-20111101:1.81
	sid-snapshot-20111001:1.81
	binutils-2_22-branch:1.81.0.4
	binutils-2_22-branchpoint:1.81
	gdb_7_3_1-2011-09-04-release:1.81
	sid-snapshot-20110901:1.81
	sid-snapshot-20110801:1.81
	gdb_7_3-2011-07-26-release:1.81
	sid-snapshot-20110701:1.81
	sid-snapshot-20110601:1.81
	sid-snapshot-20110501:1.81
	gdb_7_3-branch:1.81.0.2
	gdb_7_3-2011-04-01-branchpoint:1.81
	sid-snapshot-20110401:1.81
	sid-snapshot-20110301:1.81
	sid-snapshot-20110201:1.81
	sid-snapshot-20110101:1.80
	binutils-2_21:1.80
	sid-snapshot-20101201:1.80
	binutils-2_21-branch:1.80.0.2
	binutils-2_21-branchpoint:1.80
	sid-snapshot-20101101:1.80
	sid-snapshot-20101001:1.79
	binutils-2_20_1:1.75
	gdb_7_2-2010-09-02-release:1.78
	sid-snapshot-20100901:1.79
	sid-snapshot-20100801:1.79
	gdb_7_2-branch:1.78.0.2
	gdb_7_2-2010-07-07-branchpoint:1.78
	sid-snapshot-20100701:1.78
	sid-snapshot-20100601:1.77
	sid-snapshot-20100501:1.77
	sid-snapshot-20100401:1.77
	gdb_7_1-2010-03-18-release:1.77
	sid-snapshot-20100301:1.77
	gdb_7_1-branch:1.77.0.2
	gdb_7_1-2010-02-18-branchpoint:1.77
	sid-snapshot-20100201:1.77
	sid-snapshot-20100101:1.76
	gdb_7_0_1-2009-12-22-release:1.75
	sid-snapshot-20091201:1.75
	sid-snapshot-20091101:1.75
	binutils-2_20:1.75
	gdb_7_0-2009-10-06-release:1.75
	sid-snapshot-20091001:1.75
	gdb_7_0-branch:1.75.0.4
	gdb_7_0-2009-09-16-branchpoint:1.75
	arc-sim-20090309:1.71
	binutils-arc-20081103-branch:1.71.0.20
	binutils-arc-20081103-branchpoint:1.71
	binutils-2_20-branch:1.75.0.2
	binutils-2_20-branchpoint:1.75
	sid-snapshot-20090901:1.74
	sid-snapshot-20090801:1.74
	msnyder-checkpoint-072509-branch:1.74.0.4
	msnyder-checkpoint-072509-branchpoint:1.74
	sid-snapshot-20090701:1.74
	dje-cgen-play1-branch:1.74.0.2
	dje-cgen-play1-branchpoint:1.74
	sid-snapshot-20090601:1.73
	sid-snapshot-20090501:1.72
	sid-snapshot-20090401:1.72
	arc-20081103-branch:1.71.0.18
	arc-20081103-branchpoint:1.71
	arc-insight_6_8-branch:1.71.0.16
	arc-insight_6_8-branchpoint:1.71
	insight_6_8-branch:1.71.0.14
	insight_6_8-branchpoint:1.71
	sid-snapshot-20090301:1.72
	binutils-2_19_1:1.71
	sid-snapshot-20090201:1.72
	sid-snapshot-20090101:1.72
	reverse-20081226-branch:1.72.0.2
	reverse-20081226-branchpoint:1.72
	sid-snapshot-20081201:1.72
	multiprocess-20081120-branch:1.71.0.12
	multiprocess-20081120-branchpoint:1.71
	sid-snapshot-20081101:1.71
	binutils-2_19:1.71
	sid-snapshot-20081001:1.71
	reverse-20080930-branch:1.71.0.10
	reverse-20080930-branchpoint:1.71
	binutils-2_19-branch:1.71.0.8
	binutils-2_19-branchpoint:1.71
	sid-snapshot-20080901:1.71
	sid-snapshot-20080801:1.71
	reverse-20080717-branch:1.71.0.6
	reverse-20080717-branchpoint:1.71
	sid-snapshot-20080701:1.71
	msnyder-reverse-20080609-branch:1.71.0.4
	msnyder-reverse-20080609-branchpoint:1.71
	drow-reverse-20070409-branch:1.68.0.2
	drow-reverse-20070409-branchpoint:1.68
	sid-snapshot-20080601:1.71
	sid-snapshot-20080501:1.71
	sid-snapshot-20080403:1.71
	sid-snapshot-20080401:1.71
	gdb_6_8-2008-03-27-release:1.71
	sid-snapshot-20080301:1.71
	gdb_6_8-branch:1.71.0.2
	gdb_6_8-2008-02-26-branchpoint:1.71
	sid-snapshot-20080201:1.71
	sid-snapshot-20080101:1.71
	sid-snapshot-20071201:1.71
	sid-snapshot-20071101:1.71
	gdb_6_7_1-2007-10-29-release:1.70
	gdb_6_7-2007-10-10-release:1.70
	sid-snapshot-20071001:1.71
	gdb_6_7-branch:1.70.0.4
	gdb_6_7-2007-09-07-branchpoint:1.70
	binutils-2_18:1.70
	binutils-2_18-branch:1.70.0.2
	binutils-2_18-branchpoint:1.70
	insight_6_6-20070208-release:1.64
	binutils-csl-coldfire-4_1-32:1.61
	binutils-csl-sourcerygxx-4_1-32:1.61
	gdb_6_6-2006-12-18-release:1.64
	binutils-csl-innovasic-fido-3_4_4-33:1.61
	binutils-csl-sourcerygxx-3_4_4-32:1.50
	binutils-csl-coldfire-4_1-30:1.61
	binutils-csl-sourcerygxx-4_1-30:1.61
	binutils-csl-coldfire-4_1-28:1.61
	binutils-csl-sourcerygxx-4_1-29:1.61
	binutils-csl-sourcerygxx-4_1-28:1.61
	gdb_6_6-branch:1.64.0.2
	gdb_6_6-2006-11-15-branchpoint:1.64
	binutils-csl-arm-2006q3-27:1.61
	binutils-csl-sourcerygxx-4_1-27:1.61
	binutils-csl-arm-2006q3-26:1.61
	binutils-csl-sourcerygxx-4_1-26:1.61
	binutils-csl-sourcerygxx-4_1-25:1.61
	binutils-csl-sourcerygxx-4_1-24:1.61
	binutils-csl-sourcerygxx-4_1-23:1.61
	insight_6_5-20061003-release:1.62
	gdb-csl-symbian-6_4_50_20060226-12:1.61
	binutils-csl-sourcerygxx-4_1-21:1.61
	binutils-csl-arm-2006q3-21:1.61
	binutils-csl-sourcerygxx-4_1-22:1.61
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.61
	binutils-csl-sourcerygxx-4_1-20:1.61
	binutils-csl-arm-2006q3-19:1.61
	binutils-csl-sourcerygxx-4_1-19:1.61
	binutils-csl-sourcerygxx-4_1-18:1.61
	binutils-csl-renesas-4_1-9:1.61
	gdb-csl-sourcerygxx-3_4_4-25:1.61
	binutils-csl-sourcerygxx-3_4_4-25:1.50
	nickrob-async-20060828-mergepoint:1.62
	gdb-csl-symbian-6_4_50_20060226-11:1.61
	binutils-csl-renesas-4_1-8:1.61
	binutils-csl-renesas-4_1-7:1.61
	binutils-csl-renesas-4_1-6:1.61
	gdb-csl-sourcerygxx-4_1-17:1.61
	binutils-csl-sourcerygxx-4_1-17:1.61
	gdb-csl-20060226-branch-local-2:1.61
	gdb-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-14:1.61
	binutils-csl-sourcerygxx-4_1-15:1.61
	gdb-csl-sourcerygxx-4_1-13:1.61
	binutils-csl-sourcerygxx-4_1-13:1.61
	binutils-2_17:1.61
	gdb-csl-sourcerygxx-4_1-12:1.61
	binutils-csl-sourcerygxx-4_1-12:1.61
	gdb-csl-sourcerygxx-3_4_4-21:1.61
	binutils-csl-sourcerygxx-3_4_4-21:1.61
	gdb_6_5-20060621-release:1.62
	binutils-csl-wrs-linux-3_4_4-24:1.50
	binutils-csl-wrs-linux-3_4_4-23:1.50
	gdb-csl-sourcerygxx-4_1-9:1.61
	binutils-csl-sourcerygxx-4_1-9:1.61
	gdb-csl-sourcerygxx-4_1-8:1.61
	binutils-csl-sourcerygxx-4_1-8:1.61
	gdb-csl-sourcerygxx-4_1-7:1.61
	binutils-csl-sourcerygxx-4_1-7:1.61
	gdb-csl-arm-2006q1-6:1.61
	binutils-csl-arm-2006q1-6:1.61
	gdb-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-sourcerygxx-4_1-6:1.61
	binutils-csl-wrs-linux-3_4_4-22:1.50
	gdb-csl-symbian-6_4_50_20060226-10:1.61
	gdb-csl-symbian-6_4_50_20060226-9:1.61
	gdb-csl-symbian-6_4_50_20060226-8:1.61
	gdb-csl-coldfire-4_1-11:1.61
	binutils-csl-coldfire-4_1-11:1.61
	gdb-csl-sourcerygxx-3_4_4-19:1.61
	binutils-csl-sourcerygxx-3_4_4-19:1.61
	gdb-csl-coldfire-4_1-10:1.61
	gdb_6_5-branch:1.62.0.4
	gdb_6_5-2006-05-14-branchpoint:1.62
	binutils-csl-coldfire-4_1-10:1.61
	gdb-csl-sourcerygxx-4_1-5:1.61
	binutils-csl-sourcerygxx-4_1-5:1.61
	nickrob-async-20060513-branch:1.62.0.2
	nickrob-async-20060513-branchpoint:1.62
	gdb-csl-sourcerygxx-4_1-4:1.61
	binutils-csl-sourcerygxx-4_1-4:1.61
	msnyder-reverse-20060502-branch:1.61.0.24
	msnyder-reverse-20060502-branchpoint:1.61
	binutils-csl-wrs-linux-3_4_4-21:1.50
	gdb-csl-morpho-4_1-4:1.61
	binutils-csl-morpho-4_1-4:1.61
	gdb-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-sourcerygxx-3_4_4-17:1.61
	binutils-csl-wrs-linux-3_4_4-20:1.50
	readline_5_1-import-branch:1.61.0.22
	readline_5_1-import-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.61
	binutils-2_17-branch:1.61.0.20
	binutils-2_17-branchpoint:1.61
	gdb-csl-symbian-20060226-branch:1.61.0.18
	gdb-csl-symbian-20060226-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.61
	msnyder-reverse-20060331-branch:1.61.0.16
	msnyder-reverse-20060331-branchpoint:1.61
	binutils-csl-2_17-branch:1.61.0.14
	binutils-csl-2_17-branchpoint:1.61
	gdb-csl-available-20060303-branch:1.61.0.12
	gdb-csl-available-20060303-branchpoint:1.61
	gdb-csl-20060226-branch:1.61.0.10
	gdb-csl-20060226-branchpoint:1.61
	gdb_6_4-20051202-release:1.61
	msnyder-fork-checkpoint-branch:1.61.0.8
	msnyder-fork-checkpoint-branchpoint:1.61
	gdb-csl-gxxpro-6_3-branch:1.61.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.61
	gdb_6_4-branch:1.61.0.4
	gdb_6_4-2005-11-01-branchpoint:1.61
	gdb-csl-arm-20051020-branch:1.61.0.2
	gdb-csl-arm-20051020-branchpoint:1.61
	binutils-csl-gxxpro-3_4-branch:1.50.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.50
	binutils-2_16_1:1.50
	msnyder-tracepoint-checkpoint-branch:1.55.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.55
	gdb-csl-arm-20050325-2005-q1b:1.51
	binutils-csl-arm-2005q1b:1.50
	binutils-2_16:1.50
	gdb-csl-arm-20050325-2005-q1a:1.51
	binutils-csl-arm-2005q1a:1.50
	csl-arm-20050325-branch:1.51.0.2
	csl-arm-20050325-branchpoint:1.51
	binutils-csl-arm-2005q1-branch:1.50.0.4
	binutils-csl-arm-2005q1-branchpoint:1.50
	binutils-2_16-branch:1.50.0.2
	binutils-2_16-branchpoint:1.50
	csl-arm-2004-q3d:1.47
	gdb_6_3-20041109-release:1.46
	gdb_6_3-branch:1.46.0.2
	gdb_6_3-20041019-branchpoint:1.46
	csl-arm-2004-q3:1.46
	drow_intercu-merge-20040921:1.46
	drow_intercu-merge-20040915:1.46
	jimb-gdb_6_2-e500-branch:1.45.0.6
	jimb-gdb_6_2-e500-branchpoint:1.45
	gdb_6_2-20040730-release:1.45
	gdb_6_2-branch:1.45.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.45
	gdb_6_1_1-20040616-release:1.39
	binutils-2_15:1.39.6.1
	binutils-2_15-branchpoint:1.39
	csl-arm-2004-q1a:1.43
	csl-arm-2004-q1:1.43
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.43
	drow_intercu-merge-20040327:1.42
	ezannoni_pie-20040323-branch:1.41.0.2
	ezannoni_pie-20040323-branchpoint:1.41
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.39.0.12
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.39.0.8
	drow_intercu-20040221-branchpoint:1.39
	binutils-2_15-branch:1.39.0.6
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	csl-arm-2003-q4:1.39
	drow-cplus-merge-20031224:1.39
	drow-cplus-merge-20031220:1.39
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.39
	carlton-dictionary-20031111-merge:1.37
	gdb_6_0-2003-10-04-release:1.32
	kettenis_sparc-20030918-branch:1.35.0.4
	kettenis_sparc-20030918-branchpoint:1.35
	carlton_dictionary-20030917-merge:1.35
	ezannoni_pie-20030916-branchpoint:1.35
	ezannoni_pie-20030916-branch:1.35.0.2
	cagney_x86i386-20030821-branch:1.34.0.2
	cagney_x86i386-20030821-branchpoint:1.34
	carlton_dictionary-20030805-merge:1.34
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.32.0.6
	gdb_6_0-2003-06-23-branchpoint:1.32
	jimb-ppc64-linux-20030613-branch:1.32.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.32
	binutils-2_14:1.30.22.1
	cagney_convert-20030606-branch:1.32.0.2
	cagney_convert-20030606-branchpoint:1.32
	cagney_writestrings-20030508-branch:1.31.0.8
	cagney_writestrings-20030508-branchpoint:1.31
	jimb-ppc64-linux-20030528-branch:1.31.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.31
	carlton_dictionary-20030523-merge:1.31
	cagney_fileio-20030521-branch:1.31.0.4
	cagney_fileio-20030521-branchpoint:1.31
	kettenis_i386newframe-20030517-mergepoint:1.31
	jimb-ppc64-linux-20030509-branch:1.31.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.31
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	binutils-2_14-branch:1.30.0.22
	binutils-2_14-branchpoint:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.20
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.18
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.16
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.30.0.14
	cagney_framebase-20030326-branchpoint:1.30
	cagney_lazyid-20030317-branch:1.30.0.12
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.10
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.8
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.6
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.30
	interps-20030202-branch:1.30.0.4
	interps-20030202-branchpoint:1.30
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	binutils-2_13_2_1:1.23
	binutils-2_13_2:1.23
	carlton_dictionary-20021223-merge:1.30
	gdb_5_3-2002-12-12-release:1.27
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.23
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.27
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.8
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.6
	carlton_dictionary-20020920-branchpoint:1.27
	sid-20020905-branchpoint:1.27
	sid-20020905-branch:1.27.0.4
	gdb_5_3-branch:1.27.0.2
	gdb_5_3-2002-09-04-branchpoint:1.27
	kseitz_interps-20020829-merge:1.25
	cagney_sysregs-20020825-branch:1.24.0.4
	cagney_sysregs-20020825-branchpoint:1.24
	readline_4_3-import-branch:1.24.0.2
	readline_4_3-import-branchpoint:1.24
	binutils-2_13:1.23
	gdb_5_2_1-2002-07-23-release:1.20
	binutils-2_13-branchpoint:1.23
	binutils-2_13-branch:1.23.0.2
	kseitz_interps-20020528-branch:1.20.0.10
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.20.0.8
	cagney_regbuf-20020515-branchpoint:1.20
	binutils-2_12_1:1.20
	jimb-macro-020506-branch:1.20.0.6
	jimb-macro-020506-branchpoint:1.20
	gdb_5_2-2002-04-29-release:1.20
	binutils-2_12:1.20
	gdb_5_2-branch:1.20.0.4
	gdb_5_2-2002-03-03-branchpoint:1.20
	binutils-2_12-branch:1.20.0.2
	binutils-2_12-branchpoint:1.20
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8.2.1
	x86_64versiong3:1.9
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.4
	gdb_5_0-2000-04-10-branchpoint:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.90
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.5
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.90
date	2013.04.24.13.19.27;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.03.14.42.10;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.24.11.13.59;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2012.11.09.17.36.12;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2012.11.09.08.29.29;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.82;

1.82
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2011.01.14.12.35.56;	author amodra;	state Exp;
branches
	1.81.4.1;
next	1.80;

1.80
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2010.07.23.14.52.46;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.27.04.07.52;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.11.14.19.40;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.22.00.52.20;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2009.05.21.14.15.48;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.08.11.38.58;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.08.11.28.35;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.08.00.26.45;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.01.11.16.29;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.20.18.12.08;	author hjl;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.15.08.22.45;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.17.10.22.40;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.07.13.22.51;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.04.15.53.22;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.20.23.36.17;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.03.11.40.59;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.31.23.13.23;	author bje;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.16.16.56.00;	author rsandifo;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.21.15.28.25;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2004.08.13.03.15.58;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.29.13.46.32;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.20.23.16.41;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches
	1.39.6.1
	1.39.8.1
	1.39.12.1;
next	1.38;

1.38
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.04.11.04.34;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.25.06.40.20;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.03.16.24.04;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.09.02.27.04;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches
	1.30.20.1
	1.30.22.1;
next	1.29;

1.29
date	2002.11.28.11.55.41;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.03.10.43.44;	author hp;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.02.14.23.43;	author nickc;	state Exp;
branches
	1.27.6.1
	1.27.8.1;
next	1.26;

1.26
date	2002.09.02.11.47.42;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.29.06.49.33;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.25.06.21.52;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches
	1.20.8.1
	1.20.10.1;
next	1.19;

1.19
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.12.23.53.31;	author aoliva;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.09.47.35;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.13.10.43.29;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.13.10.06.11;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.04.22.14.19;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.12.08.18.34.31;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.10.29.34;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.12.07.35.11;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.02.41.43;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.14.57.28;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.81.4.1
date	2012.05.11.12.24.28;	author nickc;	state Exp;
branches;
next	;

1.80.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.39.6.1
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.39.8.1
date	2004.03.27.17.37.34;	author drow;	state Exp;
branches;
next	1.39.8.2;

1.39.8.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.39.8.3;

1.39.8.3
date	2004.09.16.17.00.28;	author drow;	state Exp;
branches;
next	;

1.39.12.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.30.20.1
date	2003.05.18.09.43.43;	author kettenis;	state Exp;
branches;
next	;

1.30.22.1
date	2003.06.03.16.26.48;	author nickc;	state Exp;
branches;
next	;

1.27.6.1
date	2002.11.15.19.18.27;	author carlton;	state Exp;
branches;
next	1.27.6.2;

1.27.6.2
date	2002.12.23.19.37.45;	author carlton;	state Exp;
branches;
next	1.27.6.3;

1.27.6.3
date	2003.05.23.18.40.25;	author carlton;	state Exp;
branches;
next	1.27.6.4;

1.27.6.4
date	2003.06.27.21.49.18;	author carlton;	state Exp;
branches;
next	1.27.6.5;

1.27.6.5
date	2003.08.05.17.12.49;	author carlton;	state Exp;
branches;
next	1.27.6.6;

1.27.6.6
date	2003.09.17.21.27.53;	author carlton;	state Exp;
branches;
next	1.27.6.7;

1.27.6.7
date	2003.11.11.23.50.20;	author carlton;	state Exp;
branches;
next	1.27.6.8;

1.27.6.8
date	2003.12.15.23.59.32;	author carlton;	state Exp;
branches;
next	;

1.27.8.1
date	2003.12.14.20.26.42;	author drow;	state Exp;
branches;
next	;

1.20.8.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.20.10.1
date	2002.06.20.01.30.23;	author kseitz;	state Exp;
branches;
next	1.20.10.2;

1.20.10.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	1.20.10.3;

1.20.10.3
date	2002.08.09.18.34.15;	author kseitz;	state Exp;
branches;
next	1.20.10.4;

1.20.10.4
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	1.20.10.5;

1.20.10.5
date	2002.10.01.00.45.47;	author kseitz;	state Exp;
branches;
next	1.20.10.6;

1.20.10.6
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.8.2.1
date	2001.02.10.20.09.18;	author nickc;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.90
log
@	* ecoff.c: casting the return value of BFD_ALIGN to int
	* elf32-tic6x.c: removing unused variables
	* elf32-v850.c: redefine the type of a variable (int -> bfd_vma)
	* vms-alpha.c: initialize a variable
@
text
@/* V850-specific support for 32-bit ELF
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* XXX FIXME: This code is littered with 32bit int, 16bit short, 8bit char
   dependencies.  As is the gas & simulator code for the v850.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/v850.h"
#include "libiberty.h"

/* Sign-extend a 17-bit number.  */
#define SEXT17(x)	((((x) & 0x1ffff) ^ 0x10000) - 0x10000)

/* Sign-extend a 22-bit number.  */
#define SEXT22(x)	((((x) & 0x3fffff) ^ 0x200000) - 0x200000)

static reloc_howto_type v850_elf_howto_table[];

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
v850_elf_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  bfd_boolean ret = TRUE;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  unsigned int r_type;
  int other = 0;
  const char *common = NULL;

  if (info->relocatable)
    return TRUE;

#ifdef DEBUG
  _bfd_error_handler ("v850_elf_check_relocs called for section %A in %B",
		      sec, abfd);
#endif

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	default:
	  break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_V850_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries
	   are actually used.  Record for later use during GC.  */
        case R_V850_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_V850_SDA_16_16_SPLIT_OFFSET:
	case R_V850_SDA_16_16_OFFSET:
	case R_V850_SDA_15_16_OFFSET:
	case R_V810_GPWLO_1:
	case R_V850_HWLO:
	case R_V850_HWLO_1:
	  other = V850_OTHER_SDA;
	  common = ".scommon";
	  goto small_data_common;

	case R_V850_ZDA_16_16_SPLIT_OFFSET:
	case R_V850_ZDA_16_16_OFFSET:
	case R_V850_ZDA_15_16_OFFSET:
	  other = V850_OTHER_ZDA;
	  common = ".zcommon";
	  goto small_data_common;

	case R_V850_TDA_4_4_OFFSET:
	case R_V850_TDA_4_5_OFFSET:
	case R_V850_TDA_7_7_OFFSET:
	case R_V850_TDA_6_8_OFFSET:
	case R_V850_TDA_7_8_OFFSET:
	case R_V850_TDA_16_16_OFFSET:
	  other = V850_OTHER_TDA;
	  common = ".tcommon";
	  /* fall through */

#define V850_OTHER_MASK (V850_OTHER_TDA | V850_OTHER_SDA | V850_OTHER_ZDA)

	small_data_common:
	  if (h)
	    {
	      /* Flag which type of relocation was used.  */
	      h->other |= other;
	      if ((h->other & V850_OTHER_MASK) != (other & V850_OTHER_MASK)
		  && (h->other & V850_OTHER_ERROR) == 0)
		{
		  const char * msg;
		  static char  buff[200]; /* XXX */

		  switch (h->other & V850_OTHER_MASK)
		    {
		    default:
		      msg = _("Variable `%s' cannot occupy in multiple small data regions");
		      break;
		    case V850_OTHER_SDA | V850_OTHER_ZDA | V850_OTHER_TDA:
		      msg = _("Variable `%s' can only be in one of the small, zero, and tiny data regions");
		      break;
		    case V850_OTHER_SDA | V850_OTHER_ZDA:
		      msg = _("Variable `%s' cannot be in both small and zero data regions simultaneously");
		      break;
		    case V850_OTHER_SDA | V850_OTHER_TDA:
		      msg = _("Variable `%s' cannot be in both small and tiny data regions simultaneously");
		      break;
		    case V850_OTHER_ZDA | V850_OTHER_TDA:
		      msg = _("Variable `%s' cannot be in both zero and tiny data regions simultaneously");
		      break;
		    }

		  sprintf (buff, msg, h->root.root.string);
		  info->callbacks->warning (info, buff, h->root.root.string,
					    abfd, h->root.u.def.section,
					    (bfd_vma) 0);

		  bfd_set_error (bfd_error_bad_value);
		  h->other |= V850_OTHER_ERROR;
		  ret = FALSE;
		}
	    }

	  if (h && h->root.type == bfd_link_hash_common
	      && h->root.u.c.p
	      && !strcmp (bfd_get_section_name (abfd, h->root.u.c.p->section), "COMMON"))
	    {
	      asection * section;

	      section = h->root.u.c.p->section = bfd_make_section_old_way (abfd, common);
	      section->flags |= SEC_IS_COMMON;
	    }

#ifdef DEBUG
	  fprintf (stderr, "v850_elf_check_relocs, found %s relocation for %s%s\n",
		   v850_elf_howto_table[ (int)r_type ].name,
		   (h && h->root.root.string) ? h->root.root.string : "<unknown>",
		   (h->root.type == bfd_link_hash_common) ? ", symbol is common" : "");
#endif
	  break;
	}
    }

  return ret;
}

/* In the old version, when an entry was checked out from the table,
   it was deleted.  This produced an error if the entry was needed
   more than once, as the second attempted retry failed.

   In the current version, the entry is not deleted, instead we set
   the field 'found' to TRUE.  If a second lookup matches the same
   entry, then we know that the hi16s reloc has already been updated
   and does not need to be updated a second time.

   TODO - TOFIX: If it is possible that we need to restore 2 different
   addresses from the same table entry, where the first generates an
   overflow, whilst the second do not, then this code will fail.  */

typedef struct hi16s_location
{
  bfd_vma                 addend;
  bfd_byte *              address;
  unsigned long           counter;
  bfd_boolean             found;
  struct hi16s_location * next;
}
hi16s_location;

static hi16s_location * previous_hi16s;
static hi16s_location * free_hi16s;
static unsigned long    hi16s_counter;

static void
remember_hi16s_reloc (bfd *abfd, bfd_vma addend, bfd_byte *address)
{
  hi16s_location * entry = NULL;
  bfd_size_type amt = sizeof (* free_hi16s);

  /* Find a free structure.  */
  if (free_hi16s == NULL)
    free_hi16s = bfd_zalloc (abfd, amt);

  entry      = free_hi16s;
  free_hi16s = free_hi16s->next;

  entry->addend  = addend;
  entry->address = address;
  entry->counter = hi16s_counter ++;
  entry->found   = FALSE;
  entry->next    = previous_hi16s;
  previous_hi16s = entry;

  /* Cope with wrap around of our counter.  */
  if (hi16s_counter == 0)
    {
      /* XXX: Assume that all counter entries differ only in their low 16 bits.  */
      for (entry = previous_hi16s; entry != NULL; entry = entry->next)
	entry->counter &= 0xffff;

      hi16s_counter = 0x10000;
    }
}

static bfd_byte *
find_remembered_hi16s_reloc (bfd_vma addend, bfd_boolean *already_found)
{
  hi16s_location *match = NULL;
  hi16s_location *entry;
  bfd_byte *addr;

  /* Search the table.  Record the most recent entry that matches.  */
  for (entry = previous_hi16s; entry; entry = entry->next)
    {
      if (entry->addend == addend
	  && (match == NULL || match->counter < entry->counter))
	{
	  match    = entry;
	}
    }

  if (match == NULL)
    return NULL;

  /* Extract the address.  */
  addr = match->address;

  /* Remember if this entry has already been used before.  */
  if (already_found)
    * already_found = match->found;

  /* Note that this entry has now been used.  */
  match->found = TRUE;

  return addr;
}

/* Calculate the final operand value for a R_V850_LO16 or
   R_V850_LO16_SPLIT_OFFSET.  *INSN is the current operand value and
   ADDEND is the sum of the relocation symbol and offset.  Store the
   operand value in *INSN and return true on success.

   The assembler has already done some of this: If the value stored in
   the instruction has its 15th bit set, (counting from zero) then the
   assembler will have added 1 to the value stored in the associated
   HI16S reloc.  So for example, these relocations:

       movhi hi( fred ), r0, r1
       movea lo( fred ), r1, r1

   will store 0 in the value fields for the MOVHI and MOVEA instructions
   and addend will be the address of fred, but for these instructions:

       movhi hi( fred + 0x123456 ), r0, r1
       movea lo( fred + 0x123456 ), r1, r1

   the value stored in the MOVHI instruction will be 0x12 and the value
   stored in the MOVEA instruction will be 0x3456.  If however the
   instructions were:

       movhi hi( fred + 0x10ffff ), r0, r1
       movea lo( fred + 0x10ffff ), r1, r1

   then the value stored in the MOVHI instruction would be 0x11 (not
   0x10) and the value stored in the MOVEA instruction would be 0xffff.
   Thus (assuming for the moment that the addend is 0), at run time the
   MOVHI instruction loads 0x110000 into r1, then the MOVEA instruction
   adds 0xffffffff (sign extension!) producing 0x10ffff.  Similarly if
   the instructions were:

       movhi hi( fred - 1 ), r0, r1
       movea lo( fred - 1 ), r1, r1

   then 0 is stored in the MOVHI instruction and -1 is stored in the
   MOVEA instruction.

   Overflow can occur if the addition of the value stored in the
   instruction plus the addend sets the 15th bit when before it was clear.
   This is because the 15th bit will be sign extended into the high part,
   thus reducing its value by one, but since the 15th bit was originally
   clear, the assembler will not have added 1 to the previous HI16S reloc
   to compensate for this effect.  For example:

      movhi hi( fred + 0x123456 ), r0, r1
      movea lo( fred + 0x123456 ), r1, r1

   The value stored in HI16S reloc is 0x12, the value stored in the LO16
   reloc is 0x3456.  If we assume that the address of fred is 0x00007000
   then the relocations become:

     HI16S: 0x0012 + (0x00007000 >> 16)    = 0x12
     LO16:  0x3456 + (0x00007000 & 0xffff) = 0xa456

   but when the instructions are executed, the MOVEA instruction's value
   is signed extended, so the sum becomes:

	0x00120000
      + 0xffffa456
      ------------
	0x0011a456    but 'fred + 0x123456' = 0x0012a456

   Note that if the 15th bit was set in the value stored in the LO16
   reloc, then we do not have to do anything:

      movhi hi( fred + 0x10ffff ), r0, r1
      movea lo( fred + 0x10ffff ), r1, r1

      HI16S:  0x0011 + (0x00007000 >> 16)    = 0x11
      LO16:   0xffff + (0x00007000 & 0xffff) = 0x6fff

	0x00110000
      + 0x00006fff
      ------------
	0x00116fff  = fred + 0x10ffff = 0x7000 + 0x10ffff

   Overflow can also occur if the computation carries into the 16th bit
   and it also results in the 15th bit having the same value as the 15th
   bit of the original value.   What happens is that the HI16S reloc
   will have already examined the 15th bit of the original value and
   added 1 to the high part if the bit is set.  This compensates for the
   sign extension of 15th bit of the result of the computation.  But now
   there is a carry into the 16th bit, and this has not been allowed for.

   So, for example if fred is at address 0xf000:

     movhi hi( fred + 0xffff ), r0, r1    [bit 15 of the offset is set]
     movea lo( fred + 0xffff ), r1, r1

     HI16S: 0x0001 + (0x0000f000 >> 16)    = 0x0001
     LO16:  0xffff + (0x0000f000 & 0xffff) = 0xefff   (carry into bit 16 is lost)

       0x00010000
     + 0xffffefff
     ------------
       0x0000efff   but 'fred + 0xffff' = 0x0001efff

   Similarly, if the 15th bit remains clear, but overflow occurs into
   the 16th bit then (assuming the address of fred is 0xf000):

     movhi hi( fred + 0x7000 ), r0, r1    [bit 15 of the offset is clear]
     movea lo( fred + 0x7000 ), r1, r1

     HI16S: 0x0000 + (0x0000f000 >> 16)    = 0x0000
     LO16:  0x7000 + (0x0000f000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)

       0x00000000
     + 0x00006fff
     ------------
       0x00006fff   but 'fred + 0x7000' = 0x00016fff

   Note - there is no need to change anything if a carry occurs, and the
   15th bit changes its value from being set to being clear, as the HI16S
   reloc will have already added in 1 to the high part for us:

     movhi hi( fred + 0xffff ), r0, r1     [bit 15 of the offset is set]
     movea lo( fred + 0xffff ), r1, r1

     HI16S: 0x0001 + (0x00007000 >> 16)
     LO16:  0xffff + (0x00007000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)

       0x00010000
     + 0x00006fff   (bit 15 not set, so the top half is zero)
     ------------
       0x00016fff   which is right (assuming that fred is at 0x7000)

   but if the 15th bit goes from being clear to being set, then we must
   once again handle overflow:

     movhi hi( fred + 0x7000 ), r0, r1     [bit 15 of the offset is clear]
     movea lo( fred + 0x7000 ), r1, r1

     HI16S: 0x0000 + (0x0000ffff >> 16)
     LO16:  0x7000 + (0x0000ffff & 0xffff) = 0x6fff  (carry into bit 16)

       0x00000000
     + 0x00006fff   (bit 15 not set, so the top half is zero)
     ------------
       0x00006fff   which is wrong (assuming that fred is at 0xffff).  */

static bfd_boolean
v850_elf_perform_lo16_relocation (bfd *abfd, unsigned long *insn,
				  unsigned long addend)
{
#define BIT15_SET(x) ((x) & 0x8000)
#define OVERFLOWS(a,i) ((((a) & 0xffff) + (i)) > 0xffff)

  if ((BIT15_SET (*insn + addend) && ! BIT15_SET (addend))
      || (OVERFLOWS (addend, *insn)
	  && ((! BIT15_SET (*insn)) || (BIT15_SET (addend)))))
    {
      bfd_boolean already_updated;
      bfd_byte *hi16s_address = find_remembered_hi16s_reloc
	(addend, & already_updated);

      /* Amend the matching HI16_S relocation.  */
      if (hi16s_address != NULL)
	{
	  if (! already_updated)
	    {
	      unsigned long hi_insn = bfd_get_16 (abfd, hi16s_address);
	      hi_insn += 1;
	      bfd_put_16 (abfd, hi_insn, hi16s_address);
	    }
	}
      else
	{
	  (*_bfd_error_handler) (_("FAILED to find previous HI16 reloc"));
	  return FALSE;
	}
    }
#undef OVERFLOWS
#undef BIT15_SET

  /* Do not complain if value has top bit set, as this has been
     anticipated.  */
  *insn = (*insn + addend) & 0xffff;
  return TRUE;
}

/* FIXME:  The code here probably ought to be removed and the code in reloc.c
   allowed to do its stuff instead.  At least for most of the relocs, anyway.  */

static bfd_reloc_status_type
v850_elf_perform_relocation (bfd *abfd,
			     unsigned int r_type,
			     bfd_vma addend,
			     bfd_byte *address)
{
  unsigned long insn;
  unsigned long result;
  bfd_signed_vma saddend = (bfd_signed_vma) addend;

  switch (r_type)
    {
    default:
#ifdef DEBUG
      fprintf (stderr, "reloc number %d not recognised\n", r_type);
#endif
      return bfd_reloc_notsupported;

    case R_V850_REL32:
    case R_V850_ABS32:
    case R_V810_WORD:
    case R_V850_PC32:
      bfd_put_32 (abfd, addend, address);
      return bfd_reloc_ok;

    case R_V850_WLO23:
    case R_V850_23:
      insn  = bfd_get_32 (abfd, address);
      insn &= ~((0x7f << 4) | (0x7fff80 << (16-7)));
      insn |= ((addend & 0x7f) << 4) | ((addend & 0x7fff80) << (16-7));
      bfd_put_32 (abfd, (bfd_vma) insn, address);
      return bfd_reloc_ok;

    case R_V850_PCR22:
    case R_V850_22_PCREL:
      if (saddend > 0x1fffff || saddend < -0x200000)
	return bfd_reloc_overflow;

      if ((addend % 2) != 0)
	return bfd_reloc_dangerous;

      insn  = bfd_get_32 (abfd, address);
      insn &= ~0xfffe003f;
      insn |= (((addend & 0xfffe) << 16) | ((addend & 0x3f0000) >> 16));
      bfd_put_32 (abfd, (bfd_vma) insn, address);
      return bfd_reloc_ok;

    case R_V850_PC17:
    case R_V850_17_PCREL:
      if (saddend > 0xffff || saddend < -0x10000)
	return bfd_reloc_overflow;

      if ((addend % 2) != 0)
	return bfd_reloc_dangerous;

      insn  = bfd_get_32 (abfd, address);
      insn &= ~ 0xfffe0010;
      insn |= ((addend & 0xfffe) << 16) | ((addend & 0x10000) >> (16-4));
      break;

    case R_V850_PC16U:
    case R_V850_16_PCREL:
      if ((saddend < -0xffff) || (saddend > 0))
	return bfd_reloc_overflow;

      if ((addend % 2) != 0)
	return bfd_reloc_dangerous;

      insn  = bfd_get_16 (abfd, address);
      insn &= ~0xfffe;
      insn |= (-addend & 0xfffe);
      break;

    case R_V850_PC9:
    case R_V850_9_PCREL:
      if (saddend > 0xff || saddend < -0x100)
	return bfd_reloc_overflow;

      if ((addend % 2) != 0)
	return bfd_reloc_dangerous;

      insn  = bfd_get_16 (abfd, address);
      insn &= ~ 0xf870;
      insn |= ((addend & 0x1f0) << 7) | ((addend & 0x0e) << 3);
      break;

    case R_V810_WHI:
    case R_V850_HI16:
      addend += (bfd_get_16 (abfd, address) << 16);
      addend = (addend >> 16);
      insn = addend;
      break;

    case R_V810_WHI1:
    case R_V850_HI16_S:
      /* Remember where this relocation took place.  */
      remember_hi16s_reloc (abfd, addend, address);

      addend += (bfd_get_16 (abfd, address) << 16);
      addend = (addend >> 16) + ((addend & 0x8000) != 0);

      /* This relocation cannot overflow.  */
      if (addend > 0xffff)
	addend = 0;

      insn = addend;
      break;

    case R_V810_WLO:
    case R_V850_LO16:
      insn = bfd_get_16 (abfd, address);
      if (! v850_elf_perform_lo16_relocation (abfd, &insn, addend))
	return bfd_reloc_overflow;
      break;

    case R_V810_BYTE:
    case R_V850_8:
      addend += (char) bfd_get_8 (abfd, address);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7f || saddend < -0x80)
	return bfd_reloc_overflow;

      bfd_put_8 (abfd, addend, address);
      return bfd_reloc_ok;

    case R_V850_CALLT_16_16_OFFSET:
      addend += bfd_get_16 (abfd, address);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0xffff || saddend < 0)
	return bfd_reloc_overflow;

      insn = addend;
      break;

    case R_V850_CALLT_15_16_OFFSET:
      insn = bfd_get_16 (abfd, address);

      addend += insn & 0xfffe;

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0xffff || saddend < 0)
	return bfd_reloc_overflow;

      insn = (0xfffe & addend)
	| (insn & ~0xfffe);
      break;

    case R_V850_CALLT_6_7_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += ((insn & 0x3f) << 1);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7e || saddend < 0)
	return bfd_reloc_overflow;

      if (addend & 1)
	return bfd_reloc_dangerous;

      insn &= 0xff80;
      insn |= (addend >> 1);
      break;

    case R_V850_16:
    case R_V810_HWORD:
    case R_V850_SDA_16_16_OFFSET:
    case R_V850_ZDA_16_16_OFFSET:
    case R_V850_TDA_16_16_OFFSET:
      addend += bfd_get_16 (abfd, address);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7fff || saddend < -0x8000)
	return bfd_reloc_overflow;

      insn = addend;
      break;

    case R_V850_16_S1:
    case R_V850_SDA_15_16_OFFSET:
    case R_V850_ZDA_15_16_OFFSET:
    case R_V810_GPWLO_1:
      insn = bfd_get_16 (abfd, address);
      addend += (insn & 0xfffe);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7ffe || saddend < -0x8000)
	return bfd_reloc_overflow;

      if (addend & 1)
        return bfd_reloc_dangerous;

      insn = (addend &~ (bfd_vma) 1) | (insn & 1);
      break;

    case R_V850_TDA_6_8_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += ((insn & 0x7e) << 1);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0xfc || saddend < 0)
	return bfd_reloc_overflow;

      if (addend & 3)
	return bfd_reloc_dangerous;

      insn &= 0xff81;
      insn |= (addend >> 1);
      break;

    case R_V850_TDA_7_8_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += ((insn & 0x7f) << 1);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0xfe || saddend < 0)
	return bfd_reloc_overflow;

      if (addend & 1)
	return bfd_reloc_dangerous;

      insn &= 0xff80;
      insn |= (addend >> 1);
      break;

    case R_V850_TDA_7_7_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += insn & 0x7f;

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7f || saddend < 0)
	return bfd_reloc_overflow;

      insn &= 0xff80;
      insn |= addend;
      break;

    case R_V850_TDA_4_5_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += ((insn & 0xf) << 1);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x1e || saddend < 0)
	return bfd_reloc_overflow;

      if (addend & 1)
	return bfd_reloc_dangerous;

      insn &= 0xfff0;
      insn |= (addend >> 1);
      break;

    case R_V850_TDA_4_4_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += insn & 0xf;

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0xf || saddend < 0)
	return bfd_reloc_overflow;

      insn &= 0xfff0;
      insn |= addend;
      break;

    case R_V810_WLO_1:
    case R_V850_HWLO:
    case R_V850_HWLO_1:
    case R_V850_LO16_S1:
      insn = bfd_get_16 (abfd, address);
      result = insn & 0xfffe;
      if (! v850_elf_perform_lo16_relocation (abfd, &result, addend))
	return bfd_reloc_overflow;
      if (result & 1)
	return bfd_reloc_overflow;
      insn = (result & 0xfffe)
	| (insn & ~0xfffe);
	bfd_put_16 (abfd, insn, address);
      return bfd_reloc_ok;

    case R_V850_BLO:
    case R_V850_LO16_SPLIT_OFFSET:
      insn = bfd_get_32 (abfd, address);
      result = ((insn & 0xfffe0000) >> 16) | ((insn & 0x20) >> 5);
      if (! v850_elf_perform_lo16_relocation (abfd, &result, addend))
	return bfd_reloc_overflow;
      insn = (((result << 16) & 0xfffe0000)
	      | ((result << 5) & 0x20)
	      | (insn & ~0xfffe0020));
      bfd_put_32 (abfd, insn, address);
      return bfd_reloc_ok;

    case R_V850_16_SPLIT_OFFSET:
    case R_V850_SDA_16_16_SPLIT_OFFSET:
    case R_V850_ZDA_16_16_SPLIT_OFFSET:
      insn = bfd_get_32 (abfd, address);
      addend += ((insn & 0xfffe0000) >> 16) + ((insn & 0x20) >> 5);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7fff || saddend < -0x8000)
	return bfd_reloc_overflow;

      insn &= 0x0001ffdf;
      insn |= (addend & 1) << 5;
      insn |= (addend &~ (bfd_vma) 1) << 16;

      bfd_put_32 (abfd, (bfd_vma) insn, address);
      return bfd_reloc_ok;

    case R_V850_GNU_VTINHERIT:
    case R_V850_GNU_VTENTRY:
      return bfd_reloc_ok;

    }

  bfd_put_16 (abfd, (bfd_vma) insn, address);
  return bfd_reloc_ok;
}

/* Insert the addend into the instruction.  */

static bfd_reloc_status_type
v850_elf_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		arelent *reloc,
		asymbol *symbol,
		void * data ATTRIBUTE_UNUSED,
		asection *isection,
		bfd *obfd,
		char **err ATTRIBUTE_UNUSED)
{
  long relocation;

  /* If there is an output BFD,
     and the symbol is not a section name (which is only defined at final link time),
     and either we are not putting the addend into the instruction
      or the addend is zero, so there is nothing to add into the instruction
     then just fixup the address and return.  */
  if (obfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc->howto->partial_inplace
	  || reloc->addend == 0))
    {
      reloc->address += isection->output_offset;
      return bfd_reloc_ok;
    }

  /* Catch relocs involving undefined symbols.  */
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && obfd == NULL)
    return bfd_reloc_undefined;

  /* We handle final linking of some relocs ourselves.  */

  /* Is the address of the relocation really within the section?  */
  if (reloc->address > bfd_get_section_limit (abfd, isection))
    return bfd_reloc_outofrange;

  /* Work out which section the relocation is targeted at and the
     initial relocation command value.  */

  if (reloc->howto->pc_relative)
    return bfd_reloc_ok;

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  /* Convert input-section-relative symbol value to absolute + addend.  */
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc->addend;

  reloc->addend = relocation;
  return bfd_reloc_ok;
}

/* This function is used for relocs which are only used
   for relaxing, which the linker should otherwise ignore.  */

static bfd_reloc_status_type
v850_elf_ignore_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol ATTRIBUTE_UNUSED,
		       void * data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}
/* Note: It is REQUIRED that the 'type' value of each entry
   in this array match the index of the entry in the array.
   SeeAlso: RELOC_NUBMER in include/elf/v850.h.  */
static reloc_howto_type v850_elf_howto_table[] =
{
  /* This reloc does nothing.  */
  HOWTO (R_V850_NONE,			/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* Special_function.  */
	 "R_V850_NONE",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0,				/* Src_mask.  */
	 0,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* A PC relative 9 bit branch.  */
  HOWTO (R_V850_9_PCREL,		/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 9,				/* Bitsize.  */
	 TRUE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_9_PCREL",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x00ffffff,			/* Src_mask.  */
	 0x00ffffff,			/* Dst_mask.  */
	 TRUE),				/* PCrel_offset.  */

  /* A PC relative 22 bit branch.  */
  HOWTO (R_V850_22_PCREL,		/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 22,				/* Bitsize.  */
	 TRUE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_signed,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_22_PCREL",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x07ffff80,			/* Src_mask.  */
	 0x07ffff80,			/* Dst_mask.  */
	 TRUE),				/* PCrel_offset.  */

  /* High 16 bits of symbol value.  */
  HOWTO (R_V850_HI16_S,			/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_HI16_S",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* High 16 bits of symbol value.  */
  HOWTO (R_V850_HI16,			/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_HI16",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_V850_LO16,			/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_LO16",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* Simple 32bit reloc.  */
  HOWTO (R_V850_ABS32,			/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_ABS32",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffffffff,			/* Src_mask.  */
	 0xffffffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* Simple 16bit reloc.  */
  HOWTO (R_V850_16,			/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* Special_function.  */
	 "R_V850_16",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* Simple 8bit reloc.	 */
  HOWTO (R_V850_8,			/* Type.  */
	 0,				/* Rightshift.  */
	 0,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 8,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* Special_function.  */
	 "R_V850_8",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xff,				/* Src_mask.  */
	 0xff,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_16_16_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_SDA_16_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 15 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_15_16_OFFSET,	/* Type.  */
	 1,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 1,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_SDA_15_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe,			/* Src_mask.  */
	 0xfffe,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_16_16_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_ZDA_16_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 15 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_15_16_OFFSET,	/* Type.  */
	 1,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 1,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_ZDA_15_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe,			/* Src_mask.  */
	 0xfffe,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 6 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_6_8_OFFSET,		/* Type.  */
	 2,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 8,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 1,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_6_8_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x7e,				/* Src_mask.  */
	 0x7e,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 8 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_7_8_OFFSET,		/* Type.  */
	 1,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 8,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_7_8_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x7f,				/* Src_mask.  */
	 0x7f,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 7 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_7_7_OFFSET,		/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 7,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_7_7_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x7f,				/* Src_mask.  */
	 0x7f,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the tiny data area pointer!  */
  HOWTO (R_V850_TDA_16_16_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_16_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xfff,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 5 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_4_5_OFFSET,		/* Type.  */
	 1,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 5,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_4_5_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x0f,				/* Src_mask.  */
	 0x0f,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 4 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_4_4_OFFSET,		/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 4,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_TDA_4_4_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x0f,				/* Src_mask.  */
	 0x0f,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_16_16_SPLIT_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_SDA_16_16_SPLIT_OFFSET",/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe0020,			/* Src_mask.  */
	 0xfffe0020,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_16_16_SPLIT_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_ZDA_16_16_SPLIT_OFFSET",/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe0020,			/* Src_mask.  */
	 0xfffe0020,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 6 bit offset from the call table base pointer.  */
  HOWTO (R_V850_CALLT_6_7_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 7,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_CALLT_6_7_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x3f,				/* Src_mask.  */
	 0x3f,				/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* 16 bit offset from the call table base pointer.  */
  HOWTO (R_V850_CALLT_16_16_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_CALLT_16_16_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */


  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_V850_GNU_VTINHERIT, /* Type.  */
	 0,                     /* Rightshift.  */
	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
	 0,                     /* Bitsize.  */
	 FALSE,                 /* PC_relative.  */
	 0,                     /* Bitpos.  */
	 complain_overflow_dont, /* Complain_on_overflow.  */
	 NULL,                  /* Special_function.  */
	 "R_V850_GNU_VTINHERIT", /* Name.  */
	 FALSE,                 /* Partial_inplace.  */
	 0,                     /* Src_mask.  */
	 0,                     /* Dst_mask.  */
	 FALSE),                /* PCrel_offset.  */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_V850_GNU_VTENTRY,     /* Type.  */
	 0,                     /* Rightshift.  */
	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
	 0,                     /* Bitsize.  */
	 FALSE,                 /* PC_relative.  */
	 0,                     /* Bitpos.  */
	 complain_overflow_dont, /* Complain_on_overflow.  */
	 _bfd_elf_rel_vtable_reloc_fn,  /* Special_function.  */
	 "R_V850_GNU_VTENTRY",   /* Name.  */
	 FALSE,                 /* Partial_inplace.  */
	 0,                     /* Src_mask.  */
	 0,                     /* Dst_mask.  */
	 FALSE),                /* PCrel_offset.  */

  /* Indicates a .longcall pseudo-op.  The compiler will generate a .longcall
     pseudo-op when it finds a function call which can be relaxed.  */
  HOWTO (R_V850_LONGCALL,     /* Type.  */
	 0,                     /* Rightshift.  */
	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
	 32,                    /* Bitsize.  */
	 TRUE,                  /* PC_relative.  */
	 0,                     /* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 v850_elf_ignore_reloc, /* Special_function.  */
	 "R_V850_LONGCALL",     /* Name.  */
	 FALSE,                 /* Partial_inplace.  */
	 0,                     /* Src_mask.  */
	 0,                     /* Dst_mask.  */
	 TRUE),                 /* PCrel_offset.  */

  /* Indicates a .longjump pseudo-op.  The compiler will generate a
     .longjump pseudo-op when it finds a branch which can be relaxed.  */
  HOWTO (R_V850_LONGJUMP,     /* Type.  */
	 0,                     /* Rightshift.  */
	 2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
	 32,                    /* Bitsize.  */
	 TRUE,                  /* PC_relative.  */
	 0,                     /* Bitpos.  */
	 complain_overflow_signed, /* Complain_on_overflow.  */
	 v850_elf_ignore_reloc, /* Special_function.  */
	 "R_V850_LONGJUMP",     /* Name.  */
	 FALSE,                 /* Partial_inplace.  */
	 0,                     /* Src_mask.  */
	 0,                     /* Dst_mask.  */
	 TRUE),                 /* PCrel_offset.  */

  HOWTO (R_V850_ALIGN,        /* Type.  */
	 0,                     /* Rightshift.  */
	 1,                     /* Size (0 = byte, 1 = short, 2 = long).  */
	 0,                     /* Bitsize.  */
	 FALSE,                 /* PC_relative.  */
	 0,                     /* Bitpos.  */
	 complain_overflow_unsigned, /* Complain_on_overflow.  */
	 v850_elf_ignore_reloc, /* Special_function.  */
	 "R_V850_ALIGN",        /* Name.  */
	 FALSE,                 /* Partial_inplace.  */
	 0,                     /* Src_mask.  */
	 0,                     /* Dst_mask.  */
	 TRUE),                 /* PCrel_offset.  */

  /* Simple pc-relative 32bit reloc.  */
  HOWTO (R_V850_REL32,			/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* Bitsize.  */
	 TRUE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_REL32",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffffffff,			/* Src_mask.  */
	 0xffffffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* An ld.bu version of R_V850_LO16.  */
  HOWTO (R_V850_LO16_SPLIT_OFFSET,	/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_LO16_SPLIT_OFFSET",	/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe0020,			/* Src_mask.  */
	 0xfffe0020,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* A unsigned PC relative 16 bit loop.  */
  HOWTO (R_V850_16_PCREL,		/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 TRUE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_16_PCREL",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xfffe,			/* Src_mask.  */
	 0xfffe,			/* Dst_mask.  */
	 TRUE),				/* PCrel_offset.  */

  /* A PC relative 17 bit branch.  */
  HOWTO (R_V850_17_PCREL,		/* Type.  */
	 0,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 17,				/* Bitsize.  */
	 TRUE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_bitfield,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_17_PCREL",		/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0x0010fffe,			/* Src_mask.  */
	 0x0010fffe,			/* Dst_mask.  */
	 TRUE),				/* PCrel_offset.  */

  /* A 23bit offset ld/st.  */
  HOWTO (R_V850_23,			/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 23,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_dont,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_23",			/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffff07f0,			/* src_mask.  */
	 0xffff07f0,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* A PC relative 32 bit branch.  */
  HOWTO (R_V850_32_PCREL,		/* type.  */
	 1,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 TRUE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_signed,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_32_PCREL",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xfffffffe,			/* src_mask.  */
	 0xfffffffe,			/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

  /* A absolute 32 bit branch.	*/
  HOWTO (R_V850_32_ABS,			/* type.  */
	 1,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 TRUE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_signed,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_32_ABS",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xfffffffe,			/* src_mask.  */
	 0xfffffffe,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* High 16 bits of symbol value.  */
  HOWTO (R_V850_HI16,			/* Type.  */
	 0,				/* Rightshift.  */
	 1,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* Bitsize.  */
	 FALSE,				/* PC_relative.  */
	 0,				/* Bitpos.  */
	 complain_overflow_dont,	/* Complain_on_overflow.  */
	 v850_elf_reloc,		/* Special_function.  */
	 "R_V850_HI16",			/* Name.  */
	 FALSE,				/* Partial_inplace.  */
	 0xffff,			/* Src_mask.  */
	 0xffff,			/* Dst_mask.  */
	 FALSE),			/* PCrel_offset.  */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_V850_16_S1,			/* type.  */
	 1,				/* rightshift.  */
	 1,				/* size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_dont,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_16_S1",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xfffe,			/* src_mask.  */
	 0xfffe,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_V850_LO16_S1,		/* type.  */
	 1,				/* rightshift.  */
	 1,				/* size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_dont,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_LO16_S1",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xfffe,			/* src_mask.  */
	 0xfffe,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* 16 bit offset from the call table base pointer.  */
  HOWTO (R_V850_CALLT_15_16_OFFSET,	/* type.  */
	 1,				/* rightshift.  */
	 1,				/* size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_dont,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_CALLT_15_16_OFFSET",	/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xfffe,			/* src_mask.  */
	 0xfffe,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Like R_V850_32 PCREL, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_V850_32_GOTPCREL,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 TRUE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_unsigned,	/* complain_on_overflow.  */
	 v850_elf_reloc,		/* special_function.  */
	 "R_V850_32_GOTPCREL",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

  /* Like R_V850_SDA_, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_V850_16_GOT,			/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 16,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_unsigned,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_16_GOT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffff,			/* src_mask.  */
	 0xffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  HOWTO (R_V850_32_GOT,			/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_unsigned,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_32_GOT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Like R_V850_22_PCREL, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_V850_22_PLT,			/* type.  */
	 1,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 22,				/* bitsize.  */
	 TRUE,				/* pc_relative.  */
	 7,				/* bitpos.  */
	 complain_overflow_signed,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_22_PLT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0x07ffff80,			/* src_mask.  */
	 0x07ffff80,			/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

  HOWTO (R_V850_32_PLT,			/* type.  */
	 1,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 TRUE,				/* pc_relative.  */
	 1,				/* bitpos.  */
	 complain_overflow_signed,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_32_PLT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_V850_COPY,			/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long).  */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_COPY",			/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Like R_M32R_24, but used when setting global offset table
     entries.  */
  HOWTO (R_V850_GLOB_DAT,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_GLOB_DAT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_V850_JMP_SLOT,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_JMP_SLOT",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_V850_RELATIVE,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_RELATIVE",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  HOWTO (R_V850_16_GOTOFF,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_16_GOTOFF",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffff,			/* src_mask.  */
	 0xffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  HOWTO (R_V850_32_GOTOFF,		/* type.  */
	 0,				/* rightshift.  */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_bitfield,	/* complain_on_overflow.  */
	 bfd_elf_generic_reloc,		/* special_function.  */
	 "R_V850_32_GOTOFF",		/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0xffffffff,			/* src_mask.  */
	 0xffffffff,			/* dst_mask.  */
	 FALSE),			/* pcrel_offset.  */

  HOWTO (R_V850_CODE,			/* type.  */
	 0,				/* rightshift.  */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 0,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_unsigned,	/* complain_on_overflow.  */
	 v850_elf_ignore_reloc,		/* special_function.  */
	 "R_V850_CODE",			/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0,				/* src_mask.  */
	 0,				/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

  HOWTO (R_V850_DATA,			/* type.  */
	 0,				/* rightshift.  */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 0,				/* bitsize.  */
	 FALSE,				/* pc_relative.  */
	 0,				/* bitpos.  */
	 complain_overflow_unsigned,	/* complain_on_overflow.  */
	 v850_elf_ignore_reloc,		/* special_function.  */
	 "R_V850_DATA",			/* name.  */
	 FALSE,				/* partial_inplace.  */
	 0,				/* src_mask.  */
	 0,				/* dst_mask.  */
	 TRUE),				/* pcrel_offset.  */

};

/* Map BFD reloc types to V850 ELF reloc types.  */

struct v850_elf_reloc_map
{
  /* BFD_RELOC_V850_CALLT_16_16_OFFSET is 258, which will not fix in an
     unsigned char.  */
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int elf_reloc_val;
};

static const struct v850_elf_reloc_map v850_elf_reloc_map[] =
{
  { BFD_RELOC_NONE,                        R_V850_NONE                   },
  { BFD_RELOC_V850_9_PCREL,                R_V850_9_PCREL                },
  { BFD_RELOC_V850_22_PCREL,               R_V850_22_PCREL               },
  { BFD_RELOC_HI16_S,                      R_V850_HI16_S                 },
  { BFD_RELOC_HI16,                        R_V850_HI16                   },
  { BFD_RELOC_LO16,                        R_V850_LO16                   },
  { BFD_RELOC_32,                          R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,                    R_V850_REL32                  },
  { BFD_RELOC_16,                          R_V850_16                     },
  { BFD_RELOC_8,                           R_V850_8                      },
  { BFD_RELOC_V850_SDA_16_16_OFFSET,       R_V850_SDA_16_16_OFFSET       },
  { BFD_RELOC_V850_SDA_15_16_OFFSET,       R_V850_SDA_15_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_16_16_OFFSET,       R_V850_ZDA_16_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_15_16_OFFSET,       R_V850_ZDA_15_16_OFFSET       },
  { BFD_RELOC_V850_TDA_6_8_OFFSET,         R_V850_TDA_6_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_8_OFFSET,         R_V850_TDA_7_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_7_OFFSET,         R_V850_TDA_7_7_OFFSET         },
  { BFD_RELOC_V850_TDA_16_16_OFFSET,       R_V850_TDA_16_16_OFFSET       },
  { BFD_RELOC_V850_TDA_4_5_OFFSET,         R_V850_TDA_4_5_OFFSET         },
  { BFD_RELOC_V850_TDA_4_4_OFFSET,         R_V850_TDA_4_4_OFFSET         },
  { BFD_RELOC_V850_LO16_SPLIT_OFFSET,      R_V850_LO16_SPLIT_OFFSET      },
  { BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET, R_V850_SDA_16_16_SPLIT_OFFSET },
  { BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET, R_V850_ZDA_16_16_SPLIT_OFFSET },
  { BFD_RELOC_V850_CALLT_6_7_OFFSET,       R_V850_CALLT_6_7_OFFSET       },
  { BFD_RELOC_V850_CALLT_16_16_OFFSET,     R_V850_CALLT_16_16_OFFSET     },
  { BFD_RELOC_VTABLE_INHERIT,              R_V850_GNU_VTINHERIT          },
  { BFD_RELOC_VTABLE_ENTRY,                R_V850_GNU_VTENTRY            },
  { BFD_RELOC_V850_LONGCALL,               R_V850_LONGCALL               },
  { BFD_RELOC_V850_LONGJUMP,               R_V850_LONGJUMP               },
  { BFD_RELOC_V850_ALIGN,                  R_V850_ALIGN                  },
  { BFD_RELOC_V850_16_PCREL,               R_V850_16_PCREL               },
  { BFD_RELOC_V850_17_PCREL,               R_V850_17_PCREL               },
  { BFD_RELOC_V850_23,                     R_V850_23                     },
  { BFD_RELOC_V850_32_PCREL,               R_V850_32_PCREL               },
  { BFD_RELOC_V850_32_ABS,                 R_V850_32_ABS                 },
  { BFD_RELOC_V850_16_SPLIT_OFFSET,        R_V850_HI16                   },
  { BFD_RELOC_V850_16_S1,                  R_V850_16_S1                  },
  { BFD_RELOC_V850_LO16_S1,                R_V850_LO16_S1                },
  { BFD_RELOC_V850_CALLT_15_16_OFFSET,     R_V850_CALLT_15_16_OFFSET     },
  { BFD_RELOC_V850_32_GOTPCREL,            R_V850_32_GOTPCREL            },
  { BFD_RELOC_V850_16_GOT,                 R_V850_16_GOT                 },
  { BFD_RELOC_V850_32_GOT,                 R_V850_32_GOT                 },
  { BFD_RELOC_V850_22_PLT_PCREL,           R_V850_22_PLT                 },
  { BFD_RELOC_V850_32_PLT_PCREL,           R_V850_32_PLT                 },
  { BFD_RELOC_V850_COPY,                   R_V850_COPY                   },
  { BFD_RELOC_V850_GLOB_DAT,               R_V850_GLOB_DAT               },
  { BFD_RELOC_V850_JMP_SLOT,               R_V850_JMP_SLOT               },
  { BFD_RELOC_V850_RELATIVE,               R_V850_RELATIVE               },
  { BFD_RELOC_V850_16_GOTOFF,              R_V850_16_GOTOFF              },
  { BFD_RELOC_V850_32_GOTOFF,              R_V850_32_GOTOFF              },
  { BFD_RELOC_V850_CODE,                   R_V850_CODE                   },
  { BFD_RELOC_V850_DATA,                   R_V850_DATA                   },
};

#define V800_RELOC(name,sz,bit,shift,complain,pcrel,resolver)		 \
  HOWTO (name, shift, sz, bit, pcrel, 0, complain_overflow_ ## complain, \
	 bfd_elf_ ## resolver ## _reloc, #name, FALSE, 0, ~0, FALSE)

#define V800_EMPTY(name) EMPTY_HOWTO (name - R_V810_NONE)

#define bfd_elf_v850_reloc v850_elf_reloc

/* Note: It is REQUIRED that the 'type' value (R_V810_...) of each entry
   in this array match the index of the entry in the array minus 0x30.
   See: bfd_elf_v850_relocate_section(), v800_elf_reloc_type_lookup()
   and v800_elf_info_to_howto().  */

static reloc_howto_type v800_elf_howto_table[] =
{
  V800_RELOC (R_V810_NONE,      0,  0, 0, dont,     FALSE, generic),	/* Type = 0x30 */
  V800_RELOC (R_V810_BYTE,      0,  8, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_HWORD,     1, 16, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_WORD,      2, 32, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_WLO,       1, 16, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_WHI,       1, 16, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_WHI1,      1, 16, 0, dont,     FALSE, generic),
  V800_RELOC (R_V810_GPBYTE,    0,  8, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPHWORD,   1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPWORD,    2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPWLO,     1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPWHI,     1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPWHI1,    1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_HWLO,      1, 16, 0, dont,     FALSE, generic),
  V800_EMPTY (R_V810_reserved1),
  V800_RELOC (R_V850_EP7BIT,    0,  7, 0, unsigned, FALSE, v850),
  V800_RELOC (R_V850_EPHBYTE,   0,  8, 1, unsigned, FALSE, v850),
  V800_RELOC (R_V850_EPWBYTE,   0,  8, 2, unsigned, FALSE, v850),
  V800_RELOC (R_V850_REGHWLO,   1, 16, 0, dont,     FALSE, v850),
  V800_EMPTY (R_V810_reserved2),
  V800_RELOC (R_V850_GPHWLO,    1, 16, 0, dont,     FALSE, v850),
  V800_EMPTY (R_V810_reserved3),
  V800_RELOC (R_V850_PCR22,     2, 22, 0, signed,   TRUE,  generic),
  V800_RELOC (R_V850_BLO,       2, 24, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_EP4BIT,    0,  4, 0, unsigned, FALSE, v850),
  V800_RELOC (R_V850_EP5BIT,    0,  5, 0, unsigned, FALSE, v850),
  V800_RELOC (R_V850_REGBLO,    2, 24, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_GPBLO,     2, 24, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_WLO_1,     1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_GPWLO_1,   1, 16, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_BLO_1,     2, 16, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_HWLO_1,    1, 16, 0, signed,   FALSE, v850),
  V800_EMPTY  (R_V810_reserved4),
  V800_RELOC (R_V850_GPBLO_1,   2, 16, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_GPHWLO_1,  1, 16, 1, signed,   FALSE, v850),
  V800_EMPTY (R_V810_reserved5),
  V800_RELOC (R_V850_EPBLO,     2, 16, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_EPHWLO,    1, 16, 1, signed,   FALSE, v850),
  V800_EMPTY (R_V810_reserved6),
  V800_RELOC (R_V850_EPWLO_N,   1, 16, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_PC32,      2, 32, 1, signed,   TRUE,  v850),
  V800_RELOC (R_V850_W23BIT,    2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_GPW23BIT,  2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_EPW23BIT,  2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_B23BIT,    2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_GPB23BIT,  2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_EPB23BIT,  2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_PC16U,     1, 16, 1, unsigned, TRUE,  generic),
  V800_RELOC (R_V850_PC17,      2, 17, 1, signed,   TRUE,  generic),
  V800_RELOC (R_V850_DW8,       2,  8, 2, signed,   FALSE, v850),
  V800_RELOC (R_V850_GPDW8,     2,  8, 2, signed,   FALSE, v850),
  V800_RELOC (R_V850_EPDW8,     2,  8, 2, signed,   FALSE, v850),
  V800_RELOC (R_V850_PC9,       1,  9, 3, signed,   TRUE,  v850),
  V800_RELOC (R_V810_REGBYTE,   0,  8, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_REGHWORD,  1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_REGWORD,   2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_REGWLO,    1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_REGWHI,    1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_REGWHI1,   1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_REGW23BIT, 2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_REGB23BIT, 2, 23, 1, signed,   FALSE, v850),
  V800_RELOC (R_V850_REGDW8,    2,  8, 2, signed,   FALSE, v850),
  V800_RELOC (R_V810_EPBYTE,    0,  8, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_EPHWORD,   1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_EPWORD,    2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_WLO23,     2, 32, 1, dont,     FALSE, v850),
  V800_RELOC (R_V850_WORD_E,    2, 32, 1, dont,     FALSE, v850),
  V800_RELOC (R_V850_REGWORD_E, 2, 32, 1, dont,     FALSE, v850),
  V800_RELOC (R_V850_WORD,      2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_GPWORD,    2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_REGWORD,   2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_EPWORD,    2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPBYTE,    0,  8, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPHWORD,   1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPWORD,    2, 32, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPWLO,     1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPWHI,     1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPWHI1,    1, 16, 0, dont,     FALSE, v850),
  V800_RELOC (R_V850_TPHWLO,    1, 16, 1, dont,     FALSE, v850),
  V800_RELOC (R_V850_TPBLO,     2, 24, 0, dont,     FALSE, v850),
  V800_RELOC (R_V810_TPWLO_1,   1, 16, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_TPBLO_1,   2, 16, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_TPHWLO_1,  1, 16, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_TP23BIT,   2, 23, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_TPW23BIT,  2, 23, 0, signed,   FALSE, v850),
  V800_RELOC (R_V850_TPDW8,     2,  8, 0, signed,   FALSE, v850)
};

/* Map a bfd relocation into the appropriate howto structure.  */

static reloc_howto_type *
v850_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = ARRAY_SIZE (v850_elf_reloc_map); i --;)
    if (v850_elf_reloc_map[i].bfd_reloc_val == code)
      {
	unsigned int elf_reloc_val = v850_elf_reloc_map[i].elf_reloc_val;

	BFD_ASSERT (v850_elf_howto_table[elf_reloc_val].type == elf_reloc_val);

	return v850_elf_howto_table + elf_reloc_val;
      }

  return NULL;
}

static reloc_howto_type *
v850_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (v850_elf_howto_table) / sizeof (v850_elf_howto_table[0]);
       i++)
    if (v850_elf_howto_table[i].name != NULL
	&& strcasecmp (v850_elf_howto_table[i].name, r_name) == 0)
      return &v850_elf_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an V850 ELF reloc.  */

static void
v850_elf_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			    arelent *cache_ptr,
			    Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_V850_max);
  cache_ptr->howto = &v850_elf_howto_table[r_type];
}

/* Set the howto pointer for a V850 ELF reloc (type RELA).  */

static void
v850_elf_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			     arelent * cache_ptr,
			     Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_V850_max);
  cache_ptr->howto = &v850_elf_howto_table[r_type];
}

static bfd_boolean
v850_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED, const char *name)
{
  return (   (name[0] == '.' && (name[1] == 'L' || name[1] == '.'))
	  || (name[0] == '_' &&  name[1] == '.' && name[2] == 'L' && name[3] == '_'));
}

static bfd_boolean
v850_elf_is_target_special_symbol (bfd *abfd, asymbol *sym)
{
  return v850_elf_is_local_label_name (abfd, sym->name);
}

/* We overload some of the bfd_reloc error codes for own purposes.  */
#define bfd_reloc_gp_not_found		bfd_reloc_other
#define bfd_reloc_ep_not_found		bfd_reloc_continue
#define bfd_reloc_ctbp_not_found	(bfd_reloc_dangerous + 1)

/* Perform a relocation as part of a final link.  */

static bfd_reloc_status_type
v850_elf_final_link_relocate (reloc_howto_type *howto,
			      bfd *input_bfd,
			      bfd *output_bfd ATTRIBUTE_UNUSED,
			      asection *input_section,
			      bfd_byte *contents,
			      bfd_vma offset,
			      bfd_vma value,
			      bfd_vma addend,
			      struct bfd_link_info *info,
			      asection *sym_sec,
			      int is_local ATTRIBUTE_UNUSED)
{
  unsigned int r_type = howto->type;
  bfd_byte *hit_data = contents + offset;

  /* Adjust the value according to the relocation.  */
  switch (r_type)
    {
    case R_V850_PC9:
    case R_V850_9_PCREL:
      value -= (input_section->output_section->vma
		+ input_section->output_offset);
      value -= offset;
      break;

    case R_V850_PC16U:
    case R_V850_16_PCREL:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);

      /* If the sign extension will corrupt the value then we have overflowed.  */
      if ((value & 0xffff0000) != 0xffff0000)
	return bfd_reloc_overflow;

      break;

    case R_V850_PC17:
    case R_V850_17_PCREL:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);

      /* If the sign extension will corrupt the value then we have overflowed.  */
      if (((value & 0xffff0000) != 0x0) && ((value & 0xffff0000) != 0xffff0000))
	return bfd_reloc_overflow;

      value = SEXT17 (value);
      break;

    case R_V850_PCR22:
    case R_V850_22_PCREL:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);

      /* If the sign extension will corrupt the value then we have overflowed.  */
      if (((value & 0xffe00000) != 0x0) && ((value & 0xffe00000) != 0xffe00000))
	return bfd_reloc_overflow;

      /* Only the bottom 22 bits of the PC are valid.  */
      value = SEXT22 (value);
      break;

    case R_V850_PC32:
    case R_V850_32_PCREL:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);
      break;

    case R_V850_32_ABS:
    case R_V850_23:
    case R_V850_HI16_S:
    case R_V850_HI16:
    case R_V850_LO16:
    case R_V850_LO16_S1:
    case R_V850_LO16_SPLIT_OFFSET:
    case R_V850_16:
    case R_V850_ABS32:
    case R_V850_8:
    case R_V810_BYTE:
    case R_V810_HWORD:
    case R_V810_WORD:
    case R_V810_WLO:
    case R_V810_WHI:
    case R_V810_WHI1:
    case R_V810_WLO_1:
    case R_V850_WLO23:
    case R_V850_BLO:
      break;

    case R_V850_ZDA_15_16_OFFSET:
    case R_V850_ZDA_16_16_OFFSET:
    case R_V850_ZDA_16_16_SPLIT_OFFSET:
      if (sym_sec == NULL)
	return bfd_reloc_undefined;

      value -= sym_sec->output_section->vma;
      break;

    case R_V850_SDA_15_16_OFFSET:
    case R_V850_SDA_16_16_OFFSET:
    case R_V850_SDA_16_16_SPLIT_OFFSET:
    case R_V810_GPWLO_1:
      {
	unsigned long                gp;
	struct bfd_link_hash_entry * h;

	if (sym_sec == NULL)
	  return bfd_reloc_undefined;

	/* Get the value of __gp.  */
	h = bfd_link_hash_lookup (info->hash, "__gp", FALSE, FALSE, TRUE);
	if (h == NULL
	    || h->type != bfd_link_hash_defined)
	  return bfd_reloc_gp_not_found;

	gp = (h->u.def.value
	      + h->u.def.section->output_section->vma
	      + h->u.def.section->output_offset);

	value -= sym_sec->output_section->vma;
	value -= (gp - sym_sec->output_section->vma);
      }
    break;

    case R_V850_TDA_4_4_OFFSET:
    case R_V850_TDA_4_5_OFFSET:
    case R_V850_TDA_7_7_OFFSET:
    case R_V850_TDA_7_8_OFFSET:
    case R_V850_TDA_6_8_OFFSET:
    case R_V850_TDA_16_16_OFFSET:
      {
	unsigned long                ep;
	struct bfd_link_hash_entry * h;

	/* Get the value of __ep.  */
	h = bfd_link_hash_lookup (info->hash, "__ep", FALSE, FALSE, TRUE);
	if (h == NULL
	    || h->type != bfd_link_hash_defined)
	  return bfd_reloc_ep_not_found;

	ep = (h->u.def.value
	      + h->u.def.section->output_section->vma
	      + h->u.def.section->output_offset);

	value -= ep;
      }
    break;

    case R_V850_CALLT_6_7_OFFSET:
      {
	unsigned long                ctbp;
	struct bfd_link_hash_entry * h;

	/* Get the value of __ctbp.  */
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
	if (h == NULL
	    || h->type != bfd_link_hash_defined)
	  return bfd_reloc_ctbp_not_found;

	ctbp = (h->u.def.value
	      + h->u.def.section->output_section->vma
	      + h->u.def.section->output_offset);
	value -= ctbp;
      }
    break;

    case R_V850_CALLT_15_16_OFFSET:
    case R_V850_CALLT_16_16_OFFSET:
      {
	unsigned long                ctbp;
	struct bfd_link_hash_entry * h;

	if (sym_sec == NULL)
	  return bfd_reloc_undefined;

	/* Get the value of __ctbp.  */
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
	if (h == NULL
	    || h->type != bfd_link_hash_defined)
	  return bfd_reloc_ctbp_not_found;

	ctbp = (h->u.def.value
	      + h->u.def.section->output_section->vma
	      + h->u.def.section->output_offset);

	value -= sym_sec->output_section->vma;
	value -= (ctbp - sym_sec->output_section->vma);
      }
    break;

    case R_V850_NONE:
    case R_V810_NONE:
    case R_V850_GNU_VTINHERIT:
    case R_V850_GNU_VTENTRY:
    case R_V850_LONGCALL:
    case R_V850_LONGJUMP:
    case R_V850_ALIGN:
      return bfd_reloc_ok;

    default:
#ifdef DEBUG
      fprintf (stderr, "reloc number %d not recognised\n", r_type);
#endif
      return bfd_reloc_notsupported;
    }

  /* Perform the relocation.  */
  return v850_elf_perform_relocation (input_bfd, r_type, value + addend, hit_data);
}

/* Relocate an V850 ELF section.  */

static bfd_boolean
v850_elf_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  /* Reset the list of remembered HI16S relocs to empty.  */
  free_hi16s     = previous_hi16s;
  previous_hi16s = NULL;
  hi16s_counter  = 0;

  rel    = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_symndx = ELF32_R_SYM (rel->r_info);
      r_type   = ELF32_R_TYPE (rel->r_info);

      if (r_type == R_V850_GNU_VTENTRY
          || r_type == R_V850_GNU_VTINHERIT)
        continue;

      if (bfd_get_arch (input_bfd) == bfd_arch_v850_rh850)
	howto = v800_elf_howto_table + (r_type - R_V810_NONE);
      else
	howto = v850_elf_howto_table + r_type;

      BFD_ASSERT (r_type == howto->type);

      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  /* Note - this check is delayed until now as it is possible and
	     valid to have a file without any symbols but with relocs that
	     can be processed.  */
	  if (sym_hashes == NULL)
	    {
	      info->callbacks->warning
		(info, "no hash table available",
		 NULL, input_bfd, input_section, (bfd_vma) 0);

	      return FALSE;
	    }

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      /* FIXME: We should use the addend, but the COFF relocations don't.  */
      r = v850_elf_final_link_relocate (howto, input_bfd, output_bfd,
					input_section,
					contents, rel->r_offset,
					relocation, rel->r_addend,
					info, sec, h == NULL);

      if (r != bfd_reloc_ok)
	{
	  const char * name;
	  const char * msg = NULL;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = (bfd_elf_string_from_elf_section
		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
	      if (name == NULL || *name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  switch ((int) r)
	    {
	    case bfd_reloc_overflow:
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		return FALSE;
	      break;

	    case bfd_reloc_undefined:
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, name, input_bfd, input_section,
		      rel->r_offset, TRUE)))
		return FALSE;
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      goto common_error;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      goto common_error;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      goto common_error;

	    case bfd_reloc_gp_not_found:
	      msg = _("could not locate special linker symbol __gp");
	      goto common_error;

	    case bfd_reloc_ep_not_found:
	      msg = _("could not locate special linker symbol __ep");
	      goto common_error;

	    case bfd_reloc_ctbp_not_found:
	      msg = _("could not locate special linker symbol __ctbp");
	      goto common_error;

	    default:
	      msg = _("internal error: unknown error");
	      /* fall through */

	    common_error:
	      if (!((*info->callbacks->warning)
		    (info, msg, name, input_bfd, input_section,
		     rel->r_offset)))
		return FALSE;
	      break;
	    }
	}
    }

  return TRUE;
}

static asection *
v850_elf_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_V850_GNU_VTINHERIT:
      case R_V850_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Set the right machine number and architecture.  */

static bfd_boolean
v850_elf_object_p (bfd *abfd)
{
  enum bfd_architecture arch;
  unsigned long mach;

  switch (elf_elfheader (abfd)->e_machine)
    {
    case EM_V800:
      arch = bfd_arch_v850_rh850;
      mach = (elf_elfheader (abfd)->e_flags & EF_V800_850E3)
	? bfd_mach_v850e3v5 : bfd_mach_v850e2v3;
      break;

    case EM_CYGNUS_V850:
    case EM_V850:
      arch = bfd_arch_v850;
      switch (elf_elfheader (abfd)->e_flags & EF_V850_ARCH)
	{
	default:
	case E_V850_ARCH:     mach = bfd_mach_v850; break;
	case E_V850E_ARCH:    mach = bfd_mach_v850e; break;
	case E_V850E1_ARCH:   mach = bfd_mach_v850e1; break;
	case E_V850E2_ARCH:   mach = bfd_mach_v850e2; break;
	case E_V850E2V3_ARCH: mach = bfd_mach_v850e2v3; break;
	case E_V850E3V5_ARCH: mach = bfd_mach_v850e3v5; break;
	}
      break;

    default:
      return FALSE;
    }

  return bfd_default_set_arch_mach (abfd, arch, mach);
}

/* Store the machine number in the flags field.  */

static void
v850_elf_final_write_processing (bfd *abfd,
				 bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_v850_rh850:
      val = EF_RH850_ABI;
      if (bfd_get_mach (abfd) == bfd_mach_v850e3v5)
	val |= EF_V800_850E3;
      elf_elfheader (abfd)->e_flags |= val;
      break;

    case bfd_arch_v850:
      switch (bfd_get_mach (abfd))
	{
	default:
	case bfd_mach_v850:     val = E_V850_ARCH; break;
	case bfd_mach_v850e:    val = E_V850E_ARCH; break;
	case bfd_mach_v850e1:   val = E_V850E1_ARCH; break;
	case bfd_mach_v850e2:   val = E_V850E2_ARCH; break;
	case bfd_mach_v850e2v3: val = E_V850E2V3_ARCH; break;
	case bfd_mach_v850e3v5: val = E_V850E3V5_ARCH; break;
	}
      elf_elfheader (abfd)->e_flags &=~ EF_V850_ARCH;
      elf_elfheader (abfd)->e_flags |= val;
      break;
    default:
      break;
    }
}

/* Function to keep V850 specific file flags.  */

static bfd_boolean
v850_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file
   to the output object file when linking.  */

static bfd_boolean
v850_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword out_flags;
  flagword in_flags;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (! elf_flags_init (obfd))
    {
      /* If the input is the default architecture then do not
	 bother setting the flags for the output architecture,
	 instead allow future merges to do this.  If no future
	 merges ever set these flags then they will retain their
	 unitialised values, which surprise surprise, correspond
	 to the default values.  */
      if (bfd_get_arch_info (ibfd)->the_default)
	return TRUE;

      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;

      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
	  && bfd_get_arch_info (obfd)->the_default)
	return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));

      return TRUE;
    }

  /* Check flag compatibility.  */
  if (in_flags == out_flags)
    return TRUE;

  if (bfd_get_arch (obfd) == bfd_arch_v850_rh850)
    {
      if ((in_flags & EF_V800_850E3) != (out_flags & EF_V800_850E3))
	{
	  _bfd_error_handler (_("%B: Architecture mismatch with previous modules"),
			      ibfd);
	  elf_elfheader (obfd)->e_flags |= EF_V800_850E3;
	}

      if ((in_flags & EF_RH850_DATA_ALIGN8) != (out_flags & EF_RH850_DATA_ALIGN8))
	{
	  _bfd_error_handler (_("%B: Alignment mismatch with previous modules"),
			      ibfd);
	  elf_elfheader (obfd)->e_flags |= EF_RH850_DATA_ALIGN8;
	}

      return TRUE;
    }

  if ((in_flags & EF_V850_ARCH) != (out_flags & EF_V850_ARCH)
      && (in_flags & EF_V850_ARCH) != E_V850_ARCH)
    {
      /* Allow earlier architecture binaries to be linked with later binaries.
         Set the output binary to the later architecture, except for v850e1,
         which we set to v850e.  */
      if (   (in_flags  & EF_V850_ARCH) == E_V850E1_ARCH
          && (out_flags & EF_V850_ARCH) == E_V850E_ARCH)
        return TRUE;

      if (   (in_flags  & EF_V850_ARCH) == E_V850_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E_ARCH);
	  return TRUE;
	}

      if ((   (in_flags & EF_V850_ARCH) == E_V850_ARCH
	   || (in_flags & EF_V850_ARCH) == E_V850E_ARCH)
	  && (out_flags & EF_V850_ARCH) == E_V850E2_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E2_ARCH);
	  return TRUE;
	}

      if ((   (in_flags & EF_V850_ARCH) == E_V850_ARCH
	   || (in_flags & EF_V850_ARCH) == E_V850E_ARCH
	   || (in_flags & EF_V850_ARCH) == E_V850E2_ARCH)
	  && (out_flags & EF_V850_ARCH) == E_V850E2V3_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E2V3_ARCH);
	  return TRUE;
	}

      if ((   (in_flags & EF_V850_ARCH) == E_V850_ARCH
	   || (in_flags & EF_V850_ARCH) == E_V850E_ARCH
	   || (in_flags & EF_V850_ARCH) == E_V850E2_ARCH
           || (in_flags & EF_V850_ARCH) == E_V850E2V3_ARCH)
	  && (out_flags & EF_V850_ARCH) == E_V850E3V5_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E3V5_ARCH);
	  return TRUE;
	}

      _bfd_error_handler (_("%B: Architecture mismatch with previous modules"),
			  ibfd);
    }

  return TRUE;
}

/* Display the flags field.  */

static bfd_boolean
v850_elf_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE * file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* xgettext:c-format.  */
  fprintf (file, _("private flags = %lx: "), elf_elfheader (abfd)->e_flags);

  if (bfd_get_arch (abfd) == bfd_arch_v850_rh850)
    {
      if ((elf_elfheader (abfd)->e_flags & EF_RH850_ABI) != EF_RH850_ABI)
	fprintf (file, _("unknown v850 architecture"));
      else if (elf_elfheader (abfd)->e_flags & EF_V800_850E3)
	fprintf (file, _("v850 E3 architecture"));
      else
	fprintf (file, _("v850 architecture"));

      if (elf_elfheader (abfd)->e_flags & EF_RH850_DATA_ALIGN8)
	fprintf (file, _(", 8-byte data alignment"));
    }
  else
    {
      switch (elf_elfheader (abfd)->e_flags & EF_V850_ARCH)
	{
	default:
	case E_V850_ARCH: fprintf (file, _("v850 architecture")); break;
	case E_V850E_ARCH: fprintf (file, _("v850e architecture")); break;
	case E_V850E1_ARCH: fprintf (file, _("v850e1 architecture")); break;
	case E_V850E2_ARCH: fprintf (file, _("v850e2 architecture")); break;
	case E_V850E2V3_ARCH: fprintf (file, _("v850e2v3 architecture")); break;
	case E_V850E3V5_ARCH: fprintf (file, _("v850e3v5 architecture")); break;
	}
    }

  fputc ('\n', file);

  return TRUE;
}

/* V850 ELF uses four common sections.  One is the usual one, and the
   others are for (small) objects in one of the special data areas:
   small, tiny and zero.  All the objects are kept together, and then
   referenced via the gp register, the ep register or the r0 register
   respectively, which yields smaller, faster assembler code.  This
   approach is copied from elf32-mips.c.  */

static asection  v850_elf_scom_section;
static asymbol   v850_elf_scom_symbol;
static asymbol * v850_elf_scom_symbol_ptr;
static asection  v850_elf_tcom_section;
static asymbol   v850_elf_tcom_symbol;
static asymbol * v850_elf_tcom_symbol_ptr;
static asection  v850_elf_zcom_section;
static asymbol   v850_elf_zcom_symbol;
static asymbol * v850_elf_zcom_symbol_ptr;

/* Given a BFD section, try to locate the
   corresponding ELF section index.  */

static bfd_boolean
v850_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
				   asection *sec,
				   int *retval)
{
  if (strcmp (bfd_get_section_name (abfd, sec), ".scommon") == 0)
    *retval = SHN_V850_SCOMMON;
  else if (strcmp (bfd_get_section_name (abfd, sec), ".tcommon") == 0)
    *retval = SHN_V850_TCOMMON;
  else if (strcmp (bfd_get_section_name (abfd, sec), ".zcommon") == 0)
    *retval = SHN_V850_ZCOMMON;
  else
    return FALSE;

  return TRUE;
}

/* Handle the special V850 section numbers that a symbol may use.  */

static void
v850_elf_symbol_processing (bfd *abfd, asymbol *asym)
{
  elf_symbol_type * elfsym = (elf_symbol_type *) asym;
  unsigned int indx;

  indx = elfsym->internal_elf_sym.st_shndx;

  /* If the section index is an "ordinary" index, then it may
     refer to a v850 specific section created by the assembler.
     Check the section's type and change the index it matches.

     FIXME: Should we alter the st_shndx field as well ?  */

  if (indx < elf_numsections (abfd))
    switch (elf_elfsections (abfd)[indx]->sh_type)
      {
      case SHT_V850_SCOMMON:
	indx = SHN_V850_SCOMMON;
	break;

      case SHT_V850_TCOMMON:
	indx = SHN_V850_TCOMMON;
	break;

      case SHT_V850_ZCOMMON:
	indx = SHN_V850_ZCOMMON;
	break;

      default:
	break;
      }

  switch (indx)
    {
    case SHN_V850_SCOMMON:
      if (v850_elf_scom_section.name == NULL)
	{
	  /* Initialize the small common section.  */
	  v850_elf_scom_section.name           = ".scommon";
	  v850_elf_scom_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
	  v850_elf_scom_section.output_section = & v850_elf_scom_section;
	  v850_elf_scom_section.symbol         = & v850_elf_scom_symbol;
	  v850_elf_scom_section.symbol_ptr_ptr = & v850_elf_scom_symbol_ptr;
	  v850_elf_scom_symbol.name            = ".scommon";
	  v850_elf_scom_symbol.flags           = BSF_SECTION_SYM;
	  v850_elf_scom_symbol.section         = & v850_elf_scom_section;
	  v850_elf_scom_symbol_ptr             = & v850_elf_scom_symbol;
	}
      asym->section = & v850_elf_scom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;

    case SHN_V850_TCOMMON:
      if (v850_elf_tcom_section.name == NULL)
	{
	  /* Initialize the tcommon section.  */
	  v850_elf_tcom_section.name           = ".tcommon";
	  v850_elf_tcom_section.flags          = SEC_IS_COMMON;
	  v850_elf_tcom_section.output_section = & v850_elf_tcom_section;
	  v850_elf_tcom_section.symbol         = & v850_elf_tcom_symbol;
	  v850_elf_tcom_section.symbol_ptr_ptr = & v850_elf_tcom_symbol_ptr;
	  v850_elf_tcom_symbol.name            = ".tcommon";
	  v850_elf_tcom_symbol.flags           = BSF_SECTION_SYM;
	  v850_elf_tcom_symbol.section         = & v850_elf_tcom_section;
	  v850_elf_tcom_symbol_ptr             = & v850_elf_tcom_symbol;
	}
      asym->section = & v850_elf_tcom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;

    case SHN_V850_ZCOMMON:
      if (v850_elf_zcom_section.name == NULL)
	{
	  /* Initialize the zcommon section.  */
	  v850_elf_zcom_section.name           = ".zcommon";
	  v850_elf_zcom_section.flags          = SEC_IS_COMMON;
	  v850_elf_zcom_section.output_section = & v850_elf_zcom_section;
	  v850_elf_zcom_section.symbol         = & v850_elf_zcom_symbol;
	  v850_elf_zcom_section.symbol_ptr_ptr = & v850_elf_zcom_symbol_ptr;
	  v850_elf_zcom_symbol.name            = ".zcommon";
	  v850_elf_zcom_symbol.flags           = BSF_SECTION_SYM;
	  v850_elf_zcom_symbol.section         = & v850_elf_zcom_section;
	  v850_elf_zcom_symbol_ptr             = & v850_elf_zcom_symbol;
	}
      asym->section = & v850_elf_zcom_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      break;
    }
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We must handle the special v850 section numbers here.  */

static bfd_boolean
v850_elf_add_symbol_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  Elf_Internal_Sym *sym,
			  const char **namep ATTRIBUTE_UNUSED,
			  flagword *flagsp ATTRIBUTE_UNUSED,
			  asection **secp,
			  bfd_vma *valp)
{
  unsigned int indx = sym->st_shndx;

  /* If the section index is an "ordinary" index, then it may
     refer to a v850 specific section created by the assembler.
     Check the section's type and change the index it matches.

     FIXME: Should we alter the st_shndx field as well ?  */

  if (indx < elf_numsections (abfd))
    switch (elf_elfsections (abfd)[indx]->sh_type)
      {
      case SHT_V850_SCOMMON:
	indx = SHN_V850_SCOMMON;
	break;

      case SHT_V850_TCOMMON:
	indx = SHN_V850_TCOMMON;
	break;

      case SHT_V850_ZCOMMON:
	indx = SHN_V850_ZCOMMON;
	break;

      default:
	break;
      }

  switch (indx)
    {
    case SHN_V850_SCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".scommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_V850_TCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".tcommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_V850_ZCOMMON:
      *secp = bfd_make_section_old_way (abfd, ".zcommon");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

static int
v850_elf_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  const char *name ATTRIBUTE_UNUSED,
				  Elf_Internal_Sym *sym,
				  asection *input_sec,
				  struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  /* If we see a common symbol, which implies a relocatable link, then
     if a symbol was in a special common section in an input file, mark
     it as a special common in the output file.  */

  if (sym->st_shndx == SHN_COMMON)
    {
      if (strcmp (input_sec->name, ".scommon") == 0)
	sym->st_shndx = SHN_V850_SCOMMON;
      else if (strcmp (input_sec->name, ".tcommon") == 0)
	sym->st_shndx = SHN_V850_TCOMMON;
      else if (strcmp (input_sec->name, ".zcommon") == 0)
	sym->st_shndx = SHN_V850_ZCOMMON;
    }

  /* The price we pay for using h->other unused bits as flags in the
     linker is cleaning up after ourselves.  */

  sym->st_other &= ~(V850_OTHER_SDA | V850_OTHER_ZDA | V850_OTHER_TDA
		     | V850_OTHER_ERROR);

  return 1;
}

static bfd_boolean
v850_elf_section_from_shdr (bfd *abfd,
			    Elf_Internal_Shdr *hdr,
			    const char *name,
			    int shindex)
{
  /* There ought to be a place to keep ELF backend specific flags, but
     at the moment there isn't one.  We just keep track of the
     sections by their name, instead.  */

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  switch (hdr->sh_type)
    {
    case SHT_V850_SCOMMON:
    case SHT_V850_TCOMMON:
    case SHT_V850_ZCOMMON:
      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
				   (bfd_get_section_flags (abfd,
							   hdr->bfd_section)
				    | SEC_IS_COMMON)))
	return FALSE;
    }

  return TRUE;
}

/* Set the correct type for a V850 ELF section.  We do this
   by the section name, which is a hack, but ought to work.  */

static bfd_boolean
v850_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
			Elf_Internal_Shdr *hdr,
			asection *sec)
{
  const char * name;

  name = bfd_get_section_name (abfd, sec);

  if (strcmp (name, ".scommon") == 0)
    hdr->sh_type = SHT_V850_SCOMMON;
  else if (strcmp (name, ".tcommon") == 0)
    hdr->sh_type = SHT_V850_TCOMMON;
  else if (strcmp (name, ".zcommon") == 0)
    hdr->sh_type = SHT_V850_ZCOMMON;

  return TRUE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
v850_elf_relax_delete_bytes (bfd *abfd,
			     asection *sec,
			     bfd_vma addr,
			     bfd_vma toaddr,
			     int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf32_External_Sym *extsyms;
  Elf32_External_Sym *esym;
  Elf32_External_Sym *esymend;
  int sym_index;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  struct elf_link_hash_entry *sym_hash;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_External_Sym_Shndx *shndx;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an alignment
     power larger than the number of bytes we are deleting.  */

  /* Actually delete the bytes.  */
#if (DEBUG_RELAX & 2)
  fprintf (stderr, "relax_delete: contents: sec: %s  %p .. %p %x\n",
	   sec->name, addr, toaddr, count );
#endif
  memmove (contents + addr, contents + addr + count,
	   toaddr - addr - count);
  memset (contents + toaddr-count, 0, count);

  /* Adjust all the relocs.  */
  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;

  for (; irel < irelend; irel++)
    {
      bfd_vma raddr, paddr, symval;
      Elf_Internal_Sym isym;

      /* Get the new reloc address.  */
      raddr = irel->r_offset;
      if ((raddr >= (addr + count) && raddr < toaddr))
	irel->r_offset -= count;

      if (raddr >= addr && raddr < addr + count)
	{
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       (int) R_V850_NONE);
	  continue;
	}

      if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN)
	continue;

      bfd_elf32_swap_symbol_in (abfd,
				extsyms + ELF32_R_SYM (irel->r_info),
				shndx ? shndx + ELF32_R_SYM (irel->r_info) : NULL,
				& isym);

      if (isym.st_shndx != sec_shndx)
	continue;

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  symval = isym.st_value;
#if (DEBUG_RELAX & 2)
	  {
	    char * name = bfd_elf_string_from_elf_section
	                   (abfd, symtab_hdr->sh_link, isym.st_name);
	    fprintf (stderr,
	       "relax_delete: local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
	       sec->name, name, isym.st_name,
	       sec->output_section->vma, sec->output_offset,
	       isym.st_value, irel->r_addend);
	  }
#endif
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry * h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;

	  h = elf_sym_hashes (abfd) [indx];
	  BFD_ASSERT (h != NULL);

	  symval = h->root.u.def.value;
#if (DEBUG_RELAX & 2)
	  fprintf (stderr,
		   "relax_delete: defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
		   sec->name, h->root.root.string, h->root.u.def.value,
		   sec->output_section->vma, sec->output_offset, irel->r_addend);
#endif
	}

      paddr = symval + irel->r_addend;

      if ( (symval >= addr + count && symval < toaddr)
	  && (paddr < addr + count || paddr >= toaddr))
	irel->r_addend += count;
      else if (    (symval < addr + count || symval >= toaddr)
	        && (paddr >= addr + count && paddr < toaddr))
	irel->r_addend -= count;
    }

  /* Adjust the local symbols defined in this section.  */
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;

  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value >= addr + count
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;

	  if (isym.st_value + isym.st_size >= toaddr)
	    isym.st_size += count;

	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
	}
      else if (isym.st_shndx == sec_shndx
	       && isym.st_value < addr + count)
	{
	  if (isym.st_value+isym.st_size >= addr + count
	      && isym.st_value+isym.st_size < toaddr)
	    isym.st_size -= count;

	  if (isym.st_value >= addr
	      && isym.st_value <  addr + count)
	    isym.st_value = addr;

	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));

  for (sym_index = 0; esym < esymend; esym ++, sym_index ++)
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
      sym_hash = elf_sym_hashes (abfd) [sym_index];

      if (isym.st_shndx == sec_shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value >= addr + count
	  && (sym_hash)->root.u.def.value < toaddr)
	{
	  if ((sym_hash)->root.u.def.value + isym.st_size >= toaddr)
	    {
	      isym.st_size += count;
	      bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
	    }

	  (sym_hash)->root.u.def.value -= count;
	}
      else if (isym.st_shndx == sec_shndx
	       && ((sym_hash)->root.type == bfd_link_hash_defined
		   || (sym_hash)->root.type == bfd_link_hash_defweak)
	       && (sym_hash)->root.u.def.section == sec
	       && (sym_hash)->root.u.def.value < addr + count)
	{
	  if ((sym_hash)->root.u.def.value+isym.st_size >= addr + count
	      && (sym_hash)->root.u.def.value+isym.st_size < toaddr)
	    isym.st_size -= count;

	  if ((sym_hash)->root.u.def.value >= addr
	      && (sym_hash)->root.u.def.value < addr + count)
	    (sym_hash)->root.u.def.value = addr;

	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
	}

      if (shndx)
	++ shndx;
    }

  return TRUE;
}

#define NOP_OPCODE 	(0x0000)
#define MOVHI	    	0x0640				/* 4byte.  */
#define MOVHI_MASK  	0x07e0
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte.  */
#define MOVHI_R2(insn)	((insn) >> 11)
#define MOVEA	    	0x0620				/* 2byte.  */
#define MOVEA_MASK  	0x07e0
#define MOVEA_R1(insn)	((insn) & 0x1f)
#define MOVEA_R2(insn)	((insn) >> 11)
#define JARL_4	    	0x00040780				/* 4byte.  */
#define JARL_4_MASK 	0xFFFF07FF
#define JARL_R2(insn)	(int)(((insn) & (~JARL_4_MASK)) >> 11)
#define ADD_I       	0x0240					/* 2byte.  */
#define ADD_I_MASK  	0x07e0
#define ADD_I5(insn)	((((insn) & 0x001f) << 11) >> 11)	/* 2byte.  */
#define ADD_R2(insn)	((insn) >> 11)
#define JMP_R	    	0x0060					/* 2byte.  */
#define JMP_R_MASK 	0xFFE0
#define JMP_R1(insn)	((insn) & 0x1f)

static bfd_boolean
v850_elf_relax_section (bfd *abfd,
			asection *sec,
			struct bfd_link_info *link_info,
			bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Rela *irelalign = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_byte *contents = NULL;
  bfd_vma addr = 0;
  bfd_vma toaddr;
  int align_pad_size = 0;
  bfd_boolean result = TRUE;

  *again = FALSE;

  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;

  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, NULL, link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  irelend = internal_relocs + sec->reloc_count;

  while (addr < sec->size)
    {
      toaddr = sec->size;

      for (irel = internal_relocs; irel < irelend; irel ++)
	if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN
	    && irel->r_offset > addr
	    && irel->r_offset < toaddr)
	  toaddr = irel->r_offset;

#ifdef DEBUG_RELAX
      fprintf (stderr, "relax region 0x%x to 0x%x align pad %d\n",
	       addr, toaddr, align_pad_size);
#endif
      if (irelalign)
	{
	  bfd_vma alignto;
	  bfd_vma alignmoveto;

	  alignmoveto = BFD_ALIGN (addr - align_pad_size, 1 << irelalign->r_addend);
	  alignto = BFD_ALIGN (addr, 1 << irelalign->r_addend);

	  if (alignmoveto < alignto)
	    {
	      bfd_vma i;

	      align_pad_size = alignto - alignmoveto;
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax move region 0x%x to 0x%x delete size 0x%x\n",
		       alignmoveto, toaddr, align_pad_size);
#endif
	      if (!v850_elf_relax_delete_bytes (abfd, sec, alignmoveto,
						toaddr, align_pad_size))
		goto error_return;

	      for (i  = BFD_ALIGN (toaddr - align_pad_size, 1);
		   (i + 1) < toaddr; i += 2)
		bfd_put_16 (abfd, NOP_OPCODE, contents + i);

	      addr = alignmoveto;
	    }
	  else
	    align_pad_size = 0;
	}

      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  bfd_vma laddr;
	  bfd_vma addend;
	  bfd_vma symval;
	  int insn[5];
	  int no_match = -1;
	  Elf_Internal_Rela *hi_irelfn;
	  Elf_Internal_Rela *lo_irelfn;
	  Elf_Internal_Rela *irelcall;
	  bfd_signed_vma foff;
	  unsigned int r_type;

	  if (! (irel->r_offset >= addr && irel->r_offset < toaddr
		 && (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGCALL
		     || ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGJUMP)))
	    continue;

#ifdef DEBUG_RELAX
	  fprintf (stderr, "relax check r_info 0x%x r_offset 0x%x r_addend 0x%x\n",
		   irel->r_info,
		   irel->r_offset,
		   irel->r_addend );
#endif

	  /* Get the section contents.  */
	  if (contents == NULL)
	    {
	      if (elf_section_data (sec)->this_hdr.contents != NULL)
		contents = elf_section_data (sec)->this_hdr.contents;
	      else
		{
		  if (! bfd_malloc_and_get_section (abfd, sec, &contents))
		    goto error_return;
		}
	    }

	  /* Read this BFD's local symbols if we haven't done so already.  */
	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  laddr = irel->r_offset;

	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGCALL)
	    {
	      /* Check code for -mlong-calls output. */
	      if (laddr + 16 <= (bfd_vma) sec->size)
		{
		  insn[0] = bfd_get_16 (abfd, contents + laddr);
		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
		  insn[2] = bfd_get_32 (abfd, contents + laddr + 8);
		  insn[3] = bfd_get_16 (abfd, contents + laddr + 12);
		  insn[4] = bfd_get_16 (abfd, contents + laddr + 14);

		  if ((insn[0] & MOVHI_MASK) != MOVHI
		       || MOVHI_R1 (insn[0]) != 0)
		    no_match = 0;

		  if (no_match < 0
		      && ((insn[1] & MOVEA_MASK) != MOVEA
			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
		    no_match = 1;

		  if (no_match < 0
		      && (insn[2] & JARL_4_MASK) != JARL_4)
		    no_match = 2;

		  if (no_match < 0
		      && ((insn[3] & ADD_I_MASK) != ADD_I
			   || ADD_I5 (insn[3]) != 4
			   || JARL_R2 (insn[2]) != ADD_R2 (insn[3])))
		    no_match = 3;

		  if (no_match < 0
		      && ((insn[4] & JMP_R_MASK) != JMP_R
			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[4])))
		    no_match = 4;
		}
	      else
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized insns",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));

		  continue;
		}

	      if (no_match >= 0)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized insn 0x%x",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));

		  continue;
		}

	      /* Get the reloc for the address from which the register is
	         being loaded.  This reloc will tell us which function is
	         actually being called.  */

	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
		{
		  r_type = ELF32_R_TYPE (hi_irelfn->r_info);

		  if (hi_irelfn->r_offset == laddr + 2
		      && (r_type == (int) R_V850_HI16_S || r_type == (int) R_V810_WHI1))
		    break;
		}

	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
		{
		  r_type = ELF32_R_TYPE (lo_irelfn->r_info);

		  if (lo_irelfn->r_offset == laddr + 6
		      && (r_type == (int) R_V850_LO16 || r_type == (int) R_V810_WLO))
		    break;
		}

	      for (irelcall = internal_relocs; irelcall < irelend; irelcall ++)
		{
		  r_type = ELF32_R_TYPE (irelcall->r_info);

		  if (irelcall->r_offset == laddr + 8
		      && (r_type == (int) R_V850_22_PCREL || r_type == (int) R_V850_PCR22))
		    break;
		}

	      if (   hi_irelfn == irelend
		  || lo_irelfn == irelend
		  || irelcall  == irelend)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized reloc",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));

		  continue;
		}

	      if (ELF32_R_SYM (irelcall->r_info) < symtab_hdr->sh_info)
		{
		  Elf_Internal_Sym *  isym;

		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (irelcall->r_info);

		  symval = isym->st_value;
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry * h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (irelcall->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = h->root.u.def.value;
		}

	      if (symval + irelcall->r_addend != irelcall->r_offset + 4)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized reloc 0x%lx",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset, irelcall->r_offset ));

		  continue;
		}

	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		{
		  Elf_Internal_Sym *isym;
		  asection *sym_sec;

		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);

		  if (isym->st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym->st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym->st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  symval = (isym->st_value
			    + sym_sec->output_section->vma
			    + sym_sec->output_offset);
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry *h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (hi_irelfn->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
		}

	      addend = irel->r_addend;

	      foff = (symval + addend
		      - (irel->r_offset
			 + sec->output_section->vma
			 + sec->output_offset
			 + 4));
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax longcall r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
		       irel->r_offset,
		       (irel->r_offset
			+ sec->output_section->vma
			+ sec->output_offset),
		       symval, addend, foff);
#endif

	      if (foff < -0x100000 || foff >= 0x100000)
		/* After all that work, we can't shorten this function call.  */
		continue;

	      /* For simplicity of coding, we are going to modify the section
	         contents, the section relocs, and the BFD symbol table.  We
	         must tell the rest of the code not to free up this
	         information.  It would be possible to instead create a table
	         of changes which have to be made, as is done in coff-mips.c;
	         that would be more work, but would require less memory when
	         the linker is run.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (bfd_byte *) isymbuf;

	      /* Replace the long call with a jarl.  */
	      if (bfd_get_arch (abfd) == bfd_arch_v850_rh850)
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_PCR22);
	      else
		irel->r_info = ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_22_PCREL);

	      addend = 0;

	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		/* If this needs to be changed because of future relaxing,
		   it will be handled here like other internal IND12W
		   relocs.  */
		bfd_put_32 (abfd,
			    0x00000780 | (JARL_R2 (insn[2])<<11) | ((addend << 16) & 0xffff) | ((addend >> 16) & 0xf),
			    contents + irel->r_offset);
	      else
		/* We can't fully resolve this yet, because the external
		   symbol value may be changed by future relaxing.
		   We let the final link phase handle it.  */
		bfd_put_32 (abfd, 0x00000780 | (JARL_R2 (insn[2])<<11),
			    contents + irel->r_offset);

	      hi_irelfn->r_info =
		ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
	      lo_irelfn->r_info =
		ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
	      irelcall->r_info =
		ELF32_R_INFO (ELF32_R_SYM (irelcall->r_info), R_V850_NONE);

	      if (! v850_elf_relax_delete_bytes (abfd, sec,
						 irel->r_offset + 4, toaddr, 12))
		goto error_return;

	      align_pad_size += 12;
	    }
	  else if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGJUMP)
	    {
	      /* Check code for -mlong-jumps output.  */
	      if (laddr + 10 <= (bfd_vma) sec->size)
		{
		  insn[0] = bfd_get_16 (abfd, contents + laddr);
		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
		  insn[2] = bfd_get_16 (abfd, contents + laddr + 8);

		  if ((insn[0] & MOVHI_MASK) != MOVHI
		       || MOVHI_R1 (insn[0]) != 0)
		    no_match = 0;

		  if (no_match < 0
		      && ((insn[1] & MOVEA_MASK) != MOVEA
			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
		    no_match = 1;

		  if (no_match < 0
		      && ((insn[2] & JMP_R_MASK) != JMP_R
			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[2])))
		    no_match = 4;
		}
	      else
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized insns",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));

		  continue;
		}

	      if (no_match >= 0)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized insn 0x%x",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));

		  continue;
		}

	      /* Get the reloc for the address from which the register is
	         being loaded.  This reloc will tell us which function is
	         actually being called.  */
	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
		{
		  r_type = ELF32_R_TYPE (hi_irelfn->r_info);

		  if (hi_irelfn->r_offset == laddr + 2
		      && ((r_type == (int) R_V850_HI16_S) || r_type == (int) R_V810_WHI1))
		    break;
		}

	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
		{
		  r_type = ELF32_R_TYPE (lo_irelfn->r_info);

		  if (lo_irelfn->r_offset == laddr + 6
		      && (r_type == (int) R_V850_LO16 || r_type == (int) R_V810_WLO))
		    break;
		}

	      if (   hi_irelfn == irelend
		  || lo_irelfn == irelend)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized reloc",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));

		  continue;
		}

	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		{
		  Elf_Internal_Sym *  isym;
		  asection *          sym_sec;

		  /* A local symbol.  */
		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);

		  if (isym->st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym->st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym->st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  symval = (isym->st_value
			    + sym_sec->output_section->vma
			    + sym_sec->output_offset);
#ifdef DEBUG_RELAX
		  {
		    char * name = bfd_elf_string_from_elf_section
		      (abfd, symtab_hdr->sh_link, isym->st_name);

		    fprintf (stderr, "relax long jump local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
			     sym_sec->name, name, isym->st_name,
			     sym_sec->output_section->vma,
			     sym_sec->output_offset,
			     isym->st_value, irel->r_addend);
		  }
#endif
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry * h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
#ifdef DEBUG_RELAX
		  fprintf (stderr,
			   "relax longjump defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
			   sec->name, h->root.root.string, h->root.u.def.value,
			   sec->output_section->vma, sec->output_offset, irel->r_addend);
#endif
		}

	      addend = irel->r_addend;

	      foff = (symval + addend
		      - (irel->r_offset
			 + sec->output_section->vma
			 + sec->output_offset
			 + 4));
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax longjump r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
		       irel->r_offset,
		       (irel->r_offset
			+ sec->output_section->vma
			+ sec->output_offset),
		       symval, addend, foff);
#endif
	      if (foff < -0x100000 || foff >= 0x100000)
		/* After all that work, we can't shorten this function call.  */
		continue;

	      /* For simplicity of coding, we are going to modify the section
	         contents, the section relocs, and the BFD symbol table.  We
	         must tell the rest of the code not to free up this
	         information.  It would be possible to instead create a table
	         of changes which have to be made, as is done in coff-mips.c;
	         that would be more work, but would require less memory when
	         the linker is run.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      elf_section_data (sec)->this_hdr.contents = contents;
	      symtab_hdr->contents = (bfd_byte *) isymbuf;

	      if (foff < -0x100 || foff >= 0x100)
		{
		  /* Replace the long jump with a jr.  */

		  if (bfd_get_arch (abfd) == bfd_arch_v850_rh850)
		    irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_PCR22);
		  else
		    irel->r_info =
		      ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);

		  irel->r_addend = addend;
		  addend = 0;

		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		    /* If this needs to be changed because of future relaxing,
		       it will be handled here like other internal IND12W
		       relocs.  */
		    bfd_put_32 (abfd,
				0x00000780 | ((addend << 15) & 0xffff0000) | ((addend >> 17) & 0xf),
				contents + irel->r_offset);
		  else
		    /* We can't fully resolve this yet, because the external
		       symbol value may be changed by future relaxing.
		       We let the final link phase handle it.  */
		    bfd_put_32 (abfd, 0x00000780, contents + irel->r_offset);

		  hi_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
		  lo_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
		  if (!v850_elf_relax_delete_bytes (abfd, sec,
						    irel->r_offset + 4, toaddr, 6))
		    goto error_return;

		  align_pad_size += 6;
		}
	      else
		{
		  /* Replace the long jump with a br.  */

		  if (bfd_get_arch (abfd) == bfd_arch_v850_rh850)
		    irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_PC9);
		  else
		    irel->r_info =
		      ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_9_PCREL);

		  irel->r_addend = addend;
		  addend = 0;

		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		    /* If this needs to be changed because of future relaxing,
		       it will be handled here like other internal IND12W
		       relocs.  */
		    bfd_put_16 (abfd,
				0x0585 | ((addend << 10) & 0xf800) | ((addend << 3) & 0x0070),
				contents + irel->r_offset);
		  else
		    /* We can't fully resolve this yet, because the external
		       symbol value may be changed by future relaxing.
		       We let the final link phase handle it.  */
		    bfd_put_16 (abfd, 0x0585, contents + irel->r_offset);

		  hi_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
		  lo_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
		  if (!v850_elf_relax_delete_bytes (abfd, sec,
						    irel->r_offset + 2, toaddr, 8))
		    goto error_return;

		  align_pad_size += 8;
		}
	    }
	}

      irelalign = NULL;
      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN
	      && irel->r_offset == toaddr)
	    {
	      irel->r_offset -= align_pad_size;

	      if (irelalign == NULL || irelalign->r_addend > irel->r_addend)
		irelalign = irel;
	    }
	}

      addr = toaddr;
    }

  if (!irelalign)
    {
#ifdef DEBUG_RELAX
      fprintf (stderr, "relax pad %d shorten %d -> %d\n",
	       align_pad_size,
	       sec->size,
	       sec->size - align_pad_size);
#endif
      sec->size -= align_pad_size;
    }

 finish:
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != (unsigned char *) contents)
    free (contents);

  if (isymbuf != NULL
      && symtab_hdr->contents != (bfd_byte *) isymbuf)
    free (isymbuf);

  return result;

 error_return:
  result = FALSE;
  goto finish;
}

static const struct bfd_elf_special_section v850_elf_special_sections[] =
{
  { STRING_COMMA_LEN (".call_table_data"), 0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE) },
  { STRING_COMMA_LEN (".call_table_text"), 0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
								 + SHF_EXECINSTR) },
  { STRING_COMMA_LEN (".rosdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
								 + SHF_V850_GPREL) },
  { STRING_COMMA_LEN (".rozdata"),        -2, SHT_PROGBITS,     (SHF_ALLOC
								 + SHF_V850_R0REL) },
  { STRING_COMMA_LEN (".sbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_GPREL) },
  { STRING_COMMA_LEN (".scommon"),        -2, SHT_V850_SCOMMON, (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_GPREL) },
  { STRING_COMMA_LEN (".sdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_GPREL) },
  { STRING_COMMA_LEN (".tbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_EPREL) },
  { STRING_COMMA_LEN (".tcommon"),        -2, SHT_V850_TCOMMON, (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_R0REL) },
  { STRING_COMMA_LEN (".tdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_EPREL) },
  { STRING_COMMA_LEN (".zbss"),           -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_R0REL) },
  { STRING_COMMA_LEN (".zcommon"),        -2, SHT_V850_ZCOMMON, (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_R0REL) },
  { STRING_COMMA_LEN (".zdata"),          -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
								 + SHF_V850_R0REL) },
  { NULL,                     0,           0, 0,                0 }
};

#define TARGET_LITTLE_SYM			bfd_elf32_v850_vec
#define TARGET_LITTLE_NAME			"elf32-v850"
#define ELF_ARCH				bfd_arch_v850
#define ELF_MACHINE_CODE			EM_V850
#define ELF_MACHINE_ALT1			EM_CYGNUS_V850
#define ELF_MAXPAGESIZE				0x1000

#define elf_info_to_howto			v850_elf_info_to_howto_rela
#define elf_info_to_howto_rel			v850_elf_info_to_howto_rel

#define elf_backend_check_relocs		v850_elf_check_relocs
#define elf_backend_relocate_section    	v850_elf_relocate_section
#define elf_backend_object_p			v850_elf_object_p
#define elf_backend_final_write_processing 	v850_elf_final_write_processing
#define elf_backend_section_from_bfd_section 	v850_elf_section_from_bfd_section
#define elf_backend_symbol_processing		v850_elf_symbol_processing
#define elf_backend_add_symbol_hook		v850_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook 	v850_elf_link_output_symbol_hook
#define elf_backend_section_from_shdr		v850_elf_section_from_shdr
#define elf_backend_fake_sections		v850_elf_fake_sections
#define elf_backend_gc_mark_hook                v850_elf_gc_mark_hook
#define elf_backend_special_sections		v850_elf_special_sections

#define elf_backend_can_gc_sections 1
#define elf_backend_rela_normal 1

#define bfd_elf32_bfd_is_local_label_name	v850_elf_is_local_label_name
#define bfd_elf32_bfd_is_target_special_symbol	v850_elf_is_target_special_symbol

#define bfd_elf32_bfd_reloc_type_lookup		v850_elf_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup	        v850_elf_reloc_name_lookup
#define bfd_elf32_bfd_merge_private_bfd_data 	v850_elf_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags		v850_elf_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data	v850_elf_print_private_bfd_data
#define bfd_elf32_bfd_relax_section		v850_elf_relax_section

#define elf_symbol_leading_char			'_'

#undef  elf32_bed
#define elf32_bed elf32_v850_bed

#include "elf32-target.h"

/* Map BFD reloc types to V800 ELF reloc types.  */

static const struct v850_elf_reloc_map v800_elf_reloc_map[] =
{
  { BFD_RELOC_NONE,                   R_V810_NONE    },
  { BFD_RELOC_8,                      R_V810_BYTE    },
  { BFD_RELOC_16,                     R_V810_HWORD   },
  { BFD_RELOC_32,                     R_V810_WORD    },
  { BFD_RELOC_LO16,                   R_V810_WLO     },
  { BFD_RELOC_HI16,                   R_V810_WHI     },
  { BFD_RELOC_HI16_S,                 R_V810_WHI1    },
  { BFD_RELOC_V850_32_PCREL,          R_V850_PC32    },
  { BFD_RELOC_V850_22_PCREL,          R_V850_PCR22   },
  { BFD_RELOC_V850_17_PCREL,          R_V850_PC17    },
  { BFD_RELOC_V850_16_PCREL,          R_V850_PC16U   },
  { BFD_RELOC_V850_9_PCREL,	      R_V850_PC9     },
  { BFD_RELOC_V850_LO16_S1,           R_V810_WLO_1   }, /* Or R_V850_HWLO or R_V850_HWLO_1.  */
  { BFD_RELOC_V850_23,                R_V850_WLO23   },
  { BFD_RELOC_V850_LO16_SPLIT_OFFSET, R_V850_BLO     },
  { BFD_RELOC_V850_ZDA_16_16_OFFSET,  R_V810_HWORD   },
  { BFD_RELOC_V850_TDA_16_16_OFFSET,  R_V810_HWORD   },
  { BFD_RELOC_V850_SDA_16_16_OFFSET,  R_V810_HWORD   },
  { BFD_RELOC_V850_SDA_15_16_OFFSET,  R_V810_GPWLO_1 }
};

/* Map a bfd relocation into the appropriate howto structure.  */

static reloc_howto_type *
v800_elf_reloc_type_lookup (bfd * abfd, bfd_reloc_code_real_type code)
{
  unsigned int i;

  BFD_ASSERT (bfd_get_arch (abfd) == bfd_arch_v850_rh850);

  for (i = ARRAY_SIZE (v800_elf_reloc_map); i --;)
    if (v800_elf_reloc_map[i].bfd_reloc_val == code)
      {
	unsigned int elf_reloc_val = v800_elf_reloc_map[i].elf_reloc_val;
	unsigned int idx = elf_reloc_val - R_V810_NONE;

	BFD_ASSERT (v800_elf_howto_table[idx].type == elf_reloc_val);

	return v800_elf_howto_table + idx;
      }

#ifdef DEBUG
  fprintf (stderr, "failed to find v800 equiv of bfd reloc code %d\n", code);
#endif
  return NULL;
}

static reloc_howto_type *
v800_elf_reloc_name_lookup (bfd * abfd, const char * r_name)
{
  unsigned int i;

  BFD_ASSERT (bfd_get_arch (abfd) == bfd_arch_v850_rh850);

  for (i = ARRAY_SIZE (v800_elf_howto_table); i--;)
    if (v800_elf_howto_table[i].name != NULL
	&& strcasecmp (v800_elf_howto_table[i].name, r_name) == 0)
      return v800_elf_howto_table + i;

  return NULL;
}


/* Set the howto pointer in CACHE_PTR for a V800 ELF reloc.  */

static void
v800_elf_info_to_howto (bfd *               abfd,
			arelent *           cache_ptr,
			Elf_Internal_Rela * dst)
{
  unsigned int r_type = ELF32_R_TYPE (dst->r_info);

  BFD_ASSERT (bfd_get_arch (abfd) == bfd_arch_v850_rh850);

  BFD_ASSERT (r_type < (unsigned int) R_V800_max);

  if (r_type == R_V800_NONE)
    r_type = R_V810_NONE;

  BFD_ASSERT (r_type >= (unsigned int) R_V810_NONE);
  r_type -= R_V810_NONE;
  BFD_ASSERT (r_type < ARRAY_SIZE (v800_elf_howto_table));

  cache_ptr->howto = v800_elf_howto_table + r_type;
}


#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM			bfd_elf32_v850_rh850_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME			"elf32-v850-rh850"
#undef  ELF_ARCH
#define ELF_ARCH				bfd_arch_v850_rh850
#undef  ELF_MACHINE_CODE
#define ELF_MACHINE_CODE			EM_V800
#undef  ELF_MACHINE_ALT1

#undef  elf32_bed
#define elf32_bed elf32_v850_rh850_bed

#undef  elf_info_to_howto
#define elf_info_to_howto			v800_elf_info_to_howto
#undef  elf_info_to_howto_rel
#define elf_info_to_howto_rel			NULL
#undef  bfd_elf32_bfd_reloc_type_lookup
#define bfd_elf32_bfd_reloc_type_lookup		v800_elf_reloc_type_lookup
#undef  bfd_elf32_bfd_reloc_name_lookup
#define bfd_elf32_bfd_reloc_name_lookup		v800_elf_reloc_name_lookup

#include "elf32-target.h"
@


1.89
log
@	* elf32-v850.c (v850_elf_is_target_special_symbol): New function.
	(bfd_elf32_bfd_is_target_special_symbol): Define.

	* v850.h (V850_INVERSE_PCREL): Define.

	* v850-dis.c (print_value): With V850_INVERSE_PCREL compute the
	destination address by subtracting the operand from the current
	address.
	* v850-opc.c (insert_u16_loop): Disallow negative offsets.  Store
	a positive value in the insn.
	(extract_u16_loop): Do not negate the returned value.
	(D16_LOOP): Add V850_INVERSE_PCREL flag.

	(ceilf.sw): Remove duplicate entry.
	(cvtf.hs): New entry.
	(cvtf.sh): Likewise.
	(fmaf.s): Likewise.
	(fmsf.s): Likewise.
	(fnmaf.s): Likewise.
	(fnmsf.s): Likewise.
	(maddf.s): Restrict to E3V5 architectures.
	(msubf.s): Likewise.
	(nmaddf.s): Likewise.
	(nmsubf.s): Likewise.
@
text
@d3144 1
a3144 1
	      unsigned int i;
@


1.88
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d1923 6
d3800 2
@


1.87
log
@Add support for V850E3V5 architecture
@
text
@d86 4
@


1.86
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d2 1
a2 3
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d2341 2
a2342 1
      mach = bfd_mach_v850e2v3;
d2356 1
d2379 2
d2393 1
d2513 11
d2567 1
@


1.85
log
@2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* Makefile.am (ALL_MACHINES): Add cpu-v850-rh850.lo.
	(ALL_MACHINES_CFILES): Add cpu-v850-rh850.c.
	* archures.c (bfd_arch_info): Add bfd_v850_rh850_arch.
	* config.bfd: Likewise.
	* configure.in: Add bfd_elf32_v850_rh850_vec.
	* cpu-v850.c: Update printed description.
	* cpu-v850_rh850.c: New file.
	* elf32-v850.c (v850_elf_check_relocs): Add support for RH850 ABI
	relocs.
	(v850_elf_perform_relocation): Likewise.
	(v850_elf_final_link_relocate): Likewise.
	(v850_elf_relocate_section): Likewise.
	(v850_elf_relax_section): Likewise.
	(v800_elf_howto_table): New.
	(v850_elf_object_p): Add support for RH850 ABI values.
	(v850_elf_final_write_processing): Likewise.
	(v850_elf_merge_private_bfd_data): Likewise.
	(v850_elf_print_private_bfd_data): Likewise.
	(v800_elf_reloc_map): New.
	(v800_elf_reloc_type_lookup): New.
	(v800_elf_reloc_name_lookup): New.
	(v800_elf_info_to_howto): New.
	(bfd_elf32_v850_rh850_vec): New.
	(bfd_arch_v850_rh850): New.
	* targets.c (_bfd_targets): Add bfd_elf32_v850_rh850_vec.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.

	* readelf.c (get_machine_flags): Add support for E_FLAG_RX_ABI.
	(guess_is_rela): Add EM_V800.
	(dump_relocations): Likewise.
	(get_machine_name): Update EM_V800.
	(get_machine_flags): Add support for RH850 ABI flags.
	(is_32bit_abs_reloc): Add support for RH850 ABI reloc.

	* config/tc-v850.c (v850_target_arch): New.
	(v850_target_format): New.
	(set_machine): Use v850_target_arch.
	(md_begin): Likewise.
	(md_show_usage): Document new switches.
	(md_parse_option): Add -mgcc-abi, -mrh850-abi, -m8byte-align and
	-m4byte-align.
	* config/tc-v850.c (TARGET_ARCH) Use v850_target_arch.
	(TARGET_FORMAT): Use v850_target_format.
	* doc/c-v850.texi: Document new options.

	* v850.h: Add RH850 ABI values.

	* Makefile.am: (ALL_EMULATION_SOURCES): Add ev850_rh850.c.
	* Makefile.in: Regenerate.
	* configure.tgt (v850*-*-*): Make v850_rh850 the default
	emulation. Add vanilla v850 as an extra emulation.
	* emulparams/v850_rh850.sh: New file.
	* scripttempl/v850_rh850.sc: New file.

	* configure.in: Add bfd_v850_rh850_arch.
	* configure: Regenerate.
	* disassemble.c (disassembler): Likewise.
@
text
@d2534 1
a2534 1
	fprintf (file, _("unknown v850 architecture"));	
d3247 1
a3247 1
	      
d3876 1
a3876 1
  cache_ptr->howto = v800_elf_howto_table + r_type;  
@


1.84
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d58 1
a58 1
  enum v850_reloc_type r_type;
d90 1
a90 1
      r_type = (enum v850_reloc_type) ELF32_R_TYPE (rel->r_info);
a93 22
	case R_V850_NONE:
	case R_V850_9_PCREL:
	case R_V850_16_PCREL:
	case R_V850_17_PCREL:
	case R_V850_22_PCREL:
	case R_V850_32_PCREL:
	case R_V850_32_ABS:
	case R_V850_HI16:
	case R_V850_HI16_S:
	case R_V850_LO16:
	case R_V850_LO16_S1:
	case R_V850_LO16_SPLIT_OFFSET:
	case R_V850_23:
	case R_V850_ABS32:
	case R_V850_REL32:
	case R_V850_16:
	case R_V850_16_S1:
	case R_V850_16_SPLIT_OFFSET:
	case R_V850_8:
	case R_V850_CALLT_6_7_OFFSET:
	case R_V850_CALLT_15_16_OFFSET:
	case R_V850_CALLT_16_16_OFFSET:
d115 3
d494 3
d501 2
d506 1
d514 1
d528 1
d541 1
d554 1
d567 1
d574 1
d589 1
d596 1
d650 1
d667 1
d756 3
d771 1
d890 1
a890 1
   SeeAlso: RELOC_NUBMER in include/elf/v850.h  */
d1746 103
d1948 1
d1955 1
d1967 1
d1980 1
d1994 1
d2011 9
d2034 1
d2124 1
d2133 3
d2172 1
a2172 1
      int r_type;
d2188 7
a2194 1
      howto = v850_elf_howto_table + r_type;
d2331 1
a2331 1
/* Set the right machine number.  */
d2336 4
a2339 1
  switch (elf_elfheader (abfd)->e_flags & EF_V850_ARCH)
d2341 3
a2343 3
    default:
    case E_V850_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850);
d2345 13
a2357 11
    case E_V850E_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e);
      break;
    case E_V850E1_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e1);
      break;
    case E_V850E2_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e2);
      break;
    case E_V850E2V3_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e2v3);
d2359 3
d2363 2
a2364 1
  return TRUE;
d2375 1
a2375 1
  switch (bfd_get_mach (abfd))
d2377 18
d2396 1
a2396 5
    case bfd_mach_v850:   val = E_V850_ARCH; break;
    case bfd_mach_v850e:  val = E_V850E_ARCH; break;
    case bfd_mach_v850e1: val = E_V850E1_ARCH; break;
    case bfd_mach_v850e2: val = E_V850E2_ARCH;  break;
    case bfd_mach_v850e2v3: val = E_V850E2V3_ARCH;  break;
a2397 3

  elf_elfheader (abfd)->e_flags &=~ EF_V850_ARCH;
  elf_elfheader (abfd)->e_flags |= val;
d2454 19
d2476 4
a2479 4

      /* Allow v850e1 binaries to be linked with v850e binaries.
         Set the output binary to v850e.  */
      if ((in_flags & EF_V850_ARCH) == E_V850E1_ARCH
d2483 1
a2483 1
      if ((in_flags & EF_V850_ARCH) == E_V850_ARCH
d2491 1
a2491 1
      if (((in_flags & EF_V850_ARCH) == E_V850_ARCH
d2500 1
a2500 1
      if (((in_flags & EF_V850_ARCH) == E_V850_ARCH
d2531 1
a2531 1
  switch (elf_elfheader (abfd)->e_flags & EF_V850_ARCH)
d2533 21
a2553 6
    default:
    case E_V850_ARCH: fprintf (file, _("v850 architecture")); break;
    case E_V850E_ARCH: fprintf (file, _("v850e architecture")); break;
    case E_V850E1_ARCH: fprintf (file, _("v850e1 architecture")); break;
    case E_V850E2_ARCH: fprintf (file, _("v850e2 architecture")); break;
    case E_V850E2V3_ARCH: fprintf (file, _("v850e2v3 architecture")); break;
d3151 1
d3247 1
d3249 7
a3255 4
		if (hi_irelfn->r_offset == laddr + 2
		    && ELF32_R_TYPE (hi_irelfn->r_info)
		        == (int) R_V850_HI16_S)
		  break;
d3258 7
a3264 4
		if (lo_irelfn->r_offset == laddr + 6
		    && ELF32_R_TYPE (lo_irelfn->r_info)
		        == (int) R_V850_LO16)
		  break;
d3267 7
a3273 4
		if (irelcall->r_offset == laddr + 8
		    && ELF32_R_TYPE (irelcall->r_info)
                        == (int) R_V850_22_PCREL)
		  break;
d3399 4
a3402 1
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_22_PCREL);
d3478 7
a3484 3
		if (hi_irelfn->r_offset == laddr + 2
		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V850_HI16_S)
		  break;
d3487 7
a3493 3
		if (lo_irelfn->r_offset == laddr + 6
		    && ELF32_R_TYPE (lo_irelfn->r_info) == (int) R_V850_LO16)
		  break;
d3600 5
a3604 2
		  irel->r_info =
		    ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);
d3636 5
a3640 2
		  irel->r_info =
			ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_9_PCREL);
a3752 1
#define ELF_MACHINE_ALT2			EM_V800 /* This is the value used by the GreenHills toolchain.  */
d3776 1
a3776 1
#define bfd_elf32_bfd_reloc_name_lookup	v850_elf_reloc_name_lookup
d3784 118
@


1.83
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d627 1
a627 1
      addend += insn & 0xfffe;;
@


1.82
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2099 1
a2099 1
					 rel, relend, howto, contents);
@


1.81
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d3 2
a4 1
   2006, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.
d2097 1
a2097 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.81.4.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2096 1
a2096 1
      if (sec != NULL && discarded_section (sec))
@


1.80
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
d483 1
a483 1
	  fprintf (stderr, _("FAILED to find previous HI16 reloc\n"));
@


1.80.2.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.
d483 1
a483 1
	  (*_bfd_error_handler) (_("FAILED to find previous HI16 reloc"));
@


1.79
log
@Add support for v850E2 and v850E2V3
@
text
@d2097 2
a2098 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.78
log
@fix set but unused variable warnings
@
text
@d34 5
a38 2
/* Sign-extend a 24-bit number.  */
#define SEXT24(x)	((((x) & 0xffffff) ^ 0x800000) - 0x800000)
d95 2
d98 3
a101 1
	case R_V850_HI16:
d103 1
d105 1
d109 2
d113 1
d147 1
d149 1
a149 1
	case R_V850_TDA_4_4_OFFSET:
a151 1
	case R_V850_TDA_7_7_OFFSET:
d330 2
a331 2
       movhi hi( fred + 0x123456), r0, r1
       movea lo( fred + 0x123456), r1, r1
d337 2
a338 2
       movhi hi( fred + 0x10ffff), r0, r1
       movea lo( fred + 0x10ffff), r1, r1
d347 2
a348 2
       movhi hi( fred - 1), r0, r1
       movea lo( fred - 1), r1, r1
d360 2
a361 2
      movhi hi( fred + 0x123456), r0, r1
      movea lo( fred + 0x123456), r1, r1
d381 2
a382 2
      movhi hi( fred + 0x10ffff), r0, r1
      movea lo( fred + 0x10ffff), r1, r1
d402 2
a403 2
     movhi hi( fred + 0xffff), r0, r1    [bit 15 of the offset is set]
     movea lo( fred + 0xffff), r1, r1
d416 2
a417 2
     movhi hi( fred + 0x7000), r0, r1    [bit 15 of the offset is clear]
     movea lo( fred + 0x7000), r1, r1
d431 2
a432 2
     movhi hi( fred + 0xffff), r0, r1     [bit 15 of the offset is set]
     movea lo( fred + 0xffff), r1, r1
d445 2
a446 2
     movhi hi( fred + 0x7000), r0, r1     [bit 15 of the offset is clear]
     movea lo( fred + 0x7000), r1, r1
d519 7
d539 24
d623 30
d667 1
d758 12
d781 2
a783 1
    case R_V850_SDA_16_16_SPLIT_OFFSET:
a798 16
    case R_V850_CALLT_6_7_OFFSET:
      insn = bfd_get_16 (abfd, address);
      addend += ((insn & 0x3f) << 1);

      saddend = (bfd_signed_vma) addend;

      if (saddend > 0x7e || saddend < 0)
	return bfd_reloc_overflow;

      if (addend & 1)
	return bfd_reloc_dangerous;

      insn &= 0xff80;
      insn |= (addend >> 1);
      break;

d887 2
a888 1
   in this array match the index of the entry in the array.  */
d908 3
a910 3
	 2,				/* Rightshift.  */
	 2,				/* Size (0 = byte, 1 = short, 2 = long).  */
	 26,				/* Bitsize.  */
d923 1
a923 1
	 2,				/* Rightshift.  */
d927 1
a927 1
	 7,				/* Bitpos.  */
d1236 1
d1239 12
a1250 12
         0,                     /* Rightshift.  */
         2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
         0,                     /* Bitsize.  */
         FALSE,                 /* PC_relative.  */
         0,                     /* Bitpos.  */
         complain_overflow_dont, /* Complain_on_overflow.  */
         NULL,                  /* Special_function.  */
         "R_V850_GNU_VTINHERIT", /* Name.  */
         FALSE,                 /* Partial_inplace.  */
         0,                     /* Src_mask.  */
         0,                     /* Dst_mask.  */
         FALSE),                /* PCrel_offset.  */
d1252 1
a1252 1
  /* GNU extension to record C++ vtable member usage */
d1254 12
a1265 12
         0,                     /* Rightshift.  */
         2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
         0,                     /* Bitsize.  */
         FALSE,                 /* PC_relative.  */
         0,                     /* Bitpos.  */
         complain_overflow_dont, /* Complain_on_overflow.  */
         _bfd_elf_rel_vtable_reloc_fn,  /* Special_function.  */
         "R_V850_GNU_VTENTRY",   /* Name.  */
         FALSE,                 /* Partial_inplace.  */
         0,                     /* Src_mask.  */
         0,                     /* Dst_mask.  */
         FALSE),                /* PCrel_offset.  */
d1270 12
a1281 12
       0,                     /* Rightshift.  */
       2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
       32,                    /* Bitsize.  */
       TRUE,                  /* PC_relative.  */
       0,                     /* Bitpos.  */
       complain_overflow_signed, /* Complain_on_overflow.  */
       v850_elf_ignore_reloc, /* Special_function.  */
       "R_V850_LONGCALL",     /* Name.  */
       FALSE,                 /* Partial_inplace.  */
       0,                     /* Src_mask.  */
       0,                     /* Dst_mask.  */
       TRUE),                 /* PCrel_offset.  */
d1286 12
a1297 12
       0,                     /* Rightshift.  */
       2,                     /* Size (0 = byte, 1 = short, 2 = long).  */
       32,                    /* Bitsize.  */
       TRUE,                  /* PC_relative.  */
       0,                     /* Bitpos.  */
       complain_overflow_signed, /* Complain_on_overflow.  */
       v850_elf_ignore_reloc, /* Special_function.  */
       "R_V850_LONGJUMP",     /* Name.  */
       FALSE,                 /* Partial_inplace.  */
       0,                     /* Src_mask.  */
       0,                     /* Dst_mask.  */
       TRUE),                 /* PCrel_offset.  */
d1300 13
a1312 13
       0,                     /* Rightshift.  */
       1,                     /* Size (0 = byte, 1 = short, 2 = long).  */
       0,                     /* Bitsize.  */
       FALSE,                 /* PC_relative.  */
       0,                     /* Bitpos.  */
       complain_overflow_unsigned, /* Complain_on_overflow.  */
       v850_elf_ignore_reloc, /* Special_function.  */
       "R_V850_ALIGN",        /* Name.  */
       FALSE,                 /* Partial_inplace.  */
       0,                     /* Src_mask.  */
       0,                     /* Dst_mask.  */
       TRUE),                 /* PCrel_offset.  */
  
d1342 335
d1691 10
a1700 10
  { BFD_RELOC_NONE,		           R_V850_NONE                   },
  { BFD_RELOC_V850_9_PCREL,	           R_V850_9_PCREL                },
  { BFD_RELOC_V850_22_PCREL,	           R_V850_22_PCREL               },
  { BFD_RELOC_HI16_S,		           R_V850_HI16_S                 },
  { BFD_RELOC_HI16,		           R_V850_HI16                   },
  { BFD_RELOC_LO16,		           R_V850_LO16                   },
  { BFD_RELOC_32,		           R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,		           R_V850_REL32                  },
  { BFD_RELOC_16,		           R_V850_16                     },
  { BFD_RELOC_8,		           R_V850_8                      },
d1721 22
a1742 1

d1849 23
d1878 1
a1878 1
      if (((value & 0xff000000) != 0x0) && ((value & 0xff000000) != 0xff000000))
d1881 2
a1882 2
      /* Only the bottom 24 bits of the PC are valid.  */
      value = SEXT24 (value);
d1885 1
a1885 1
    case R_V850_REL32:
d1891 2
d1896 1
a1938 1
    case R_V850_TDA_16_16_OFFSET:
d1942 1
d1979 1
d2225 6
d2249 2
d2314 1
d2316 1
a2316 1
	 Set the output binary to v850e.  */
d2318 4
d2323 14
a2336 1
	return TRUE;
d2338 4
a2341 2
      if ((in_flags & EF_V850_ARCH) == E_V850E_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E1_ARCH)
d2344 1
a2344 1
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E_ARCH);
d2366 1
a2366 1
  /* xgettext:c-format */
d2375 2
d2438 1
a2438 1
    switch (elf_elfsections(abfd)[indx]->sh_type)
d2535 1
a2535 1
    switch (elf_elfsections(abfd)[indx]->sh_type)
d2865 1
a2865 1
#define MOVHI	    	0x0640				/* 4byte */
d2867 1
a2867 1
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte */
d2869 1
a2869 1
#define MOVEA	    	0x0620				/* 2byte */
d2873 1
a2873 1
#define JARL_4	    	0x00040780				/* 4byte */
d2876 1
a2876 1
#define ADD_I       	0x0240					/* 2byte */
d2878 1
a2878 1
#define ADD_I5(insn)	((((insn) & 0x001f) << 11) >> 11)	/* 2byte */
d2880 1
a2880 1
#define JMP_R	    	0x0060					/* 2byte */
@


1.77
log
@        * elf32-v850.c (v850_elf_perform_relocation): Fix overflow
        handling of R_V850_HI16_S relocation.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a49 1
  bfd *dynobj;
a65 1
  dynobj = elf_hash_table (info)->dynobj;
a273 2
  hi16s_location *previous = NULL;
  hi16s_location *prev;
a281 1
	  previous = prev;
a283 2

      prev = entry;
@


1.76
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d553 1
a553 1
      if (addend > 0x7fff)
@


1.75
log
@update copyright dates
@
text
@d2191 1
a2191 1
  int index;
d2339 1
a2339 1
  for (index = 0; esym < esymend; esym ++, index ++)
d2344 1
a2344 1
      sym_hash = elf_sym_hashes (abfd) [index];
@


1.74
log
@include/elf/
	* ppc.h (R_PPC_RELAX*): Define as enum.
bfd/
	* elf32-ppc.c (ppc_elf_check_relocs): Handle R_PPC_RELAX* in switch.
	* elf32-v850.c (v850_elf_relocate_section): Warning fix.
@
text
@d3 1
a3 1
   2006, 2007, 2008  Free Software Foundation, Inc.
@


1.73
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d1683 1
a1683 1
	  switch (r)
@


1.72
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d2098 1
a2098 1
static bfd_boolean
d2125 1
a2125 1
  return TRUE;
@


1.71
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
a54 1
  asection *sreloc;
a69 1
  sreloc = NULL;
@


1.70
log
@Switch sources over to use the GPL version 3
@
text
@d119 3
a121 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.69
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
@


1.68
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d25 1
a26 1
#include "sysdep.h"
@


1.67
log
@duh. commit correct version of patch.
@
text
@d1342 16
d3092 1
@


1.66
log
@include/elf/
	* v850.h (V850_OTHER_TDA_BYTE): Delete.
	(V850_OTHER_SDA, V850_OTHER_ZDA, V850_OTHER_TDA): Assign bits
	that don't clash with visibility bits.
bfd/
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Clean out
	V850_OTHER_* bits.
@
text
@d2086 1
a2086 1
				  struct elf_link_hash_entry *h)
d2104 3
a2106 4
     
  if (h != NULL)
    h->other &= ~(V850_OTHER_SDA | V850_OTHER_ZDA | V850_OTHER_TDA
		  | V850_OTHER_ERROR);
@


1.65
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d2086 1
a2086 1
				  struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
d2102 7
@


1.64
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
a1569 3
  if (info->relocatable)
    return TRUE;

a1597 1
      /* This is a final link.  */
d1630 14
@


1.63
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@a1713 10
static bfd_boolean
v850_elf_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			asection *sec ATTRIBUTE_UNUSED,
			const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* No got and plt entries for v850-elf.  */
  return TRUE;
}

d1716 1
a1716 1
		       struct bfd_link_info *info ATTRIBUTE_UNUSED,
d1722 1
a1722 2
    {
      switch (ELF32_R_TYPE (rel->r_info))
d1726 2
a1727 19
        break;

      default:
        switch (h->root.type)
          {
          case bfd_link_hash_defined:
          case bfd_link_hash_defweak:
            return h->root.u.def.section;

          case bfd_link_hash_common:
            return h->root.u.c.p->section;

	  default:
	    break;
          }
       }
     }
   else
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1729 1
a1729 1
  return NULL;
a3052 1
#define elf_backend_gc_sweep_hook               v850_elf_gc_sweep_hook
@


1.62
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d3031 26
a3056 27
  { ".call_table_data", 16,  0, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_WRITE) },
  { ".call_table_text", 16,  0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_EXECINSTR) },
  { ".rosdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_GPREL) },
  { ".rozdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_R0REL) },
  { ".sbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".scommon",          8, -2, SHT_V850_SCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".sdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".tbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".tcommon",          8, -2, SHT_V850_TCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".tdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".zbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zcommon",          8, -2, SHT_V850_ZCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { NULL,        0, 0, 0,            0 }
@


1.61
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d36 2
@


1.60
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a3056 18

static const struct bfd_elf_special_section *
v850_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					v850_elf_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}
d3081 1
a3081 1
#define elf_backend_get_sec_type_attr		v850_elf_get_sec_type_attr
@


1.59
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d3027 1
a3027 1
static struct bfd_elf_special_section const v850_elf_special_sections[] =
d3061 1
a3061 1
  const struct bfd_elf_special_section const *ssect;
@


1.58
log
@Update function declarations to ISO C90 formatting
@
text
@d3027 1
a3027 2
static struct bfd_elf_special_section const
  v850_special_sections_c[]=
a3032 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  v850_special_sections_r[]=
{
a3036 8
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  v850_special_sections_s[]=
{
  { ".sdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
d3041 2
a3042 8
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  v850_special_sections_t[]=
{
  { ".tdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
d3047 2
a3048 8
  { NULL,               0,   0, 0,                0 }
};

static struct bfd_elf_special_section const
  v850_special_sections_z[]=
{
  { ".zdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
d3053 2
d3058 2
a3059 2
static struct bfd_elf_special_section const *
  v850_elf_special_sections[27] =
d3061 14
a3074 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  v850_special_sections_c,	/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  v850_special_sections_r,	/* 'r' */
  v850_special_sections_s,	/* 's' */
  v850_special_sections_t,	/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  v850_special_sections_z,	/* 'z' */
  NULL				/* other */
};
d3099 1
a3099 1
#define elf_backend_special_sections		v850_elf_special_sections
@


1.57
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
a35 612
static reloc_howto_type *v850_elf_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void v850_elf_info_to_howto_rel
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static void v850_elf_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_reloc_status_type v850_elf_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean v850_elf_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean v850_elf_relocate_section
  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_reloc_status_type v850_elf_perform_relocation
  PARAMS ((bfd *, unsigned int, bfd_vma, bfd_byte *));
static bfd_boolean v850_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
static void remember_hi16s_reloc
  PARAMS ((bfd *, bfd_vma, bfd_byte *));
static bfd_byte * find_remembered_hi16s_reloc
  PARAMS ((bfd_vma, bfd_boolean *));
static bfd_reloc_status_type v850_elf_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *, bfd_vma,
	   bfd_vma, bfd_vma, struct bfd_link_info *, asection *, int));
static bfd_boolean v850_elf_object_p
  PARAMS ((bfd *));
static bfd_boolean v850_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void v850_elf_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean v850_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean v850_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean v850_elf_print_private_bfd_data
  PARAMS ((bfd *, PTR));
static bfd_boolean v850_elf_section_from_bfd_section
  PARAMS ((bfd *, asection *, int *));
static void v850_elf_symbol_processing
  PARAMS ((bfd *, asymbol *));
static bfd_boolean v850_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static bfd_boolean v850_elf_link_output_symbol_hook
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
static bfd_boolean v850_elf_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection * v850_elf_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *,
	   Elf_Internal_Rela *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_reloc_status_type v850_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean v850_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int));
static bfd_boolean v850_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));

/* Note: It is REQUIRED that the 'type' value of each entry
   in this array match the index of the entry in the array.  */
static reloc_howto_type v850_elf_howto_table[] =
{
  /* This reloc does nothing.  */
  HOWTO (R_V850_NONE,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,		/* special_function */
	 "R_V850_NONE",			/* name */
	 FALSE,				/* partial_inplace */
	 0,				/* src_mask */
	 0,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* A PC relative 9 bit branch.  */
  HOWTO (R_V850_9_PCREL,		/* type */
	 2,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 26,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_9_PCREL",		/* name */
	 FALSE,				/* partial_inplace */
	 0x00ffffff,			/* src_mask */
	 0x00ffffff,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  /* A PC relative 22 bit branch.  */
  HOWTO (R_V850_22_PCREL,		/* type */
	 2,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 22,				/* bitsize */
	 TRUE,				/* pc_relative */
	 7,				/* bitpos */
	 complain_overflow_signed,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_22_PCREL",		/* name */
	 FALSE,				/* partial_inplace */
	 0x07ffff80,			/* src_mask */
	 0x07ffff80,			/* dst_mask */
	 TRUE),				/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_V850_HI16_S,			/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_HI16_S",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_V850_HI16,			/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_HI16",			/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_V850_LO16,			/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_LO16",			/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* Simple 32bit reloc.  */
  HOWTO (R_V850_ABS32,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_ABS32",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* Simple 16bit reloc.  */
  HOWTO (R_V850_16,			/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,		/* special_function */
	 "R_V850_16",			/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* Simple 8bit reloc.	 */
  HOWTO (R_V850_8,			/* type */
	 0,				/* rightshift */
	 0,				/* size (0 = byte, 1 = short, 2 = long) */
	 8,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,		/* special_function */
	 "R_V850_8",			/* name */
	 FALSE,				/* partial_inplace */
	 0xff,				/* src_mask */
	 0xff,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_16_16_OFFSET,	/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_SDA_16_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 15 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_15_16_OFFSET,	/* type */
	 1,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 1,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_SDA_15_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xfffe,			/* src_mask */
	 0xfffe,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_16_16_OFFSET,	/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_ZDA_16_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 15 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_15_16_OFFSET,	/* type */
	 1,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 1,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_ZDA_15_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xfffe,			/* src_mask */
	 0xfffe,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 6 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_6_8_OFFSET,		/* type */
	 2,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 8,				/* bitsize */
	 FALSE,				/* pc_relative */
	 1,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_6_8_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x7e,				/* src_mask */
	 0x7e,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 8 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_7_8_OFFSET,		/* type */
	 1,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 8,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_7_8_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x7f,				/* src_mask */
	 0x7f,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 7 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_7_7_OFFSET,		/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 7,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_7_7_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x7f,				/* src_mask */
	 0x7f,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the tiny data area pointer!  */
  HOWTO (R_V850_TDA_16_16_OFFSET,	/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_16_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xfff,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 5 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_4_5_OFFSET,		/* type */
	 1,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 5,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_4_5_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x0f,				/* src_mask */
	 0x0f,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 4 bit offset from the tiny data area pointer.  */
  HOWTO (R_V850_TDA_4_4_OFFSET,		/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 4,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_TDA_4_4_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x0f,				/* src_mask */
	 0x0f,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the short data area pointer.  */
  HOWTO (R_V850_SDA_16_16_SPLIT_OFFSET,	/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_SDA_16_16_SPLIT_OFFSET",/* name */
	 FALSE,				/* partial_inplace */
	 0xfffe0020,			/* src_mask */
	 0xfffe0020,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the zero data area pointer.  */
  HOWTO (R_V850_ZDA_16_16_SPLIT_OFFSET,	/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_ZDA_16_16_SPLIT_OFFSET",/* name */
	 FALSE,				/* partial_inplace */
	 0xfffe0020,			/* src_mask */
	 0xfffe0020,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 6 bit offset from the call table base pointer.  */
  HOWTO (R_V850_CALLT_6_7_OFFSET,	/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 7,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_CALLT_6_7_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0x3f,				/* src_mask */
	 0x3f,				/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* 16 bit offset from the call table base pointer.  */
  HOWTO (R_V850_CALLT_16_16_OFFSET,	/* type */
	 0,				/* rightshift */
	 1,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_CALLT_16_16_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xffff,			/* src_mask */
	 0xffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_V850_GNU_VTINHERIT, /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         NULL,                  /* special_function */
         "R_V850_GNU_VTINHERIT", /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_V850_GNU_VTENTRY,     /* type */
         0,                     /* rightshift */
         2,                     /* size (0 = byte, 1 = short, 2 = long) */
         0,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
         "R_V850_GNU_VTENTRY",   /* name */
         FALSE,                 /* partial_inplace */
         0,                     /* src_mask */
         0,                     /* dst_mask */
         FALSE),                /* pcrel_offset */

  /* Indicates a .longcall pseudo-op.  The compiler will generate a .longcall
     pseudo-op when it finds a function call which can be relaxed.  */
  HOWTO (R_V850_LONGCALL,     /* type */
       0,                     /* rightshift */
       2,                     /* size (0 = byte, 1 = short, 2 = long) */
       32,                    /* bitsize */
       TRUE,                  /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_signed, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_LONGCALL",     /* name */
       FALSE,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       TRUE),                 /* pcrel_offset */

  /* Indicates a .longjump pseudo-op.  The compiler will generate a
     .longjump pseudo-op when it finds a branch which can be relaxed.  */
  HOWTO (R_V850_LONGJUMP,     /* type */
       0,                     /* rightshift */
       2,                     /* size (0 = byte, 1 = short, 2 = long) */
       32,                    /* bitsize */
       TRUE,                  /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_signed, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_LONGJUMP",     /* name */
       FALSE,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       TRUE),                 /* pcrel_offset */

  HOWTO (R_V850_ALIGN,        /* type */
       0,                     /* rightshift */
       1,                     /* size (0 = byte, 1 = short, 2 = long) */
       0,                     /* bitsize */
       FALSE,                 /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_unsigned, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_ALIGN",        /* name */
       FALSE,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       TRUE),                 /* pcrel_offset */
  
  /* Simple pc-relative 32bit reloc.  */
  HOWTO (R_V850_REL32,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_REL32",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */

  /* An ld.bu version of R_V850_LO16.  */
  HOWTO (R_V850_LO16_SPLIT_OFFSET,	/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 16,				/* bitsize */
	 FALSE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_LO16_SPLIT_OFFSET",	/* name */
	 FALSE,				/* partial_inplace */
	 0xfffe0020,			/* src_mask */
	 0xfffe0020,			/* dst_mask */
	 FALSE),			/* pcrel_offset */
};

/* Map BFD reloc types to V850 ELF reloc types.  */

struct v850_elf_reloc_map
{
  /* BFD_RELOC_V850_CALLT_16_16_OFFSET is 258, which will not fix in an
     unsigned char.  */
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int elf_reloc_val;
};

static const struct v850_elf_reloc_map v850_elf_reloc_map[] =
{
  { BFD_RELOC_NONE,		           R_V850_NONE                   },
  { BFD_RELOC_V850_9_PCREL,	           R_V850_9_PCREL                },
  { BFD_RELOC_V850_22_PCREL,	           R_V850_22_PCREL               },
  { BFD_RELOC_HI16_S,		           R_V850_HI16_S                 },
  { BFD_RELOC_HI16,		           R_V850_HI16                   },
  { BFD_RELOC_LO16,		           R_V850_LO16                   },
  { BFD_RELOC_32,		           R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,		           R_V850_REL32                  },
  { BFD_RELOC_16,		           R_V850_16                     },
  { BFD_RELOC_8,		           R_V850_8                      },
  { BFD_RELOC_V850_SDA_16_16_OFFSET,       R_V850_SDA_16_16_OFFSET       },
  { BFD_RELOC_V850_SDA_15_16_OFFSET,       R_V850_SDA_15_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_16_16_OFFSET,       R_V850_ZDA_16_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_15_16_OFFSET,       R_V850_ZDA_15_16_OFFSET       },
  { BFD_RELOC_V850_TDA_6_8_OFFSET,         R_V850_TDA_6_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_8_OFFSET,         R_V850_TDA_7_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_7_OFFSET,         R_V850_TDA_7_7_OFFSET         },
  { BFD_RELOC_V850_TDA_16_16_OFFSET,       R_V850_TDA_16_16_OFFSET       },
  { BFD_RELOC_V850_TDA_4_5_OFFSET,         R_V850_TDA_4_5_OFFSET         },
  { BFD_RELOC_V850_TDA_4_4_OFFSET,         R_V850_TDA_4_4_OFFSET         },
  { BFD_RELOC_V850_LO16_SPLIT_OFFSET,      R_V850_LO16_SPLIT_OFFSET      },
  { BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET, R_V850_SDA_16_16_SPLIT_OFFSET },
  { BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET, R_V850_ZDA_16_16_SPLIT_OFFSET },
  { BFD_RELOC_V850_CALLT_6_7_OFFSET,       R_V850_CALLT_6_7_OFFSET       },
  { BFD_RELOC_V850_CALLT_16_16_OFFSET,     R_V850_CALLT_16_16_OFFSET     },
  { BFD_RELOC_VTABLE_INHERIT,              R_V850_GNU_VTINHERIT          },
  { BFD_RELOC_VTABLE_ENTRY,                R_V850_GNU_VTENTRY            },
  { BFD_RELOC_V850_LONGCALL,               R_V850_LONGCALL               },
  { BFD_RELOC_V850_LONGJUMP,               R_V850_LONGJUMP               },
  { BFD_RELOC_V850_ALIGN,                  R_V850_ALIGN                  },

};

/* Map a bfd relocation into the appropriate howto structure.  */

static reloc_howto_type *
v850_elf_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
{
  unsigned int i;

  for (i = ARRAY_SIZE (v850_elf_reloc_map); i --;)
    if (v850_elf_reloc_map[i].bfd_reloc_val == code)
      {
	unsigned int elf_reloc_val = v850_elf_reloc_map[i].elf_reloc_val;

	BFD_ASSERT (v850_elf_howto_table[elf_reloc_val].type == elf_reloc_val);

	return v850_elf_howto_table + elf_reloc_val;
      }

  return NULL;
}

/* Set the howto pointer for an V850 ELF reloc.  */

static void
v850_elf_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_V850_max);
  cache_ptr->howto = &v850_elf_howto_table[r_type];
}

/* Set the howto pointer for a V850 ELF reloc (type RELA).  */
static void
v850_elf_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf_Internal_Rela *dst;
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_V850_max);
  cache_ptr->howto = &v850_elf_howto_table[r_type];
}

d41 4
a44 5
v850_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d55 1
a55 1
  const char *common = (const char *)0;
d225 5
a229 5
  bfd_vma addend;
  bfd_byte *address;
  unsigned long counter;
  bfd_boolean found;
  struct hi16s_location *next;
d233 3
a235 3
static hi16s_location *previous_hi16s;
static hi16s_location *free_hi16s;
static unsigned long hi16s_counter;
d238 1
a238 4
remember_hi16s_reloc (abfd, addend, address)
     bfd *abfd;
     bfd_vma addend;
     bfd_byte *address;
d245 1
a245 1
    free_hi16s = (hi16s_location *) bfd_zalloc (abfd, amt);
d260 1
a260 1
      /* XXX - Assume that all counter entries differ only in their low 16 bits.  */
a265 2

  return;
d269 1
a269 3
find_remembered_hi16s_reloc (addend, already_found)
     bfd_vma addend;
     bfd_boolean *already_found;
d454 1
d492 4
a495 5
v850_elf_perform_relocation (abfd, r_type, addend, address)
     bfd *abfd;
     unsigned int r_type;
     bfd_vma addend;
     bfd_byte *address;
a503 1
      /* fprintf (stderr, "reloc type %d not SUPPORTED\n", r_type ); */
a584 2

      /* drop through */
d745 7
a751 8
v850_elf_reloc (abfd, reloc, symbol, data, isection, obfd, err)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *isection;
     bfd *obfd;
     char **err ATTRIBUTE_UNUSED;
d760 1
a760 1
  if (obfd != (bfd *) NULL
d806 7
a812 9
v850_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d819 549
d1370 1
a1370 3
v850_elf_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d1384 11
a1394 14
v850_elf_final_link_relocate (howto, input_bfd, output_bfd,
			      input_section, contents, offset, value,
			      addend, info, sym_sec, is_local)
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     int is_local ATTRIBUTE_UNUSED;
d1417 1
a1417 1
      /* Only the bottom 24 bits of the PC are valid */
d1457 1
a1457 1
	if (h == (struct bfd_link_hash_entry *) NULL
d1482 1
a1482 1
	if (h == (struct bfd_link_hash_entry *) NULL
d1501 1
a1501 1
	if (h == (struct bfd_link_hash_entry *) NULL
d1522 1
a1522 1
	if (h == (struct bfd_link_hash_entry *) NULL
d1554 8
a1561 10
v850_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1614 3
a1616 3
	  /* Note - this check is delayed until now as it is possible and valid
	     to have a file without any symbols but with relocs that can be
	     processed.  */
d1642 1
a1642 1
	  const char * msg = (const char *)0;
d1713 4
a1716 5
v850_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d1723 5
a1727 6
v850_elf_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
       struct bfd_link_info *info ATTRIBUTE_UNUSED;
       Elf_Internal_Rela *rel;
       struct elf_link_hash_entry *h;
       Elf_Internal_Sym *sym;
d1761 1
a1761 2
v850_elf_object_p (abfd)
     bfd *abfd;
d1782 2
a1783 3
v850_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1790 3
a1792 3
    case bfd_mach_v850:  val = E_V850_ARCH; break;
    case bfd_mach_v850e: val = E_V850E_ARCH; break;
    case bfd_mach_v850e1: val = E_V850E1_ARCH;  break;
d1802 1
a1802 3
v850_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d1814 1
d1816 1
a1816 3
v850_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d1880 1
a1880 3
v850_elf_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d1895 1
a1895 1
    case E_V850E_ARCH:  fprintf (file, _("v850e architecture")); break;
d1925 3
a1927 4
v850_elf_section_from_bfd_section (abfd, sec, retval)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
d1944 1
a1944 3
v850_elf_symbol_processing (abfd, asym)
     bfd *abfd;
     asymbol *asym;
d2038 7
a2044 8
v850_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d2098 5
a2102 6
v850_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
d2153 3
a2155 4
v850_elf_fake_sections (abfd, hdr, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr;
     asection *sec;
d2157 1
a2157 1
  register const char * name;
d2162 1
a2162 3
    {
      hdr->sh_type = SHT_V850_SCOMMON;
    }
d2164 1
a2164 3
    {
      hdr->sh_type = SHT_V850_TCOMMON;
    }
d2174 5
a2178 6
v850_elf_relax_delete_bytes (abfd, sec, addr, toaddr, count)
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     bfd_vma toaddr;
     int count;
d2399 4
a2402 5
v850_elf_relax_section (abfd, sec, link_info, again)
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d2426 1
a2426 2
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
d2508 1
a2508 1
		  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
@


1.56
log
@* elf32-v850.c (ELF_MACHINE_ALT2): Define so that binaries produced by the
  GreenHills toolchain can be assimilated.
@
text
@d692 6
a697 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.55
log
@(v850_elf_relocate_section): Move code to test for the presence of a symbol
table to just before the symbol table is actually used.
@
text
@d3220 1
@


1.54
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@a1651 9
  if (sym_hashes == NULL)
    {
      info->callbacks->warning
	(info, "no hash table available",
	 NULL, input_bfd, input_section, (bfd_vma) 0);

      return FALSE;
    }

d1692 12
@


1.53
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3124 22
a3145 1
static struct bfd_elf_special_section const v850_elf_special_sections[]=
a3148 2
  { ".rosdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_GPREL) },
d3153 6
d3165 6
a3172 2
  { ".rozdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_R0REL) },
d3177 33
a3209 5
  { ".call_table_data", 16,  0, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_WRITE) },
  { ".call_table_text", 16,  0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_EXECINSTR) },
  { NULL,               0,   0, 0,                0 }
@


1.52
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.51
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.50
log
@update copyright dates
@
text
@a80 2
static bfd_boolean v850_elf_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d2211 4
a2214 4
v850_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d2220 1
a2220 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.49
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.48
log
@include/elf/
	* v850.h (R_V850_LO16_SPLIT_OFFSET): New reloc.

bfd/
	* reloc.c (BFD_RELOC_V850_LO16_SPLIT_OFFSET): New bfd_reloc_code_type.
	* elf32-v850.c (v850_elf_howto_table): Add entry for
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_reloc_map): Map it to BFD_RELOC_V850_LO16_SPLIT_OFFSET.
	(v850_elf_perform_lo16_relocation): New function, extracted from...
	(v850_elf_perform_relocation): ...here.  Use it to handle
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_check_relocs, v850_elf_final_link_relocate): Handle
	R_V850_LO16_SPLIT_OFFSET.
	* libbfd.h, bfd-in2.h: Regenerate.

gas/
	* config/tc-v850.c (handle_lo16): New function.
	(v850_reloc_prefix): Use it to check lo().
	(md_assemble, md_apply_fix3): Handle BFD_RELOC_V850_LO16_SPLIT_OFFSET.

gas/testsuite/
	* gas/v850/split-lo16.{s,d}: New test.
	* gas/v850/v850.exp: Run it.

ld/testsuite/
	* ld-v850: New directory.
@
text
@a1417 24
#if 0 /* Since this reloc is going to be processed later on, we should
	 not make it pc-relative here.  To test this, try assembling and
	 linking this program:

	 	.text
		.globl _start
		nop
	_start:
        	jr foo

	        .section ".foo","ax"
		nop
	foo:
        	nop      */
  if (reloc->howto->pc_relative)
    {
      /* Here the variable relocation holds the final address of the
	 symbol we are relocating against, plus any addend.  */
      relocation -= isection->output_section->vma + isection->output_offset;

      /* Deal with pcrel_offset.  */
      relocation -= reloc->address;
    }
#endif
a1697 11
#if 0
	  {
	    char * name;

	    name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link, sym->st_name);
	    name = (name == NULL) ? "<none>" : name;
	    fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
		     sec->name, name, sym->st_name,
		     sec->output_section->vma, sec->output_offset, sym->st_value, rel->r_addend);
	  }
#endif
@


1.47
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d536 15
d585 1
d706 1
d922 181
d1114 1
d1174 4
a1177 177
      /* Calculate the sum of the value stored in the instruction and the
	 addend and check for overflow from the low 16 bits into the high
	 16 bits.  The assembler has already done some of this:  If the
	 value stored in the instruction has its 15th bit set, (counting
	 from zero) then the assembler will have added 1 to the value
	 stored in the associated HI16S reloc.  So for example, these
	 relocations:

	     movhi hi( fred ), r0, r1
	     movea lo( fred ), r1, r1

	 will store 0 in the value fields for the MOVHI and MOVEA instructions
	 and addend will be the address of fred, but for these instructions:

	     movhi hi( fred + 0x123456), r0, r1
	     movea lo( fred + 0x123456), r1, r1

	 the value stored in the MOVHI instruction will be 0x12 and the value
	 stored in the MOVEA instruction will be 0x3456.  If however the
	 instructions were:

	     movhi hi( fred + 0x10ffff), r0, r1
	     movea lo( fred + 0x10ffff), r1, r1

	 then the value stored in the MOVHI instruction would be 0x11 (not
	 0x10) and the value stored in the MOVEA instruction would be 0xffff.
	 Thus (assuming for the moment that the addend is 0), at run time the
	 MOVHI instruction loads 0x110000 into r1, then the MOVEA instruction
	 adds 0xffffffff (sign extension!) producing 0x10ffff.  Similarly if
	 the instructions were:

	     movhi hi( fred - 1), r0, r1
	     movea lo( fred - 1), r1, r1

	 then 0 is stored in the MOVHI instruction and -1 is stored in the
	 MOVEA instruction.

	 Overflow can occur if the addition of the value stored in the
	 instruction plus the addend sets the 15th bit when before it was clear.
	 This is because the 15th bit will be sign extended into the high part,
	 thus reducing its value by one, but since the 15th bit was originally
	 clear, the assembler will not have added 1 to the previous HI16S reloc
	 to compensate for this effect.  For example:

	    movhi hi( fred + 0x123456), r0, r1
	    movea lo( fred + 0x123456), r1, r1

	 The value stored in HI16S reloc is 0x12, the value stored in the LO16
	 reloc is 0x3456.  If we assume that the address of fred is 0x00007000
	 then the relocations become:

	   HI16S: 0x0012 + (0x00007000 >> 16)    = 0x12
	   LO16:  0x3456 + (0x00007000 & 0xffff) = 0xa456

	 but when the instructions are executed, the MOVEA instruction's value
	 is signed extended, so the sum becomes:

	      0x00120000
	    + 0xffffa456
	    ------------
	      0x0011a456    but 'fred + 0x123456' = 0x0012a456

	 Note that if the 15th bit was set in the value stored in the LO16
	 reloc, then we do not have to do anything:

	    movhi hi( fred + 0x10ffff), r0, r1
	    movea lo( fred + 0x10ffff), r1, r1

	    HI16S:  0x0011 + (0x00007000 >> 16)    = 0x11
	    LO16:   0xffff + (0x00007000 & 0xffff) = 0x6fff

	      0x00110000
	    + 0x00006fff
	    ------------
	      0x00116fff  = fred + 0x10ffff = 0x7000 + 0x10ffff

	 Overflow can also occur if the computation carries into the 16th bit
	 and it also results in the 15th bit having the same value as the 15th
	 bit of the original value.   What happens is that the HI16S reloc
	 will have already examined the 15th bit of the original value and
	 added 1 to the high part if the bit is set.  This compensates for the
	 sign extension of 15th bit of the result of the computation.  But now
	 there is a carry into the 16th bit, and this has not been allowed for.

	 So, for example if fred is at address 0xf000:

	   movhi hi( fred + 0xffff), r0, r1    [bit 15 of the offset is set]
	   movea lo( fred + 0xffff), r1, r1

	   HI16S: 0x0001 + (0x0000f000 >> 16)    = 0x0001
	   LO16:  0xffff + (0x0000f000 & 0xffff) = 0xefff   (carry into bit 16 is lost)

	     0x00010000
	   + 0xffffefff
	   ------------
	     0x0000efff   but 'fred + 0xffff' = 0x0001efff

	 Similarly, if the 15th bit remains clear, but overflow occurs into
	 the 16th bit then (assuming the address of fred is 0xf000):

	   movhi hi( fred + 0x7000), r0, r1    [bit 15 of the offset is clear]
	   movea lo( fred + 0x7000), r1, r1

	   HI16S: 0x0000 + (0x0000f000 >> 16)    = 0x0000
	   LO16:  0x7000 + (0x0000f000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)

	     0x00000000
	   + 0x00006fff
	   ------------
	     0x00006fff   but 'fred + 0x7000' = 0x00016fff

	 Note - there is no need to change anything if a carry occurs, and the
	 15th bit changes its value from being set to being clear, as the HI16S
	 reloc will have already added in 1 to the high part for us:

	   movhi hi( fred + 0xffff), r0, r1     [bit 15 of the offset is set]
	   movea lo( fred + 0xffff), r1, r1

	   HI16S: 0x0001 + (0x00007000 >> 16)
	   LO16:  0xffff + (0x00007000 & 0xffff) = 0x6fff  (carry into bit 16 is lost)

	     0x00010000
	   + 0x00006fff   (bit 15 not set, so the top half is zero)
	   ------------
	     0x00016fff   which is right (assuming that fred is at 0x7000)

	 but if the 15th bit goes from being clear to being set, then we must
	 once again handle overflow:

	   movhi hi( fred + 0x7000), r0, r1     [bit 15 of the offset is clear]
	   movea lo( fred + 0x7000), r1, r1

	   HI16S: 0x0000 + (0x0000ffff >> 16)
	   LO16:  0x7000 + (0x0000ffff & 0xffff) = 0x6fff  (carry into bit 16)

	     0x00000000
	   + 0x00006fff   (bit 15 not set, so the top half is zero)
	   ------------
	     0x00006fff   which is wrong (assuming that fred is at 0xffff).  */
      {
	long result;

	insn   = bfd_get_16 (abfd, address);
	result = insn + addend;

#define BIT15_SET(x) ((x) & 0x8000)
#define OVERFLOWS(a,i) ((((a) & 0xffff) + (i)) > 0xffff)

	if ((BIT15_SET (result) && ! BIT15_SET (addend))
	    || (OVERFLOWS (addend, insn)
		&& ((! BIT15_SET (insn)) || (BIT15_SET (addend)))))
	  {
	    bfd_boolean already_updated;
	    bfd_byte *hi16s_address = find_remembered_hi16s_reloc
	      (addend, & already_updated);

	    /* Amend the matching HI16_S relocation.  */
	    if (hi16s_address != NULL)
	      {
		if (! already_updated)
		  {
		    insn = bfd_get_16 (abfd, hi16s_address);
		    insn += 1;
		    bfd_put_16 (abfd, (bfd_vma) insn, hi16s_address);
		  }
	      }
	    else
	      {
		fprintf (stderr, _("FAILED to find previous HI16 reloc\n"));
		return bfd_reloc_overflow;
	      }
	  }

	/* Do not complain if value has top bit set, as this has been anticipated.  */
	insn = result & 0xffff;
	break;
      }
d1307 11
d1532 1
@


1.46
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1732 3
a1734 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.45
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d659 2
a660 3
  fprintf (stderr, "v850_elf_check_relocs called for section %s in %s\n",
	   bfd_get_section_name (abfd, sec),
	   bfd_archive_filename (abfd));
d1950 2
a1951 2
      _bfd_error_handler (_("%s: Architecture mismatch with previous modules"),
			  bfd_archive_filename (ibfd));
@


1.44
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1336 1
  bfd_size_type sz;
d1362 1
a1362 2
  sz = isection->rawsize ? isection->rawsize : isection->size;
  if (reloc->address > sz)
@


1.43
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d1337 1
d1363 2
a1364 1
  if (reloc->address > isection->_cooked_size)
a2519 5
  /* If this is the first time we have been called
     for this section, initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

d2530 1
a2530 1
  while (addr < sec->_cooked_size)
d2532 1
a2532 1
      toaddr = sec->_cooked_size;
d2606 1
a2606 6
		  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
		  if (contents == NULL)
		    goto error_return;

		  if (! bfd_get_section_contents (abfd, sec, contents,
						  (file_ptr) 0, sec->_raw_size))
d2628 1
a2628 1
	      if (laddr + 16 <= (bfd_vma) sec->_raw_size)
d2857 1
a2857 1
	      if (laddr + 10 <= (bfd_vma) sec->_raw_size)
d3099 2
a3100 2
	       sec->_cooked_size,
	       sec->_cooked_size - align_pad_size);
d3102 1
a3102 1
      sec->_cooked_size -= align_pad_size;
@


1.42
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d702 1
a702 1
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d709 1
a709 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.41
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d76 1
a76 1
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
d2127 1
a2127 1
     const Elf_Internal_Sym *sym;
@


1.40
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1701 4
a1704 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.39
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d1699 1
a1699 1
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1701 3
a1703 35
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
#if 0
	      fprintf (stderr, "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n",
		       sec->name, h->root.root.string, h->root.u.def.value, sec->output_section->vma, sec->output_offset, relocation);
#endif
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
#if 0
	      fprintf (stderr, "undefined: sec: %s, name: %s\n",
		       sec->name, h->root.root.string);
#endif
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
#if 0
	      fprintf (stderr, "unknown: name: %s\n", h->root.root.string);
#endif
	      relocation = 0;
	    }
@


1.39.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d76 1
a76 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d702 1
a702 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d709 1
a709 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1699 1
a1699 1
	  bfd_boolean unresolved_reloc, warned;
d1701 35
a1735 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2158 1
a2158 1
     Elf_Internal_Sym *sym;
@


1.39.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d76 1
a76 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Sym *,
d1699 1
a1699 1
	  bfd_boolean unresolved_reloc, warned;
d1701 35
a1735 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2158 1
a2158 1
     Elf_Internal_Sym *sym;
@


1.39.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d702 1
a702 1
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d709 1
a709 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.39.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d659 3
a661 2
  _bfd_error_handler ("v850_elf_check_relocs called for section %A in %B",
		      sec, abfd);
d1362 1
a1362 1
  if (reloc->address > bfd_get_section_limit (abfd, isection))
d1951 2
a1952 2
      _bfd_error_handler (_("%B: Architecture mismatch with previous modules"),
			  ibfd);
d2518 5
d2533 1
a2533 1
  while (addr < sec->size)
d2535 1
a2535 1
      toaddr = sec->size;
d2609 6
a2614 1
		  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d2636 1
a2636 1
	      if (laddr + 16 <= (bfd_vma) sec->size)
d2865 1
a2865 1
	      if (laddr + 10 <= (bfd_vma) sec->size)
d3107 2
a3108 2
	       sec->size,
	       sec->size - align_pad_size);
d3110 1
a3110 1
      sec->size -= align_pad_size;
@


1.39.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1699 1
a1699 1
	  bfd_boolean unresolved_reloc, warned;
d1701 35
a1735 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.38
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d79 2
a80 2
  PARAMS ((bfd *, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *));
d2216 1
a2216 2
v850_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
d2221 1
@


1.37
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d896 1
a896 1
  /* Remeber if this entry has already been used before.  */
d907 1
a907 1
   allowed to do its  stuff instead.  At least for most of the relocs, anwyay.  */
d1365 1
a1365 1
  /* Work out which section the relocation is targetted at and the
@


1.36
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d1684 1
a1684 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.35
log
@Add binutils support for v850e1 processor
@
text
@d3166 27
a3192 28
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".rosdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_V850_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".scommon",		0,	NULL,	0,
    SHT_V850_SCOMMON, 	SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".tdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_EPREL },
  { ".tbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_V850_EPREL },
  { ".tcommon",		0,	NULL,	0,
    SHT_V850_TCOMMON,	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".zdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".rozdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_V850_R0REL },
  { ".zbss",		0,	NULL,	0,
    SHT_NOBITS,	  	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".zcommon",		0,	NULL,	0,
    SHT_V850_ZCOMMON, 	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".call_table_data",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".call_table_text",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_EXECINSTR },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.34
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d1880 3
d1901 1
d1967 18
a1984 2
    _bfd_error_handler (_("%s: Architecture mismatch with previous modules"),
			bfd_archive_filename (ibfd));
d2010 1
@


1.33
log
@Correct spelling of "relocatable".
@
text
@d3142 32
d3197 1
@


1.32
log
@Add pc-relative 32-bit reloc to v850 port.  Fixes ld-elf/merge test failure.
@
text
@d655 1
a655 1
  if (info->relocateable)
d1635 1
a1635 1
  if (info->relocateable)
d2523 1
a2523 1
  if (link_info->relocateable
@


1.31
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d192 1
a192 1
  HOWTO (R_V850_32,			/* type */
d200 1
a200 1
	 "R_V850_32",			/* name */
d521 15
d556 2
a557 1
  { BFD_RELOC_32,		           R_V850_32                     },
d691 2
a692 1
	case R_V850_32:
d925 2
a926 1
    case R_V850_32:
d1487 6
d1497 1
a1497 1
    case R_V850_32:
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d2511 1
a2511 1
  internal_relocs = (_bfd_elf32_link_read_relocs
@


1.30.22.1
log
@Add pc-relative 32-bit reloc to V850 port.  Fixes ld-elf/merge test failure.
@
text
@d192 1
a192 1
  HOWTO (R_V850_ABS32,			/* type */
d200 1
a200 1
	 "R_V850_ABS32",		/* name */
a520 15
  
  /* Simple pc-relative 32bit reloc.  */
  HOWTO (R_V850_REL32,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_REL32",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */
d541 1
a541 2
  { BFD_RELOC_32,		           R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,		           R_V850_REL32                  },
d675 1
a675 2
	case R_V850_ABS32:
	case R_V850_REL32:
d908 1
a908 2
    case R_V850_REL32:
    case R_V850_ABS32:
a1468 6
    case R_V850_REL32:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);
      break;

d1473 1
a1473 1
    case R_V850_ABS32:
@


1.30.20.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d2511 1
a2511 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.29
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d43 1
a43 1
static boolean v850_elf_is_local_label_name
d45 1
a45 1
static boolean v850_elf_relocate_section
d50 1
a50 1
static boolean v850_elf_check_relocs
d55 1
a55 1
  PARAMS ((bfd_vma, boolean *));
d59 1
a59 1
static boolean v850_elf_object_p
d61 1
a61 1
static boolean v850_elf_fake_sections
d64 2
a65 2
  PARAMS ((bfd *, boolean));
static boolean v850_elf_set_private_flags
d67 1
a67 1
static boolean v850_elf_merge_private_bfd_data
d69 1
a69 1
static boolean v850_elf_print_private_bfd_data
d71 1
a71 1
static boolean v850_elf_section_from_bfd_section
d75 1
a75 1
static boolean v850_elf_add_symbol_hook
d78 1
a78 1
static boolean v850_elf_link_output_symbol_hook
d81 1
a81 1
static boolean v850_elf_section_from_shdr
d83 1
a83 1
static boolean v850_elf_gc_sweep_hook
d92 1
a92 1
static boolean v850_elf_relax_delete_bytes
d94 2
a95 2
static boolean v850_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
d106 1
a106 1
	 false,				/* pc_relative */
d111 1
a111 1
	 false,				/* partial_inplace */
d114 1
a114 1
	 false),			/* pcrel_offset */
d121 1
a121 1
	 true,				/* pc_relative */
d126 1
a126 1
	 false,				/* partial_inplace */
d129 1
a129 1
	 true),				/* pcrel_offset */
d136 1
a136 1
	 true,				/* pc_relative */
d141 1
a141 1
	 false,				/* partial_inplace */
d144 1
a144 1
	 true),				/* pcrel_offset */
d151 1
a151 1
	 false,				/* pc_relative */
d156 1
a156 1
	 false,				/* partial_inplace */
d159 1
a159 1
	 false),			/* pcrel_offset */
d166 1
a166 1
	 false,				/* pc_relative */
d171 1
a171 1
	 false,				/* partial_inplace */
d174 1
a174 1
	 false),			/* pcrel_offset */
d181 1
a181 1
	 false,				/* pc_relative */
d186 1
a186 1
	 false,				/* partial_inplace */
d189 1
a189 1
	 false),			/* pcrel_offset */
d196 1
a196 1
	 false,				/* pc_relative */
d201 1
a201 1
	 false,				/* partial_inplace */
d204 1
a204 1
	 false),			/* pcrel_offset */
d211 1
a211 1
	 false,				/* pc_relative */
d216 1
a216 1
	 false,				/* partial_inplace */
d219 1
a219 1
	 false),			/* pcrel_offset */
d226 1
a226 1
	 false,				/* pc_relative */
d231 1
a231 1
	 false,				/* partial_inplace */
d234 1
a234 1
	 false),			/* pcrel_offset */
d241 1
a241 1
	 false,				/* pc_relative */
d246 1
a246 1
	 false,				/* partial_inplace */
d249 1
a249 1
	 false),			/* pcrel_offset */
d256 1
a256 1
	 false,				/* pc_relative */
d261 1
a261 1
	 false,				/* partial_inplace */
d264 1
a264 1
	 false),			/* pcrel_offset */
d271 1
a271 1
	 false,				/* pc_relative */
d276 1
a276 1
	 false,				/* partial_inplace */
d279 1
a279 1
	 false),			/* pcrel_offset */
d286 1
a286 1
	 false,				/* pc_relative */
d291 1
a291 1
	 false,				/* partial_inplace */
d294 1
a294 1
	 false),			/* pcrel_offset */
d301 1
a301 1
	 false,				/* pc_relative */
d306 1
a306 1
	 false,				/* partial_inplace */
d309 1
a309 1
	 false),			/* pcrel_offset */
d316 1
a316 1
	 false,				/* pc_relative */
d321 1
a321 1
	 false,				/* partial_inplace */
d324 1
a324 1
	 false),			/* pcrel_offset */
d331 1
a331 1
	 false,				/* pc_relative */
d336 1
a336 1
	 false,				/* partial_inplace */
d339 1
a339 1
	 false),			/* pcrel_offset */
d346 1
a346 1
	 false,				/* pc_relative */
d351 1
a351 1
	 false,				/* partial_inplace */
d354 1
a354 1
	 false),			/* pcrel_offset */
d361 1
a361 1
	 false,				/* pc_relative */
d366 1
a366 1
	 false,				/* partial_inplace */
d369 1
a369 1
	 false),			/* pcrel_offset */
d376 1
a376 1
	 false,				/* pc_relative */
d381 1
a381 1
	 false,				/* partial_inplace */
d384 1
a384 1
	 false),			/* pcrel_offset */
d391 1
a391 1
	 false,				/* pc_relative */
d396 1
a396 1
	 false,				/* partial_inplace */
d399 1
a399 1
	 false),			/* pcrel_offset */
d406 1
a406 1
	 false,				/* pc_relative */
d411 1
a411 1
	 false,				/* partial_inplace */
d414 1
a414 1
	 false),			/* pcrel_offset */
d421 1
a421 1
	 false,				/* pc_relative */
d426 1
a426 1
	 false,				/* partial_inplace */
d429 1
a429 1
	 false),			/* pcrel_offset */
d436 1
a436 1
	 false,				/* pc_relative */
d441 1
a441 1
	 false,				/* partial_inplace */
d444 1
a444 1
	 false),			/* pcrel_offset */
d451 1
a451 1
         false,                 /* pc_relative */
d456 1
a456 1
         false,                 /* partial_inplace */
d459 1
a459 1
         false),                /* pcrel_offset */
d466 1
a466 1
         false,                 /* pc_relative */
d471 1
a471 1
         false,                 /* partial_inplace */
d474 1
a474 1
         false),                /* pcrel_offset */
d482 1
a482 1
       true,                  /* pc_relative */
d487 1
a487 1
       false,                 /* partial_inplace */
d490 1
a490 1
       true),                 /* pcrel_offset */
d498 1
a498 1
       true,                  /* pc_relative */
d503 1
a503 1
       false,                 /* partial_inplace */
d506 1
a506 1
       true),                 /* pcrel_offset */
d512 1
a512 1
       false,                 /* pc_relative */
d517 1
a517 1
       false,                 /* partial_inplace */
d520 1
a520 1
       true),                 /* pcrel_offset */
d570 2
a571 2
     bfd *                     abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type  code;
d592 3
a594 3
     bfd *               abfd ATTRIBUTE_UNUSED;
     arelent *           cache_ptr;
     Elf_Internal_Rela * dst;
d606 3
a608 3
     bfd *               abfd ATTRIBUTE_UNUSED;
     arelent *           cache_ptr;
     Elf_Internal_Rela * dst;
d621 1
a621 1
static boolean
d623 4
a626 4
     bfd *                      abfd;
     struct bfd_link_info *     info;
     asection *                 sec;
     const Elf_Internal_Rela *  relocs;
d628 1
a628 1
  boolean ret = true;
d640 1
a640 1
    return true;
d686 1
a686 1
            return false;
d693 1
a693 1
            return false;
d759 1
a759 1
		  ret = false;
d791 1
a791 1
   the field 'found' to true.  If a second lookup matches the same
d801 2
a802 2
  bfd_vma       addend;
  bfd_byte *    address;
d804 2
a805 2
  boolean       found;
  struct hi16s_location * next;
d809 3
a811 3
static hi16s_location *  previous_hi16s;
static hi16s_location *  free_hi16s;
static unsigned long     hi16s_counter;
d815 3
a817 3
     bfd *      abfd;
     bfd_vma    addend;
     bfd_byte * address;
d832 1
a832 1
  entry->found   = false;
d851 2
a852 2
     bfd_vma   addend;
     boolean * already_found;
d854 5
a858 5
  hi16s_location * match = NULL;
  hi16s_location * entry;
  hi16s_location * previous = NULL;
  hi16s_location * prev;
  bfd_byte *       addr;
d884 1
a884 1
  match->found = true;
d1110 2
a1111 2
	    boolean already_updated;
	    bfd_byte * hi16s_address = find_remembered_hi16s_reloc
d1311 7
a1317 7
     bfd *       abfd ATTRIBUTE_UNUSED;
     arelent *   reloc;
     asymbol *   symbol;
     PTR         data ATTRIBUTE_UNUSED;
     asection *  isection;
     bfd *       obfd;
     char **     err ATTRIBUTE_UNUSED;
d1350 1
a1350 1
  if (reloc->howto->pc_relative == true)
d1398 7
a1404 7
     bfd *      abfd ATTRIBUTE_UNUSED;
     arelent *  reloc_entry;
     asymbol *  symbol ATTRIBUTE_UNUSED;
     PTR        data ATTRIBUTE_UNUSED;
     asection * input_section;
     bfd *      output_bfd;
     char **    error_message ATTRIBUTE_UNUSED;
d1412 1
a1412 1
static boolean
d1414 2
a1415 2
     bfd *         abfd ATTRIBUTE_UNUSED;
     const char *  name;
d1432 11
a1442 11
     reloc_howto_type *      howto;
     bfd *                   input_bfd;
     bfd *                   output_bfd ATTRIBUTE_UNUSED;
     asection *              input_section;
     bfd_byte *              contents;
     bfd_vma                 offset;
     bfd_vma                 value;
     bfd_vma                 addend;
     struct bfd_link_info *  info;
     asection *              sym_sec;
     int                     is_local ATTRIBUTE_UNUSED;
d1444 2
a1445 2
  unsigned int   r_type   = howto->type;
  bfd_byte *     hit_data = contents + offset;
d1497 1
a1497 1
	h = bfd_link_hash_lookup (info->hash, "__gp", false, false, true);
d1522 1
a1522 1
	h = bfd_link_hash_lookup (info->hash, "__ep", false, false, true);
d1541 1
a1541 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", false, false, true);
d1562 1
a1562 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", false, false, true);
d1594 1
a1594 1
static boolean
d1597 13
a1609 13
     bfd *                  output_bfd;
     struct bfd_link_info * info;
     bfd *                  input_bfd;
     asection *             input_section;
     bfd_byte *             contents;
     Elf_Internal_Rela *    relocs;
     Elf_Internal_Sym *     local_syms;
     asection **            local_sections;
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
d1612 1
a1612 1
    return true;
d1623 1
a1623 1
      return false;
d1635 8
a1642 8
      int                          r_type;
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
d1705 2
a1706 2
		      input_section, rel->r_offset, true)))
		return false;
d1742 1
a1742 1
		return false;
d1748 2
a1749 2
		      rel->r_offset, true)))
		return false;
d1784 1
a1784 1
		return false;
d1790 1
a1790 1
  return true;
d1793 1
a1793 1
static boolean
d1801 1
a1801 1
  return true;
d1843 1
a1843 1
static boolean
d1857 1
a1857 1
  return true;
d1864 2
a1865 2
     bfd *   abfd;
     boolean linker ATTRIBUTE_UNUSED;
d1871 1
a1871 1
    default:		 
d1882 1
a1882 1
static boolean
d1884 1
a1884 1
     bfd *    abfd;
d1891 2
a1892 2
  elf_flags_init (abfd) = true;
  return true;
d1897 1
a1897 1
static boolean
d1899 2
a1900 2
     bfd * ibfd;
     bfd * obfd;
d1907 1
a1907 1
    return true;
d1921 1
a1921 1
	return true;
d1923 1
a1923 1
      elf_flags_init (obfd) = true;
d1930 1
a1930 1
      return true;
d1935 1
a1935 1
    return true;
d1942 1
a1942 1
  return true;
d1947 1
a1947 1
static boolean
d1949 2
a1950 2
     bfd *   abfd;
     PTR     ptr;
d1970 1
a1970 1
  return true;
d1993 1
a1993 1
static boolean
d1995 3
a1997 3
     bfd *                 abfd ATTRIBUTE_UNUSED;
     asection *            sec;
     int *                 retval;
d2006 1
a2006 1
    return false;
d2008 1
a2008 1
  return true;
d2015 2
a2016 2
     bfd *     abfd;
     asymbol * asym;
d2109 1
a2109 1
static boolean
d2111 7
a2117 7
     bfd *                    abfd;
     struct bfd_link_info *   info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym * sym;
     const char **            namep ATTRIBUTE_UNUSED;
     flagword *               flagsp ATTRIBUTE_UNUSED;
     asection **              secp;
     bfd_vma *                valp;
d2167 1
a2167 1
  return true;
d2170 1
a2170 1
static boolean
d2172 5
a2176 5
     bfd *                  abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info * info ATTRIBUTE_UNUSED;
     const char *           name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *     sym;
     asection *             input_sec;
d2192 1
a2192 1
  return true;
d2195 1
a2195 1
static boolean
d2197 3
a2199 3
     bfd *               abfd;
     Elf_Internal_Shdr * hdr;
     const char *        name;
d2206 1
a2206 1
    return false;
d2217 1
a2217 1
	return false;
d2220 1
a2220 1
  return true;
d2226 1
a2226 1
static boolean
d2228 3
a2230 3
     bfd *               abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr * hdr;
     asection *          sec;
d2247 1
a2247 1
  return true;
d2252 1
a2252 1
static boolean
d2254 18
a2271 18
     bfd *      abfd;
     asection * sec;
     bfd_vma    addr;
     bfd_vma    toaddr;
     int        count;
{
  Elf_Internal_Shdr *		symtab_hdr;
  Elf32_External_Sym *		extsyms;
  Elf32_External_Sym *         	esym;
  Elf32_External_Sym *         	esymend;
  int 				index;
  unsigned int 			sec_shndx;
  bfd_byte *                   	contents;
  Elf_Internal_Rela *          	irel;
  Elf_Internal_Rela *          	irelend;
  struct elf_link_hash_entry * 	sym_hash;
  Elf_Internal_Shdr *           shndx_hdr;
  Elf_External_Sym_Shndx *      shndx;
d2306 1
a2306 1
	irel->r_offset -= count;	
d2314 1
a2314 1
      
d2322 1
a2322 1
      
d2361 1
a2361 1
	      
d2363 1
a2363 1
      
d2389 2
a2390 2
	    isym.st_size += count;	    
	  
d2455 1
a2455 1
  return true;
d2459 1
a2459 1
#define MOVHI	    	0x0640				/* 4byte */ 
d2461 1
a2461 1
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte */ 
d2478 1
a2478 1
static boolean 
d2480 16
a2495 16
     bfd *			abfd;
     asection *			sec;
     struct bfd_link_info *	link_info;
     boolean *			again;
{
  Elf_Internal_Shdr *	    symtab_hdr;
  Elf_Internal_Rela *	    internal_relocs;
  Elf_Internal_Rela *	    irel;
  Elf_Internal_Rela *	    irelend;
  Elf_Internal_Rela *	    irelalign = NULL;
  Elf_Internal_Sym *	    isymbuf = NULL;
  bfd_byte *		    contents = NULL;
  bfd_vma 		    addr = 0;
  bfd_vma		    toaddr;
  int 			    align_pad_size = 0;
  boolean                   result = true;
d2497 1
a2497 1
  * again = false;
d2502 1
a2502 1
    return true;
d2518 1
a2518 1
  
d2528 1
a2528 1
      
d2552 1
a2552 1
		goto error_return;		
d2566 9
a2574 9
	  bfd_vma 	      laddr;
	  bfd_vma	      addend;
	  bfd_vma	      symval;
	  int 		      insn[5];
	  int 		      no_match = -1;
	  Elf_Internal_Rela * hi_irelfn;
	  Elf_Internal_Rela * lo_irelfn;
	  Elf_Internal_Rela * irelcall;
	  bfd_signed_vma      foff;
d2629 1
a2629 1
	  
d2670 1
a2670 1
		}      
d2677 1
a2677 1
		    && ELF32_R_TYPE (hi_irelfn->r_info) 
d2703 1
a2703 1
	
d2745 2
a2746 2
		  Elf_Internal_Sym * isym;
		  asection *         sym_sec;
d2750 1
a2750 1
          
d2766 1
a2766 1
		  struct elf_link_hash_entry * h;
d2815 1
a2815 1
      
d2835 1
a2835 1
	      hi_irelfn->r_info = 
d2894 1
a2894 1
		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V850_HI16_S) 
d2911 1
a2911 1
	
d3008 2
a3009 2
			ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);
  
d3115 1
a3115 1
  result = false;
@


1.28
log
@	* elf32-v850.c (v850_elf_relax_delete_bytes): Correct parameters
	for bfd_elf32_swap_symbol_out.
@
text
@d38 1
a38 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
d40 1
a40 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d62 1
a62 1
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));
d592 3
a594 3
     bfd *                 abfd ATTRIBUTE_UNUSED;
     arelent *             cache_ptr;
     Elf32_Internal_Rel *  dst;
d606 3
a608 3
     bfd *                 abfd ATTRIBUTE_UNUSED;
     arelent *             cache_ptr;
     Elf32_Internal_Rela   *dst;
d2228 3
a2230 3
     bfd *                 abfd ATTRIBUTE_UNUSED;
     Elf32_Internal_Shdr * hdr;
     asection *            sec;
@


1.27
log
@Use helpful names instead of cryptically overloaded bfd_reloc error codes.
Replace caching of external symbols with caching of internal symbols obtained
from calling bfd_elf_get_elf_syms().
Fixup problems with freeing cached allocated memory blocks.
@
text
@d2391 1
a2391 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
d2404 1
a2404 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
d2429 1
a2429 1
	      bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
d2448 1
a2448 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
@


1.27.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d38 1
a38 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d40 1
a40 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d43 1
a43 1
static bfd_boolean v850_elf_is_local_label_name
d45 1
a45 1
static bfd_boolean v850_elf_relocate_section
d50 1
a50 1
static bfd_boolean v850_elf_check_relocs
d55 1
a55 1
  PARAMS ((bfd_vma, bfd_boolean *));
d59 1
a59 1
static bfd_boolean v850_elf_object_p
d61 2
a62 2
static bfd_boolean v850_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d64 2
a65 2
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean v850_elf_set_private_flags
d67 1
a67 1
static bfd_boolean v850_elf_merge_private_bfd_data
d69 1
a69 1
static bfd_boolean v850_elf_print_private_bfd_data
d71 1
a71 1
static bfd_boolean v850_elf_section_from_bfd_section
d75 1
a75 1
static bfd_boolean v850_elf_add_symbol_hook
d78 4
a81 4
static bfd_boolean v850_elf_link_output_symbol_hook
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
static bfd_boolean v850_elf_section_from_shdr
d83 1
a83 1
static bfd_boolean v850_elf_gc_sweep_hook
d92 1
a92 1
static bfd_boolean v850_elf_relax_delete_bytes
d94 2
a95 2
static bfd_boolean v850_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d106 1
a106 1
	 FALSE,				/* pc_relative */
d111 1
a111 1
	 FALSE,				/* partial_inplace */
d114 1
a114 1
	 FALSE),			/* pcrel_offset */
d121 1
a121 1
	 TRUE,				/* pc_relative */
d126 1
a126 1
	 FALSE,				/* partial_inplace */
d129 1
a129 1
	 TRUE),				/* pcrel_offset */
d136 1
a136 1
	 TRUE,				/* pc_relative */
d141 1
a141 1
	 FALSE,				/* partial_inplace */
d144 1
a144 1
	 TRUE),				/* pcrel_offset */
d151 1
a151 1
	 FALSE,				/* pc_relative */
d156 1
a156 1
	 FALSE,				/* partial_inplace */
d159 1
a159 1
	 FALSE),			/* pcrel_offset */
d166 1
a166 1
	 FALSE,				/* pc_relative */
d171 1
a171 1
	 FALSE,				/* partial_inplace */
d174 1
a174 1
	 FALSE),			/* pcrel_offset */
d181 1
a181 1
	 FALSE,				/* pc_relative */
d186 1
a186 1
	 FALSE,				/* partial_inplace */
d189 1
a189 1
	 FALSE),			/* pcrel_offset */
d192 1
a192 1
  HOWTO (R_V850_ABS32,			/* type */
d196 1
a196 1
	 FALSE,				/* pc_relative */
d200 2
a201 2
	 "R_V850_ABS32",		/* name */
	 FALSE,				/* partial_inplace */
d204 1
a204 1
	 FALSE),			/* pcrel_offset */
d211 1
a211 1
	 FALSE,				/* pc_relative */
d216 1
a216 1
	 FALSE,				/* partial_inplace */
d219 1
a219 1
	 FALSE),			/* pcrel_offset */
d226 1
a226 1
	 FALSE,				/* pc_relative */
d231 1
a231 1
	 FALSE,				/* partial_inplace */
d234 1
a234 1
	 FALSE),			/* pcrel_offset */
d241 1
a241 1
	 FALSE,				/* pc_relative */
d246 1
a246 1
	 FALSE,				/* partial_inplace */
d249 1
a249 1
	 FALSE),			/* pcrel_offset */
d256 1
a256 1
	 FALSE,				/* pc_relative */
d261 1
a261 1
	 FALSE,				/* partial_inplace */
d264 1
a264 1
	 FALSE),			/* pcrel_offset */
d271 1
a271 1
	 FALSE,				/* pc_relative */
d276 1
a276 1
	 FALSE,				/* partial_inplace */
d279 1
a279 1
	 FALSE),			/* pcrel_offset */
d286 1
a286 1
	 FALSE,				/* pc_relative */
d291 1
a291 1
	 FALSE,				/* partial_inplace */
d294 1
a294 1
	 FALSE),			/* pcrel_offset */
d301 1
a301 1
	 FALSE,				/* pc_relative */
d306 1
a306 1
	 FALSE,				/* partial_inplace */
d309 1
a309 1
	 FALSE),			/* pcrel_offset */
d316 1
a316 1
	 FALSE,				/* pc_relative */
d321 1
a321 1
	 FALSE,				/* partial_inplace */
d324 1
a324 1
	 FALSE),			/* pcrel_offset */
d331 1
a331 1
	 FALSE,				/* pc_relative */
d336 1
a336 1
	 FALSE,				/* partial_inplace */
d339 1
a339 1
	 FALSE),			/* pcrel_offset */
d346 1
a346 1
	 FALSE,				/* pc_relative */
d351 1
a351 1
	 FALSE,				/* partial_inplace */
d354 1
a354 1
	 FALSE),			/* pcrel_offset */
d361 1
a361 1
	 FALSE,				/* pc_relative */
d366 1
a366 1
	 FALSE,				/* partial_inplace */
d369 1
a369 1
	 FALSE),			/* pcrel_offset */
d376 1
a376 1
	 FALSE,				/* pc_relative */
d381 1
a381 1
	 FALSE,				/* partial_inplace */
d384 1
a384 1
	 FALSE),			/* pcrel_offset */
d391 1
a391 1
	 FALSE,				/* pc_relative */
d396 1
a396 1
	 FALSE,				/* partial_inplace */
d399 1
a399 1
	 FALSE),			/* pcrel_offset */
d406 1
a406 1
	 FALSE,				/* pc_relative */
d411 1
a411 1
	 FALSE,				/* partial_inplace */
d414 1
a414 1
	 FALSE),			/* pcrel_offset */
d421 1
a421 1
	 FALSE,				/* pc_relative */
d426 1
a426 1
	 FALSE,				/* partial_inplace */
d429 1
a429 1
	 FALSE),			/* pcrel_offset */
d436 1
a436 1
	 FALSE,				/* pc_relative */
d441 1
a441 1
	 FALSE,				/* partial_inplace */
d444 1
a444 1
	 FALSE),			/* pcrel_offset */
d451 1
a451 1
         FALSE,                 /* pc_relative */
d456 1
a456 1
         FALSE,                 /* partial_inplace */
d459 1
a459 1
         FALSE),                /* pcrel_offset */
d466 1
a466 1
         FALSE,                 /* pc_relative */
d471 1
a471 1
         FALSE,                 /* partial_inplace */
d474 1
a474 1
         FALSE),                /* pcrel_offset */
d482 1
a482 1
       TRUE,                  /* pc_relative */
d487 1
a487 1
       FALSE,                 /* partial_inplace */
d490 1
a490 1
       TRUE),                 /* pcrel_offset */
d498 1
a498 1
       TRUE,                  /* pc_relative */
d503 1
a503 1
       FALSE,                 /* partial_inplace */
d506 1
a506 1
       TRUE),                 /* pcrel_offset */
d512 1
a512 1
       FALSE,                 /* pc_relative */
d517 1
a517 1
       FALSE,                 /* partial_inplace */
d520 1
a520 16
       TRUE),                 /* pcrel_offset */
  
  /* Simple pc-relative 32bit reloc.  */
  HOWTO (R_V850_REL32,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_REL32",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */
d541 1
a541 2
  { BFD_RELOC_32,		           R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,		           R_V850_REL32                  },
d570 2
a571 2
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d592 3
a594 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d606 3
a608 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf_Internal_Rela *dst;
d621 1
a621 1
static bfd_boolean
d623 4
a626 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d628 1
a628 1
  bfd_boolean ret = TRUE;
d639 2
a640 2
  if (info->relocatable)
    return TRUE;
d675 1
a675 2
	case R_V850_ABS32:
	case R_V850_REL32:
d686 1
a686 1
            return FALSE;
d693 1
a693 1
            return FALSE;
d759 1
a759 1
		  ret = FALSE;
d791 1
a791 1
   the field 'found' to TRUE.  If a second lookup matches the same
d801 2
a802 2
  bfd_vma addend;
  bfd_byte *address;
d804 2
a805 2
  bfd_boolean found;
  struct hi16s_location *next;
d809 3
a811 3
static hi16s_location *previous_hi16s;
static hi16s_location *free_hi16s;
static unsigned long hi16s_counter;
d815 3
a817 3
     bfd *abfd;
     bfd_vma addend;
     bfd_byte *address;
d832 1
a832 1
  entry->found   = FALSE;
d851 2
a852 2
     bfd_vma addend;
     bfd_boolean *already_found;
d854 5
a858 5
  hi16s_location *match = NULL;
  hi16s_location *entry;
  hi16s_location *previous = NULL;
  hi16s_location *prev;
  bfd_byte *addr;
d879 1
a879 1
  /* Remember if this entry has already been used before.  */
d884 1
a884 1
  match->found = TRUE;
d890 1
a890 1
   allowed to do its stuff instead.  At least for most of the relocs, anyway.  */
d908 1
a908 2
    case R_V850_REL32:
    case R_V850_ABS32:
d1110 2
a1111 2
	    bfd_boolean already_updated;
	    bfd_byte *hi16s_address = find_remembered_hi16s_reloc
d1311 7
a1317 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *isection;
     bfd *obfd;
     char **err ATTRIBUTE_UNUSED;
d1347 1
a1347 1
  /* Work out which section the relocation is targeted at and the
d1350 1
a1350 1
  if (reloc->howto->pc_relative)
d1398 7
a1404 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1412 1
a1412 1
static bfd_boolean
d1414 2
a1415 2
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d1432 11
a1442 11
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     int is_local ATTRIBUTE_UNUSED;
d1444 2
a1445 2
  unsigned int r_type = howto->type;
  bfd_byte *hit_data = contents + offset;
a1468 6
    case R_V850_REL32:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);
      break;

d1473 1
a1473 1
    case R_V850_ABS32:
d1497 1
a1497 1
	h = bfd_link_hash_lookup (info->hash, "__gp", FALSE, FALSE, TRUE);
d1522 1
a1522 1
	h = bfd_link_hash_lookup (info->hash, "__ep", FALSE, FALSE, TRUE);
d1541 1
a1541 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
d1562 1
a1562 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
d1594 1
a1594 1
static bfd_boolean
d1597 13
a1609 13
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d1611 2
a1612 2
  if (info->relocatable)
    return TRUE;
d1623 1
a1623 1
      return FALSE;
d1635 8
a1642 8
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
d1660 1
a1660 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1705 2
a1706 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d1742 1
a1742 1
		return FALSE;
d1748 2
a1749 2
		      rel->r_offset, TRUE)))
		return FALSE;
d1784 1
a1784 1
		return FALSE;
d1790 1
a1790 1
  return TRUE;
d1793 1
a1793 1
static bfd_boolean
d1801 1
a1801 1
  return TRUE;
d1843 1
a1843 1
static bfd_boolean
a1855 3
    case E_V850E1_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e1);
      break;
d1857 1
a1857 1
  return TRUE;
d1864 2
a1865 2
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1871 1
a1871 1
    default:
a1873 1
    case bfd_mach_v850e1: val = E_V850E1_ARCH;  break;
d1882 1
a1882 1
static bfd_boolean
d1884 1
a1884 1
     bfd *abfd;
d1891 2
a1892 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1897 1
a1897 1
static bfd_boolean
d1899 2
a1900 2
     bfd *ibfd;
     bfd *obfd;
d1907 1
a1907 1
    return TRUE;
d1921 1
a1921 1
	return TRUE;
d1923 1
a1923 1
      elf_flags_init (obfd) = TRUE;
d1930 1
a1930 1
      return TRUE;
d1935 1
a1935 1
    return TRUE;
d1939 2
a1940 6
    {
      /* Allow v850e1 binaries to be linked with v850e binaries.
	 Set the output binary to v850e.  */
      if ((in_flags & EF_V850_ARCH) == E_V850E1_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E_ARCH)
	return TRUE;
d1942 1
a1942 13
      if ((in_flags & EF_V850_ARCH) == E_V850E_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E1_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E_ARCH);
	  return TRUE;
	}

      _bfd_error_handler (_("%s: Architecture mismatch with previous modules"),
			  bfd_archive_filename (ibfd));
    }

  return TRUE;
d1947 1
a1947 1
static bfd_boolean
d1949 2
a1950 2
     bfd *abfd;
     PTR ptr;
a1965 1
    case E_V850E1_ARCH: fprintf (file, _("v850e1 architecture")); break;
d1970 1
a1970 1
  return TRUE;
d1993 1
a1993 1
static bfd_boolean
d1995 3
a1997 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
d2006 1
a2006 1
    return FALSE;
d2008 1
a2008 1
  return TRUE;
d2015 2
a2016 2
     bfd *abfd;
     asymbol *asym;
d2109 1
a2109 1
static bfd_boolean
d2111 7
a2117 7
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d2167 1
a2167 1
  return TRUE;
d2170 7
a2176 7
static bfd_boolean
v850_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
d2192 1
a2192 1
  return TRUE;
d2195 1
a2195 1
static bfd_boolean
d2197 3
a2199 3
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d2206 1
a2206 1
    return FALSE;
d2217 1
a2217 1
	return FALSE;
d2220 1
a2220 1
  return TRUE;
d2226 1
a2226 1
static bfd_boolean
d2228 3
a2230 3
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr;
     asection *sec;
d2247 1
a2247 1
  return TRUE;
d2252 1
a2252 1
static bfd_boolean
d2254 18
a2271 18
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     bfd_vma toaddr;
     int count;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf32_External_Sym *extsyms;
  Elf32_External_Sym *esym;
  Elf32_External_Sym *esymend;
  int index;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  struct elf_link_hash_entry *sym_hash;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_External_Sym_Shndx *shndx;
d2306 1
a2306 1
	irel->r_offset -= count;
d2314 1
a2314 1

d2322 1
a2322 1

d2361 1
a2361 1

d2363 1
a2363 1

d2389 3
a2391 3
	    isym.st_size += count;

	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2404 1
a2404 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2429 1
a2429 1
	      bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2448 1
a2448 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2455 1
a2455 1
  return TRUE;
d2459 1
a2459 1
#define MOVHI	    	0x0640				/* 4byte */
d2461 1
a2461 1
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte */
d2478 1
a2478 1
static bfd_boolean
d2480 16
a2495 16
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Rela *irelalign = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_byte *contents = NULL;
  bfd_vma addr = 0;
  bfd_vma toaddr;
  int align_pad_size = 0;
  bfd_boolean result = TRUE;
d2497 1
a2497 1
  *again = FALSE;
d2499 1
a2499 1
  if (link_info->relocatable
d2502 1
a2502 1
    return TRUE;
d2511 1
a2511 1
  internal_relocs = (_bfd_elf_link_read_relocs
d2518 1
a2518 1

d2528 1
a2528 1

d2552 1
a2552 1
		goto error_return;
d2566 9
a2574 9
	  bfd_vma laddr;
	  bfd_vma addend;
	  bfd_vma symval;
	  int insn[5];
	  int no_match = -1;
	  Elf_Internal_Rela *hi_irelfn;
	  Elf_Internal_Rela *lo_irelfn;
	  Elf_Internal_Rela *irelcall;
	  bfd_signed_vma foff;
d2629 1
a2629 1

d2670 1
a2670 1
		}
d2677 1
a2677 1
		    && ELF32_R_TYPE (hi_irelfn->r_info)
d2703 1
a2703 1

d2745 2
a2746 2
		  Elf_Internal_Sym *isym;
		  asection *sym_sec;
d2750 1
a2750 1

d2766 1
a2766 1
		  struct elf_link_hash_entry *h;
d2815 1
a2815 1

d2835 1
a2835 1
	      hi_irelfn->r_info =
d2894 1
a2894 1
		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V850_HI16_S)
d2911 1
a2911 1

d3008 2
a3009 2
		    ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);

d3115 1
a3115 1
  result = FALSE;
a3117 31

static struct bfd_elf_special_section const v850_elf_special_sections[]=
{
  { ".sdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".rosdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_GPREL) },
  { ".sbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".scommon",          8, -2, SHT_V850_SCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".tdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".tbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".tcommon",          8, -2, SHT_V850_TCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".rozdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_R0REL) },
  { ".zbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zcommon",          8, -2, SHT_V850_ZCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".call_table_data", 16,  0, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_WRITE) },
  { ".call_table_text", 16,  0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_EXECINSTR) },
  { NULL,               0,   0, 0,                0 }
};
a3140 1
#define elf_backend_special_sections		v850_elf_special_sections
@


1.27.6.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2391 1
a2391 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2404 1
a2404 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2429 1
a2429 1
	      bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2448 1
a2448 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
@


1.27.6.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d38 1
a38 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d40 1
a40 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d43 1
a43 1
static bfd_boolean v850_elf_is_local_label_name
d45 1
a45 1
static bfd_boolean v850_elf_relocate_section
d50 1
a50 1
static bfd_boolean v850_elf_check_relocs
d55 1
a55 1
  PARAMS ((bfd_vma, bfd_boolean *));
d59 1
a59 1
static bfd_boolean v850_elf_object_p
d61 2
a62 2
static bfd_boolean v850_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d64 2
a65 2
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean v850_elf_set_private_flags
d67 1
a67 1
static bfd_boolean v850_elf_merge_private_bfd_data
d69 1
a69 1
static bfd_boolean v850_elf_print_private_bfd_data
d71 1
a71 1
static bfd_boolean v850_elf_section_from_bfd_section
d75 1
a75 1
static bfd_boolean v850_elf_add_symbol_hook
d78 1
a78 1
static bfd_boolean v850_elf_link_output_symbol_hook
d81 1
a81 1
static bfd_boolean v850_elf_section_from_shdr
d83 1
a83 1
static bfd_boolean v850_elf_gc_sweep_hook
d92 1
a92 1
static bfd_boolean v850_elf_relax_delete_bytes
d94 2
a95 2
static bfd_boolean v850_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d106 1
a106 1
	 FALSE,				/* pc_relative */
d111 1
a111 1
	 FALSE,				/* partial_inplace */
d114 1
a114 1
	 FALSE),			/* pcrel_offset */
d121 1
a121 1
	 TRUE,				/* pc_relative */
d126 1
a126 1
	 FALSE,				/* partial_inplace */
d129 1
a129 1
	 TRUE),				/* pcrel_offset */
d136 1
a136 1
	 TRUE,				/* pc_relative */
d141 1
a141 1
	 FALSE,				/* partial_inplace */
d144 1
a144 1
	 TRUE),				/* pcrel_offset */
d151 1
a151 1
	 FALSE,				/* pc_relative */
d156 1
a156 1
	 FALSE,				/* partial_inplace */
d159 1
a159 1
	 FALSE),			/* pcrel_offset */
d166 1
a166 1
	 FALSE,				/* pc_relative */
d171 1
a171 1
	 FALSE,				/* partial_inplace */
d174 1
a174 1
	 FALSE),			/* pcrel_offset */
d181 1
a181 1
	 FALSE,				/* pc_relative */
d186 1
a186 1
	 FALSE,				/* partial_inplace */
d189 1
a189 1
	 FALSE),			/* pcrel_offset */
d196 1
a196 1
	 FALSE,				/* pc_relative */
d201 1
a201 1
	 FALSE,				/* partial_inplace */
d204 1
a204 1
	 FALSE),			/* pcrel_offset */
d211 1
a211 1
	 FALSE,				/* pc_relative */
d216 1
a216 1
	 FALSE,				/* partial_inplace */
d219 1
a219 1
	 FALSE),			/* pcrel_offset */
d226 1
a226 1
	 FALSE,				/* pc_relative */
d231 1
a231 1
	 FALSE,				/* partial_inplace */
d234 1
a234 1
	 FALSE),			/* pcrel_offset */
d241 1
a241 1
	 FALSE,				/* pc_relative */
d246 1
a246 1
	 FALSE,				/* partial_inplace */
d249 1
a249 1
	 FALSE),			/* pcrel_offset */
d256 1
a256 1
	 FALSE,				/* pc_relative */
d261 1
a261 1
	 FALSE,				/* partial_inplace */
d264 1
a264 1
	 FALSE),			/* pcrel_offset */
d271 1
a271 1
	 FALSE,				/* pc_relative */
d276 1
a276 1
	 FALSE,				/* partial_inplace */
d279 1
a279 1
	 FALSE),			/* pcrel_offset */
d286 1
a286 1
	 FALSE,				/* pc_relative */
d291 1
a291 1
	 FALSE,				/* partial_inplace */
d294 1
a294 1
	 FALSE),			/* pcrel_offset */
d301 1
a301 1
	 FALSE,				/* pc_relative */
d306 1
a306 1
	 FALSE,				/* partial_inplace */
d309 1
a309 1
	 FALSE),			/* pcrel_offset */
d316 1
a316 1
	 FALSE,				/* pc_relative */
d321 1
a321 1
	 FALSE,				/* partial_inplace */
d324 1
a324 1
	 FALSE),			/* pcrel_offset */
d331 1
a331 1
	 FALSE,				/* pc_relative */
d336 1
a336 1
	 FALSE,				/* partial_inplace */
d339 1
a339 1
	 FALSE),			/* pcrel_offset */
d346 1
a346 1
	 FALSE,				/* pc_relative */
d351 1
a351 1
	 FALSE,				/* partial_inplace */
d354 1
a354 1
	 FALSE),			/* pcrel_offset */
d361 1
a361 1
	 FALSE,				/* pc_relative */
d366 1
a366 1
	 FALSE,				/* partial_inplace */
d369 1
a369 1
	 FALSE),			/* pcrel_offset */
d376 1
a376 1
	 FALSE,				/* pc_relative */
d381 1
a381 1
	 FALSE,				/* partial_inplace */
d384 1
a384 1
	 FALSE),			/* pcrel_offset */
d391 1
a391 1
	 FALSE,				/* pc_relative */
d396 1
a396 1
	 FALSE,				/* partial_inplace */
d399 1
a399 1
	 FALSE),			/* pcrel_offset */
d406 1
a406 1
	 FALSE,				/* pc_relative */
d411 1
a411 1
	 FALSE,				/* partial_inplace */
d414 1
a414 1
	 FALSE),			/* pcrel_offset */
d421 1
a421 1
	 FALSE,				/* pc_relative */
d426 1
a426 1
	 FALSE,				/* partial_inplace */
d429 1
a429 1
	 FALSE),			/* pcrel_offset */
d436 1
a436 1
	 FALSE,				/* pc_relative */
d441 1
a441 1
	 FALSE,				/* partial_inplace */
d444 1
a444 1
	 FALSE),			/* pcrel_offset */
d451 1
a451 1
         FALSE,                 /* pc_relative */
d456 1
a456 1
         FALSE,                 /* partial_inplace */
d459 1
a459 1
         FALSE),                /* pcrel_offset */
d466 1
a466 1
         FALSE,                 /* pc_relative */
d471 1
a471 1
         FALSE,                 /* partial_inplace */
d474 1
a474 1
         FALSE),                /* pcrel_offset */
d482 1
a482 1
       TRUE,                  /* pc_relative */
d487 1
a487 1
       FALSE,                 /* partial_inplace */
d490 1
a490 1
       TRUE),                 /* pcrel_offset */
d498 1
a498 1
       TRUE,                  /* pc_relative */
d503 1
a503 1
       FALSE,                 /* partial_inplace */
d506 1
a506 1
       TRUE),                 /* pcrel_offset */
d512 1
a512 1
       FALSE,                 /* pc_relative */
d517 1
a517 1
       FALSE,                 /* partial_inplace */
d520 1
a520 1
       TRUE),                 /* pcrel_offset */
d570 2
a571 2
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d592 3
a594 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d606 3
a608 3
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent * cache_ptr;
     Elf_Internal_Rela *dst;
d621 1
a621 1
static bfd_boolean
d623 4
a626 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d628 1
a628 1
  bfd_boolean ret = TRUE;
d640 1
a640 1
    return TRUE;
d686 1
a686 1
            return FALSE;
d693 1
a693 1
            return FALSE;
d759 1
a759 1
		  ret = FALSE;
d791 1
a791 1
   the field 'found' to TRUE.  If a second lookup matches the same
d801 2
a802 2
  bfd_vma addend;
  bfd_byte *address;
d804 2
a805 2
  bfd_boolean found;
  struct hi16s_location *next;
d809 3
a811 3
static hi16s_location *previous_hi16s;
static hi16s_location *free_hi16s;
static unsigned long hi16s_counter;
d815 3
a817 3
     bfd *abfd;
     bfd_vma addend;
     bfd_byte *address;
d832 1
a832 1
  entry->found   = FALSE;
d851 2
a852 2
     bfd_vma addend;
     bfd_boolean *already_found;
d854 5
a858 5
  hi16s_location *match = NULL;
  hi16s_location *entry;
  hi16s_location *previous = NULL;
  hi16s_location *prev;
  bfd_byte *addr;
d884 1
a884 1
  match->found = TRUE;
d1110 2
a1111 2
	    bfd_boolean already_updated;
	    bfd_byte *hi16s_address = find_remembered_hi16s_reloc
d1311 7
a1317 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *isection;
     bfd *obfd;
     char **err ATTRIBUTE_UNUSED;
d1350 1
a1350 1
  if (reloc->howto->pc_relative)
d1398 7
a1404 7
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1412 1
a1412 1
static bfd_boolean
d1414 2
a1415 2
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d1432 11
a1442 11
     reloc_howto_type *howto;
     bfd *input_bfd;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd_byte *contents;
     bfd_vma offset;
     bfd_vma value;
     bfd_vma addend;
     struct bfd_link_info *info;
     asection *sym_sec;
     int is_local ATTRIBUTE_UNUSED;
d1444 2
a1445 2
  unsigned int r_type = howto->type;
  bfd_byte *hit_data = contents + offset;
d1497 1
a1497 1
	h = bfd_link_hash_lookup (info->hash, "__gp", FALSE, FALSE, TRUE);
d1522 1
a1522 1
	h = bfd_link_hash_lookup (info->hash, "__ep", FALSE, FALSE, TRUE);
d1541 1
a1541 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
d1562 1
a1562 1
	h = bfd_link_hash_lookup (info->hash, "__ctbp", FALSE, FALSE, TRUE);
d1594 1
a1594 1
static bfd_boolean
d1597 13
a1609 13
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
d1612 1
a1612 1
    return TRUE;
d1623 1
a1623 1
      return FALSE;
d1635 8
a1642 8
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
d1705 2
a1706 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d1742 1
a1742 1
		return FALSE;
d1748 2
a1749 2
		      rel->r_offset, TRUE)))
		return FALSE;
d1784 1
a1784 1
		return FALSE;
d1790 1
a1790 1
  return TRUE;
d1793 1
a1793 1
static bfd_boolean
d1801 1
a1801 1
  return TRUE;
d1843 1
a1843 1
static bfd_boolean
d1857 1
a1857 1
  return TRUE;
d1864 2
a1865 2
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1871 1
a1871 1
    default:
d1882 1
a1882 1
static bfd_boolean
d1884 1
a1884 1
     bfd *abfd;
d1891 2
a1892 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1897 1
a1897 1
static bfd_boolean
d1899 2
a1900 2
     bfd *ibfd;
     bfd *obfd;
d1907 1
a1907 1
    return TRUE;
d1921 1
a1921 1
	return TRUE;
d1923 1
a1923 1
      elf_flags_init (obfd) = TRUE;
d1930 1
a1930 1
      return TRUE;
d1935 1
a1935 1
    return TRUE;
d1942 1
a1942 1
  return TRUE;
d1947 1
a1947 1
static bfd_boolean
d1949 2
a1950 2
     bfd *abfd;
     PTR ptr;
d1970 1
a1970 1
  return TRUE;
d1993 1
a1993 1
static bfd_boolean
d1995 3
a1997 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     int *retval;
d2006 1
a2006 1
    return FALSE;
d2008 1
a2008 1
  return TRUE;
d2015 2
a2016 2
     bfd *abfd;
     asymbol *asym;
d2109 1
a2109 1
static bfd_boolean
d2111 7
a2117 7
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d2167 1
a2167 1
  return TRUE;
d2170 1
a2170 1
static bfd_boolean
d2172 5
a2176 5
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     Elf_Internal_Sym *sym;
     asection *input_sec;
d2192 1
a2192 1
  return TRUE;
d2195 1
a2195 1
static bfd_boolean
d2197 3
a2199 3
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d2206 1
a2206 1
    return FALSE;
d2217 1
a2217 1
	return FALSE;
d2220 1
a2220 1
  return TRUE;
d2226 1
a2226 1
static bfd_boolean
d2228 3
a2230 3
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *hdr;
     asection *sec;
d2247 1
a2247 1
  return TRUE;
d2252 1
a2252 1
static bfd_boolean
d2254 18
a2271 18
     bfd *abfd;
     asection *sec;
     bfd_vma addr;
     bfd_vma toaddr;
     int count;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf32_External_Sym *extsyms;
  Elf32_External_Sym *esym;
  Elf32_External_Sym *esymend;
  int index;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  struct elf_link_hash_entry *sym_hash;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_External_Sym_Shndx *shndx;
d2306 1
a2306 1
	irel->r_offset -= count;
d2314 1
a2314 1

d2322 1
a2322 1

d2361 1
a2361 1

d2363 1
a2363 1

d2389 2
a2390 2
	    isym.st_size += count;

d2455 1
a2455 1
  return TRUE;
d2459 1
a2459 1
#define MOVHI	    	0x0640				/* 4byte */
d2461 1
a2461 1
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte */
d2478 1
a2478 1
static bfd_boolean
d2480 16
a2495 16
     bfd *abfd;
     asection *sec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  Elf_Internal_Rela *irelalign = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_byte *contents = NULL;
  bfd_vma addr = 0;
  bfd_vma toaddr;
  int align_pad_size = 0;
  bfd_boolean result = TRUE;
d2497 1
a2497 1
  *again = FALSE;
d2502 1
a2502 1
    return TRUE;
d2518 1
a2518 1

d2528 1
a2528 1

d2552 1
a2552 1
		goto error_return;
d2566 9
a2574 9
	  bfd_vma laddr;
	  bfd_vma addend;
	  bfd_vma symval;
	  int insn[5];
	  int no_match = -1;
	  Elf_Internal_Rela *hi_irelfn;
	  Elf_Internal_Rela *lo_irelfn;
	  Elf_Internal_Rela *irelcall;
	  bfd_signed_vma foff;
d2629 1
a2629 1

d2670 1
a2670 1
		}
d2677 1
a2677 1
		    && ELF32_R_TYPE (hi_irelfn->r_info)
d2703 1
a2703 1

d2745 2
a2746 2
		  Elf_Internal_Sym *isym;
		  asection *sym_sec;
d2750 1
a2750 1

d2766 1
a2766 1
		  struct elf_link_hash_entry *h;
d2815 1
a2815 1

d2835 1
a2835 1
	      hi_irelfn->r_info =
d2894 1
a2894 1
		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V850_HI16_S)
d2911 1
a2911 1

d3008 2
a3009 2
		    ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);

d3115 1
a3115 1
  result = FALSE;
@


1.27.6.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d2511 1
a2511 1
  internal_relocs = (_bfd_elf_link_read_relocs
@


1.27.6.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d192 1
a192 1
  HOWTO (R_V850_ABS32,			/* type */
d200 1
a200 1
	 "R_V850_ABS32",		/* name */
a520 15
  
  /* Simple pc-relative 32bit reloc.  */
  HOWTO (R_V850_REL32,			/* type */
	 0,				/* rightshift */
	 2,				/* size (0 = byte, 1 = short, 2 = long) */
	 32,				/* bitsize */
	 TRUE,				/* pc_relative */
	 0,				/* bitpos */
	 complain_overflow_dont,	/* complain_on_overflow */
	 v850_elf_reloc,		/* special_function */
	 "R_V850_REL32",		/* name */
	 FALSE,				/* partial_inplace */
	 0xffffffff,			/* src_mask */
	 0xffffffff,			/* dst_mask */
	 FALSE),			/* pcrel_offset */
d541 1
a541 2
  { BFD_RELOC_32,		           R_V850_ABS32                  },
  { BFD_RELOC_32_PCREL,		           R_V850_REL32                  },
d639 1
a639 1
  if (info->relocatable)
d675 1
a675 2
	case R_V850_ABS32:
	case R_V850_REL32:
d908 1
a908 2
    case R_V850_REL32:
    case R_V850_ABS32:
a1468 6
    case R_V850_REL32:
      value -= (input_section->output_section->vma
		+ input_section->output_offset
		+ offset);
      break;

d1473 1
a1473 1
    case R_V850_ABS32:
d1611 1
a1611 1
  if (info->relocatable)
d2499 1
a2499 1
  if (link_info->relocatable
@


1.27.6.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a3141 32

static struct bfd_elf_special_section const v850_elf_special_sections[]=
{
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".rosdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_V850_GPREL },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".scommon",		0,	NULL,	0,
    SHT_V850_SCOMMON, 	SHF_ALLOC + SHF_WRITE + SHF_V850_GPREL },
  { ".tdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_EPREL },
  { ".tbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_V850_EPREL },
  { ".tcommon",		0,	NULL,	0,
    SHT_V850_TCOMMON,	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".zdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".rozdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_V850_R0REL },
  { ".zbss",		0,	NULL,	0,
    SHT_NOBITS,	  	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".zcommon",		0,	NULL,	0,
    SHT_V850_ZCOMMON, 	SHF_ALLOC + SHF_WRITE + SHF_V850_R0REL },
  { ".call_table_data",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".call_table_text",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_EXECINSTR },
  { NULL,		0,	NULL,	0,
    0,			0 }
};
a3164 1
#define elf_backend_special_sections		v850_elf_special_sections
@


1.27.6.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a1879 3
    case E_V850E1_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e1);
      break;
a1897 1
    case bfd_mach_v850e1: val = E_V850E1_ARCH;  break;
d1963 2
a1964 18
    {
      /* Allow v850e1 binaries to be linked with v850e binaries.
	 Set the output binary to v850e.  */
      if ((in_flags & EF_V850_ARCH) == E_V850E1_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E_ARCH)
	return TRUE;

      if ((in_flags & EF_V850_ARCH) == E_V850E_ARCH
	  && (out_flags & EF_V850_ARCH) == E_V850E1_ARCH)
	{
	  elf_elfheader (obfd)->e_flags =
	    ((out_flags & ~ EF_V850_ARCH) | E_V850E_ARCH);
	  return TRUE;
	}

      _bfd_error_handler (_("%s: Architecture mismatch with previous modules"),
			  bfd_archive_filename (ibfd));
    }
a1989 1
    case E_V850E1_ARCH: fprintf (file, _("v850e1 architecture")); break;
@


1.27.6.7
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1684 1
a1684 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d3166 28
a3193 27
  { ".sdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".rosdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_GPREL) },
  { ".sbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".scommon",          8, -2, SHT_V850_SCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_GPREL) },
  { ".tdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".tbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_EPREL) },
  { ".tcommon",          8, -2, SHT_V850_TCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zdata",            6, -2, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".rozdata",          8, -2, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_V850_R0REL) },
  { ".zbss",             5, -2, SHT_NOBITS,       (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".zcommon",          8, -2, SHT_V850_ZCOMMON, (SHF_ALLOC + SHF_WRITE
                                                   + SHF_V850_R0REL) },
  { ".call_table_data", 16,  0, SHT_PROGBITS,     (SHF_ALLOC
                                                   + SHF_WRITE) },
  { ".call_table_text", 16,  0, SHT_PROGBITS,     (SHF_ALLOC + SHF_WRITE
                                                   + SHF_EXECINSTR) },
  { NULL,               0,   0, 0,                0 }
@


1.27.6.8
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d79 2
a80 2
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d896 1
a896 1
  /* Remember if this entry has already been used before.  */
d907 1
a907 1
   allowed to do its stuff instead.  At least for most of the relocs, anyway.  */
d1365 1
a1365 1
  /* Work out which section the relocation is targeted at and the
d2216 2
a2217 1
v850_elf_link_output_symbol_hook (info, name, sym, input_sec, h)
a2221 1
     struct elf_link_hash_entry *h ATTRIBUTE_UNUSED;
@


1.26
log
@	* ecoff.c (_bfd_ecoff_set_arch_mach_hook): Don't use hard-coded
	bfd_mach constants.
	(ecoff_get_magic): Likewise.
	* elf32-v850.c (v850_elf_object_p): Likewise.
	(v850_elf_final_write_processing): Likewise.
	* mipsbsd.c (MY(set_arch_mach)): Likewise.
	(MY(write_object_contents)): Likewise.
	* coff64-rs6000.c (xcoff64_write_object_contents): Likewise.
	* coffcode.h (coff_write_object_contents): Likewise.
	(coff_set_arch_mach_hook): Add comment describing machine == 0.
	Remove unnecessary "machine" assignments.
	(coff_write_relocs): Test for the absolute section sym by testing
	section and flags.

	* pdp11.c (NAME(aout,machine_type)): Like aoutx.h.
@
text
@a1333 4
#if 0
  else if (obfd != NULL)
    return bfd_reloc_continue;
#endif
d1421 5
d1500 1
a1500 1
	  return bfd_reloc_other;
d1525 1
a1525 2
	  /* Actually this indicates that __ep could not be found.  */
	  return bfd_reloc_continue;
d1544 1
a1544 2
	  /* Actually this indicates that __ctbp could not be found.  */
	  return bfd_reloc_dangerous + 1;
d1565 1
a1565 1
	  return (bfd_reloc_dangerous + 1);
d1764 1
a1764 1
	    case bfd_reloc_other:
d1768 1
a1768 1
	    case bfd_reloc_continue:
d1772 1
a1772 1
	    case (bfd_reloc_dangerous + 1):
a2486 1
  Elf_Internal_Rela *	    free_relocs = NULL;
d2490 1
a2491 3
  bfd_byte *		    free_contents = NULL;
  Elf32_External_Sym *	    extsyms = NULL;
  Elf32_External_Sym *	    free_extsyms = NULL;
d2495 2
a2496 3
  Elf_Internal_Shdr *       shndx_hdr = NULL;
  Elf_External_Sym_Shndx *  shndx_buf = NULL;
  
a2515 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
a2598 2
		  free_contents = contents;

d2605 2
a2606 2
	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (extsyms == NULL)
d2608 7
a2614 32
	      /* Get cached copy if it exists.  */
	      if (symtab_hdr->contents != NULL)
		extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	      else
		{
		  /* Go get them off disk.  */
		  bfd_size_type amt;

		  amt = symtab_hdr->sh_info;
		  amt *= sizeof (Elf32_External_Sym);
		  extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
		  if (extsyms == NULL)
		    goto error_return;
		  free_extsyms = extsyms;
		  if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		      || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		    goto error_return;
		}

	      if (shndx_hdr->sh_size != 0)
		{
		  bfd_size_type amt;

		  amt = symtab_hdr->sh_info;
		  amt *= sizeof (Elf_External_Sym_Shndx);
		  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
		  if (shndx_buf == NULL)
		    goto error_return;
		  if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		      || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		    goto error_return;
		}
d2706 1
a2706 5
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;
d2709 1
a2709 4
		  r_index = ELF32_R_SYM (irelcall->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
d2711 1
a2711 9
		  if (isym.st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym.st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym.st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = isym.st_value;
d2745 2
a2746 5
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;
d2749 1
a2749 4
		  r_index = ELF32_R_SYM (irel->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
d2751 1
a2751 1
		  if (isym.st_shndx == SHN_UNDEF)
d2753 1
a2753 1
		  else if (isym.st_shndx == SHN_ABS)
d2755 1
a2755 1
		  else if (isym.st_shndx == SHN_COMMON)
d2758 2
a2759 2
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = (isym.st_value
d2769 1
a2769 1
		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
a2812 2
	      free_relocs = NULL;

d2814 1
a2814 4
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;
d2915 2
a2916 5
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;
d2919 3
a2921 6
		  r_index = ELF32_R_SYM (irel->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
	  
		  if (isym.st_shndx == SHN_UNDEF)
d2923 1
a2923 1
		  else if (isym.st_shndx == SHN_ABS)
d2925 1
a2925 1
		  else if (isym.st_shndx == SHN_COMMON)
d2928 2
a2929 2
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = (isym.st_value
d2935 1
a2935 1
		      (abfd, symtab_hdr->sh_link, isym.st_name);
d2938 4
a2941 3
			     sym_sec->name, name, isym.st_name,
			     sym_sec->output_section->vma, sym_sec->output_offset,
			     isym.st_value, irel->r_addend);
a2999 2
	      free_relocs = NULL;

d3001 1
a3001 4
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;
d3099 14
a3112 1
  return true;
d3115 2
a3116 10
  if (free_relocs != NULL)
    free (free_relocs);

  if (free_contents != NULL)
    free (free_contents);

  if (free_extsyms != NULL)
    free (free_extsyms);

  return false;
@


1.25
log
@Add linker relaxation to v850 toolchain
@
text
@d1851 6
a1856 2
    case E_V850_ARCH:   (void) bfd_default_set_arch_mach (abfd, bfd_arch_v850, 0); break;
    case E_V850E_ARCH:  (void) bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e); break;
d1872 3
a1874 3
    default:
    case 0: val = E_V850_ARCH; break;
    case bfd_mach_v850e:  val = E_V850E_ARCH; break;
@


1.24
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 1
   dependencies.  As is the gas & simulator code or the v850.  */
d90 6
d476 45
d535 17
a551 17
  { BFD_RELOC_NONE,		R_V850_NONE },
  { BFD_RELOC_V850_9_PCREL,	R_V850_9_PCREL },
  { BFD_RELOC_V850_22_PCREL,	R_V850_22_PCREL },
  { BFD_RELOC_HI16_S,		R_V850_HI16_S },
  { BFD_RELOC_HI16,		R_V850_HI16 },
  { BFD_RELOC_LO16,		R_V850_LO16 },
  { BFD_RELOC_32,		R_V850_32 },
  { BFD_RELOC_16,		R_V850_16 },
  { BFD_RELOC_8,		R_V850_8 },
  { BFD_RELOC_V850_SDA_16_16_OFFSET, R_V850_SDA_16_16_OFFSET },
  { BFD_RELOC_V850_SDA_15_16_OFFSET, R_V850_SDA_15_16_OFFSET },
  { BFD_RELOC_V850_ZDA_16_16_OFFSET, R_V850_ZDA_16_16_OFFSET },
  { BFD_RELOC_V850_ZDA_15_16_OFFSET, R_V850_ZDA_15_16_OFFSET },
  { BFD_RELOC_V850_TDA_6_8_OFFSET,   R_V850_TDA_6_8_OFFSET   },
  { BFD_RELOC_V850_TDA_7_8_OFFSET,   R_V850_TDA_7_8_OFFSET   },
  { BFD_RELOC_V850_TDA_7_7_OFFSET,   R_V850_TDA_7_7_OFFSET   },
  { BFD_RELOC_V850_TDA_16_16_OFFSET, R_V850_TDA_16_16_OFFSET },
d558 5
a562 2
  { BFD_RELOC_VTABLE_INHERIT,               R_V850_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY,                 R_V850_GNU_VTENTRY },
d1354 3
d1395 20
d1429 2
a1430 2
				    input_section, contents, offset, value,
				    addend, info, sym_sec, is_local)
d1580 3
a1852 1
    case E_V850EA_ARCH: (void) bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850ea); break;
a1870 1
    case bfd_mach_v850ea: val = E_V850EA_ARCH;  break;
a1962 1
    case E_V850EA_ARCH: fprintf (file, _("v850ea architecture")); break;
d2246 933
d3211 1
@


1.23
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d1532 3
d1572 1
a1573 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d2194 1
@


1.22
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d87 1
a87 1
  PARAMS ((bfd *, struct bfd_link_info *,
d1743 2
a1744 2
v850_elf_gc_mark_hook (abfd, info, rel, h, sym)
       bfd *abfd;
d1774 1
a1774 3
     {
       return bfd_section_from_elf_index (abfd, sym->st_shndx);
     }
@


1.21
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d1325 1
a1325 1
  if (reloc->howto->pc_relative == true)
@


1.20
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d82 1
a82 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
d2138 1
a2138 1
     char *              name;
@


1.20.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d82 1
a82 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d2138 1
a2138 1
     const char *        name;
@


1.20.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d87 1
a87 1
  PARAMS ((asection *, struct bfd_link_info *,
d1325 1
a1325 1
  if (reloc->howto->pc_relative)
d1743 2
a1744 2
v850_elf_gc_mark_hook (sec, info, rel, h, sym)
       asection *sec;
d1774 3
a1776 1
     return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.20.10.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a1531 3
  if (info->relocateable)
    return true;

d1569 21
a1590 1
      howto = v850_elf_howto_table + r_type;
a2210 1
#define elf_backend_rela_normal 1
@


1.20.10.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 1
   dependencies.  As is the gas & simulator code for the v850.  */
a89 6
static bfd_reloc_status_type v850_elf_ignore_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static boolean v850_elf_relax_delete_bytes
  PARAMS ((bfd *, asection *, bfd_vma, bfd_vma, int));
static boolean v850_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
a469 45
  /* Indicates a .longcall pseudo-op.  The compiler will generate a .longcall
     pseudo-op when it finds a function call which can be relaxed.  */
  HOWTO (R_V850_LONGCALL,     /* type */
       0,                     /* rightshift */
       2,                     /* size (0 = byte, 1 = short, 2 = long) */
       32,                    /* bitsize */
       true,                  /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_signed, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_LONGCALL",     /* name */
       false,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       true),                 /* pcrel_offset */

  /* Indicates a .longjump pseudo-op.  The compiler will generate a
     .longjump pseudo-op when it finds a branch which can be relaxed.  */
  HOWTO (R_V850_LONGJUMP,     /* type */
       0,                     /* rightshift */
       2,                     /* size (0 = byte, 1 = short, 2 = long) */
       32,                    /* bitsize */
       true,                  /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_signed, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_LONGJUMP",     /* name */
       false,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       true),                 /* pcrel_offset */

  HOWTO (R_V850_ALIGN,        /* type */
       0,                     /* rightshift */
       1,                     /* size (0 = byte, 1 = short, 2 = long) */
       0,                     /* bitsize */
       false,                 /* pc_relative */
       0,                     /* bitpos */
       complain_overflow_unsigned, /* complain_on_overflow */
       v850_elf_ignore_reloc, /* special_function */
       "R_V850_ALIGN",        /* name */
       false,                 /* partial_inplace */
       0,                     /* src_mask */
       0,                     /* dst_mask */
       true),                 /* pcrel_offset */
d484 17
a500 17
  { BFD_RELOC_NONE,		           R_V850_NONE                   },
  { BFD_RELOC_V850_9_PCREL,	           R_V850_9_PCREL                },
  { BFD_RELOC_V850_22_PCREL,	           R_V850_22_PCREL               },
  { BFD_RELOC_HI16_S,		           R_V850_HI16_S                 },
  { BFD_RELOC_HI16,		           R_V850_HI16                   },
  { BFD_RELOC_LO16,		           R_V850_LO16                   },
  { BFD_RELOC_32,		           R_V850_32                     },
  { BFD_RELOC_16,		           R_V850_16                     },
  { BFD_RELOC_8,		           R_V850_8                      },
  { BFD_RELOC_V850_SDA_16_16_OFFSET,       R_V850_SDA_16_16_OFFSET       },
  { BFD_RELOC_V850_SDA_15_16_OFFSET,       R_V850_SDA_15_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_16_16_OFFSET,       R_V850_ZDA_16_16_OFFSET       },
  { BFD_RELOC_V850_ZDA_15_16_OFFSET,       R_V850_ZDA_15_16_OFFSET       },
  { BFD_RELOC_V850_TDA_6_8_OFFSET,         R_V850_TDA_6_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_8_OFFSET,         R_V850_TDA_7_8_OFFSET         },
  { BFD_RELOC_V850_TDA_7_7_OFFSET,         R_V850_TDA_7_7_OFFSET         },
  { BFD_RELOC_V850_TDA_16_16_OFFSET,       R_V850_TDA_16_16_OFFSET       },
d507 2
a508 5
  { BFD_RELOC_VTABLE_INHERIT,              R_V850_GNU_VTINHERIT          },
  { BFD_RELOC_VTABLE_ENTRY,                R_V850_GNU_VTENTRY            },
  { BFD_RELOC_V850_LONGCALL,               R_V850_LONGCALL               },
  { BFD_RELOC_V850_LONGJUMP,               R_V850_LONGJUMP               },
  { BFD_RELOC_V850_ALIGN,                  R_V850_ALIGN                  },
a1299 3
  if (reloc->howto->pc_relative == true)
    return bfd_reloc_ok;

a1337 20

/* This function is used for relocs which are only used
   for relaxing, which the linker should otherwise ignore.  */

static bfd_reloc_status_type
v850_elf_ignore_reloc (abfd, reloc_entry, symbol, data, input_section,
                       output_bfd, error_message)
     bfd *      abfd ATTRIBUTE_UNUSED;
     arelent *  reloc_entry;
     asymbol *  symbol ATTRIBUTE_UNUSED;
     PTR        data ATTRIBUTE_UNUSED;
     asection * input_section;
     bfd *      output_bfd;
     char **    error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != NULL)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}
d1352 2
a1353 2
			      input_section, contents, offset, value,
			      addend, info, sym_sec, is_local)
a1502 3
    case R_V850_LONGCALL:
    case R_V850_LONGJUMP:
    case R_V850_ALIGN:
d1773 1
d1792 1
d1885 1
a2168 933

/* Delete some bytes from a section while relaxing.  */

static boolean
v850_elf_relax_delete_bytes (abfd, sec, addr, toaddr, count)
     bfd *      abfd;
     asection * sec;
     bfd_vma    addr;
     bfd_vma    toaddr;
     int        count;
{
  Elf_Internal_Shdr *		symtab_hdr;
  Elf32_External_Sym *		extsyms;
  Elf32_External_Sym *         	esym;
  Elf32_External_Sym *         	esymend;
  int 				index;
  unsigned int 			sec_shndx;
  bfd_byte *                   	contents;
  Elf_Internal_Rela *          	irel;
  Elf_Internal_Rela *          	irelend;
  struct elf_link_hash_entry * 	sym_hash;
  Elf_Internal_Shdr *           shndx_hdr;
  Elf_External_Sym_Shndx *      shndx;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;

  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an alignment
     power larger than the number of bytes we are deleting.  */

  /* Actually delete the bytes.  */
#if (DEBUG_RELAX & 2)
  fprintf (stderr, "relax_delete: contents: sec: %s  %p .. %p %x\n",
	   sec->name, addr, toaddr, count );
#endif
  memmove (contents + addr, contents + addr + count,
	   toaddr - addr - count);
  memset (contents + toaddr-count, 0, count);

  /* Adjust all the relocs.  */
  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  shndx = (Elf_External_Sym_Shndx *) shndx_hdr->contents;

  for (; irel < irelend; irel++)
    {
      bfd_vma raddr, paddr, symval;
      Elf_Internal_Sym isym;

      /* Get the new reloc address.  */
      raddr = irel->r_offset;
      if ((raddr >= (addr + count) && raddr < toaddr))
	irel->r_offset -= count;	

      if (raddr >= addr && raddr < addr + count)
	{
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       (int) R_V850_NONE);
	  continue;
	}
      
      if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN)
	continue;

      bfd_elf32_swap_symbol_in (abfd,
				extsyms + ELF32_R_SYM (irel->r_info),
				shndx ? shndx + ELF32_R_SYM (irel->r_info) : NULL,
				& isym);
      
      if (isym.st_shndx != sec_shndx)
	continue;

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  symval = isym.st_value;
#if (DEBUG_RELAX & 2)
	  {
	    char * name = bfd_elf_string_from_elf_section
	                   (abfd, symtab_hdr->sh_link, isym.st_name);
	    fprintf (stderr,
	       "relax_delete: local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
	       sec->name, name, isym.st_name,
	       sec->output_section->vma, sec->output_offset,
	       isym.st_value, irel->r_addend);
	  }
#endif
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry * h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;

	  h = elf_sym_hashes (abfd) [indx];
	  BFD_ASSERT (h != NULL);

	  symval = h->root.u.def.value;
#if (DEBUG_RELAX & 2)
	  fprintf (stderr,
		   "relax_delete: defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
		   sec->name, h->root.root.string, h->root.u.def.value,
		   sec->output_section->vma, sec->output_offset, irel->r_addend);
#endif
	}
	      
      paddr = symval + irel->r_addend;
      
      if ( (symval >= addr + count && symval < toaddr)
	  && (paddr < addr + count || paddr >= toaddr))
	irel->r_addend += count;
      else if (    (symval < addr + count || symval >= toaddr)
	        && (paddr >= addr + count && paddr < toaddr))
	irel->r_addend -= count;
    }

  /* Adjust the local symbols defined in this section.  */
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;

  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);

      if (isym.st_shndx == sec_shndx
	  && isym.st_value >= addr + count
	  && isym.st_value < toaddr)
	{
	  isym.st_value -= count;

	  if (isym.st_value + isym.st_size >= toaddr)
	    isym.st_size += count;	    
	  
	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
	}
      else if (isym.st_shndx == sec_shndx
	       && isym.st_value < addr + count)
	{
	  if (isym.st_value+isym.st_size >= addr + count
	      && isym.st_value+isym.st_size < toaddr)
	    isym.st_size -= count;

	  if (isym.st_value >= addr
	      && isym.st_value <  addr + count)
	    isym.st_value = addr;

	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  esym = extsyms + symtab_hdr->sh_info;
  esymend = extsyms + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));

  for (index = 0; esym < esymend; esym ++, index ++)
    {
      Elf_Internal_Sym isym;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
      sym_hash = elf_sym_hashes (abfd) [index];

      if (isym.st_shndx == sec_shndx
	  && ((sym_hash)->root.type == bfd_link_hash_defined
	      || (sym_hash)->root.type == bfd_link_hash_defweak)
	  && (sym_hash)->root.u.def.section == sec
	  && (sym_hash)->root.u.def.value >= addr + count
	  && (sym_hash)->root.u.def.value < toaddr)
	{
	  if ((sym_hash)->root.u.def.value + isym.st_size >= toaddr)
	    {
	      isym.st_size += count;
	      bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
	    }

	  (sym_hash)->root.u.def.value -= count;
	}
      else if (isym.st_shndx == sec_shndx
	       && ((sym_hash)->root.type == bfd_link_hash_defined
		   || (sym_hash)->root.type == bfd_link_hash_defweak)
	       && (sym_hash)->root.u.def.section == sec
	       && (sym_hash)->root.u.def.value < addr + count)
	{
	  if ((sym_hash)->root.u.def.value+isym.st_size >= addr + count
	      && (sym_hash)->root.u.def.value+isym.st_size < toaddr)
	    isym.st_size -= count;

	  if ((sym_hash)->root.u.def.value >= addr
	      && (sym_hash)->root.u.def.value < addr + count)
	    (sym_hash)->root.u.def.value = addr;

	  bfd_elf32_swap_symbol_out (abfd, & isym, shndx, esym);
	}

      if (shndx)
	++ shndx;
    }

  return true;
}

#define NOP_OPCODE 	(0x0000)
#define MOVHI	    	0x0640				/* 4byte */ 
#define MOVHI_MASK  	0x07e0
#define MOVHI_R1(insn)	((insn) & 0x1f)			/* 4byte */ 
#define MOVHI_R2(insn)	((insn) >> 11)
#define MOVEA	    	0x0620				/* 2byte */
#define MOVEA_MASK  	0x07e0
#define MOVEA_R1(insn)	((insn) & 0x1f)
#define MOVEA_R2(insn)	((insn) >> 11)
#define JARL_4	    	0x00040780				/* 4byte */
#define JARL_4_MASK 	0xFFFF07FF
#define JARL_R2(insn)	(int)(((insn) & (~JARL_4_MASK)) >> 11)
#define ADD_I       	0x0240					/* 2byte */
#define ADD_I_MASK  	0x07e0
#define ADD_I5(insn)	((((insn) & 0x001f) << 11) >> 11)	/* 2byte */
#define ADD_R2(insn)	((insn) >> 11)
#define JMP_R	    	0x0060					/* 2byte */
#define JMP_R_MASK 	0xFFE0
#define JMP_R1(insn)	((insn) & 0x1f)

static boolean 
v850_elf_relax_section (abfd, sec, link_info, again)
     bfd *			abfd;
     asection *			sec;
     struct bfd_link_info *	link_info;
     boolean *			again;
{
  Elf_Internal_Shdr *	    symtab_hdr;
  Elf_Internal_Rela *	    internal_relocs;
  Elf_Internal_Rela *	    free_relocs = NULL;
  Elf_Internal_Rela *	    irel;
  Elf_Internal_Rela *	    irelend;
  Elf_Internal_Rela *	    irelalign = NULL;
  bfd_byte *		    contents = NULL;
  bfd_byte *		    free_contents = NULL;
  Elf32_External_Sym *	    extsyms = NULL;
  Elf32_External_Sym *	    free_extsyms = NULL;
  bfd_vma 		    addr = 0;
  bfd_vma		    toaddr;
  int 			    align_pad_size = 0;
  Elf_Internal_Shdr *       shndx_hdr = NULL;
  Elf_External_Sym_Shndx *  shndx_buf = NULL;
  
  * again = false;

  if (link_info->relocateable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return true;

  /* If this is the first time we have been called
     for this section, initialize the cooked size.  */
  if (sec->_cooked_size == 0)
    sec->_cooked_size = sec->_raw_size;

  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;

  internal_relocs = (_bfd_elf32_link_read_relocs
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  irelend = internal_relocs + sec->reloc_count;
  
  while (addr < sec->_cooked_size)
    {
      toaddr = sec->_cooked_size;

      for (irel = internal_relocs; irel < irelend; irel ++)
	if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN
	    && irel->r_offset > addr
	    && irel->r_offset < toaddr)
	  toaddr = irel->r_offset;
      
#ifdef DEBUG_RELAX
      fprintf (stderr, "relax region 0x%x to 0x%x align pad %d\n",
	       addr, toaddr, align_pad_size);
#endif
      if (irelalign)
	{
	  bfd_vma alignto;
	  bfd_vma alignmoveto;

	  alignmoveto = BFD_ALIGN (addr - align_pad_size, 1 << irelalign->r_addend);
	  alignto = BFD_ALIGN (addr, 1 << irelalign->r_addend);

	  if (alignmoveto < alignto)
	    {
	      unsigned int i;

	      align_pad_size = alignto - alignmoveto;
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax move region 0x%x to 0x%x delete size 0x%x\n",
		       alignmoveto, toaddr, align_pad_size);
#endif
	      if (!v850_elf_relax_delete_bytes (abfd, sec, alignmoveto,
						toaddr, align_pad_size))
		goto error_return;		

	      for (i  = BFD_ALIGN (toaddr - align_pad_size, 1);
		   (i + 1) < toaddr; i += 2)
		bfd_put_16 (abfd, NOP_OPCODE, contents + i);

	      addr = alignmoveto;
	    }
	  else
	    align_pad_size = 0;
	}

      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  bfd_vma 	      laddr;
	  bfd_vma	      addend;
	  bfd_vma	      symval;
	  int 		      insn[5];
	  int 		      no_match = -1;
	  Elf_Internal_Rela * hi_irelfn;
	  Elf_Internal_Rela * lo_irelfn;
	  Elf_Internal_Rela * irelcall;
	  bfd_signed_vma      foff;

	  if (! (irel->r_offset >= addr && irel->r_offset < toaddr
		 && (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGCALL
		     || ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGJUMP)))
	    continue;

#ifdef DEBUG_RELAX
	  fprintf (stderr, "relax check r_info 0x%x r_offset 0x%x r_addend 0x%x\n",
		   irel->r_info,
		   irel->r_offset,
		   irel->r_addend );
#endif

	  /* Get the section contents.  */
	  if (contents == NULL)
	    {
	      if (elf_section_data (sec)->this_hdr.contents != NULL)
		contents = elf_section_data (sec)->this_hdr.contents;
	      else
		{
		  contents = (bfd_byte *) bfd_malloc (sec->_raw_size);
		  if (contents == NULL)
		    goto error_return;

		  free_contents = contents;

		  if (! bfd_get_section_contents (abfd, sec, contents,
						  (file_ptr) 0, sec->_raw_size))
		    goto error_return;
		}
	    }

	  /* Read this BFD's symbols if we haven't done so already.  */
	  if (extsyms == NULL)
	    {
	      /* Get cached copy if it exists.  */
	      if (symtab_hdr->contents != NULL)
		extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	      else
		{
		  /* Go get them off disk.  */
		  bfd_size_type amt;

		  amt = symtab_hdr->sh_info;
		  amt *= sizeof (Elf32_External_Sym);
		  extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
		  if (extsyms == NULL)
		    goto error_return;
		  free_extsyms = extsyms;
		  if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		      || bfd_bread ((PTR) extsyms, amt, abfd) != amt)
		    goto error_return;
		}

	      if (shndx_hdr->sh_size != 0)
		{
		  bfd_size_type amt;

		  amt = symtab_hdr->sh_info;
		  amt *= sizeof (Elf_External_Sym_Shndx);
		  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
		  if (shndx_buf == NULL)
		    goto error_return;
		  if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		      || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		    goto error_return;
		}
	    }

	  laddr = irel->r_offset;

	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGCALL)
	    {
	      /* Check code for -mlong-calls output. */
	      if (laddr + 16 <= (bfd_vma) sec->_raw_size)
		{
		  insn[0] = bfd_get_16 (abfd, contents + laddr);
		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
		  insn[2] = bfd_get_32 (abfd, contents + laddr + 8);
		  insn[3] = bfd_get_16 (abfd, contents + laddr + 12);
		  insn[4] = bfd_get_16 (abfd, contents + laddr + 14);
	  
		  if ((insn[0] & MOVHI_MASK) != MOVHI
		       || MOVHI_R1 (insn[0]) != 0)
		    no_match = 0;

		  if (no_match < 0
		      && ((insn[1] & MOVEA_MASK) != MOVEA
			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
		    no_match = 1;

		  if (no_match < 0
		      && (insn[2] & JARL_4_MASK) != JARL_4)
		    no_match = 2;

		  if (no_match < 0
		      && ((insn[3] & ADD_I_MASK) != ADD_I
			   || ADD_I5 (insn[3]) != 4
			   || JARL_R2 (insn[2]) != ADD_R2 (insn[3])))
		    no_match = 3;

		  if (no_match < 0
		      && ((insn[4] & JMP_R_MASK) != JMP_R
			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[4])))
		    no_match = 4;
		}
	      else
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized insns",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));

		  continue;
		}

	      if (no_match >= 0)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized insn 0x%x",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));

		  continue;
		}      

	      /* Get the reloc for the address from which the register is
	         being loaded.  This reloc will tell us which function is
	         actually being called.  */
	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
		if (hi_irelfn->r_offset == laddr + 2
		    && ELF32_R_TYPE (hi_irelfn->r_info) 
		        == (int) R_V850_HI16_S)
		  break;

	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
		if (lo_irelfn->r_offset == laddr + 6
		    && ELF32_R_TYPE (lo_irelfn->r_info)
		        == (int) R_V850_LO16)
		  break;

	      for (irelcall = internal_relocs; irelcall < irelend; irelcall ++)
		if (irelcall->r_offset == laddr + 8
		    && ELF32_R_TYPE (irelcall->r_info)
                        == (int) R_V850_22_PCREL)
		  break;

	      if (   hi_irelfn == irelend
		  || lo_irelfn == irelend
		  || irelcall  == irelend)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized reloc",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));

		  continue;
		}
	
	      if (ELF32_R_SYM (irelcall->r_info) < symtab_hdr->sh_info)
		{
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;

		  /* A local symbol.  */
		  r_index = ELF32_R_SYM (irelcall->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);

		  if (isym.st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym.st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym.st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = isym.st_value;
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry * h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (irelcall->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = h->root.u.def.value;
		}

	      if (symval + irelcall->r_addend != irelcall->r_offset + 4)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGCALL points to unrecognized reloc 0x%lx",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset, irelcall->r_offset ));

		  continue;
		}

	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		{
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;

		  /* A local symbol.  */
		  r_index = ELF32_R_SYM (irel->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
          
		  if (isym.st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym.st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym.st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = (isym.st_value
			    + sym_sec->output_section->vma
			    + sym_sec->output_offset);
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry * h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
		}

	      addend = irel->r_addend;

	      foff = (symval + addend
		      - (irel->r_offset
			 + sec->output_section->vma
			 + sec->output_offset
			 + 4));
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax longcall r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
		       irel->r_offset,
		       (irel->r_offset
			+ sec->output_section->vma
			+ sec->output_offset),
		       symval, addend, foff);
#endif

	      if (foff < -0x100000 || foff >= 0x100000)
		/* After all that work, we can't shorten this function call.  */
		continue;

	      /* For simplicity of coding, we are going to modify the section
	         contents, the section relocs, and the BFD symbol table.  We
	         must tell the rest of the code not to free up this
	         information.  It would be possible to instead create a table
	         of changes which have to be made, as is done in coff-mips.c;
	         that would be more work, but would require less memory when
	         the linker is run.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      free_relocs = NULL;

	      elf_section_data (sec)->this_hdr.contents = contents;
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;
      
	      /* Replace the long call with a jarl.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_22_PCREL);

	      addend = 0;

	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		/* If this needs to be changed because of future relaxing,
		   it will be handled here like other internal IND12W
		   relocs.  */
		bfd_put_32 (abfd,
			    0x00000780 | (JARL_R2 (insn[2])<<11) | ((addend << 16) & 0xffff) | ((addend >> 16) & 0xf),
			    contents + irel->r_offset);
	      else
		/* We can't fully resolve this yet, because the external
		   symbol value may be changed by future relaxing.
		   We let the final link phase handle it.  */
		bfd_put_32 (abfd, 0x00000780 | (JARL_R2 (insn[2])<<11),
			    contents + irel->r_offset);

	      hi_irelfn->r_info = 
		ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
	      lo_irelfn->r_info =
		ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
	      irelcall->r_info =
		ELF32_R_INFO (ELF32_R_SYM (irelcall->r_info), R_V850_NONE);

	      if (! v850_elf_relax_delete_bytes (abfd, sec,
						 irel->r_offset + 4, toaddr, 12))
		goto error_return;

	      align_pad_size += 12;
	    }
	  else if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_LONGJUMP)
	    {
	      /* Check code for -mlong-jumps output.  */
	      if (laddr + 10 <= (bfd_vma) sec->_raw_size)
		{
		  insn[0] = bfd_get_16 (abfd, contents + laddr);
		  insn[1] = bfd_get_16 (abfd, contents + laddr + 4);
		  insn[2] = bfd_get_16 (abfd, contents + laddr + 8);

		  if ((insn[0] & MOVHI_MASK) != MOVHI
		       || MOVHI_R1 (insn[0]) != 0)
		    no_match = 0;

		  if (no_match < 0
		      && ((insn[1] & MOVEA_MASK) != MOVEA
			   || MOVHI_R2 (insn[0]) != MOVEA_R1 (insn[1])))
		    no_match = 1;

		  if (no_match < 0
		      && ((insn[2] & JMP_R_MASK) != JMP_R
			   || MOVEA_R2 (insn[1]) != JMP_R1 (insn[2])))
		    no_match = 4;
		}
	      else
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized insns",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset));

		  continue;
		}

	      if (no_match >= 0)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized insn 0x%x",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset+no_match, insn[no_match]));

		  continue;
		}

	      /* Get the reloc for the address from which the register is
	         being loaded.  This reloc will tell us which function is
	         actually being called.  */
	      for (hi_irelfn = internal_relocs; hi_irelfn < irelend; hi_irelfn ++)
		if (hi_irelfn->r_offset == laddr + 2
		    && ELF32_R_TYPE (hi_irelfn->r_info) == (int) R_V850_HI16_S) 
		  break;

	      for (lo_irelfn = internal_relocs; lo_irelfn < irelend; lo_irelfn ++)
		if (lo_irelfn->r_offset == laddr + 6
		    && ELF32_R_TYPE (lo_irelfn->r_info) == (int) R_V850_LO16)
		  break;

	      if (   hi_irelfn == irelend
		  || lo_irelfn == irelend)
		{
		  ((*_bfd_error_handler)
		   ("%s: 0x%lx: warning: R_V850_LONGJUMP points to unrecognized reloc",
		    bfd_get_filename (abfd), (unsigned long) irel->r_offset ));

		  continue;
		}
	
	      /* Get the value of the symbol referred to by the reloc.  */
	      if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		{
		  unsigned int		   r_index;
		  Elf_Internal_Sym         isym;
		  asection *               sym_sec;
		  Elf32_External_Sym *     esym;
		  Elf_External_Sym_Shndx * shndx;

		  /* A local symbol.  */
		  r_index = ELF32_R_SYM (irel->r_info);
		  esym = extsyms + r_index;
		  shndx = shndx_buf + (shndx_buf ? r_index : 0);
		  bfd_elf32_swap_symbol_in (abfd, esym, shndx, & isym);
	  
		  if (isym.st_shndx == SHN_UNDEF)
		    sym_sec = bfd_und_section_ptr;
		  else if (isym.st_shndx == SHN_ABS)
		    sym_sec = bfd_abs_section_ptr;
		  else if (isym.st_shndx == SHN_COMMON)
		    sym_sec = bfd_com_section_ptr;
		  else
		    sym_sec = bfd_section_from_elf_index (abfd, isym.st_shndx);
		  symval = (isym.st_value
			    + sym_sec->output_section->vma
			    + sym_sec->output_offset);
#ifdef DEBUG_RELAX
		  {
		    char * name = bfd_elf_string_from_elf_section
		      (abfd, symtab_hdr->sh_link, isym.st_name);

		    fprintf (stderr, "relax long jump local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
			     sym_sec->name, name, isym.st_name,
			     sym_sec->output_section->vma, sym_sec->output_offset,
			     isym.st_value, irel->r_addend);
		  }
#endif
		}
	      else
		{
		  unsigned long indx;
		  struct elf_link_hash_entry * h;

		  /* An external symbol.  */
		  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
		  h = elf_sym_hashes (abfd)[indx];
		  BFD_ASSERT (h != NULL);

		  if (   h->root.type != bfd_link_hash_defined
		      && h->root.type != bfd_link_hash_defweak)
		    /* This appears to be a reference to an undefined
		       symbol.  Just ignore it--it will be caught by the
		       regular reloc processing.  */
		    continue;

		  symval = (h->root.u.def.value
			    + h->root.u.def.section->output_section->vma
			    + h->root.u.def.section->output_offset);
#ifdef DEBUG_RELAX
		  fprintf (stderr,
			   "relax longjump defined: sec: %s, name: %s, value: %x + %x + %x addend %x\n",
			   sec->name, h->root.root.string, h->root.u.def.value,
			   sec->output_section->vma, sec->output_offset, irel->r_addend);
#endif
		}

	      addend = irel->r_addend;

	      foff = (symval + addend
		      - (irel->r_offset
			 + sec->output_section->vma
			 + sec->output_offset
			 + 4));
#ifdef DEBUG_RELAX
	      fprintf (stderr, "relax longjump r_offset 0x%x ptr 0x%x symbol 0x%x addend 0x%x distance 0x%x\n",
		       irel->r_offset,
		       (irel->r_offset
			+ sec->output_section->vma
			+ sec->output_offset),
		       symval, addend, foff);
#endif
	      if (foff < -0x100000 || foff >= 0x100000)
		/* After all that work, we can't shorten this function call.  */
		continue;

	      /* For simplicity of coding, we are going to modify the section
	         contents, the section relocs, and the BFD symbol table.  We
	         must tell the rest of the code not to free up this
	         information.  It would be possible to instead create a table
	         of changes which have to be made, as is done in coff-mips.c;
	         that would be more work, but would require less memory when
	         the linker is run.  */
	      elf_section_data (sec)->relocs = internal_relocs;
	      free_relocs = NULL;

	      elf_section_data (sec)->this_hdr.contents = contents;
	      free_contents = NULL;

	      symtab_hdr->contents = (bfd_byte *) extsyms;
	      free_extsyms = NULL;

	      if (foff < -0x100 || foff >= 0x100)
		{
		  /* Replace the long jump with a jr.  */

		  irel->r_info =
			ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_22_PCREL);
  
		  irel->r_addend = addend;
		  addend = 0;

		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		    /* If this needs to be changed because of future relaxing,
		       it will be handled here like other internal IND12W
		       relocs.  */
		    bfd_put_32 (abfd,
				0x00000780 | ((addend << 15) & 0xffff0000) | ((addend >> 17) & 0xf),
				contents + irel->r_offset);
		  else
		    /* We can't fully resolve this yet, because the external
		       symbol value may be changed by future relaxing.
		       We let the final link phase handle it.  */
		    bfd_put_32 (abfd, 0x00000780, contents + irel->r_offset);

		  hi_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
		  lo_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
		  if (!v850_elf_relax_delete_bytes (abfd, sec,
						    irel->r_offset + 4, toaddr, 6))
		    goto error_return;

		  align_pad_size += 6;
		}
	      else
		{
		  /* Replace the long jump with a br.  */

		  irel->r_info =
			ELF32_R_INFO (ELF32_R_SYM (irel->r_info), R_V850_9_PCREL);

		  irel->r_addend = addend;
		  addend = 0;

		  if (ELF32_R_SYM (hi_irelfn->r_info) < symtab_hdr->sh_info)
		    /* If this needs to be changed because of future relaxing,
		       it will be handled here like other internal IND12W
		       relocs.  */
		    bfd_put_16 (abfd,
				0x0585 | ((addend << 10) & 0xf800) | ((addend << 3) & 0x0070),
				contents + irel->r_offset);
		  else
		    /* We can't fully resolve this yet, because the external
		       symbol value may be changed by future relaxing.
		       We let the final link phase handle it.  */
		    bfd_put_16 (abfd, 0x0585, contents + irel->r_offset);

		  hi_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (hi_irelfn->r_info), R_V850_NONE);
		  lo_irelfn->r_info =
			ELF32_R_INFO (ELF32_R_SYM (lo_irelfn->r_info), R_V850_NONE);
		  if (!v850_elf_relax_delete_bytes (abfd, sec,
						    irel->r_offset + 2, toaddr, 8))
		    goto error_return;

		  align_pad_size += 8;
		}
	    }
	}

      irelalign = NULL;
      for (irel = internal_relocs; irel < irelend; irel++)
	{
	  if (ELF32_R_TYPE (irel->r_info) == (int) R_V850_ALIGN
	      && irel->r_offset == toaddr)
	    {
	      irel->r_offset -= align_pad_size;

	      if (irelalign == NULL || irelalign->r_addend > irel->r_addend)
		irelalign = irel;
	    }
	}

      addr = toaddr;
    }

  if (!irelalign)
    {
#ifdef DEBUG_RELAX
      fprintf (stderr, "relax pad %d shorten %d -> %d\n",
	       align_pad_size,
	       sec->_cooked_size,
	       sec->_cooked_size - align_pad_size);
#endif
      sec->_cooked_size -= align_pad_size;
    }

  return true;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);

  if (free_contents != NULL)
    free (free_contents);

  if (free_extsyms != NULL)
    free (free_extsyms);

  return false;
}
a2200 1
#define bfd_elf32_bfd_relax_section		v850_elf_relax_section
@


1.20.10.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d1334 4
a1424 5
/* We overload some of the bfd_reloc error codes for own purposes.  */
#define bfd_reloc_gp_not_found		bfd_reloc_other
#define bfd_reloc_ep_not_found		bfd_reloc_continue
#define bfd_reloc_ctbp_not_found	(bfd_reloc_dangerous + 1)

d1499 1
a1499 1
	  return bfd_reloc_gp_not_found;
d1524 2
a1525 1
	  return bfd_reloc_ep_not_found;
d1544 2
a1545 1
	  return bfd_reloc_ctbp_not_found;
d1566 1
a1566 1
	  return bfd_reloc_ctbp_not_found;
d1765 1
a1765 1
	    case bfd_reloc_gp_not_found:
d1769 1
a1769 1
	    case bfd_reloc_ep_not_found:
d1773 1
a1773 1
	    case bfd_reloc_ctbp_not_found:
d1851 2
a1852 6
    case E_V850_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850);
      break;
    case E_V850E_ARCH:
      bfd_default_set_arch_mach (abfd, bfd_arch_v850, bfd_mach_v850e);
      break;
d1868 3
a1870 3
    default:		 
    case bfd_mach_v850:  val = E_V850_ARCH; break;
    case bfd_mach_v850e: val = E_V850E_ARCH; break;
d2484 1
a2487 1
  Elf_Internal_Sym *	    isymbuf = NULL;
d2489 3
d2495 3
a2497 2
  boolean                   result = true;

d2517 2
d2602 2
d2610 2
a2611 2
	  /* Read this BFD's local symbols if we haven't done so already.  */
	  if (isymbuf == NULL && symtab_hdr->sh_info != 0)
d2613 32
a2644 7
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
d2736 5
a2740 1
		  Elf_Internal_Sym *  isym;
d2743 4
a2746 1
		  isym = isymbuf + ELF32_R_SYM (irelcall->r_info);
d2748 9
a2756 1
		  symval = isym->st_value;
d2790 5
a2794 2
		  Elf_Internal_Sym * isym;
		  asection *         sym_sec;
d2797 4
a2800 1
		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);
d2802 1
a2802 1
		  if (isym->st_shndx == SHN_UNDEF)
d2804 1
a2804 1
		  else if (isym->st_shndx == SHN_ABS)
d2806 1
a2806 1
		  else if (isym->st_shndx == SHN_COMMON)
d2809 2
a2810 2
		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  symval = (isym->st_value
d2820 1
a2820 1
		  indx = ELF32_R_SYM (hi_irelfn->r_info) - symtab_hdr->sh_info;
d2864 2
d2867 4
a2870 1
	      symtab_hdr->contents = (bfd_byte *) isymbuf;
d2971 5
a2975 2
		  Elf_Internal_Sym *  isym;
		  asection *          sym_sec;
d2978 6
a2983 3
		  isym = isymbuf + ELF32_R_SYM (hi_irelfn->r_info);

		  if (isym->st_shndx == SHN_UNDEF)
d2985 1
a2985 1
		  else if (isym->st_shndx == SHN_ABS)
d2987 1
a2987 1
		  else if (isym->st_shndx == SHN_COMMON)
d2990 2
a2991 2
		    sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  symval = (isym->st_value
d2997 1
a2997 1
		      (abfd, symtab_hdr->sh_link, isym->st_name);
d3000 3
a3002 4
			     sym_sec->name, name, isym->st_name,
			     sym_sec->output_section->vma,
			     sym_sec->output_offset,
			     isym->st_value, irel->r_addend);
d3061 2
d3064 4
a3067 1
	      symtab_hdr->contents = (bfd_byte *) isymbuf;
d3165 1
a3165 12
 finish:
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != (unsigned char *) contents)
    free (contents);

  if (isymbuf != NULL
      && symtab_hdr->contents != (bfd_byte *) isymbuf)
    free (isymbuf);
d3167 6
a3172 1
  return result;
d3174 4
a3177 3
 error_return:
  result = false;
  goto finish;
@


1.20.10.6
log
@merge from mainline
@
text
@d2391 1
a2391 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2404 1
a2404 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2429 1
a2429 1
	      bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
d2448 1
a2448 1
	  bfd_elf32_swap_symbol_out (abfd, & isym, esym, shndx);
@


1.20.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d82 1
a82 1
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d2138 1
a2138 1
     const char *        name;
@


1.19
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d72 1
a72 1
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *, int *));
d1933 1
a1933 1
v850_elf_section_from_bfd_section (abfd, hdr, sec, retval)
a1934 1
     Elf32_Internal_Shdr * hdr ATTRIBUTE_UNUSED;
@


1.18
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a66 2
static boolean v850_elf_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
a1832 22
/* Copy backend specific data from one object module to another.  */

static boolean
v850_elf_copy_private_bfd_data (ibfd, obfd)
     bfd * ibfd;
     bfd * obfd;
{
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;

  return true;
}

a2216 1
#define bfd_elf32_bfd_copy_private_bfd_data 	v850_elf_copy_private_bfd_data
@


1.17
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1777 3
a1779 8
       if (!(elf_bad_symtab (abfd)
           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
                && sym->st_shndx != SHN_COMMON))
          {
            return bfd_section_from_elf_index (abfd, sym->st_shndx);
          }
      }
d1983 1
a1983 1
  unsigned short index;
d1985 1
a1985 1
  index = elfsym->internal_elf_sym.st_shndx;
d1993 2
a1994 2
  if (index < elf_elfheader(abfd)[0].e_shnum)
    switch (elf_elfsections(abfd)[index]->sh_type)
d1997 1
a1997 1
	index = SHN_V850_SCOMMON;
d2001 1
a2001 1
	index = SHN_V850_TCOMMON;
d2005 1
a2005 1
	index = SHN_V850_ZCOMMON;
d2012 1
a2012 1
  switch (index)
d2083 1
a2083 1
  int index = sym->st_shndx;
d2091 2
a2092 2
  if (index < elf_elfheader(abfd)[0].e_shnum)
    switch (elf_elfsections(abfd)[index]->sh_type)
d2095 1
a2095 1
	index = SHN_V850_SCOMMON;
d2099 1
a2099 1
	index = SHN_V850_TCOMMON;
d2103 1
a2103 1
	index = SHN_V850_ZCOMMON;
d2110 1
a2110 1
  switch (index)
@


1.16
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d1600 1
a1600 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.15
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d593 1
a593 1
	   bfd_get_filename (abfd));
d1909 1
a1909 1
			bfd_get_filename (ibfd));
@


1.14
log
@* elf.c (prep_headers): Get the machine code from the elf
backend data.
* elf-m10200.c (ELF_MACHINE_CODE): Redefine to EM_MN10200.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10200.
* elf-m10300.c (ELF_MACHINE_CODE): Redefine to EM_MN10300.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10300.
* elf-arc.c (arc_elf_final_write_processing): Don't override
e_machine, it's now properly set in prep_headers.
* elf32-avr.c (elf32_avr_object_p): Accept both EM_AVR and
EM_AVR_OLD.
(ELF_MACHINE_ALT1): Define to EM_AVR_OLD.
* elf-d10v.c (ELF_MACHINE_CODE): Redefine to EM_D10V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D10V.
* elf-d30v.c (ELF_MACHINE_CODE): Redefine to EM_D30V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D30V.
* elf-fr30.c (ELF_MACHINE_CODE): Redefine to EM_FR30.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_FR30.
* elf-m32r.c (ELF_MACHINE_CODE): Redefine to EM_M32R.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_M32R.
* elf32-pj.c (ELF_MACHINE_ALT1): DEfine to EM_PJ_OLD.
* elf-v850.c (ELF_MACHINE_CODE): Redefine to EM_V850.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_V850.
@
text
@d33 1
a33 1
#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
d49 1
a49 1
  PARAMS ((bfd *, int, bfd_vma, bfd_byte *));
d527 1
a527 1
	
d702 2
a703 1
					    abfd, h->root.u.def.section, 0);
d768 1
d772 1
a772 1
    free_hi16s = (hi16s_location *) bfd_zalloc (abfd, sizeof (* free_hi16s));
d842 4
a845 4
     bfd *      abfd;
     int        r_type;
     bfd_vma    addend;
     bfd_byte * address;
d870 1
a870 1
      bfd_put_32 (abfd, insn, address);
d1069 1
a1069 1
		    bfd_put_16 (abfd, insn, hi16s_address);
d1135 1
a1135 1
      insn = (addend & ~1) | (insn & 1);
d1224 1
a1224 1
      insn |= (addend & ~1) << 16;
d1226 1
a1226 1
      bfd_put_32 (abfd, insn, address);
d1251 1
a1251 1
  bfd_put_16 (abfd, insn, address);
d1320 1
a1320 1
	_start:         
d1368 1
a1368 1
  unsigned long  r_type   = howto->type;
d1540 2
a1541 1
	(info, "no hash table available", NULL, input_bfd, input_section, 0);
@


1.13
log
@Add missing prototypes
@
text
@d2221 2
a2222 1
#define ELF_MACHINE_CODE			EM_CYGNUS_V850
@


1.12
log
@Fix bug in previous delta
@
text
@d481 1
a481 1
  unsigned char elf_reloc_val;
d526 1
a526 1
	int elf_reloc_val = v850_elf_reloc_map[i].elf_reloc_val;
@


1.11
log
@Add missing prototypes.  Fix formatting.
@
text
@d526 3
a528 1
	BFD_ASSERT (v850_elf_howto_table[code].type == v850_elf_reloc_map[i].elf_reloc_val);
d530 1
a530 1
	return v850_elf_howto_table + code;
@


1.10
log
@Update copyright notices
@
text
@d30 1
d32 1
a32 1
/* sign-extend a 24-bit number */
d85 7
d93 2
a94 2
/* Note: It is REQUIRED that the 'type' value of each entry in this array
   match the index of the entry in the array.  */
d514 2
a515 1
/* Map a bfd relocation into the appropriate howto structure */
d523 4
a526 7
  for (i = 0;
       i < sizeof (v850_elf_reloc_map) / sizeof (struct v850_elf_reloc_map);
       i++)
    {
      if (v850_elf_reloc_map[i].bfd_reloc_val == code)
	{
	  BFD_ASSERT (v850_elf_howto_table[v850_elf_reloc_map[i].elf_reloc_val].type == v850_elf_reloc_map[i].elf_reloc_val);
d528 2
a529 3
	  return & v850_elf_howto_table[v850_elf_reloc_map[i].elf_reloc_val];
	}
    }
d535 1
d635 2
a636 2
        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
d671 2
a672 1
	      h->other |= other;	/* flag which type of relocation was used */
d712 3
a714 1
	      asection *section = h->root.u.c.p->section = bfd_make_section_old_way (abfd, common);
d731 12
a742 14
/*
 * In the old version, when an entry was checked out from the table,
 * it was deleted.  This produced an error if the entry was needed
 * more than once, as the second attempted retry failed.
 *
 * In the current version, the entry is not deleted, instead we set
 * the field 'found' to true.  If a second lookup matches the same
 * entry, then we know that the hi16s reloc has already been updated
 * and does not need to be updated a second time.
 *
 * TODO - TOFIX: If it is possible that we need to restore 2 different
 * addresses from the same table entry, where the first generates an
 * overflow, whilst the second do not, then this code will fail.
 */
d835 1
d1040 1
a1040 3
	     0x00006fff   which is wrong (assuming that fred is at 0xffff)
	 */

d1252 1
d1268 1
a1268 1
         or the addend is zero, so there is nothing to add into the instruction
d1280 1
a1280 3
    {
      return bfd_reloc_continue;
    }
d1322 1
a1322 2
        	nop
      */
d1329 1
a1329 1
      /* Deal with pcrel_offset */
d1347 1
d1385 2
a1386 1
      value = SEXT24 (value);  /* Only the bottom 24 bits of the PC are valid */
d1445 2
a1446 1
	  return bfd_reloc_continue;  /* Actually this indicates that __ep could not be found.  */
d1465 2
a1466 1
	  return (bfd_reloc_dangerous + 1);  /* Actually this indicates that __ctbp could not be found.  */
d1512 1
d1601 1
d1604 3
a1606 3
fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
	 sec->name, name, sym->st_name,
	 sec->output_section->vma, sec->output_offset, sym->st_value, rel->r_addend);
d1626 2
a1627 2
fprintf (stderr, "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n",
	 sec->name, h->root.root.string, h->root.u.def.value, sec->output_section->vma, sec->output_offset, relocation);
d1633 2
a1634 2
fprintf (stderr, "undefined: sec: %s, name: %s\n",
	 sec->name, h->root.root.string);
d1645 1
a1645 1
fprintf (stderr, "unknown: name: %s\n", h->root.root.string);
d1651 1
a1651 2
      /* FIXME: We should use the addend, but the COFF relocations
         don't.  */
d1737 1
a1737 1
  /* No got and plt entries for v850-elf */
d1784 1
d1786 1
d1802 1
d1823 1
d1837 2
a1838 1
/* Copy backend specific data from one object module to another */
d1855 1
d1859 2
a1860 2
/* Merge backend specific data from an object file to the output
   object file when linking.  */
d1892 1
a1892 3
	{
	  return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
	}
d1908 2
a1909 1
/* Display the flags field */
d1955 2
a1956 2
/* Given a BFD section, try to locate the corresponding ELF section
   index.  */
a2135 1
/*ARGSIGNORED*/
d2189 3
a2191 2
/* Set the correct type for a V850 ELF section.  We do this by the
   section name, which is a hack, but ought to work.  */
@


1.9
log
@Do not convert reloc addend to PC rel, it will be handled later on.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.8
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d1303 15
d1327 1
a1327 1

@


1.8.2.1
log
@Do not convert reloc addend to PC rel, it will be handled later on.
@
text
@a1302 15
#if 0 /* Since this reloc is going to be processed later on, we should
	 not make it pc-relative here.  To test this, try assembling and
	 linking this program:

	 	.text
		.globl _start
		nop
	_start:         
        	jr foo

	        .section ".foo","ax"
		nop
	foo:
        	nop
      */
a1311 1
#endif
@


1.8.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d1328 1
@


1.7
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@a503 1

a526 1

a554 1

a1242 1

a1315 1

a1324 1

a1485 1

a2184 1

@


1.6
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@a19 2


a22 1

d32 1
a32 1
      
d103 1
a103 1
  /* A PC relative 9 bit branch. */
d118 1
a118 1
  /* A PC relative 22 bit branch. */
d312 1
a312 1
  
d462 1
a462 1
 
d521 1
a521 1
	  
d544 1
a544 1
/* Set the howto pointer for a V850 ELF reloc (type RELA). */
d644 1
a644 1
	  
d651 1
a651 1
	  
d760 1
a760 1
  
d767 1
a767 1
  
d774 1
a774 1
  
d784 1
a784 1
  
d798 1
a798 1
  
d808 1
a808 1
      
d824 1
a824 1
  
d826 1
a826 1
}     
d839 1
a839 1
  
d845 1
a845 1
      
d849 1
a849 1
      
d853 1
a853 1
      
d856 1
a856 1
      
d862 1
a862 1
      
d866 1
a866 1
      
d869 1
a869 1
      
d874 1
a874 1
      
d880 1
a880 1
      
d887 2
a888 2
      
      /* This relocation cannot overflow. */
d891 1
a891 1
      
d894 1
a894 1
      
a971 1
	 
d1006 1
a1006 1
	   
d1045 1
a1045 1
	
d1053 1
a1053 1
	    
d1070 1
a1070 1
	
d1080 1
a1080 1
      
d1089 1
a1089 1
      
d1091 1
a1091 1
      
d1097 1
a1097 1
      
d1100 1
a1100 1
      /* drop through */            
d1105 1
a1105 1
      
d1107 1
a1107 1
      
d1113 1
a1113 1
      
d1118 1
a1118 1
      
d1120 1
a1120 1
      
d1123 1
a1123 1
      
d1126 1
a1126 1
      
d1129 1
a1129 1
      
d1133 1
a1133 1
      
d1135 1
a1135 1
      
d1138 1
a1138 1
      
d1141 1
a1141 1
      
d1145 1
a1145 1
      
d1149 1
a1149 1
      
d1151 1
a1151 1
      
d1154 1
a1154 1
      
d1157 1
a1157 1
      
d1161 1
a1161 1
      
d1165 1
a1165 1
	
d1167 1
a1167 1
      
d1170 1
a1170 1
      
d1174 1
a1174 1
      
d1178 1
a1178 1
      
d1180 1
a1180 1
      
d1183 1
a1183 1
      
d1186 1
a1186 1
      
d1190 1
a1190 1
      
d1194 1
a1194 1
      
d1196 1
a1196 1
      
d1199 1
a1199 1
      
d1203 1
a1203 1
      
d1208 1
a1208 1
      
d1210 1
a1210 1
      
d1213 1
a1213 1
      
d1217 1
a1217 1
      
d1220 1
a1220 1
      
d1224 1
a1224 1
      
d1226 1
a1226 1
      
d1229 1
a1229 1
      
d1232 1
a1232 1
      
d1260 1
a1260 1
  
d1274 1
a1274 1
#if 0  
d1280 1
a1280 1
  
d1292 1
a1292 1
  
d1295 1
a1295 1
  
d1301 1
a1301 1
  
d1306 1
a1306 1
  
d1312 1
a1312 1
      
d1317 1
a1317 1
  reloc->addend = relocation;	
a1321 1
/*ARGSUSED*/
d1360 1
a1360 1
    
d1369 1
a1369 1
      
d1372 1
a1372 1
      
d1381 1
a1381 1
    case R_V850_ZDA_15_16_OFFSET:	
d1386 1
a1386 1
	  
d1399 1
a1399 1
	  
d1424 1
a1424 1
	
d1429 1
a1429 1
	  return bfd_reloc_continue;  /* Actually this indicates that __ep could not be found. */
d1438 1
a1438 1
    
d1443 1
a1443 1
	
d1448 1
a1448 1
	  return (bfd_reloc_dangerous + 1);  /* Actually this indicates that __ctbp could not be found. */
d1456 1
a1456 1
    
d1464 1
a1464 1
	  
d1479 1
a1479 1
      
d1490 1
a1490 1
  return v850_elf_perform_relocation (input_bfd, r_type, value + addend, hit_data); 
d1522 1
a1522 1
  
d1527 1
a1527 1
  
d1594 1
a1594 1
	  
d1598 1
a1598 1
	  
d1694 1
a1694 1
	      
d1801 1
a1801 1
/* Function to keep V850 specific file flags. */
d1862 1
a1862 1
      
d1894 1
a1894 1
  
d1896 1
a1896 1
  
d1898 1
a1898 1
  
d1901 1
a1901 1
  
d1909 1
a1909 1
  
d1911 1
a1911 1
  
a1931 1

d1950 1
a1950 1
  
d1963 1
a1963 1
  
d1969 1
a1969 1
     
d1971 1
a1971 1
  
d1978 1
a1978 1
	
d1982 1
a1982 1
	
d1986 1
a1986 1
	
d1990 1
a1990 1
  
d2010 1
a2010 1
      
a2051 1
/*ARGSUSED*/
d2063 1
a2063 1
  
d2067 1
a2067 1
     
d2069 1
a2069 1
  
d2076 1
a2076 1
	
d2080 1
a2080 1
	
d2084 1
a2084 1
	
d2088 1
a2088 1
  
d2096 1
a2096 1
      
d2102 1
a2102 1
      
d2125 1
a2125 1
  
d2189 1
a2189 1
  
a2192 1

d2199 1
a2199 1
	
a2216 1

@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d1628 1
a1628 1
		      input_section, rel->r_offset)))
d1672 1
a1672 1
		      rel->r_offset)))
@


1.4
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d512 1
a512 1
     bfd *                     abfd;
d536 1
a536 1
     bfd *                 abfd;
d550 1
a550 1
     bfd *                 abfd;
d1255 1
a1255 1
     bfd *       abfd;
d1258 1
a1258 1
     PTR         data;
d1261 1
a1261 1
     char **     err;
d1329 1
a1329 1
     bfd *         abfd;
d1344 1
a1344 1
     bfd *                   output_bfd;
d1352 1
a1352 1
     int                     is_local;
d1719 4
a1722 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1731 1
a1731 1
       struct bfd_link_info *info;
d1790 1
a1790 1
     boolean linker;
d1943 2
a1944 2
     bfd *                 abfd;
     Elf32_Internal_Shdr * hdr;
d2062 1
a2062 1
     struct bfd_link_info *   info;
d2064 2
a2065 2
     const char **            namep;
     flagword *               flagsp;
d2123 3
a2125 3
     bfd *                  abfd;
     struct bfd_link_info * info;
     const char *           name;
d2178 1
a2178 1
     bfd *                 abfd;
@


1.3
log
@Catch overflow in 22_PCREL reloc.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
a799 1
  int              i;
d1753 3
@


1.2
log
@        * elf32-v850.c (v850_elf_howto_table): Make partial_inplace false
        for all relocations.
@
text
@d1372 4
@


1.1
log
@Initial revision
@
text
@d146 1
a146 1
	 true,				/* partial_inplace */
d161 1
a161 1
	 true,				/* partial_inplace */
d176 1
a176 1
	 true,				/* partial_inplace */
d191 1
a191 1
	 true,				/* partial_inplace */
d206 1
a206 1
	 true,				/* partial_inplace */
d221 1
a221 1
	 true,				/* partial_inplace */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

