head	1.63;
access;
symbols
	sid-snapshot-20180601:1.63
	sid-snapshot-20180501:1.63
	sid-snapshot-20180401:1.63
	sid-snapshot-20180301:1.63
	sid-snapshot-20180201:1.63
	sid-snapshot-20180101:1.63
	sid-snapshot-20171201:1.63
	sid-snapshot-20171101:1.63
	sid-snapshot-20171001:1.63
	sid-snapshot-20170901:1.63
	sid-snapshot-20170801:1.63
	sid-snapshot-20170701:1.63
	sid-snapshot-20170601:1.63
	sid-snapshot-20170501:1.63
	sid-snapshot-20170401:1.63
	sid-snapshot-20170301:1.63
	sid-snapshot-20170201:1.63
	sid-snapshot-20170101:1.63
	sid-snapshot-20161201:1.63
	sid-snapshot-20161101:1.63
	sid-snapshot-20160901:1.63
	sid-snapshot-20160801:1.63
	sid-snapshot-20160701:1.63
	sid-snapshot-20160601:1.63
	sid-snapshot-20160501:1.63
	sid-snapshot-20160401:1.63
	sid-snapshot-20160301:1.63
	sid-snapshot-20160201:1.63
	sid-snapshot-20160101:1.63
	sid-snapshot-20151201:1.63
	sid-snapshot-20151101:1.63
	sid-snapshot-20151001:1.63
	sid-snapshot-20150901:1.63
	sid-snapshot-20150801:1.63
	sid-snapshot-20150701:1.63
	sid-snapshot-20150601:1.63
	sid-snapshot-20150501:1.63
	sid-snapshot-20150401:1.63
	sid-snapshot-20150301:1.63
	sid-snapshot-20150201:1.63
	sid-snapshot-20150101:1.63
	sid-snapshot-20141201:1.63
	sid-snapshot-20141101:1.63
	sid-snapshot-20141001:1.63
	sid-snapshot-20140901:1.63
	sid-snapshot-20140801:1.63
	sid-snapshot-20140701:1.63
	sid-snapshot-20140601:1.63
	sid-snapshot-20140501:1.63
	sid-snapshot-20140401:1.63
	sid-snapshot-20140301:1.63
	sid-snapshot-20140201:1.63
	sid-snapshot-20140101:1.63
	sid-snapshot-20131201:1.63
	sid-snapshot-20131101:1.63
	sid-snapshot-20131001:1.63
	binutils-2_24-branch:1.63.0.2
	binutils-2_24-branchpoint:1.63
	binutils-2_21_1:1.49.2.1
	sid-snapshot-20130901:1.63
	gdb_7_6_1-2013-08-30-release:1.61
	sid-snapshot-20130801:1.63
	sid-snapshot-20130701:1.63
	sid-snapshot-20130601:1.63
	sid-snapshot-20130501:1.63
	gdb_7_6-2013-04-26-release:1.61
	sid-snapshot-20130401:1.63
	binutils-2_23_2:1.59
	gdb_7_6-branch:1.61.0.2
	gdb_7_6-2013-03-12-branchpoint:1.61
	sid-snapshot-20130301:1.61
	sid-snapshot-20130201:1.60
	sid-snapshot-20130101:1.60
	sid-snapshot-20121201:1.60
	gdb_7_5_1-2012-11-29-release:1.59
	binutils-2_23_1:1.59
	sid-snapshot-20121101:1.60
	binutils-2_23:1.59
	sid-snapshot-20121001:1.59
	sid-snapshot-20120901:1.59
	gdb_7_5-2012-08-17-release:1.59
	sid-snapshot-20120801:1.59
	binutils-2_23-branch:1.59.0.4
	binutils-2_23-branchpoint:1.59
	gdb_7_5-branch:1.59.0.2
	gdb_7_5-2012-07-18-branchpoint:1.59
	sid-snapshot-20120701:1.58
	sid-snapshot-20120601:1.57
	sid-snapshot-20120501:1.56
	binutils-2_22_branch:1.54.0.4
	gdb_7_4_1-2012-04-26-release:1.55
	sid-snapshot-20120401:1.55
	sid-snapshot-20120301:1.55
	sid-snapshot-20120201:1.55
	gdb_7_4-2012-01-24-release:1.55
	sid-snapshot-20120101:1.55
	gdb_7_4-branch:1.55.0.2
	gdb_7_4-2011-12-13-branchpoint:1.55
	sid-snapshot-20111201:1.55
	binutils-2_22:1.54
	sid-snapshot-20111101:1.55
	sid-snapshot-20111001:1.54
	binutils-2_22-branch:1.54.0.2
	binutils-2_22-branchpoint:1.54
	gdb_7_3_1-2011-09-04-release:1.53
	sid-snapshot-20110901:1.54
	sid-snapshot-20110801:1.54
	gdb_7_3-2011-07-26-release:1.53
	sid-snapshot-20110701:1.54
	sid-snapshot-20110601:1.53
	sid-snapshot-20110501:1.53
	gdb_7_3-branch:1.53.0.2
	gdb_7_3-2011-04-01-branchpoint:1.53
	sid-snapshot-20110401:1.53
	sid-snapshot-20110301:1.53
	sid-snapshot-20110201:1.52
	sid-snapshot-20110101:1.51
	binutils-2_21:1.49
	sid-snapshot-20101201:1.51
	binutils-2_21-branch:1.49.0.2
	binutils-2_21-branchpoint:1.49
	sid-snapshot-20101101:1.49
	sid-snapshot-20101001:1.48
	binutils-2_20_1:1.42.2.2
	gdb_7_2-2010-09-02-release:1.47
	sid-snapshot-20100901:1.48
	sid-snapshot-20100801:1.47
	gdb_7_2-branch:1.47.0.2
	gdb_7_2-2010-07-07-branchpoint:1.47
	sid-snapshot-20100701:1.47
	sid-snapshot-20100601:1.46
	sid-snapshot-20100501:1.46
	sid-snapshot-20100401:1.46
	gdb_7_1-2010-03-18-release:1.46
	sid-snapshot-20100301:1.46
	gdb_7_1-branch:1.46.0.2
	gdb_7_1-2010-02-18-branchpoint:1.46
	sid-snapshot-20100201:1.45
	sid-snapshot-20100101:1.45
	gdb_7_0_1-2009-12-22-release:1.43
	sid-snapshot-20091201:1.44
	sid-snapshot-20091101:1.44
	binutils-2_20:1.42.2.2
	gdb_7_0-2009-10-06-release:1.43
	sid-snapshot-20091001:1.44
	gdb_7_0-branch:1.43.0.2
	gdb_7_0-2009-09-16-branchpoint:1.43
	arc-sim-20090309:1.28
	binutils-arc-20081103-branch:1.34.0.12
	binutils-arc-20081103-branchpoint:1.34
	binutils-2_20-branch:1.42.0.2
	binutils-2_20-branchpoint:1.42
	sid-snapshot-20090901:1.40
	sid-snapshot-20090801:1.38
	msnyder-checkpoint-072509-branch:1.38.0.2
	msnyder-checkpoint-072509-branchpoint:1.38
	sid-snapshot-20090701:1.37
	dje-cgen-play1-branch:1.37.0.2
	dje-cgen-play1-branchpoint:1.37
	sid-snapshot-20090601:1.36
	sid-snapshot-20090501:1.35
	sid-snapshot-20090401:1.35
	arc-20081103-branch:1.34.0.10
	arc-20081103-branchpoint:1.34
	arc-insight_6_8-branch:1.28.0.6
	arc-insight_6_8-branchpoint:1.28
	insight_6_8-branch:1.28.0.4
	insight_6_8-branchpoint:1.28
	sid-snapshot-20090301:1.35
	binutils-2_19_1:1.34
	sid-snapshot-20090201:1.35
	sid-snapshot-20090101:1.35
	reverse-20081226-branch:1.35.0.2
	reverse-20081226-branchpoint:1.35
	sid-snapshot-20081201:1.35
	multiprocess-20081120-branch:1.34.0.8
	multiprocess-20081120-branchpoint:1.34
	sid-snapshot-20081101:1.34
	binutils-2_19:1.34
	sid-snapshot-20081001:1.34
	reverse-20080930-branch:1.34.0.6
	reverse-20080930-branchpoint:1.34
	binutils-2_19-branch:1.34.0.4
	binutils-2_19-branchpoint:1.34
	sid-snapshot-20080901:1.34
	sid-snapshot-20080801:1.34
	reverse-20080717-branch:1.34.0.2
	reverse-20080717-branchpoint:1.34
	sid-snapshot-20080701:1.30
	msnyder-reverse-20080609-branch:1.30.0.2
	msnyder-reverse-20080609-branchpoint:1.30
	drow-reverse-20070409-branch:1.19.0.2
	drow-reverse-20070409-branchpoint:1.19
	sid-snapshot-20080601:1.30
	sid-snapshot-20080501:1.30
	sid-snapshot-20080403:1.30
	sid-snapshot-20080401:1.30
	gdb_6_8-2008-03-27-release:1.28
	sid-snapshot-20080301:1.28
	gdb_6_8-branch:1.28.0.2
	gdb_6_8-2008-02-26-branchpoint:1.28
	sid-snapshot-20080201:1.26
	sid-snapshot-20080101:1.26
	sid-snapshot-20071201:1.25
	sid-snapshot-20071101:1.25
	gdb_6_7_1-2007-10-29-release:1.23
	gdb_6_7-2007-10-10-release:1.23
	sid-snapshot-20071001:1.25
	gdb_6_7-branch:1.23.0.2
	gdb_6_7-2007-09-07-branchpoint:1.23
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	insight_6_6-20070208-release:1.17
	binutils-csl-coldfire-4_1-32:1.5.2.1
	binutils-csl-sourcerygxx-4_1-32:1.5.2.1
	gdb_6_6-2006-12-18-release:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.5.2.1
	binutils-csl-coldfire-4_1-30:1.5.2.1
	binutils-csl-sourcerygxx-4_1-30:1.5.2.1
	binutils-csl-coldfire-4_1-28:1.5.2.1
	binutils-csl-sourcerygxx-4_1-29:1.5.2.1
	binutils-csl-sourcerygxx-4_1-28:1.5.2.1
	gdb_6_6-branch:1.17.0.2
	gdb_6_6-2006-11-15-branchpoint:1.17
	binutils-csl-arm-2006q3-27:1.5.2.1
	binutils-csl-sourcerygxx-4_1-27:1.5.2.1
	binutils-csl-arm-2006q3-26:1.5.2.1
	binutils-csl-sourcerygxx-4_1-26:1.5.2.1
	binutils-csl-sourcerygxx-4_1-25:1.5.2.1
	binutils-csl-sourcerygxx-4_1-24:1.5.2.1
	binutils-csl-sourcerygxx-4_1-23:1.5.2.1
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	binutils-csl-sourcerygxx-4_1-21:1.5.2.1
	binutils-csl-arm-2006q3-21:1.5.2.1
	binutils-csl-sourcerygxx-4_1-22:1.5.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.5.2.1
	binutils-csl-sourcerygxx-4_1-20:1.5.2.1
	binutils-csl-arm-2006q3-19:1.5.2.1
	binutils-csl-sourcerygxx-4_1-19:1.5.2.1
	binutils-csl-sourcerygxx-4_1-18:1.5.2.1
	binutils-csl-renesas-4_1-9:1.5.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.15
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	binutils-csl-renesas-4_1-8:1.5
	binutils-csl-renesas-4_1-7:1.5
	binutils-csl-renesas-4_1-6:1.5
	gdb-csl-sourcerygxx-4_1-17:1.3
	binutils-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	binutils-csl-sourcerygxx-4_1-14:1.5
	binutils-csl-sourcerygxx-4_1-15:1.5
	gdb-csl-sourcerygxx-4_1-13:1.3
	binutils-csl-sourcerygxx-4_1-13:1.5
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.3
	binutils-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	binutils-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.10
	gdb-csl-sourcerygxx-4_1-9:1.3
	binutils-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.3
	binutils-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.3
	binutils-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.3
	binutils-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.3
	binutils-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	binutils-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	binutils-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.10.0.10
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.5
	gdb-csl-sourcerygxx-4_1-5:1.3
	binutils-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.10.0.8
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.3
	binutils-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.10.0.6
	msnyder-reverse-20060502-branchpoint:1.10
	gdb-csl-morpho-4_1-4:1.3
	binutils-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	binutils-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.10.0.4
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	binutils-2_17-branch:1.10.0.2
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.3.0.10
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.7.0.2
	msnyder-reverse-20060331-branchpoint:1.7
	binutils-csl-2_17-branch:1.5.0.2
	binutils-csl-2_17-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.4.0.2
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.3.0.8
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.6
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.2
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.1.0.2
	gdb-csl-arm-20051020-branchpoint:1.1
	binutils_latest_snapshot:1.63;
locks; strict;
comment	@ * @;


1.63
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2013.02.10.04.01.15;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2012.10.23.09.33.54;	author nathan;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2012.06.29.14.45.58;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.24.05.12.31;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2011.10.19.07.17.13;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.14.12.35.56;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2010.11.15.22.30.45;	author vapier;	state Exp;
branches;
next	1.50;

1.50
date	2010.11.15.08.34.00;	author vapier;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.25.15.54.13;	author drow;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2010.08.25.14.53.40;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.23.08.03.02;	author jiez;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.11.03.20.34;	author jiez;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.04.03.35.32;	author jiez;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.11.11.41.17;	author bernds;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.09.16.45.04;	author bernds;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.10.15.26.56;	author tromey;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.18.14.18.28;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2009.05.10.23.33.50;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.16.15.27.05;	author bernds;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.15.13.09.47;	author jiez;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.12.08.54.12;	author jiez;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.11.19.24.38;	author jiez;	state Exp;
branches;
next	1.30;

1.30
date	2008.03.26.13.04.23;	author bernds;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.12.14.01.28;	author bernds;	state Exp;
branches;
next	1.28;

1.28
date	2008.02.11.22.25.03;	author bernds;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.11.16.04.51;	author bernds;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.31.11.01.54;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.26.13.45.31;	author jbeulich;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.05.18.49.41;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.20.14.34.08;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.23.05.45.22;	author jiez;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.23.03.58.33;	author jiez;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.06.11.45.01;	author bernds;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.05.20.46.15;	author bernds;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.05.19.57.36;	author bernds;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.26.00.38.42;	author bernds;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.25.18.17.42;	author bernds;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.24.16.31.20;	author jiez;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.24.14.25.13;	author jiez;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.30.15.36.41;	author clm;	state Exp;
branches;
next	;

1.54.2.1
date	2012.05.11.12.24.22;	author nickc;	state Exp;
branches;
next	;

1.49.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.42.2.1
date	2009.09.11.03.24.05;	author jiez;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2009.09.23.08.03.49;	author jiez;	state Exp;
branches;
next	;

1.5.2.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;


desc
@@


1.63
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@/* ADI Blackfin BFD support for 32-bit ELF.
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/bfin.h"
#include "dwarf2.h"
#include "hashtab.h"

/* FUNCTION : bfin_pltpc_reloc
   ABSTRACT : TODO : figure out how to handle pltpc relocs.  */
static bfd_reloc_status_type
bfin_pltpc_reloc (
     bfd *abfd ATTRIBUTE_UNUSED,
     arelent *reloc_entry ATTRIBUTE_UNUSED,
     asymbol *symbol ATTRIBUTE_UNUSED,
     void * data ATTRIBUTE_UNUSED,
     asection *input_section ATTRIBUTE_UNUSED,
     bfd *output_bfd ATTRIBUTE_UNUSED,
     char **error_message ATTRIBUTE_UNUSED)
{
  bfd_reloc_status_type flag = bfd_reloc_ok;
  return flag;
}


static bfd_reloc_status_type
bfin_pcrel24_reloc (bfd *abfd,
                    arelent *reloc_entry,
                    asymbol *symbol,
                    void * data,
                    asection *input_section,
                    bfd *output_bfd,
                    char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *output_section;
  bfd_boolean relocatable = (output_bfd != NULL);

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  output_section = symbol->section->output_section;

  if (relocatable)
    output_base = 0;
  else
    output_base = output_section->vma;

  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
    relocation += output_base + symbol->section->output_offset;

  if (!relocatable && !strcmp (symbol->name, symbol->section->name))
    relocation += reloc_entry->addend;

  relocation -= input_section->output_section->vma + input_section->output_offset;
  relocation -= reloc_entry->address;

  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_reloc_status_type status;
      status = bfd_check_overflow (howto->complain_on_overflow,
				   howto->bitsize,
				   howto->rightshift,
				   bfd_arch_bits_per_address(abfd),
				   relocation);
      if (status != bfd_reloc_ok)
	return status;
    }

  /* if rightshift is 1 and the number odd, return error.  */
  if (howto->rightshift && (relocation & 0x01))
    {
      (*_bfd_error_handler) (_("relocation should be even number"));
      return bfd_reloc_overflow;
    }

  relocation >>= (bfd_vma) howto->rightshift;
  /* Shift everything up to where it's going to be used.  */

  relocation <<= (bfd_vma) howto->bitpos;

  if (relocatable)
    {
      reloc_entry->address += input_section->output_offset;
      reloc_entry->addend += symbol->section->output_offset;
    }

  {
    short x;

    /* We are getting reloc_entry->address 2 byte off from
       the start of instruction. Assuming absolute postion
       of the reloc data. But, following code had been written assuming
       reloc address is starting at begining of instruction.
       To compensate that I have increased the value of
       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

    relocation += 1;
    x = bfd_get_16 (abfd, (bfd_byte *) data + addr - 2);
    x = (x & 0xff00) | ((relocation >> 16) & 0xff);
    bfd_put_16 (abfd, x, (unsigned char *) data + addr - 2);

    x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
    x = relocation & 0xFFFF;
    bfd_put_16 (abfd, x, (unsigned char *) data + addr );
  }
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
bfin_imm16_reloc (bfd *abfd,
     		  arelent *reloc_entry,
     		  asymbol *symbol,
     		  void * data,
     		  asection *input_section,
     		  bfd *output_bfd,
     		  char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation, x;
  bfd_size_type reloc_addr = reloc_entry->address;
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *output_section;
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  output_section = symbol->section->output_section;
  relocation = symbol->value;

  /* Convert input-section-relative symbol value to absolute.  */
  if (relocatable)
    output_base = 0;
  else
    output_base = output_section->vma;

  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
    relocation += output_base + symbol->section->output_offset;

  /* Add in supplied addend.  */
  relocation += reloc_entry->addend;

  if (relocatable)
    {
      reloc_entry->address += input_section->output_offset;
      reloc_entry->addend += symbol->section->output_offset;
    }
  else
    {
      reloc_entry->addend = 0;
    }

  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_reloc_status_type flag;
      flag = bfd_check_overflow (howto->complain_on_overflow,
				 howto->bitsize,
				 howto->rightshift,
				 bfd_arch_bits_per_address(abfd),
				 relocation);
      if (flag != bfd_reloc_ok)
	return flag;
    }

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */

  relocation >>= (bfd_vma) howto->rightshift;
  x = relocation;
  bfd_put_16 (abfd, x, (unsigned char *) data + reloc_addr);
  return bfd_reloc_ok;
}


static bfd_reloc_status_type
bfin_byte4_reloc (bfd *abfd,
                  arelent *reloc_entry,
                  asymbol *symbol,
                  void * data,
                  asection *input_section,
                  bfd *output_bfd,
                  char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation, x;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma output_base = 0;
  asection *output_section;
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  output_section = symbol->section->output_section;
  relocation = symbol->value;
  /* Convert input-section-relative symbol value to absolute.  */
  if (relocatable)
    output_base = 0;
  else
    output_base = output_section->vma;

  if ((symbol->name
       && symbol->section->name
       && !strcmp (symbol->name, symbol->section->name))
      || !relocatable)
    {
      relocation += output_base + symbol->section->output_offset;
    }

  relocation += reloc_entry->addend;

  if (relocatable)
    {
      /* This output will be relocatable ... like ld -r. */
      reloc_entry->address += input_section->output_offset;
      reloc_entry->addend += symbol->section->output_offset;
    }
  else
    {
      reloc_entry->addend = 0;
    }

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */
  x = relocation & 0xFFFF0000;
  x >>=16;
  bfd_put_16 (abfd, x, (unsigned char *) data + addr + 2);

  x = relocation & 0x0000FFFF;
  bfd_put_16 (abfd, x, (unsigned char *) data + addr);
  return bfd_reloc_ok;
}

/* bfin_bfd_reloc handles the blackfin arithmetic relocations.
   Use this instead of bfd_perform_relocation.  */
static bfd_reloc_status_type
bfin_bfd_reloc (bfd *abfd,
		arelent *reloc_entry,
     		asymbol *symbol,
     		void * data,
     		asection *input_section,
     		bfd *output_bfd,
     		char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation;
  bfd_size_type addr = reloc_entry->address;
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *output_section;
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if (relocatable)
    output_base = 0;
  else
    output_base = output_section->vma;

  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
    relocation += output_base + symbol->section->output_offset;

  if (!relocatable && !strcmp (symbol->name, symbol->section->name))
    {
      /* Add in supplied addend.  */
      relocation += reloc_entry->addend;
    }

  /* Here the variable relocation holds the final address of the
     symbol we are relocating against, plus any addend.  */

  if (howto->pc_relative == TRUE)
    {
      relocation -= input_section->output_section->vma + input_section->output_offset;

      if (howto->pcrel_offset == TRUE)
        relocation -= reloc_entry->address;
    }

  if (relocatable)
    {
      reloc_entry->address += input_section->output_offset;
      reloc_entry->addend += symbol->section->output_offset;
    }

  if (howto->complain_on_overflow != complain_overflow_dont)
    {
      bfd_reloc_status_type status;

      status = bfd_check_overflow (howto->complain_on_overflow,
                                  howto->bitsize,
                                  howto->rightshift,
                                  bfd_arch_bits_per_address(abfd),
                                  relocation);
      if (status != bfd_reloc_ok)
	return status;
    }

  /* If rightshift is 1 and the number odd, return error.  */
  if (howto->rightshift && (relocation & 0x01))
    {
      (*_bfd_error_handler) (_("relocation should be even number"));
      return bfd_reloc_overflow;
    }

  relocation >>= (bfd_vma) howto->rightshift;

  /* Shift everything up to where it's going to be used.  */

  relocation <<= (bfd_vma) howto->bitpos;

#define DOIT(x)								\
  x = ( (x & ~howto->dst_mask) | (relocation & howto->dst_mask))

  /* handle 8 and 16 bit relocations here. */
  switch (howto->size)
    {
    case 0:
      {
        char x = bfd_get_8 (abfd, (char *) data + addr);
        DOIT (x);
        bfd_put_8 (abfd, x, (unsigned char *) data + addr);
      }
      break;

    case 1:
      {
        unsigned short x = bfd_get_16 (abfd, (bfd_byte *) data + addr);
        DOIT (x);
        bfd_put_16 (abfd, (bfd_vma) x, (unsigned char *) data + addr);
      }
      break;

    default:
      return bfd_reloc_other;
    }

  return bfd_reloc_ok;
}

/* HOWTO Table for blackfin.
   Blackfin relocations are fairly complicated.
   Some of the salient features are
   a. Even numbered offsets. A number of (not all) relocations are
      even numbered. This means that the rightmost bit is not stored.
      Needs to right shift by 1 and check to see if value is not odd
   b. A relocation can be an expression. An expression takes on
      a variety of relocations arranged in a stack.
   As a result, we cannot use the standard generic function as special
   function. We will have our own, which is very similar to the standard
   generic function except that it understands how to get the value from
   the relocation stack. .  */

#define BFIN_RELOC_MIN 0
#define BFIN_RELOC_MAX 0x21
#define BFIN_GNUEXT_RELOC_MIN 0x40
#define BFIN_GNUEXT_RELOC_MAX 0x43
#define BFIN_ARELOC_MIN 0xE0
#define BFIN_ARELOC_MAX 0xF3

static reloc_howto_type bfin_howto_table [] =
{
  /* This reloc does nothing. .  */
  HOWTO (R_BFIN_UNUSED0,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_BFIN_UNUSED0",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL5M2,	/* type.  */
	 1,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long)..  */
	 4,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_unsigned, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_PCREL5M2",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x0000000F,		/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_UNUSED1,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_BFIN_UNUSED1",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL10,	/* type.  */
	 1,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 10,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_PCREL10",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x000003FF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL12_JUMP,	/* type.  */
	 1,			/* rightshift.  */
				/* the offset is actually 13 bit
				   aligned on a word boundary so
				   only 12 bits have to be used.
				   Right shift the rightmost bit..  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 12,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_PCREL12_JUMP",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x0FFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_RIMM16,		/* type.  */
	 0,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_imm16_reloc,	/* special_function.  */
	 "R_BFIN_RIMM16",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x0000FFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_LUIMM16,	/* type.  */
	 0,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_imm16_reloc,	/* special_function.  */
	 "R_BFIN_LUIMM16",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x0000FFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_HUIMM16,	/* type.  */
	 16,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_unsigned, /* complain_on_overflow.  */
	 bfin_imm16_reloc,	/* special_function.  */
	 "R_BFIN_HUIMM16",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x0000FFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL12_JUMP_S,	/* type.  */
	 1,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 12,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_PCREL12_JUMP_S", /* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x00000FFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL24_JUMP_X,	/* type.  */
         1,			/* rightshift.  */
         2,			/* size (0 = byte, 1 = short, 2 = long).  */
         24,			/* bitsize.  */
         TRUE,			/* pc_relative.  */
         0,			/* bitpos.  */
         complain_overflow_signed, /* complain_on_overflow.  */
         bfin_pcrel24_reloc,	/* special_function.  */
	"R_BFIN_PCREL24_JUMP_X", /* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x00FFFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL24,	/* type.  */
	 1,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 24,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_pcrel24_reloc,	/* special_function.  */
	 "R_BFIN_PCREL24",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x00FFFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_UNUSEDB,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_BFIN_UNUSEDB",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_UNUSEDC,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_BFIN_UNUSEDC",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL24_JUMP_L,	/* type.  */
	 1,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 24,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_pcrel24_reloc,	/* special_function.  */
	 "R_BFIN_PCREL24_JUMP_L", /* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x00FFFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL24_CALL_X,	/* type.  */
	 1,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 24,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_pcrel24_reloc,	/* special_function.  */
	 "R_BFIN_PCREL24_CALL_X", /* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x00FFFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_VAR_EQ_SYMB,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_VAR_EQ_SYMB",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_BYTE_DATA,	/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 8,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_unsigned, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_BYTE_DATA",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0xFF,			/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_BYTE2_DATA,	/* type.  */
	 0,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_signed, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_BYTE2_DATA",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0xFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_BYTE4_DATA,	/* type.  */
	 0,			/* rightshift.  */
	 2,			/* size (0 = byte, 1 = short, 2 = long).  */
	 32,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_unsigned, /* complain_on_overflow.  */
	 bfin_byte4_reloc,	/* special_function.  */
	 "R_BFIN_BYTE4_DATA",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0xFFFFFFFF,		/* dst_mask.  */
	 TRUE),			/* pcrel_offset.  */

  HOWTO (R_BFIN_PCREL11,	/* type.  */
	 1,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 10,			/* bitsize.  */
	 TRUE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_unsigned, /* complain_on_overflow.  */
	 bfin_bfd_reloc,	/* special_function.  */
	 "R_BFIN_PCREL11",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0x000003FF,		/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */


  /* A 18-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_BFIN_GOT17M4,        /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOT17M4",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTHI,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		        /* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTLO,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOT17M4,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOT17M4", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFF17M4, /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFF17M4", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFFHI, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFFHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFFLO, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFFLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_BFIN_GOTOFF17M4,     /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFF17M4",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTOFFHI,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTOFFLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */
};

static reloc_howto_type bfin_gnuext_howto_table [] =
{
  HOWTO (R_BFIN_PLTPC,		/* type.  */
	 0,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfin_pltpc_reloc,	/* special_function.  */
	 "R_BFIN_PLTPC",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0xffff,		/* src_mask.  */
	 0xffff,		/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_BFIN_GOT,		/* type.  */
	 0,			/* rightshift.  */
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_BFIN_GOT",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0x7fff,		/* src_mask.  */
	 0x7fff,		/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

/* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_BFIN_GNU_VTINHERIT, /* type.  */
         0,                     /* rightshift.  */
         2,                     /* size (0 = byte, 1 = short, 2 = long).  */
         0,                     /* bitsize.  */
         FALSE,                 /* pc_relative.  */
         0,                     /* bitpos.  */
         complain_overflow_dont, /* complain_on_overflow.  */
         NULL,                  /* special_function.  */
         "R_BFIN_GNU_VTINHERIT", /* name.  */
         FALSE,                 /* partial_inplace.  */
         0,                     /* src_mask.  */
         0,                     /* dst_mask.  */
         FALSE),                /* pcrel_offset.  */

/* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_BFIN_GNU_VTENTRY,	/* type.  */
         0,                     /* rightshift.  */
         2,                     /* size (0 = byte, 1 = short, 2 = long).  */
         0,                     /* bitsize.  */
         FALSE,                 /* pc_relative.  */
         0,			/* bitpos.  */
         complain_overflow_dont, /* complain_on_overflow.  */
         _bfd_elf_rel_vtable_reloc_fn, /* special_function.  */
         "R_BFIN_GNU_VTENTRY",	/* name.  */
         FALSE,                 /* partial_inplace.  */
         0,                     /* src_mask.  */
         0,                     /* dst_mask.  */
         FALSE)                 /* pcrel_offset.  */
};

struct bfin_reloc_map
{
  bfd_reloc_code_real_type 	bfd_reloc_val;
  unsigned int			bfin_reloc_val;
};

static const struct bfin_reloc_map bfin_reloc_map [] =
{
  { BFD_RELOC_NONE,			R_BFIN_UNUSED0 },
  { BFD_RELOC_BFIN_5_PCREL,		R_BFIN_PCREL5M2 },
  { BFD_RELOC_NONE,			R_BFIN_UNUSED1 },
  { BFD_RELOC_BFIN_10_PCREL,		R_BFIN_PCREL10 },
  { BFD_RELOC_BFIN_12_PCREL_JUMP,	R_BFIN_PCREL12_JUMP },
  { BFD_RELOC_BFIN_16_IMM,		R_BFIN_RIMM16 },
  { BFD_RELOC_BFIN_16_LOW,		R_BFIN_LUIMM16 },
  { BFD_RELOC_BFIN_16_HIGH,		R_BFIN_HUIMM16 },
  { BFD_RELOC_BFIN_12_PCREL_JUMP_S,	R_BFIN_PCREL12_JUMP_S },
  { BFD_RELOC_24_PCREL,			R_BFIN_PCREL24 },
  { BFD_RELOC_24_PCREL,			R_BFIN_PCREL24 },
  { BFD_RELOC_BFIN_24_PCREL_JUMP_L,	R_BFIN_PCREL24_JUMP_L },
  { BFD_RELOC_NONE,			R_BFIN_UNUSEDB },
  { BFD_RELOC_NONE,			R_BFIN_UNUSEDC },
  { BFD_RELOC_BFIN_24_PCREL_CALL_X,	R_BFIN_PCREL24_CALL_X },
  { BFD_RELOC_8,			R_BFIN_BYTE_DATA },
  { BFD_RELOC_16,			R_BFIN_BYTE2_DATA },
  { BFD_RELOC_32,			R_BFIN_BYTE4_DATA },
  { BFD_RELOC_BFIN_11_PCREL,		R_BFIN_PCREL11 },
  { BFD_RELOC_BFIN_GOT,			R_BFIN_GOT },
  { BFD_RELOC_BFIN_PLTPC,		R_BFIN_PLTPC },

  { BFD_RELOC_BFIN_GOT17M4,      R_BFIN_GOT17M4 },
  { BFD_RELOC_BFIN_GOTHI,      R_BFIN_GOTHI },
  { BFD_RELOC_BFIN_GOTLO,      R_BFIN_GOTLO },
  { BFD_RELOC_BFIN_FUNCDESC,   R_BFIN_FUNCDESC },
  { BFD_RELOC_BFIN_FUNCDESC_GOT17M4, R_BFIN_FUNCDESC_GOT17M4 },
  { BFD_RELOC_BFIN_FUNCDESC_GOTHI, R_BFIN_FUNCDESC_GOTHI },
  { BFD_RELOC_BFIN_FUNCDESC_GOTLO, R_BFIN_FUNCDESC_GOTLO },
  { BFD_RELOC_BFIN_FUNCDESC_VALUE, R_BFIN_FUNCDESC_VALUE },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4, R_BFIN_FUNCDESC_GOTOFF17M4 },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI, R_BFIN_FUNCDESC_GOTOFFHI },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO, R_BFIN_FUNCDESC_GOTOFFLO },
  { BFD_RELOC_BFIN_GOTOFF17M4,   R_BFIN_GOTOFF17M4 },
  { BFD_RELOC_BFIN_GOTOFFHI,   R_BFIN_GOTOFFHI },
  { BFD_RELOC_BFIN_GOTOFFLO,   R_BFIN_GOTOFFLO },

  { BFD_RELOC_VTABLE_INHERIT,		R_BFIN_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY,		R_BFIN_GNU_VTENTRY },
};


static void
bfin_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
                    arelent *cache_ptr,
                    Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);

  if (r_type <= BFIN_RELOC_MAX)
    cache_ptr->howto = &bfin_howto_table [r_type];

  else if (r_type >= BFIN_GNUEXT_RELOC_MIN && r_type <= BFIN_GNUEXT_RELOC_MAX)
    cache_ptr->howto = &bfin_gnuext_howto_table [r_type - BFIN_GNUEXT_RELOC_MIN];

  else
    cache_ptr->howto = (reloc_howto_type *) NULL;
}

/* Given a BFD reloc type, return the howto.  */
static reloc_howto_type *
bfin_bfd_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  unsigned int i;
  unsigned int r_type = BFIN_RELOC_MIN;

  for (i = sizeof (bfin_reloc_map) / sizeof (bfin_reloc_map[0]); --i;)
    if (bfin_reloc_map[i].bfd_reloc_val == code)
      r_type = bfin_reloc_map[i].bfin_reloc_val;

  if (r_type <= BFIN_RELOC_MAX && r_type > BFIN_RELOC_MIN)
    return &bfin_howto_table [r_type];

  else if (r_type >= BFIN_GNUEXT_RELOC_MIN && r_type <= BFIN_GNUEXT_RELOC_MAX)
   return &bfin_gnuext_howto_table [r_type - BFIN_GNUEXT_RELOC_MIN];

  return (reloc_howto_type *) NULL;
}

static reloc_howto_type *
bfin_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (bfin_howto_table)
	    / sizeof (bfin_howto_table[0]));
       i++)
    if (bfin_howto_table[i].name != NULL
	&& strcasecmp (bfin_howto_table[i].name, r_name) == 0)
      return &bfin_howto_table[i];

  for (i = 0;
       i < (sizeof (bfin_gnuext_howto_table)
	    / sizeof (bfin_gnuext_howto_table[0]));
       i++)
    if (bfin_gnuext_howto_table[i].name != NULL
	&& strcasecmp (bfin_gnuext_howto_table[i].name, r_name) == 0)
      return &bfin_gnuext_howto_table[i];

  return NULL;
}

/* Given a bfin relocation type, return the howto.  */
static reloc_howto_type *
bfin_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
			unsigned int r_type)
{
  if (r_type <= BFIN_RELOC_MAX)
    return &bfin_howto_table [r_type];

  else if (r_type >= BFIN_GNUEXT_RELOC_MIN && r_type <= BFIN_GNUEXT_RELOC_MAX)
   return &bfin_gnuext_howto_table [r_type - BFIN_GNUEXT_RELOC_MIN];

  return (reloc_howto_type *) NULL;
}

/* Set by ld emulation if --code-in-l1.  */
bfd_boolean elf32_bfin_code_in_l1 = 0;

/* Set by ld emulation if --data-in-l1.  */
bfd_boolean elf32_bfin_data_in_l1 = 0;

static void
elf32_bfin_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
  if (elf32_bfin_code_in_l1)
    elf_elfheader (abfd)->e_flags |= EF_BFIN_CODE_IN_L1;
  if (elf32_bfin_data_in_l1)
    elf_elfheader (abfd)->e_flags |= EF_BFIN_DATA_IN_L1;
}

/* Return TRUE if the name is a local label.
   bfin local labels begin with L$.  */
static bfd_boolean
bfin_is_local_label_name (bfd *abfd, const char *label)
{
  if (label[0] == 'L' && label[1] == '$' )
    return TRUE;

  return _bfd_elf_is_local_label_name (abfd, label);
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
bfin_check_relocs (bfd * abfd,
		   struct bfd_link_info *info,
		   asection *sec,
                   const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sgot = NULL;
  srelgot = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
       /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_BFIN_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries
           are actually used.  Record for later use during GC.  */
        case R_BFIN_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_BFIN_GOT:
	  if (h != NULL
	      && strcmp (h->root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */

	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_linker_section (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY);
		  srelgot = bfd_make_section_anyway_with_flags (dynobj,
								".rela.got",
								flags);
		  if (srelgot == NULL
		      || !bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1 && !h->forced_local)
		    {
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
			return FALSE;
		    }

		  /* Allocate space in the .got section.  */
		  sgot->size += 4;
		  /* Allocate relocation space.  */
		  srelgot->size += sizeof (Elf32_External_Rela);
		}
	      h->got.refcount++;
	    }
	  else
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->size += 4;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
		         output a R_68K_RELATIVE reloc so that the dynamic
		         linker can adjust this GOT entry.  */
		      srelgot->size += sizeof (Elf32_External_Rela);
		    }
		}
	      local_got_refcounts[r_symndx]++;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

static enum elf_reloc_type_class
elf32_bfin_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela * rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    default:
      return reloc_class_normal;
    }
}

static bfd_reloc_status_type
bfin_final_link_relocate (Elf_Internal_Rela *rel, reloc_howto_type *howto,
			  bfd *input_bfd, asection *input_section,
			  bfd_byte *contents, bfd_vma address,
			  bfd_vma value, bfd_vma addend)
{
  int r_type = ELF32_R_TYPE (rel->r_info);

  if (r_type == R_BFIN_PCREL24 || r_type == R_BFIN_PCREL24_JUMP_L)
    {
      bfd_reloc_status_type r = bfd_reloc_ok;
      bfd_vma x;

      if (address > bfd_get_section_limit (input_bfd, input_section))
	return bfd_reloc_outofrange;

      value += addend;

      /* Perform usual pc-relative correction.  */
      value -= input_section->output_section->vma + input_section->output_offset;
      value -= address;

      /* We are getting reloc_entry->address 2 byte off from
	 the start of instruction. Assuming absolute postion
	 of the reloc data. But, following code had been written assuming
	 reloc address is starting at begining of instruction.
	 To compensate that I have increased the value of
	 relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

      value += 2;
      address -= 2;

      if ((value & 0xFF000000) != 0
	  && (value & 0xFF000000) != 0xFF000000)
	r = bfd_reloc_overflow;

      value >>= 1;

      x = bfd_get_16 (input_bfd, contents + address);
      x = (x & 0xff00) | ((value >> 16) & 0xff);
      bfd_put_16 (input_bfd, x, contents + address);

      x = bfd_get_16 (input_bfd, contents + address + 2);
      x = value & 0xFFFF;
      bfd_put_16 (input_bfd, x, contents + address + 2);
      return r;
    }

  return _bfd_final_link_relocate (howto, input_bfd, input_section, contents,
				   rel->r_offset, value, addend);

}

static bfd_boolean
bfin_relocate_section (bfd * output_bfd,
		       struct bfd_link_info *info,
		       bfd * input_bfd,
		       asection * input_section,
		       bfd_byte * contents,
		       Elf_Internal_Rela * relocs,
		       Elf_Internal_Sym * local_syms,
		       asection ** local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  asection *sgot;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  int i = 0;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++, i++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation = 0;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      bfd_vma address;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= 243)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (r_type == R_BFIN_GNU_VTENTRY
          || r_type == R_BFIN_GNU_VTINHERIT)
	continue;

      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      r_symndx = ELF32_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      address = rel->r_offset;

      /* Then, process normally.  */
      switch (r_type)
	{
	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  return bfd_reloc_ok;

	case R_BFIN_GOT:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */
	  if (h != NULL
	      && strcmp (h->root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	    goto do_default;
	  /* Fall through.  */
	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */

	  {
	    bfd_vma off;

	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = output_bfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }

	    if (sgot == NULL)
	      {
		sgot = bfd_get_linker_section (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
	      }

	    if (h != NULL)
	      {
		bfd_boolean dyn;

		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) - 1);
		dyn = elf_hash_table (info)->dynamic_sections_created;

		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& (info->symbolic
			    || h->dynindx == -1
			    || h->forced_local)
			&& h->def_regular))
		  {
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally, or the symbol was forced to be local
		       because of a version file..  We must initialize
		       this entry in the global offset table.  Since
		       the offset must always be a multiple of 4, we
		       use the least significant bit to record whether
		       we have initialized it already.

		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			bfd_put_32 (output_bfd, relocation,
				    sgot->contents + off);
			h->got.offset |= 1;
		      }
		  }
		else
		  unresolved_reloc = FALSE;
	      }
	    else
	      {
		BFD_ASSERT (local_got_offsets != NULL);
		off = local_got_offsets[r_symndx];
		BFD_ASSERT (off != (bfd_vma) - 1);

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    bfd_put_32 (output_bfd, relocation, sgot->contents + off);

		    if (info->shared)
		      {
			asection *s;
			Elf_Internal_Rela outrel;
			bfd_byte *loc;

			s = bfd_get_linker_section (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);

			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset + off);
			outrel.r_info =
			  ELF32_R_INFO (0, R_BFIN_PCREL24);
			outrel.r_addend = relocation;
			loc = s->contents;
			loc +=
			  s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }

		    local_got_offsets[r_symndx] |= 1;
		  }
	      }

	    relocation = sgot->output_offset + off;
	    rel->r_addend = 0;
            /* bfin : preg = [preg + 17bitdiv4offset] relocation is div by 4.  */
            relocation /= 4;
	  }
	  goto do_default;

	default:
	do_default:
	  r = bfin_final_link_relocate (rel, howto, input_bfd, input_section,
					contents, address,
					relocation, rel->r_addend);

	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
         because such sections are not SEC_ALLOC and thus ld.so will
         not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0 && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	     input_bfd,
	     input_section, (long) rel->r_offset, h->root.root.string);
	  return FALSE;
	}

      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, (h ? &h->root : NULL), name, howto->name,
		     (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

static asection *
bfin_gc_mark_hook (asection * sec,
		   struct bfd_link_info *info,
		   Elf_Internal_Rela * rel,
		   struct elf_link_hash_entry *h,
                   Elf_Internal_Sym * sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_BFIN_GNU_VTINHERIT:
      case R_BFIN_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
bfin_gc_sweep_hook (bfd * abfd,
		    struct bfd_link_info *info,
		    asection * sec,
                    const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sgot = bfd_get_linker_section (dynobj, ".got");
  srelgot = bfd_get_linker_section (dynobj, ".rela.got");

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_BFIN_GOT:
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      if (info->shared)
			srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  break;
	default:
	  break;
	}
    }
  return TRUE;
}

extern const bfd_target bfd_elf32_bfinfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_bfinfdpic_vec)

/* An extension of the elf hash table data structure,
   containing some additional Blackfin-specific data.  */
struct bfinfdpic_elf_link_hash_table
{
  struct elf_link_hash_table elf;

  /* A pointer to the .got section.  */
  asection *sgot;
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
  /* Summary reloc information collected by
     _bfinfdpic_count_got_plt_entries.  */
  struct _bfinfdpic_dynamic_got_info *g;
};

/* Get the Blackfin ELF linker hash table from a link_info structure.  */

#define bfinfdpic_hash_table(info) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((info)->hash)) \
  == BFIN_ELF_DATA ? ((struct bfinfdpic_elf_link_hash_table *) ((info)->hash)) : NULL)

#define bfinfdpic_got_section(info) \
  (bfinfdpic_hash_table (info)->sgot)
#define bfinfdpic_gotrel_section(info) \
  (bfinfdpic_hash_table (info)->sgotrel)
#define bfinfdpic_gotfixup_section(info) \
  (bfinfdpic_hash_table (info)->sgotfixup)
#define bfinfdpic_plt_section(info) \
  (bfinfdpic_hash_table (info)->splt)
#define bfinfdpic_pltrel_section(info) \
  (bfinfdpic_hash_table (info)->spltrel)
#define bfinfdpic_relocs_info(info) \
  (bfinfdpic_hash_table (info)->relocs_info)
#define bfinfdpic_got_initial_offset(info) \
  (bfinfdpic_hash_table (info)->got0)
#define bfinfdpic_plt_initial_offset(info) \
  (bfinfdpic_hash_table (info)->plt0)
#define bfinfdpic_dynamic_got_plt_info(info) \
  (bfinfdpic_hash_table (info)->g)

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _bfinfdpic_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 18- or 32-bit
     ranges.  */
  bfd_vma got17m4, gothilo;
  /* Total size needed for function descriptor entries within the 18-
     or 32-bit ranges.  */
  bfd_vma fd17m4, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

/* Create a Blackfin ELF linker hash table.  */

static struct bfd_link_hash_table *
bfinfdpic_elf_link_hash_table_create (bfd *abfd)
{
  struct bfinfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct bfinfdpic_elf_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry),
				      BFIN_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define BFINFDPIC_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define BFINFDPIC_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)

/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct bfinfdpic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;

  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 2 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 17M4 suffix indicates a
     GOT17M4 relocation; hilo is used for GOTLO/GOTHI pairs.  */
  unsigned got17m4;
  unsigned gothilo;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot17m4;
  unsigned fdgothilo;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff17m4;
  unsigned fdgoffhilo;
  /* Whether symbol+addend is referenced with GOTOFF17M4, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff17m4 || fdgotofflohi
      || ((fd || fdgot17m4 || fdgothilo)
          && (symndx != -1 || BFINFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;

  /* The number of R_BFIN_BYTE4_DATA, R_BFIN_FUNCDESC and R_BFIN_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;

  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;

  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
};

/* Compute a hash with the key fields of an bfinfdpic_relocs_info entry.  */
static hashval_t
bfinfdpic_relocs_info_hash (const void *entry_)
{
  const struct bfinfdpic_relocs_info *entry = entry_;

  return (entry->symndx == -1
	  ? (long) entry->d.h->root.root.hash
	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
}

/* Test whether the key fields of two bfinfdpic_relocs_info entries are
   identical.  */
static int
bfinfdpic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct bfinfdpic_relocs_info *e1 = entry1;
  const struct bfinfdpic_relocs_info *e2 = entry2;

  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
}

/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct bfinfdpic_relocs_info *entry,
			   enum insert_option insert)
{
  struct bfinfdpic_relocs_info **loc;

  if (!ht)
    return NULL;

  loc = (struct bfinfdpic_relocs_info **) htab_find_slot (ht, entry, insert);

  if (! loc)
    return NULL;

  if (*loc)
    return *loc;

  *loc = bfd_zalloc (abfd, sizeof (**loc));

  if (! *loc)
    return *loc;

  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;

  return *loc;
}

/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_global (struct htab *ht,
				  bfd *abfd,
				  struct elf_link_hash_entry *h,
				  bfd_vma addend,
				  enum insert_option insert)
{
  struct bfinfdpic_relocs_info entry;

  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;

  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
{
  struct bfinfdpic_relocs_info entry;

  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;

  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */

inline static void
bfinfdpic_pic_merge_early_relocs_info (struct bfinfdpic_relocs_info *e2,
				       struct bfinfdpic_relocs_info const *e1)
{
  e2->got17m4 |= e1->got17m4;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot17m4 |= e1->fdgot17m4;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff17m4 |= e1->fdgoff17m4;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;
}

/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */

#define LZPLT_RESOLVER_EXTRA 10
#define LZPLT_NORMAL_SIZE 6
#define LZPLT_ENTRIES 1362

#define BFINFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) LZPLT_NORMAL_SIZE * LZPLT_ENTRIES + LZPLT_RESOLVER_EXTRA)
#define BFINFDPIC_LZPLT_RESOLV_LOC (LZPLT_NORMAL_SIZE * LZPLT_ENTRIES / 2)

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
_bfinfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct bfinfdpic_relocs_info *entry)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  /* If the entry's index is zero, this relocation was probably to a
     linkonce section that got discarded.  We reserved a dynamic
     relocation, but it was for another entry than the one we got at
     the time of emitting the relocation.  Unfortunately there's no
     simple way for us to catch this situation, since the relocation
     is cleared right before calling relocate_section, at which point
     we no longer know what the relocation used to point to.  */
  if (entry->symndx)
    {
      BFD_ASSERT (entry->dynrelocs > 0);
      entry->dynrelocs--;
    }

  return reloc_offset;
}

/* Add a fixup to the ROFIXUP section.  */

static bfd_vma
_bfinfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
			struct bfinfdpic_relocs_info *entry)
{
  bfd_vma fixup_offset;

  if (rofixup->flags & SEC_EXCLUDE)
    return -1;

  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;

  if (entry && entry->symndx)
    {
      /* See discussion about symndx == 0 in _bfinfdpic_add_dyn_reloc
	 above.  */
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }

  return fixup_offset;
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
_bfinfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
{
  Elf_Internal_Phdr *p = _bfd_elf_find_segment_containing_section (output_bfd, osec);

  return (p != NULL) ? p - elf_tdata (output_bfd)->phdr : -1;
}

inline static bfd_boolean
_bfinfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = _bfinfdpic_osec_to_segment (output_bfd, osec);

  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
}

/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_bfinfdpic_emit_got_relocs_plt_entries (struct bfinfdpic_relocs_info *entry,
					bfd *output_bfd,
					struct bfd_link_info *info,
					asection *sec,
					Elf_Internal_Sym *sym,
					bfd_vma addend)
{
  bfd_vma fd_lazy_rel_offset = (bfd_vma) -1;
  int dynindx = -1;

  if (entry->done)
    return TRUE;
  entry->done = 1;

  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
	{
	  if (sec
	      && sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
	}
    }

  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1
	      || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    _bfinfdpic_add_rofixup (output_bfd,
				   bfinfdpic_gotfixup_section (info),
				   bfinfdpic_got_section (info)->output_section
				   ->vma
				   + bfinfdpic_got_section (info)->output_offset
				   + bfinfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
	}
      else
	_bfinfdpic_add_dyn_reloc (output_bfd, bfinfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  bfinfdpic_got_section (info),
				  bfinfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + bfinfdpic_got_section (info)
				 ->output_section->vma
				 + bfinfdpic_got_section (info)->output_offset,
				 R_BFIN_BYTE4_DATA, idx, ad, entry);

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
    {
      int reloc, idx;
      bfd_vma ad = 0;

      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1
	      && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && BFINFDPIC_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
	    {
	      reloc = R_BFIN_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
	    }
	  else if (entry->symndx == -1
		   && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
	    {
	      reloc = R_BFIN_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		return FALSE;
	    }
	  else
	    {
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_BFIN_BYTE4_DATA;
	      idx = elf_section_data (bfinfdpic_got_section (info)
				      ->output_section)->dynindx;
	      ad = bfinfdpic_got_section (info)->output_offset
		+ bfinfdpic_got_initial_offset (info) + entry->fd_entry;
	    }

	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
	      ad += bfinfdpic_got_section (info)->output_section->vma;
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
	    }
	  else
	    _bfinfdpic_add_dyn_reloc (output_bfd,
				     bfinfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      bfinfdpic_got_section (info),
				      bfinfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
	}

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fdgot_entry);
    }

  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
	    }
	}
      else
	{
	  ofst
	    = _bfinfdpic_add_dyn_reloc (output_bfd,
					entry->lazyplt
					? bfinfdpic_pltrel_section (info)
					: bfinfdpic_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 bfinfdpic_got_section (info),
					 bfinfdpic_got_initial_offset (info)
					 + entry->fd_entry)
					+ bfinfdpic_got_section (info)
					->output_section->vma
					+ bfinfdpic_got_section (info)
					->output_offset,
					R_BFIN_FUNCDESC_VALUE, idx, ad, entry);
	}

      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = bfinfdpic_got_section (info)->output_section->vma
	    + bfinfdpic_got_section (info)->output_offset
	    + bfinfdpic_got_initial_offset (info);
	}
      else if (entry->lazyplt)
	{
	  if (ad)
	    return FALSE;

	  fd_lazy_rel_offset = ofst;

	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + bfinfdpic_plt_section (info)->output_offset
	    + bfinfdpic_plt_section (info)->output_section->vma;
	  highword = _bfinfdpic_osec_to_segment
	    (output_bfd, bfinfdpic_plt_section (info)->output_section);
	}
      else
	{
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (sec == NULL
	      || (entry->symndx == -1 && entry->d.h->dynindx != -1
		  && entry->d.h->dynindx == idx))
	    highword = 0;
	  else
	    highword = _bfinfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
	}

      bfd_put_32 (output_bfd, lowword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }

  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = bfinfdpic_plt_section (info)->contents
	+ entry->plt_entry;

      BFD_ASSERT (entry->fd_entry);

      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (18 - 1))
	  && entry->fd_entry + 4 < (1 << (18 - 1)))
	{
	  /* P1 = [P3 + fd_entry]; P3 = [P3 + fd_entry + 4] */
	  bfd_put_32 (output_bfd,
		      0xe519 | ((entry->fd_entry << 14) & 0xFFFF0000),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe51b | (((entry->fd_entry + 4) << 14) & 0xFFFF0000),
		      plt_code + 4);
	  plt_code += 8;
	}
      else
	{
	  /* P1.L = fd_entry; P1.H = fd_entry;
	     P3 = P3 + P1;
	     P1 = [P3];
	     P3 = [P3 + 4];  */
	  bfd_put_32 (output_bfd,
		      0xe109 | (entry->fd_entry << 16),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe149 | (entry->fd_entry & 0xFFFF0000),
		      plt_code + 4);
	  bfd_put_16 (output_bfd, 0x5ad9, plt_code + 8);
	  bfd_put_16 (output_bfd, 0x9159, plt_code + 10);
	  bfd_put_16 (output_bfd, 0xac5b, plt_code + 12);
	  plt_code += 14;
	}
      /* JUMP (P1) */
      bfd_put_16 (output_bfd, 0x0051, plt_code);
    }

  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = bfinfdpic_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;

      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;

      resolverStub_addr = entry->lzplt_entry / BFINFDPIC_LZPLT_BLOCK_SIZE
	* BFINFDPIC_LZPLT_BLOCK_SIZE + BFINFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= bfinfdpic_plt_initial_offset (info))
	resolverStub_addr = bfinfdpic_plt_initial_offset (info) - LZPLT_NORMAL_SIZE - LZPLT_RESOLVER_EXTRA;

      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.
	     P2 = [P3];
	     R3 = [P3 + 4];
	     JUMP (P2);  */
	  bfd_put_32 (output_bfd,
		      0xa05b915a,
		      lzplt_code);
	  bfd_put_16 (output_bfd, 0x0052, lzplt_code + 4);
	}
      else
	{
	  /* JUMP.S  resolverStub */
	  bfd_put_16 (output_bfd,
		      0x2000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 2) & (((bfd_vma)1 << 12) - 1)),
		      lzplt_code);
	}
    }

  return TRUE;
}

/* Relocate an Blackfin ELF section.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
bfinfdpic_relocate_section (bfd * output_bfd,
			    struct bfd_link_info *info,
			    bfd * input_bfd,
			    asection * input_section,
			    bfd_byte * contents,
			    Elf_Internal_Rela * relocs,
			    Elf_Internal_Sym * local_syms,
			    asection ** local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  unsigned isec_segment, got_segment, plt_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  isec_segment = _bfinfdpic_osec_to_segment (output_bfd,
					     input_section->output_section);
  if (IS_FDPIC (output_bfd) && bfinfdpic_got_section (info))
    got_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_got_section (info)
					      ->output_section);
  else
    got_segment = -1;
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_plt_section (info)
					      ->output_section);
  else
    plt_segment = -1;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char * name = NULL;
      int r_type;
      asection *osec;
      struct bfinfdpic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;

      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_type == R_BFIN_GNU_VTINHERIT
	  || r_type == R_BFIN_GNU_VTENTRY)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);
      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  osec = sec;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && !BFINFDPIC_SYM_LOCAL (info, h))
	{
	  osec = sec = NULL;
	  relocation = 0;
	}

      switch (r_type)
	{
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	case R_BFIN_BYTE4_DATA:
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	case R_BFIN_FUNCDESC:
	case R_BFIN_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info
						       (info), input_bfd, h,
						       orig_addend, INSERT);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						      (info), input_bfd, r_symndx,
						      orig_addend, INSERT);
	  if (! picrel)
	    return FALSE;

	  if (!_bfinfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						       osec, sym,
						       rel->r_addend))
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
	      return FALSE;

	    }

	  break;

	default:
	non_fdpic:
	  picrel = NULL;
	  if (h && ! BFINFDPIC_SYM_LOCAL (info, h)
	      && _bfd_elf_section_offset (output_bfd, info, input_section,
					  rel->r_offset) != (bfd_vma) -1)
	    {
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}

      switch (r_type)
	{
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	  check_segment[0] = isec_segment;
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
	    {
	      relocation = bfinfdpic_plt_section (info)->output_section->vma
		+ bfinfdpic_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
	    }
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;

	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFLO:
	  relocation -= bfinfdpic_got_section (info)->output_section->vma
	    + bfinfdpic_got_section (info)->output_offset
	    + bfinfdpic_got_initial_offset (info);
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h)
		    && BFINFDPIC_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
		  {
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->warning
			  (info, _("R_BFIN_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_BFIN_BYTE4_DATA;
		    dynindx = elf_section_data (bfinfdpic_got_section (info)
						->output_section)->dynindx;
		    addend = bfinfdpic_got_section (info)->output_offset
		      + bfinfdpic_got_initial_offset (info)
		      + picrel->fd_entry;
		  }

		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_FUNCDESC_LOCAL (info, h)))
		  {
		    bfd_vma offset;

		    addend += bfinfdpic_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			if (_bfinfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
			  {
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }

			offset = _bfd_elf_section_offset
			  (output_bfd, info,
			   input_section, rel->r_offset);

			if (offset != (bfd_vma)-1)
			  _bfinfdpic_add_rofixup (output_bfd,
						  bfinfdpic_gotfixup_section
						  (info),
						  offset + input_section
						  ->output_section->vma
						  + input_section->output_offset,
						  picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    bfd_vma offset;

		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    offset = _bfd_elf_section_offset (output_bfd, info,
						      input_section, rel->r_offset);

		    if (offset != (bfd_vma)-1)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						offset + input_section
						->output_section->vma
						+ input_section->output_offset,
						r_type,
						dynindx, addend, picrel);
		  }
		else
		  addend += bfinfdpic_got_section (info)->output_section->vma;
	      }

	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_BYTE4_DATA:
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
	case R_BFIN_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;
	    bfd_vma offset;
	    offset = _bfd_elf_section_offset (output_bfd, info,
					      input_section, rel->r_offset);

	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_BFIN_FUNCDESC_VALUE)
		  {
		    info->callbacks->warning
		      (info, _("R_BFIN_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }

	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if (IS_FDPIC (input_bfd)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			if (offset != (bfd_vma)-1)
			  {
			    _bfinfdpic_add_rofixup (output_bfd,
						    bfinfdpic_gotfixup_section
						    (info),
						    offset + input_section
						    ->output_section->vma
						    + input_section->output_offset,
						    picrel);

			    if (r_type == R_BFIN_FUNCDESC_VALUE)
			      _bfinfdpic_add_rofixup
				(output_bfd,
				 bfinfdpic_gotfixup_section (info),
				 offset + input_section->output_section->vma
				 + input_section->output_offset + 4, picrel);
			  }
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }

		    if (offset != (bfd_vma)-1)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						offset
						+ input_section->output_section->vma
						+ input_section->output_offset,
						r_type, dynindx, addend, picrel);
		  }
		else if (osec)
		  addend += osec->output_section->vma;
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }

	    if (r_type == R_BFIN_FUNCDESC_VALUE)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      bfinfdpic_got_section (info)->output_section->vma
			      + bfinfdpic_got_section (info)->output_offset
			      + bfinfdpic_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! BFINFDPIC_SYM_LOCAL (info, h)
			      ? 0
			      : _bfinfdpic_osec_to_segment (output_bfd,
							    sec
							    ->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
	}

      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
	{
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && filename_cmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && filename_cmp (input_bfd->filename
				   + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
#endif
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_BFIN_PIC;
	}

      switch (r_type)
	{
	case R_BFIN_GOTOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_BFIN_GOTHI:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	  relocation >>= 16;
	  /* Fall through.  */

	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation &= 0xffff;
	  break;

	default:
	  break;
	}

      switch (r_type)
	{
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
	    break;
	  /* Fall through.  */

	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF17M4
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */
	case R_BFIN_GOTOFFHI:
	  relocation -= rel->r_addend;
	  break;

	default:
	  break;
	}

      r = bfin_final_link_relocate (rel, howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* Update the relocation information for the relocations of the section
   being removed.  */

static bfd_boolean
bfinfdpic_gc_sweep_hook (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  struct bfinfdpic_relocs_info *picrel;

  BFD_ASSERT (IS_FDPIC (abfd));

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      if (h != NULL)
	picrel = bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, NO_INSERT);
      else
	picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						  (info), abfd, r_symndx,
						  rel->r_addend, NO_INSERT);

      if (!picrel)
	return TRUE;

      switch (ELF32_R_TYPE (rel->r_info))
        {
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	  picrel->call--;
	  break;

	case R_BFIN_FUNCDESC_VALUE:
	  picrel->relocsfdv--;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  /* Fall through.  */

	case R_BFIN_BYTE4_DATA:
	  picrel->sym--;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  break;

	case R_BFIN_GOT17M4:
	  picrel->got17m4--;
	  break;

	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  picrel->gothilo--;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	  picrel->fdgot17m4--;
	  break;

	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  picrel->fdgothilo--;
	  break;

	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	  picrel->gotoff--;
	  break;

	case R_BFIN_FUNCDESC_GOTOFF17M4:
	  picrel->fdgoff17m4--;
	  break;

	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo--;
	  break;

	case R_BFIN_FUNCDESC:
	  picrel->fd--;
	  picrel->relocsfd--;
	  break;

	default:
	  break;
        }
    }

  return TRUE;
}

/* We need dynamic symbols for every section, since segments can
   relocate independently.  */
static bfd_boolean
_bfinfdpic_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info ATTRIBUTE_UNUSED,
				    asection *p)
{
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Create  a .got section, as well as its additional info field.  This
   is almost entirely copied from
   elflink.c:_bfd_elf_create_got_section().  */

static bfd_boolean
_bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  asection *s;
  struct elf_link_hash_entry *h;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign;

  /* This function may be called more than once.  */
  s = bfd_get_linker_section (abfd, ".got");
  if (s != NULL)
    return TRUE;

  /* Machine specific: although pointers are 32-bits wide, we want the
     GOT to be aligned to a 64-bit boundary, such that function
     descriptors in it can be accessed with 64-bit loads and
     stores.  */
  ptralign = 3;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  pltflags = flags;

  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (bed->want_got_plt)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      h = _bfd_elf_define_linkage_sym (abfd, info, s, "__GLOBAL_OFFSET_TABLE_");
      elf_hash_table (info)->hgot = h;
      if (h == NULL)
	return FALSE;

      /* Machine-specific: we want the symbol for executables as
	 well.  */
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* The first bit of the global offset table is the header.  */
  s->size += bed->got_header_size;

  /* This is the machine-specific part.  Create and initialize section
     data for the got.  */
  if (IS_FDPIC (abfd))
    {
      bfinfdpic_got_section (info) = s;
      bfinfdpic_relocs_info (info) = htab_try_create (1,
						      bfinfdpic_relocs_info_hash,
						      bfinfdpic_relocs_info_eq,
						      (htab_del) NULL);
      if (! bfinfdpic_relocs_info (info))
	return FALSE;

      s = bfd_make_section_anyway_with_flags (abfd, ".rel.got",
					      (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      bfinfdpic_gotrel_section (info) = s;

      /* Machine-specific.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".rofixup",
					      (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      bfinfdpic_gotfixup_section (info) = s;
    }

  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  /* Blackfin-specific: remember it.  */
  bfinfdpic_plt_section (info) = s;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "__PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;

      if (! info->executable
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* Blackfin-specific: we want rel relocations for the plt.  */
  s = bfd_make_section_anyway_with_flags (abfd, ".rel.plt",
					  flags | SEC_READONLY);
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  /* Blackfin-specific: remember it.  */
  bfinfdpic_pltrel_section (info) = s;

  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_bfinfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  /* Blackfin-specific: we want to create the GOT in the Blackfin way.  */
  if (! _bfin_create_got_section (abfd, info))
    return FALSE;

  /* Blackfin-specific: make sure we created everything we wanted.  */
  BFD_ASSERT (bfinfdpic_got_section (info) && bfinfdpic_gotrel_section (info)
	      /* && bfinfdpic_gotfixup_section (info) */
	      && bfinfdpic_plt_section (info)
	      && bfinfdpic_pltrel_section (info));

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
					      SEC_ALLOC | SEC_LINKER_CREATED);
      if (s == NULL)
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
	 normally needed.  We need to create it here, though, so that the
	 linker will map it to an output section.  We can't just create it
	 only if we need it, because we will not know whether we need it
	 until we have seen all the input files, and the first time the
	 main linker code calls BFD after examining all the input files
	 (size_dynamic_sections) the input sections have already been
	 mapped to the output sections.  If the section turns out not to
	 be needed, we can discard it later.  We will never need this
	 section when generating a shared object, since they do not use
	 copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section_anyway_with_flags (abfd,
						  ".rela.bss",
						  flags | SEC_READONLY);
	  if (s == NULL
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* Compute the total GOT size required by each symbol in each range.
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static void
_bfinfdpic_count_nontls_entries (struct bfinfdpic_relocs_info *entry,
				 struct _bfinfdpic_dynamic_got_info *dinfo)
{
  /* Allocate space for a GOT entry pointing to the symbol.  */
  if (entry->got17m4)
    dinfo->got17m4 += 4;
  else if (entry->gothilo)
    dinfo->gothilo += 4;
  else
    entry->relocs32--;
  entry->relocs32++;

  /* Allocate space for a GOT entry pointing to the function
     descriptor.  */
  if (entry->fdgot17m4)
    dinfo->got17m4 += 4;
  else if (entry->fdgothilo)
    dinfo->gothilo += 4;
  else
    entry->relocsfd--;
  entry->relocsfd++;

  /* Decide whether we need a PLT entry, a function descriptor in the
     GOT, and a lazy PLT entry for this symbol.  */
  entry->plt = entry->call
    && entry->symndx == -1 && ! BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;
  entry->privfd = entry->plt
    || entry->fdgoff17m4 || entry->fdgoffhilo
    || ((entry->fd || entry->fdgot17m4 || entry->fdgothilo)
	&& (entry->symndx != -1
	    || BFINFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
  entry->lazyplt = entry->privfd
    && entry->symndx == -1 && ! BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && ! (dinfo->info->flags & DF_BIND_NOW)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;

  /* Allocate space for a function descriptor.  */
  if (entry->fdgoff17m4)
    dinfo->fd17m4 += 8;
  else if (entry->privfd && entry->plt)
    dinfo->fdplt += 8;
  else if (entry->privfd)
    dinfo->fdhilo += 8;
  else
    entry->relocsfdv--;
  entry->relocsfdv++;

  if (entry->lazyplt)
    dinfo->lzplt += LZPLT_NORMAL_SIZE;
}

/* Compute the number of dynamic relocations and fixups that a symbol
   requires, and add (or subtract) from the grand and per-symbol
   totals.  */

static void
_bfinfdpic_count_relocs_fixups (struct bfinfdpic_relocs_info *entry,
				struct _bfinfdpic_dynamic_got_info *dinfo,
				bfd_boolean subtract)
{
  bfd_vma relocs = 0, fixups = 0;

  if (!dinfo->info->executable || dinfo->info->pie)
    relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv;
  else
    {
      if (entry->symndx != -1 || BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocs32 + 2 * entry->relocsfdv;
	}
      else
	relocs += entry->relocs32 + entry->relocsfdv;

      if (entry->symndx != -1
	  || BFINFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocsfd;
	}
      else
	relocs += entry->relocsfd;
    }

  if (subtract)
    {
      relocs = - relocs;
      fixups = - fixups;
    }

  entry->dynrelocs += relocs;
  entry->fixups += fixups;
  dinfo->relocs += relocs;
  dinfo->fixups += fixups;
}

/* Compute the total GOT and PLT size required by each symbol in each range. *
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_bfinfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_info *dinfo = dinfo_;

  _bfinfdpic_count_nontls_entries (entry, dinfo);

  _bfinfdpic_count_relocs_fixups (entry, dinfo, FALSE);

  return 1;
}

/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */

struct _bfinfdpic_dynamic_got_plt_info
{
  /* Summary information collected with _bfinfdpic_count_got_plt_entries.  */
  struct _bfinfdpic_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.  */
  struct _bfinfdpic_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_vma fdplt;
  } got17m4, gothilo;
};

/* Determine the positive and negative ranges to be used by each
   offset range in the GOT.  FDCUR and CUR, that must be aligned to a
   double-word boundary, are the minimum (negative) and maximum
   (positive) GOT offsets already used by previous ranges, except for
   an ODD entry that may have been left behind.  GOT and FD indicate
   the size of GOT entries and function descriptors that must be
   placed within the range from -WRAP to WRAP.  If there's room left,
   up to FDPLT bytes should be reserved for additional function
   descriptors.  */

inline static bfd_signed_vma
_bfinfdpic_compute_got_alloc_data (struct _bfinfdpic_dynamic_got_alloc_data *gad,
				   bfd_signed_vma fdcur,
				   bfd_signed_vma odd,
				   bfd_signed_vma cur,
				   bfd_vma got,
				   bfd_vma fd,
				   bfd_vma fdplt,
				   bfd_vma wrap)
{
  bfd_signed_vma wrapmin = -wrap;

  /* Start at the given initial points.  */
  gad->fdcur = fdcur;
  gad->cur = cur;

  /* If we had an incoming odd word and we have any got entries that
     are going to use it, consume it, otherwise leave gad->odd at
     zero.  We might force gad->odd to zero and return the incoming
     odd such that it is used by the next range, but then GOT entries
     might appear to be out of order and we wouldn't be able to
     shorten the GOT by one word if it turns out to end with an
     unpaired GOT entry.  */
  if (odd && got)
    {
      gad->odd = odd;
      got -= 4;
      odd = 0;
    }
  else
    gad->odd = 0;

  /* If we're left with an unpaired GOT entry, compute its location
     such that we can return it.  Otherwise, if got doesn't require an
     odd number of words here, either odd was already zero in the
     block above, or it was set to zero because got was non-zero, or
     got was already zero.  In the latter case, we want the value of
     odd to carry over to the return statement, so we don't want to
     reset odd unless the condition below is true.  */
  if (got & 4)
    {
      odd = cur + got;
      got += 4;
    }

  /* Compute the tentative boundaries of this range.  */
  gad->max = cur + got;
  gad->min = fdcur - fd;
  gad->fdplt = 0;

  /* If function descriptors took too much space, wrap some of them
     around.  */
  if (gad->min < wrapmin)
    {
      gad->max += wrapmin - gad->min;
      gad->min = wrapmin;
    }
  /* If there is space left and we have function descriptors
     referenced in PLT entries that could take advantage of shorter
     offsets, place them here.  */
  else if (fdplt && gad->min > wrapmin)
    {
      bfd_vma fds;
      if ((bfd_vma) (gad->min - wrapmin) < fdplt)
	fds = gad->min - wrapmin;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->min -= fds;
      gad->fdplt += fds;
    }

  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }
  /* If there is more space left, try to place some more function
     descriptors for PLT entries.  */
  else if (fdplt && (bfd_vma) gad->max < wrap)
    {
      bfd_vma fds;
      if ((bfd_vma) (wrap - gad->max) < fdplt)
	fds = wrap - gad->max;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->max += fds;
      gad->fdplt += fds;
    }

  /* If odd was initially computed as an offset past the wrap point,
     wrap it around.  */
  if (odd > gad->max)
    odd = gad->min + odd - gad->max;

  /* _bfinfdpic_get_got_entry() below will always wrap gad->cur if needed
     before returning, so do it here too.  This guarantees that,
     should cur and fdcur meet at the wrap point, they'll both be
     equal to min.  */
  if (gad->cur == gad->max)
    gad->cur = gad->min;

  return odd;
}

/* Compute the location of the next GOT entry, given the allocation
   data for a range.  */

inline static bfd_signed_vma
_bfinfdpic_get_got_entry (struct _bfinfdpic_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;

  if (gad->odd)
    {
      /* If there was an odd word left behind, use it.  */
      ret = gad->odd;
      gad->odd = 0;
    }
  else
    {
      /* Otherwise, use the word pointed to by cur, reserve the next
	 as an odd word, and skip to the next pair of words, possibly
	 wrapping around.  */
      ret = gad->cur;
      gad->odd = gad->cur + 4;
      gad->cur += 8;
      if (gad->cur == gad->max)
	gad->cur = gad->min;
    }

  return ret;
}

/* Compute the location of the next function descriptor entry in the
   GOT, given the allocation data for a range.  */

inline static bfd_signed_vma
_bfinfdpic_get_fd_entry (struct _bfinfdpic_dynamic_got_alloc_data *gad)
{
  /* If we're at the bottom, wrap around, and only then allocate the
     next pair of words.  */
  if (gad->fdcur == gad->min)
    gad->fdcur = gad->max;
  return gad->fdcur -= 8;
}

/* Assign GOT offsets for every GOT entry and function descriptor.
   Doing everything in a single pass is tricky.  */

static int
_bfinfdpic_assign_got_entries (void **entryp, void *info_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_plt_info *dinfo = info_;

  if (entry->got17m4)
    entry->got_entry = _bfinfdpic_get_got_entry (&dinfo->got17m4);
  else if (entry->gothilo)
    entry->got_entry = _bfinfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgot17m4)
    entry->fdgot_entry = _bfinfdpic_get_got_entry (&dinfo->got17m4);
  else if (entry->fdgothilo)
    entry->fdgot_entry = _bfinfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgoff17m4)
    entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
  else if (entry->plt && dinfo->got17m4.fdplt)
    {
      dinfo->got17m4.fdplt -= 8;
      entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
    }
  else if (entry->plt)
    {
      dinfo->gothilo.fdplt -= 8;
      entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);
    }
  else if (entry->privfd)
    entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);

  return 1;
}

/* Assign GOT offsets to private function descriptors used by PLT
   entries (or referenced by 32-bit offsets), as well as PLT entries
   and lazy PLT entries.  */

static int
_bfinfdpic_assign_plt_entries (void **entryp, void *info_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_plt_info *dinfo = info_;

  /* If this symbol requires a local function descriptor, allocate
     one.  */
  if (entry->privfd && entry->fd_entry == 0)
    {
      if (dinfo->got17m4.fdplt)
	{
	  entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
	  dinfo->got17m4.fdplt -= 8;
	}
      else
	{
	  BFD_ASSERT (dinfo->gothilo.fdplt);
	  entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);
	  dinfo->gothilo.fdplt -= 8;
	}
    }

  if (entry->plt)
    {
      int size;

      /* We use the section's raw size to mark the location of the
	 next PLT entry.  */
      entry->plt_entry = bfinfdpic_plt_section (dinfo->g.info)->size;

      /* Figure out the length of this PLT entry based on the
	 addressing mode we need to reach the function descriptor.  */
      BFD_ASSERT (entry->fd_entry);
      if (entry->fd_entry >= -(1 << (18 - 1))
	  && entry->fd_entry + 4 < (1 << (18 - 1)))
	size = 10;
      else
	size = 16;

      bfinfdpic_plt_section (dinfo->g.info)->size += size;
    }

  if (entry->lazyplt)
    {
      entry->lzplt_entry = dinfo->g.lzplt;
      dinfo->g.lzplt += LZPLT_NORMAL_SIZE;
      /* If this entry is the one that gets the resolver stub, account
	 for the additional instruction.  */
      if (entry->lzplt_entry % BFINFDPIC_LZPLT_BLOCK_SIZE
	  == BFINFDPIC_LZPLT_RESOLV_LOC)
	dinfo->g.lzplt += LZPLT_RESOLVER_EXTRA;
    }

  return 1;
}

/* Cancel out any effects of calling _bfinfdpic_assign_got_entries and
   _bfinfdpic_assign_plt_entries.  */

static int
_bfinfdpic_reset_got_plt_entries (void **entryp, void *ignore ATTRIBUTE_UNUSED)
{
  struct bfinfdpic_relocs_info *entry = *entryp;

  entry->got_entry = 0;
  entry->fdgot_entry = 0;
  entry->fd_entry = 0;
  entry->plt_entry = (bfd_vma)-1;
  entry->lzplt_entry = (bfd_vma)-1;

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
_bfinfdpic_resolve_final_relocs_info (void **entryp, void *p)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  htab_t *htab = p;

  if (entry->symndx == -1)
    {
      struct elf_link_hash_entry *h = entry->d.h;
      struct bfinfdpic_relocs_info *oentry;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *)h->root.u.i.link;

      if (entry->d.h == h)
	return 1;

      oentry = bfinfdpic_relocs_info_for_global (*htab, 0, h, entry->addend,
						NO_INSERT);

      if (oentry)
	{
	  /* Merge the two entries.  */
	  bfinfdpic_pic_merge_early_relocs_info (oentry, entry);
	  htab_clear_slot (*htab, entryp);
	  return 1;
	}

      entry->d.h = h;

      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (*htab, entry))
	{
	  htab_clear_slot (*htab, entryp);
	  entryp = htab_find_slot (*htab, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
    }

  return 1;
}

/* Compute the total size of the GOT, the PLT, the dynamic relocations
   section and the rofixup section.  Assign locations for GOT and PLT
   entries.  */

static bfd_boolean
_bfinfdpic_size_got_plt (bfd *output_bfd,
			 struct _bfinfdpic_dynamic_got_plt_info *gpinfop)
{
  bfd_signed_vma odd;
  bfd_vma limit;
  struct bfd_link_info *info = gpinfop->g.info;
  bfd *dynobj = elf_hash_table (info)->dynobj;

  memcpy (bfinfdpic_dynamic_got_plt_info (info), &gpinfop->g,
	  sizeof (gpinfop->g));

  odd = 12;
  /* Compute the total size taken by entries in the 18-bit range,
     to tell how many PLT function descriptors we can bring into it
     without causing it to overflow.  */
  limit = odd + gpinfop->g.got17m4 + gpinfop->g.fd17m4;
  if (limit < (bfd_vma)1 << 18)
    limit = ((bfd_vma)1 << 18) - limit;
  else
    limit = 0;
  if (gpinfop->g.fdplt < limit)
    limit = gpinfop->g.fdplt;

  /* Determine the ranges of GOT offsets that we can use for each
     range of addressing modes.  */
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfop->got17m4,
					  0,
					  odd,
					  16,
					  gpinfop->g.got17m4,
					  gpinfop->g.fd17m4,
					  limit,
					  (bfd_vma)1 << (18-1));
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfop->gothilo,
					  gpinfop->got17m4.min,
					  odd,
					  gpinfop->got17m4.max,
					  gpinfop->g.gothilo,
					  gpinfop->g.fdhilo,
					  gpinfop->g.fdplt - gpinfop->got17m4.fdplt,
					  (bfd_vma)1 << (32-1));

  /* Now assign (most) GOT offsets.  */
  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_assign_got_entries,
		 gpinfop);

  bfinfdpic_got_section (info)->size = gpinfop->gothilo.max
    - gpinfop->gothilo.min
    /* If an odd word is the last word of the GOT, we don't need this
       word to be part of the GOT.  */
    - (odd + 4 == gpinfop->gothilo.max ? 4 : 0);
  if (bfinfdpic_got_section (info)->size == 0)
    bfinfdpic_got_section (info)->flags |= SEC_EXCLUDE;
  else if (bfinfdpic_got_section (info)->size == 12
	   && ! elf_hash_table (info)->dynamic_sections_created)
    {
      bfinfdpic_got_section (info)->flags |= SEC_EXCLUDE;
      bfinfdpic_got_section (info)->size = 0;
    }
  else
    {
      bfinfdpic_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_got_section (info)->size);
      if (bfinfdpic_got_section (info)->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    /* Subtract the number of lzplt entries, since those will generate
       relocations in the pltrel section.  */
    bfinfdpic_gotrel_section (info)->size =
      (gpinfop->g.relocs - gpinfop->g.lzplt / LZPLT_NORMAL_SIZE)
      * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  else
    BFD_ASSERT (gpinfop->g.relocs == 0);
  if (bfinfdpic_gotrel_section (info)->size == 0)
    bfinfdpic_gotrel_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_gotrel_section (info)->size);
      if (bfinfdpic_gotrel_section (info)->contents == NULL)
	return FALSE;
    }

  bfinfdpic_gotfixup_section (info)->size = (gpinfop->g.fixups + 1) * 4;
  if (bfinfdpic_gotfixup_section (info)->size == 0)
    bfinfdpic_gotfixup_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_gotfixup_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_gotfixup_section (info)->size);
      if (bfinfdpic_gotfixup_section (info)->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    bfinfdpic_pltrel_section (info)->size =
      gpinfop->g.lzplt / LZPLT_NORMAL_SIZE * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  if (bfinfdpic_pltrel_section (info)->size == 0)
    bfinfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_pltrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_pltrel_section (info)->size);
      if (bfinfdpic_pltrel_section (info)->contents == NULL)
	return FALSE;
    }

  /* Add 4 bytes for every block of at most 65535 lazy PLT entries,
     such that there's room for the additional instruction needed to
     call the resolver.  Since _bfinfdpic_assign_got_entries didn't
     account for them, our block size is 4 bytes smaller than the real
     block size.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfinfdpic_plt_section (info)->size = gpinfop->g.lzplt
	+ ((gpinfop->g.lzplt + (BFINFDPIC_LZPLT_BLOCK_SIZE - 4) - LZPLT_NORMAL_SIZE)
	   / (BFINFDPIC_LZPLT_BLOCK_SIZE - 4) * LZPLT_RESOLVER_EXTRA);
    }

  /* Reset it, such that _bfinfdpic_assign_plt_entries() can use it to
     actually assign lazy PLT entries addresses.  */
  gpinfop->g.lzplt = 0;

  /* Save information that we're going to need to generate GOT and PLT
     entries.  */
  bfinfdpic_got_initial_offset (info) = -gpinfop->gothilo.min;

  if (get_elf_backend_data (output_bfd)->want_got_sym)
    elf_hash_table (info)->hgot->root.u.def.value
      = bfinfdpic_got_initial_offset (info);

  if (elf_hash_table (info)->dynamic_sections_created)
    bfinfdpic_plt_initial_offset (info) =
      bfinfdpic_plt_section (info)->size;

  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_assign_plt_entries,
		 gpinfop);

  /* Allocate the PLT section contents only after
     _bfinfdpic_assign_plt_entries has a chance to add the size of the
     non-lazy PLT entries.  */
  if (bfinfdpic_plt_section (info)->size == 0)
    bfinfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_plt_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_plt_section (info)->size);
      if (bfinfdpic_plt_section (info)->contents == NULL)
	return FALSE;
    }

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf32_bfinfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
{
  struct elf_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  struct _bfinfdpic_dynamic_got_plt_info gpinfo;

  htab = elf_hash_table (info);
  dynobj = htab->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (htab->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = bfinfdpic_relocs_info (info);

      htab_traverse (relocs, _bfinfdpic_resolve_final_relocs_info, &relocs);

      if (relocs == bfinfdpic_relocs_info (info))
	break;
    }

  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_count_got_plt_entries,
		 &gpinfo.g);

  /* Allocate space to save the summary information, we're going to
     use it if we're doing relaxations.  */
  bfinfdpic_dynamic_got_plt_info (info) = bfd_alloc (dynobj, sizeof (gpinfo.g));

  if (!_bfinfdpic_size_got_plt (output_bfd, &gpinfo))
      return FALSE;

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (bfinfdpic_got_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))
	  return FALSE;

      if (bfinfdpic_pltrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
	  return FALSE;

      if (bfinfdpic_gotrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,
					    sizeof (Elf32_External_Rel)))
	  return FALSE;
    }

  s = bfd_get_linker_section (dynobj, ".dynbss");
  if (s && s->size == 0)
    s->flags |= SEC_EXCLUDE;

  s = bfd_get_linker_section (dynobj, ".rela.bss");
  if (s && s->size == 0)
    s->flags |= SEC_EXCLUDE;

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
{
  if (!info->relocatable
      && !bfd_elf_stack_segment_size (output_bfd, info,
				      "__stacksize", DEFAULT_STACK_SIZE))
    return FALSE;

  return TRUE;
}

/* Check whether any of the relocations was optimized away, and
   subtract it from the relocation or fixup count.  */
static bfd_boolean
_bfinfdpic_check_discarded_relocs (bfd *abfd, asection *sec,
				   struct bfd_link_info *info,
				   bfd_boolean *changed)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  Elf_Internal_Rela *rel, *erel;

  if ((sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

  rel = elf_section_data (sec)->relocs;

  /* Now examine each relocation.  */
  for (erel = rel + sec->reloc_count; rel < erel; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;
      struct bfinfdpic_relocs_info *picrel;
      struct _bfinfdpic_dynamic_got_info *dinfo;

      if (ELF32_R_TYPE (rel->r_info) != R_BFIN_BYTE4_DATA
	  && ELF32_R_TYPE (rel->r_info) != R_BFIN_FUNCDESC)
	continue;

      if (_bfd_elf_section_offset (sec->output_section->owner,
				   info, sec, rel->r_offset)
	  != (bfd_vma)-1)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
	}

      if (h != NULL)
	picrel = bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info (info),
						  abfd, h,
						  rel->r_addend, NO_INSERT);
      else
	picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info (info),
						 abfd, r_symndx,
						 rel->r_addend, NO_INSERT);

      if (! picrel)
	return FALSE;

      *changed = TRUE;
      dinfo = bfinfdpic_dynamic_got_plt_info (info);

      _bfinfdpic_count_relocs_fixups (picrel, dinfo, TRUE);
      if (ELF32_R_TYPE (rel->r_info) == R_BFIN_BYTE4_DATA)
	picrel->relocs32--;
      else /* we know (ELF32_R_TYPE (rel->r_info) == R_BFIN_FUNCDESC) */
	picrel->relocsfd--;
      _bfinfdpic_count_relocs_fixups (picrel, dinfo, FALSE);
    }

  return TRUE;
}

static bfd_boolean
bfinfdpic_elf_discard_info (bfd *ibfd,
			   struct elf_reloc_cookie *cookie ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info)
{
  bfd_boolean changed = FALSE;
  asection *s;
  bfd *obfd = NULL;

  /* Account for relaxation of .eh_frame section.  */
  for (s = ibfd->sections; s; s = s->next)
    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
      {
	if (!_bfinfdpic_check_discarded_relocs (ibfd, s, info, &changed))
	  return FALSE;
	obfd = s->output_section->owner;
      }

  if (changed)
    {
      struct _bfinfdpic_dynamic_got_plt_info gpinfo;

      memset (&gpinfo, 0, sizeof (gpinfo));
      memcpy (&gpinfo.g, bfinfdpic_dynamic_got_plt_info (info),
	      sizeof (gpinfo.g));

      /* Clear GOT and PLT assignments.  */
      htab_traverse (bfinfdpic_relocs_info (info),
		     _bfinfdpic_reset_got_plt_entries,
		     NULL);

      if (!_bfinfdpic_size_got_plt (obfd, &gpinfo))
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_finish_dynamic_sections (bfd *output_bfd,
					struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  if (bfinfdpic_got_section (info))
    {
      BFD_ASSERT (bfinfdpic_gotrel_section (info)->size
		  == (bfinfdpic_gotrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));

      if (bfinfdpic_gotfixup_section (info))
	{
	  struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	  bfd_vma got_value = hgot->root.u.def.value
	    + hgot->root.u.def.section->output_section->vma
	    + hgot->root.u.def.section->output_offset;

	  _bfinfdpic_add_rofixup (output_bfd, bfinfdpic_gotfixup_section (info),
				 got_value, 0);

	  if (bfinfdpic_gotfixup_section (info)->size
	      != (bfinfdpic_gotfixup_section (info)->reloc_count * 4))
	    {
	      (*_bfd_error_handler)
		("LINKER BUG: .rofixup section size mismatch");
	      return FALSE;
	    }
	}
    }
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      BFD_ASSERT (bfinfdpic_pltrel_section (info)->size
		  == (bfinfdpic_pltrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
    }

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf32_External_Dyn * dyncon;
      Elf32_External_Dyn * dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = bfinfdpic_got_section (info)->output_section->vma
		+ bfinfdpic_got_section (info)->output_offset
		+ bfinfdpic_got_initial_offset (info);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = bfinfdpic_pltrel_section (info)
		->output_section->vma
		+ bfinfdpic_pltrel_section (info)->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = bfinfdpic_pltrel_section (info)->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */

static bfd_boolean
elf32_bfinfdpic_adjust_dynamic_symbol (struct bfd_link_info *info,
				       struct elf_link_hash_entry *h)
{
  bfd * dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
    }

  return TRUE;
}

/* Perform any actions needed for dynamic symbols.  */

static bfd_boolean
elf32_bfinfdpic_finish_dynamic_symbol
(bfd *output_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */

static bfd_boolean
bfinfdpic_elf_use_relative_eh_frame
(bfd *input_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  return FALSE;
}

/* Adjust the contents of an eh_frame_hdr section before they're output.  */

static bfd_byte
bfinfdpic_elf_encode_eh_address (bfd *abfd,
				struct bfd_link_info *info,
				asection *osec, bfd_vma offset,
				asection *loc_sec, bfd_vma loc_offset,
				bfd_vma *encoded)
{
  struct elf_link_hash_entry *h;

  h = elf_hash_table (info)->hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (_bfinfdpic_osec_to_segment (abfd, osec)
	      == _bfinfdpic_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (_bfinfdpic_osec_to_segment (abfd, osec)
	      == (_bfinfdpic_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
}



/* Look through the relocs for a section during the first phase.

   Besides handling virtual table relocs for gc, we have to deal with
   all sorts of PIC-related relocations.  We describe below the
   general plan on how to handle such relocations, even though we only
   collect information at this point, storing them in hash tables for
   perusal of later passes.

   32 relocations are propagated to the linker output when creating
   position-independent output.  LO16 and HI16 relocations are not
   supposed to be encountered in this case.

   LABEL16 should always be resolvable by the linker, since it's only
   used by branches.

   LABEL24, on the other hand, is used by calls.  If it turns out that
   the target of a call is a dynamic symbol, a PLT entry must be
   created for it, which triggers the creation of a private function
   descriptor and, unless lazy binding is disabled, a lazy PLT entry.

   GPREL relocations require the referenced symbol to be in the same
   segment as _gp, but this can only be checked later.

   All GOT, GOTOFF and FUNCDESC relocations require a .got section to
   exist.  LABEL24 might as well, since it may require a PLT entry,
   that will require a got.

   Non-FUNCDESC GOT relocations require a GOT entry to be created
   regardless of whether the symbol is dynamic.  However, since a
   global symbol that turns out to not be exported may have the same
   address of a non-dynamic symbol, we don't assign GOT entries at
   this point, such that we can share them in this case.  A relocation
   for the GOT entry always has to be created, be it to offset a
   private symbol by the section load address, be it to get the symbol
   resolved dynamically.

   FUNCDESC GOT relocations require a GOT entry to be created, and
   handled as if a FUNCDESC relocation was applied to the GOT entry in
   an object file.

   FUNCDESC relocations referencing a symbol that turns out to NOT be
   dynamic cause a private function descriptor to be created.  The
   FUNCDESC relocation then decays to a 32 relocation that points at
   the private descriptor.  If the symbol is dynamic, the FUNCDESC
   relocation is propagated to the linker output, such that the
   dynamic linker creates the canonical descriptor, pointing to the
   dynamically-resolved definition of the function.

   Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic
   symbols that are assigned to the same segment as the GOT, but we
   can only check this later, after we know the complete set of
   symbols defined and/or exported.

   FUNCDESC GOTOFF relocations require a function descriptor to be
   created and, unless lazy binding is disabled or the symbol is not
   dynamic, a lazy PLT entry.  Since we can't tell at this point
   whether a symbol is going to be dynamic, we have to decide later
   whether to create a lazy PLT entry or bind the descriptor directly
   to the private function.

   FUNCDESC_VALUE relocations are not supposed to be present in object
   files, but they may very well be simply propagated to the linker
   output, since they have no side effect.


   A function descriptor always requires a FUNCDESC_VALUE relocation.
   Whether it's in .plt.rel or not depends on whether lazy binding is
   enabled and on whether the referenced symbol is dynamic.

   The existence of a lazy PLT requires the resolverStub lazy PLT
   entry to be present.


   As for assignment of GOT, PLT and lazy PLT entries, and private
   descriptors, we might do them all sequentially, but we can do
   better than that.  For example, we can place GOT entries and
   private function descriptors referenced using 12-bit operands
   closer to the PIC register value, such that these relocations don't
   overflow.  Those that are only referenced with LO16 relocations
   could come next, but we may as well place PLT-required function
   descriptors in the 12-bit range to make them shorter.  Symbols
   referenced with LO16/HI16 may come next, but we may place
   additional function descriptors in the 16-bit range if we can
   reliably tell that we've already placed entries that are ever
   referenced with only LO16.  PLT entries are therefore generated as
   small as possible, while not introducing relocation overflows in
   GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be
   generated before or after PLT entries, but not intermingled with
   them, such that we can have more lazy PLT entries in range for a
   branch to the resolverStub.  The resolverStub should be emitted at
   the most distant location from the first lazy PLT entry such that
   it's still in range for a branch, or closer, if there isn't a need
   for so many lazy PLT entries.  Additional lazy PLT entries may be
   emitted after the resolverStub, as long as branches are still in
   range.  If the branch goes out of range, longer lazy PLT entries
   are emitted.

   We could further optimize PLT and lazy PLT entries by giving them
   priority in assignment to closer-to-gr17 locations depending on the
   number of occurrences of references to them (assuming a function
   that's called more often is more important for performance, so its
   PLT entry should be faster), or taking hints from the compiler.
   Given infinite time and money... :-)  */

static bfd_boolean
bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  bfd *dynobj;
  struct bfinfdpic_relocs_info *picrel;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  dynobj = elf_hash_table (info)->dynobj;
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	case R_BFIN_FUNCDESC:
	case R_BFIN_FUNCDESC_VALUE:
	  if (! IS_FDPIC (abfd))
	    goto bad_reloc;
	  /* Fall through.  */
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	case R_BFIN_BYTE4_DATA:
	  if (IS_FDPIC (abfd) && ! dynobj)
	    {
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfin_create_got_section (abfd, info))
		return FALSE;
	    }
	  if (! IS_FDPIC (abfd))
	    {
	      picrel = NULL;
	      break;
	    }
	  if (h != NULL)
	    {
	      if (h->dynindx == -1)
		switch (ELF_ST_VISIBILITY (h->other))
		  {
		  case STV_INTERNAL:
		  case STV_HIDDEN:
		    break;
		  default:
		    bfd_elf_link_record_dynamic_symbol (info, h);
		    break;
		  }
	      picrel
		= bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, INSERT);
	    }
	  else
	    picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						     (info), abfd, r_symndx,
						     rel->r_addend, INSERT);
	  if (! picrel)
	    return FALSE;
	  break;

	default:
	  picrel = NULL;
	  break;
	}

      switch (ELF32_R_TYPE (rel->r_info))
        {
	case R_BFIN_PCREL24:
	case R_BFIN_PCREL24_JUMP_L:
	  if (IS_FDPIC (abfd))
	    picrel->call++;
	  break;

	case R_BFIN_FUNCDESC_VALUE:
	  picrel->relocsfdv++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  /* Fall through.  */

	case R_BFIN_BYTE4_DATA:
	  if (! IS_FDPIC (abfd))
	    break;

	  picrel->sym++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  break;

	case R_BFIN_GOT17M4:
	  picrel->got17m4++;
	  break;

	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  picrel->gothilo++;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	  picrel->fdgot17m4++;
	  break;

	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  picrel->fdgothilo++;
	  break;

	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	  picrel->gotoff++;
	  break;

	case R_BFIN_FUNCDESC_GOTOFF17M4:
	  picrel->fdgoff17m4++;
	  break;

	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo++;
	  break;

	case R_BFIN_FUNCDESC:
	  picrel->fd++;
	  picrel->relocsfd++;
	  break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_BFIN_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_BFIN_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_BFIN_HUIMM16:
	case R_BFIN_LUIMM16:
	case R_BFIN_PCREL12_JUMP_S:
	case R_BFIN_PCREL10:
	  break;

	default:
	bad_reloc:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation type %i"),
	     abfd, ELF32_R_TYPE (rel->r_info));
	  return FALSE;
        }
    }

  return TRUE;
}

/* Set the right machine number for a Blackfin ELF file.  */

static bfd_boolean
elf32_bfin_object_p (bfd *abfd)
{
  bfd_default_set_arch_mach (abfd, bfd_arch_bfin, 0);
  return (((elf_elfheader (abfd)->e_flags & EF_BFIN_FDPIC) != 0)
	  == (IS_FDPIC (abfd)));
}

static bfd_boolean
elf32_bfin_set_private_flags (bfd * abfd, flagword flags)
{
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Copy backend specific data from one object module to another.  */

static bfd_boolean
bfin_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;

  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (! bfin_elf_copy_private_bfd_data (ibfd, obfd))
    return FALSE;

  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
    return TRUE;

  return TRUE;
}


/* Display the flags field.  */
static bfd_boolean
elf32_bfin_print_private_bfd_data (bfd * abfd, void * ptr)
{
  FILE *file = (FILE *) ptr;
  flagword flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (flags & EF_BFIN_PIC)
    fprintf (file, " -fpic");

  if (flags & EF_BFIN_FDPIC)
    fprintf (file, " -mfdpic");

  fputc ('\n', file);

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_bfin_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags, new_flags;
  bfd_boolean error = FALSE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (new_flags & EF_BFIN_FDPIC)
    new_flags &= ~EF_BFIN_PIC;

#ifndef DEBUG
  if (0)
#endif
  (*_bfd_error_handler) ("old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s",
			 old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no",
			 bfd_get_filename (ibfd));

  if (!elf_flags_init (obfd))			/* First call, no flags set.  */
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  if (((new_flags & EF_BFIN_FDPIC) == 0) != (! IS_FDPIC (obfd)))
    {
      error = TRUE;
      if (IS_FDPIC (obfd))
	(*_bfd_error_handler)
	  (_("%s: cannot link non-fdpic object file into fdpic executable"),
	   bfd_get_filename (ibfd));
      else
	(*_bfd_error_handler)
	  (_("%s: cannot link fdpic object file into non-fdpic executable"),
	   bfd_get_filename (ibfd));
    }

  if (error)
    bfd_set_error (bfd_error_bad_value);

  return !error;
}

/* bfin ELF linker hash entry.  */

struct bfin_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of PC relative relocs copied for this symbol.  */
  struct bfin_pcrel_relocs_copied *pcrel_relocs_copied;
};

/* bfin ELF linker hash table.  */

struct bfin_link_hash_table
{
  struct elf_link_hash_table root;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

#define bfin_hash_entry(ent) ((struct bfin_link_hash_entry *) (ent))

static struct bfd_hash_entry *
bfin_link_hash_newfunc (struct bfd_hash_entry *entry,
			struct bfd_hash_table *table, const char *string)
{
  struct bfd_hash_entry *ret = entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (struct bfin_link_hash_entry));
  if (ret == NULL)
    return ret;

  /* Call the allocation method of the superclass.  */
  ret = _bfd_elf_link_hash_newfunc (ret, table, string);
  if (ret != NULL)
    bfin_hash_entry (ret)->pcrel_relocs_copied = NULL;

  return ret;
}

/* Create an bfin ELF linker hash table.  */

static struct bfd_link_hash_table *
bfin_link_hash_table_create (bfd * abfd)
{
  struct bfin_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct bfin_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      bfin_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry),
				      BFIN_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->sym_cache.abfd = NULL;

  return &ret->root.root;
}

/* The size in bytes of an entry in the procedure linkage table.  */

/* Finish up the dynamic sections.  */

static bfd_boolean
bfin_finish_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	}

    }
  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
bfin_finish_dynamic_symbol (bfd * output_bfd,
			    struct bfd_link_info *info,
			    struct elf_link_hash_entry *h,
			    Elf_Internal_Sym * sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->got.offset != (bfd_vma) - 1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.
         Set it up.  */

      sgot = bfd_get_linker_section (dynobj, ".got");
      srela = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + (h->got.offset & ~(bfd_vma) 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
         locally, we just want to emit a RELATIVE reloc.  Likewise if
         the symbol was forced to be local because of a version file.
         The entry in the global offset table will already have been
         initialized in the relocate_section function.  */
      if (info->shared
	  && (info->symbolic
	      || h->dynindx == -1 || h->forced_local) && h->def_regular)
	{
	  (*_bfd_error_handler) (_("*** check this relocation %s"),
				 __FUNCTION__);
	  rela.r_info = ELF32_R_INFO (0, R_BFIN_PCREL24);
	  rela.r_addend = bfd_get_signed_32 (output_bfd,
					     (sgot->contents
					      +
					      (h->got.
					       offset & ~(bfd_vma) 1)));
	}
      else
	{
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      sgot->contents + (h->got.offset & ~(bfd_vma) 1));
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_BFIN_GOT);
	  rela.r_addend = 0;
	}

      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->needs_copy)
    {
      BFD_ASSERT (0);
    }
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "__DYNAMIC") == 0
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
bfin_adjust_dynamic_symbol (struct bfd_link_info *info,
			    struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;
  unsigned int power_of_two;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic && h->ref_regular && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC || h->needs_plt)
    {
      BFD_ASSERT(0);
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_linker_section (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_68K_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;

      srel = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (!bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
}

/* The bfin linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that it
   can discard PC relative relocs if it doesn't need them when linking
   with -Bsymbolic.  We store the information in a field extending the
   regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we have
   copied for a given symbol.  */

struct bfin_pcrel_relocs_copied
{
  /* Next section.  */
  struct bfin_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* This function is called via elf_link_hash_traverse if we are
   creating a shared object.  In the -Bsymbolic case it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal shared case, it
   discards space for pc-relative relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.

   We also check whether any of the remaining relocations apply
   against a readonly section, and set the DF_TEXTREL flag in this
   case.  */

static bfd_boolean
bfin_discard_copies (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
  struct bfin_pcrel_relocs_copied *s;

  if (!h->def_regular || (!info->symbolic && !h->forced_local))
    {
      if ((info->flags & DF_TEXTREL) == 0)
	{
	  /* Look for relocations against read-only sections.  */
	  for (s = bfin_hash_entry (h)->pcrel_relocs_copied;
	       s != NULL; s = s->next)
	    if ((s->section->flags & SEC_READONLY) != 0)
	      {
		info->flags |= DF_TEXTREL;
		break;
	      }
	}

      return TRUE;
    }

  for (s = bfin_hash_entry (h)->pcrel_relocs_copied;
       s != NULL; s = s->next)
    s->section->size -= s->count * sizeof (Elf32_External_Rela);

  return TRUE;
}

static bfd_boolean
bfin_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_linker_section (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     For the normal shared case we discard the PC relative relocs
     against symbols that have become local due to visibility changes.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf_link_hash_traverse (elf_hash_table (info),
			    bfin_discard_copies, info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      bfd_boolean strip;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
         of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

       if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
	         output file.  This is mostly to handle .rela.bss and
	         .rela.plt.  We must create both sections in
	         create_dynamic_sections, because they must be created
	         before the linker maps input sections to output
	         sections.  The linker does that before
	         adjust_dynamic_symbol is called, and it is that
	         function which decides whether anything needs to go
	         into these sections.  */
	      strip = TRUE;
	    }
	  else
	    {
	      relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
	         to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".got"))
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      /* Allocate memory for the section contents.  */
      /* FIXME: This should be a call to bfd_alloc not bfd_zalloc.
         Unused entries should be reclaimed before the section's contents
         are written out, but at the moment this does not happen.  Thus in
         order to prevent writing out garbage, we initialise the section's
         contents to zero.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
         values later, in bfin_finish_dynamic_sections, but we
         must add the entries now so that we get the correct size for
         the .dynamic section.  The DT_DEBUG entry is filled in by the
         dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!info->shared)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}


      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT,
				     sizeof (Elf32_External_Rela)))
	    return FALSE;
	}

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Given a .data section and a .emreloc in-memory section, store
   relocation information into the .emreloc section which can be
   used at runtime to relocate the section.  This is called by the
   linker when the --embedded-relocs switch is used.  This is called
   after the add_symbols entry point has been called for all the
   objects, and before the final_link entry point is called.  */

bfd_boolean
bfd_bfin_elf32_create_embedded_relocs (bfd *abfd,
				       struct bfd_link_info *info,
				       asection *datasec,
				       asection *relsec,
				       char **errmsg)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *p;
  bfd_size_type amt;

  BFD_ASSERT (! info->relocatable);

  *errmsg = NULL;

  if (datasec->reloc_count == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, datasec, NULL, (Elf_Internal_Rela *) NULL,
		      info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  amt = (bfd_size_type) datasec->reloc_count * 12;
  relsec->contents = (bfd_byte *) bfd_alloc (abfd, amt);
  if (relsec->contents == NULL)
    goto error_return;

  p = relsec->contents;

  irelend = internal_relocs + datasec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++, p += 12)
    {
      asection *targetsec;

      /* We are going to write a four byte longword into the runtime
       reloc section.  The longword will be the address in the data
       section which must be relocated.  It is followed by the name
       of the target section NUL-padded or truncated to 8
       characters.  */

      /* We can only relocate absolute longword relocs at run time.  */
      if (ELF32_R_TYPE (irel->r_info) != (int) R_BFIN_BYTE4_DATA)
	{
	  *errmsg = _("unsupported reloc type");
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}

      /* Get the target section referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols if we haven't done so already.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		goto error_return;
	    }

	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  targetsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
	}
      else
	{
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    targetsec = h->root.u.def.section;
	  else
	    targetsec = NULL;
	}

      bfd_put_32 (abfd, irel->r_offset + datasec->output_offset, p);
      memset (p + 4, 0, 8);
      if (targetsec != NULL)
	strncpy ((char *) p + 4, targetsec->output_section->name, 8);
    }

  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  return TRUE;

error_return:
  if (isymbuf != NULL && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (datasec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

struct bfd_elf_special_section const elf32_bfin_special_sections[] =
{
  { ".l1.text",		8, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".l1.data",		8, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,		0,  0, 0,            0 }
};


#define TARGET_LITTLE_SYM		bfd_elf32_bfin_vec
#define TARGET_LITTLE_NAME		"elf32-bfin"
#define ELF_ARCH			bfd_arch_bfin
#define ELF_TARGET_ID			BFIN_ELF_DATA
#define ELF_MACHINE_CODE		EM_BLACKFIN
#define ELF_MAXPAGESIZE			0x1000
#define elf_symbol_leading_char		'_'

#define bfd_elf32_bfd_reloc_type_lookup	bfin_bfd_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
					bfin_bfd_reloc_name_lookup
#define elf_info_to_howto		bfin_info_to_howto
#define elf_info_to_howto_rel		0
#define elf_backend_object_p		elf32_bfin_object_p

#define bfd_elf32_bfd_is_local_label_name \
                                        bfin_is_local_label_name
#define bfin_hash_table(p) \
  ((struct bfin_link_hash_table *) (p)->hash)



#define elf_backend_create_dynamic_sections \
                                        _bfd_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create \
                                        bfin_link_hash_table_create
#define bfd_elf32_bfd_final_link        bfd_elf_gc_common_final_link

#define elf_backend_check_relocs        bfin_check_relocs
#define elf_backend_adjust_dynamic_symbol \
                                        bfin_adjust_dynamic_symbol
#define elf_backend_size_dynamic_sections \
                                        bfin_size_dynamic_sections
#define elf_backend_relocate_section    bfin_relocate_section
#define elf_backend_finish_dynamic_symbol \
                                        bfin_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
                                        bfin_finish_dynamic_sections
#define elf_backend_gc_mark_hook        bfin_gc_mark_hook
#define elf_backend_gc_sweep_hook       bfin_gc_sweep_hook
#define bfd_elf32_bfd_merge_private_bfd_data \
                                        elf32_bfin_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags \
                                        elf32_bfin_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
                                        elf32_bfin_print_private_bfd_data
#define elf_backend_final_write_processing \
                                        elf32_bfin_final_write_processing
#define elf_backend_reloc_type_class    elf32_bfin_reloc_type_class
#define elf_backend_stack_align		8
#define elf_backend_can_gc_sections 1
#define elf_backend_special_sections	elf32_bfin_special_sections
#define elf_backend_can_refcount 1
#define elf_backend_want_got_plt 0
#define elf_backend_plt_readonly 1
#define elf_backend_want_plt_sym 0
#define elf_backend_got_header_size     12
#define elf_backend_rela_normal         1

#include "elf32-target.h"

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM          bfd_elf32_bfinfdpic_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elf32-bfinfdpic"
#undef	elf32_bed
#define	elf32_bed		elf32_bfinfdpic_bed

#undef elf_backend_gc_sweep_hook
#define elf_backend_gc_sweep_hook       bfinfdpic_gc_sweep_hook

#undef elf_backend_got_header_size
#define elf_backend_got_header_size     0

#undef elf_backend_relocate_section
#define elf_backend_relocate_section    bfinfdpic_relocate_section
#undef elf_backend_check_relocs
#define elf_backend_check_relocs        bfinfdpic_check_relocs

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
		bfinfdpic_elf_link_hash_table_create
#undef elf_backend_always_size_sections
#define elf_backend_always_size_sections \
		elf32_bfinfdpic_always_size_sections
#undef bfd_elf32_bfd_copy_private_bfd_data
#define bfd_elf32_bfd_copy_private_bfd_data \
		elf32_bfinfdpic_copy_private_bfd_data

#undef elf_backend_create_dynamic_sections
#define elf_backend_create_dynamic_sections \
		elf32_bfinfdpic_create_dynamic_sections
#undef elf_backend_adjust_dynamic_symbol
#define elf_backend_adjust_dynamic_symbol \
		elf32_bfinfdpic_adjust_dynamic_symbol
#undef elf_backend_size_dynamic_sections
#define elf_backend_size_dynamic_sections \
		elf32_bfinfdpic_size_dynamic_sections
#undef elf_backend_finish_dynamic_symbol
#define elf_backend_finish_dynamic_symbol \
		elf32_bfinfdpic_finish_dynamic_symbol
#undef elf_backend_finish_dynamic_sections
#define elf_backend_finish_dynamic_sections \
		elf32_bfinfdpic_finish_dynamic_sections

#undef elf_backend_discard_info
#define elf_backend_discard_info \
		bfinfdpic_elf_discard_info
#undef elf_backend_can_make_relative_eh_frame
#define elf_backend_can_make_relative_eh_frame \
		bfinfdpic_elf_use_relative_eh_frame
#undef elf_backend_can_make_lsda_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
		bfinfdpic_elf_use_relative_eh_frame
#undef elf_backend_encode_eh_address
#define elf_backend_encode_eh_address \
		bfinfdpic_elf_encode_eh_address

#undef elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p       1
#undef elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p      1
/* We use REL for dynamic relocations only.  */
#undef elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p  1

#undef elf_backend_omit_section_dynsym
#define elf_backend_omit_section_dynsym _bfinfdpic_link_omit_section_dynsym

#include "elf32-target.h"
@


1.62
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d1190 7
a1196 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.61
log
@	* i386linux.c (linux_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_alloc.
	* pdp11.c (link_hash_table_create): Allocate table with
	bfd_malloc, not bfd_alloc.
	* elf32-bfin.c (bfinfdpic_elf_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_zalloc.
	(bfin_link_hash_table_create): Likewise.
	* elf32-frv.c (frvfdpic_elf_link_hash_table_create): Likewise.
	* elf64-hppa.c (elf64_hppa_hash_table_create): Likewise.
@
text
@d1304 3
a1306 1
elf32_bfin_reloc_type_class (const Elf_Internal_Rela * rela)
@


1.60
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d1824 1
a1824 1
  ret = bfd_zalloc (abfd, amt);
d5091 1
a5091 1
  ret = bfd_zalloc (abfd, amt);
@


1.59
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d4314 4
a4317 29
  if (!info->relocatable)
    {
      struct elf_link_hash_entry *h;

      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !h->def_regular)
	{
	  struct bfd_link_hash_entry *bh = NULL;

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;
	}
    }
a4437 45
elf32_bfinfdpic_modify_program_headers (bfd *output_bfd,
					struct bfd_link_info *info)
{
  struct elf_obj_tdata *tdata = elf_tdata (output_bfd);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* objcopy and strip preserve what's already there using
     elf32_bfinfdpic_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

  for (p = tdata->phdr, m = tdata->segment_map; m != NULL; m = m->next, p++)
    if (m->p_type == PT_GNU_STACK)
      break;

  if (m)
    {
      struct elf_link_hash_entry *h;

      /* Obtain the pointer to the __stacksize symbol.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (h)
	{
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
	}

      /* Set the header p_memsz from the symbol value.  We
	 intentionally ignore the symbol section.  */
      if (h && h->root.type == bfd_link_hash_defined)
	p->p_memsz = h->root.u.def.value;
      else
	p->p_memsz = DEFAULT_STACK_SIZE;

      p->p_align = 8;
    }

  return TRUE;
}

static bfd_boolean
a4949 2
  unsigned i;

a4960 25
  /* Copy the stack size.  */
  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
      {
	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
	    {
	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

	      /* Rewrite the phdrs, since we're only called after they
		 were first written.  */
	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
			    ->s->sizeof_ehdr, SEEK_SET) != 0
		  || get_elf_backend_data (obfd)->s
		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
				     elf_elfheader (obfd)->e_phnum) != 0)
		return FALSE;
	      break;
	    }

	break;
      }

d5708 1
a5743 3
#undef elf_backend_modify_program_headers
#define elf_backend_modify_program_headers \
		elf32_bfinfdpic_modify_program_headers
@


1.58
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d37 1
a37 1
     PTR data ATTRIBUTE_UNUSED,
d51 1
a51 1
                    PTR data,
d148 1
a148 1
     		  PTR data,
d220 1
a220 1
                  PTR data,
d286 1
a286 1
     		PTR data,
d1112 1
a1112 1
			    unsigned int r_type)
d1142 1
a1142 3
bfin_is_local_label_name (
     bfd *abfd,
     const char *label)
d1168 1
d1999 4
a2002 4
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
d2037 1
a2037 1
				      struct bfinfdpic_relocs_info const *e1)
d2103 1
a2103 1
		       struct bfinfdpic_relocs_info *entry)
a2157 1

d2159 1
a2159 1
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
d4351 2
a4352 3
				  struct bfd_link_info *info,
				  
				  bfd_boolean *changed)
d4600 2
a4601 3
elf32_bfinfdpic_adjust_dynamic_symbol
(struct bfd_link_info *info,
 struct elf_link_hash_entry *h)
d5064 1
a5064 1
elf32_bfin_print_private_bfd_data (bfd * abfd, PTR ptr)
d5212 1
a5212 1
				  struct bfd_link_info *info)
d5246 3
a5248 3
				struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				Elf_Internal_Sym * sym)
d5323 1
a5323 1
				struct elf_link_hash_entry *h)
d5451 1
a5451 1
bfin_discard_copies (struct elf_link_hash_entry *h, PTR inf)
d5482 1
a5482 1
				struct bfd_link_info *info)
d5522 1
a5522 1
			    bfin_discard_copies, (PTR) info);
a5632 3
bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *, char **));

d5634 5
a5638 6
bfd_bfin_elf32_create_embedded_relocs (
     bfd *abfd,
     struct bfd_link_info *info,
     asection *datasec,
     asection *relsec,
     char **errmsg)
d5658 1
a5658 1
		     (abfd, datasec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
@


1.57
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1227 1
a1227 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d1233 1
a1233 1
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d1239 3
a1241 2
		  srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
							 flags);
d1487 1
a1487 1
		sgot = bfd_get_section_by_name (dynobj, ".got");
d1551 1
a1551 1
			s = bfd_get_section_by_name (dynobj, ".rela.got");
d1680 2
a1681 2
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d3391 2
a3392 2
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
d3405 1
a3405 1
  s = bfd_make_section_with_flags (abfd, ".got", flags);
d3412 1
a3412 1
      s = bfd_make_section_with_flags (abfd, ".got.plt", flags);
d3450 2
a3451 2
      s = bfd_make_section_with_flags (abfd, ".rel.got",
				       (flags | SEC_READONLY));
d3459 2
a3460 2
      s = bfd_make_section_with_flags (abfd, ".rofixup",
				       (flags | SEC_READONLY));
d3474 1
a3474 1
  s = bfd_make_section_with_flags (abfd, ".plt", pltflags);
d3501 2
a3502 1
  s = bfd_make_section_with_flags (abfd, ".rel.plt", flags | SEC_READONLY);
d3548 2
a3549 2
      s = bfd_make_section_with_flags (abfd, ".dynbss",
				       SEC_ALLOC | SEC_LINKER_CREATED);
d3554 10
a3563 10
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
d3566 3
a3568 3
	  s = bfd_make_section_with_flags (abfd,
					   ".rela.bss",
					   flags | SEC_READONLY);
d4251 1
a4251 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d4301 1
a4301 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d4305 1
a4305 1
  s = bfd_get_section_by_name (dynobj, ".rela.bss");
d4551 1
a4551 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d5223 1
a5223 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d5268 2
a5269 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
d5381 1
a5381 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d5392 1
a5392 1
      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d5500 1
a5500 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d5513 1
a5513 1
      s = bfd_get_section_by_name (dynobj, ".rela.got");
@


1.56
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1449 1
a1449 1
					 rel, relend, howto, contents);
d2670 1
a2670 1
					 rel, relend, howto, contents);
@


1.55
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1447 1
a1447 1
      if (sec != NULL && elf_discarded_section (sec))
d2668 1
a2668 1
      if (sec != NULL && elf_discarded_section (sec))
d4436 1
a4436 1
    if (s->sec_info_type == ELF_INFO_TYPE_EH_FRAME)
@


1.54
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d1588 3
a1590 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0 && h->def_dynamic))
d2736 3
a2738 1
	  if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
@


1.54.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1447 1
a1447 1
      if (sec != NULL && discarded_section (sec))
d2666 1
a2666 1
      if (sec != NULL && discarded_section (sec))
d4432 1
a4432 1
    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
@


1.53
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@a5453 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.52
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d3106 1
a3106 1
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
d3108 2
a3109 2
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
@


1.51
log
@blackfin: add support for L1 code/data flags

Add new linker options for marking programs to load into L1 memory
at runtime.  This needs new EF flag bits, so declare them.

Signed-off-by: Jie Zhang <jie.zhang@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010
d107 1
a107 1
      fprintf(stderr, "relocation should be even number\n");
d363 1
a363 1
      fprintf(stderr, "relocation should be even number\n");
d5279 2
a5280 1
	  fprintf(stderr, "*** check this relocation %s\n", __FUNCTION__);
@


1.50
log
@bfd: bfin: drop needless symbol flag handling imported from FRV

The Blackfin bfd merged some FRV code recently, and then removed pieces
that didn't make sense.  In the FRV code, it outputs a "_gp" symbol in
its BFD whereas in the Blackfin code, we don't.  So while on the FRV
side it fiddles with the "flags" variable (sometimes using it for section
flags and sometimes using it for symbol flags), we don't need any of
that.  This lead to BZ 12177 where the Blackfin code is a bit confusing.
So to fix things up, remove more stuff we don't need.  Shouldn't change
the behavior at all.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1123 16
d5806 2
@


1.49
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@a3444 5
      flags = BSF_GLOBAL;
    }
  else
    {
      flags = BSF_GLOBAL | BSF_WEAK;
a3446 1
  flags = pltflags;
@


1.49.2.1
log
@backport from mainline
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011
d107 1
a107 1
      (*_bfd_error_handler) (_("relocation should be even number"));
d363 1
a363 1
      (*_bfd_error_handler) (_("relocation should be even number"));
d5269 1
a5269 2
	  (*_bfd_error_handler) (_("*** check this relocation %s"),
				 __FUNCTION__);
@


1.48
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d1432 2
a1433 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
d2651 2
a2652 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.47
log
@fix set but unused variable warnings
@
text
@d5767 1
@


1.46
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a3381 1
  int offset;
a3458 1
      offset = -2048;
a3462 1
      offset = 2048;
d5107 3
a5109 1
#ifdef DEBUG
a5112 1
#endif
@


1.45
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 1
   Copyright 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1720 2
a1721 2
/* An extension of the elf hash table data structure, containing some
   additional Blackfin-specific data.  */
d1752 2
a1753 1
  ((struct bfinfdpic_elf_link_hash_table *) ((info)->hash))
d1819 2
a1820 1
				      sizeof (struct elf_link_hash_entry)))
d5198 2
a5199 1
				      sizeof (struct elf_link_hash_entry)))
@


1.44
log
@	* elf32-bfin.c (_bfinfdpic_size_got_plt): Make sure empty
	.rel.plt and .plt sections are removed.
	(elf32_bfinfdpic_size_dynamic_sections): Remove empty .dynbss
	section.  Remove the duplicated removing of empty .rel.plt
	section.
@
text
@a3483 1
      struct elf_link_hash_entry *h;
@


1.43
log
@	* elf32-bfin.c (bfinfdpic_relocs_info_find): Just return
	NULL if `ht' is NULL.
@
text
@d4169 5
d4175 5
a4179 12
      bfinfdpic_pltrel_section (info)->size =
	gpinfop->g.lzplt / LZPLT_NORMAL_SIZE * get_elf_backend_data (output_bfd)->s->sizeof_rel;
      if (bfinfdpic_pltrel_section (info)->size == 0)
	bfinfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
      else
	{
	  bfinfdpic_pltrel_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     bfinfdpic_pltrel_section (info)->size);
	  if (bfinfdpic_pltrel_section (info)->contents == NULL)
	    return FALSE;
	}
d4216 3
a4218 1
  if (elf_hash_table (info)->dynamic_sections_created)
d4220 5
a4224 10
      if (bfinfdpic_plt_section (info)->size == 0)
	bfinfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
      else
	{
	  bfinfdpic_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     bfinfdpic_plt_section (info)->size);
	  if (bfinfdpic_plt_section (info)->contents == NULL)
	    return FALSE;
	}
d4300 1
a4300 2

  s = bfd_get_section_by_name (dynobj, ".rela.bss");
d4304 1
a4304 1
  s = bfd_get_section_by_name (dynobj, ".rel.plt");
@


1.42
log
@	* elf32-bfin.c (elf32_bfinfdpic_create_dynamic_sections): Always
	create .rela.bss.
	(elf32_bfinfdpic_size_dynamic_sections): Set SEC_EXCLUDE flag
	for empty .rela.bss and .rel.plt sections.
@
text
@d1953 6
a1958 2
  struct bfinfdpic_relocs_info **loc =
    (struct bfinfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
@


1.42.2.1
log
@	* elf32-bfin.c (bfinfdpic_relocs_info_find): Just return
	NULL if `ht' is NULL.
@
text
@d1953 2
a1954 6
  struct bfinfdpic_relocs_info **loc;

  if (!ht)
    return NULL;

  loc = (struct bfinfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
@


1.42.2.2
log
@	* elf32-bfin.c (_bfinfdpic_size_got_plt): Make sure empty
	.rel.plt and .plt sections are removed.
	(elf32_bfinfdpic_size_dynamic_sections): Remove empty .dynbss
	section.  Remove the duplicated removing of empty .rel.plt
	section.
@
text
@a4168 5
    bfinfdpic_pltrel_section (info)->size =
      gpinfop->g.lzplt / LZPLT_NORMAL_SIZE * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  if (bfinfdpic_pltrel_section (info)->size == 0)
    bfinfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
  else
d4170 12
a4181 5
      bfinfdpic_pltrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_pltrel_section (info)->size);
      if (bfinfdpic_pltrel_section (info)->contents == NULL)
	return FALSE;
d4218 1
a4218 3
  if (bfinfdpic_plt_section (info)->size == 0)
    bfinfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
  else
d4220 10
a4229 5
      bfinfdpic_plt_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_plt_section (info)->size);
      if (bfinfdpic_plt_section (info)->contents == NULL)
	return FALSE;
d4305 2
a4306 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d4310 1
a4310 1
  s = bfd_get_section_by_name (dynobj, ".rela.bss");
@


1.41
log
@update copyright dates
@
text
@d3562 1
a3562 2
					   (bed->default_use_rela_p
					    ? ".rela.bss" : ".rel.bss"),
d4301 9
@


1.40
log
@	Merge some FRV FDPIC changes into the Blackfin code.
	* elf32-bfin.c (struct bfinfdpic_elf_link_hash_table): Add pointer to
	summary reloc information.
	(bfinfdpic_dynamic_got_plt_info): New.
	(_bfin_create_got_section): Create the PLT section here.
	(elf32_bfinfdpic_create_dynamic_sections): Not here.
	(_bfinfdpic_count_nontls_entries): Move out of...
	(_bfinfdpic_count_got_plt_entries): ... here.
	(_bfinfdpic_count_relocs_fixups): Likewise.
	(_bfinfdpic_reset_got_plt_entries): New.
	(_bfinfdpic_size_got_plt): Move out of...
	(elf32_bfinfdpic_size_dynamic_sections): ... here.
	(bfinfdpic_relocate_section): Be careful not to call
	_bfinfdpic_add_rofixup or _bfinfdpic_add_dyn_reloc for deleted relocs.
	(bfinfdpic_check_discarded_relocs, bfinfdpic_elf_discard_info):
	New functions.
	(elf_backend_discard_info): Define for FD-PIC.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.39
log
@bfd/
	From Mike Frysinger <michael.frysinger@@analog.com>
	* elf32-bfin.c (bfin_howto_table, bfin_reloc_map, bfin_check_relocs,
	bfin_final_link_relocate, bfin_relocate_section, bfin_gc_sweep_hook,
	_bfinfdpic_emit_got_relocs_plt_entries, bfinfdpic_relocate_section,
	bfinfdpic_gc_sweep_hook, bfinfdpic_check_relocs,
	bfin_finish_dynamic_symbol, bfd_bfin_elf32_create_embedded_relocs):
	Adjust to match the renamed reloc definitions.

gas/testsuite/
	From Mike Frysinger <michael.frysinger@@analog.com>
	* gas/bfin/reloc.d: Adjust for the renamed relocations.

include/elf/
	From Mike Frysinger <michael.frysinger@@analog.com>
	* bfin.h (R_BFIN_UNUSED, R_BFIN_PCREL5M2, R_BFIN_UNUSED1,
	R_BFIN_PCREL10, R_BFIN_PCREL12_JUMP, R_BFIN_RIMM16,
	R_BFIN_LUIMM16, R_BFIN_HUIMM16, R_BFIN_PCREL12_JUMP_S,
	R_BFIN_PCREL24_JUMP_X, R_BFIN_PCREL24, R_BFIN_UNUSEDB,
	R_BFIN_UNUSEDC, R_BFIN_PCREL24_JUMP_L, R_BFIN_PCREL24_CALL_X,
	R_BFIN_VAR_EQ_SYMB, R_BFIN_BYTE_DATA, R_BFIN_BYTE2_DATA,
	R_BFIN_BYTE4_DATA, R_BFIN_PCREL11, R_BFIN_PUSH, R_BFIN_CONST,
	R_BFIN_ADD, R_BFIN_SUB, R_BFIN_MULT, R_BFIN_DIV, R_BFIN_MOD,
	R_BFIN_LSHIFT, R_BFIN_RSHIFT, R_BFIN_AND, R_BFIN_OR, R_BFIN_XOR,
	R_BFIN_LAND, R_BFIN_LOR, R_BFIN_LEN, R_BFIN_NEG, R_BFIN_COMP,
	R_BFIN_PAGE, R_BFIN_HWPAGE, R_BFIN_ADDR, R_BFIN_PLTPLC,
	R_BFIN_GOT, R_BFIN_MAX): Renamed from R_unused0, R_pcrel5ms,
	R_unused1, R_pcrel10, R_pcrel12_jump, R_rimm16, R_luimm16,
	R_huimm16, R_pcrel12_jump_s, R_pcrel24_jump_x, R_pcrel24,
	R_unusedb, R_unusedc, R_pcrel24_jump_l, R_pcrel24_call_x,
	R_var_eq_symb, R_byte_data, R_byte2_data, R_byte4_data, R_pcrel11,
	R_push, R_const, R_add, R_sub, R_mult, R_div, R_mod, R_lshift,
	R_rshift, R_and, R_or, R_xor, R_land, R_lor, R_len, R_neg, R_comp,
	R_page, R_hwpage, R_addr, R_pltpc, R_got.
@
text
@d1743 3
d1769 2
d2157 2
a2158 1
	  if (sec->output_section
d2426 3
a2428 2
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
d2853 2
d2870 13
a2882 10
			_bfinfdpic_add_rofixup (output_bfd,
					       bfinfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2903 2
a2904 8
		    /* Only output a reloc for a not deleted entry.  */
		    if (offset >= (bfd_vma) -2)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						0,
						R_BFIN_UNUSED0,
						dynindx, addend, picrel);
		    else
d2995 9
a3003 13
			/* Only output a reloc for a not deleted entry.  */
			if (offset >= (bfd_vma)-2)
			  _bfinfdpic_add_rofixup (output_bfd,
						  bfinfdpic_gotfixup_section
						  (info), -1, picrel);
			else
			  _bfinfdpic_add_rofixup (output_bfd,
						  bfinfdpic_gotfixup_section
						  (info),
						  offset + input_section
						  ->output_section->vma
						  + input_section->output_offset,
						  picrel);
d3005 1
a3005 8
			if (r_type == R_BFIN_FUNCDESC_VALUE)
			  {
			    if (offset >= (bfd_vma)-2)
			      _bfinfdpic_add_rofixup
				(output_bfd,
				 bfinfdpic_gotfixup_section (info),
				 -1, picrel);
			    else
d3031 2
a3032 6
		    /* Only output a reloc for a not deleted entry.  */
		    if (offset >= (bfd_vma)-2)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						0, R_BFIN_UNUSED0, dynindx, addend, picrel);
		    else
d3036 1
a3036 2
						+ input_section
						->output_section->vma
d3048 1
a3048 1
	    if (r_type == R_BFIN_FUNCDESC_VALUE && offset < (bfd_vma)-2)
d3462 1
a3462 22
  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_bfinfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
d3504 21
d3579 3
a3581 2
static int
_bfinfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
a3582 4
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_info *dinfo = dinfo_;
  unsigned relocs = 0, fixups = 0;

d3630 12
d3667 6
d3677 16
d3988 17
d4061 3
a4063 1
/* Set the sizes of the dynamic sections.  */
d4066 2
a4067 2
elf32_bfinfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
a4068 3
  bfd *dynobj;
  asection *s;
  struct _bfinfdpic_dynamic_got_plt_info gpinfo;
d4071 2
d4074 2
a4075 30
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;

  for (;;)
    {
      htab_t relocs = bfinfdpic_relocs_info (info);

      htab_traverse (relocs, _bfinfdpic_resolve_final_relocs_info, &relocs);

      if (relocs == bfinfdpic_relocs_info (info))
	break;
    }

  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_count_got_plt_entries,
		 &gpinfo.g);
d4081 1
a4081 1
  limit = odd + gpinfo.g.got17m4 + gpinfo.g.fd17m4;
d4086 2
a4087 2
  if (gpinfo.g.fdplt < limit)
    limit = gpinfo.g.fdplt;
d4091 1
a4091 1
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfo.got17m4,
d4095 2
a4096 2
					  gpinfo.g.got17m4,
					  gpinfo.g.fd17m4,
d4099 2
a4100 2
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfo.gothilo,
					  gpinfo.got17m4.min,
d4102 4
a4105 4
					  gpinfo.got17m4.max,
					  gpinfo.g.gothilo,
					  gpinfo.g.fdhilo,
					  gpinfo.g.fdplt - gpinfo.got17m4.fdplt,
d4110 1
a4110 1
		 &gpinfo);
d4112 2
a4113 2
  bfinfdpic_got_section (info)->size = gpinfo.gothilo.max
    - gpinfo.gothilo.min
d4116 1
a4116 1
    - (odd + 4 == gpinfo.gothilo.max ? 4 : 0);
d4138 1
a4138 1
      (gpinfo.g.relocs - gpinfo.g.lzplt / LZPLT_NORMAL_SIZE)
d4141 1
a4141 1
    BFD_ASSERT (gpinfo.g.relocs == 0);
d4153 1
a4153 1
  bfinfdpic_gotfixup_section (info)->size = (gpinfo.g.fixups + 1) * 4;
d4168 1
a4168 1
	gpinfo.g.lzplt / LZPLT_NORMAL_SIZE * get_elf_backend_data (output_bfd)->s->sizeof_rel;
d4188 2
a4189 2
      bfinfdpic_plt_section (info)->size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (BFINFDPIC_LZPLT_BLOCK_SIZE - 4) - LZPLT_NORMAL_SIZE)
d4195 1
a4195 1
  gpinfo.g.lzplt = 0;
d4199 1
a4199 1
  bfinfdpic_got_initial_offset (info) = -gpinfo.gothilo.min;
d4203 1
a4203 1
      += bfinfdpic_got_initial_offset (info);
d4210 1
a4210 1
		 &gpinfo);
d4229 53
d4342 116
d5861 3
@


1.38
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d424 1
a424 1
  HOWTO (R_unused0,		/* type.  */
d432 1
a432 1
	 "R_unused0",		/* name.  */
d438 1
a438 1
  HOWTO (R_pcrel5m2,		/* type.  */
d446 1
a446 1
	 "R_pcrel5m2",		/* name.  */
d452 1
a452 1
  HOWTO (R_unused1,		/* type.  */
d460 1
a460 1
	 "R_unused1",		/* name.  */
d466 1
a466 1
  HOWTO (R_pcrel10,		/* type.  */
d474 1
a474 1
	 "R_pcrel10",		/* name.  */
d480 1
a480 1
  HOWTO (R_pcrel12_jump,	/* type.  */
d492 1
a492 1
	 "R_pcrel12_jump",	/* name.  */
d498 1
a498 1
  HOWTO (R_rimm16,		/* type.  */
d506 1
a506 1
	 "R_rimm16",		/* name.  */
d512 1
a512 1
  HOWTO (R_luimm16,		/* type.  */
d520 1
a520 1
	 "R_luimm16",		/* name.  */
d526 1
a526 1
  HOWTO (R_huimm16,		/* type.  */
d534 1
a534 1
	 "R_huimm16",		/* name.  */
d540 1
a540 1
  HOWTO (R_pcrel12_jump_s,	/* type.  */
d548 1
a548 1
	 "R_pcrel12_jump_s",	/* name.  */
d554 1
a554 1
  HOWTO (R_pcrel24_jump_x,	/* type.  */
d562 1
a562 1
         "R_pcrel24_jump_x",	/* name.  */
d568 1
a568 1
  HOWTO (R_pcrel24,		/* type.  */
d576 1
a576 1
	 "R_pcrel24",		/* name.  */
d582 1
a582 1
  HOWTO (R_unusedb,		/* type.  */
d590 1
a590 1
	 "R_unusedb",		/* name.  */
d596 1
a596 1
  HOWTO (R_unusedc,		/* type.  */
d604 1
a604 1
	 "R_unusedc",		/* name.  */
d610 1
a610 1
  HOWTO (R_pcrel24_jump_l,	/* type.  */
d618 1
a618 1
	 "R_pcrel24_jump_l",	/* name.  */
d624 1
a624 1
  HOWTO (R_pcrel24_call_x,	/* type.  */
d632 1
a632 1
	 "R_pcrel24_call_x",	/* name.  */
d638 1
a638 1
  HOWTO (R_var_eq_symb,		/* type.  */
d646 1
a646 1
	 "R_var_eq_symb",		/* name.  */
d652 1
a652 1
  HOWTO (R_byte_data,		/* type.  */
d660 1
a660 1
	 "R_byte_data",		/* name.  */
d666 1
a666 1
  HOWTO (R_byte2_data,		/* type.  */
d674 1
a674 1
	 "R_byte2_data",	/* name.  */
d680 1
a680 1
  HOWTO (R_byte4_data,		/* type.  */
d688 1
a688 1
	 "R_byte4_data",	/* name.  */
d694 1
a694 1
  HOWTO (R_pcrel11,		/* type.  */
d702 1
a702 1
	 "R_pcrel11",		/* name.  */
d934 1
a934 1
  HOWTO (R_pltpc,		/* type.  */
d942 1
a942 1
	 "R_pltpc",		/* name.  */
d948 1
a948 1
  HOWTO (R_got,			/* type.  */
d956 1
a956 1
	 "R_got",		/* name.  */
d1001 21
a1021 21
  { BFD_RELOC_NONE,			R_unused0 },
  { BFD_RELOC_BFIN_5_PCREL,		R_pcrel5m2 },
  { BFD_RELOC_NONE,			R_unused1 },
  { BFD_RELOC_BFIN_10_PCREL,		R_pcrel10 },
  { BFD_RELOC_BFIN_12_PCREL_JUMP,	R_pcrel12_jump },
  { BFD_RELOC_BFIN_16_IMM,		R_rimm16 },
  { BFD_RELOC_BFIN_16_LOW,		R_luimm16 },
  { BFD_RELOC_BFIN_16_HIGH,		R_huimm16 },
  { BFD_RELOC_BFIN_12_PCREL_JUMP_S,	R_pcrel12_jump_s },
  { BFD_RELOC_24_PCREL,			R_pcrel24 },
  { BFD_RELOC_24_PCREL,			R_pcrel24 },
  { BFD_RELOC_BFIN_24_PCREL_JUMP_L,	R_pcrel24_jump_l },
  { BFD_RELOC_NONE,			R_unusedb },
  { BFD_RELOC_NONE,			R_unusedc },
  { BFD_RELOC_BFIN_24_PCREL_CALL_X,	R_pcrel24_call_x },
  { BFD_RELOC_8,			R_byte_data },
  { BFD_RELOC_16,			R_byte2_data },
  { BFD_RELOC_32,			R_byte4_data },
  { BFD_RELOC_BFIN_11_PCREL,		R_pcrel11 },
  { BFD_RELOC_BFIN_GOT,			R_got },
  { BFD_RELOC_BFIN_PLTPC,		R_pltpc },
d1194 1
a1194 1
	case R_got:
d1304 1
a1304 1
  if (r_type == R_pcrel24 || r_type == R_pcrel24_jump_l)
d1453 1
a1453 1
	case R_got:
d1546 1
a1546 1
			  ELF32_R_INFO (0, R_pcrel24);
d1678 1
a1678 1
	case R_got:
d1896 1
a1896 1
  /* The number of R_byte4_data, R_BFIN_FUNCDESC and R_BFIN_FUNCDESC_VALUE
d2212 1
a2212 1
				 R_byte4_data, idx, ad, entry);
d2264 1
a2264 1
	      reloc = R_byte4_data;
d2668 3
a2670 3
	case R_pcrel24:
	case R_pcrel24_jump_l:
	case R_byte4_data:
d2730 2
a2731 2
	case R_pcrel24:
	case R_pcrel24_jump_l:
d2829 1
a2829 1
		    r_type = R_byte4_data;
d2896 1
a2896 1
						R_unused0,
d2919 1
a2919 1
	case R_byte4_data:
d3040 1
a3040 1
						0, R_unused0, dynindx, addend, picrel);
d3156 2
a3157 2
	case R_pcrel24:
	case R_pcrel24_jump_l:
d3287 2
a3288 2
	case R_pcrel24:
	case R_pcrel24_jump_l:
d3298 1
a3298 1
	case R_byte4_data:
d4656 3
a4658 3
	case R_pcrel24:
	case R_pcrel24_jump_l:
	case R_byte4_data:
d4702 2
a4703 2
	case R_pcrel24:
	case R_pcrel24_jump_l:
d4714 1
a4714 1
	case R_byte4_data:
d4777 4
a4780 4
	case R_huimm16:
	case R_luimm16:
	case R_pcrel12_jump_s:
	case R_pcrel10:
d5097 1
a5097 1
	  rela.r_info = ELF32_R_INFO (0, R_pcrel24);
d5108 1
a5108 1
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_got);
d5503 1
a5503 1
      if (ELF32_R_TYPE (irel->r_info) != (int) R_byte4_data)
@


1.37
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d26 1
a26 1
#include "elf/dwarf2.h"
@


1.36
log
@Remove unnecessary ATTRIBUTE_UNUSED
@
text
@d4969 2
a4970 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d5016 1
a5016 1
  ret->sym_sec.abfd = NULL;
@


1.35
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d1126 1
a1126 1
     bfd *abfd ATTRIBUTE_UNUSED,
d3354 2
a3355 3
				    struct bfd_link_info *info
				    ATTRIBUTE_UNUSED,
				    asection *p ATTRIBUTE_UNUSED)
d4417 2
a4418 2
(struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
@


1.34
log
@	* elf32-bfin.c (bfin_check_relocs, bfin_relocate_section,
	bfin_final_link_relocate, bfin_gc_mark_hook, bfin_gc_sweep_hook,
	ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE,
	struct _bfinfdpic_dynamic_got_info): Moved around to keep FD-PIC code
	separate from non-FD-PIC.
@
text
@a1152 1
  asection *sreloc;
a1162 1
  sreloc = NULL;
a1363 1
  asection *sreloc;
a1373 1
  sreloc = NULL;
@


1.33
log
@	bfd/
	* elf32-bfin.c (elf32_bfin_special_sections[]): New.
	(elf_backend_special_sections): Define.

	ld/
	* emulparams/elf32bfinfd.sh (OTHER_SECTIONS): Define.
@
text
@d1134 61
d1196 5
a1200 2
extern const bfd_target bfd_elf32_bfinfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_bfinfdpic_vec)
d1202 7
a1208 5
/* An extension of the elf hash table data structure, containing some
   additional Blackfin-specific data.  */
struct bfinfdpic_elf_link_hash_table
{
  struct elf_link_hash_table elf;
d1210 5
a1214 19
  /* A pointer to the .got section.  */
  asection *sgot;
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
};
d1216 15
a1230 1
/* Get the Blackfin ELF linker hash table from a link_info structure.  */
d1232 10
a1241 2
#define bfinfdpic_hash_table(info) \
  ((struct bfinfdpic_elf_link_hash_table *) ((info)->hash))
d1243 13
a1255 16
#define bfinfdpic_got_section(info) \
  (bfinfdpic_hash_table (info)->sgot)
#define bfinfdpic_gotrel_section(info) \
  (bfinfdpic_hash_table (info)->sgotrel)
#define bfinfdpic_gotfixup_section(info) \
  (bfinfdpic_hash_table (info)->sgotfixup)
#define bfinfdpic_plt_section(info) \
  (bfinfdpic_hash_table (info)->splt)
#define bfinfdpic_pltrel_section(info) \
  (bfinfdpic_hash_table (info)->spltrel)
#define bfinfdpic_relocs_info(info) \
  (bfinfdpic_hash_table (info)->relocs_info)
#define bfinfdpic_got_initial_offset(info) \
  (bfinfdpic_hash_table (info)->got0)
#define bfinfdpic_plt_initial_offset(info) \
  (bfinfdpic_hash_table (info)->plt0)
d1257 22
a1278 1
/* Create a Blackfin ELF linker hash table.  */
d1280 4
a1283 5
static struct bfd_link_hash_table *
bfinfdpic_elf_link_hash_table_create (bfd *abfd)
{
  struct bfinfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct bfinfdpic_elf_link_hash_table);
d1285 2
a1286 3
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
    return NULL;
d1288 4
a1291 3
  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry)))
d1293 2
a1294 2
      free (ret);
      return NULL;
d1296 9
d1306 4
a1309 2
  return &ret->elf.root;
}
d1311 2
a1312 8
/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define BFINFDPIC_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define BFINFDPIC_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)
d1314 1
a1314 20
/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct bfinfdpic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;
d1316 10
a1325 44
  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 2 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 17M4 suffix indicates a
     GOT17M4 relocation; hilo is used for GOTLO/GOTHI pairs.  */
  unsigned got17m4;
  unsigned gothilo;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot17m4;
  unsigned fdgothilo;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff17m4;
  unsigned fdgoffhilo;
  /* Whether symbol+addend is referenced with GOTOFF17M4, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff17m4 || fdgotofflohi
      || ((fd || fdgot17m4 || fdgothilo)
          && (symndx != -1 || BFINFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;
d1327 2
a1328 3
  /* The number of R_byte4_data, R_BFIN_FUNCDESC and R_BFIN_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;
d1330 3
a1332 3
  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;
d1334 1
a1334 11
  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
};
d1336 3
a1338 5
/* Compute a hash with the key fields of an bfinfdpic_relocs_info entry.  */
static hashval_t
bfinfdpic_relocs_info_hash (const void *entry_)
{
  const struct bfinfdpic_relocs_info *entry = entry_;
d1340 5
a1344 4
  return (entry->symndx == -1
	  ? (long) entry->d.h->root.root.hash
	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
}
d1346 2
a1347 7
/* Test whether the key fields of two bfinfdpic_relocs_info entries are
   identical.  */
static int
bfinfdpic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct bfinfdpic_relocs_info *e1 = entry1;
  const struct bfinfdpic_relocs_info *e2 = entry2;
a1348 2
  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
d1351 9
a1359 8
/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct bfinfdpic_relocs_info *entry,
			   enum insert_option insert)
d1361 9
a1369 2
  struct bfinfdpic_relocs_info **loc =
    (struct bfinfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
d1371 4
a1374 2
  if (! loc)
    return NULL;
d1376 2
a1377 2
  if (*loc)
    return *loc;
d1379 14
a1392 1
  *loc = bfd_zalloc (abfd, sizeof (**loc));
d1394 6
a1399 2
  if (! *loc)
    return *loc;
d1401 3
a1403 5
  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;
d1405 7
a1411 2
  return *loc;
}
d1413 4
a1416 11
/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_global (struct htab *ht,
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
{
  struct bfinfdpic_relocs_info entry;
d1418 9
a1426 3
  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;
d1428 5
a1432 2
  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}
d1434 10
a1443 11
/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
{
  struct bfinfdpic_relocs_info entry;
d1445 2
a1446 3
  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;
d1448 1
a1448 2
  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}
d1450 6
a1455 2
/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */
d1457 20
a1476 15
inline static void
bfinfdpic_pic_merge_early_relocs_info (struct bfinfdpic_relocs_info *e2,
				      struct bfinfdpic_relocs_info const *e1)
{
  e2->got17m4 |= e1->got17m4;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot17m4 |= e1->fdgot17m4;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff17m4 |= e1->fdgoff17m4;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;
}
d1478 5
a1482 4
/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */
d1484 3
a1486 3
#define LZPLT_RESOLVER_EXTRA 10
#define LZPLT_NORMAL_SIZE 6
#define LZPLT_ENTRIES 1362
d1488 3
a1490 2
#define BFINFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) LZPLT_NORMAL_SIZE * LZPLT_ENTRIES + LZPLT_RESOLVER_EXTRA)
#define BFINFDPIC_LZPLT_RESOLV_LOC (LZPLT_NORMAL_SIZE * LZPLT_ENTRIES / 2)
d1492 15
a1506 1
/* Add a dynamic relocation to the SRELOC section.  */
d1508 20
a1527 7
inline static bfd_vma
_bfinfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct bfinfdpic_relocs_info *entry)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;
d1529 8
a1536 3
  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;
d1538 5
a1542 5
  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;
d1544 2
a1545 12
  /* If the entry's index is zero, this relocation was probably to a
     linkonce section that got discarded.  We reserved a dynamic
     relocation, but it was for another entry than the one we got at
     the time of emitting the relocation.  Unfortunately there's no
     simple way for us to catch this situation, since the relocation
     is cleared right before calling relocate_section, at which point
     we no longer know what the relocation used to point to.  */
  if (entry->symndx)
    {
      BFD_ASSERT (entry->dynrelocs > 0);
      entry->dynrelocs--;
    }
d1547 10
a1556 2
  return reloc_offset;
}
d1558 3
a1560 1
/* Add a fixup to the ROFIXUP section.  */
d1562 6
a1567 5
static bfd_vma
_bfinfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		       struct bfinfdpic_relocs_info *entry)
{
  bfd_vma fixup_offset;
d1569 5
a1573 2
  if (rofixup->flags & SEC_EXCLUDE)
    return -1;
d1575 2
a1576 7
  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;
d1578 12
a1589 7
  if (entry && entry->symndx)
    {
      /* See discussion about symndx == 0 in _bfinfdpic_add_dyn_reloc
	 above.  */
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }
d1591 3
a1593 2
  return fixup_offset;
}
d1595 12
a1606 2
/* Find the segment number in which OSEC, and output section, is
   located.  */
d1608 17
a1624 4
static unsigned
_bfinfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
{
  Elf_Internal_Phdr *p = _bfd_elf_find_segment_containing_section (output_bfd, osec);
d1626 1
a1626 1
  return (p != NULL) ? p - elf_tdata (output_bfd)->phdr : -1;
d1629 6
a1634 2
inline static bfd_boolean
_bfinfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
d1636 7
a1642 1
  unsigned seg = _bfinfdpic_osec_to_segment (output_bfd, osec);
d1644 1
a1644 1
  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
d1647 1
a1647 10
/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_bfinfdpic_emit_got_relocs_plt_entries (struct bfinfdpic_relocs_info *entry,
					bfd *output_bfd,
					struct bfd_link_info *info,
					asection *sec,
					Elf_Internal_Sym *sym,
					bfd_vma addend)
d1649 5
d1655 7
a1661 2
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
  int dynindx = -1;
d1663 2
a1664 1
  if (entry->done)
a1665 1
  entry->done = 1;
d1667 3
a1669 16
  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
	{
	  if (sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
	}
    }
d1671 2
a1672 5
  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
d1674 2
a1675 56
      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}

      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1
	      || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    _bfinfdpic_add_rofixup (output_bfd,
				   bfinfdpic_gotfixup_section (info),
				   bfinfdpic_got_section (info)->output_section
				   ->vma
				   + bfinfdpic_got_section (info)->output_offset
				   + bfinfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
	}
      else
	_bfinfdpic_add_dyn_reloc (output_bfd, bfinfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  bfinfdpic_got_section (info),
				  bfinfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + bfinfdpic_got_section (info)
				 ->output_section->vma
				 + bfinfdpic_got_section (info)->output_offset,
				 R_byte4_data, idx, ad, entry);

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
d1677 2
a1678 2
      int reloc, idx;
      bfd_vma ad = 0;
d1680 1
a1680 3
      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
d1682 3
a1684 11
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1
	      && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && BFINFDPIC_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
d1686 11
a1696 5
	      reloc = R_BFIN_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
d1698 1
a1698 2
	  else if (entry->symndx == -1
		   && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
d1700 11
a1710 5
	      reloc = R_BFIN_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		return FALSE;
d1712 3
a1714 46
	  else
	    {
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_byte4_data;
	      idx = elf_section_data (bfinfdpic_got_section (info)
				      ->output_section)->dynindx;
	      ad = bfinfdpic_got_section (info)->output_offset
		+ bfinfdpic_got_initial_offset (info) + entry->fd_entry;
	    }

	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
	      ad += bfinfdpic_got_section (info)->output_section->vma;
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
	    }
	  else
	    _bfinfdpic_add_dyn_reloc (output_bfd,
				     bfinfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      bfinfdpic_got_section (info),
				      bfinfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
a1715 5

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fdgot_entry);
d1717 5
d1723 5
a1727 8
  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;
d1729 19
a1747 15
      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}
d1749 1
a1749 48
      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
	    }
	}
      else
	{
	  ofst
	    = _bfinfdpic_add_dyn_reloc (output_bfd,
					entry->lazyplt
					? bfinfdpic_pltrel_section (info)
					: bfinfdpic_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 bfinfdpic_got_section (info),
					 bfinfdpic_got_initial_offset (info)
					 + entry->fd_entry)
					+ bfinfdpic_got_section (info)
					->output_section->vma
					+ bfinfdpic_got_section (info)
					->output_offset,
					R_BFIN_FUNCDESC_VALUE, idx, ad, entry);
	}
d1751 2
a1752 13
      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = bfinfdpic_got_section (info)->output_section->vma
	    + bfinfdpic_got_section (info)->output_offset
	    + bfinfdpic_got_initial_offset (info);
	}
      else if (entry->lazyplt)
	{
	  if (ad)
	    return FALSE;
d1754 16
a1769 1
	  fd_lazy_rel_offset = ofst;
d1771 2
a1772 25
	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + bfinfdpic_plt_section (info)->output_offset
	    + bfinfdpic_plt_section (info)->output_section->vma;
	  highword = _bfinfdpic_osec_to_segment
	    (output_bfd, bfinfdpic_plt_section (info)->output_section);
	}
      else
	{
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
	    highword = 0;
	  else
	    highword = _bfinfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
	}
d1774 1
a1774 9
      bfd_put_32 (output_bfd, lowword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }
d1776 1
a1776 5
  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = bfinfdpic_plt_section (info)->contents
	+ entry->plt_entry;
d1778 23
a1800 1
      BFD_ASSERT (entry->fd_entry);
d1802 1
a1802 34
      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (18 - 1))
	  && entry->fd_entry + 4 < (1 << (18 - 1)))
	{
	  /* P1 = [P3 + fd_entry]; P3 = [P3 + fd_entry + 4] */
	  bfd_put_32 (output_bfd,
		      0xe519 | ((entry->fd_entry << 14) & 0xFFFF0000),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe51b | (((entry->fd_entry + 4) << 14) & 0xFFFF0000),
		      plt_code + 4);
	  plt_code += 8;
	}
      else
	{
	  /* P1.L = fd_entry; P1.H = fd_entry;
	     P3 = P3 + P1;
	     P1 = [P3];
	     P3 = [P3 + 4];  */
	  bfd_put_32 (output_bfd,
		      0xe109 | (entry->fd_entry << 16),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe149 | (entry->fd_entry & 0xFFFF0000),
		      plt_code + 4);
	  bfd_put_16 (output_bfd, 0x5ad9, plt_code + 8);
	  bfd_put_16 (output_bfd, 0x9159, plt_code + 10);
	  bfd_put_16 (output_bfd, 0xac5b, plt_code + 12);
	  plt_code += 14;
	}
      /* JUMP (P1) */
      bfd_put_16 (output_bfd, 0x0051, plt_code);
    }
d1804 5
a1808 6
  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = bfinfdpic_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;
d1810 3
a1812 2
      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;
d1814 6
a1819 25
      resolverStub_addr = entry->lzplt_entry / BFINFDPIC_LZPLT_BLOCK_SIZE
	* BFINFDPIC_LZPLT_BLOCK_SIZE + BFINFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= bfinfdpic_plt_initial_offset (info))
	resolverStub_addr = bfinfdpic_plt_initial_offset (info) - LZPLT_NORMAL_SIZE - LZPLT_RESOLVER_EXTRA;

      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.
	     P2 = [P3];
	     R3 = [P3 + 4];
	     JUMP (P2);  */
	  bfd_put_32 (output_bfd,
		      0xa05b915a,
		      lzplt_code);
	  bfd_put_16 (output_bfd, 0x0052, lzplt_code + 4);
	}
      else
	{
	  /* JUMP.S  resolverStub */
	  bfd_put_16 (output_bfd,
		      0x2000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 2) & (((bfd_vma)1 << 12) - 1)),
		      lzplt_code);
	}
d1822 1
a1822 1
  return TRUE;
d1825 8
d1834 4
a1837 9
/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
bfin_check_relocs (bfd * abfd,
		   struct bfd_link_info *info,
		   asection *sec,
                   const Elf_Internal_Rela *relocs)
d1839 15
a1853 11
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;
  if (info->relocatable)
    return TRUE;
d1855 44
a1898 4
  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
d1900 3
a1902 3
  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;
d1904 3
a1906 5
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
d1908 11
a1918 5
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1920 5
a1924 8
      switch (ELF32_R_TYPE (rel->r_info))
	{
       /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_BFIN_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
d1926 4
a1929 8
        /* This relocation describes which C++ vtable entries
           are actually used.  Record for later use during GC.  */
        case R_BFIN_GNU_VTENTRY:
          BFD_ASSERT (h != NULL);
          if (h != NULL
              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
d1931 7
a1937 5
	case R_got:
	  if (h != NULL
	      && strcmp (h->root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */
d1939 3
a1941 7
	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }
d1943 11
a1953 5
	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }
d1955 2
a1956 15
	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY);
		  srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
							 flags);
		  if (srelgot == NULL
		      || !bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }
d1958 2
a1959 10
	  if (h != NULL)
	    {
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1 && !h->forced_local)
		    {
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
			return FALSE;
		    }
d1961 1
a1961 13
		  /* Allocate space in the .got section.  */
		  sgot->size += 4;
		  /* Allocate relocation space.  */
		  srelgot->size += sizeof (Elf32_External_Rela);
		}
	      h->got.refcount++;
	    }
	  else
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;
d1963 2
a1964 22
		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->size += 4;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
		         output a R_68K_RELATIVE reloc so that the dynamic
		         linker can adjust this GOT entry.  */
		      srelgot->size += sizeof (Elf32_External_Rela);
		    }
		}
	      local_got_refcounts[r_symndx]++;
	    }
	  break;
d1966 5
a1970 4
	default:
	  break;
	}
    }
d1972 1
a1972 1
  return TRUE;
d1975 9
a1983 2
static enum elf_reloc_type_class
elf32_bfin_reloc_type_class (const Elf_Internal_Rela * rela)
d1985 7
a1991 5
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    default:
      return reloc_class_normal;
    }
d1993 10
a2002 6

static bfd_reloc_status_type
bfin_final_link_relocate (Elf_Internal_Rela *rel, reloc_howto_type *howto,
			  bfd *input_bfd, asection *input_section,
			  bfd_byte *contents, bfd_vma address,
			  bfd_vma value, bfd_vma addend)
d2004 8
a2011 1
  int r_type = ELF32_R_TYPE (rel->r_info);
d2013 2
a2014 4
  if (r_type == R_pcrel24 || r_type == R_pcrel24_jump_l)
    {
      bfd_reloc_status_type r = bfd_reloc_ok;
      bfd_vma x;
d2016 15
a2030 2
      if (address > bfd_get_section_limit (input_bfd, input_section))
	return bfd_reloc_outofrange;
d2032 4
a2035 1
      value += addend;
d2037 3
a2039 3
      /* Perform usual pc-relative correction.  */
      value -= input_section->output_section->vma + input_section->output_offset;
      value -= address;
d2041 2
a2042 6
      /* We are getting reloc_entry->address 2 byte off from
	 the start of instruction. Assuming absolute postion
	 of the reloc data. But, following code had been written assuming
	 reloc address is starting at begining of instruction.
	 To compensate that I have increased the value of
	 relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
d2044 1
a2044 2
      value += 2;
      address -= 2;
d2046 7
a2052 3
      if ((value & 0xFF000000) != 0
	  && (value & 0xFF000000) != 0xFF000000)
	r = bfd_reloc_overflow;
d2054 3
a2056 1
      value >>= 1;
d2058 5
a2062 3
      x = bfd_get_16 (input_bfd, contents + address);
      x = (x & 0xff00) | ((value >> 16) & 0xff);
      bfd_put_16 (input_bfd, x, contents + address);
d2064 11
a2074 4
      x = bfd_get_16 (input_bfd, contents + address + 2);
      x = value & 0xFFFF;
      bfd_put_16 (input_bfd, x, contents + address + 2);
      return r;
d2077 1
a2077 3
  return _bfd_final_link_relocate (howto, input_bfd, input_section, contents,
				   rel->r_offset, value, addend);

d2080 1
a2080 2

/* Relocate an Blackfin ELF section.
d2082 5
a2086 2
   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.
d2088 2
a2089 3
   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.
d2091 7
a2097 3
   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.
d2099 7
a2105 2
   This function does not have to worry about setting the reloc
   address or the reloc symbol index.
d2107 2
a2108 1
   LOCAL_SYMS is a pointer to the swapped in local symbols.
d2110 2
a2111 2
   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.
d2113 4
a2116 2
   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).
d2118 2
a2119 5
   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */
d2121 2
a2122 9
static bfd_boolean
bfinfdpic_relocate_section (bfd * output_bfd,
			    struct bfd_link_info *info,
			    bfd * input_bfd,
			    asection * input_section,
			    bfd_byte * contents,
			    Elf_Internal_Rela * relocs,
			    Elf_Internal_Sym * local_syms,
			    asection ** local_sections)
d2124 1
a2124 7
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  unsigned isec_segment, got_segment, plt_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);
d2126 2
a2127 3
  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;
d2129 2
a2130 14
  isec_segment = _bfinfdpic_osec_to_segment (output_bfd,
					     input_section->output_section);
  if (IS_FDPIC (output_bfd) && bfinfdpic_got_section (info))
    got_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_got_section (info)
					      ->output_section);
  else
    got_segment = -1;
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_plt_section (info)
					      ->output_section);
  else
    plt_segment = -1;
d2132 7
a2138 14
  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char * name = NULL;
      int r_type;
      asection *osec;
      struct bfinfdpic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;
d2140 3
a2142 1
      r_type = ELF32_R_TYPE (rel->r_info);
d2144 3
a2146 3
      if (r_type == R_BFIN_GNU_VTINHERIT
	  || r_type == R_BFIN_GNU_VTENTRY)
	continue;
d2148 7
a2154 3
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
d2156 6
a2161 2
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
d2163 1
d2165 5
a2169 3
      h      = NULL;
      sym    = NULL;
      sec    = NULL;
d2171 4
a2174 1
      if (r_symndx < symtab_hdr->sh_info)
d2176 9
a2184 7
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
a2185 4
      else
	{
	  bfd_boolean warned;
	  bfd_boolean unresolved_reloc;
d2187 6
a2192 8
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  osec = sec;
	}

      if (sec != NULL && elf_discarded_section (sec))
d2194 11
a2204 7
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
d2206 11
d2218 5
a2222 2
      if (info->relocatable)
	continue;
d2224 6
a2229 8
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && !BFINFDPIC_SYM_LOCAL (info, h))
	{
	  osec = sec = NULL;
	  relocation = 0;
	}
d2231 3
a2233 1
      switch (r_type)
d2235 27
a2261 24
	case R_pcrel24:
	case R_pcrel24_jump_l:
	case R_byte4_data:
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	case R_BFIN_FUNCDESC:
	case R_BFIN_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info
						       (info), input_bfd, h,
						       orig_addend, INSERT);
a2262 12
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						      (info), input_bfd, r_symndx,
						      orig_addend, INSERT);
	  if (! picrel)
	    return FALSE;

	  if (!_bfinfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						       osec, sym,
						       rel->r_addend))
d2264 9
a2272 5
	      (*_bfd_error_handler)
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
	      return FALSE;

d2275 9
a2283 6
	  break;

	default:
	non_fdpic:
	  picrel = NULL;
	  if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
d2285 9
a2293 4
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
d2295 13
a2307 1
	  break;
d2310 36
a2345 1
      switch (r_type)
d2347 5
a2351 6
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  check_segment[0] = isec_segment;
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
d2353 16
a2368 4
	      relocation = bfinfdpic_plt_section (info)->output_section->vma
		+ bfinfdpic_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
d2370 19
a2388 12
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;
d2390 6
a2395 18
	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFLO:
	  relocation -= bfinfdpic_got_section (info)->output_section->vma
d2398 5
a2402 5
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
d2404 1
a2404 6
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
d2406 25
a2430 4
	case R_BFIN_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;
d2432 9
a2440 43
	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h)
		    && BFINFDPIC_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
		  {
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->warning
			  (info, _("R_BFIN_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_byte4_data;
		    dynindx = elf_section_data (bfinfdpic_got_section (info)
						->output_section)->dynindx;
		    addend = bfinfdpic_got_section (info)->output_offset
		      + bfinfdpic_got_initial_offset (info)
		      + picrel->fd_entry;
		  }
d2442 5
a2446 41
		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_FUNCDESC_LOCAL (info, h)))
		  {
		    addend += bfinfdpic_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			if (_bfinfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
			  {
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }
			_bfinfdpic_add_rofixup (output_bfd,
					       bfinfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    bfd_vma offset;
d2448 106
a2553 31
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    offset = _bfd_elf_section_offset (output_bfd, info,
						      input_section, rel->r_offset);
		    /* Only output a reloc for a not deleted entry.  */
		    if (offset >= (bfd_vma) -2)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						0,
						R_unused0,
						dynindx, addend, picrel);
		    else
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						offset + input_section
						->output_section->vma
						+ input_section->output_offset,
						r_type,
						dynindx, addend, picrel);
		  }
		else
		  addend += bfinfdpic_got_section (info)->output_section->vma;
	      }
d2555 17
a2571 7
	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
d2573 3
a2575 14
	case R_byte4_data:
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
	case R_BFIN_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;
	    bfd_vma offset;
	    offset = _bfd_elf_section_offset (output_bfd, info,
					      input_section, rel->r_offset);
d2577 14
a2590 28
	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_BFIN_FUNCDESC_VALUE)
		  {
		    info->callbacks->warning
		      (info, _("R_BFIN_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }
d2592 14
a2605 39
	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if (IS_FDPIC (input_bfd)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			/* Only output a reloc for a not deleted entry.  */
			if (offset >= (bfd_vma)-2)
			  _bfinfdpic_add_rofixup (output_bfd,
						  bfinfdpic_gotfixup_section
						  (info), -1, picrel);
			else
			  _bfinfdpic_add_rofixup (output_bfd,
						  bfinfdpic_gotfixup_section
						  (info),
						  offset + input_section
						  ->output_section->vma
						  + input_section->output_offset,
						  picrel);
d2607 1
a2607 54
			if (r_type == R_BFIN_FUNCDESC_VALUE)
			  {
			    if (offset >= (bfd_vma)-2)
			      _bfinfdpic_add_rofixup
				(output_bfd,
				 bfinfdpic_gotfixup_section (info),
				 -1, picrel);
			    else
			      _bfinfdpic_add_rofixup
				(output_bfd,
				 bfinfdpic_gotfixup_section (info),
				 offset + input_section->output_section->vma
				 + input_section->output_offset + 4, picrel);
			  }
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    /* Only output a reloc for a not deleted entry.  */
		    if (offset >= (bfd_vma)-2)
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						0, R_unused0, dynindx, addend, picrel);
		    else
		      _bfinfdpic_add_dyn_reloc (output_bfd,
						bfinfdpic_gotrel_section (info),
						offset
						+ input_section
						->output_section->vma
						+ input_section->output_offset,
						r_type, dynindx, addend, picrel);
		  }
		else if (osec)
		  addend += osec->output_section->vma;
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }
d2609 3
a2611 30
	    if (r_type == R_BFIN_FUNCDESC_VALUE && offset < (bfd_vma)-2)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      bfinfdpic_got_section (info)->output_section->vma
			      + bfinfdpic_got_section (info)->output_offset
			      + bfinfdpic_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! BFINFDPIC_SYM_LOCAL (info, h)
			      ? 0
			      : _bfinfdpic_osec_to_segment (output_bfd,
							    sec
							    ->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;
d2613 6
a2618 6
	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
d2621 15
a2635 1
      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
d2637 8
a2644 29
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
#endif
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_BFIN_PIC;
d2647 1
a2647 1
      switch (r_type)
d2649 8
a2656 10
	case R_BFIN_GOTOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_BFIN_GOTHI:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	  relocation >>= 16;
	  /* Fall through.  */
d2658 2
a2659 6
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation &= 0xffff;
	  break;
d2661 7
a2667 2
	default:
	  break;
d2674 3
a2676 3
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
	    break;
	  /* Fall through.  */
a2677 5
	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
d2684 3
d2690 15
a2704 7
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF17M4
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */
	case R_BFIN_GOTOFFHI:
	  relocation -= rel->r_addend;
	  break;
d2706 8
a2713 3
	default:
	  break;
	}
d2715 1
a2715 3
      r = bfin_final_link_relocate (rel, howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
d2717 1
a2717 3
      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;
d2719 4
a2722 1
	  switch (r)
d2724 4
a2727 26
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
d2729 1
a2729 61

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

static bfd_boolean
bfin_relocate_section (bfd * output_bfd,
		       struct bfd_link_info *info,
		       bfd * input_bfd,
		       asection * input_section,
		       bfd_byte * contents,
		       Elf_Internal_Rela * relocs,
		       Elf_Internal_Sym * local_syms,
		       asection ** local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  int i = 0;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++, i++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation = 0;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      bfd_vma address;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= 243)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
d2732 1
a2732 6
      if (r_type == R_BFIN_GNU_VTENTRY
          || r_type == R_BFIN_GNU_VTINHERIT)
	continue;

      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
d2734 24
a2757 4
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      r_symndx = ELF32_R_SYM (rel->r_info);
d2759 6
a2764 4
      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
d2766 6
a2771 9
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;
d2773 11
a2783 5
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}
d2785 6
a2790 10
      if (sec != NULL && elf_discarded_section (sec))
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
d2792 4
a2795 2
      if (info->relocatable)
	continue;
d2797 43
a2839 1
      address = rel->r_offset;
d2841 41
a2881 6
      /* Then, process normally.  */
      switch (r_type)
	{
	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  return bfd_reloc_ok;
d2883 31
a2913 9
	case R_got:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */
	  if (h != NULL
	      && strcmp (h->root.root.string, "__GLOBAL_OFFSET_TABLE_") == 0)
	    goto do_default;
	  /* Fall through.  */
	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */
d2915 7
a2921 2
	  {
	    bfd_vma off;
d2923 2
a2924 1
	  if (dynobj == NULL)
d2926 11
a2936 5
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = output_bfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }
d2938 14
a2951 1
	    if (sgot == NULL)
d2953 12
a2964 2
		sgot = bfd_get_section_by_name (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
d2967 6
a2972 1
	    if (h != NULL)
d2974 6
a2979 12
		bfd_boolean dyn;

		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) - 1);
		dyn = elf_hash_table (info)->dynamic_sections_created;

		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& (info->symbolic
			    || h->dynindx == -1
			    || h->forced_local)
			&& h->def_regular))
d2981 25
a3005 8
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally, or the symbol was forced to be local
		       because of a version file..  We must initialize
		       this entry in the global offset table.  Since
		       the offset must always be a multiple of 4, we
		       use the least significant bit to record whether
		       we have initialized it already.
d3007 14
a3020 10
		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			bfd_put_32 (output_bfd, relocation,
				    sgot->contents + off);
			h->got.offset |= 1;
a3022 2
		else
		  unresolved_reloc = FALSE;
d3026 35
a3060 3
		BFD_ASSERT (local_got_offsets != NULL);
		off = local_got_offsets[r_symndx];
		BFD_ASSERT (off != (bfd_vma) - 1);
d3062 12
a3073 5
		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
d3075 71
a3145 2
		  {
		    bfd_put_32 (output_bfd, relocation, sgot->contents + off);
d3147 6
a3152 5
		    if (info->shared)
		      {
			asection *s;
			Elf_Internal_Rela outrel;
			bfd_byte *loc;
d3154 3
a3156 2
			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);
d3158 7
a3164 10
			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset + off);
			outrel.r_info =
			  ELF32_R_INFO (0, R_pcrel24);
			outrel.r_addend = relocation;
			loc = s->contents;
			loc +=
			  s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }
d3166 21
a3186 10
		    local_got_offsets[r_symndx] |= 1;
		  }
	      }

	    relocation = sgot->output_offset + off;
	    rel->r_addend = 0;
            /* bfin : preg = [preg + 17bitdiv4offset] relocation is div by 4.  */
            relocation /= 4;
	  }
	  goto do_default;
a3188 5
	do_default:
	  r = bfin_final_link_relocate (rel, howto, input_bfd, input_section,
					contents, address,
					relocation, rel->r_addend);

d3192 3
a3194 12
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
         because such sections are not SEC_ALLOC and thus ld.so will
         not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0 && h->def_dynamic))
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	     input_bfd,
	     input_section, (long) rel->r_offset, h->root.root.string);
	  return FALSE;
	}
d3198 1
a3198 1
	  const char *name;
d3200 1
a3200 3
	  if (h != NULL)
	    name = h->root.root.string;
	  else
d3202 26
a3227 7
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
d3230 6
a3235 15
	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, (h ? &h->root : NULL), name, howto->name,
		     (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
a3241 18
static asection *
bfin_gc_mark_hook (asection * sec,
		   struct bfd_link_info *info,
		   Elf_Internal_Rela * rel,
		   struct elf_link_hash_entry *h,
                   Elf_Internal_Sym * sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_BFIN_GNU_VTINHERIT:
      case R_BFIN_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

a3353 73
/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
bfin_gc_sweep_hook (bfd * abfd,
		    struct bfd_link_info *info,
		    asection * sec,
                    const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_got:
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      if (info->shared)
			srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  break;
	default:
	  break;
	}
    }
  return TRUE;
}

a3588 31
/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _bfinfdpic_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 18- or 32-bit
     ranges.  */
  bfd_vma got17m4, gothilo;
  /* Total size needed for function descriptor entries within the 18-
     or 32-bit ranges.  */
  bfd_vma fd17m4, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

@


1.32
log
@Revert my last change since it has not been approved.
@
text
@d5575 8
d5631 1
@


1.31
log
@	bfd/
	* elf.c (_bfd_elf_map_sections_to_segments): Don't put
	executable sections into the same segment with other
	read only sections if --sep-code.
	* elf32-bfin.c (elf32_bfin_code_in_l1): New variable.
	(elf32_bfin_data_in_l1): New variable.
	(elf32_bfin_final_write_processing): New.
	(elf32_bfin_special_sections[]): New.
	(elf_backend_final_write_processing): Define.
	(elf_backend_special_sections): Define.

	binutils/
	* readelf.c (get_machine_flags): Deal with Blackfin specific
	flags.

	include/
	* bfdlink.h (struct bfd_link_info): Add sep_code member
	variable.
	* elf/bfin.h (EF_BFIN_CODE_IN_L1): Define.
	(EF_BFIN_DATA_IN_L1): Define.

	ld/
	* Makefile.am (eelf32bfin.c): Depend on bfin.em.
	(eelf32bfinfd.c): Likewise.
	* Makefile.in: Regenerate.
	* gen-doc.texi: Set Blackfin.
	* ld.texinfo: Document --sep-code and Blackfin specific
	options.
	* ldmain.c (main): Initialize link_info.sep_code.
	* lexsup.c (enum option_values): Add OPTION_SEP_CODE.
	(ld_options[]): Add --sep-code.
	(parse_args): Deal with --sep-code.
	* emulparams/bfin.sh (EXTRA_EM_FILE): Define.
	* emulparams/elf32bfinfd.sh (OTHER_SECTIONS): Define.
	* emultempl/bfin.em: New file.
@
text
@a1121 16
/* Set by ld emulation if --code-in-l1.  */
bfd_boolean elf32_bfin_code_in_l1 = 0;

/* Set by ld emulation if --data-in-l1.  */
bfd_boolean elf32_bfin_data_in_l1 = 0;

static void
elf32_bfin_final_write_processing (bfd *abfd,
				   bfd_boolean linker ATTRIBUTE_UNUSED)
{
  if (elf32_bfin_code_in_l1)
    elf_elfheader (abfd)->e_flags |= EF_BFIN_CODE_IN_L1;
  if (elf32_bfin_data_in_l1)
    elf_elfheader (abfd)->e_flags |= EF_BFIN_DATA_IN_L1;
}

a5574 8

struct bfd_elf_special_section const elf32_bfin_special_sections[] =
{
  { ".l1.text",		8, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".l1.data",		8, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,		0,  0, 0,            0 }
};

a5620 2
#define elf_backend_final_write_processing \
					elf32_bfin_final_write_processing
a5622 1
#define elf_backend_special_sections	elf32_bfin_special_sections
@


1.30
log
@	* elf32-bfin.c (bfin_final_link_relocate): New function, wrapper around
	_bfd_final_link_relocate that also handles R_pcrel24 relocs.
	(bfinfdpic_relocate_section, bfin_relocate_section): Use it.
@
text
@d1122 16
d5591 8
d5645 2
d5649 1
@


1.29
log
@	From Jie Zhang <jie.zhang@@analog.com>
	* elf32-bfin.c (struct bfinfdpic_relocs_info): Make got17m4,
	gothilo, fd, fdgot17m4, fdgothilo, fdgoff17m4, fdgoffhilo,
	gotoff, call and sym not bitfields.
	(bfinfdpic_gc_sweep_hook): New function; update the relocation
	information for the relocations of the section being removed.
	(bfinfdpic_check_relocs): Accumulate the number of relocations
	which set got17m4, gothilo, fd, fdgot17m4, fdgothilo, fdgoff17m4,
	fdgoffhilo, gotoff, call and sym fields.
	(elf_backend_gc_sweep_hook): Redefine for FD-PIC.
@
text
@d2073 54
d2794 3
a2796 37
      if (r_type == R_pcrel24
	  || r_type == R_pcrel24_jump_l)
	{
	  bfd_vma x;
	  bfd_vma address = rel->r_offset;

	  relocation += rel->r_addend;

	  /* Perform usual pc-relative correction.  */
	  relocation -= input_section->output_section->vma + input_section->output_offset;
	  relocation -= address;

	  /* We are getting reloc_entry->address 2 byte off from
	     the start of instruction. Assuming absolute postion
	     of the reloc data. But, following code had been written assuming
	     reloc address is starting at begining of instruction.
	     To compensate that I have increased the value of
	     relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

	  relocation += 2;
	  address -= 2;

	  relocation >>= 1;

	  x = bfd_get_16 (input_bfd, contents + address);
	  x = (x & 0xff00) | ((relocation >> 16) & 0xff);
	  bfd_put_16 (input_bfd, x, contents + address);

	  x = bfd_get_16 (input_bfd, contents + address + 2);
	  x = relocation & 0xFFFF;
	  bfd_put_16 (input_bfd, x, contents + address + 2);
	  r = bfd_reloc_ok;
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);
a3061 34
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  {
	    bfd_vma x;

	    relocation += rel->r_addend;

	    /* Perform usual pc-relative correction.  */
	    relocation -= input_section->output_section->vma + input_section->output_offset;
	    relocation -= address;

	    /* We are getting reloc_entry->address 2 byte off from
	       the start of instruction. Assuming absolute postion
	       of the reloc data. But, following code had been written assuming
	       reloc address is starting at begining of instruction.
	       To compensate that I have increased the value of
	       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

	    relocation += 2;
	    address -= 2;

	    relocation >>= 1;

	    x = bfd_get_16 (input_bfd, contents + address);
	    x = (x & 0xff00) | ((relocation >> 16) & 0xff);
	    bfd_put_16 (input_bfd, x, contents + address);

	    x = bfd_get_16 (input_bfd, contents + address + 2);
	    x = relocation & 0xFFFF;
	    bfd_put_16 (input_bfd, x, contents + address + 2);
	    r = bfd_reloc_ok;
	  }
	  break;

d3064 1
a3064 1
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
@


1.28
log
@	* elf32-bfin.c (bfinfdpic_relocate_section): Take more care not to
	emit invalid relocs or rofixup entries for deleted .eh_frame entries.
@
text
@d1245 2
a1246 2
  unsigned got17m4:1;
  unsigned gothilo:1;
d1248 1
a1248 1
  unsigned fd:1;
d1250 2
a1251 2
  unsigned fdgot17m4:1;
  unsigned fdgothilo:1;
d1253 2
a1254 2
  unsigned fdgoff17m4:1;
  unsigned fdgoffhilo:1;
d1259 1
a1259 1
  unsigned gotoff:1;
d1261 1
a1261 1
  unsigned call:1;
d1264 1
a1264 1
  unsigned sym:1;
d3154 112
d4726 1
a4726 1
	    picrel->call = 1;
d4739 1
a4739 1
	  picrel->sym = 1;
d4745 1
a4745 1
	  picrel->got17m4 = 1;
d4750 1
a4750 1
	  picrel->gothilo = 1;
d4754 1
a4754 1
	  picrel->fdgot17m4 = 1;
d4759 1
a4759 1
	  picrel->fdgothilo = 1;
d4765 1
a4765 1
	  picrel->gotoff = 1;
d4769 1
a4769 1
	  picrel->fdgoff17m4 = 1;
d4774 1
a4774 1
	  picrel->fdgoffhilo = 1;
d4778 1
a4778 1
	  picrel->fd = 1;
d5654 1
@


1.27
log
@	* elf32-bfin.c (bfin_relocate_section): Set up dynobj before using it
	if necessary.
	(elf32_bfin_merge_private_bfd_data): Simplify, and ensure object type
	mismatches are detected.
@
text
@d2482 3
d2541 14
a2554 10
			_bfinfdpic_add_rofixup (output_bfd,
					       bfinfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
d2556 13
a2568 8
			  _bfinfdpic_add_rofixup
			    (output_bfd,
			     bfinfdpic_gotfixup_section (info),
			     _bfd_elf_section_offset
			     (output_bfd, info,
			      input_section, rel->r_offset)
			     + input_section->output_section->vma
			     + input_section->output_offset + 4, picrel);
d2588 13
a2600 9
		    _bfinfdpic_add_dyn_reloc (output_bfd,
					      bfinfdpic_gotrel_section (info),
					      _bfd_elf_section_offset
					      (output_bfd, info,
					       input_section, rel->r_offset)
					      + input_section
					      ->output_section->vma
					      + input_section->output_offset,
					      r_type, dynindx, addend, picrel);
d2610 1
a2610 1
	    if (r_type == R_BFIN_FUNCDESC_VALUE)
@


1.26
log
@* elf.c (_bfd_elf_find_segment_containing_section): New function:
  Scan the segment map looking for the segment containing a
  specified function.
* elf-bfd.h: Prototype the new function.
* elf-hppa.h (elf_hppa_osec_to_segment): Delete.
  (elf_hppa_record_segment_addrs): Use new function.
* elf32-bfin.c (_bfdfdpic_osec_to_segment): Use new function.
* elf32-frv.c (_frvfdpic_osec_to_segment): Use new function.
* elf32-hppa.c (hppa_record_segment_addr): Use new function.
* elfxx-ia64.c (elfNN_ia64_relocate_section): Use new function.
@
text
@d2927 8
d4806 1
a4806 2
  flagword old_flags, old_partial;
  flagword new_flags, new_partial;
d4824 1
a4824 1
      old_flags = new_flags;
d4827 1
a4827 28
  else if (new_flags == old_flags)		/* Compatible flags are ok.  */
    ;

  else						/* Possibly incompatible flags.  */
    {
      /* We don't have to do anything if the pic flags are the same, or the new
         module(s) were compiled with -mlibrary-pic.  */
      new_partial = (new_flags & EF_BFIN_PIC_FLAGS);
      old_partial = (old_flags & EF_BFIN_PIC_FLAGS);
      if (new_partial == old_partial)
	;

      /* If we have mixtures of -fpic and -fPIC, or in both bits.  */
      else if (new_partial != 0 && old_partial != 0)
	old_flags |= new_partial;

      /* One module was compiled for pic and the other was not, see if we have
         had any relocations that are not pic-safe.  */
      else
	old_flags |= new_partial;

    }

  /* Update the old flags now with changes made above.  */
  elf_elfheader (obfd)->e_flags = old_flags;

  if (((new_flags & EF_BFIN_FDPIC) == 0)
      != (! IS_FDPIC (ibfd)))
@


1.25
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d1500 1
a1500 18
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* Find the segment that contains the output_section.  */
  for (m = elf_tdata (output_bfd)->segment_map,
	 p = elf_tdata (output_bfd)->phdr;
       m != NULL;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == osec)
	  break;

      if (i >= 0)
	break;
    }
d1502 1
a1502 1
  return p - elf_tdata (output_bfd)->phdr;
@


1.24
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d4514 1
a4514 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a4524 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.23
log
@2007-09-04  Michael Snyder  <msnyder@@access-company.com>

	* elf32-bfin.c (howto_table): Cut and paste error?
	Name field of reloc is wrong.
@
text
@d1982 3
a1984 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d4676 3
a4678 1
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.22
log
@Switch sources over to use the GPL version 3
@
text
@d719 1
a719 1
	 "R_BFIN_GOT12",		/* name */
@


1.21
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d18 2
a19 2
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */
@


1.20
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d4728 4
@


1.19
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.18
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d1060 1
a1061 1
}
d1081 23
d1105 1
d1107 1
a1119 1

d5502 2
@


1.17
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 2005, 2006 Free Software Foundation, Inc.
a2111 3
  if (info->relocatable)
    return TRUE;

a2151 1
      /* This is a final link.  */
d2176 9
a2184 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d2186 10
a2195 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2197 2
a2198 1
	  name = h->root.root.string;
d2200 7
a2206 34
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && ! BFINFDPIC_SYM_LOCAL (info, h))
	    {
	      sec = NULL;
	      relocation = 0;
	    }
	  else
	    if (h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	      {
		sec = h->root.u.def.section;
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	      }
	    else if (h->root.type == bfd_link_hash_undefweak)
	      {
		relocation = 0;
	      }
	    else if (info->unresolved_syms_in_objects == RM_IGNORE
		     && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	      relocation = 0;
	    else
	      {
		if (! ((*info->callbacks->undefined_symbol)
		       (info, h->root.root.string, input_bfd,
			input_section, rel->r_offset,
			(info->unresolved_syms_in_objects == RM_GENERATE_ERROR
			 || ELF_ST_VISIBILITY (h->other)))))
		  return FALSE;
		relocation = 0;
	      }
	  osec = sec;
a2818 3
  if (info->relocatable)
    return TRUE;

d2875 1
a2875 1
	  h = NULL;
d2882 14
@


1.16
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3109 1
a3109 1
		   struct bfd_link_info *info ATTRIBUTE_UNUSED,
d3115 6
a3120 17
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{

	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d3122 1
a3122 21
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}


/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
bfinfdpic_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
a5535 1
#define elf_backend_gc_sweep_hook       bfinfdpic_gc_sweep_hook
@


1.15
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_modify_program_headers.
	* elfxx-target.h (elf_backend_modify_program_headers): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_modify_segment_map): Remove comment.
	(assign_file_positions_for_load_sections): Only call
	elf_modify_segment_map for objcopy/strip.
	(assign_file_positions_except_relocs): Call
	elf_backend_modify_program_headers.
	* elf32-frv.c (elf32_frvfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_frvfdpic_modify_segment_map): Delete.
	(elf32_frvfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_bfinfdpic_modify_segment_map): Delete.
	(elf32_bfinfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elfxx-ia64.c (elfNN_ia64_modify_program_headers): New function.
	Split out from..
	(elfNN_ia64_modify_segment_map): ..here.
	(elf_backend_modify_program_headers): Define.
@
text
@d5295 1
a5295 1
       if (strncmp (name, ".rela", 5) == 0)
d5319 1
a5319 1
      else if (strncmp (name, ".got", 4) != 0)
@


1.14
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@a4158 1
      asection *sec;
a4183 7

      /* Create a stack section, and set its alignment.  */
      sec = bfd_make_section (output_bfd, ".stack");

      if (sec == NULL
	  || ! bfd_set_section_alignment (output_bfd, sec, 3))
	return FALSE;
d4190 2
a4191 2
elf32_bfinfdpic_modify_segment_map (bfd *output_bfd,
				   struct bfd_link_info *info)
d4193 1
d4195 1
d4202 1
a4202 1
  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
a4207 1
      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
d4210 4
a4213 1
      if (sec)
a4214 3
	  /* Obtain the pointer to the __stacksize symbol.  */
	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				    FALSE, FALSE, FALSE);
d4217 1
a4217 1
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
d4219 1
d4221 6
a4226 6
	  /* Set the section size from the symbol value.  We
	     intentionally ignore the symbol section.  */
	  if (h->root.type == bfd_link_hash_defined)
	    sec->size = h->root.u.def.value;
	  else
	    sec->size = DEFAULT_STACK_SIZE;
d4228 1
a4228 9
	  /* Add the stack section to the PT_GNU_STACK segment,
	     such that its size and alignment requirements make it
	     to the segment.  */
	  if (m->count == 0)
	    {
	      m->sections[m->count] = sec;
	      m->count++;
	    }
	}
d5583 3
a5585 3
#undef elf_backend_modify_segment_map
#define elf_backend_modify_segment_map \
		elf32_bfinfdpic_modify_segment_map
@


1.13
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d4237 5
a4241 2
	  m->sections[m->count] = sec;
	  m->count++;
@


1.12
log
@	* elf32-bfin.c (bfinfdpic_relocate_section): Clear reloc for
	deteted entries in .eh_frame section.
@
text
@d1987 5
a1991 1
		  srelgot = bfd_make_section (dynobj, ".rela.got");
a1992 7
		      || !bfd_set_section_flags (dynobj, srelgot,
						 (SEC_ALLOC
						  | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
d3380 1
a3380 1
  s = bfd_make_section (abfd, ".plt");
a3381 1
      || ! bfd_set_section_flags (abfd, s, pltflags)
d3408 1
a3408 1
  s = bfd_make_section (abfd, ".rel.plt");
a3409 1
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d3433 3
a3435 3
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
d3451 4
a3454 3
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
a3455 1
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
@


1.11
log
@	* elf32-bfin.c (bfin_check_relocs): Use __GLOBAL_OFFSET_TABLE_
	instead of _GLOBAL_OFFSET_TABLE_.
	(bfin_relocate_section): Ditto.
	(_bfin_create_got_section): Ditto.
	(elf32_bfinfdpic_create_dynamic_sections): Use
	__PROCEDURE_LINKAGE_TABLE_ instead of _PROCEDURE_LINKAGE_TABLE_.
	(bfin_finish_dynamic_symbol): Use __DYNAMIC instead of _DYNAMIC.
@
text
@d2438 2
d2450 17
a2466 9
		    _bfinfdpic_add_dyn_reloc (output_bfd,
					      bfinfdpic_gotrel_section (info),
					      _bfd_elf_section_offset
					      (output_bfd, info,
					       input_section, rel->r_offset)
					      + input_section
					      ->output_section->vma
					      + input_section->output_offset,
					      r_type, dynindx, addend, picrel);
@


1.10
log
@
	* elf32-bfin.c (bfinfdpic_relocs_info_hash): Sprinkle casts to
	eliminate warnings.
@
text
@d1964 1
a1964 1
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d2906 1
a2906 1
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3294 1
a3294 1
      h = _bfd_elf_define_linkage_sym (abfd, info, s, "_GLOBAL_OFFSET_TABLE_");
d3389 1
a3389 1
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
d5038 1
a5038 1
fprintf(stderr, "*** check this relocation %s\n", __FUNCTION__);
d5064 1
a5064 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.9
log
@Fix -Werror problem in previous change.
@
text
@d1287 2
a1288 2
	  ? entry->d.h->root.root.hash
	  : entry->symndx + entry->d.abfd->id * 257) + entry->addend;
@


1.8
log
@	* elf32-bfin.c (_bfin_create_got_section): Don't generate a _gp
	symbol.
@
text
@a3255 1
  struct bfd_link_hash_entry *bh;
@


1.7
log
@	* config.bfd (bfin-*-*): Add bfd_elf32_bfinfdpic_vec.
	* configure.in: Likewise.
	* configure: Regenerate.
	* elf32-bfin.c: Include "elf/dwarf2.h" and "hashtab.h".
	(BFIN_RELOC_MAX): Now 0x21.
	(bfin_howto_table, bfin_reloc_map): Add FD-PIC relocs.
	(bfd_elf32_bfinfdpic_vec): Declare.
	(IS_FDPIC): New macro.
	(struct bfinfdpic_elf_link_hash_table): New struct.
	(bfinfdpic_hash_table, bfinfdpic_got_section,
	bfinfdpic_gotrel_section, bfinfdpic_gotfixup_section,
	bfinfdpic_plt_setion, bfinfdpic_pltrel_section,
	bfinfdpic_relocs_info, bfinfdpic_got_initial_offset,
	bfinfdpic_plt_initial_offset): Accessor macros for it.
	(BFINFDPIC_SYM_LOCAL, BFINFDPIC_FUNCDESC_LOCAL): New macros.
	(struct bfinfdpic_relocs_info): New struct.
	(LZPLT_RESOLVER_EXTRA, LZPLT_NORMAL_SIZE, LZPLT_ENTRIES,
	BFINFDPIC_LZPLT_BLOCK_SIZE, BFINFDPIC_LZPLT_RESOLV_LOC,
	DEFAULT_STACK_SIZE): New macros.
	(bfinfdpic_elf_link_hash_table_create, bfinfdpic_relocs_info_hash,
	bfinfdpic_relocs_info_eq, bfinfdpics_relocs_info_find,
	bfinfdpic_relocs_info_for_global, bfinfdpic_relocs_info_for_local,
	bfinfdpic_pic_merge_early_relocs_info, _bfinfdpic_add_dyn_reloc,
	_bfinfdpic_add_rofixup, _bfinfdpic_osec_to_segment,
	_bfinfdpic_osec_readonly_p, bfinfdpic_relocate_section,
	bfinfdpic_check_relocs, bfinfdpic_gc_sweep_hook,
	_bfinfdpic_link_omit_section_dynsym, _bfin_create_got_section,
	elf32_bfinfdpic_create_dynamic_sections, _bfinfdpic_get_fd_entry,
	_bfinfdpic_compute_got_alloc_data, _bfinfdpic_get_got_entry,
	_bfinfdpic_assign_got_entries, _bfinfdpic_assign_plt_entries,
	_bfinfdpic_resolve_final_relocs_info,
	elf32_bfinfdpic_size_dynamic_sections,
	elf32_bfinfdpic_always_size_sections,
	elf32_bfinfdpic_modify_segment_map,
	_bfinfdpic_count_got_plt_entries,
	elf32_bfinfdpic_finish_dynamic_sections,
	elf32_bfinfdpic_adjust_dynamic_symbol,
	elf32_bfinfdpic_finish_dynamic_symbol,
	elf32_bfinfdpic_elf_use_relative_eh_frame,
	elf32_bfinfdpic_elf_encode_eh_address,
	elf32_bfin_object_p, bfin_elf_copy_private_bfd_data,
	elf32_bfinfdpic_copy_private_bfd_data,
	(struct _bfinfdpic_dynamic_got_info,
	struct _bfinfdpic_dynamic_got_plt_info): New structs.
	(elf32_bfin_print_private_bfd_data): Print PIC flags.
	(elf32_bfin_merge_private_bfd_data): Extend to support FD-PIC.
	(TARGET_LITTLE_SYM, TARGET_LITTLE_NAME, elf32_bed,
	elf_backend_got_header_size, bfd_elf32_bfd_link_hash_table_create,
	elf_backend_always_size_sectinos, elf_backend_modify_segment_map,
	bfd_elf32_bfd_copy_private_bfd_data,
	elf_backend_create_dynamic_sections, elf_backend_adjust_dynamic_symbol,
	elf_backend_size_dynamic_sections, elf_backend_finish_dynamic_symbol,
	elf_backend_finish_dynamic_sections, elf_backend_relocate_section,
	elf_backend_can_make_relative_eh_frame, elf_backend_check_relocs,
	elf_backend_can_make_ldsa_relative_eh_frame, elf_backend_may_use_rel_p,
	elf_backend_may_use_rela_p, elf_backend_default_use_rela_p,
	elf_backend_omit_section_dynsym): Redefine these macros and include
	"elf32-target.h" again to create the elf32-bfinfdpic target.
	* reloc.c (BFD_RELOC_BFIN_GOT17M4, BFD_RELOC_BFIN_GOTHI,
	BFD_RELOC_BFIN_GOTLO, BFD_RELOC_BFIN_FUNCDESC,
	BFD_RELOC_BFIN_FUNCDESC_GOT17M4, BFD_RELOC_BFIN_FUNCDESC_GOTHI,
	BFD_RELOC_BFIN_FUNCDESC_GOTLO, BFD_RELOC_BFIN_FUNCDESC_VALUE,
	BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4, BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
	BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO, BFD_RELOC_BFIN_GOTOFFHI,
	BFD_RELOC_BFIN_GOTOFFLO): New.
	* targets.c (bfd_elf32_bfinfdpic_vec): New bfd_target.
	(_bfd_target_vector): Add it.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@a3345 17
  /* Define _gp in .rofixup, for FDPIC, or .got otherwise.  If it
     turns out that we're linking with a different linker script, the
     linker script will override it.  */
  bh = NULL;
  if (!(_bfd_generic_link_add_one_symbol
	(info, abfd, "_gp", flags, s, offset, (const char *) NULL, FALSE,
	 bed->collect, &bh)))
    return FALSE;
  h = (struct elf_link_hash_entry *) bh;
  h->def_regular = 1;
  h->type = STT_OBJECT;
  /* h->other = STV_HIDDEN; */ /* Should we?  */

  /* Machine-specific: we want the symbol for executables as well.  */
  if (IS_FDPIC (abfd) && ! bfd_elf_link_record_dynamic_symbol (info, h))
    return FALSE;

@


1.6
log
@	* elf32-bfin.c (bfd_const_reloc, bfd_oper_reloc, bfin_push_reloc,
	RELOC_STACK_SIZE, reloc_stack, reloc_stack_tos, is_reloc_stack_empty,
	reloc_stack_push, reloc_stack_pop, reloc_stack_operate,
	bfin_areloc_howto_table): Delete.  All
	uses deleted as well.
	(bfin_reloc_map): Delete all stack relocs.
	(bfin_info_to_howto, bfin_bfd_reloc_type_lookup,
	bfin_reloc_type_lookup): Don't support them.
	(bfin_relocate_section): Don't try to handle them.
@
text
@d26 2
d415 1
a415 1
#define BFIN_RELOC_MAX 0x13
d707 223
d1022 16
d1111 791
d2066 30
d2098 8
a2105 8
bfin_relocate_section (bfd * output_bfd,
		       struct bfd_link_info *info,
		       bfd * input_bfd,
		       asection * input_section,
		       bfd_byte * contents,
		       Elf_Internal_Rela * relocs,
		       Elf_Internal_Sym * local_syms,
		       asection ** local_sections)
a2106 1
  bfd *dynobj;
a2108 3
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *sreloc;
d2111 3
a2113 1
  int i = 0;
d2118 1
a2118 2
  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d2120 1
a2120 1
  local_got_offsets = elf_local_got_offsets (input_bfd);
d2122 14
a2135 2
  sgot = NULL;
  sreloc = NULL;
d2137 1
a2137 3
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++, i++)
a2138 1
      int r_type;
a2140 1
      struct elf_link_hash_entry *h;
d2143 2
a2144 2
      bfd_vma relocation = 0;
      bfd_boolean unresolved_reloc;
d2146 5
a2150 1
      bfd_vma address;
a2152 5
      if (r_type < 0 || r_type >= 243)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
d2154 2
a2155 2
      if (r_type == R_BFIN_GNU_VTENTRY
          || r_type == R_BFIN_GNU_VTINHERIT)
d2158 2
a2165 1
      r_symndx = ELF32_R_SYM (rel->r_info);
d2167 3
a2169 4
      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
d2174 1
a2174 1
	  sec = local_sections[r_symndx];
d2176 4
d2183 5
a2187 7
	  bfd_boolean warned;
	  h = NULL;
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}
d2189 99
a2287 1
      address = rel->r_offset;
a2288 1
      /* Then, process normally.  */
d2291 50
a2340 3
	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  return bfd_reloc_ok;
d2342 6
a2347 9
	case R_got:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    goto do_default;
	  /* Fall through.  */
	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */
d2349 1
d2351 2
a2352 1
	    bfd_vma off;
d2354 2
a2355 1
	    if (sgot == NULL)
d2357 103
a2459 2
		sgot = bfd_get_section_by_name (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
d2462 7
a2468 3
	    if (h != NULL)
	      {
		bfd_boolean dyn;
d2470 11
a2480 3
		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) - 1);
		dyn = elf_hash_table (info)->dynamic_sections_created;
d2482 5
a2486 6
		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& (info->symbolic
			    || h->dynindx == -1
			    || h->forced_local)
			&& h->def_regular))
d2488 22
a2509 8
		    /* This is actually a static link, or it is a
		       -Bsymbolic link and the symbol is defined
		       locally, or the symbol was forced to be local
		       because of a version file..  We must initialize
		       this entry in the global offset table.  Since
		       the offset must always be a multiple of 4, we
		       use the least significant bit to record whether
		       we have initialized it already.
d2511 25
a2535 6
		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
d2537 19
a2555 3
			bfd_put_32 (output_bfd, relocation,
				    sgot->contents + off);
			h->got.offset |= 1;
a2557 2
		else
		  unresolved_reloc = FALSE;
d2561 3
a2563 10
		BFD_ASSERT (local_got_offsets != NULL);
		off = local_got_offsets[r_symndx];
		BFD_ASSERT (off != (bfd_vma) - 1);

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
d2565 3
a2567 3
		    bfd_put_32 (output_bfd, relocation, sgot->contents + off);

		    if (info->shared)
d2569 5
a2573 16
			asection *s;
			Elf_Internal_Rela outrel;
			bfd_byte *loc;

			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);

			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset + off);
			outrel.r_info =
			  ELF32_R_INFO (0, R_pcrel24);
			outrel.r_addend = relocation;
			loc = s->contents;
			loc +=
			  s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d2575 9
a2583 2

		    local_got_offsets[r_symndx] |= 1;
d2585 6
d2593 27
a2619 4
	    relocation = sgot->output_offset + off;
	    rel->r_addend = 0;
            /* bfin : preg = [preg + 17bitdiv4offset] relocation is div by 4.  */
            relocation /= 4;
d2621 2
a2622 1
	  goto do_default;
d2624 7
a2630 4
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  {
	    bfd_vma x;
d2632 32
a2663 1
	    relocation += rel->r_addend;
d2665 12
a2676 3
	    /* Perform usual pc-relative correction.  */
	    relocation -= input_section->output_section->vma + input_section->output_offset;
	    relocation -= address;
d2678 6
a2683 6
	    /* We are getting reloc_entry->address 2 byte off from
	       the start of instruction. Assuming absolute postion
	       of the reloc data. But, following code had been written assuming
	       reloc address is starting at begining of instruction.
	       To compensate that I have increased the value of
	       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
d2685 3
a2687 2
	    relocation += 2;
	    address -= 2;
d2689 7
a2695 5
	    relocation >>= 1;

	    x = bfd_get_16 (input_bfd, contents + address);
	    x = (x & 0xff00) | ((relocation >> 16) & 0xff);
	    bfd_put_16 (input_bfd, x, contents + address);
d2697 20
a2716 5
	    x = bfd_get_16 (input_bfd, contents + address + 2);
	    x = relocation & 0xFFFF;
	    bfd_put_16 (input_bfd, x, contents + address + 2);
	    r = bfd_reloc_ok;
	  }
a2719 5
	do_default:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, address,
					relocation, rel->r_addend);

d2723 2
a2724 5
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
         because such sections are not SEC_ALLOC and thus ld.so will
         not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0 && h->def_dynamic))
d2726 29
a2754 5
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	     input_bfd,
	     input_section, (long) rel->r_offset, h->root.root.string);
	  return FALSE;
d2756 4
d2763 1
a2763 1
	  const char *name;
d2765 1
a2765 3
	  if (h != NULL)
	    name = h->root.root.string;
	  else
d2767 1573
a4339 7
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
d4341 38
d4380 1
a4380 17
	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, (h ? &h->root : NULL), name, howto->name,
		     (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }
d4382 7
d4392 8
a4399 6
static asection *
bfin_gc_mark_hook (asection * sec,
		   struct bfd_link_info *info ATTRIBUTE_UNUSED,
		   Elf_Internal_Rela * rel,
		   struct elf_link_hash_entry *h,
                   Elf_Internal_Sym * sym)
d4401 3
a4403 4
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
d4405 1
a4405 3
	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  break;
d4407 8
a4414 5
	default:
	  switch (h->root.type)
	    {
	    default:
	      break;
d4416 2
a4417 3
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d4419 13
a4431 7
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d4433 1
a4433 1
  return NULL;
d4437 104
a4540 1
/* Update the got entry reference counts for the section being removed.  */
d4543 2
a4544 4
bfin_gc_sweep_hook (bfd * abfd,
		    struct bfd_link_info *info,
		    asection * sec,
                    const Elf_Internal_Rela * relocs)
d4547 3
a4549 3
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
d4551 1
a4551 2
  asection *sgot;
  asection *srelgot;
d4553 1
a4553 2
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
d4558 3
a4560 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d4562 3
a4564 5
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
d4566 1
d4568 6
a4573 1
      struct elf_link_hash_entry *h;
d4577 27
a4603 3
	case R_got:
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
d4605 2
a4606 11
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
d4608 1
a4608 1
	  else if (local_got_refcounts != NULL)
d4610 14
a4623 11
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      if (info->shared)
			srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
d4625 6
d4632 1
d4634 1
d4637 89
d4731 9
a4740 2
/* Merge backend specific data from an object file to the output
   object file when linking.  */
d4742 1
a4742 1
elf32_bfin_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
d4744 6
a4749 2
  flagword out_flags;
  flagword in_flags;
d4751 3
d4758 2
a4759 8
  in_flags = elf_elfheader (ibfd)->e_flags;
  out_flags = elf_elfheader (obfd)->e_flags;

  if (!elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;
    }
d4761 2
a4765 1

d4767 1
a4767 1
elf32_bfin_set_private_flags (bfd * abfd, flagword flags)
d4769 38
a4806 2
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
d4816 1
d4823 1
a4823 2
  /* Ignore init flag - it may not be set, despite the flags field
     containing valid data.  */
d4828 6
d4839 74
d4937 1
a4937 1
			    struct bfd_hash_table *table, const char *string)
d4964 2
a4965 2
  ret = (struct bfin_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct bfin_link_hash_table *) NULL)
d4970 1
a4970 1
				      sizeof (struct bfin_link_hash_entry)))
a5256 3
/* Set the sizes of the dynamic sections.  */
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/libc.so.1"

d5402 1
a5402 1

d5528 1
a5528 1

d5539 1
d5554 1
a5554 1
#define elf_backend_check_relocs   bfin_check_relocs
d5581 69
@


1.5
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1 1
a1 1
/* ADI Blackfin BFD support for 32-bit ELF. 
a26 161
/* Handling expression relocations for blackfin.  Blackfin
   will generate relocations in an expression form with a stack.
   A relocation such as P1.H  = _typenames-4000000;
   will generate the following relocs at offset 4:
00000004 R_expst_push      _typenames
00000004 R_expst_const     .__constant
00000004 R_expst_sub       .__operator
00000006 R_huimm16         .__operator

   The .__constant and .__operator symbol names are fake.
   Special case is a single relocation
     P1.L  = _typenames; generates
00000002 R_luimm16         _typenames

   Thus, if you get a R_luimm16, R_huimm16, R_imm16,
   if the stack is not empty, pop the stack and
   put the value, else do the normal thing
   We will currently assume that the max the stack
   would grow to is 100. .  */

#define RELOC_STACK_SIZE 100
static bfd_vma reloc_stack[RELOC_STACK_SIZE];
static unsigned int reloc_stack_tos = 0;

#define is_reloc_stack_empty() ((reloc_stack_tos > 0) ? 0 : 1)

static void
reloc_stack_push (bfd_vma value)
{
  reloc_stack[reloc_stack_tos++] = value;
}

static bfd_vma
reloc_stack_pop (void)
{
  return reloc_stack[--reloc_stack_tos];
}

static bfd_vma
reloc_stack_operate (unsigned int oper)
{
  bfd_vma value;
  switch (oper)
    {
    case R_add:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] + reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_sub:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] - reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_mult:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] * reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_div:
      {
	if (reloc_stack[reloc_stack_tos - 1] == 0)
	  {
	    _bfd_abort (__FILE__, __LINE__, _("Division by zero. "));
	  }
	else
	  {
	    value =
	      reloc_stack[reloc_stack_tos - 2] / reloc_stack[reloc_stack_tos - 1];
	    reloc_stack_tos -= 2;
	  }
	break;
      }
    case R_mod:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] % reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_lshift:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] << reloc_stack[reloc_stack_tos -
							  1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_rshift:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] >> reloc_stack[reloc_stack_tos -
							  1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_and:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] & reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_or:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] | reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_xor:
      {
	value =
	  reloc_stack[reloc_stack_tos - 2] ^ reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_land:
      {
	value = reloc_stack[reloc_stack_tos - 2]
	  && reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_lor:
      {
	value = reloc_stack[reloc_stack_tos - 2]
	  || reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 2;
	break;
      }
    case R_neg:
      {
	value = -reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos--;
	break;
      }
    case R_comp:
      {
	value = ~reloc_stack[reloc_stack_tos - 1];
	reloc_stack_tos -= 1;
	break;
      }
    default:
      {
	fprintf (stderr, "bfin relocation : Internal bug\n");
	return 0;
      }
    }

  reloc_stack_push (value);

  return value;
}

d37 1
a37 1
     char **error_message ATTRIBUTE_UNUSED) 
d40 1
a40 1
  return flag; 
d63 7
a69 2
  if (!is_reloc_stack_empty ())
    relocation = reloc_stack_pop();
d71 8
a78 5
    {
      if (bfd_is_und_section (symbol->section)
          && (symbol->flags & BSF_WEAK) == 0
          && !relocatable)
        return bfd_reloc_undefined;
d80 2
a81 4
      if (bfd_is_com_section (symbol->section))
	relocation = 0;
      else
	relocation = symbol->value;       
d83 2
a84 1
      output_section = symbol->section->output_section;
a85 12
      if (relocatable)
	output_base = 0;
      else
	output_base = output_section->vma;
      
      if (!relocatable || !strcmp (symbol->name, symbol->section->name))
	relocation += output_base + symbol->section->output_offset;
        
      if (!relocatable && !strcmp (symbol->name, symbol->section->name))
        relocation += reloc_entry->addend;
    }
      
d92 5
a96 5
      status= bfd_check_overflow (howto->complain_on_overflow, 
                                  howto->bitsize,
                                  howto->rightshift, 
                                  bfd_arch_bits_per_address(abfd),
                                  relocation);      
d100 1
a100 1
      
d123 5
a127 5
    the start of instruction. Assuming absolute postion
    of the reloc data. But, following code had been written assuming 
    reloc address is starting at begining of instruction.
    To compensate that I have increased the value of 
    relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */ 
d142 7
a148 7
bfin_push_reloc (bfd *abfd ATTRIBUTE_UNUSED,
     		 arelent *reloc_entry,
     		 asymbol *symbol,
     		 PTR data ATTRIBUTE_UNUSED,
     		 asection *input_section,
     		 bfd *output_bfd,
     		 char **error_message ATTRIBUTE_UNUSED) 
d150 2
a151 1
  bfd_vma relocation;
d153 1
d157 4
a165 4
  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit(abfd, input_section))
     return bfd_reloc_outofrange;
      
d167 1
a167 1
  relocation = symbol->value;      
d175 1
a175 1
  if (!relocatable || !strcmp(symbol->name, symbol->section->name))
a185 99

  /* Now that we have the value, push it. */
  reloc_stack_push (relocation);
  
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
bfin_oper_reloc (bfd *abfd ATTRIBUTE_UNUSED,
     		 arelent *reloc_entry,
     		 asymbol *symbol ATTRIBUTE_UNUSED,
     		 PTR data ATTRIBUTE_UNUSED,
     		 asection *input_section,
     		 bfd *output_bfd,
     		 char **error_message ATTRIBUTE_UNUSED) 
{
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Just call the operation based on the reloc_type.  */
  reloc_stack_operate (reloc_entry->howto->type);
  
  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
bfin_const_reloc (bfd *abfd ATTRIBUTE_UNUSED,
     		  arelent *reloc_entry,
     		  asymbol *symbol ATTRIBUTE_UNUSED,
     		  PTR data ATTRIBUTE_UNUSED,
     		  asection *input_section,
     		  bfd *output_bfd,
     		  char **error_message ATTRIBUTE_UNUSED) 
{
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Push the addend portion of the relocation.  */
  reloc_stack_push (reloc_entry->addend);

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  
  return bfd_reloc_ok;
}

static bfd_reloc_status_type
bfin_imm16_reloc (bfd *abfd,
     		  arelent *reloc_entry,
     		  asymbol *symbol,
     		  PTR data,
     		  asection *input_section,
     		  bfd *output_bfd,
     		  char **error_message ATTRIBUTE_UNUSED) 
{
  bfd_vma relocation, x;
  bfd_size_type reloc_addr = reloc_entry->address;
  bfd_vma output_base = 0;
  reloc_howto_type *howto = reloc_entry->howto;
  asection *output_section;
  bfd_boolean relocatable = (output_bfd != NULL);

  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (is_reloc_stack_empty ())
    {
      if (bfd_is_und_section (symbol->section)
          && (symbol->flags & BSF_WEAK) == 0
          && !relocatable)
        return bfd_reloc_undefined;

      output_section = symbol->section->output_section;
      relocation = symbol->value;      

      /* Convert input-section-relative symbol value to absolute.  */
      if (relocatable)
        output_base = 0;
      else
	output_base = output_section->vma;
  
      if (!relocatable || !strcmp (symbol->name, symbol->section->name))
	relocation += output_base + symbol->section->output_offset;

      /* Add in supplied addend.  */
      relocation += reloc_entry->addend;
    }
  else
    {
      relocation = reloc_stack_pop ();
    }

  if (relocatable)
    {	              
      reloc_entry->address += input_section->output_offset;
      reloc_entry->addend += symbol->section->output_offset;
    }
d195 4
a198 4
                                 howto->bitsize,
                                 howto->rightshift,
                                 bfd_arch_bits_per_address(abfd),
                                 relocation);
d200 1
a200 1
        return flag;
a202 1

d220 1
a220 1
                  char **error_message ATTRIBUTE_UNUSED) 
d232 4
a235 22
  if (is_reloc_stack_empty ())
    {
      if (bfd_is_und_section (symbol->section)
          && (symbol->flags & BSF_WEAK) == 0
          && !relocatable)
        return bfd_reloc_undefined;

      output_section = symbol->section->output_section;
      relocation = symbol->value;      
      /* Convert input-section-relative symbol value to absolute.  */
      if (relocatable)
	output_base = 0;
      else
	output_base = output_section->vma;
  
      if ((symbol->name 
	  && symbol->section->name
          && !strcmp (symbol->name, symbol->section->name))
          || !relocatable)
        {
	  relocation += output_base + symbol->section->output_offset;
	}
d237 5
a241 2
      relocation += reloc_entry->addend;
    }
d243 6
d250 1
a250 2
      relocation = reloc_stack_pop();
      relocation += reloc_entry->addend;
d253 2
d256 1
a256 1
    { 
d271 1
a271 1
            
d299 16
a314 31
  if (is_reloc_stack_empty())
    {
      if (bfd_is_und_section (symbol->section)
          && (symbol->flags & BSF_WEAK) == 0
          && !relocatable)
        return bfd_reloc_undefined;

      /* Get symbol value.  (Common symbols are special.)  */
      if (bfd_is_com_section (symbol->section))
        relocation = 0;
      else
        relocation = symbol->value;       
  
      output_section = symbol->section->output_section;
        
      /* Convert input-section-relative symbol value to absolute.  */
      if (relocatable)
	output_base = 0;
      else
	output_base = output_section->vma;
        
      if (!relocatable || !strcmp (symbol->name, symbol->section->name))
        relocation += output_base + symbol->section->output_offset;

     if (!relocatable && !strcmp (symbol->name, symbol->section->name))
       {
         /* Add in supplied addend.  */
         relocation += reloc_entry->addend;
       }
        
    }
d316 6
d323 2
a324 1
      relocation = reloc_stack_pop();
d326 1
a326 1
      
d348 1
a348 1
      status = bfd_check_overflow (howto->complain_on_overflow, 
d350 1
a350 1
                                  howto->rightshift, 
d356 1
a356 1
      
d370 1
a370 1
#define DOIT(x) \
d396 1
a396 1
   return bfd_reloc_ok;
a398 32
#if 0
static bfd_reloc_status_type bfin_bfd_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_imm16_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_pcrel24_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_pltpc_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_const_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_oper_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_byte4_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_reloc_status_type bfin_push_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

static bfd_boolean bfin_is_local_label_name
  PARAMS ((bfd *, const char *));
#endif
bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *, char **));


d477 1
a477 1
 
d523 1
a523 1
 
a706 283
static reloc_howto_type bfin_areloc_howto_table [] =
{
  HOWTO (R_push,
	 0,
	 2,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfin_push_reloc,
	 "R_expst_push",
	 FALSE,
	 0,
	 0,
	 FALSE),

  HOWTO (R_const,
	 0,
	 2,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfin_const_reloc,
	 "R_expst_const",
	 FALSE,
	 0,
	 0,
	 FALSE),

  HOWTO (R_add,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfin_oper_reloc,
	 "R_expst_add",
	 FALSE,
	 0,
	 0,
	 FALSE),

  HOWTO (R_sub,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfin_oper_reloc,
	 "R_expst_sub",
	 FALSE,
	 0,
	 0,
	 FALSE),

  HOWTO (R_mult,
	 0,
	 0,
	 0,
	 FALSE,
	 0,
	 complain_overflow_dont,
	 bfin_oper_reloc,
	 "R_expst_mult",
	 FALSE,
	 0,
	 0,
	 FALSE),

  HOWTO (R_div,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_div",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_mod,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_mod",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_lshift,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_lshift",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_rshift,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_rshift",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_and,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_and",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_or,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_or",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_xor,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_xor",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_land,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_land",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_lor,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_lor",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_len,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_len",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_neg,			/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_neg",		/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */

  HOWTO (R_comp,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_comp",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */
  
  HOWTO (R_page,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_page",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */
  
  HOWTO (R_hwpage,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_hwpage",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */
  
  HOWTO (R_addr,		/* type.  */
	 0,			/* rightshift.  */
	 0,			/* size (0 = byte, 1 = short, 2 = long).  */
	 0,			/* bitsize.  */
	 FALSE,			/* pc_relative.  */
	 0,			/* bitpos.  */
	 complain_overflow_dont, /* complain_on_overflow.  */
	 bfin_oper_reloc,	/* special_function.  */
	 "R_expst_addr",	/* name.  */
	 FALSE,			/* partial_inplace.  */
	 0,			/* src_mask.  */
	 0,			/* dst_mask.  */
	 FALSE),		/* pcrel_offset.  */
};

a798 21
  { BFD_ARELOC_BFIN_PUSH,		R_push },
  { BFD_ARELOC_BFIN_CONST,		R_const },
  { BFD_ARELOC_BFIN_ADD,		R_add },
  { BFD_ARELOC_BFIN_SUB,		R_sub },
  { BFD_ARELOC_BFIN_MULT,		R_mult },
  { BFD_ARELOC_BFIN_DIV,		R_div },
  { BFD_ARELOC_BFIN_MOD,		R_mod },
  { BFD_ARELOC_BFIN_LSHIFT,		R_lshift },
  { BFD_ARELOC_BFIN_RSHIFT,		R_rshift },
  { BFD_ARELOC_BFIN_AND,		R_and },
  { BFD_ARELOC_BFIN_OR,			R_or },
  { BFD_ARELOC_BFIN_XOR,		R_xor },
  { BFD_ARELOC_BFIN_LAND,		R_land },
  { BFD_ARELOC_BFIN_LOR,		R_lor },
  { BFD_ARELOC_BFIN_LEN,		R_len },
  { BFD_ARELOC_BFIN_NEG,		R_neg },
  { BFD_ARELOC_BFIN_COMP,		R_comp },
  { BFD_ARELOC_BFIN_PAGE,		R_page },
  { BFD_ARELOC_BFIN_HWPAGE,		R_hwpage },
  { BFD_ARELOC_BFIN_ADDR,		R_addr }

a813 3
  else if (r_type >= BFIN_ARELOC_MIN && r_type <= BFIN_ARELOC_MAX)
    cache_ptr->howto = &bfin_areloc_howto_table [r_type - BFIN_ARELOC_MIN];

a835 3
  else if (r_type >= BFIN_ARELOC_MIN && r_type <= BFIN_ARELOC_MAX)
   return &bfin_areloc_howto_table [r_type - BFIN_ARELOC_MIN];

a849 3
  else if (r_type >= BFIN_ARELOC_MIN && r_type <= BFIN_ARELOC_MAX)
   return &bfin_areloc_howto_table [r_type - BFIN_ARELOC_MIN];

d1113 6
a1118 18
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (!
	      (!strcmp (h->root.root.string, ".__constant")
	       || !strcmp (h->root.root.string, ".__operator")))
	    {
	      bfd_boolean warned;
	      h = NULL;
	      RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				       r_symndx, symtab_hdr, sym_hashes,
				       h, sec, relocation,
				       unresolved_reloc, warned);

	    }
a1121 36
      /* First, get stack relocs out of the way.  */
      switch (r_type)
	{
	case R_push:
	  reloc_stack_push (relocation + rel->r_addend);
	  r = bfd_reloc_ok;
	  goto done_reloc;
	case R_const:
	  reloc_stack_push (rel->r_addend);
	  r = bfd_reloc_ok;
	  goto done_reloc;
	case R_add:
	case R_sub:
	case R_mult:
	case R_div:
	case R_mod:
	case R_lshift:
	case R_rshift:
	case R_neg:
	case R_and:
	case R_or:
	case R_xor:
	case R_land:
	case R_lor:
	case R_comp:
	case R_page:
	case R_hwpage:
	  reloc_stack_operate (r_type);
	  r = bfd_reloc_ok;
	  goto done_reloc;

	default:
	  if (!is_reloc_stack_empty())
	    relocation = reloc_stack_pop ();
	  break;
	}
d1247 1
a1247 1
	       of the reloc data. But, following code had been written assuming 
d1249 2
a1250 2
	       To compensate that I have increased the value of 
	       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */ 
a1276 1
    done_reloc:
d1997 3
d2119 1
a2119 1
#define ELF_MACHINE_CODE		EM_BLACKFIN	
@


1.5.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d1 1
a1 1
/* ADI Blackfin BFD support for 32-bit ELF.
d26 161
a186 2
#include "elf/dwarf2.h"
#include "hashtab.h"
d198 1
a198 1
     char **error_message ATTRIBUTE_UNUSED)
d201 1
a201 1
  return flag;
d224 2
a225 7
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
d227 5
a231 1
    relocation = symbol->value;
d233 4
a236 1
  output_section = symbol->section->output_section;
d238 1
a238 10
  if (relocatable)
    output_base = 0;
  else
    output_base = output_section->vma;

  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
    relocation += output_base + symbol->section->output_offset;

  if (!relocatable && !strcmp (symbol->name, symbol->section->name))
    relocation += reloc_entry->addend;
d240 12
d258 5
a262 5
      status = bfd_check_overflow (howto->complain_on_overflow,
				   howto->bitsize,
				   howto->rightshift,
				   bfd_arch_bits_per_address(abfd),
				   relocation);
d266 1
a266 1

d289 5
a293 5
       the start of instruction. Assuming absolute postion
       of the reloc data. But, following code had been written assuming
       reloc address is starting at begining of instruction.
       To compensate that I have increased the value of
       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
d308 7
a314 7
bfin_imm16_reloc (bfd *abfd,
     		  arelent *reloc_entry,
     		  asymbol *symbol,
     		  PTR data,
     		  asection *input_section,
     		  bfd *output_bfd,
     		  char **error_message ATTRIBUTE_UNUSED)
d316 1
a316 2
  bfd_vma relocation, x;
  bfd_size_type reloc_addr = reloc_entry->address;
a317 1
  reloc_howto_type *howto = reloc_entry->howto;
a320 4
  /* Is the address of the relocation really within the section?  */
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

d326 4
d331 1
a331 1
  relocation = symbol->value;
d339 1
a339 1
  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
d350 99
d458 4
a461 4
				 howto->bitsize,
				 howto->rightshift,
				 bfd_arch_bits_per_address(abfd),
				 relocation);
d463 1
a463 1
	return flag;
d466 1
d484 1
a484 1
                  char **error_message ATTRIBUTE_UNUSED)
d496 22
a517 4
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;
d519 2
a520 5
  output_section = symbol->section->output_section;
  relocation = symbol->value;
  /* Convert input-section-relative symbol value to absolute.  */
  if (relocatable)
    output_base = 0;
a521 6
    output_base = output_section->vma;

  if ((symbol->name
       && symbol->section->name
       && !strcmp (symbol->name, symbol->section->name))
      || !relocatable)
d523 2
a524 1
      relocation += output_base + symbol->section->output_offset;
a526 2
  relocation += reloc_entry->addend;

d528 1
a528 1
    {
d543 1
a543 1

d571 31
a601 16
  if (bfd_is_und_section (symbol->section)
      && (symbol->flags & BSF_WEAK) == 0
      && !relocatable)
    return bfd_reloc_undefined;

  /* Get symbol value.  (Common symbols are special.)  */
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  output_section = symbol->section->output_section;

  /* Convert input-section-relative symbol value to absolute.  */
  if (relocatable)
    output_base = 0;
a602 6
    output_base = output_section->vma;

  if (!relocatable || !strcmp (symbol->name, symbol->section->name))
    relocation += output_base + symbol->section->output_offset;

  if (!relocatable && !strcmp (symbol->name, symbol->section->name))
d604 1
a604 2
      /* Add in supplied addend.  */
      relocation += reloc_entry->addend;
d606 1
a606 1

d628 1
a628 1
      status = bfd_check_overflow (howto->complain_on_overflow,
d630 1
a630 1
                                  howto->rightshift,
d636 1
a636 1

d650 1
a650 1
#define DOIT(x)								\
d676 1
a676 1
  return bfd_reloc_ok;
d679 32
d725 1
a725 1
#define BFIN_RELOC_MAX 0x21
d789 1
a789 1

d835 1
a835 1

d1017 1
d1019 71
d1091 13
a1103 222
  /* A 18-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_BFIN_GOT17M4,        /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOT12",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTHI,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTHI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		        /* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTLO,	        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTLO",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOT17M4,	/* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOT17M4", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTHI,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The 32-bit address of the canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_VALUE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_VALUE", /* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFF17M4, /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFF17M4", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFFHI, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFFHI", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     canonical descriptor of a function.  */
  HOWTO (R_BFIN_FUNCDESC_GOTOFFLO, /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_FUNCDESC_GOTOFFLO", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* A 12-bit signed operand with the GOT offset for the address of
     the symbol.  */
  HOWTO (R_BFIN_GOTOFF17M4,     /* type */
	 2,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFF17M4",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,	        /* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The upper 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTOFFHI,        /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFFHI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */

  /* The lower 16 bits of the GOT offset for the address of the
     symbol.  */
  HOWTO (R_BFIN_GOTOFFLO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_BFIN_GOTOFFLO",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),	        /* pcrel_offset */
};
d1105 1
a1105 3
static reloc_howto_type bfin_gnuext_howto_table [] =
{
  HOWTO (R_pltpc,		/* type.  */
d1107 2
a1108 2
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
d1111 3
a1113 3
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfin_pltpc_reloc,	/* special_function.  */
	 "R_pltpc",		/* name.  */
d1115 2
a1116 2
	 0xffff,		/* src_mask.  */
	 0xffff,		/* dst_mask.  */
d1119 1
a1119 1
  HOWTO (R_got,			/* type.  */
d1121 2
a1122 2
	 1,			/* size (0 = byte, 1 = short, 2 = long).  */
	 16,			/* bitsize.  */
d1125 3
a1127 3
	 complain_overflow_bitfield, /* complain_on_overflow.  */
	 bfd_elf_generic_reloc,	/* special_function.  */
	 "R_got",		/* name.  */
d1129 201
a1329 2
	 0x7fff,		/* src_mask.  */
	 0x7fff,		/* dst_mask.  */
a1391 16

  { BFD_RELOC_BFIN_GOT17M4,      R_BFIN_GOT17M4 },
  { BFD_RELOC_BFIN_GOTHI,      R_BFIN_GOTHI },
  { BFD_RELOC_BFIN_GOTLO,      R_BFIN_GOTLO },
  { BFD_RELOC_BFIN_FUNCDESC,   R_BFIN_FUNCDESC },
  { BFD_RELOC_BFIN_FUNCDESC_GOT17M4, R_BFIN_FUNCDESC_GOT17M4 },
  { BFD_RELOC_BFIN_FUNCDESC_GOTHI, R_BFIN_FUNCDESC_GOTHI },
  { BFD_RELOC_BFIN_FUNCDESC_GOTLO, R_BFIN_FUNCDESC_GOTLO },
  { BFD_RELOC_BFIN_FUNCDESC_VALUE, R_BFIN_FUNCDESC_VALUE },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4, R_BFIN_FUNCDESC_GOTOFF17M4 },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI, R_BFIN_FUNCDESC_GOTOFFHI },
  { BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO, R_BFIN_FUNCDESC_GOTOFFLO },
  { BFD_RELOC_BFIN_GOTOFF17M4,   R_BFIN_GOTOFF17M4 },
  { BFD_RELOC_BFIN_GOTOFFHI,   R_BFIN_GOTOFFHI },
  { BFD_RELOC_BFIN_GOTOFFLO,   R_BFIN_GOTOFFLO },

d1394 21
d1430 3
d1455 3
d1472 3
a1494 2
extern const bfd_target bfd_elf32_bfinfdpic_vec;
#define IS_FDPIC(bfd) ((bfd)->xvec == &bfd_elf32_bfinfdpic_vec)
d1496 9
a1504 3
/* An extension of the elf hash table data structure, containing some
   additional Blackfin-specific data.  */
struct bfinfdpic_elf_link_hash_table
d1506 6
a1511 3
  struct elf_link_hash_table elf;

  /* A pointer to the .got section.  */
d1513 4
a1516 17
  /* A pointer to the .rel.got section.  */
  asection *sgotrel;
  /* A pointer to the .rofixup section.  */
  asection *sgotfixup;
  /* A pointer to the .plt section.  */
  asection *splt;
  /* A pointer to the .rel.plt section.  */
  asection *spltrel;
  /* GOT base offset.  */
  bfd_vma got0;
  /* Location of the first non-lazy PLT entry, i.e., the number of
     bytes taken by lazy PLT entries.  */
  bfd_vma plt0;
  /* A hash table holding information about which symbols were
     referenced with which PIC-related relocations.  */
  struct htab *relocs_info;
};
d1518 4
a1521 1
/* Get the Blackfin ELF linker hash table from a link_info structure.  */
d1523 3
a1525 2
#define bfinfdpic_hash_table(info) \
  ((struct bfinfdpic_elf_link_hash_table *) ((info)->hash))
d1527 5
a1531 16
#define bfinfdpic_got_section(info) \
  (bfinfdpic_hash_table (info)->sgot)
#define bfinfdpic_gotrel_section(info) \
  (bfinfdpic_hash_table (info)->sgotrel)
#define bfinfdpic_gotfixup_section(info) \
  (bfinfdpic_hash_table (info)->sgotfixup)
#define bfinfdpic_plt_section(info) \
  (bfinfdpic_hash_table (info)->splt)
#define bfinfdpic_pltrel_section(info) \
  (bfinfdpic_hash_table (info)->spltrel)
#define bfinfdpic_relocs_info(info) \
  (bfinfdpic_hash_table (info)->relocs_info)
#define bfinfdpic_got_initial_offset(info) \
  (bfinfdpic_hash_table (info)->got0)
#define bfinfdpic_plt_initial_offset(info) \
  (bfinfdpic_hash_table (info)->plt0)
d1533 5
a1537 1
/* Create a Blackfin ELF linker hash table.  */
d1539 8
a1546 5
static struct bfd_link_hash_table *
bfinfdpic_elf_link_hash_table_create (bfd *abfd)
{
  struct bfinfdpic_elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct bfinfdpic_elf_link_hash_table);
d1548 6
a1553 3
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
    return NULL;
d1555 5
a1559 7
  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }
d1561 7
a1567 2
  return &ret->elf.root;
}
d1569 5
a1573 94
/* Decide whether a reference to a symbol can be resolved locally or
   not.  If the symbol is protected, we want the local address, but
   its function descriptor must be assigned by the dynamic linker.  */
#define BFINFDPIC_SYM_LOCAL(INFO, H) \
  (_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \
   || ! elf_hash_table (INFO)->dynamic_sections_created)
#define BFINFDPIC_FUNCDESC_LOCAL(INFO, H) \
  ((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)

/* This structure collects information on what kind of GOT, PLT or
   function descriptors are required by relocations that reference a
   certain symbol.  */
struct bfinfdpic_relocs_info
{
  /* The index of the symbol, as stored in the relocation r_info, if
     we have a local symbol; -1 otherwise.  */
  long symndx;
  union
  {
    /* The input bfd in which the symbol is defined, if it's a local
       symbol.  */
    bfd *abfd;
    /* If symndx == -1, the hash table entry corresponding to a global
       symbol (even if it turns out to bind locally, in which case it
       should ideally be replaced with section's symndx + addend).  */
    struct elf_link_hash_entry *h;
  } d;
  /* The addend of the relocation that references the symbol.  */
  bfd_vma addend;

  /* The fields above are used to identify an entry.  The fields below
     contain information on how an entry is used and, later on, which
     locations it was assigned.  */
  /* The following 2 fields record whether the symbol+addend above was
     ever referenced with a GOT relocation.  The 17M4 suffix indicates a
     GOT17M4 relocation; hilo is used for GOTLO/GOTHI pairs.  */
  unsigned got17m4:1;
  unsigned gothilo:1;
  /* Whether a FUNCDESC relocation references symbol+addend.  */
  unsigned fd:1;
  /* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
  unsigned fdgot17m4:1;
  unsigned fdgothilo:1;
  /* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
  unsigned fdgoff17m4:1;
  unsigned fdgoffhilo:1;
  /* Whether symbol+addend is referenced with GOTOFF17M4, GOTOFFLO or
     GOTOFFHI relocations.  The addend doesn't really matter, since we
     envision that this will only be used to check whether the symbol
     is mapped to the same segment as the got.  */
  unsigned gotoff:1;
  /* Whether symbol+addend is referenced by a LABEL24 relocation.  */
  unsigned call:1;
  /* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE
     relocation.  */
  unsigned sym:1;
  /* Whether we need a PLT entry for a symbol.  Should be implied by
     something like:
     (call && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h))  */
  unsigned plt:1;
  /* Whether a function descriptor should be created in this link unit
     for symbol+addend.  Should be implied by something like:
     (plt || fdgotoff17m4 || fdgotofflohi
      || ((fd || fdgot17m4 || fdgothilo)
          && (symndx != -1 || BFINFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
  unsigned privfd:1;
  /* Whether a lazy PLT entry is needed for this symbol+addend.
     Should be implied by something like:
     (privfd && symndx == -1 && ! BFINFDPIC_SYM_LOCAL (info, d.h)
      && ! (info->flags & DF_BIND_NOW))  */
  unsigned lazyplt:1;
  /* Whether we've already emitted GOT relocations and PLT entries as
     needed for this symbol.  */
  unsigned done:1;

  /* The number of R_byte4_data, R_BFIN_FUNCDESC and R_BFIN_FUNCDESC_VALUE
     relocations referencing the symbol.  */
  unsigned relocs32, relocsfd, relocsfdv;

  /* The number of .rofixups entries and dynamic relocations allocated
     for this symbol, minus any that might have already been used.  */
  unsigned fixups, dynrelocs;

  /* The offsets of the GOT entries assigned to symbol+addend, to the
     function descriptor's address, and to a function descriptor,
     respectively.  Should be zero if unassigned.  The offsets are
     counted from the value that will be assigned to the PIC register,
     not from the beginning of the .got section.  */
  bfd_signed_vma got_entry, fdgot_entry, fd_entry;
  /* The offsets of the PLT entries assigned to symbol+addend,
     non-lazy and lazy, respectively.  If unassigned, should be
     (bfd_vma)-1.  */
  bfd_vma plt_entry, lzplt_entry;
};
d1575 18
a1592 5
/* Compute a hash with the key fields of an bfinfdpic_relocs_info entry.  */
static hashval_t
bfinfdpic_relocs_info_hash (const void *entry_)
{
  const struct bfinfdpic_relocs_info *entry = entry_;
d1594 10
a1603 4
  return (entry->symndx == -1
	  ? (long) entry->d.h->root.root.hash
	  : entry->symndx + (long) entry->d.abfd->id * 257) + entry->addend;
}
d1605 13
a1617 7
/* Test whether the key fields of two bfinfdpic_relocs_info entries are
   identical.  */
static int
bfinfdpic_relocs_info_eq (const void *entry1, const void *entry2)
{
  const struct bfinfdpic_relocs_info *e1 = entry1;
  const struct bfinfdpic_relocs_info *e2 = entry2;
d1619 22
a1640 3
  return e1->symndx == e2->symndx && e1->addend == e2->addend
    && (e1->symndx == -1 ? e1->d.h == e2->d.h : e1->d.abfd == e2->d.abfd);
}
d1642 4
a1645 11
/* Find or create an entry in a hash table HT that matches the key
   fields of the given ENTRY.  If it's not found, memory for a new
   entry is allocated in ABFD's obstack.  */
static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_find (struct htab *ht,
			   bfd *abfd,
			   const struct bfinfdpic_relocs_info *entry,
			   enum insert_option insert)
{
  struct bfinfdpic_relocs_info **loc =
    (struct bfinfdpic_relocs_info **) htab_find_slot (ht, entry, insert);
d1647 1
a1647 18
  if (! loc)
    return NULL;

  if (*loc)
    return *loc;

  *loc = bfd_zalloc (abfd, sizeof (**loc));

  if (! *loc)
    return *loc;

  (*loc)->symndx = entry->symndx;
  (*loc)->d = entry->d;
  (*loc)->addend = entry->addend;
  (*loc)->plt_entry = (bfd_vma)-1;
  (*loc)->lzplt_entry = (bfd_vma)-1;

  return *loc;
d1650 2
a1651 9
/* Obtain the address of the entry in HT associated with H's symbol +
   addend, creating a new entry if none existed.  ABFD is only used
   for memory allocation purposes.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_global (struct htab *ht,
				 bfd *abfd,
				 struct elf_link_hash_entry *h,
				 bfd_vma addend,
				 enum insert_option insert)
d1653 1
a1653 87
  struct bfinfdpic_relocs_info entry;

  entry.symndx = -1;
  entry.d.h = h;
  entry.addend = addend;

  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Obtain the address of the entry in HT associated with the SYMNDXth
   local symbol of the input bfd ABFD, plus the addend, creating a new
   entry if none existed.  */
inline static struct bfinfdpic_relocs_info *
bfinfdpic_relocs_info_for_local (struct htab *ht,
				bfd *abfd,
				long symndx,
				bfd_vma addend,
				enum insert_option insert)
{
  struct bfinfdpic_relocs_info entry;

  entry.symndx = symndx;
  entry.d.abfd = abfd;
  entry.addend = addend;

  return bfinfdpic_relocs_info_find (ht, abfd, &entry, insert);
}

/* Merge fields set by check_relocs() of two entries that end up being
   mapped to the same (presumably global) symbol.  */

inline static void
bfinfdpic_pic_merge_early_relocs_info (struct bfinfdpic_relocs_info *e2,
				      struct bfinfdpic_relocs_info const *e1)
{
  e2->got17m4 |= e1->got17m4;
  e2->gothilo |= e1->gothilo;
  e2->fd |= e1->fd;
  e2->fdgot17m4 |= e1->fdgot17m4;
  e2->fdgothilo |= e1->fdgothilo;
  e2->fdgoff17m4 |= e1->fdgoff17m4;
  e2->fdgoffhilo |= e1->fdgoffhilo;
  e2->gotoff |= e1->gotoff;
  e2->call |= e1->call;
  e2->sym |= e1->sym;
}

/* Every block of 65535 lazy PLT entries shares a single call to the
   resolver, inserted in the 32768th lazy PLT entry (i.e., entry #
   32767, counting from 0).  All other lazy PLT entries branch to it
   in a single instruction.  */

#define LZPLT_RESOLVER_EXTRA 10
#define LZPLT_NORMAL_SIZE 6
#define LZPLT_ENTRIES 1362

#define BFINFDPIC_LZPLT_BLOCK_SIZE ((bfd_vma) LZPLT_NORMAL_SIZE * LZPLT_ENTRIES + LZPLT_RESOLVER_EXTRA)
#define BFINFDPIC_LZPLT_RESOLV_LOC (LZPLT_NORMAL_SIZE * LZPLT_ENTRIES / 2)

/* Add a dynamic relocation to the SRELOC section.  */

inline static bfd_vma
_bfinfdpic_add_dyn_reloc (bfd *output_bfd, asection *sreloc, bfd_vma offset,
			 int reloc_type, long dynindx, bfd_vma addend,
			 struct bfinfdpic_relocs_info *entry)
{
  Elf_Internal_Rela outrel;
  bfd_vma reloc_offset;

  outrel.r_offset = offset;
  outrel.r_info = ELF32_R_INFO (dynindx, reloc_type);
  outrel.r_addend = addend;

  reloc_offset = sreloc->reloc_count * sizeof (Elf32_External_Rel);
  BFD_ASSERT (reloc_offset < sreloc->size);
  bfd_elf32_swap_reloc_out (output_bfd, &outrel,
			    sreloc->contents + reloc_offset);
  sreloc->reloc_count++;

  /* If the entry's index is zero, this relocation was probably to a
     linkonce section that got discarded.  We reserved a dynamic
     relocation, but it was for another entry than the one we got at
     the time of emitting the relocation.  Unfortunately there's no
     simple way for us to catch this situation, since the relocation
     is cleared right before calling relocate_section, at which point
     we no longer know what the relocation used to point to.  */
  if (entry->symndx)
d1655 2
a1656 2
      BFD_ASSERT (entry->dynrelocs > 0);
      entry->dynrelocs--;
a1657 2

  return reloc_offset;
d1660 9
a1668 5
/* Add a fixup to the ROFIXUP section.  */

static bfd_vma
_bfinfdpic_add_rofixup (bfd *output_bfd, asection *rofixup, bfd_vma offset,
		       struct bfinfdpic_relocs_info *entry)
d1670 9
a1678 1
  bfd_vma fixup_offset;
d1680 2
a1681 2
  if (rofixup->flags & SEC_EXCLUDE)
    return -1;
d1683 4
a1686 7
  fixup_offset = rofixup->reloc_count * 4;
  if (rofixup->contents)
    {
      BFD_ASSERT (fixup_offset < rofixup->size);
      bfd_put_32 (output_bfd, offset, rofixup->contents + fixup_offset);
    }
  rofixup->reloc_count++;
d1688 2
a1689 7
  if (entry && entry->symndx)
    {
      /* See discussion about symndx == 0 in _bfinfdpic_add_dyn_reloc
	 above.  */
      BFD_ASSERT (entry->fixups > 0);
      entry->fixups--;
    }
d1691 3
a1693 17
  return fixup_offset;
}

/* Find the segment number in which OSEC, and output section, is
   located.  */

static unsigned
_bfinfdpic_osec_to_segment (bfd *output_bfd, asection *osec)
{
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  /* Find the segment that contains the output_section.  */
  for (m = elf_tdata (output_bfd)->segment_map,
	 p = elf_tdata (output_bfd)->phdr;
       m != NULL;
       m = m->next, p++)
d1695 10
a1704 1
      int i;
d1706 2
a1707 45
      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == osec)
	  break;

      if (i >= 0)
	break;
    }

  return p - elf_tdata (output_bfd)->phdr;
}

inline static bfd_boolean
_bfinfdpic_osec_readonly_p (bfd *output_bfd, asection *osec)
{
  unsigned seg = _bfinfdpic_osec_to_segment (output_bfd, osec);

  return ! (elf_tdata (output_bfd)->phdr[seg].p_flags & PF_W);
}

/* Generate relocations for GOT entries, function descriptors, and
   code for PLT and lazy PLT entries.  */

inline static bfd_boolean
_bfinfdpic_emit_got_relocs_plt_entries (struct bfinfdpic_relocs_info *entry,
					bfd *output_bfd,
					struct bfd_link_info *info,
					asection *sec,
					Elf_Internal_Sym *sym,
					bfd_vma addend)

{
  bfd_vma fd_lazy_rel_offset = (bfd_vma)-1;
  int dynindx = -1;

  if (entry->done)
    return TRUE;
  entry->done = 1;

  if (entry->got_entry || entry->fdgot_entry || entry->fd_entry)
    {
      /* If the symbol is dynamic, consider it for dynamic
	 relocations, otherwise decay to section + offset.  */
      if (entry->symndx == -1 && entry->d.h->dynindx != -1)
	dynindx = entry->d.h->dynindx;
      else
d1709 2
a1710 6
	  if (sec->output_section
	      && ! bfd_is_abs_section (sec->output_section)
	      && ! bfd_is_und_section (sec->output_section))
	    dynindx = elf_section_data (sec->output_section)->dynindx;
	  else
	    dynindx = 0;
a1711 1
    }
d1713 3
a1715 5
  /* Generate relocation for GOT entry pointing to the symbol.  */
  if (entry->got_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
d1717 2
a1718 4
      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
d1720 2
a1721 9
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
d1723 6
d1730 1
a1730 6
      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1
	      || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
d1732 3
a1734 11
	  if (sec)
	    ad += sec->output_section->vma;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    _bfinfdpic_add_rofixup (output_bfd,
				   bfinfdpic_gotfixup_section (info),
				   bfinfdpic_got_section (info)->output_section
				   ->vma
				   + bfinfdpic_got_section (info)->output_offset
				   + bfinfdpic_got_initial_offset (info)
				   + entry->got_entry, entry);
a1736 27
	_bfinfdpic_add_dyn_reloc (output_bfd, bfinfdpic_gotrel_section (info),
				 _bfd_elf_section_offset
				 (output_bfd, info,
				  bfinfdpic_got_section (info),
				  bfinfdpic_got_initial_offset (info)
				  + entry->got_entry)
				 + bfinfdpic_got_section (info)
				 ->output_section->vma
				 + bfinfdpic_got_section (info)->output_offset,
				 R_byte4_data, idx, ad, entry);

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->got_entry);
    }

  /* Generate relocation for GOT entry pointing to a canonical
     function descriptor.  */
  if (entry->fdgot_entry)
    {
      int reloc, idx;
      bfd_vma ad = 0;

      if (! (entry->symndx == -1
	     && entry->d.h->root.type == bfd_link_hash_undefweak
	     && BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
d1738 1
a1738 39
	  /* If the symbol is dynamic and there may be dynamic symbol
	     resolution because we are, or are linked with, a shared
	     library, emit a FUNCDESC relocation such that the dynamic
	     linker will allocate the function descriptor.  If the
	     symbol needs a non-local function descriptor but binds
	     locally (e.g., its visibility is protected, emit a
	     dynamic relocation decayed to section+offset.  */
	  if (entry->symndx == -1
	      && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)
	      && BFINFDPIC_SYM_LOCAL (info, entry->d.h)
	      && !(info->executable && !info->pie))
	    {
	      reloc = R_BFIN_FUNCDESC;
	      idx = elf_section_data (entry->d.h->root.u.def.section
				      ->output_section)->dynindx;
	      ad = entry->d.h->root.u.def.section->output_offset
		+ entry->d.h->root.u.def.value;
	    }
	  else if (entry->symndx == -1
		   && ! BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h))
	    {
	      reloc = R_BFIN_FUNCDESC;
	      idx = dynindx;
	      ad = addend;
	      if (ad)
		return FALSE;
	    }
	  else
	    {
	      /* Otherwise, we know we have a private function descriptor,
		 so reference it directly.  */
	      if (elf_hash_table (info)->dynamic_sections_created)
		BFD_ASSERT (entry->privfd);
	      reloc = R_byte4_data;
	      idx = elf_section_data (bfinfdpic_got_section (info)
				      ->output_section)->dynindx;
	      ad = bfinfdpic_got_section (info)->output_offset
		+ bfinfdpic_got_initial_offset (info) + entry->fd_entry;
	    }
d1740 3
a1742 40
	  /* If there is room for dynamic symbol resolution, emit the
	     dynamic relocation.  However, if we're linking an
	     executable at a fixed location, we won't have emitted a
	     dynamic symbol entry for the got section, so idx will be
	     zero, which means we can and should compute the address
	     of the private descriptor ourselves.  */
	  if (info->executable && !info->pie
	      && (entry->symndx != -1
		  || BFINFDPIC_FUNCDESC_LOCAL (info, entry->d.h)))
	    {
	      ad += bfinfdpic_got_section (info)->output_section->vma;
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fdgot_entry, entry);
	    }
	  else
	    _bfinfdpic_add_dyn_reloc (output_bfd,
				     bfinfdpic_gotrel_section (info),
				     _bfd_elf_section_offset
				     (output_bfd, info,
				      bfinfdpic_got_section (info),
				      bfinfdpic_got_initial_offset (info)
				      + entry->fdgot_entry)
				     + bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset,
				     reloc, idx, ad, entry);
	}

      bfd_put_32 (output_bfd, ad,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fdgot_entry);
    }
d1744 10
a1753 24
  /* Generate relocation to fill in a private function descriptor in
     the GOT.  */
  if (entry->fd_entry)
    {
      int idx = dynindx;
      bfd_vma ad = addend;
      bfd_vma ofst;
      long lowword, highword;

      /* If the symbol is dynamic but binds locally, use
	 section+offset.  */
      if (sec && (entry->symndx != -1
		  || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (entry->symndx == -1)
	    ad += entry->d.h->root.u.def.value;
	  else
	    ad += sym->st_value;
	  ad += sec->output_offset;
	  if (sec->output_section && elf_section_data (sec->output_section))
	    idx = elf_section_data (sec->output_section)->dynindx;
	  else
	    idx = 0;
	}
a1754 28
      /* If we're linking an executable at a fixed address, we can
	 omit the dynamic relocation as long as the symbol is local to
	 this module.  */
      if (info->executable && !info->pie
	  && (entry->symndx != -1 || BFINFDPIC_SYM_LOCAL (info, entry->d.h)))
	{
	  if (sec)
	    ad += sec->output_section->vma;
	  ofst = 0;
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    {
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry, entry);
	      _bfinfdpic_add_rofixup (output_bfd,
				     bfinfdpic_gotfixup_section (info),
				     bfinfdpic_got_section (info)
				     ->output_section->vma
				     + bfinfdpic_got_section (info)
				     ->output_offset
				     + bfinfdpic_got_initial_offset (info)
				     + entry->fd_entry + 4, entry);
d1757 4
a1760 1
      else
d1762 27
a1788 16
	  ofst
	    = _bfinfdpic_add_dyn_reloc (output_bfd,
					entry->lazyplt
					? bfinfdpic_pltrel_section (info)
					: bfinfdpic_gotrel_section (info),
					_bfd_elf_section_offset
					(output_bfd, info,
					 bfinfdpic_got_section (info),
					 bfinfdpic_got_initial_offset (info)
					 + entry->fd_entry)
					+ bfinfdpic_got_section (info)
					->output_section->vma
					+ bfinfdpic_got_section (info)
					->output_offset,
					R_BFIN_FUNCDESC_VALUE, idx, ad, entry);
	}
d1790 4
a1793 8
      /* If we've omitted the dynamic relocation, just emit the fixed
	 addresses of the symbol and of the local GOT base offset.  */
      if (info->executable && !info->pie && sec && sec->output_section)
	{
	  lowword = ad;
	  highword = bfinfdpic_got_section (info)->output_section->vma
	    + bfinfdpic_got_section (info)->output_offset
	    + bfinfdpic_got_initial_offset (info);
a1794 4
      else if (entry->lazyplt)
	{
	  if (ad)
	    return FALSE;
d1796 2
a1797 15
	  fd_lazy_rel_offset = ofst;

	  /* A function descriptor used for lazy or local resolving is
	     initialized such that its high word contains the output
	     section index in which the PLT entries are located, and
	     the low word contains the address of the lazy PLT entry
	     entry point, that must be within the memory region
	     assigned to that section.  */
	  lowword = entry->lzplt_entry + 4
	    + bfinfdpic_plt_section (info)->output_offset
	    + bfinfdpic_plt_section (info)->output_section->vma;
	  highword = _bfinfdpic_osec_to_segment
	    (output_bfd, bfinfdpic_plt_section (info)->output_section);
	}
      else
d1799 3
a1801 11
	  /* A function descriptor for a local function gets the index
	     of the section.  For a non-local function, it's
	     disregarded.  */
	  lowword = ad;
	  if (entry->symndx == -1 && entry->d.h->dynindx != -1
	      && entry->d.h->dynindx == idx)
	    highword = 0;
	  else
	    highword = _bfinfdpic_osec_to_segment
	      (output_bfd, sec->output_section);
	}
d1803 9
a1811 9
      bfd_put_32 (output_bfd, lowword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry);
      bfd_put_32 (output_bfd, highword,
		  bfinfdpic_got_section (info)->contents
		  + bfinfdpic_got_initial_offset (info)
		  + entry->fd_entry + 4);
    }
d1813 2
a1814 5
  /* Generate code for the PLT entry.  */
  if (entry->plt_entry != (bfd_vma) -1)
    {
      bfd_byte *plt_code = bfinfdpic_plt_section (info)->contents
	+ entry->plt_entry;
d1816 5
a1820 1
      BFD_ASSERT (entry->fd_entry);
d1822 3
a1824 34
      /* Figure out what kind of PLT entry we need, depending on the
	 location of the function descriptor within the GOT.  */
      if (entry->fd_entry >= -(1 << (18 - 1))
	  && entry->fd_entry + 4 < (1 << (18 - 1)))
	{
	  /* P1 = [P3 + fd_entry]; P3 = [P3 + fd_entry + 4] */
	  bfd_put_32 (output_bfd,
		      0xe519 | ((entry->fd_entry << 14) & 0xFFFF0000),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe51b | (((entry->fd_entry + 4) << 14) & 0xFFFF0000),
		      plt_code + 4);
	  plt_code += 8;
	}
      else
	{
	  /* P1.L = fd_entry; P1.H = fd_entry;
	     P3 = P3 + P1;
	     P1 = [P3];
	     P3 = [P3 + 4];  */
	  bfd_put_32 (output_bfd,
		      0xe109 | (entry->fd_entry << 16),
		      plt_code);
	  bfd_put_32 (output_bfd,
		      0xe149 | (entry->fd_entry & 0xFFFF0000),
		      plt_code + 4);
	  bfd_put_16 (output_bfd, 0x5ad9, plt_code + 8);
	  bfd_put_16 (output_bfd, 0x9159, plt_code + 10);
	  bfd_put_16 (output_bfd, 0xac5b, plt_code + 12);
	  plt_code += 14;
	}
      /* JUMP (P1) */
      bfd_put_16 (output_bfd, 0x0051, plt_code);
    }
d1826 3
a1828 14
  /* Generate code for the lazy PLT entry.  */
  if (entry->lzplt_entry != (bfd_vma) -1)
    {
      bfd_byte *lzplt_code = bfinfdpic_plt_section (info)->contents
	+ entry->lzplt_entry;
      bfd_vma resolverStub_addr;

      bfd_put_32 (output_bfd, fd_lazy_rel_offset, lzplt_code);
      lzplt_code += 4;

      resolverStub_addr = entry->lzplt_entry / BFINFDPIC_LZPLT_BLOCK_SIZE
	* BFINFDPIC_LZPLT_BLOCK_SIZE + BFINFDPIC_LZPLT_RESOLV_LOC;
      if (resolverStub_addr >= bfinfdpic_plt_initial_offset (info))
	resolverStub_addr = bfinfdpic_plt_initial_offset (info) - LZPLT_NORMAL_SIZE - LZPLT_RESOLVER_EXTRA;
d1830 2
a1831 1054
      if (entry->lzplt_entry == resolverStub_addr)
	{
	  /* This is a lazy PLT entry that includes a resolver call.
	     P2 = [P3];
	     R3 = [P3 + 4];
	     JUMP (P2);  */
	  bfd_put_32 (output_bfd,
		      0xa05b915a,
		      lzplt_code);
	  bfd_put_16 (output_bfd, 0x0052, lzplt_code + 4);
	}
      else
	{
	  /* JUMP.S  resolverStub */
	  bfd_put_16 (output_bfd,
		      0x2000
		      | (((resolverStub_addr - entry->lzplt_entry)
			  / 2) & (((bfd_vma)1 << 12) - 1)),
		      lzplt_code);
	}
    }

  return TRUE;
}


/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
bfin_check_relocs (bfd * abfd,
		   struct bfd_link_info *info,
		   asection *sec,
                   const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;
  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];

      switch (ELF32_R_TYPE (rel->r_info))
	{
       /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_BFIN_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries
           are actually used.  Record for later use during GC.  */
        case R_BFIN_GNU_VTENTRY:
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_got:
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall through.  */

	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || !bfd_set_section_flags (dynobj, srelgot,
						 (SEC_ALLOC
						  | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
		      || !bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1 && !h->forced_local)
		    {
		      if (!bfd_elf_link_record_dynamic_symbol (info, h))
			return FALSE;
		    }

		  /* Allocate space in the .got section.  */
		  sgot->size += 4;
		  /* Allocate relocation space.  */
		  srelgot->size += sizeof (Elf32_External_Rela);
		}
	      h->got.refcount++;
	    }
	  else
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->size += 4;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
		         output a R_68K_RELATIVE reloc so that the dynamic
		         linker can adjust this GOT entry.  */
		      srelgot->size += sizeof (Elf32_External_Rela);
		    }
		}
	      local_got_refcounts[r_symndx]++;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

static enum elf_reloc_type_class
elf32_bfin_reloc_type_class (const Elf_Internal_Rela * rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    default:
      return reloc_class_normal;
    }
}

/* Relocate an Blackfin ELF section.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
bfinfdpic_relocate_section (bfd * output_bfd,
			    struct bfd_link_info *info,
			    bfd * input_bfd,
			    asection * input_section,
			    bfd_byte * contents,
			    Elf_Internal_Rela * relocs,
			    Elf_Internal_Sym * local_syms,
			    asection ** local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  unsigned isec_segment, got_segment, plt_segment,
    check_segment[2];
  int silence_segment_error = !(info->shared || info->pie);

  if (info->relocatable)
    return TRUE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  isec_segment = _bfinfdpic_osec_to_segment (output_bfd,
					     input_section->output_section);
  if (IS_FDPIC (output_bfd) && bfinfdpic_got_section (info))
    got_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_got_section (info)
					      ->output_section);
  else
    got_segment = -1;
  if (IS_FDPIC (output_bfd) && elf_hash_table (info)->dynamic_sections_created)
    plt_segment = _bfinfdpic_osec_to_segment (output_bfd,
					      bfinfdpic_plt_section (info)
					      ->output_section);
  else
    plt_segment = -1;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *howto;
      unsigned long r_symndx;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      bfd_vma relocation;
      bfd_reloc_status_type r;
      const char * name = NULL;
      int r_type;
      asection *osec;
      struct bfinfdpic_relocs_info *picrel;
      bfd_vma orig_addend = rel->r_addend;

      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_type == R_BFIN_GNU_VTINHERIT
	  || r_type == R_BFIN_GNU_VTENTRY)
	continue;

      /* This is a final link.  */
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  osec = sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && ! BFINFDPIC_SYM_LOCAL (info, h))
	    {
	      sec = NULL;
	      relocation = 0;
	    }
	  else
	    if (h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	      {
		sec = h->root.u.def.section;
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	      }
	    else if (h->root.type == bfd_link_hash_undefweak)
	      {
		relocation = 0;
	      }
	    else if (info->unresolved_syms_in_objects == RM_IGNORE
		     && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	      relocation = 0;
	    else
	      {
		if (! ((*info->callbacks->undefined_symbol)
		       (info, h->root.root.string, input_bfd,
			input_section, rel->r_offset,
			(info->unresolved_syms_in_objects == RM_GENERATE_ERROR
			 || ELF_ST_VISIBILITY (h->other)))))
		  return FALSE;
		relocation = 0;
	      }
	  osec = sec;
	}

      switch (r_type)
	{
	case R_pcrel24:
	case R_pcrel24_jump_l:
	case R_byte4_data:
	  if (! IS_FDPIC (output_bfd))
	    goto non_fdpic;

	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	case R_BFIN_FUNCDESC:
	case R_BFIN_FUNCDESC_VALUE:
	  if (h != NULL)
	    picrel = bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info
						       (info), input_bfd, h,
						       orig_addend, INSERT);
	  else
	    /* In order to find the entry we created before, we must
	       use the original addend, not the one that may have been
	       modified by _bfd_elf_rela_local_sym().  */
	    picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						      (info), input_bfd, r_symndx,
						      orig_addend, INSERT);
	  if (! picrel)
	    return FALSE;

	  if (!_bfinfdpic_emit_got_relocs_plt_entries (picrel, output_bfd, info,
						       osec, sym,
						       rel->r_addend))
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"),
		 input_bfd, input_section, rel->r_offset, name);
	      return FALSE;

	    }

	  break;

	default:
	non_fdpic:
	  picrel = NULL;
	  if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
	    {
	      info->callbacks->warning
		(info, _("relocation references symbol not defined in the module"),
		 name, input_bfd, input_section, rel->r_offset);
	      return FALSE;
	    }
	  break;
	}

      switch (r_type)
	{
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  check_segment[0] = isec_segment;
	  if (! IS_FDPIC (output_bfd))
	    check_segment[1] = isec_segment;
	  else if (picrel->plt)
	    {
	      relocation = bfinfdpic_plt_section (info)->output_section->vma
		+ bfinfdpic_plt_section (info)->output_offset
		+ picrel->plt_entry;
	      check_segment[1] = plt_segment;
	    }
	  /* We don't want to warn on calls to undefined weak symbols,
	     as calls to them must be protected by non-NULL tests
	     anyway, and unprotected calls would invoke undefined
	     behavior.  */
	  else if (picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefweak)
	    check_segment[1] = check_segment[0];
	  else
	    check_segment[1] = sec
	      ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	      : (unsigned)-1;
	  break;

	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  relocation = picrel->got_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  relocation = picrel->fdgot_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFLO:
	  relocation -= bfinfdpic_got_section (info)->output_section->vma
	    + bfinfdpic_got_section (info)->output_offset
	    + bfinfdpic_got_initial_offset (info);
	  check_segment[0] = got_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;

	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation = picrel->fd_entry;
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_BFIN_FUNCDESC:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    if (! (h && h->root.type == bfd_link_hash_undefweak
		   && BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		/* If the symbol is dynamic and there may be dynamic
		   symbol resolution because we are or are linked with a
		   shared library, emit a FUNCDESC relocation such that
		   the dynamic linker will allocate the function
		   descriptor.  If the symbol needs a non-local function
		   descriptor but binds locally (e.g., its visibility is
		   protected, emit a dynamic relocation decayed to
		   section+offset.  */
		if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h)
		    && BFINFDPIC_SYM_LOCAL (info, h)
		    && !(info->executable && !info->pie))
		  {
		    dynindx = elf_section_data (h->root.u.def.section
						->output_section)->dynindx;
		    addend += h->root.u.def.section->output_offset
		      + h->root.u.def.value;
		  }
		else if (h && ! BFINFDPIC_FUNCDESC_LOCAL (info, h))
		  {
		    if (addend)
		      {
			info->callbacks->warning
			  (info, _("R_BFIN_FUNCDESC references dynamic symbol with nonzero addend"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    dynindx = h->dynindx;
		  }
		else
		  {
		    /* Otherwise, we know we have a private function
		       descriptor, so reference it directly.  */
		    BFD_ASSERT (picrel->privfd);
		    r_type = R_byte4_data;
		    dynindx = elf_section_data (bfinfdpic_got_section (info)
						->output_section)->dynindx;
		    addend = bfinfdpic_got_section (info)->output_offset
		      + bfinfdpic_got_initial_offset (info)
		      + picrel->fd_entry;
		  }

		/* If there is room for dynamic symbol resolution, emit
		   the dynamic relocation.  However, if we're linking an
		   executable at a fixed location, we won't have emitted a
		   dynamic symbol entry for the got section, so idx will
		   be zero, which means we can and should compute the
		   address of the private descriptor ourselves.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_FUNCDESC_LOCAL (info, h)))
		  {
		    addend += bfinfdpic_got_section (info)->output_section->vma;
		    if ((bfd_get_section_flags (output_bfd,
						input_section->output_section)
			 & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		      {
			if (_bfinfdpic_osec_readonly_p (output_bfd,
						       input_section
						       ->output_section))
			  {
			    info->callbacks->warning
			      (info,
			       _("cannot emit fixups in read-only section"),
			       name, input_bfd, input_section, rel->r_offset);
			    return FALSE;
			  }
			_bfinfdpic_add_rofixup (output_bfd,
					       bfinfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
		      }
		  }
		else if ((bfd_get_section_flags (output_bfd,
						 input_section->output_section)
			  & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    _bfinfdpic_add_dyn_reloc (output_bfd,
					      bfinfdpic_gotrel_section (info),
					      _bfd_elf_section_offset
					      (output_bfd, info,
					       input_section, rel->r_offset)
					      + input_section
					      ->output_section->vma
					      + input_section->output_offset,
					      r_type, dynindx, addend, picrel);
		  }
		else
		  addend += bfinfdpic_got_section (info)->output_section->vma;
	      }

	    /* We want the addend in-place because dynamic
	       relocations are REL.  Setting relocation to it should
	       arrange for it to be installed.  */
	    relocation = addend - rel->r_addend;
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	case R_byte4_data:
	  if (! IS_FDPIC (output_bfd))
	    {
	      check_segment[0] = check_segment[1] = -1;
	      break;
	    }
	  /* Fall through.  */
	case R_BFIN_FUNCDESC_VALUE:
	  {
	    int dynindx;
	    bfd_vma addend = rel->r_addend;

	    /* If the symbol is dynamic but binds locally, use
	       section+offset.  */
	    if (h && ! BFINFDPIC_SYM_LOCAL (info, h))
	      {
		if (addend && r_type == R_BFIN_FUNCDESC_VALUE)
		  {
		    info->callbacks->warning
		      (info, _("R_BFIN_FUNCDESC_VALUE references dynamic symbol with nonzero addend"),
		       name, input_bfd, input_section, rel->r_offset);
		    return FALSE;
		  }
		dynindx = h->dynindx;
	      }
	    else
	      {
		if (h)
		  addend += h->root.u.def.value;
		else
		  addend += sym->st_value;
		if (osec)
		  addend += osec->output_offset;
		if (osec && osec->output_section
		    && ! bfd_is_abs_section (osec->output_section)
		    && ! bfd_is_und_section (osec->output_section))
		  dynindx = elf_section_data (osec->output_section)->dynindx;
		else
		  dynindx = 0;
	      }

	    /* If we're linking an executable at a fixed address, we
	       can omit the dynamic relocation as long as the symbol
	       is defined in the current link unit (which is implied
	       by its output section not being NULL).  */
	    if (info->executable && !info->pie
		&& (!h || BFINFDPIC_SYM_LOCAL (info, h)))
	      {
		if (osec)
		  addend += osec->output_section->vma;
		if (IS_FDPIC (input_bfd)
		    && (bfd_get_section_flags (output_bfd,
					       input_section->output_section)
			& (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit fixups in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    if (!h || h->root.type != bfd_link_hash_undefweak)
		      {
			_bfinfdpic_add_rofixup (output_bfd,
					       bfinfdpic_gotfixup_section
					       (info),
					       _bfd_elf_section_offset
					       (output_bfd, info,
						input_section, rel->r_offset)
					       + input_section
					       ->output_section->vma
					       + input_section->output_offset,
					       picrel);
			if (r_type == R_BFIN_FUNCDESC_VALUE)
			  _bfinfdpic_add_rofixup
			    (output_bfd,
			     bfinfdpic_gotfixup_section (info),
			     _bfd_elf_section_offset
			     (output_bfd, info,
			      input_section, rel->r_offset)
			     + input_section->output_section->vma
			     + input_section->output_offset + 4, picrel);
		      }
		  }
	      }
	    else
	      {
		if ((bfd_get_section_flags (output_bfd,
					    input_section->output_section)
		     & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
		  {
		    if (_bfinfdpic_osec_readonly_p (output_bfd,
						   input_section
						   ->output_section))
		      {
			info->callbacks->warning
			  (info,
			   _("cannot emit dynamic relocations in read-only section"),
			   name, input_bfd, input_section, rel->r_offset);
			return FALSE;
		      }
		    _bfinfdpic_add_dyn_reloc (output_bfd,
					      bfinfdpic_gotrel_section (info),
					      _bfd_elf_section_offset
					      (output_bfd, info,
					       input_section, rel->r_offset)
					      + input_section
					      ->output_section->vma
					      + input_section->output_offset,
					      r_type, dynindx, addend, picrel);
		  }
		else if (osec)
		  addend += osec->output_section->vma;
		/* We want the addend in-place because dynamic
		   relocations are REL.  Setting relocation to it
		   should arrange for it to be installed.  */
		relocation = addend - rel->r_addend;
	      }

	    if (r_type == R_BFIN_FUNCDESC_VALUE)
	      {
		/* If we've omitted the dynamic relocation, just emit
		   the fixed addresses of the symbol and of the local
		   GOT base offset.  */
		if (info->executable && !info->pie
		    && (!h || BFINFDPIC_SYM_LOCAL (info, h)))
		  bfd_put_32 (output_bfd,
			      bfinfdpic_got_section (info)->output_section->vma
			      + bfinfdpic_got_section (info)->output_offset
			      + bfinfdpic_got_initial_offset (info),
			      contents + rel->r_offset + 4);
		else
		  /* A function descriptor used for lazy or local
		     resolving is initialized such that its high word
		     contains the output section index in which the
		     PLT entries are located, and the low word
		     contains the offset of the lazy PLT entry entry
		     point into that section.  */
		  bfd_put_32 (output_bfd,
			      h && ! BFINFDPIC_SYM_LOCAL (info, h)
			      ? 0
			      : _bfinfdpic_osec_to_segment (output_bfd,
							    sec
							    ->output_section),
			      contents + rel->r_offset + 4);
	      }
	  }
	  check_segment[0] = check_segment[1] = got_segment;
	  break;

	default:
	  check_segment[0] = isec_segment;
	  check_segment[1] = sec
	    ? _bfinfdpic_osec_to_segment (output_bfd, sec->output_section)
	    : (unsigned)-1;
	  break;
	}

      if (check_segment[0] != check_segment[1] && IS_FDPIC (output_bfd))
	{
#if 1 /* If you take this out, remove the #error from fdpic-static-6.d
	 in the ld testsuite.  */
	  /* This helps catch problems in GCC while we can't do more
	     than static linking.  The idea is to test whether the
	     input file basename is crt0.o only once.  */
	  if (silence_segment_error == 1)
	    silence_segment_error =
	      (strlen (input_bfd->filename) == 6
	       && strcmp (input_bfd->filename, "crt0.o") == 0)
	      || (strlen (input_bfd->filename) > 6
		  && strcmp (input_bfd->filename
			     + strlen (input_bfd->filename) - 7,
			     "/crt0.o") == 0)
	      ? -1 : 0;
#endif
	  if (!silence_segment_error
	      /* We don't want duplicate errors for undefined
		 symbols.  */
	      && !(picrel && picrel->symndx == -1
		   && picrel->d.h->root.type == bfd_link_hash_undefined))
	    info->callbacks->warning
	      (info,
	       (info->shared || info->pie)
	       ? _("relocations between different segments are not supported")
	       : _("warning: relocation references a different segment"),
	       name, input_bfd, input_section, rel->r_offset);
	  if (!silence_segment_error && (info->shared || info->pie))
	    return FALSE;
	  elf_elfheader (output_bfd)->e_flags |= EF_BFIN_PIC;
	}

      switch (r_type)
	{
	case R_BFIN_GOTOFFHI:
	  /* We need the addend to be applied before we shift the
	     value right.  */
	  relocation += rel->r_addend;
	  /* Fall through.  */
	case R_BFIN_GOTHI:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	  relocation >>= 16;
	  /* Fall through.  */

	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  relocation &= 0xffff;
	  break;

	default:
	  break;
	}

      switch (r_type)
	{
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  if (! IS_FDPIC (output_bfd) || ! picrel->plt)
	    break;
	  /* Fall through.  */

	  /* When referencing a GOT entry, a function descriptor or a
	     PLT, we don't want the addend to apply to the reference,
	     but rather to the referenced symbol.  The actual entry
	     will have already been created taking the addend into
	     account, so cancel it out here.  */
	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  /* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF17M4
	     here, since we do want to apply the addend to the others.
	     Note that we've applied the addend to GOTOFFHI before we
	     shifted it right.  */
	case R_BFIN_GOTOFFHI:
	  relocation -= rel->r_addend;
	  break;

	default:
	  break;
	}

      if (r_type == R_pcrel24
	  || r_type == R_pcrel24_jump_l)
	{
	  bfd_vma x;
	  bfd_vma address = rel->r_offset;

	  relocation += rel->r_addend;

	  /* Perform usual pc-relative correction.  */
	  relocation -= input_section->output_section->vma + input_section->output_offset;
	  relocation -= address;

	  /* We are getting reloc_entry->address 2 byte off from
	     the start of instruction. Assuming absolute postion
	     of the reloc data. But, following code had been written assuming
	     reloc address is starting at begining of instruction.
	     To compensate that I have increased the value of
	     relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

	  relocation += 2;
	  address -= 2;

	  relocation >>= 1;

	  x = bfd_get_16 (input_bfd, contents + address);
	  x = (x & 0xff00) | ((relocation >> 16) & 0xff);
	  bfd_put_16 (input_bfd, x, contents + address);

	  x = bfd_get_16 (input_bfd, contents + address + 2);
	  x = relocation & 0xFFFF;
	  bfd_put_16 (input_bfd, x, contents + address + 2);
	  r = bfd_reloc_ok;
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name,
		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

static bfd_boolean
bfin_relocate_section (bfd * output_bfd,
		       struct bfd_link_info *info,
		       bfd * input_bfd,
		       asection * input_section,
		       bfd_byte * contents,
		       Elf_Internal_Rela * relocs,
		       Elf_Internal_Sym * local_syms,
		       asection ** local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  asection *sgot;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  int i = 0;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  sgot = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++, i++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation = 0;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      bfd_vma address;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= 243)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (r_type == R_BFIN_GNU_VTENTRY
          || r_type == R_BFIN_GNU_VTINHERIT)
	continue;

      howto = bfin_reloc_type_lookup (input_bfd, r_type);
      if (howto == NULL)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      r_symndx = ELF32_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned;
	  h = NULL;
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      address = rel->r_offset;

      /* Then, process normally.  */
      switch (r_type)
	{
	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  return bfd_reloc_ok;

	case R_got:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    goto do_default;
	  /* Fall through.  */
	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */

	  {
	    bfd_vma off;

	    if (sgot == NULL)
	      {
		sgot = bfd_get_section_by_name (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
	      }

	    if (h != NULL)
	      {
		bfd_boolean dyn;

		off = h->got.offset;
		BFD_ASSERT (off != (bfd_vma) - 1);
		dyn = elf_hash_table (info)->dynamic_sections_created;

		if (!WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
d1846 20
a1865 276
		       When doing a dynamic link, we create a .rela.got
		       relocation entry to initialize the value.  This
		       is done in the finish_dynamic_symbol routine.  */
		    if ((off & 1) != 0)
		      off &= ~1;
		    else
		      {
			bfd_put_32 (output_bfd, relocation,
				    sgot->contents + off);
			h->got.offset |= 1;
		      }
		  }
		else
		  unresolved_reloc = FALSE;
	      }
	    else
	      {
		BFD_ASSERT (local_got_offsets != NULL);
		off = local_got_offsets[r_symndx];
		BFD_ASSERT (off != (bfd_vma) - 1);

		/* The offset must always be a multiple of 4.  We use
		   the least significant bit to record whether we have
		   already generated the necessary reloc.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    bfd_put_32 (output_bfd, relocation, sgot->contents + off);

		    if (info->shared)
		      {
			asection *s;
			Elf_Internal_Rela outrel;
			bfd_byte *loc;

			s = bfd_get_section_by_name (dynobj, ".rela.got");
			BFD_ASSERT (s != NULL);

			outrel.r_offset = (sgot->output_section->vma
					   + sgot->output_offset + off);
			outrel.r_info =
			  ELF32_R_INFO (0, R_pcrel24);
			outrel.r_addend = relocation;
			loc = s->contents;
			loc +=
			  s->reloc_count++ * sizeof (Elf32_External_Rela);
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }

		    local_got_offsets[r_symndx] |= 1;
		  }
	      }

	    relocation = sgot->output_offset + off;
	    rel->r_addend = 0;
            /* bfin : preg = [preg + 17bitdiv4offset] relocation is div by 4.  */
            relocation /= 4;
	  }
	  goto do_default;

	case R_pcrel24:
	case R_pcrel24_jump_l:
	  {
	    bfd_vma x;

	    relocation += rel->r_addend;

	    /* Perform usual pc-relative correction.  */
	    relocation -= input_section->output_section->vma + input_section->output_offset;
	    relocation -= address;

	    /* We are getting reloc_entry->address 2 byte off from
	       the start of instruction. Assuming absolute postion
	       of the reloc data. But, following code had been written assuming
	       reloc address is starting at begining of instruction.
	       To compensate that I have increased the value of
	       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */

	    relocation += 2;
	    address -= 2;

	    relocation >>= 1;

	    x = bfd_get_16 (input_bfd, contents + address);
	    x = (x & 0xff00) | ((relocation >> 16) & 0xff);
	    bfd_put_16 (input_bfd, x, contents + address);

	    x = bfd_get_16 (input_bfd, contents + address + 2);
	    x = relocation & 0xFFFF;
	    bfd_put_16 (input_bfd, x, contents + address + 2);
	    r = bfd_reloc_ok;
	  }
	  break;

	default:
	do_default:
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, address,
					relocation, rel->r_addend);

	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
         because such sections are not SEC_ALLOC and thus ld.so will
         not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0 && h->def_dynamic))
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	     input_bfd,
	     input_section, (long) rel->r_offset, h->root.root.string);
	  return FALSE;
	}

      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (!(info->callbacks->reloc_overflow
		    (info, (h ? &h->root : NULL), name, howto->name,
		     (bfd_vma) 0, input_bfd, input_section, rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

static asection *
bfin_gc_mark_hook (asection * sec,
		   struct bfd_link_info *info ATTRIBUTE_UNUSED,
		   Elf_Internal_Rela * rel,
		   struct elf_link_hash_entry *h,
                   Elf_Internal_Sym * sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{

	case R_BFIN_GNU_VTINHERIT:
	case R_BFIN_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}


/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
bfinfdpic_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
bfin_gc_sweep_hook (bfd * abfd,
		    struct bfd_link_info *info,
		    asection * sec,
                    const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_got:
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->size -= 4;
		      if (info->shared)
			srelgot->size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  break;
	default:
	  break;
	}
    }
  return TRUE;
}
d1867 8
a1874 685
/* We need dynamic symbols for every section, since segments can
   relocate independently.  */
static bfd_boolean
_bfinfdpic_link_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info
				    ATTRIBUTE_UNUSED,
				    asection *p ATTRIBUTE_UNUSED)
{
  switch (elf_section_data (p)->this_hdr.sh_type)
    {
    case SHT_PROGBITS:
    case SHT_NOBITS:
      /* If sh_type is yet undecided, assume it could be
	 SHT_PROGBITS/SHT_NOBITS.  */
    case SHT_NULL:
      return FALSE;

      /* There shouldn't be section relative relocations
	 against any other section.  */
    default:
      return TRUE;
    }
}

/* Create  a .got section, as well as its additional info field.  This
   is almost entirely copied from
   elflink.c:_bfd_elf_create_got_section().  */

static bfd_boolean
_bfin_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  asection *s;
  struct elf_link_hash_entry *h;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ptralign;
  int offset;

  /* This function may be called more than once.  */
  s = bfd_get_section_by_name (abfd, ".got");
  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
    return TRUE;

  /* Machine specific: although pointers are 32-bits wide, we want the
     GOT to be aligned to a 64-bit boundary, such that function
     descriptors in it can be accessed with 64-bit loads and
     stores.  */
  ptralign = 3;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  pltflags = flags;

  s = bfd_make_section_with_flags (abfd, ".got", flags);
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, ptralign))
    return FALSE;

  if (bed->want_got_plt)
    {
      s = bfd_make_section_with_flags (abfd, ".got.plt", flags);
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s, ptralign))
	return FALSE;
    }

  if (bed->want_got_sym)
    {
      /* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got
	 (or .got.plt) section.  We don't do this in the linker script
	 because we don't want to define the symbol if we are not creating
	 a global offset table.  */
      h = _bfd_elf_define_linkage_sym (abfd, info, s, "_GLOBAL_OFFSET_TABLE_");
      elf_hash_table (info)->hgot = h;
      if (h == NULL)
	return FALSE;

      /* Machine-specific: we want the symbol for executables as
	 well.  */
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* The first bit of the global offset table is the header.  */
  s->size += bed->got_header_size;

  /* This is the machine-specific part.  Create and initialize section
     data for the got.  */
  if (IS_FDPIC (abfd))
    {
      bfinfdpic_got_section (info) = s;
      bfinfdpic_relocs_info (info) = htab_try_create (1,
						      bfinfdpic_relocs_info_hash,
						      bfinfdpic_relocs_info_eq,
						      (htab_del) NULL);
      if (! bfinfdpic_relocs_info (info))
	return FALSE;

      s = bfd_make_section_with_flags (abfd, ".rel.got",
				       (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      bfinfdpic_gotrel_section (info) = s;

      /* Machine-specific.  */
      s = bfd_make_section_with_flags (abfd, ".rofixup",
				       (flags | SEC_READONLY));
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;

      bfinfdpic_gotfixup_section (info) = s;
      offset = -2048;
      flags = BSF_GLOBAL;
    }
  else
    {
      offset = 2048;
      flags = BSF_GLOBAL | BSF_WEAK;
    }

  return TRUE;
}

/* Make sure the got and plt sections exist, and that our pointers in
   the link hash table point to them.  */

static bfd_boolean
elf32_bfinfdpic_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  /* This is mostly copied from
     elflink.c:_bfd_elf_create_dynamic_sections().  */
  flagword flags, pltflags;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and
     .rel[a].bss sections.  */

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  pltflags = flags;
  pltflags |= SEC_CODE;
  if (bed->plt_not_loaded)
    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);
  if (bed->plt_readonly)
    pltflags |= SEC_READONLY;

  s = bfd_make_section (abfd, ".plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, pltflags)
      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))
    return FALSE;
  /* Blackfin-specific: remember it.  */
  bfinfdpic_plt_section (info) = s;

  if (bed->want_plt_sym)
    {
      /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the
	 .plt section.  */
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh = NULL;

      if (! (_bfd_generic_link_add_one_symbol
	     (info, abfd, "_PROCEDURE_LINKAGE_TABLE_", BSF_GLOBAL, s, 0, NULL,
	      FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return FALSE;
      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = STT_OBJECT;

      if (! info->executable
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;
    }

  /* Blackfin-specific: we want rel relocations for the plt.  */
  s = bfd_make_section (abfd, ".rel.plt");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
    return FALSE;
  /* Blackfin-specific: remember it.  */
  bfinfdpic_pltrel_section (info) = s;

  /* Blackfin-specific: we want to create the GOT in the Blackfin way.  */
  if (! _bfin_create_got_section (abfd, info))
    return FALSE;

  /* Blackfin-specific: make sure we created everything we wanted.  */
  BFD_ASSERT (bfinfdpic_got_section (info) && bfinfdpic_gotrel_section (info)
	      /* && bfinfdpic_gotfixup_section (info) */
	      && bfinfdpic_plt_section (info)
	      && bfinfdpic_pltrel_section (info));

  if (bed->want_dynbss)
    {
      /* The .dynbss section is a place to put symbols which are defined
	 by dynamic objects, are referenced by regular objects, and are
	 not functions.  We must allocate space for them in the process
	 image and use a R_*_COPY reloc to tell the dynamic linker to
	 initialize them at run time.  The linker script puts the .dynbss
	 section into the .bss section of the final image.  */
      s = bfd_make_section (abfd, ".dynbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
	return FALSE;

      /* The .rel[a].bss section holds copy relocs.  This section is not
     normally needed.  We need to create it here, though, so that the
     linker will map it to an output section.  We can't just create it
     only if we need it, because we will not know whether we need it
     until we have seen all the input files, and the first time the
     main linker code calls BFD after examining all the input files
     (size_dynamic_sections) the input sections have already been
     mapped to the output sections.  If the section turns out not to
     be needed, we can discard it later.  We will never need this
     section when generating a shared object, since they do not use
     copy relocs.  */
      if (! info->shared)
	{
	  s = bfd_make_section (abfd,
				(bed->default_use_rela_p
				 ? ".rela.bss" : ".rel.bss"));
	  if (s == NULL
	      || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
	    return FALSE;
	}
    }

  return TRUE;
}

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

#define DEFAULT_STACK_SIZE 0x20000

/* This structure is used to collect the number of entries present in
   each addressable range of the got.  */
struct _bfinfdpic_dynamic_got_info
{
  /* Several bits of information about the current link.  */
  struct bfd_link_info *info;
  /* Total size needed for GOT entries within the 18- or 32-bit
     ranges.  */
  bfd_vma got17m4, gothilo;
  /* Total size needed for function descriptor entries within the 18-
     or 32-bit ranges.  */
  bfd_vma fd17m4, fdhilo;
  /* Total size needed function descriptor entries referenced in PLT
     entries, that would be profitable to place in offsets close to
     the PIC register.  */
  bfd_vma fdplt;
  /* Total size needed by lazy PLT entries.  */
  bfd_vma lzplt;
  /* Number of relocations carried over from input object files.  */
  unsigned long relocs;
  /* Number of fixups introduced by relocations in input object files.  */
  unsigned long fixups;
};

/* Compute the total GOT size required by each symbol in each range.
   Symbols may require up to 4 words in the GOT: an entry pointing to
   the symbol, an entry pointing to its function descriptor, and a
   private function descriptors taking two words.  */

static int
_bfinfdpic_count_got_plt_entries (void **entryp, void *dinfo_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_info *dinfo = dinfo_;
  unsigned relocs = 0, fixups = 0;

  /* Allocate space for a GOT entry pointing to the symbol.  */
  if (entry->got17m4)
    dinfo->got17m4 += 4;
  else if (entry->gothilo)
    dinfo->gothilo += 4;
  else
    entry->relocs32--;
  entry->relocs32++;

  /* Allocate space for a GOT entry pointing to the function
     descriptor.  */
  if (entry->fdgot17m4)
    dinfo->got17m4 += 4;
  else if (entry->fdgothilo)
    dinfo->gothilo += 4;
  else
    entry->relocsfd--;
  entry->relocsfd++;

  /* Decide whether we need a PLT entry, a function descriptor in the
     GOT, and a lazy PLT entry for this symbol.  */
  entry->plt = entry->call
    && entry->symndx == -1 && ! BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;
  entry->privfd = entry->plt
    || entry->fdgoff17m4 || entry->fdgoffhilo
    || ((entry->fd || entry->fdgot17m4 || entry->fdgothilo)
	&& (entry->symndx != -1
	    || BFINFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h)));
  entry->lazyplt = entry->privfd
    && entry->symndx == -1 && ! BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h)
    && ! (dinfo->info->flags & DF_BIND_NOW)
    && elf_hash_table (dinfo->info)->dynamic_sections_created;

  /* Allocate space for a function descriptor.  */
  if (entry->fdgoff17m4)
    dinfo->fd17m4 += 8;
  else if (entry->privfd && entry->plt)
    dinfo->fdplt += 8;
  else if (entry->privfd)
    dinfo->fdhilo += 8;
  else
    entry->relocsfdv--;
  entry->relocsfdv++;

  if (entry->lazyplt)
    dinfo->lzplt += LZPLT_NORMAL_SIZE;

  if (!dinfo->info->executable || dinfo->info->pie)
    relocs = entry->relocs32 + entry->relocsfd + entry->relocsfdv;
  else
    {
      if (entry->symndx != -1 || BFINFDPIC_SYM_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocs32 + 2 * entry->relocsfdv;
	}
      else
	relocs += entry->relocs32 + entry->relocsfdv;

      if (entry->symndx != -1
	  || BFINFDPIC_FUNCDESC_LOCAL (dinfo->info, entry->d.h))
	{
	  if (entry->symndx != -1
	      || entry->d.h->root.type != bfd_link_hash_undefweak)
	    fixups += entry->relocsfd;
	}
      else
	relocs += entry->relocsfd;
    }

  entry->dynrelocs += relocs;
  entry->fixups += fixups;
  dinfo->relocs += relocs;
  dinfo->fixups += fixups;

  return 1;
}

/* This structure is used to assign offsets to got entries, function
   descriptors, plt entries and lazy plt entries.  */

struct _bfinfdpic_dynamic_got_plt_info
{
  /* Summary information collected with _bfinfdpic_count_got_plt_entries.  */
  struct _bfinfdpic_dynamic_got_info g;

  /* For each addressable range, we record a MAX (positive) and MIN
     (negative) value.  CUR is used to assign got entries, and it's
     incremented from an initial positive value to MAX, then from MIN
     to FDCUR (unless FDCUR wraps around first).  FDCUR is used to
     assign function descriptors, and it's decreased from an initial
     non-positive value to MIN, then from MAX down to CUR (unless CUR
     wraps around first).  All of MIN, MAX, CUR and FDCUR always point
     to even words.  ODD, if non-zero, indicates an odd word to be
     used for the next got entry, otherwise CUR is used and
     incremented by a pair of words, wrapping around when it reaches
     MAX.  FDCUR is decremented (and wrapped) before the next function
     descriptor is chosen.  FDPLT indicates the number of remaining
     slots that can be used for function descriptors used only by PLT
     entries.  */
  struct _bfinfdpic_dynamic_got_alloc_data
  {
    bfd_signed_vma max, cur, odd, fdcur, min;
    bfd_vma fdplt;
  } got17m4, gothilo;
};

/* Determine the positive and negative ranges to be used by each
   offset range in the GOT.  FDCUR and CUR, that must be aligned to a
   double-word boundary, are the minimum (negative) and maximum
   (positive) GOT offsets already used by previous ranges, except for
   an ODD entry that may have been left behind.  GOT and FD indicate
   the size of GOT entries and function descriptors that must be
   placed within the range from -WRAP to WRAP.  If there's room left,
   up to FDPLT bytes should be reserved for additional function
   descriptors.  */

inline static bfd_signed_vma
_bfinfdpic_compute_got_alloc_data (struct _bfinfdpic_dynamic_got_alloc_data *gad,
				   bfd_signed_vma fdcur,
				   bfd_signed_vma odd,
				   bfd_signed_vma cur,
				   bfd_vma got,
				   bfd_vma fd,
				   bfd_vma fdplt,
				   bfd_vma wrap)
{
  bfd_signed_vma wrapmin = -wrap;

  /* Start at the given initial points.  */
  gad->fdcur = fdcur;
  gad->cur = cur;

  /* If we had an incoming odd word and we have any got entries that
     are going to use it, consume it, otherwise leave gad->odd at
     zero.  We might force gad->odd to zero and return the incoming
     odd such that it is used by the next range, but then GOT entries
     might appear to be out of order and we wouldn't be able to
     shorten the GOT by one word if it turns out to end with an
     unpaired GOT entry.  */
  if (odd && got)
    {
      gad->odd = odd;
      got -= 4;
      odd = 0;
    }
  else
    gad->odd = 0;

  /* If we're left with an unpaired GOT entry, compute its location
     such that we can return it.  Otherwise, if got doesn't require an
     odd number of words here, either odd was already zero in the
     block above, or it was set to zero because got was non-zero, or
     got was already zero.  In the latter case, we want the value of
     odd to carry over to the return statement, so we don't want to
     reset odd unless the condition below is true.  */
  if (got & 4)
    {
      odd = cur + got;
      got += 4;
    }

  /* Compute the tentative boundaries of this range.  */
  gad->max = cur + got;
  gad->min = fdcur - fd;
  gad->fdplt = 0;

  /* If function descriptors took too much space, wrap some of them
     around.  */
  if (gad->min < wrapmin)
    {
      gad->max += wrapmin - gad->min;
      gad->min = wrapmin;
    }
  /* If there is space left and we have function descriptors
     referenced in PLT entries that could take advantage of shorter
     offsets, place them here.  */
  else if (fdplt && gad->min > wrapmin)
    {
      bfd_vma fds;
      if ((bfd_vma) (gad->min - wrapmin) < fdplt)
	fds = gad->min - wrapmin;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->min -= fds;
      gad->fdplt += fds;
    }

  /* If GOT entries took too much space, wrap some of them around.
     This may well cause gad->min to become lower than wrapmin.  This
     will cause a relocation overflow later on, so we don't have to
     report it here . */
  if ((bfd_vma) gad->max > wrap)
    {
      gad->min -= gad->max - wrap;
      gad->max = wrap;
    }
  /* If there is more space left, try to place some more function
     descriptors for PLT entries.  */
  else if (fdplt && (bfd_vma) gad->max < wrap)
    {
      bfd_vma fds;
      if ((bfd_vma) (wrap - gad->max) < fdplt)
	fds = wrap - gad->max;
      else
	fds = fdplt;

      fdplt -= fds;
      gad->max += fds;
      gad->fdplt += fds;
    }

  /* If odd was initially computed as an offset past the wrap point,
     wrap it around.  */
  if (odd > gad->max)
    odd = gad->min + odd - gad->max;

  /* _bfinfdpic_get_got_entry() below will always wrap gad->cur if needed
     before returning, so do it here too.  This guarantees that,
     should cur and fdcur meet at the wrap point, they'll both be
     equal to min.  */
  if (gad->cur == gad->max)
    gad->cur = gad->min;

  return odd;
}

/* Compute the location of the next GOT entry, given the allocation
   data for a range.  */

inline static bfd_signed_vma
_bfinfdpic_get_got_entry (struct _bfinfdpic_dynamic_got_alloc_data *gad)
{
  bfd_signed_vma ret;

  if (gad->odd)
    {
      /* If there was an odd word left behind, use it.  */
      ret = gad->odd;
      gad->odd = 0;
    }
  else
    {
      /* Otherwise, use the word pointed to by cur, reserve the next
	 as an odd word, and skip to the next pair of words, possibly
	 wrapping around.  */
      ret = gad->cur;
      gad->odd = gad->cur + 4;
      gad->cur += 8;
      if (gad->cur == gad->max)
	gad->cur = gad->min;
    }

  return ret;
}

/* Compute the location of the next function descriptor entry in the
   GOT, given the allocation data for a range.  */

inline static bfd_signed_vma
_bfinfdpic_get_fd_entry (struct _bfinfdpic_dynamic_got_alloc_data *gad)
{
  /* If we're at the bottom, wrap around, and only then allocate the
     next pair of words.  */
  if (gad->fdcur == gad->min)
    gad->fdcur = gad->max;
  return gad->fdcur -= 8;
}

/* Assign GOT offsets for every GOT entry and function descriptor.
   Doing everything in a single pass is tricky.  */

static int
_bfinfdpic_assign_got_entries (void **entryp, void *info_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_plt_info *dinfo = info_;

  if (entry->got17m4)
    entry->got_entry = _bfinfdpic_get_got_entry (&dinfo->got17m4);
  else if (entry->gothilo)
    entry->got_entry = _bfinfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgot17m4)
    entry->fdgot_entry = _bfinfdpic_get_got_entry (&dinfo->got17m4);
  else if (entry->fdgothilo)
    entry->fdgot_entry = _bfinfdpic_get_got_entry (&dinfo->gothilo);

  if (entry->fdgoff17m4)
    entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
  else if (entry->plt && dinfo->got17m4.fdplt)
    {
      dinfo->got17m4.fdplt -= 8;
      entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
    }
  else if (entry->plt)
    {
      dinfo->gothilo.fdplt -= 8;
      entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);
    }
  else if (entry->privfd)
    entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);

  return 1;
}

/* Assign GOT offsets to private function descriptors used by PLT
   entries (or referenced by 32-bit offsets), as well as PLT entries
   and lazy PLT entries.  */

static int
_bfinfdpic_assign_plt_entries (void **entryp, void *info_)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  struct _bfinfdpic_dynamic_got_plt_info *dinfo = info_;

  /* If this symbol requires a local function descriptor, allocate
     one.  */
  if (entry->privfd && entry->fd_entry == 0)
    {
      if (dinfo->got17m4.fdplt)
	{
	  entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->got17m4);
	  dinfo->got17m4.fdplt -= 8;
	}
      else
	{
	  BFD_ASSERT (dinfo->gothilo.fdplt);
	  entry->fd_entry = _bfinfdpic_get_fd_entry (&dinfo->gothilo);
	  dinfo->gothilo.fdplt -= 8;
	}
    }

  if (entry->plt)
    {
      int size;

      /* We use the section's raw size to mark the location of the
	 next PLT entry.  */
      entry->plt_entry = bfinfdpic_plt_section (dinfo->g.info)->size;

      /* Figure out the length of this PLT entry based on the
	 addressing mode we need to reach the function descriptor.  */
      BFD_ASSERT (entry->fd_entry);
      if (entry->fd_entry >= -(1 << (18 - 1))
	  && entry->fd_entry + 4 < (1 << (18 - 1)))
	size = 10;
      else
	size = 16;

      bfinfdpic_plt_section (dinfo->g.info)->size += size;
    }

  if (entry->lazyplt)
    {
      entry->lzplt_entry = dinfo->g.lzplt;
      dinfo->g.lzplt += LZPLT_NORMAL_SIZE;
      /* If this entry is the one that gets the resolver stub, account
	 for the additional instruction.  */
      if (entry->lzplt_entry % BFINFDPIC_LZPLT_BLOCK_SIZE
	  == BFINFDPIC_LZPLT_RESOLV_LOC)
	dinfo->g.lzplt += LZPLT_RESOLVER_EXTRA;
    }

  return 1;
}

/* Follow indirect and warning hash entries so that each got entry
   points to the final symbol definition.  P must point to a pointer
   to the hash table we're traversing.  Since this traversal may
   modify the hash table, we set this pointer to NULL to indicate
   we've made a potentially-destructive change to the hash table, so
   the traversal must be restarted.  */
static int
_bfinfdpic_resolve_final_relocs_info (void **entryp, void *p)
{
  struct bfinfdpic_relocs_info *entry = *entryp;
  htab_t *htab = p;

  if (entry->symndx == -1)
    {
      struct elf_link_hash_entry *h = entry->d.h;
      struct bfinfdpic_relocs_info *oentry;

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *)h->root.u.i.link;

      if (entry->d.h == h)
	return 1;

      oentry = bfinfdpic_relocs_info_for_global (*htab, 0, h, entry->addend,
						NO_INSERT);

      if (oentry)
	{
	  /* Merge the two entries.  */
	  bfinfdpic_pic_merge_early_relocs_info (oentry, entry);
	  htab_clear_slot (*htab, entryp);
	  return 1;
	}
d1876 5
a1880 1
      entry->d.h = h;
d1882 2
a1883 15
      /* If we can't find this entry with the new bfd hash, re-insert
	 it, and get the traversal restarted.  */
      if (! htab_find (*htab, entry))
	{
	  htab_clear_slot (*htab, entryp);
	  entryp = htab_find_slot (*htab, entry, INSERT);
	  if (! *entryp)
	    *entryp = entry;
	  /* Abort the traversal, since the whole table may have
	     moved, and leave it up to the parent to restart the
	     process.  */
	  *(htab_t *)p = NULL;
	  return 0;
	}
    }
d1885 10
a1894 2
  return 1;
}
d1896 3
a1898 1
/* Set the sizes of the dynamic sections.  */
d1900 6
a1905 9
static bfd_boolean
elf32_bfinfdpic_size_dynamic_sections (bfd *output_bfd,
				      struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  struct _bfinfdpic_dynamic_got_plt_info gpinfo;
  bfd_signed_vma odd;
  bfd_vma limit;
d1907 4
a1910 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d1912 1
a1912 11
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
	}
    }
d1914 3
a1916 2
  memset (&gpinfo, 0, sizeof (gpinfo));
  gpinfo.g.info = info;
d1918 6
a1923 3
  for (;;)
    {
      htab_t relocs = bfinfdpic_relocs_info (info);
d1925 2
a1926 1
      htab_traverse (relocs, _bfinfdpic_resolve_final_relocs_info, &relocs);
d1928 1
a1928 3
      if (relocs == bfinfdpic_relocs_info (info))
	break;
    }
d1930 3
a1932 2
  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_count_got_plt_entries,
		 &gpinfo.g);
d1934 6
a1939 56
  odd = 12;
  /* Compute the total size taken by entries in the 18-bit range,
     to tell how many PLT function descriptors we can bring into it
     without causing it to overflow.  */
  limit = odd + gpinfo.g.got17m4 + gpinfo.g.fd17m4;
  if (limit < (bfd_vma)1 << 18)
    limit = ((bfd_vma)1 << 18) - limit;
  else
    limit = 0;
  if (gpinfo.g.fdplt < limit)
    limit = gpinfo.g.fdplt;

  /* Determine the ranges of GOT offsets that we can use for each
     range of addressing modes.  */
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfo.got17m4,
					  0,
					  odd,
					  16,
					  gpinfo.g.got17m4,
					  gpinfo.g.fd17m4,
					  limit,
					  (bfd_vma)1 << (18-1));
  odd = _bfinfdpic_compute_got_alloc_data (&gpinfo.gothilo,
					  gpinfo.got17m4.min,
					  odd,
					  gpinfo.got17m4.max,
					  gpinfo.g.gothilo,
					  gpinfo.g.fdhilo,
					  gpinfo.g.fdplt - gpinfo.got17m4.fdplt,
					  (bfd_vma)1 << (32-1));

  /* Now assign (most) GOT offsets.  */
  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_assign_got_entries,
		 &gpinfo);

  bfinfdpic_got_section (info)->size = gpinfo.gothilo.max
    - gpinfo.gothilo.min
    /* If an odd word is the last word of the GOT, we don't need this
       word to be part of the GOT.  */
    - (odd + 4 == gpinfo.gothilo.max ? 4 : 0);
  if (bfinfdpic_got_section (info)->size == 0)
    bfinfdpic_got_section (info)->flags |= SEC_EXCLUDE;
  else if (bfinfdpic_got_section (info)->size == 12
	   && ! elf_hash_table (info)->dynamic_sections_created)
    {
      bfinfdpic_got_section (info)->flags |= SEC_EXCLUDE;
      bfinfdpic_got_section (info)->size = 0;
    }
  else
    {
      bfinfdpic_got_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_got_section (info)->size);
      if (bfinfdpic_got_section (info)->contents == NULL)
	return FALSE;
    }
d1941 5
a1945 18
  if (elf_hash_table (info)->dynamic_sections_created)
    /* Subtract the number of lzplt entries, since those will generate
       relocations in the pltrel section.  */
    bfinfdpic_gotrel_section (info)->size =
      (gpinfo.g.relocs - gpinfo.g.lzplt / LZPLT_NORMAL_SIZE)
      * get_elf_backend_data (output_bfd)->s->sizeof_rel;
  else
    BFD_ASSERT (gpinfo.g.relocs == 0);
  if (bfinfdpic_gotrel_section (info)->size == 0)
    bfinfdpic_gotrel_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_gotrel_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_gotrel_section (info)->size);
      if (bfinfdpic_gotrel_section (info)->contents == NULL)
	return FALSE;
    }
d1947 1
a1947 25
  bfinfdpic_gotfixup_section (info)->size = (gpinfo.g.fixups + 1) * 4;
  if (bfinfdpic_gotfixup_section (info)->size == 0)
    bfinfdpic_gotfixup_section (info)->flags |= SEC_EXCLUDE;
  else
    {
      bfinfdpic_gotfixup_section (info)->contents =
	(bfd_byte *) bfd_zalloc (dynobj,
				 bfinfdpic_gotfixup_section (info)->size);
      if (bfinfdpic_gotfixup_section (info)->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfinfdpic_pltrel_section (info)->size =
	gpinfo.g.lzplt / LZPLT_NORMAL_SIZE * get_elf_backend_data (output_bfd)->s->sizeof_rel;
      if (bfinfdpic_pltrel_section (info)->size == 0)
	bfinfdpic_pltrel_section (info)->flags |= SEC_EXCLUDE;
      else
	{
	  bfinfdpic_pltrel_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     bfinfdpic_pltrel_section (info)->size);
	  if (bfinfdpic_pltrel_section (info)->contents == NULL)
	    return FALSE;
a1948 1
    }
d1950 6
a1955 39
  /* Add 4 bytes for every block of at most 65535 lazy PLT entries,
     such that there's room for the additional instruction needed to
     call the resolver.  Since _bfinfdpic_assign_got_entries didn't
     account for them, our block size is 4 bytes smaller than the real
     block size.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfinfdpic_plt_section (info)->size = gpinfo.g.lzplt
	+ ((gpinfo.g.lzplt + (BFINFDPIC_LZPLT_BLOCK_SIZE - 4) - LZPLT_NORMAL_SIZE)
	   / (BFINFDPIC_LZPLT_BLOCK_SIZE - 4) * LZPLT_RESOLVER_EXTRA);
    }

  /* Reset it, such that _bfinfdpic_assign_plt_entries() can use it to
     actually assign lazy PLT entries addresses.  */
  gpinfo.g.lzplt = 0;

  /* Save information that we're going to need to generate GOT and PLT
     entries.  */
  bfinfdpic_got_initial_offset (info) = -gpinfo.gothilo.min;

  if (get_elf_backend_data (output_bfd)->want_got_sym)
    elf_hash_table (info)->hgot->root.u.def.value
      += bfinfdpic_got_initial_offset (info);

  if (elf_hash_table (info)->dynamic_sections_created)
    bfinfdpic_plt_initial_offset (info) =
      bfinfdpic_plt_section (info)->size;

  htab_traverse (bfinfdpic_relocs_info (info), _bfinfdpic_assign_plt_entries,
		 &gpinfo);

  /* Allocate the PLT section contents only after
     _bfinfdpic_assign_plt_entries has a chance to add the size of the
     non-lazy PLT entries.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (bfinfdpic_plt_section (info)->size == 0)
	bfinfdpic_plt_section (info)->flags |= SEC_EXCLUDE;
      else
d1957 4
a1960 25
	  bfinfdpic_plt_section (info)->contents =
	    (bfd_byte *) bfd_zalloc (dynobj,
				     bfinfdpic_plt_section (info)->size);
	  if (bfinfdpic_plt_section (info)->contents == NULL)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      if (bfinfdpic_got_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTGOT, 0))
	  return FALSE;

      if (bfinfdpic_pltrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_PLTREL, DT_REL)
	    || !_bfd_elf_add_dynamic_entry (info, DT_JMPREL, 0))
	  return FALSE;

      if (bfinfdpic_gotrel_section (info)->size)
	if (!_bfd_elf_add_dynamic_entry (info, DT_REL, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELSZ, 0)
	    || !_bfd_elf_add_dynamic_entry (info, DT_RELENT,
					    sizeof (Elf32_External_Rel)))
a1961 37
    }

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_always_size_sections (bfd *output_bfd,
				     struct bfd_link_info *info)
{
  if (!info->relocatable)
    {
      struct elf_link_hash_entry *h;
      asection *sec;

      /* Force a PT_GNU_STACK segment to be created.  */
      if (! elf_tdata (output_bfd)->stack_flags)
	elf_tdata (output_bfd)->stack_flags = PF_R | PF_W | PF_X;

      /* Define __stacksize if it's not defined yet.  */
      h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				FALSE, FALSE, FALSE);
      if (! h || h->root.type != bfd_link_hash_defined
	  || h->type != STT_OBJECT
	  || !h->def_regular)
	{
	  struct bfd_link_hash_entry *bh = NULL;

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "__stacksize",
		 BSF_GLOBAL, bfd_abs_section_ptr, DEFAULT_STACK_SIZE,
		 (const char *) NULL, FALSE,
		 get_elf_backend_data (output_bfd)->collect, &bh)))
	    return FALSE;

	  h = (struct elf_link_hash_entry *) bh;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;
d1964 1
a1964 32
      /* Create a stack section, and set its alignment.  */
      sec = bfd_make_section (output_bfd, ".stack");

      if (sec == NULL
	  || ! bfd_set_section_alignment (output_bfd, sec, 3))
	return FALSE;
    }

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_modify_segment_map (bfd *output_bfd,
				   struct bfd_link_info *info)
{
  struct elf_segment_map *m;

  /* objcopy and strip preserve what's already there using
     elf32_bfinfdpic_copy_private_bfd_data ().  */
  if (! info)
    return TRUE;

  for (m = elf_tdata (output_bfd)->segment_map; m != NULL; m = m->next)
    if (m->p_type == PT_GNU_STACK)
      break;

  if (m)
    {
      asection *sec = bfd_get_section_by_name (output_bfd, ".stack");
      struct elf_link_hash_entry *h;

      if (sec)
d1966 1
a1966 7
	  /* Obtain the pointer to the __stacksize symbol.  */
	  h = elf_link_hash_lookup (elf_hash_table (info), "__stacksize",
				    FALSE, FALSE, FALSE);
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *)h->root.u.i.link;
	  BFD_ASSERT (h->root.type == bfd_link_hash_defined);
d1968 2
a1969 4
	  /* Set the section size from the symbol value.  We
	     intentionally ignore the symbol section.  */
	  if (h->root.type == bfd_link_hash_defined)
	    sec->size = h->root.u.def.value;
d1971 9
a1979 1
	    sec->size = DEFAULT_STACK_SIZE;
d1981 8
a1988 38
	  /* Add the stack section to the PT_GNU_STACK segment,
	     such that its size and alignment requirements make it
	     to the segment.  */
	  m->sections[m->count] = sec;
	  m->count++;
	}
    }

  return TRUE;
}

static bfd_boolean
elf32_bfinfdpic_finish_dynamic_sections (bfd *output_bfd,
					struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  if (bfinfdpic_got_section (info))
    {
      BFD_ASSERT (bfinfdpic_gotrel_section (info)->size
		  == (bfinfdpic_gotrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));

      if (bfinfdpic_gotfixup_section (info))
	{
	  struct elf_link_hash_entry *hgot = elf_hash_table (info)->hgot;
	  bfd_vma got_value = hgot->root.u.def.value
	    + hgot->root.u.def.section->output_section->vma
	    + hgot->root.u.def.section->output_offset;

	  _bfinfdpic_add_rofixup (output_bfd, bfinfdpic_gotfixup_section (info),
				 got_value, 0);

	  if (bfinfdpic_gotfixup_section (info)->size
	      != (bfinfdpic_gotfixup_section (info)->reloc_count * 4))
d1991 3
a1993 1
		("LINKER BUG: .rofixup section size mismatch");
a1997 84
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      BFD_ASSERT (bfinfdpic_pltrel_section (info)->size
		  == (bfinfdpic_pltrel_section (info)->reloc_count
		      * sizeof (Elf32_External_Rel)));
    }

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf32_External_Dyn * dyncon;
      Elf32_External_Dyn * dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);

      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = bfinfdpic_got_section (info)->output_section->vma
		+ bfinfdpic_got_section (info)->output_offset
		+ bfinfdpic_got_initial_offset (info);
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = bfinfdpic_pltrel_section (info)
		->output_section->vma
		+ bfinfdpic_pltrel_section (info)->output_offset;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = bfinfdpic_pltrel_section (info)->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */

static bfd_boolean
elf32_bfinfdpic_adjust_dynamic_symbol
(struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED)
{
  bfd * dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
    }
d2002 6
a2007 8
/* Perform any actions needed for dynamic symbols.  */

static bfd_boolean
elf32_bfinfdpic_finish_dynamic_symbol
(bfd *output_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 struct elf_link_hash_entry *h ATTRIBUTE_UNUSED,
 Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
d2009 4
a2012 2
  return TRUE;
}
d2014 3
a2016 2
/* Decide whether to attempt to turn absptr or lsda encodings in
   shared libraries into pcrel within the given input section.  */
d2018 5
a2022 9
static bfd_boolean
bfinfdpic_elf_use_relative_eh_frame
(bfd *input_bfd ATTRIBUTE_UNUSED,
 struct bfd_link_info *info ATTRIBUTE_UNUSED,
 asection *eh_frame_section ATTRIBUTE_UNUSED)
{
  /* We can't use PC-relative encodings in FDPIC binaries, in general.  */
  return FALSE;
}
d2024 3
a2026 1
/* Adjust the contents of an eh_frame_hdr section before they're output.  */
d2028 7
a2034 8
static bfd_byte
bfinfdpic_elf_encode_eh_address (bfd *abfd,
				struct bfd_link_info *info,
				asection *osec, bfd_vma offset,
				asection *loc_sec, bfd_vma loc_offset,
				bfd_vma *encoded)
{
  struct elf_link_hash_entry *h;
d2036 1
a2036 18
  h = elf_hash_table (info)->hgot;
  BFD_ASSERT (h && h->root.type == bfd_link_hash_defined);

  if (! h || (_bfinfdpic_osec_to_segment (abfd, osec)
	      == _bfinfdpic_osec_to_segment (abfd, loc_sec->output_section)))
    return _bfd_elf_encode_eh_address (abfd, info, osec, offset,
				       loc_sec, loc_offset, encoded);

  BFD_ASSERT (_bfinfdpic_osec_to_segment (abfd, osec)
	      == (_bfinfdpic_osec_to_segment
		  (abfd, h->root.u.def.section->output_section)));

  *encoded = osec->vma + offset
    - (h->root.u.def.value
       + h->root.u.def.section->output_section->vma
       + h->root.u.def.section->output_offset);

  return DW_EH_PE_datarel | DW_EH_PE_sdata4;
d2040 1
a2040 104

/* Look through the relocs for a section during the first phase.

   Besides handling virtual table relocs for gc, we have to deal with
   all sorts of PIC-related relocations.  We describe below the
   general plan on how to handle such relocations, even though we only
   collect information at this point, storing them in hash tables for
   perusal of later passes.

   32 relocations are propagated to the linker output when creating
   position-independent output.  LO16 and HI16 relocations are not
   supposed to be encountered in this case.

   LABEL16 should always be resolvable by the linker, since it's only
   used by branches.

   LABEL24, on the other hand, is used by calls.  If it turns out that
   the target of a call is a dynamic symbol, a PLT entry must be
   created for it, which triggers the creation of a private function
   descriptor and, unless lazy binding is disabled, a lazy PLT entry.

   GPREL relocations require the referenced symbol to be in the same
   segment as _gp, but this can only be checked later.

   All GOT, GOTOFF and FUNCDESC relocations require a .got section to
   exist.  LABEL24 might as well, since it may require a PLT entry,
   that will require a got.

   Non-FUNCDESC GOT relocations require a GOT entry to be created
   regardless of whether the symbol is dynamic.  However, since a
   global symbol that turns out to not be exported may have the same
   address of a non-dynamic symbol, we don't assign GOT entries at
   this point, such that we can share them in this case.  A relocation
   for the GOT entry always has to be created, be it to offset a
   private symbol by the section load address, be it to get the symbol
   resolved dynamically.

   FUNCDESC GOT relocations require a GOT entry to be created, and
   handled as if a FUNCDESC relocation was applied to the GOT entry in
   an object file.

   FUNCDESC relocations referencing a symbol that turns out to NOT be
   dynamic cause a private function descriptor to be created.  The
   FUNCDESC relocation then decays to a 32 relocation that points at
   the private descriptor.  If the symbol is dynamic, the FUNCDESC
   relocation is propagated to the linker output, such that the
   dynamic linker creates the canonical descriptor, pointing to the
   dynamically-resolved definition of the function.

   Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic
   symbols that are assigned to the same segment as the GOT, but we
   can only check this later, after we know the complete set of
   symbols defined and/or exported.

   FUNCDESC GOTOFF relocations require a function descriptor to be
   created and, unless lazy binding is disabled or the symbol is not
   dynamic, a lazy PLT entry.  Since we can't tell at this point
   whether a symbol is going to be dynamic, we have to decide later
   whether to create a lazy PLT entry or bind the descriptor directly
   to the private function.

   FUNCDESC_VALUE relocations are not supposed to be present in object
   files, but they may very well be simply propagated to the linker
   output, since they have no side effect.


   A function descriptor always requires a FUNCDESC_VALUE relocation.
   Whether it's in .plt.rel or not depends on whether lazy binding is
   enabled and on whether the referenced symbol is dynamic.

   The existence of a lazy PLT requires the resolverStub lazy PLT
   entry to be present.


   As for assignment of GOT, PLT and lazy PLT entries, and private
   descriptors, we might do them all sequentially, but we can do
   better than that.  For example, we can place GOT entries and
   private function descriptors referenced using 12-bit operands
   closer to the PIC register value, such that these relocations don't
   overflow.  Those that are only referenced with LO16 relocations
   could come next, but we may as well place PLT-required function
   descriptors in the 12-bit range to make them shorter.  Symbols
   referenced with LO16/HI16 may come next, but we may place
   additional function descriptors in the 16-bit range if we can
   reliably tell that we've already placed entries that are ever
   referenced with only LO16.  PLT entries are therefore generated as
   small as possible, while not introducing relocation overflows in
   GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be
   generated before or after PLT entries, but not intermingled with
   them, such that we can have more lazy PLT entries in range for a
   branch to the resolverStub.  The resolverStub should be emitted at
   the most distant location from the first lazy PLT entry such that
   it's still in range for a branch, or closer, if there isn't a need
   for so many lazy PLT entries.  Additional lazy PLT entries may be
   emitted after the resolverStub, as long as branches are still in
   range.  If the branch goes out of range, longer lazy PLT entries
   are emitted.

   We could further optimize PLT and lazy PLT entries by giving them
   priority in assignment to closer-to-gr17 locations depending on the
   number of occurrences of references to them (assuming a function
   that's called more often is more important for performance, so its
   PLT entry should be faster), or taking hints from the compiler.
   Given infinite time and money... :-)  */
d2043 4
a2046 2
bfinfdpic_check_relocs (bfd *abfd, struct bfd_link_info *info,
			asection *sec, const Elf_Internal_Rela *relocs)
d2049 3
a2051 3
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
d2053 2
a2054 1
  struct bfinfdpic_relocs_info *picrel;
d2056 2
a2057 1
  if (info->relocatable)
d2062 4
a2065 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
d2067 2
a2068 3
  dynobj = elf_hash_table (info)->dynobj;
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
d2070 1
a2071 7
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d2075 3
a2077 21
	case R_BFIN_GOT17M4:
	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	case R_BFIN_FUNCDESC_GOT17M4:
	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	case R_BFIN_FUNCDESC_GOTOFF17M4:
	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	case R_BFIN_FUNCDESC:
	case R_BFIN_FUNCDESC_VALUE:
	  if (! IS_FDPIC (abfd))
	    goto bad_reloc;
	  /* Fall through.  */
	case R_pcrel24:
	case R_pcrel24_jump_l:
	case R_byte4_data:
	  if (IS_FDPIC (abfd) && ! dynobj)
d2079 11
a2089 3
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfin_create_got_section (abfd, info))
		return FALSE;
d2091 1
a2091 1
	  if (! IS_FDPIC (abfd))
d2093 11
a2103 2
	      picrel = NULL;
	      break;
a2104 23
	  if (h != NULL)
	    {
	      if (h->dynindx == -1)
		switch (ELF_ST_VISIBILITY (h->other))
		  {
		  case STV_INTERNAL:
		  case STV_HIDDEN:
		    break;
		  default:
		    bfd_elf_link_record_dynamic_symbol (info, h);
		    break;
		  }
	      picrel
		= bfinfdpic_relocs_info_for_global (bfinfdpic_relocs_info (info),
						   abfd, h,
						   rel->r_addend, INSERT);
	    }
	  else
	    picrel = bfinfdpic_relocs_info_for_local (bfinfdpic_relocs_info
						     (info), abfd, r_symndx,
						     rel->r_addend, INSERT);
	  if (! picrel)
	    return FALSE;
a2105 1

a2106 1
	  picrel = NULL;
a2108 89

      switch (ELF32_R_TYPE (rel->r_info))
        {
	case R_pcrel24:
	case R_pcrel24_jump_l:
	  if (IS_FDPIC (abfd))
	    picrel->call = 1;
	  break;

	case R_BFIN_FUNCDESC_VALUE:
	  picrel->relocsfdv++;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32--;
	  /* Fall through.  */

	case R_byte4_data:
	  if (! IS_FDPIC (abfd))
	    break;

	  picrel->sym = 1;
	  if (bfd_get_section_flags (abfd, sec) & SEC_ALLOC)
	    picrel->relocs32++;
	  break;

	case R_BFIN_GOT17M4:
	  picrel->got17m4 = 1;
	  break;

	case R_BFIN_GOTHI:
	case R_BFIN_GOTLO:
	  picrel->gothilo = 1;
	  break;

	case R_BFIN_FUNCDESC_GOT17M4:
	  picrel->fdgot17m4 = 1;
	  break;

	case R_BFIN_FUNCDESC_GOTHI:
	case R_BFIN_FUNCDESC_GOTLO:
	  picrel->fdgothilo = 1;
	  break;

	case R_BFIN_GOTOFF17M4:
	case R_BFIN_GOTOFFHI:
	case R_BFIN_GOTOFFLO:
	  picrel->gotoff = 1;
	  break;

	case R_BFIN_FUNCDESC_GOTOFF17M4:
	  picrel->fdgoff17m4 = 1;
	  break;

	case R_BFIN_FUNCDESC_GOTOFFHI:
	case R_BFIN_FUNCDESC_GOTOFFLO:
	  picrel->fdgoffhilo = 1;
	  break;

	case R_BFIN_FUNCDESC:
	  picrel->fd = 1;
	  picrel->relocsfd++;
	  break;

        /* This relocation describes the C++ object vtable hierarchy.
           Reconstruct it for later use during GC.  */
        case R_BFIN_GNU_VTINHERIT:
          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;

        /* This relocation describes which C++ vtable entries are actually
           used.  Record for later use during GC.  */
        case R_BFIN_GNU_VTENTRY:
          if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;

	case R_huimm16:
	case R_luimm16:
	case R_pcrel12_jump_s:
	case R_pcrel10:
	  break;

	default:
	bad_reloc:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation type %i"),
	     abfd, ELF32_R_TYPE (rel->r_info));
	  return FALSE;
        }
a2113 9
/* Set the right machine number for a Blackfin ELF file.  */

static bfd_boolean
elf32_bfin_object_p (bfd *abfd)
{
  bfd_default_set_arch_mach (abfd, bfd_arch_bfin, 0);
  return (((elf_elfheader (abfd)->e_flags & EF_BFIN_FDPIC) != 0)
	  == (IS_FDPIC (abfd)));
}
d2115 2
d2118 1
a2118 1
elf32_bfin_set_private_flags (bfd * abfd, flagword flags)
d2120 2
a2121 4
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}
a2122 5
/* Copy backend specific data from one object module to another.  */

static bfd_boolean
bfin_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
d2127 8
a2134 2
  BFD_ASSERT (!elf_flags_init (obfd)
	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);
a2135 2
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;
d2139 1
d2141 1
a2141 1
elf32_bfinfdpic_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d2143 2
a2144 38
  unsigned i;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (! bfin_elf_copy_private_bfd_data (ibfd, obfd))
    return FALSE;

  if (! elf_tdata (ibfd) || ! elf_tdata (ibfd)->phdr
      || ! elf_tdata (obfd) || ! elf_tdata (obfd)->phdr)
    return TRUE;

  /* Copy the stack size.  */
  for (i = 0; i < elf_elfheader (ibfd)->e_phnum; i++)
    if (elf_tdata (ibfd)->phdr[i].p_type == PT_GNU_STACK)
      {
	Elf_Internal_Phdr *iphdr = &elf_tdata (ibfd)->phdr[i];

	for (i = 0; i < elf_elfheader (obfd)->e_phnum; i++)
	  if (elf_tdata (obfd)->phdr[i].p_type == PT_GNU_STACK)
	    {
	      memcpy (&elf_tdata (obfd)->phdr[i], iphdr, sizeof (*iphdr));

	      /* Rewrite the phdrs, since we're only called after they
		 were first written.  */
	      if (bfd_seek (obfd, (bfd_signed_vma) get_elf_backend_data (obfd)
			    ->s->sizeof_ehdr, SEEK_SET) != 0
		  || get_elf_backend_data (obfd)->s
		  ->write_out_phdrs (obfd, elf_tdata (obfd)->phdr,
				     elf_elfheader (obfd)->e_phnum) != 0)
		return FALSE;
	      break;
	    }

	break;
      }

a2153 1
  flagword flags;
d2160 2
a2161 1
  flags = elf_elfheader (abfd)->e_flags;
a2165 6
  if (flags & EF_BFIN_PIC)
    fprintf (file, " -fpic");

  if (flags & EF_BFIN_FDPIC)
    fprintf (file, " -mfdpic");

a2170 74
/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
elf32_bfin_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags, old_partial;
  flagword new_flags, new_partial;
  bfd_boolean error = FALSE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

  if (new_flags & EF_BFIN_FDPIC)
    new_flags &= ~EF_BFIN_PIC;

#ifdef DEBUG
  (*_bfd_error_handler) ("old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s",
			 old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no",
			 bfd_get_filename (ibfd));
#endif

  if (!elf_flags_init (obfd))			/* First call, no flags set.  */
    {
      elf_flags_init (obfd) = TRUE;
      old_flags = new_flags;
    }

  else if (new_flags == old_flags)		/* Compatible flags are ok.  */
    ;

  else						/* Possibly incompatible flags.  */
    {
      /* We don't have to do anything if the pic flags are the same, or the new
         module(s) were compiled with -mlibrary-pic.  */
      new_partial = (new_flags & EF_BFIN_PIC_FLAGS);
      old_partial = (old_flags & EF_BFIN_PIC_FLAGS);
      if (new_partial == old_partial)
	;

      /* If we have mixtures of -fpic and -fPIC, or in both bits.  */
      else if (new_partial != 0 && old_partial != 0)
	old_flags |= new_partial;

      /* One module was compiled for pic and the other was not, see if we have
         had any relocations that are not pic-safe.  */
      else
	old_flags |= new_partial;

    }

  /* Update the old flags now with changes made above.  */
  elf_elfheader (obfd)->e_flags = old_flags;

  if (((new_flags & EF_BFIN_FDPIC) == 0)
      != (! IS_FDPIC (ibfd)))
    {
      error = TRUE;
      if (IS_FDPIC (obfd))
	(*_bfd_error_handler)
	  (_("%s: cannot link non-fdpic object file into fdpic executable"),
	   bfd_get_filename (ibfd));
      else
	(*_bfd_error_handler)
	  (_("%s: cannot link fdpic object file into non-fdpic executable"),
	   bfd_get_filename (ibfd));
    }

  if (error)
    bfd_set_error (bfd_error_bad_value);

  return !error;
}

d2195 1
a2195 1
			struct bfd_hash_table *table, const char *string)
d2222 2
a2223 2
  ret = bfd_zalloc (abfd, amt);
  if (ret == NULL)
d2228 1
a2228 1
				      sizeof (struct elf_link_hash_entry)))
d2515 3
d2663 1
a2663 1

a2670 3
bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *, asection *, char **));

d2786 1
a2786 1

d2790 1
a2790 1
#define ELF_MACHINE_CODE		EM_BLACKFIN
a2796 1
#define elf_backend_object_p		elf32_bfin_object_p
d2811 1
a2811 1
#define elf_backend_check_relocs        bfin_check_relocs
a2837 69
#include "elf32-target.h"

#undef TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM          bfd_elf32_bfinfdpic_vec
#undef TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elf32-bfinfdpic"
#undef	elf32_bed
#define	elf32_bed		elf32_bfinfdpic_bed

#undef elf_backend_gc_sweep_hook
#define elf_backend_gc_sweep_hook       bfinfdpic_gc_sweep_hook

#undef elf_backend_got_header_size
#define elf_backend_got_header_size     0

#undef elf_backend_relocate_section
#define elf_backend_relocate_section    bfinfdpic_relocate_section
#undef elf_backend_check_relocs
#define elf_backend_check_relocs        bfinfdpic_check_relocs

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
		bfinfdpic_elf_link_hash_table_create
#undef elf_backend_always_size_sections
#define elf_backend_always_size_sections \
		elf32_bfinfdpic_always_size_sections
#undef elf_backend_modify_segment_map
#define elf_backend_modify_segment_map \
		elf32_bfinfdpic_modify_segment_map
#undef bfd_elf32_bfd_copy_private_bfd_data
#define bfd_elf32_bfd_copy_private_bfd_data \
		elf32_bfinfdpic_copy_private_bfd_data

#undef elf_backend_create_dynamic_sections
#define elf_backend_create_dynamic_sections \
		elf32_bfinfdpic_create_dynamic_sections
#undef elf_backend_adjust_dynamic_symbol
#define elf_backend_adjust_dynamic_symbol \
		elf32_bfinfdpic_adjust_dynamic_symbol
#undef elf_backend_size_dynamic_sections
#define elf_backend_size_dynamic_sections \
		elf32_bfinfdpic_size_dynamic_sections
#undef elf_backend_finish_dynamic_symbol
#define elf_backend_finish_dynamic_symbol \
		elf32_bfinfdpic_finish_dynamic_symbol
#undef elf_backend_finish_dynamic_sections
#define elf_backend_finish_dynamic_sections \
		elf32_bfinfdpic_finish_dynamic_sections

#undef elf_backend_can_make_relative_eh_frame
#define elf_backend_can_make_relative_eh_frame \
		bfinfdpic_elf_use_relative_eh_frame
#undef elf_backend_can_make_lsda_relative_eh_frame
#define elf_backend_can_make_lsda_relative_eh_frame \
		bfinfdpic_elf_use_relative_eh_frame
#undef elf_backend_encode_eh_address
#define elf_backend_encode_eh_address \
		bfinfdpic_elf_encode_eh_address

#undef elf_backend_may_use_rel_p
#define elf_backend_may_use_rel_p       1
#undef elf_backend_may_use_rela_p
#define elf_backend_may_use_rela_p      1
/* We use REL for dynamic relocations only.  */
#undef elf_backend_default_use_rela_p
#define elf_backend_default_use_rela_p  1

#undef elf_backend_omit_section_dynsym
#define elf_backend_omit_section_dynsym _bfinfdpic_link_omit_section_dynsym
@


1.4
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2005 Free Software Foundation, Inc.
d2227 2
a2228 1
				      bfin_link_hash_newfunc))
@


1.3
log
@bfd/
	* elf32-bfin.c (bfd_bfin_elf32_create_embedded_relocs): Fix signedness
	warning.
gas/
	* Makefile.am (bfin-parse.h): Renamed from bfin-parse.tab.h.
	(EXTRA_DIST): Add bfin-parse.h and bfin-lex.c.
	* Makefile.in: Regenerate.
	* config/bfin-lex.l: Include bfin-parse.h instead of bfin-parse.tab.h.
	* config/tc-bfin.c (md_chars_to_number): Change the type of first
	argument from unsigned char * to char * to remove signedness warnings.
@
text
@d2340 1
a2340 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.2
log
@	* elf32-bfin.c (bfin_howto_table): Set src_mask to 0 for all relocs.
	(bfin_imm16_reloc): Always add in the addend.  Don't fetch existing
	contents from section.
	(bfin_relocate_section): Rework so as to not call special_functions.
	Handle the relocation stack here.  Treat pcrel24 relocs specially.
@
text
@d2767 1
a2767 1
	strncpy (p + 4, targetsec->output_section->name, 8);
@


1.1
log
@	* Makefile.am: Bfin support.
	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* archures.c (bfd_mach_bfin): New.
	(bfd_arch_bfin): New.
	bfd-in.h (bfd_bfin_elf32_create_embedded_relocs): New.
	* bfd-in2.h: Regenerated.
	* config.bfd: Bfin support.
	* configure: Regenerated.
	* configure.in: Bfin support.
	* libbfd.h: Regenerated.
	* reloc.c: Add BFD relocations for Bfin.
	* targets.c (bfd_elf32_bfin_vec): New.
	* cpu-bfin.c: New file.
	* elf32-bfin.c: New file.
@
text
@d436 2
a437 5
      if (symbol->flags & BSF_SECTION_SYM)
	{
	  /* Add in supplied addend.  */
	  relocation += reloc_entry->addend;
	}
a469 1
  x = bfd_get_16 (abfd, (bfd_byte *) data + reloc_addr);
d758 1
a758 1
	 0x0000000F,		/* src_mask.  */
d786 1
a786 1
	 0x000003FF,		/* src_mask.  */
d804 1
a804 1
	 0x0FFF,		/* src_mask.  */
d818 1
a818 1
	 0x0000FFFF,		/* src_mask.  */
d832 1
a832 1
	 0x0000FFFF,		/* src_mask.  */
d846 1
a846 1
	 0x0000FFFF,		/* src_mask.  */
d860 1
a860 1
	 0x00000FFF,		/* src_mask.  */
d874 1
a874 1
	 0x00FFFFFF,		/* src_mask.  */
d888 1
a888 1
	 0x00FFFFFF,		/* src_mask.  */
d930 1
a930 1
	 0x00FFFFFF,		/* src_mask.  */
d944 1
a944 1
	 0x00FFFFFF,		/* src_mask.  */
d972 1
a972 1
	 0xFF,			/* src_mask.  */
d986 1
a986 1
	 0xFFFF,		/* src_mask.  */
d1000 1
a1000 1
	 0xFFFFFFFF,		/* src_mask.  */
d1014 1
a1014 1
	 0x000003FF,		/* src_mask.  */
d1659 1
a1677 1
  char *error_msg = NULL;
d1704 1
a1734 4
	  /* Call to bfd_elf_rela_local_sym would have CHANGED the sec
             as well as updated relocation. The value returned is
             w.r.t the original section.  */
	  sec = local_sections[r_symndx];
d1758 39
d1808 1
a1808 1
	    break;
d1828 1
a1829 1
		dyn = elf_hash_table (info)->dynamic_sections_created;
d1834 2
a1835 1
			    || h->forced_local) && h->def_regular))
d1863 1
a1863 3
		BFD_ASSERT (local_got_offsets != NULL
			    && local_got_offsets[r_symndx] != (bfd_vma) - 1);

d1865 1
a1873 1

d1905 34
d1942 4
a1945 9
	  if (howto->special_function)
	    {
	      bfd_reloc_status_type cont;
	      arelent reloc_ent;
	      asymbol symbol;
	      asymbol *symbol1;
	      symbol.flags = 0;
	      symbol.section = bfd_und_section_ptr;
	      symbol.value = 0;
a1946 49
	      if (h != NULL)
		{
		  if (unresolved_reloc)
		    {
		      break;
		    }
		  if (h->root.type != bfd_link_hash_undefweak
		      && h->root.type != bfd_link_hash_undefined)
		    {
		      symbol.the_bfd = input_bfd;
		      symbol.section = h->root.u.def.section;
		      symbol.name = h->root.root.string;
		      symbol.value = h->root.u.def.value;
		    }
		  if (h->root.type == bfd_link_hash_defweak
                      || h->root.type == bfd_link_hash_undefweak)
		    {
		      symbol.name = h->root.root.string;
		      symbol.flags |= BSF_WEAK;
		    }
		}
	      else
		{
		  symbol = *sec->symbol;
		}
	      reloc_ent.address = rel->r_offset;
	      reloc_ent.howto = howto;
	      reloc_ent.addend = rel->r_addend;
	      symbol1 = &symbol;
	      reloc_ent.sym_ptr_ptr = &symbol1;

	      cont =
		howto->special_function (input_bfd, &reloc_ent, &symbol,
					 contents, input_section,
					 info->
					 relocatable ? output_bfd : NULL,
					 &error_msg);
	      if (cont == bfd_reloc_ok)
		{
		  continue;
		}
	    }
	  else
	    {
	      fprintf (stderr, "%s no special func r_type is %d\n",
		       input_bfd->filename, r_type);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
d1950 1
a1963 4
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);

@

