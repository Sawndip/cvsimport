head	1.592;
access;
symbols
	sid-snapshot-20180601:1.592
	sid-snapshot-20180501:1.592
	sid-snapshot-20180401:1.592
	sid-snapshot-20180301:1.592
	sid-snapshot-20180201:1.592
	sid-snapshot-20180101:1.592
	sid-snapshot-20171201:1.592
	sid-snapshot-20171101:1.592
	sid-snapshot-20171001:1.592
	sid-snapshot-20170901:1.592
	sid-snapshot-20170801:1.592
	sid-snapshot-20170701:1.592
	sid-snapshot-20170601:1.592
	sid-snapshot-20170501:1.592
	sid-snapshot-20170401:1.592
	sid-snapshot-20170301:1.592
	sid-snapshot-20170201:1.592
	sid-snapshot-20170101:1.592
	sid-snapshot-20161201:1.592
	sid-snapshot-20161101:1.592
	sid-snapshot-20160901:1.592
	sid-snapshot-20160801:1.592
	sid-snapshot-20160701:1.592
	sid-snapshot-20160601:1.592
	sid-snapshot-20160501:1.592
	sid-snapshot-20160401:1.592
	sid-snapshot-20160301:1.592
	sid-snapshot-20160201:1.592
	sid-snapshot-20160101:1.592
	sid-snapshot-20151201:1.592
	sid-snapshot-20151101:1.592
	sid-snapshot-20151001:1.592
	sid-snapshot-20150901:1.592
	sid-snapshot-20150801:1.592
	sid-snapshot-20150701:1.592
	sid-snapshot-20150601:1.592
	sid-snapshot-20150501:1.592
	sid-snapshot-20150401:1.592
	sid-snapshot-20150301:1.592
	sid-snapshot-20150201:1.592
	sid-snapshot-20150101:1.592
	sid-snapshot-20141201:1.592
	sid-snapshot-20141101:1.592
	sid-snapshot-20141001:1.592
	sid-snapshot-20140901:1.592
	sid-snapshot-20140801:1.592
	sid-snapshot-20140701:1.592
	sid-snapshot-20140601:1.592
	sid-snapshot-20140501:1.592
	sid-snapshot-20140401:1.592
	sid-snapshot-20140301:1.592
	sid-snapshot-20140201:1.592
	sid-snapshot-20140101:1.592
	sid-snapshot-20131201:1.592
	sid-snapshot-20131101:1.592
	sid-snapshot-20131001:1.591
	binutils-2_24-branch:1.591.0.2
	binutils-2_24-branchpoint:1.591
	binutils-2_21_1:1.524.2.4
	sid-snapshot-20130901:1.591
	gdb_7_6_1-2013-08-30-release:1.589
	sid-snapshot-20130801:1.591
	sid-snapshot-20130701:1.591
	sid-snapshot-20130601:1.591
	sid-snapshot-20130501:1.591
	gdb_7_6-2013-04-26-release:1.589
	sid-snapshot-20130401:1.591
	binutils-2_23_2:1.568.2.3
	gdb_7_6-branch:1.589.0.2
	gdb_7_6-2013-03-12-branchpoint:1.589
	sid-snapshot-20130301:1.588
	sid-snapshot-20130201:1.581
	sid-snapshot-20130101:1.580
	sid-snapshot-20121201:1.577
	gdb_7_5_1-2012-11-29-release:1.567
	binutils-2_23_1:1.568
	sid-snapshot-20121101:1.573
	binutils-2_23:1.568
	sid-snapshot-20121001:1.570
	sid-snapshot-20120901:1.569
	gdb_7_5-2012-08-17-release:1.567
	sid-snapshot-20120801:1.568
	binutils-2_23-branch:1.568.0.2
	binutils-2_23-branchpoint:1.568
	gdb_7_5-branch:1.567.0.2
	gdb_7_5-2012-07-18-branchpoint:1.567
	sid-snapshot-20120701:1.564
	sid-snapshot-20120601:1.555
	sid-snapshot-20120501:1.552
	binutils-2_22_branch:1.543.0.4
	gdb_7_4_1-2012-04-26-release:1.545
	sid-snapshot-20120401:1.550
	sid-snapshot-20120301:1.549
	sid-snapshot-20120201:1.548
	gdb_7_4-2012-01-24-release:1.545
	sid-snapshot-20120101:1.546
	gdb_7_4-branch:1.545.0.2
	gdb_7_4-2011-12-13-branchpoint:1.545
	sid-snapshot-20111201:1.544
	binutils-2_22:1.543
	sid-snapshot-20111101:1.544
	sid-snapshot-20111001:1.544
	binutils-2_22-branch:1.543.0.2
	binutils-2_22-branchpoint:1.543
	gdb_7_3_1-2011-09-04-release:1.530
	sid-snapshot-20110901:1.543
	sid-snapshot-20110801:1.543
	gdb_7_3-2011-07-26-release:1.530
	sid-snapshot-20110701:1.542
	sid-snapshot-20110601:1.538
	sid-snapshot-20110501:1.533
	gdb_7_3-branch:1.530.0.2
	gdb_7_3-2011-04-01-branchpoint:1.530
	sid-snapshot-20110401:1.530
	sid-snapshot-20110301:1.529
	sid-snapshot-20110201:1.528
	sid-snapshot-20110101:1.527
	binutils-2_21:1.524
	sid-snapshot-20101201:1.525
	binutils-2_21-branch:1.524.0.2
	binutils-2_21-branchpoint:1.524
	sid-snapshot-20101101:1.524
	sid-snapshot-20101001:1.521
	binutils-2_20_1:1.490.2.2
	gdb_7_2-2010-09-02-release:1.511
	sid-snapshot-20100901:1.518
	sid-snapshot-20100801:1.513
	gdb_7_2-branch:1.511.0.2
	gdb_7_2-2010-07-07-branchpoint:1.511
	sid-snapshot-20100701:1.511
	sid-snapshot-20100601:1.511
	sid-snapshot-20100501:1.510
	sid-snapshot-20100401:1.506
	gdb_7_1-2010-03-18-release:1.503
	sid-snapshot-20100301:1.505
	gdb_7_1-branch:1.503.0.2
	gdb_7_1-2010-02-18-branchpoint:1.503
	sid-snapshot-20100201:1.498
	sid-snapshot-20100101:1.496
	gdb_7_0_1-2009-12-22-release:1.492
	sid-snapshot-20091201:1.493
	sid-snapshot-20091101:1.493
	binutils-2_20:1.490.2.2
	gdb_7_0-2009-10-06-release:1.492
	sid-snapshot-20091001:1.493
	gdb_7_0-branch:1.492.0.2
	gdb_7_0-2009-09-16-branchpoint:1.492
	arc-sim-20090309:1.435
	binutils-arc-20081103-branch:1.466.0.4
	binutils-arc-20081103-branchpoint:1.466
	binutils-2_20-branch:1.490.0.2
	binutils-2_20-branchpoint:1.490
	sid-snapshot-20090901:1.490
	sid-snapshot-20090801:1.486
	msnyder-checkpoint-072509-branch:1.486.0.2
	msnyder-checkpoint-072509-branchpoint:1.486
	sid-snapshot-20090701:1.483
	dje-cgen-play1-branch:1.483.0.2
	dje-cgen-play1-branchpoint:1.483
	sid-snapshot-20090601:1.481
	sid-snapshot-20090501:1.481
	sid-snapshot-20090401:1.480
	arc-20081103-branch:1.466.0.2
	arc-20081103-branchpoint:1.466
	arc-insight_6_8-branch:1.435.0.6
	arc-insight_6_8-branchpoint:1.435
	insight_6_8-branch:1.435.0.4
	insight_6_8-branchpoint:1.435
	sid-snapshot-20090301:1.477
	binutils-2_19_1:1.462.2.3
	sid-snapshot-20090201:1.475
	sid-snapshot-20090101:1.474
	reverse-20081226-branch:1.474.0.2
	reverse-20081226-branchpoint:1.474
	sid-snapshot-20081201:1.472
	multiprocess-20081120-branch:1.472.0.2
	multiprocess-20081120-branchpoint:1.472
	sid-snapshot-20081101:1.466
	binutils-2_19:1.462.2.2
	sid-snapshot-20081001:1.464
	reverse-20080930-branch:1.464.0.2
	reverse-20080930-branchpoint:1.464
	binutils-2_19-branch:1.462.0.2
	binutils-2_19-branchpoint:1.462
	sid-snapshot-20080901:1.462
	sid-snapshot-20080801:1.460
	reverse-20080717-branch:1.453.0.2
	reverse-20080717-branchpoint:1.453
	sid-snapshot-20080701:1.450
	msnyder-reverse-20080609-branch:1.448.0.2
	msnyder-reverse-20080609-branchpoint:1.448
	drow-reverse-20070409-branch:1.382.0.2
	drow-reverse-20070409-branchpoint:1.382
	sid-snapshot-20080601:1.447
	sid-snapshot-20080501:1.442
	sid-snapshot-20080403:1.440
	sid-snapshot-20080401:1.440
	gdb_6_8-2008-03-27-release:1.435
	sid-snapshot-20080301:1.436
	gdb_6_8-branch:1.435.0.2
	gdb_6_8-2008-02-26-branchpoint:1.435
	sid-snapshot-20080201:1.430
	sid-snapshot-20080101:1.429
	sid-snapshot-20071201:1.424
	sid-snapshot-20071101:1.422
	gdb_6_7_1-2007-10-29-release:1.413
	gdb_6_7-2007-10-10-release:1.413
	sid-snapshot-20071001:1.418
	gdb_6_7-branch:1.413.0.2
	gdb_6_7-2007-09-07-branchpoint:1.413
	binutils-2_18:1.405.2.3
	binutils-2_18-branch:1.405.0.2
	binutils-2_18-branchpoint:1.405
	insight_6_6-20070208-release:1.365
	binutils-csl-coldfire-4_1-32:1.329.2.2
	binutils-csl-sourcerygxx-4_1-32:1.329.2.2
	gdb_6_6-2006-12-18-release:1.365
	binutils-csl-innovasic-fido-3_4_4-33:1.329.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.270.2.1
	binutils-csl-coldfire-4_1-30:1.329.2.1
	binutils-csl-sourcerygxx-4_1-30:1.329.2.1
	binutils-csl-coldfire-4_1-28:1.329.2.1
	binutils-csl-sourcerygxx-4_1-29:1.329.2.2
	binutils-csl-sourcerygxx-4_1-28:1.329.2.1
	gdb_6_6-branch:1.365.0.2
	gdb_6_6-2006-11-15-branchpoint:1.365
	binutils-csl-arm-2006q3-27:1.329.2.1
	binutils-csl-sourcerygxx-4_1-27:1.329.2.1
	binutils-csl-arm-2006q3-26:1.329.2.1
	binutils-csl-sourcerygxx-4_1-26:1.329.2.1
	binutils-csl-sourcerygxx-4_1-25:1.329.2.1
	binutils-csl-sourcerygxx-4_1-24:1.329.2.1
	binutils-csl-sourcerygxx-4_1-23:1.329.2.1
	insight_6_5-20061003-release:1.336
	gdb-csl-symbian-6_4_50_20060226-12:1.328
	binutils-csl-sourcerygxx-4_1-21:1.329.2.1
	binutils-csl-arm-2006q3-21:1.329.2.1
	binutils-csl-sourcerygxx-4_1-22:1.329.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.329.2.1
	binutils-csl-sourcerygxx-4_1-20:1.329.2.1
	binutils-csl-arm-2006q3-19:1.329.2.1
	binutils-csl-sourcerygxx-4_1-19:1.329.2.1
	binutils-csl-sourcerygxx-4_1-18:1.329.2.1
	binutils-csl-renesas-4_1-9:1.329.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.318
	binutils-csl-sourcerygxx-3_4_4-25:1.270.2.1
	nickrob-async-20060828-mergepoint:1.351
	gdb-csl-symbian-6_4_50_20060226-11:1.328
	binutils-csl-renesas-4_1-8:1.329.2.1
	binutils-csl-renesas-4_1-7:1.329.2.1
	binutils-csl-renesas-4_1-6:1.329.2.1
	gdb-csl-sourcerygxx-4_1-17:1.328
	binutils-csl-sourcerygxx-4_1-17:1.329.2.1
	gdb-csl-20060226-branch-local-2:1.328
	gdb-csl-sourcerygxx-4_1-14:1.328
	binutils-csl-sourcerygxx-4_1-14:1.329.2.1
	binutils-csl-sourcerygxx-4_1-15:1.329.2.1
	gdb-csl-sourcerygxx-4_1-13:1.328
	binutils-csl-sourcerygxx-4_1-13:1.329.2.1
	binutils-2_17:1.329
	gdb-csl-sourcerygxx-4_1-12:1.328
	binutils-csl-sourcerygxx-4_1-12:1.329.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.328
	binutils-csl-sourcerygxx-3_4_4-21:1.329.2.1
	gdb_6_5-20060621-release:1.336
	binutils-csl-wrs-linux-3_4_4-24:1.270
	binutils-csl-wrs-linux-3_4_4-23:1.270
	gdb-csl-sourcerygxx-4_1-9:1.328
	binutils-csl-sourcerygxx-4_1-9:1.329.2.1
	gdb-csl-sourcerygxx-4_1-8:1.328
	binutils-csl-sourcerygxx-4_1-8:1.329.2.1
	gdb-csl-sourcerygxx-4_1-7:1.328
	binutils-csl-sourcerygxx-4_1-7:1.329.2.1
	gdb-csl-arm-2006q1-6:1.328
	binutils-csl-arm-2006q1-6:1.329.2.1
	gdb-csl-sourcerygxx-4_1-6:1.328
	binutils-csl-sourcerygxx-4_1-6:1.329.2.1
	binutils-csl-wrs-linux-3_4_4-22:1.270
	gdb-csl-symbian-6_4_50_20060226-10:1.328
	gdb-csl-symbian-6_4_50_20060226-9:1.328
	gdb-csl-symbian-6_4_50_20060226-8:1.328
	gdb-csl-coldfire-4_1-11:1.328
	binutils-csl-coldfire-4_1-11:1.329
	gdb-csl-sourcerygxx-3_4_4-19:1.328
	binutils-csl-sourcerygxx-3_4_4-19:1.329
	gdb-csl-coldfire-4_1-10:1.328
	gdb_6_5-branch:1.336.0.4
	gdb_6_5-2006-05-14-branchpoint:1.336
	binutils-csl-coldfire-4_1-10:1.329
	gdb-csl-sourcerygxx-4_1-5:1.328
	binutils-csl-sourcerygxx-4_1-5:1.329
	nickrob-async-20060513-branch:1.336.0.2
	nickrob-async-20060513-branchpoint:1.336
	gdb-csl-sourcerygxx-4_1-4:1.328
	binutils-csl-sourcerygxx-4_1-4:1.329
	msnyder-reverse-20060502-branch:1.333.0.2
	msnyder-reverse-20060502-branchpoint:1.333
	binutils-csl-wrs-linux-3_4_4-21:1.270
	gdb-csl-morpho-4_1-4:1.328
	binutils-csl-morpho-4_1-4:1.329
	gdb-csl-sourcerygxx-3_4_4-17:1.328
	binutils-csl-sourcerygxx-3_4_4-17:1.329
	binutils-csl-wrs-linux-3_4_4-20:1.270
	readline_5_1-import-branch:1.329.0.8
	readline_5_1-import-branchpoint:1.329
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.328
	binutils-2_17-branch:1.329.0.6
	binutils-2_17-branchpoint:1.329
	gdb-csl-symbian-20060226-branch:1.328.0.6
	gdb-csl-symbian-20060226-branchpoint:1.328
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.328
	msnyder-reverse-20060331-branch:1.329.0.4
	msnyder-reverse-20060331-branchpoint:1.329
	binutils-csl-2_17-branch:1.329.0.2
	binutils-csl-2_17-branchpoint:1.329
	gdb-csl-available-20060303-branch:1.328.0.4
	gdb-csl-available-20060303-branchpoint:1.328
	gdb-csl-20060226-branch:1.328.0.2
	gdb-csl-20060226-branchpoint:1.328
	gdb_6_4-20051202-release:1.317
	msnyder-fork-checkpoint-branch:1.318.0.4
	msnyder-fork-checkpoint-branchpoint:1.318
	gdb-csl-gxxpro-6_3-branch:1.318.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.318
	gdb_6_4-branch:1.317.0.2
	gdb_6_4-2005-11-01-branchpoint:1.317
	gdb-csl-arm-20051020-branch:1.315.0.2
	gdb-csl-arm-20051020-branchpoint:1.315
	binutils-csl-gxxpro-3_4-branch:1.270.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.270.2.1
	binutils-2_16_1:1.270.2.1
	msnyder-tracepoint-checkpoint-branch:1.299.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.299
	gdb-csl-arm-20050325-2005-q1b:1.271
	binutils-csl-arm-2005q1b:1.270
	binutils-2_16:1.270
	gdb-csl-arm-20050325-2005-q1a:1.271
	binutils-csl-arm-2005q1a:1.270
	csl-arm-20050325-branch:1.271.0.2
	csl-arm-20050325-branchpoint:1.271
	binutils-csl-arm-2005q1-branch:1.270.0.4
	binutils-csl-arm-2005q1-branchpoint:1.270
	binutils-2_16-branch:1.270.0.2
	binutils-2_16-branchpoint:1.270
	csl-arm-2004-q3d:1.252
	gdb_6_3-20041109-release:1.251
	gdb_6_3-branch:1.251.0.2
	gdb_6_3-20041019-branchpoint:1.251
	csl-arm-2004-q3:1.247
	drow_intercu-merge-20040921:1.245
	drow_intercu-merge-20040915:1.243
	jimb-gdb_6_2-e500-branch:1.233.0.6
	jimb-gdb_6_2-e500-branchpoint:1.233
	gdb_6_2-20040730-release:1.233
	gdb_6_2-branch:1.233.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.233
	gdb_6_1_1-20040616-release:1.217
	binutils-2_15:1.217.4.2
	binutils-2_15-branchpoint:1.217
	csl-arm-2004-q1a:1.224
	csl-arm-2004-q1:1.220
	gdb_6_1-2004-04-05-release:1.217
	drow_intercu-merge-20040402:1.220
	drow_intercu-merge-20040327:1.219
	ezannoni_pie-20040323-branch:1.219.0.2
	ezannoni_pie-20040323-branchpoint:1.219
	cagney_tramp-20040321-mergepoint:1.219
	cagney_tramp-20040309-branch:1.218.0.2
	cagney_tramp-20040309-branchpoint:1.218
	gdb_6_1-branch:1.217.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.217
	drow_intercu-20040221-branch:1.217.0.6
	drow_intercu-20040221-branchpoint:1.217
	binutils-2_15-branch:1.217.0.4
	cagney_bfdfile-20040213-branch:1.217.0.2
	cagney_bfdfile-20040213-branchpoint:1.217
	drow-cplus-merge-20040208:1.215
	carlton_dictionary-20040126-merge:1.215
	cagney_bigcore-20040122-branch:1.215.0.2
	cagney_bigcore-20040122-branchpoint:1.215
	drow-cplus-merge-20040113:1.215
	csl-arm-2003-q4:1.215
	drow-cplus-merge-20031224:1.215
	drow-cplus-merge-20031220:1.215
	carlton_dictionary-20031215-merge:1.215
	drow-cplus-merge-20031214:1.215
	carlton-dictionary-20031111-merge:1.208
	gdb_6_0-2003-10-04-release:1.189
	kettenis_sparc-20030918-branch:1.198.0.6
	kettenis_sparc-20030918-branchpoint:1.198
	carlton_dictionary-20030917-merge:1.198
	ezannoni_pie-20030916-branchpoint:1.198
	ezannoni_pie-20030916-branch:1.198.0.4
	cagney_x86i386-20030821-branch:1.198.0.2
	cagney_x86i386-20030821-branchpoint:1.198
	carlton_dictionary-20030805-merge:1.197
	carlton_dictionary-20030627-merge:1.190
	gdb_6_0-branch:1.189.0.6
	gdb_6_0-2003-06-23-branchpoint:1.189
	jimb-ppc64-linux-20030613-branch:1.189.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.189
	binutils-2_14:1.182.2.3
	cagney_convert-20030606-branch:1.189.0.2
	cagney_convert-20030606-branchpoint:1.189
	cagney_writestrings-20030508-branch:1.184.0.4
	cagney_writestrings-20030508-branchpoint:1.184
	jimb-ppc64-linux-20030528-branch:1.187.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.187
	carlton_dictionary-20030523-merge:1.187
	cagney_fileio-20030521-branch:1.187.0.2
	cagney_fileio-20030521-branchpoint:1.187
	kettenis_i386newframe-20030517-mergepoint:1.185
	jimb-ppc64-linux-20030509-branch:1.184.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.184
	kettenis_i386newframe-20030504-mergepoint:1.182
	carlton_dictionary-20030430-merge:1.182
	binutils-2_14-branch:1.182.0.2
	binutils-2_14-branchpoint:1.182
	kettenis_i386newframe-20030419-branch:1.181.0.6
	kettenis_i386newframe-20030419-branchpoint:1.181
	carlton_dictionary-20030416-merge:1.181
	cagney_frameaddr-20030409-mergepoint:1.181
	kettenis_i386newframe-20030406-branch:1.181.0.4
	kettenis_i386newframe-20030406-branchpoint:1.181
	cagney_frameaddr-20030403-branchpoint:1.181
	cagney_frameaddr-20030403-branch:1.181.0.2
	cagney_framebase-20030330-mergepoint:1.180
	cagney_framebase-20030326-branch:1.180.0.10
	cagney_framebase-20030326-branchpoint:1.180
	cagney_lazyid-20030317-branch:1.180.0.8
	cagney_lazyid-20030317-branchpoint:1.180
	kettenis-i386newframe-20030316-mergepoint:1.180
	offbyone-20030313-branch:1.180.0.6
	offbyone-20030313-branchpoint:1.180
	kettenis-i386newframe-20030308-branch:1.180.0.4
	kettenis-i386newframe-20030308-branchpoint:1.180
	carlton_dictionary-20030305-merge:1.180
	cagney_offbyone-20030303-branch:1.180.0.2
	cagney_offbyone-20030303-branchpoint:1.180
	carlton_dictionary-20030207-merge:1.178
	interps-20030202-branch:1.175.0.2
	interps-20030202-branchpoint:1.175
	cagney-unwind-20030108-branch:1.174.0.2
	cagney-unwind-20030108-branchpoint:1.174
	binutils-2_13_2_1:1.155.2.8
	binutils-2_13_2:1.155.2.8
	carlton_dictionary-20021223-merge:1.173
	gdb_5_3-2002-12-12-release:1.160.6.1
	carlton_dictionary-20021115-merge:1.168
	binutils-2_13_1:1.155.2.7
	kseitz_interps-20021105-merge:1.165
	kseitz_interps-20021103-merge:1.164
	drow-cplus-merge-20021020:1.164
	drow-cplus-merge-20021025:1.164
	carlton_dictionary-20021025-merge:1.164
	carlton_dictionary-20021011-merge:1.163
	drow-cplus-branch:1.163.0.2
	drow-cplus-branchpoint:1.163
	kseitz_interps-20020930-merge:1.163
	carlton_dictionary-20020927-merge:1.162
	carlton_dictionary-branch:1.162.0.2
	carlton_dictionary-20020920-branchpoint:1.162
	sid-20020905-branchpoint:1.160
	sid-20020905-branch:1.160.0.8
	gdb_5_3-branch:1.160.0.6
	gdb_5_3-2002-09-04-branchpoint:1.160
	kseitz_interps-20020829-merge:1.160
	cagney_sysregs-20020825-branch:1.160.0.4
	cagney_sysregs-20020825-branchpoint:1.160
	readline_4_3-import-branch:1.160.0.2
	readline_4_3-import-branchpoint:1.160
	binutils-2_13:1.155.2.2
	gdb_5_2_1-2002-07-23-release:1.130
	binutils-2_13-branchpoint:1.155
	binutils-2_13-branch:1.155.0.2
	kseitz_interps-20020528-branch:1.139.0.2
	kseitz_interps-20020528-branchpoint:1.139
	cagney_regbuf-20020515-branch:1.137.0.4
	cagney_regbuf-20020515-branchpoint:1.137
	binutils-2_12_1:1.127.2.5
	jimb-macro-020506-branch:1.137.0.2
	jimb-macro-020506-branchpoint:1.137
	gdb_5_2-2002-04-29-release:1.130
	binutils-2_12:1.127.2.1
	gdb_5_2-branch:1.130.0.2
	gdb_5_2-2002-03-03-branchpoint:1.130
	binutils-2_12-branch:1.127.0.2
	binutils-2_12-branchpoint:1.127
	gdb_5_1_1-2002-01-24-release:1.74
	gdb_5_1_0_1-2002-01-03-release:1.74
	cygnus_cvs_20020108_pre:1.117
	gdb_5_1_0_1-2002-01-03-branch:1.74.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.74
	gdb_5_1-2001-11-21-release:1.74
	gdb_s390-2001-09-26-branch:1.74.0.4
	gdb_s390-2001-09-26-branchpoint:1.74
	gdb_5_1-2001-07-29-branch:1.74.0.2
	gdb_5_1-2001-07-29-branchpoint:1.74
	binutils-2_11_2:1.61.2.2
	binutils-2_11_1:1.61.2.2
	binutils-2_11:1.61
	x86_64versiong3:1.63
	binutils-2_11-branch:1.61.0.2
	insight-precleanup-2001-01-01:1.61
	binutils-2_10_1:1.27.2.4
	binutils-2_10:1.27.2.3
	gdb-premipsmulti-2000-06-06-branch:1.33.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.33
	gdb_5_0-2000-05-19-release:1.27
	gdb_4_18_2-2000-05-18-release:1.27
	gdb_4_95_1-2000-05-11-snapshot:1.27
	gdb_4_95_0-2000-04-27-snapshot:1.27
	gdb_5_0-2000-04-10-branch:1.27.0.4
	gdb_5_0-2000-04-10-branchpoint:1.27
	binutils-2_10-branch:1.27.0.2
	binutils-2_10-branchpoint:1.27
	binutils_latest_snapshot:1.592
	repo-unification-2000-02-06:1.22
	binu_ss_19990721:1.14
	binu_ss_19990602:1.4
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.592
date	2013.10.17.10.05.38;	author amodra;	state Exp;
branches;
next	1.591;

1.591
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches
	1.591.2.1;
next	1.590;

1.590
date	2013.03.25.06.00.06;	author amodra;	state Exp;
branches;
next	1.589;

1.589
date	2013.03.08.17.13.31;	author nickc;	state Exp;
branches;
next	1.588;

1.588
date	2013.02.21.04.35.16;	author amodra;	state Exp;
branches;
next	1.587;

1.587
date	2013.02.21.03.02.28;	author amodra;	state Exp;
branches;
next	1.586;

1.586
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.585;

1.585
date	2013.02.18.23.50.27;	author amodra;	state Exp;
branches;
next	1.584;

1.584
date	2013.02.08.07.04.50;	author amodra;	state Exp;
branches;
next	1.583;

1.583
date	2013.02.07.04.20.31;	author amodra;	state Exp;
branches;
next	1.582;

1.582
date	2013.02.04.18.26.34;	author sergiodj;	state Exp;
branches;
next	1.581;

1.581
date	2013.01.08.18.09.10;	author yufeng;	state Exp;
branches;
next	1.580;

1.580
date	2012.12.18.13.25.46;	author amodra;	state Exp;
branches;
next	1.579;

1.579
date	2012.12.14.15.30.28;	author tromey;	state Exp;
branches;
next	1.578;

1.578
date	2012.12.07.04.58.36;	author amodra;	state Exp;
branches;
next	1.577;

1.577
date	2012.11.21.21.31.17;	author hjl;	state Exp;
branches;
next	1.576;

1.576
date	2012.11.13.22.54.21;	author hjl;	state Exp;
branches;
next	1.575;

1.575
date	2012.11.09.08.29.29;	author hjl;	state Exp;
branches;
next	1.574;

1.574
date	2012.11.08.21.16.36;	author tromey;	state Exp;
branches;
next	1.573;

1.573
date	2012.10.23.09.33.53;	author nathan;	state Exp;
branches;
next	1.572;

1.572
date	2012.10.15.20.36.12;	author devans;	state Exp;
branches;
next	1.571;

1.571
date	2012.10.07.23.59.26;	author amodra;	state Exp;
branches;
next	1.570;

1.570
date	2012.09.04.12.35.34;	author hjl;	state Exp;
branches;
next	1.569;

1.569
date	2012.08.10.02.14.50;	author amodra;	state Exp;
branches;
next	1.568;

1.568
date	2012.07.24.21.06.57;	author ccoutant;	state Exp;
branches
	1.568.2.1;
next	1.567;

1.567
date	2012.07.04.00.29.51;	author hjl;	state Exp;
branches;
next	1.566;

1.566
date	2012.07.03.16.06.33;	author hjl;	state Exp;
branches;
next	1.565;

1.565
date	2012.07.03.05.47.35;	author amodra;	state Exp;
branches;
next	1.564;

1.564
date	2012.07.01.08.23.13;	author schwab;	state Exp;
branches;
next	1.563;

1.563
date	2012.06.22.16.52.28;	author roland;	state Exp;
branches;
next	1.562;

1.562
date	2012.06.12.12.55.09;	author hjl;	state Exp;
branches;
next	1.561;

1.561
date	2012.06.12.06.31.06;	author amodra;	state Exp;
branches;
next	1.560;

1.560
date	2012.06.11.16.48.35;	author hjl;	state Exp;
branches;
next	1.559;

1.559
date	2012.06.11.16.44.02;	author hjl;	state Exp;
branches;
next	1.558;

1.558
date	2012.06.04.14.35.21;	author jkratoch;	state Exp;
branches;
next	1.557;

1.557
date	2012.06.03.04.08.07;	author amodra;	state Exp;
branches;
next	1.556;

1.556
date	2012.06.01.16.37.56;	author jkratoch;	state Exp;
branches;
next	1.555;

1.555
date	2012.05.17.06.29.02;	author amodra;	state Exp;
branches;
next	1.554;

1.554
date	2012.05.16.03.35.29;	author amodra;	state Exp;
branches;
next	1.553;

1.553
date	2012.05.08.17.18.21;	author dougkwan;	state Exp;
branches;
next	1.552;

1.552
date	2012.04.24.05.12.30;	author amodra;	state Exp;
branches;
next	1.551;

1.551
date	2012.04.09.16.27.17;	author roland;	state Exp;
branches;
next	1.550;

1.550
date	2012.03.23.09.34.57;	author amodra;	state Exp;
branches;
next	1.549;

1.549
date	2012.02.07.07.04.03;	author amodra;	state Exp;
branches;
next	1.548;

1.548
date	2012.01.23.06.16.37;	author amodra;	state Exp;
branches;
next	1.547;

1.547
date	2012.01.20.09.52.43;	author uweigand;	state Exp;
branches;
next	1.546;

1.546
date	2011.12.13.14.02.18;	author gingold;	state Exp;
branches;
next	1.545;

1.545
date	2011.12.06.14.09.09;	author uweigand;	state Exp;
branches;
next	1.544;

1.544
date	2011.09.30.10.39.44;	author gingold;	state Exp;
branches;
next	1.543;

1.543
date	2011.07.03.13.37.06;	author tschwinge;	state Exp;
branches
	1.543.2.1;
next	1.542;

1.542
date	2011.06.24.03.36.40;	author amodra;	state Exp;
branches;
next	1.541;

1.541
date	2011.06.16.12.34.19;	author nickc;	state Exp;
branches;
next	1.540;

1.540
date	2011.06.15.16.36.56;	author uweigand;	state Exp;
branches;
next	1.539;

1.539
date	2011.06.09.10.36.20;	author nickc;	state Exp;
branches;
next	1.538;

1.538
date	2011.05.23.05.41.00;	author amodra;	state Exp;
branches;
next	1.537;

1.537
date	2011.05.20.15.32.24;	author amodra;	state Exp;
branches;
next	1.536;

1.536
date	2011.05.12.07.41.42;	author jkratoch;	state Exp;
branches;
next	1.535;

1.535
date	2011.05.10.06.13.07;	author jkratoch;	state Exp;
branches;
next	1.534;

1.534
date	2011.05.07.14.12.59;	author hjl;	state Exp;
branches;
next	1.533;

1.533
date	2011.04.28.12.50.32;	author vapier;	state Exp;
branches;
next	1.532;

1.532
date	2011.04.15.11.14.00;	author nickc;	state Exp;
branches;
next	1.531;

1.531
date	2011.04.11.08.13.16;	author nickc;	state Exp;
branches;
next	1.530;

1.530
date	2011.03.14.15.54.58;	author rsandifo;	state Exp;
branches;
next	1.529;

1.529
date	2011.02.08.09.40.05;	author nickc;	state Exp;
branches;
next	1.528;

1.528
date	2011.01.14.12.35.55;	author amodra;	state Exp;
branches;
next	1.527;

1.527
date	2010.12.15.14.56.40;	author hjl;	state Exp;
branches;
next	1.526;

1.526
date	2010.12.12.14.49.25;	author hjl;	state Exp;
branches;
next	1.525;

1.525
date	2010.11.08.02.48.56;	author amodra;	state Exp;
branches;
next	1.524;

1.524
date	2010.10.29.12.10.24;	author hjl;	state Exp;
branches
	1.524.2.1;
next	1.523;

1.523
date	2010.10.08.14.00.46;	author amodra;	state Exp;
branches;
next	1.522;

1.522
date	2010.10.04.14.13.08;	author bernds;	state Exp;
branches;
next	1.521;

1.521
date	2010.09.23.11.40.05;	author amodra;	state Exp;
branches;
next	1.520;

1.520
date	2010.09.16.00.06.11;	author amodra;	state Exp;
branches;
next	1.519;

1.519
date	2010.09.09.19.22.27;	author hjl;	state Exp;
branches;
next	1.518;

1.518
date	2010.08.30.06.01.22;	author amodra;	state Exp;
branches;
next	1.517;

1.517
date	2010.08.25.14.53.40;	author hjl;	state Exp;
branches;
next	1.516;

1.516
date	2010.08.25.06.49.55;	author amodra;	state Exp;
branches;
next	1.515;

1.515
date	2010.08.18.12.24.05;	author palves;	state Exp;
branches;
next	1.514;

1.514
date	2010.08.02.10.08.02;	author amodra;	state Exp;
branches;
next	1.513;

1.513
date	2010.07.20.14.08.31;	author amodra;	state Exp;
branches;
next	1.512;

1.512
date	2010.07.17.03.10.50;	author amodra;	state Exp;
branches;
next	1.511;

1.511
date	2010.05.18.03.31.05;	author hjl;	state Exp;
branches;
next	1.510;

1.510
date	2010.04.24.01.05.24;	author amodra;	state Exp;
branches;
next	1.509;

1.509
date	2010.04.22.01.51.00;	author amodra;	state Exp;
branches;
next	1.508;

1.508
date	2010.04.10.22.21.31;	author hjl;	state Exp;
branches;
next	1.507;

1.507
date	2010.04.09.14.40.15;	author nickc;	state Exp;
branches;
next	1.506;

1.506
date	2010.03.17.13.46.35;	author hjl;	state Exp;
branches;
next	1.505;

1.505
date	2010.02.25.03.49.14;	author amodra;	state Exp;
branches;
next	1.504;

1.504
date	2010.02.19.01.47.13;	author amodra;	state Exp;
branches;
next	1.503;

1.503
date	2010.02.18.00.09.06;	author amodra;	state Exp;
branches;
next	1.502;

1.502
date	2010.02.09.12.14.42;	author sky;	state Exp;
branches;
next	1.501;

1.501
date	2010.02.05.17.08.47;	author sterling;	state Exp;
branches;
next	1.500;

1.500
date	2010.02.04.09.16.38;	author nickc;	state Exp;
branches;
next	1.499;

1.499
date	2010.02.02.12.37.39;	author hjl;	state Exp;
branches;
next	1.498;

1.498
date	2010.01.29.04.32.59;	author brobecke;	state Exp;
branches;
next	1.497;

1.497
date	2010.01.05.00.40.07;	author dgutson;	state Exp;
branches;
next	1.496;

1.496
date	2009.12.18.16.21.50;	author uweigand;	state Exp;
branches;
next	1.495;

1.495
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.494;

1.494
date	2009.12.08.03.43.23;	author amodra;	state Exp;
branches;
next	1.493;

1.493
date	2009.09.28.09.45.33;	author nickc;	state Exp;
branches;
next	1.492;

1.492
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.491;

1.491
date	2009.09.09.15.03.52;	author nickc;	state Exp;
branches;
next	1.490;

1.490
date	2009.08.31.12.02.34;	author jbeulich;	state Exp;
branches
	1.490.2.1;
next	1.489;

1.489
date	2009.08.08.01.43.28;	author amodra;	state Exp;
branches;
next	1.488;

1.488
date	2009.08.06.13.08.24;	author jakub;	state Exp;
branches;
next	1.487;

1.487
date	2009.08.03.23.56.08;	author hjl;	state Exp;
branches;
next	1.486;

1.486
date	2009.07.23.13.00.20;	author nickc;	state Exp;
branches;
next	1.485;

1.485
date	2009.07.10.14.03.02;	author hjl;	state Exp;
branches;
next	1.484;

1.484
date	2009.07.10.10.33.19;	author amodra;	state Exp;
branches;
next	1.483;

1.483
date	2009.06.27.16.07.09;	author hjl;	state Exp;
branches;
next	1.482;

1.482
date	2009.06.18.14.18.28;	author amodra;	state Exp;
branches;
next	1.481;

1.481
date	2009.04.30.15.47.09;	author nickc;	state Exp;
branches;
next	1.480;

1.480
date	2009.03.26.12.23.52;	author amodra;	state Exp;
branches;
next	1.479;

1.479
date	2009.03.18.16.26.54;	author kettenis;	state Exp;
branches;
next	1.478;

1.478
date	2009.03.13.13.39.56;	author hjl;	state Exp;
branches;
next	1.477;

1.477
date	2009.02.25.14.39.35;	author hjl;	state Exp;
branches;
next	1.476;

1.476
date	2009.02.02.03.52.38;	author amodra;	state Exp;
branches;
next	1.475;

1.475
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.474;

1.474
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.473;

1.473
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.472;

1.472
date	2008.11.19.10.09.21;	author nickc;	state Exp;
branches;
next	1.471;

1.471
date	2008.11.14.14.44.08;	author nickc;	state Exp;
branches;
next	1.470;

1.470
date	2008.11.13.03.01.15;	author hp;	state Exp;
branches;
next	1.469;

1.469
date	2008.11.12.22.04.04;	author amodra;	state Exp;
branches;
next	1.468;

1.468
date	2008.11.11.04.26.13;	author amodra;	state Exp;
branches;
next	1.467;

1.467
date	2008.11.10.22.47.58;	author schwab;	state Exp;
branches;
next	1.466;

1.466
date	2008.10.08.08.30.27;	author amodra;	state Exp;
branches;
next	1.465;

1.465
date	2008.10.03.09.40.48;	author amodra;	state Exp;
branches;
next	1.464;

1.464
date	2008.09.29.14.12.02;	author amodra;	state Exp;
branches;
next	1.463;

1.463
date	2008.09.28.13.30.35;	author amodra;	state Exp;
branches;
next	1.462;

1.462
date	2008.08.08.08.00.14;	author amodra;	state Exp;
branches
	1.462.2.1;
next	1.461;

1.461
date	2008.08.07.20.04.32;	author rsandifo;	state Exp;
branches;
next	1.460;

1.460
date	2008.08.01.06.39.04;	author amodra;	state Exp;
branches;
next	1.459;

1.459
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.458;

1.458
date	2008.07.27.03.43.51;	author amodra;	state Exp;
branches;
next	1.457;

1.457
date	2008.07.24.07.51.25;	author nickc;	state Exp;
branches;
next	1.456;

1.456
date	2008.07.22.11.19.01;	author nickc;	state Exp;
branches;
next	1.455;

1.455
date	2008.07.21.16.01.01;	author nickc;	state Exp;
branches;
next	1.454;

1.454
date	2008.07.21.05.33.37;	author luisgpm;	state Exp;
branches;
next	1.453;

1.453
date	2008.07.12.08.54.12;	author jiez;	state Exp;
branches;
next	1.452;

1.452
date	2008.07.11.19.24.38;	author jiez;	state Exp;
branches;
next	1.451;

1.451
date	2008.07.10.01.32.22;	author csilvers;	state Exp;
branches;
next	1.450;

1.450
date	2008.06.30.20.53.06;	author rsandifo;	state Exp;
branches;
next	1.449;

1.449
date	2008.06.30.20.51.58;	author rsandifo;	state Exp;
branches;
next	1.448;

1.448
date	2008.06.04.14.24.05;	author amodra;	state Exp;
branches;
next	1.447;

1.447
date	2008.05.29.07.07.20;	author jkratoch;	state Exp;
branches;
next	1.446;

1.446
date	2008.05.24.16.14.59;	author cseo;	state Exp;
branches;
next	1.445;

1.445
date	2008.05.19.06.06.03;	author amodra;	state Exp;
branches;
next	1.444;

1.444
date	2008.05.03.05.18.02;	author amodra;	state Exp;
branches;
next	1.443;

1.443
date	2008.05.01.17.06.52;	author ccoutant;	state Exp;
branches;
next	1.442;

1.442
date	2008.05.01.14.13.58;	author amodra;	state Exp;
branches;
next	1.441;

1.441
date	2008.04.29.11.53.44;	author drow;	state Exp;
branches;
next	1.440;

1.440
date	2008.03.21.16.22.51;	author nemet;	state Exp;
branches;
next	1.439;

1.439
date	2008.03.13.05.27.42;	author amodra;	state Exp;
branches;
next	1.438;

1.438
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.437;

1.437
date	2008.03.11.23.23.23;	author amodra;	state Exp;
branches;
next	1.436;

1.436
date	2008.02.27.17.06.06;	author clm;	state Exp;
branches;
next	1.435;

1.435
date	2008.02.17.23.45.23;	author kettenis;	state Exp;
branches;
next	1.434;

1.434
date	2008.02.17.13.21.20;	author jkratoch;	state Exp;
branches;
next	1.433;

1.433
date	2008.02.15.08.27.18;	author amodra;	state Exp;
branches;
next	1.432;

1.432
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.431;

1.431
date	2008.02.04.00.09.04;	author amodra;	state Exp;
branches;
next	1.430;

1.430
date	2008.01.31.10.48.35;	author nickc;	state Exp;
branches;
next	1.429;

1.429
date	2007.12.31.11.01.54;	author nickc;	state Exp;
branches;
next	1.428;

1.428
date	2007.12.24.16.58.23;	author hjl;	state Exp;
branches;
next	1.427;

1.427
date	2007.12.24.16.55.39;	author hjl;	state Exp;
branches;
next	1.426;

1.426
date	2007.12.11.13.13.59;	author clm;	state Exp;
branches;
next	1.425;

1.425
date	2007.12.10.23.44.23;	author amodra;	state Exp;
branches;
next	1.424;

1.424
date	2007.11.13.05.56.10;	author amodra;	state Exp;
branches;
next	1.423;

1.423
date	2007.11.12.03.28.52;	author amodra;	state Exp;
branches;
next	1.422;

1.422
date	2007.10.25.00.40.34;	author amodra;	state Exp;
branches;
next	1.421;

1.421
date	2007.10.16.14.42.14;	author nickc;	state Exp;
branches;
next	1.420;

1.420
date	2007.10.12.03.34.45;	author amodra;	state Exp;
branches;
next	1.419;

1.419
date	2007.10.11.05.03.07;	author hjl;	state Exp;
branches;
next	1.418;

1.418
date	2007.09.24.18.23.13;	author drow;	state Exp;
branches;
next	1.417;

1.417
date	2007.09.18.08.17.06;	author amodra;	state Exp;
branches;
next	1.416;

1.416
date	2007.09.18.00.25.07;	author hjl;	state Exp;
branches;
next	1.415;

1.415
date	2007.09.12.10.00.14;	author amodra;	state Exp;
branches;
next	1.414;

1.414
date	2007.09.08.11.03.31;	author amodra;	state Exp;
branches;
next	1.413;

1.413
date	2007.08.25.13.20.41;	author amodra;	state Exp;
branches;
next	1.412;

1.412
date	2007.08.24.21.29.19;	author palves;	state Exp;
branches;
next	1.411;

1.411
date	2007.08.24.15.11.13;	author jkratoch;	state Exp;
branches;
next	1.410;

1.410
date	2007.08.16.18.49.42;	author hjl;	state Exp;
branches;
next	1.409;

1.409
date	2007.08.16.13.38.07;	author hjl;	state Exp;
branches;
next	1.408;

1.408
date	2007.08.13.00.44.20;	author amodra;	state Exp;
branches;
next	1.407;

1.407
date	2007.08.09.23.13.41;	author hjl;	state Exp;
branches;
next	1.406;

1.406
date	2007.08.06.22.53.27;	author amodra;	state Exp;
branches;
next	1.405;

1.405
date	2007.08.06.18.35.18;	author drow;	state Exp;
branches
	1.405.2.1;
next	1.404;

1.404
date	2007.08.01.19.55.10;	author msnyder;	state Exp;
branches;
next	1.403;

1.403
date	2007.08.01.08.57.23;	author jakub;	state Exp;
branches;
next	1.402;

1.402
date	2007.07.31.08.15.44;	author jakub;	state Exp;
branches;
next	1.401;

1.401
date	2007.07.26.18.15.46;	author msnyder;	state Exp;
branches;
next	1.400;

1.400
date	2007.07.24.08.09.20;	author amodra;	state Exp;
branches;
next	1.399;

1.399
date	2007.07.18.11.23.37;	author amodra;	state Exp;
branches;
next	1.398;

1.398
date	2007.07.13.10.44.12;	author roland;	state Exp;
branches;
next	1.397;

1.397
date	2007.07.09.21.23.43;	author roland;	state Exp;
branches;
next	1.396;

1.396
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.395;

1.395
date	2007.07.02.06.47.43;	author amodra;	state Exp;
branches;
next	1.394;

1.394
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	1.393;

1.393
date	2007.06.29.01.21.08;	author amodra;	state Exp;
branches;
next	1.392;

1.392
date	2007.06.29.01.12.52;	author amodra;	state Exp;
branches;
next	1.391;

1.391
date	2007.05.30.14.29.27;	author amodra;	state Exp;
branches;
next	1.390;

1.390
date	2007.05.30.13.38.50;	author amodra;	state Exp;
branches;
next	1.389;

1.389
date	2007.05.15.08.39.58;	author amodra;	state Exp;
branches;
next	1.388;

1.388
date	2007.05.14.04.15.53;	author amodra;	state Exp;
branches;
next	1.387;

1.387
date	2007.05.10.14.46.48;	author rsandifo;	state Exp;
branches;
next	1.386;

1.386
date	2007.05.07.01.05.46;	author amodra;	state Exp;
branches;
next	1.385;

1.385
date	2007.05.02.13.44.37;	author amodra;	state Exp;
branches;
next	1.384;

1.384
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.383;

1.383
date	2007.04.17.20.09.51;	author pbrook;	state Exp;
branches;
next	1.382;

1.382
date	2007.03.29.14.37.02;	author nickc;	state Exp;
branches;
next	1.381;

1.381
date	2007.03.22.15.50.37;	author hjl;	state Exp;
branches;
next	1.380;

1.380
date	2007.03.20.12.18.18;	author nickc;	state Exp;
branches;
next	1.379;

1.379
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.378;

1.378
date	2007.03.07.02.14.40;	author amodra;	state Exp;
branches;
next	1.377;

1.377
date	2007.02.23.11.47.47;	author nickc;	state Exp;
branches;
next	1.376;

1.376
date	2007.02.21.16.43.46;	author nickc;	state Exp;
branches;
next	1.375;

1.375
date	2007.02.05.19.50.12;	author brolley;	state Exp;
branches;
next	1.374;

1.374
date	2007.02.02.21.10.50;	author jakub;	state Exp;
branches;
next	1.373;

1.373
date	2007.02.01.09.03.25;	author nickc;	state Exp;
branches;
next	1.372;

1.372
date	2007.02.01.05.35.58;	author amodra;	state Exp;
branches;
next	1.371;

1.371
date	2007.01.30.15.47.19;	author hjl;	state Exp;
branches;
next	1.370;

1.370
date	2007.01.11.12.23.53;	author nathan;	state Exp;
branches;
next	1.369;

1.369
date	2006.12.19.08.49.38;	author nathan;	state Exp;
branches;
next	1.368;

1.368
date	2006.12.01.15.55.29;	author hjl;	state Exp;
branches;
next	1.367;

1.367
date	2006.12.01.12.28.18;	author nickc;	state Exp;
branches;
next	1.366;

1.366
date	2006.11.25.00.38.14;	author hjl;	state Exp;
branches;
next	1.365;

1.365
date	2006.10.31.02.36.18;	author amodra;	state Exp;
branches;
next	1.364;

1.364
date	2006.10.30.23.25.49;	author hjl;	state Exp;
branches;
next	1.363;

1.363
date	2006.10.29.23.49.37;	author amodra;	state Exp;
branches;
next	1.362;

1.362
date	2006.10.27.04.15.50;	author hjl;	state Exp;
branches;
next	1.361;

1.361
date	2006.10.26.00.14.39;	author bje;	state Exp;
branches;
next	1.360;

1.360
date	2006.10.26.00.01.31;	author bje;	state Exp;
branches;
next	1.359;

1.359
date	2006.10.15.14.22.13;	author hjl;	state Exp;
branches;
next	1.358;

1.358
date	2006.09.27.04.18.15;	author hjl;	state Exp;
branches;
next	1.357;

1.357
date	2006.09.26.19.11.03;	author hjl;	state Exp;
branches;
next	1.356;

1.356
date	2006.09.22.13.16.45;	author amodra;	state Exp;
branches;
next	1.355;

1.355
date	2006.09.17.18.57.43;	author hp;	state Exp;
branches;
next	1.354;

1.354
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.353;

1.353
date	2006.09.14.12.11.33;	author amodra;	state Exp;
branches;
next	1.352;

1.352
date	2006.09.10.23.51.09;	author hjl;	state Exp;
branches;
next	1.351;

1.351
date	2006.08.17.02.04.53;	author hjl;	state Exp;
branches;
next	1.350;

1.350
date	2006.07.26.12.32.27;	author amodra;	state Exp;
branches;
next	1.349;

1.349
date	2006.07.24.18.18.16;	author nickc;	state Exp;
branches;
next	1.348;

1.348
date	2006.07.10.21.40.23;	author jakub;	state Exp;
branches;
next	1.347;

1.347
date	2006.06.23.02.58.00;	author amodra;	state Exp;
branches;
next	1.346;

1.346
date	2006.06.20.14.34.08;	author amodra;	state Exp;
branches;
next	1.345;

1.345
date	2006.06.20.09.58.36;	author jakub;	state Exp;
branches;
next	1.344;

1.344
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.343;

1.343
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.342;

1.342
date	2006.06.06.02.53.01;	author amodra;	state Exp;
branches;
next	1.341;

1.341
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.340;

1.340
date	2006.05.27.00.47.45;	author amodra;	state Exp;
branches;
next	1.339;

1.339
date	2006.05.25.15.08.28;	author amodra;	state Exp;
branches;
next	1.338;

1.338
date	2006.05.19.00.51.28;	author amodra;	state Exp;
branches;
next	1.337;

1.337
date	2006.05.17.05.09.24;	author amodra;	state Exp;
branches;
next	1.336;

1.336
date	2006.05.11.12.34.46;	author amodra;	state Exp;
branches;
next	1.335;

1.335
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.334;

1.334
date	2006.05.02.10.01.56;	author bje;	state Exp;
branches;
next	1.333;

1.333
date	2006.04.26.13.32.26;	author hjl;	state Exp;
branches;
next	1.332;

1.332
date	2006.04.25.17.46.15;	author hjl;	state Exp;
branches;
next	1.331;

1.331
date	2006.04.21.07.26.09;	author amodra;	state Exp;
branches;
next	1.330;

1.330
date	2006.04.21.03.42.47;	author hjl;	state Exp;
branches;
next	1.329;

1.329
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.329.2.1;
next	1.328;

1.328
date	2006.02.16.18.07.54;	author hjl;	state Exp;
branches;
next	1.327;

1.327
date	2006.02.10.17.13.23;	author hjl;	state Exp;
branches;
next	1.326;

1.326
date	2006.02.10.15.04.19;	author hjl;	state Exp;
branches;
next	1.325;

1.325
date	2006.01.17.11.09.56;	author nickc;	state Exp;
branches;
next	1.324;

1.324
date	2006.01.17.10.34.43;	author nickc;	state Exp;
branches;
next	1.323;

1.323
date	2005.12.27.09.22.59;	author amodra;	state Exp;
branches;
next	1.322;

1.322
date	2005.12.27.03.45.30;	author amodra;	state Exp;
branches;
next	1.321;

1.321
date	2005.12.13.15.34.28;	author hjl;	state Exp;
branches;
next	1.320;

1.320
date	2005.12.08.01.34.13;	author hjl;	state Exp;
branches;
next	1.319;

1.319
date	2005.12.07.19.21.44;	author hjl;	state Exp;
branches;
next	1.318;

1.318
date	2005.11.03.02.53.38;	author amodra;	state Exp;
branches;
next	1.317;

1.317
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.316;

1.316
date	2005.10.24.01.40.58;	author hjl;	state Exp;
branches;
next	1.315;

1.315
date	2005.10.15.14.57.54;	author hjl;	state Exp;
branches;
next	1.314;

1.314
date	2005.10.05.21.24.23;	author bwilson;	state Exp;
branches;
next	1.313;

1.313
date	2005.10.03.03.41.56;	author amodra;	state Exp;
branches;
next	1.312;

1.312
date	2005.09.28.14.53.23;	author hjl;	state Exp;
branches;
next	1.311;

1.311
date	2005.07.25.15.41.02;	author hjl;	state Exp;
branches;
next	1.310;

1.310
date	2005.07.25.15.35.37;	author hjl;	state Exp;
branches;
next	1.309;

1.309
date	2005.07.08.00.26.43;	author hjl;	state Exp;
branches;
next	1.308;

1.308
date	2005.07.05.09.44.20;	author jakub;	state Exp;
branches;
next	1.307;

1.307
date	2005.07.05.09.38.45;	author jakub;	state Exp;
branches;
next	1.306;

1.306
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.305;

1.305
date	2005.07.04.10.30.09;	author amodra;	state Exp;
branches;
next	1.304;

1.304
date	2005.07.04.01.53.38;	author amodra;	state Exp;
branches;
next	1.303;

1.303
date	2005.06.17.15.48.25;	author jakub;	state Exp;
branches;
next	1.302;

1.302
date	2005.06.17.13.39.56;	author jakub;	state Exp;
branches;
next	1.301;

1.301
date	2005.06.14.11.04.22;	author jakub;	state Exp;
branches;
next	1.300;

1.300
date	2005.06.06.14.28.30;	author hjl;	state Exp;
branches;
next	1.299;

1.299
date	2005.05.23.17.44.53;	author fnf;	state Exp;
branches;
next	1.298;

1.298
date	2005.05.19.08.26.51;	author amodra;	state Exp;
branches;
next	1.297;

1.297
date	2005.05.19.06.51.01;	author amodra;	state Exp;
branches;
next	1.296;

1.296
date	2005.05.18.13.41.59;	author hjl;	state Exp;
branches;
next	1.295;

1.295
date	2005.05.17.19.44.55;	author drow;	state Exp;
branches;
next	1.294;

1.294
date	2005.05.17.18.08.08;	author nickc;	state Exp;
branches;
next	1.293;

1.293
date	2005.05.17.16.23.26;	author nickc;	state Exp;
branches;
next	1.292;

1.292
date	2005.05.11.02.15.46;	author hjl;	state Exp;
branches;
next	1.291;

1.291
date	2005.05.07.13.22.45;	author hjl;	state Exp;
branches;
next	1.290;

1.290
date	2005.05.05.17.22.40;	author hjl;	state Exp;
branches;
next	1.289;

1.289
date	2005.05.05.14.33.44;	author hjl;	state Exp;
branches;
next	1.288;

1.288
date	2005.05.05.14.25.23;	author nickc;	state Exp;
branches;
next	1.287;

1.287
date	2005.05.04.15.53.11;	author nickc;	state Exp;
branches;
next	1.286;

1.286
date	2005.05.04.11.00.10;	author amodra;	state Exp;
branches;
next	1.285;

1.285
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.284;

1.284
date	2005.05.03.17.05.50;	author amodra;	state Exp;
branches;
next	1.283;

1.283
date	2005.05.03.01.05.00;	author hjl;	state Exp;
branches;
next	1.282;

1.282
date	2005.05.02.14.00.16;	author hjl;	state Exp;
branches;
next	1.281;

1.281
date	2005.04.27.20.16.06;	author hjl;	state Exp;
branches;
next	1.280;

1.280
date	2005.04.21.12.13.37;	author schwab;	state Exp;
branches;
next	1.279;

1.279
date	2005.04.18.03.13.49;	author hjl;	state Exp;
branches;
next	1.278;

1.278
date	2005.04.18.03.12.51;	author hjl;	state Exp;
branches;
next	1.277;

1.277
date	2005.04.05.04.01.09;	author hjl;	state Exp;
branches;
next	1.276;

1.276
date	2005.04.05.02.47.18;	author hjl;	state Exp;
branches;
next	1.275;

1.275
date	2005.04.01.20.52.24;	author hjl;	state Exp;
branches;
next	1.274;

1.274
date	2005.04.01.03.49.45;	author hjl;	state Exp;
branches;
next	1.273;

1.273
date	2005.04.01.00.30.49;	author hjl;	state Exp;
branches;
next	1.272;

1.272
date	2005.03.29.08.51.59;	author brobecke;	state Exp;
branches;
next	1.271;

1.271
date	2005.03.20.23.36.15;	author hjl;	state Exp;
branches;
next	1.270;

1.270
date	2005.03.06.02.02.15;	author amodra;	state Exp;
branches
	1.270.2.1;
next	1.269;

1.269
date	2005.03.03.20.52.31;	author hjl;	state Exp;
branches;
next	1.268;

1.268
date	2005.03.02.04.47.24;	author zack;	state Exp;
branches;
next	1.267;

1.267
date	2005.02.23.09.46.48;	author nickc;	state Exp;
branches;
next	1.266;

1.266
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.265;

1.265
date	2005.02.11.16.41.09;	author pbrook;	state Exp;
branches;
next	1.264;

1.264
date	2005.02.06.23.21.44;	author amodra;	state Exp;
branches;
next	1.263;

1.263
date	2005.01.31.23.13.18;	author bje;	state Exp;
branches;
next	1.262;

1.262
date	2005.01.31.22.53.25;	author bje;	state Exp;
branches;
next	1.261;

1.261
date	2005.01.25.10.33.52;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2005.01.07.09.52.00;	author jakub;	state Exp;
branches;
next	1.259;

1.259
date	2004.12.22.14.43.44;	author kewarken;	state Exp;
branches;
next	1.258;

1.258
date	2004.12.10.14.04.55;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2004.12.10.13.18.37;	author amodra;	state Exp;
branches;
next	1.256;

1.256
date	2004.12.10.13.08.03;	author jakub;	state Exp;
branches;
next	1.255;

1.255
date	2004.12.03.13.59.36;	author jbeulich;	state Exp;
branches;
next	1.254;

1.254
date	2004.11.25.00.55.57;	author pbrook;	state Exp;
branches;
next	1.253;

1.253
date	2004.11.15.23.21.23;	author pbrook;	state Exp;
branches;
next	1.252;

1.252
date	2004.11.04.00.44.23;	author bwilson;	state Exp;
branches;
next	1.251;

1.251
date	2004.10.14.23.38.08;	author amodra;	state Exp;
branches;
next	1.250;

1.250
date	2004.10.11.13.48.36;	author jakub;	state Exp;
branches;
next	1.249;

1.249
date	2004.10.07.15.00.19;	author nickc;	state Exp;
branches;
next	1.248;

1.248
date	2004.10.07.14.57.56;	author nickc;	state Exp;
branches;
next	1.247;

1.247
date	2004.09.24.03.13.01;	author amodra;	state Exp;
branches;
next	1.246;

1.246
date	2004.09.22.06.45.38;	author amodra;	state Exp;
branches;
next	1.245;

1.245
date	2004.09.17.07.14.25;	author amodra;	state Exp;
branches;
next	1.244;

1.244
date	2004.09.16.14.52.02;	author amodra;	state Exp;
branches;
next	1.243;

1.243
date	2004.09.10.00.27.10;	author amodra;	state Exp;
branches;
next	1.242;

1.242
date	2004.09.06.20.55.22;	author mmitchel;	state Exp;
branches;
next	1.241;

1.241
date	2004.08.31.09.41.11;	author ebotcazou;	state Exp;
branches;
next	1.240;

1.240
date	2004.08.28.03.05.17;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2004.08.17.09.07.35;	author jakub;	state Exp;
branches;
next	1.238;

1.238
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.237;

1.237
date	2004.07.30.15.37.04;	author hjl;	state Exp;
branches;
next	1.236;

1.236
date	2004.07.27.14.20.47;	author hjl;	state Exp;
branches;
next	1.235;

1.235
date	2004.07.26.21.01.15;	author hjl;	state Exp;
branches;
next	1.234;

1.234
date	2004.07.19.16.40.45;	author hjl;	state Exp;
branches;
next	1.233;

1.233
date	2004.07.09.16.06.20;	author nickc;	state Exp;
branches;
next	1.232;

1.232
date	2004.06.28.13.57.58;	author amodra;	state Exp;
branches;
next	1.231;

1.231
date	2004.06.24.04.46.18;	author amodra;	state Exp;
branches;
next	1.230;

1.230
date	2004.05.27.05.53.35;	author hjl;	state Exp;
branches;
next	1.229;

1.229
date	2004.05.26.10.23.49;	author amodra;	state Exp;
branches;
next	1.228;

1.228
date	2004.05.25.06.33.46;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2004.05.22.01.56.30;	author amodra;	state Exp;
branches;
next	1.226;

1.226
date	2004.05.17.16.40.00;	author bwilson;	state Exp;
branches;
next	1.225;

1.225
date	2004.05.11.17.08.37;	author jakub;	state Exp;
branches;
next	1.224;

1.224
date	2004.04.30.15.04.30;	author hjl;	state Exp;
branches;
next	1.223;

1.223
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.222;

1.222
date	2004.04.27.03.13.14;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.220;

1.220
date	2004.03.30.09.58.28;	author jakub;	state Exp;
branches;
next	1.219;

1.219
date	2004.03.18.12.50.19;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2004.03.05.11.26.04;	author nathan;	state Exp;
branches
	1.218.2.1;
next	1.217;

1.217
date	2004.02.13.14.58.58;	author cagney;	state Exp;
branches
	1.217.4.1
	1.217.6.1;
next	1.216;

1.216
date	2004.02.09.08.04.00;	author rsandifo;	state Exp;
branches;
next	1.215;

1.215
date	2003.12.11.18.10.19;	author nickc;	state Exp;
branches
	1.215.2.1;
next	1.214;

1.214
date	2003.12.01.06.28.23;	author amodra;	state Exp;
branches;
next	1.213;

1.213
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches;
next	1.212;

1.212
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.211;

1.211
date	2003.11.27.12.28.35;	author kettenis;	state Exp;
branches;
next	1.210;

1.210
date	2003.11.22.10.45.44;	author jakub;	state Exp;
branches;
next	1.209;

1.209
date	2003.11.17.21.31.10;	author drow;	state Exp;
branches;
next	1.208;

1.208
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches;
next	1.207;

1.207
date	2003.11.04.10.41.51;	author amodra;	state Exp;
branches;
next	1.206;

1.206
date	2003.11.04.06.16.33;	author amodra;	state Exp;
branches;
next	1.205;

1.205
date	2003.10.31.05.32.45;	author cagney;	state Exp;
branches;
next	1.204;

1.204
date	2003.10.29.11.15.24;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2003.10.20.14.38.39;	author cagney;	state Exp;
branches;
next	1.202;

1.202
date	2003.10.16.18.55.48;	author roland;	state Exp;
branches;
next	1.201;

1.201
date	2003.10.16.04.11.05;	author cagney;	state Exp;
branches;
next	1.200;

1.200
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.199;

1.199
date	2003.09.19.02.08.35;	author amodra;	state Exp;
branches;
next	1.198;

1.198
date	2003.08.07.08.38.07;	author amodra;	state Exp;
branches
	1.198.6.1;
next	1.197;

1.197
date	2003.08.04.09.39.46;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2003.07.31.14.34.13;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2003.07.30.02.08.06;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2003.07.28.14.21.44;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2003.07.26.01.06.27;	author hjl;	state Exp;
branches;
next	1.192;

1.192
date	2003.07.25.14.35.55;	author hjl;	state Exp;
branches;
next	1.191;

1.191
date	2003.07.07.15.51.57;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2003.06.03.22.27.22;	author jakub;	state Exp;
branches;
next	1.188;

1.188
date	2003.05.29.23.50.04;	author amodra;	state Exp;
branches;
next	1.187;

1.187
date	2003.05.21.09.23.07;	author nickc;	state Exp;
branches;
next	1.186;

1.186
date	2003.05.21.00.56.00;	author roland;	state Exp;
branches;
next	1.185;

1.185
date	2003.05.13.15.32.19;	author aph;	state Exp;
branches;
next	1.184;

1.184
date	2003.05.09.10.58.12;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2003.05.09.02.27.00;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2003.04.24.17.19.37;	author roland;	state Exp;
branches
	1.182.2.1;
next	1.181;

1.181
date	2003.03.31.18.13.25;	author nickc;	state Exp;
branches
	1.181.6.1;
next	1.180;

1.180
date	2003.02.24.18.07.22;	author nickc;	state Exp;
branches;
next	1.179;

1.179
date	2003.02.17.18.13.18;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2003.02.07.14.27.59;	author nickc;	state Exp;
branches;
next	1.177;

1.177
date	2003.02.04.12.49.57;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2003.02.04.12.34.08;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2002.12.28.21.15.35;	author jakub;	state Exp;
branches;
next	1.173;

1.173
date	2002.12.12.10.26.01;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2002.11.28.11.55.37;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2002.11.26.11.53.59;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2002.11.20.18.17.04;	author aoliva;	state Exp;
branches;
next	1.168;

1.168
date	2002.11.12.07.35.26;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2002.11.06.12.04.31;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2002.11.06.11.38.35;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2002.11.04.13.20.56;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2002.10.19.13.52.58;	author kettenis;	state Exp;
branches;
next	1.163;

1.163
date	2002.09.28.03.25.56;	author amodra;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2002.09.18.02.39.42;	author drow;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2002.09.11.14.30.53;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2002.08.22.01.27.20;	author amodra;	state Exp;
branches
	1.160.6.1;
next	1.159;

1.159
date	2002.08.17.16.09.02;	author cagney;	state Exp;
branches;
next	1.158;

1.158
date	2002.07.30.14.28.54;	author jakub;	state Exp;
branches;
next	1.157;

1.157
date	2002.07.23.18.02.32;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2002.07.23.11.15.06;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2002.07.10.04.59.42;	author amodra;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2002.07.08.08.13.37;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2002.07.07.09.10.39;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2002.07.04.13.26.30;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2002.07.02.04.31.22;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2002.06.25.09.40.43;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2002.06.25.06.21.51;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2002.06.23.02.04.28;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2002.06.09.03.08.54;	author hjl;	state Exp;
branches;
next	1.146;

1.146
date	2002.06.07.14.57.10;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2002.06.06.10.03.36;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	2002.06.05.14.06.12;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2002.06.05.03.43.09;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2002.06.04.01.05.21;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2002.05.31.02.59.47;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2002.05.23.13.12.43;	author jakub;	state Exp;
branches
	1.139.2.1;
next	1.138;

1.138
date	2002.05.15.00.18.55;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2002.04.12.03.30.56;	author amodra;	state Exp;
branches
	1.137.4.1;
next	1.136;

1.136
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches;
next	1.135;

1.135
date	2002.04.03.13.26.34;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2002.04.01.18.31.46;	author thorpej;	state Exp;
branches;
next	1.133;

1.133
date	2002.03.27.00.16.54;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2002.03.23.13.14.33;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2002.03.04.20.41.55;	author hjl;	state Exp;
branches;
next	1.130;

1.130
date	2002.02.14.04.12.24;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2002.02.13.21.53.31;	author msnyder;	state Exp;
branches;
next	1.128;

1.128
date	2002.02.13.10.20.59;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2002.01.30.10.31.28;	author nickc;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2002.01.26.10.32.21;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2002.01.25.18.56.59;	author kettenis;	state Exp;
branches;
next	1.124;

1.124
date	2002.01.21.10.29.08;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2002.01.17.13.02.40;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2002.01.15.12.52.14;	author jakub;	state Exp;
branches;
next	1.121;

1.121
date	2002.01.10.23.05.21;	author msnyder;	state Exp;
branches;
next	1.120;

1.120
date	2002.01.09.18.59.11;	author thorpej;	state Exp;
branches;
next	1.119;

1.119
date	2002.01.08.21.31.35;	author msnyder;	state Exp;
branches;
next	1.118;

1.118
date	2002.01.08.16.42.57;	author aoliva;	state Exp;
branches;
next	1.117;

1.117
date	2001.12.19.05.16.47;	author msnyder;	state Exp;
branches;
next	1.116;

1.116
date	2001.12.18.19.03.23;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2001.12.18.18.11.52;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2001.12.18.17.59.58;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2001.12.18.07.53.11;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2001.12.17.00.52.34;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	1.110;

1.110
date	2001.12.07.12.32.42;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2001.12.07.11.12.17;	author jakub;	state Exp;
branches;
next	1.108;

1.108
date	2001.11.29.10.34.01;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2001.11.23.12.17.15;	author jakub;	state Exp;
branches;
next	1.106;

1.106
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2001.11.07.16.50.38;	author jakub;	state Exp;
branches;
next	1.104;

1.104
date	2001.10.30.11.40.28;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2001.10.30.11.34.46;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2001.10.17.12.01.05;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2001.10.15.09.45.45;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2001.10.10.11.19.54;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2001.10.09.13.12.19;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.09.06.05.14;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.03.08.33.18;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2001.09.30.03.03.11;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2001.09.29.06.21.58;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2001.09.12.23.53.31;	author aoliva;	state Exp;
branches;
next	1.90;

1.90
date	2001.08.29.17.23.15;	author law;	state Exp;
branches;
next	1.89;

1.89
date	2001.08.29.01.33.52;	author amylaar;	state Exp;
branches;
next	1.88;

1.88
date	2001.08.27.10.22.03;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2001.08.26.11.46.04;	author aj;	state Exp;
branches;
next	1.86;

1.86
date	2001.08.24.20.10.25;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2001.08.24.16.36.04;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2001.08.23.15.14.15;	author jakub;	state Exp;
branches;
next	1.82;

1.82
date	2001.08.21.01.02.41;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2001.08.19.23.42.47;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2001.08.11.16.48.15;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2001.08.10.08.06.23;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2001.08.09.21.10.25;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2001.08.09.16.00.21;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2001.08.01.16.10.42;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2001.06.30.04.05.12;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2001.06.30.03.15.46;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.10.05.20.59;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.08.15.30.52;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2001.05.23.08.23.27;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.68;

1.68
date	2001.05.07.09.15.25;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2001.04.30.16.13.26;	author hjl;	state Exp;
branches;
next	1.66;

1.66
date	2001.04.24.15.08.15;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.64;

1.64
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2001.02.14.19.58.45;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2001.02.10.00.55.54;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2000.12.12.19.23.15;	author nickc;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2000.12.08.22.50.07;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2000.11.30.19.16.54;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2000.10.11.07.05.01;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2000.10.07.12.52.15;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2000.10.05.22.22.27;	author wilson;	state Exp;
branches;
next	1.55;

1.55
date	2000.09.30.00.44.49;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2000.09.29.07.14.05;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2000.09.29.07.01.18;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.11.17.01.47;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2000.09.07.20.20.05;	author kazu;	state Exp;
branches;
next	1.50;

1.50
date	2000.09.02.20.33.48;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.30.18.12.03;	author msnyder;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.22.19.33.16;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.03.19.40.29;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.03.13.50.35;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.31.18.45.26;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.20.16.21.06;	author hp;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.20.03.16.18;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.20.02.19.23;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.19.18.26.38;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.19.18.02.13;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.18.19.20.12;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2000.07.11.07.28.25;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.19.00.18.57;	author ulfc;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.06.20.00.33;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.06.00.08.01;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2000.05.31.17.27.51;	author drepper;	state Exp;
branches;
next	1.32;

1.32
date	2000.05.29.05.16.19;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.09.00.43.44;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.05.18.12.53;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.02.17.51.36;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.21.20.22.21;	author wilson;	state Exp;
branches;
next	1.27;

1.27
date	2000.03.27.08.39.12;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.03.06.15.44.25;	author clm;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.23.13.52.20;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.18.09.23.06;	author rth;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.13.23.11.32;	author rth;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.10.18.50.16;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.03.18.32.21;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	99.12.07.23.51.02;	author jimb;	state Exp;
branches;
next	1.19;

1.19
date	99.11.29.20.32.30;	author jimb;	state Exp;
branches;
next	1.18;

1.18
date	99.11.26.09.52.23;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	99.09.24.17.06.35;	author rth;	state Exp;
branches;
next	1.16;

1.16
date	99.09.04.17.07.46;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	99.07.30.21.34.43;	author rth;	state Exp;
branches;
next	1.14;

1.14
date	99.07.13.20.10.26;	author rth;	state Exp;
branches;
next	1.13;

1.13
date	99.07.13.17.30.21;	author rth;	state Exp;
branches;
next	1.12;

1.12
date	99.07.11.19.49.31;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.07.11.17.13.35;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.07.07.17.50.50;	author mmitchel;	state Exp;
branches;
next	1.9;

1.9
date	99.07.02.21.03.51;	author mmitchel;	state Exp;
branches;
next	1.8;

1.8
date	99.07.01.23.20.06;	author mmitchel;	state Exp;
branches;
next	1.7;

1.7
date	99.06.22.21.25.49;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.04.01.07.38;	author schwab;	state Exp;
branches;
next	1.5;

1.5
date	99.06.02.13.00.59;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	99.05.28.13.24.31;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.05.27.21.42.13;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.10.08.36.58;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.591.2.1
date	2013.10.17.10.09.04;	author amodra;	state Exp;
branches;
next	;

1.568.2.1
date	2013.01.21.13.48.35;	author amodra;	state Exp;
branches;
next	1.568.2.2;

1.568.2.2
date	2013.02.07.04.21.35;	author amodra;	state Exp;
branches;
next	1.568.2.3;

1.568.2.3
date	2013.02.08.07.05.11;	author amodra;	state Exp;
branches;
next	;

1.543.2.1
date	2012.05.11.12.24.20;	author nickc;	state Exp;
branches;
next	;

1.524.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	1.524.2.2;

1.524.2.2
date	2011.04.27.07.17.36;	author amodra;	state Exp;
branches;
next	1.524.2.3;

1.524.2.3
date	2011.05.29.04.51.07;	author amodra;	state Exp;
branches;
next	1.524.2.4;

1.524.2.4
date	2011.06.24.03.39.32;	author amodra;	state Exp;
branches;
next	;

1.490.2.1
date	2009.09.09.15.05.49;	author nickc;	state Exp;
branches;
next	1.490.2.2;

1.490.2.2
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.462.2.1
date	2008.09.30.01.16.21;	author amodra;	state Exp;
branches;
next	1.462.2.2;

1.462.2.2
date	2008.10.09.01.03.17;	author amodra;	state Exp;
branches;
next	1.462.2.3;

1.462.2.3
date	2008.12.23.10.06.46;	author nickc;	state Exp;
branches;
next	1.462.2.4;

1.462.2.4
date	2009.03.02.13.31.13;	author amodra;	state Exp;
branches;
next	1.462.2.5;

1.462.2.5
date	2009.03.02.13.32.54;	author amodra;	state Exp;
branches;
next	1.462.2.6;

1.462.2.6
date	2009.03.02.13.39.26;	author amodra;	state Exp;
branches;
next	1.462.2.7;

1.462.2.7
date	2009.03.02.13.40.15;	author amodra;	state Exp;
branches;
next	1.462.2.8;

1.462.2.8
date	2009.03.02.13.41.07;	author amodra;	state Exp;
branches;
next	;

1.405.2.1
date	2007.08.07.00.06.14;	author amodra;	state Exp;
branches;
next	1.405.2.2;

1.405.2.2
date	2007.08.15.04.35.45;	author amodra;	state Exp;
branches;
next	1.405.2.3;

1.405.2.3
date	2007.08.25.23.00.14;	author amodra;	state Exp;
branches;
next	1.405.2.4;

1.405.2.4
date	2007.10.25.15.31.26;	author jsm28;	state Exp;
branches;
next	;

1.329.2.1
date	2006.05.25.16.49.50;	author jules;	state Exp;
branches;
next	1.329.2.2;

1.329.2.2
date	2006.11.29.16.31.06;	author shinwell;	state Exp;
branches;
next	;

1.270.2.1
date	2005.05.30.13.13.16;	author drow;	state Exp;
branches;
next	;

1.218.2.1
date	2004.03.21.23.57.25;	author cagney;	state Exp;
branches;
next	;

1.217.4.1
date	2004.03.05.11.41.59;	author nathan;	state Exp;
branches;
next	1.217.4.2;

1.217.4.2
date	2004.04.08.12.41.36;	author amodra;	state Exp;
branches;
next	1.217.4.3;

1.217.4.3
date	2004.08.10.03.11.57;	author amodra;	state Exp;
branches;
next	1.217.4.4;

1.217.4.4
date	2004.09.07.07.11.06;	author ebotcazou;	state Exp;
branches;
next	;

1.217.6.1
date	2004.03.27.17.37.31;	author drow;	state Exp;
branches;
next	1.217.6.2;

1.217.6.2
date	2004.04.02.16.47.33;	author drow;	state Exp;
branches;
next	1.217.6.3;

1.217.6.3
date	2004.09.16.17.00.21;	author drow;	state Exp;
branches;
next	1.217.6.4;

1.217.6.4
date	2004.09.21.20.44.01;	author drow;	state Exp;
branches;
next	;

1.215.2.1
date	2004.01.22.17.03.44;	author cagney;	state Exp;
branches;
next	;

1.198.6.1
date	2003.12.12.23.18.54;	author kettenis;	state Exp;
branches;
next	;

1.182.2.1
date	2003.05.09.11.38.06;	author amodra;	state Exp;
branches;
next	1.182.2.2;

1.182.2.2
date	2003.05.13.15.35.00;	author aph;	state Exp;
branches;
next	1.182.2.3;

1.182.2.3
date	2003.06.02.18.13.34;	author drow;	state Exp;
branches;
next	;

1.181.6.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	1.181.6.2;

1.181.6.2
date	2003.05.18.09.43.39;	author kettenis;	state Exp;
branches;
next	;

1.163.2.1
date	2002.10.26.17.11.57;	author drow;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	;

1.162.2.1
date	2002.10.11.22.22.47;	author carlton;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2002.10.25.23.49.47;	author carlton;	state Exp;
branches;
next	1.162.2.3;

1.162.2.3
date	2002.11.15.19.18.25;	author carlton;	state Exp;
branches;
next	1.162.2.4;

1.162.2.4
date	2002.12.23.19.37.38;	author carlton;	state Exp;
branches;
next	1.162.2.5;

1.162.2.5
date	2003.02.07.19.17.37;	author carlton;	state Exp;
branches;
next	1.162.2.6;

1.162.2.6
date	2003.03.06.00.56.14;	author carlton;	state Exp;
branches;
next	1.162.2.7;

1.162.2.7
date	2003.04.16.19.56.42;	author carlton;	state Exp;
branches;
next	1.162.2.8;

1.162.2.8
date	2003.05.01.00.46.40;	author carlton;	state Exp;
branches;
next	1.162.2.9;

1.162.2.9
date	2003.05.23.18.40.22;	author carlton;	state Exp;
branches;
next	1.162.2.10;

1.162.2.10
date	2003.06.27.21.49.11;	author carlton;	state Exp;
branches;
next	1.162.2.11;

1.162.2.11
date	2003.08.05.17.12.45;	author carlton;	state Exp;
branches;
next	1.162.2.12;

1.162.2.12
date	2003.09.17.21.27.50;	author carlton;	state Exp;
branches;
next	1.162.2.13;

1.162.2.13
date	2003.11.11.23.50.13;	author carlton;	state Exp;
branches;
next	1.162.2.14;

1.162.2.14
date	2003.12.15.23.59.21;	author carlton;	state Exp;
branches;
next	;

1.160.6.1
date	2002.10.19.22.44.54;	author kettenis;	state Exp;
branches;
next	;

1.155.2.1
date	2002.07.23.18.01.58;	author nickc;	state Exp;
branches;
next	1.155.2.2;

1.155.2.2
date	2002.07.30.18.19.42;	author drow;	state Exp;
branches;
next	1.155.2.3;

1.155.2.3
date	2002.08.22.01.34.16;	author amodra;	state Exp;
branches;
next	1.155.2.4;

1.155.2.4
date	2002.09.22.04.04.36;	author obrien;	state Exp;
branches;
next	1.155.2.5;

1.155.2.5
date	2002.09.23.22.12.39;	author drow;	state Exp;
branches;
next	1.155.2.6;

1.155.2.6
date	2002.09.28.03.26.50;	author amodra;	state Exp;
branches;
next	1.155.2.7;

1.155.2.7
date	2002.11.07.16.57.33;	author drow;	state Exp;
branches;
next	1.155.2.8;

1.155.2.8
date	2002.11.27.20.08.05;	author obrien;	state Exp;
branches;
next	;

1.139.2.1
date	2002.06.20.01.30.02;	author kseitz;	state Exp;
branches;
next	1.139.2.2;

1.139.2.2
date	2002.07.22.21.46.42;	author kseitz;	state Exp;
branches;
next	1.139.2.3;

1.139.2.3
date	2002.08.09.18.34.12;	author kseitz;	state Exp;
branches;
next	1.139.2.4;

1.139.2.4
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	1.139.2.5;

1.139.2.5
date	2002.10.01.00.45.46;	author kseitz;	state Exp;
branches;
next	1.139.2.6;

1.139.2.6
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	1.139.2.7;

1.139.2.7
date	2002.11.05.20.33.25;	author ezannoni;	state Exp;
branches;
next	;

1.137.4.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.127.2.1
date	2002.02.14.04.12.45;	author amodra;	state Exp;
branches;
next	1.127.2.2;

1.127.2.2
date	2002.03.28.06.20.02;	author amodra;	state Exp;
branches;
next	1.127.2.3;

1.127.2.3
date	2002.04.01.18.47.48;	author thorpej;	state Exp;
branches;
next	1.127.2.4;

1.127.2.4
date	2002.04.04.14.52.56;	author amodra;	state Exp;
branches;
next	1.127.2.5;

1.127.2.5
date	2002.04.27.09.10.32;	author amodra;	state Exp;
branches;
next	;

1.61.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2001.06.11.10.04.09;	author amodra;	state Exp;
branches;
next	;

1.27.2.1
date	2000.05.09.01.00.47;	author amodra;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2000.05.23.08.39.06;	author amodra;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2000.05.29.05.18.32;	author amodra;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2000.09.06.21.24.15;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.592
log
@	PR 16056
	* elf.c (copy_elf_program_header): Only consider SEC_ALLOC sections
	when finding lowest_section.
@
text
@/* ELF executable support for BFD.

   Copyright 1993-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/*
SECTION
	ELF backends

	BFD support for ELF formats is being worked on.
	Currently, the best supported back ends are for sparc and i386
	(running svr4 or Solaris 2).

	Documentation of the internals of the support code still needs
	to be written.  The code is changing quickly enough that we
	haven't bothered yet.  */

/* For sparc64-cross-sparc32.  */
#define _SYSCALL32
#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#define ARCH_SIZE 0
#include "elf-bfd.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "elf-linux-psinfo.h"

#ifdef CORE_HEADER
#include CORE_HEADER
#endif

static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct bfd_strtab_hash **, int) ;
static bfd_boolean elf_read_notes (bfd *, file_ptr, bfd_size_type) ;
static bfd_boolean elf_parse_notes (bfd *abfd, char *buf, size_t size,
				    file_ptr offset);

/* Swap version information in and out.  The version information is
   currently size independent.  If that ever changes, this code will
   need to move into elfcode.h.  */

/* Swap in a Verdef structure.  */

void
_bfd_elf_swap_verdef_in (bfd *abfd,
			 const Elf_External_Verdef *src,
			 Elf_Internal_Verdef *dst)
{
  dst->vd_version = H_GET_16 (abfd, src->vd_version);
  dst->vd_flags   = H_GET_16 (abfd, src->vd_flags);
  dst->vd_ndx     = H_GET_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = H_GET_16 (abfd, src->vd_cnt);
  dst->vd_hash    = H_GET_32 (abfd, src->vd_hash);
  dst->vd_aux     = H_GET_32 (abfd, src->vd_aux);
  dst->vd_next    = H_GET_32 (abfd, src->vd_next);
}

/* Swap out a Verdef structure.  */

void
_bfd_elf_swap_verdef_out (bfd *abfd,
			  const Elf_Internal_Verdef *src,
			  Elf_External_Verdef *dst)
{
  H_PUT_16 (abfd, src->vd_version, dst->vd_version);
  H_PUT_16 (abfd, src->vd_flags, dst->vd_flags);
  H_PUT_16 (abfd, src->vd_ndx, dst->vd_ndx);
  H_PUT_16 (abfd, src->vd_cnt, dst->vd_cnt);
  H_PUT_32 (abfd, src->vd_hash, dst->vd_hash);
  H_PUT_32 (abfd, src->vd_aux, dst->vd_aux);
  H_PUT_32 (abfd, src->vd_next, dst->vd_next);
}

/* Swap in a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_in (bfd *abfd,
			  const Elf_External_Verdaux *src,
			  Elf_Internal_Verdaux *dst)
{
  dst->vda_name = H_GET_32 (abfd, src->vda_name);
  dst->vda_next = H_GET_32 (abfd, src->vda_next);
}

/* Swap out a Verdaux structure.  */

void
_bfd_elf_swap_verdaux_out (bfd *abfd,
			   const Elf_Internal_Verdaux *src,
			   Elf_External_Verdaux *dst)
{
  H_PUT_32 (abfd, src->vda_name, dst->vda_name);
  H_PUT_32 (abfd, src->vda_next, dst->vda_next);
}

/* Swap in a Verneed structure.  */

void
_bfd_elf_swap_verneed_in (bfd *abfd,
			  const Elf_External_Verneed *src,
			  Elf_Internal_Verneed *dst)
{
  dst->vn_version = H_GET_16 (abfd, src->vn_version);
  dst->vn_cnt     = H_GET_16 (abfd, src->vn_cnt);
  dst->vn_file    = H_GET_32 (abfd, src->vn_file);
  dst->vn_aux     = H_GET_32 (abfd, src->vn_aux);
  dst->vn_next    = H_GET_32 (abfd, src->vn_next);
}

/* Swap out a Verneed structure.  */

void
_bfd_elf_swap_verneed_out (bfd *abfd,
			   const Elf_Internal_Verneed *src,
			   Elf_External_Verneed *dst)
{
  H_PUT_16 (abfd, src->vn_version, dst->vn_version);
  H_PUT_16 (abfd, src->vn_cnt, dst->vn_cnt);
  H_PUT_32 (abfd, src->vn_file, dst->vn_file);
  H_PUT_32 (abfd, src->vn_aux, dst->vn_aux);
  H_PUT_32 (abfd, src->vn_next, dst->vn_next);
}

/* Swap in a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_in (bfd *abfd,
			  const Elf_External_Vernaux *src,
			  Elf_Internal_Vernaux *dst)
{
  dst->vna_hash  = H_GET_32 (abfd, src->vna_hash);
  dst->vna_flags = H_GET_16 (abfd, src->vna_flags);
  dst->vna_other = H_GET_16 (abfd, src->vna_other);
  dst->vna_name  = H_GET_32 (abfd, src->vna_name);
  dst->vna_next  = H_GET_32 (abfd, src->vna_next);
}

/* Swap out a Vernaux structure.  */

void
_bfd_elf_swap_vernaux_out (bfd *abfd,
			   const Elf_Internal_Vernaux *src,
			   Elf_External_Vernaux *dst)
{
  H_PUT_32 (abfd, src->vna_hash, dst->vna_hash);
  H_PUT_16 (abfd, src->vna_flags, dst->vna_flags);
  H_PUT_16 (abfd, src->vna_other, dst->vna_other);
  H_PUT_32 (abfd, src->vna_name, dst->vna_name);
  H_PUT_32 (abfd, src->vna_next, dst->vna_next);
}

/* Swap in a Versym structure.  */

void
_bfd_elf_swap_versym_in (bfd *abfd,
			 const Elf_External_Versym *src,
			 Elf_Internal_Versym *dst)
{
  dst->vs_vers = H_GET_16 (abfd, src->vs_vers);
}

/* Swap out a Versym structure.  */

void
_bfd_elf_swap_versym_out (bfd *abfd,
			  const Elf_Internal_Versym *src,
			  Elf_External_Versym *dst)
{
  H_PUT_16 (abfd, src->vs_vers, dst->vs_vers);
}

/* Standard ELF hash function.  Do not change this function; you will
   cause invalid hash tables to be generated.  */

unsigned long
bfd_elf_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 0;
  unsigned long g;
  int ch;

  while ((ch = *name++) != '\0')
    {
      h = (h << 4) + ch;
      if ((g = (h & 0xf0000000)) != 0)
	{
	  h ^= g >> 24;
	  /* The ELF ABI says `h &= ~g', but this is equivalent in
	     this case and on some machines one insn instead of two.  */
	  h ^= g;
	}
    }
  return h & 0xffffffff;
}

/* DT_GNU_HASH hash function.  Do not change this function; you will
   cause invalid hash tables to be generated.  */

unsigned long
bfd_elf_gnu_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 5381;
  unsigned char ch;

  while ((ch = *name++) != '\0')
    h = (h << 5) + h + ch;
  return h & 0xffffffff;
}

/* Create a tdata field OBJECT_SIZE bytes in length, zeroed out and with
   the object_id field of an elf_obj_tdata field set to OBJECT_ID.  */
bfd_boolean
bfd_elf_allocate_object (bfd *abfd,
			 size_t object_size,
			 enum elf_target_id object_id)
{
  BFD_ASSERT (object_size >= sizeof (struct elf_obj_tdata));
  abfd->tdata.any = bfd_zalloc (abfd, object_size);
  if (abfd->tdata.any == NULL)
    return FALSE;

  elf_object_id (abfd) = object_id;
  if (abfd->direction != read_direction)
    {
      struct output_elf_obj_tdata *o = bfd_zalloc (abfd, sizeof *o);
      if (o == NULL)
	return FALSE;
      elf_tdata (abfd)->o = o;
      elf_program_header_size (abfd) = (bfd_size_type) -1;
    }
  return TRUE;
}


bfd_boolean
bfd_elf_make_object (bfd *abfd)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_obj_tdata),
				  bed->target_id);
}

bfd_boolean
bfd_elf_mkcorefile (bfd *abfd)
{
  /* I think this can be done just like an object file.  */
  if (!abfd->xvec->_bfd_set_format[(int) bfd_object] (abfd))
    return FALSE;
  elf_tdata (abfd)->core = bfd_zalloc (abfd, sizeof (*elf_tdata (abfd)->core));
  return elf_tdata (abfd)->core != NULL;
}

static char *
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr **i_shdrp;
  bfd_byte *shstrtab = NULL;
  file_ptr offset;
  bfd_size_type shstrtabsize;

  i_shdrp = elf_elfsections (abfd);
  if (i_shdrp == 0
      || shindex >= elf_numsections (abfd)
      || i_shdrp[shindex] == 0)
    return NULL;

  shstrtab = i_shdrp[shindex]->contents;
  if (shstrtab == NULL)
    {
      /* No cached one, attempt to read, and cache what we read.  */
      offset = i_shdrp[shindex]->sh_offset;
      shstrtabsize = i_shdrp[shindex]->sh_size;

      /* Allocate and clear an extra byte at the end, to prevent crashes
	 in case the string table is not terminated.  */
      if (shstrtabsize + 1 <= 1
	  || (shstrtab = (bfd_byte *) bfd_alloc (abfd, shstrtabsize + 1)) == NULL
	  || bfd_seek (abfd, offset, SEEK_SET) != 0)
	shstrtab = NULL;
      else if (bfd_bread (shstrtab, shstrtabsize, abfd) != shstrtabsize)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_file_truncated);
	  shstrtab = NULL;
	  /* Once we've failed to read it, make sure we don't keep
	     trying.  Otherwise, we'll keep allocating space for
	     the string table over and over.  */
	  i_shdrp[shindex]->sh_size = 0;
	}
      else
	shstrtab[shstrtabsize] = '\0';
      i_shdrp[shindex]->contents = shstrtab;
    }
  return (char *) shstrtab;
}

char *
bfd_elf_string_from_elf_section (bfd *abfd,
				 unsigned int shindex,
				 unsigned int strindex)
{
  Elf_Internal_Shdr *hdr;

  if (strindex == 0)
    return "";

  if (elf_elfsections (abfd) == NULL || shindex >= elf_numsections (abfd))
    return NULL;

  hdr = elf_elfsections (abfd)[shindex];

  if (hdr->contents == NULL
      && bfd_elf_get_str_section (abfd, shindex) == NULL)
    return NULL;

  if (strindex >= hdr->sh_size)
    {
      unsigned int shstrndx = elf_elfheader(abfd)->e_shstrndx;
      (*_bfd_error_handler)
	(_("%B: invalid string offset %u >= %lu for section `%s'"),
	 abfd, strindex, (unsigned long) hdr->sh_size,
	 (shindex == shstrndx && strindex == hdr->sh_name
	  ? ".shstrtab"
	  : bfd_elf_string_from_elf_section (abfd, shstrndx, hdr->sh_name)));
      return NULL;
    }

  return ((char *) hdr->contents) + strindex;
}

/* Read and convert symbols to internal format.
   SYMCOUNT specifies the number of symbols to read, starting from
   symbol SYMOFFSET.  If any of INTSYM_BUF, EXTSYM_BUF or EXTSHNDX_BUF
   are non-NULL, they are used to store the internal symbols, external
   symbols, and symbol section index extensions, respectively.
   Returns a pointer to the internal symbol buffer (malloced if necessary)
   or NULL if there were no symbols or some kind of problem.  */

Elf_Internal_Sym *
bfd_elf_get_elf_syms (bfd *ibfd,
		      Elf_Internal_Shdr *symtab_hdr,
		      size_t symcount,
		      size_t symoffset,
		      Elf_Internal_Sym *intsym_buf,
		      void *extsym_buf,
		      Elf_External_Sym_Shndx *extshndx_buf)
{
  Elf_Internal_Shdr *shndx_hdr;
  void *alloc_ext;
  const bfd_byte *esym;
  Elf_External_Sym_Shndx *alloc_extshndx;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *alloc_intsym;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  size_t extsym_size;
  bfd_size_type amt;
  file_ptr pos;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
    abort ();

  if (symcount == 0)
    return intsym_buf;

  /* Normal syms might have section extension entries.  */
  shndx_hdr = NULL;
  if (symtab_hdr == &elf_tdata (ibfd)->symtab_hdr)
    shndx_hdr = &elf_tdata (ibfd)->symtab_shndx_hdr;

  /* Read the symbols.  */
  alloc_ext = NULL;
  alloc_extshndx = NULL;
  alloc_intsym = NULL;
  bed = get_elf_backend_data (ibfd);
  extsym_size = bed->s->sizeof_sym;
  amt = symcount * extsym_size;
  pos = symtab_hdr->sh_offset + symoffset * extsym_size;
  if (extsym_buf == NULL)
    {
      alloc_ext = bfd_malloc2 (symcount, extsym_size);
      extsym_buf = alloc_ext;
    }
  if (extsym_buf == NULL
      || bfd_seek (ibfd, pos, SEEK_SET) != 0
      || bfd_bread (extsym_buf, amt, ibfd) != amt)
    {
      intsym_buf = NULL;
      goto out;
    }

  if (shndx_hdr == NULL || shndx_hdr->sh_size == 0)
    extshndx_buf = NULL;
  else
    {
      amt = symcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);
      if (extshndx_buf == NULL)
	{
	  alloc_extshndx = (Elf_External_Sym_Shndx *)
              bfd_malloc2 (symcount, sizeof (Elf_External_Sym_Shndx));
	  extshndx_buf = alloc_extshndx;
	}
      if (extshndx_buf == NULL
	  || bfd_seek (ibfd, pos, SEEK_SET) != 0
	  || bfd_bread (extshndx_buf, amt, ibfd) != amt)
	{
	  intsym_buf = NULL;
	  goto out;
	}
    }

  if (intsym_buf == NULL)
    {
      alloc_intsym = (Elf_Internal_Sym *)
          bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));
      intsym_buf = alloc_intsym;
      if (intsym_buf == NULL)
	goto out;
    }

  /* Convert the symbols to internal form.  */
  isymend = intsym_buf + symcount;
  for (esym = (const bfd_byte *) extsym_buf, isym = intsym_buf,
           shndx = extshndx_buf;
       isym < isymend;
       esym += extsym_size, isym++, shndx = shndx != NULL ? shndx + 1 : NULL)
    if (!(*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym))
      {
	symoffset += (esym - (bfd_byte *) extsym_buf) / extsym_size;
	(*_bfd_error_handler) (_("%B symbol number %lu references "
				 "nonexistent SHT_SYMTAB_SHNDX section"),
			       ibfd, (unsigned long) symoffset);
	if (alloc_intsym != NULL)
	  free (alloc_intsym);
	intsym_buf = NULL;
	goto out;
      }

 out:
  if (alloc_ext != NULL)
    free (alloc_ext);
  if (alloc_extshndx != NULL)
    free (alloc_extshndx);

  return intsym_buf;
}

/* Look up a symbol name.  */
const char *
bfd_elf_sym_name (bfd *abfd,
		  Elf_Internal_Shdr *symtab_hdr,
		  Elf_Internal_Sym *isym,
		  asection *sym_sec)
{
  const char *name;
  unsigned int iname = isym->st_name;
  unsigned int shindex = symtab_hdr->sh_link;

  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION
      /* Check for a bogus st_shndx to avoid crashing.  */
      && isym->st_shndx < elf_numsections (abfd))
    {
      iname = elf_elfsections (abfd)[isym->st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  name = bfd_elf_string_from_elf_section (abfd, shindex, iname);
  if (name == NULL)
    name = "(null)";
  else if (sym_sec && *name == '\0')
    name = bfd_section_name (abfd, sym_sec);

  return name;
}

/* Elf_Internal_Shdr->contents is an array of these for SHT_GROUP
   sections.  The first element is the flags, the rest are section
   pointers.  */

typedef union elf_internal_group {
  Elf_Internal_Shdr *shdr;
  unsigned int flags;
} Elf_Internal_Group;

/* Return the name of the group signature symbol.  Why isn't the
   signature just a string?  */

static const char *
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
{
  Elf_Internal_Shdr *hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;

  /* First we need to ensure the symbol table is available.  Make sure
     that it is a symbol table section.  */
  if (ghdr->sh_link >= elf_numsections (abfd))
    return NULL;
  hdr = elf_elfsections (abfd) [ghdr->sh_link];
  if (hdr->sh_type != SHT_SYMTAB
      || ! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return NULL;

  /* Go read the symbol.  */
  hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, hdr, 1, ghdr->sh_info,
			    &isym, esym, &eshndx) == NULL)
    return NULL;

  return bfd_elf_sym_name (abfd, hdr, &isym, NULL);
}

/* Set next_in_group list pointer, and group name for NEWSECT.  */

static bfd_boolean
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
{
  unsigned int num_group = elf_tdata (abfd)->num_group;

  /* If num_group is zero, read in all SHT_GROUP sections.  The count
     is set to -1 if there are no SHT_GROUP sections.  */
  if (num_group == 0)
    {
      unsigned int i, shnum;

      /* First count the number of groups.  If we have a SHT_GROUP
	 section with just a flag word (ie. sh_size is 4), ignore it.  */
      shnum = elf_numsections (abfd);
      num_group = 0;

#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)	\
	(   (shdr)->sh_type == SHT_GROUP		\
	 && (shdr)->sh_size >= minsize			\
	 && (shdr)->sh_entsize == GRP_ENTRY_SIZE	\
	 && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)

      for (i = 0; i < shnum; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];

	  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))
	    num_group += 1;
	}

      if (num_group == 0)
	{
	  num_group = (unsigned) -1;
	  elf_tdata (abfd)->num_group = num_group;
	}
      else
	{
	  /* We keep a list of elf section headers for group sections,
	     so we can find them quickly.  */
	  bfd_size_type amt;

	  elf_tdata (abfd)->num_group = num_group;
	  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)
              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));
	  if (elf_tdata (abfd)->group_sect_ptr == NULL)
	    return FALSE;

	  num_group = 0;
	  for (i = 0; i < shnum; i++)
	    {
	      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];

	      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))
		{
		  unsigned char *src;
		  Elf_Internal_Group *dest;

		  /* Add to list of sections.  */
		  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;
		  num_group += 1;

		  /* Read the raw contents.  */
		  BFD_ASSERT (sizeof (*dest) >= 4);
		  amt = shdr->sh_size * sizeof (*dest) / 4;
		  shdr->contents = (unsigned char *)
                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);
		  /* PR binutils/4110: Handle corrupt group headers.  */
		  if (shdr->contents == NULL)
		    {
		      _bfd_error_handler
			(_("%B: Corrupt size field in group section header: 0x%lx"), abfd, shdr->sh_size);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }

		  memset (shdr->contents, 0, amt);

		  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0
		      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)
			  != shdr->sh_size))
		    return FALSE;

		  /* Translate raw contents, a flag word followed by an
		     array of elf section indices all in target byte order,
		     to the flag word followed by an array of elf section
		     pointers.  */
		  src = shdr->contents + shdr->sh_size;
		  dest = (Elf_Internal_Group *) (shdr->contents + amt);
		  while (1)
		    {
		      unsigned int idx;

		      src -= 4;
		      --dest;
		      idx = H_GET_32 (abfd, src);
		      if (src == shdr->contents)
			{
			  dest->flags = idx;
			  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))
			    shdr->bfd_section->flags
			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
			  break;
			}
		      if (idx >= shnum)
			{
			  ((*_bfd_error_handler)
			   (_("%B: invalid SHT_GROUP entry"), abfd));
			  idx = 0;
			}
		      dest->shdr = elf_elfsections (abfd)[idx];
		    }
		}
	    }
	}
    }

  if (num_group != (unsigned) -1)
    {
      unsigned int i;

      for (i = 0; i < num_group; i++)
	{
	  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;
	  unsigned int n_elt = shdr->sh_size / 4;

	  /* Look through this group's sections to see if current
	     section is a member.  */
	  while (--n_elt != 0)
	    if ((++idx)->shdr == hdr)
	      {
		asection *s = NULL;

		/* We are a member of this group.  Go looking through
		   other members to see if any others are linked via
		   next_in_group.  */
		idx = (Elf_Internal_Group *) shdr->contents;
		n_elt = shdr->sh_size / 4;
		while (--n_elt != 0)
		  if ((s = (++idx)->shdr->bfd_section) != NULL
		      && elf_next_in_group (s) != NULL)
		    break;
		if (n_elt != 0)
		  {
		    /* Snarf the group name from other member, and
		       insert current section in circular list.  */
		    elf_group_name (newsect) = elf_group_name (s);
		    elf_next_in_group (newsect) = elf_next_in_group (s);
		    elf_next_in_group (s) = newsect;
		  }
		else
		  {
		    const char *gname;

		    gname = group_signature (abfd, shdr);
		    if (gname == NULL)
		      return FALSE;
		    elf_group_name (newsect) = gname;

		    /* Start a circular list with one element.  */
		    elf_next_in_group (newsect) = newsect;
		  }

		/* If the group section has been created, point to the
		   new member.  */
		if (shdr->bfd_section != NULL)
		  elf_next_in_group (shdr->bfd_section) = newsect;

		i = num_group - 1;
		break;
	      }
	}
    }

  if (elf_group_name (newsect) == NULL)
    {
      (*_bfd_error_handler) (_("%B: no group info for section %A"),
			     abfd, newsect);
    }
  return TRUE;
}

bfd_boolean
_bfd_elf_setup_sections (bfd *abfd)
{
  unsigned int i;
  unsigned int num_group = elf_tdata (abfd)->num_group;
  bfd_boolean result = TRUE;
  asection *s;

  /* Process SHF_LINK_ORDER.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      Elf_Internal_Shdr *this_hdr = &elf_section_data (s)->this_hdr;
      if ((this_hdr->sh_flags & SHF_LINK_ORDER) != 0)
	{
	  unsigned int elfsec = this_hdr->sh_link;
	  /* FIXME: The old Intel compiler and old strip/objcopy may
	     not set the sh_link or sh_info fields.  Hence we could
	     get the situation where elfsec is 0.  */
	  if (elfsec == 0)
	    {
	      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
	      if (bed->link_order_error_handler)
		bed->link_order_error_handler
		  (_("%B: warning: sh_link not set for section `%A'"),
		   abfd, s);
	    }
	  else
	    {
	      asection *linksec = NULL;

	      if (elfsec < elf_numsections (abfd))
		{
		  this_hdr = elf_elfsections (abfd)[elfsec];
		  linksec = this_hdr->bfd_section;
		}

	      /* PR 1991, 2008:
		 Some strip/objcopy may leave an incorrect value in
		 sh_link.  We don't want to proceed.  */
	      if (linksec == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%B: sh_link [%d] in section `%A' is incorrect"),
		     s->owner, s, elfsec);
		  result = FALSE;
		}

	      elf_linked_to_section (s) = linksec;
	    }
	}
    }

  /* Process section groups.  */
  if (num_group == (unsigned) -1)
    return result;

  for (i = 0; i < num_group; i++)
    {
      Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];
      Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;
      unsigned int n_elt = shdr->sh_size / 4;

      while (--n_elt != 0)
	if ((++idx)->shdr->bfd_section)
	  elf_sec_group (idx->shdr->bfd_section) = shdr->bfd_section;
	else if (idx->shdr->sh_type == SHT_RELA
		 || idx->shdr->sh_type == SHT_REL)
	  /* We won't include relocation sections in section groups in
	     output object files. We adjust the group section size here
	     so that relocatable link will work correctly when
	     relocation sections are in section group in input object
	     files.  */
	  shdr->bfd_section->size -= 4;
	else
	  {
	    /* There are some unknown sections in the group.  */
	    (*_bfd_error_handler)
	      (_("%B: unknown [%d] section `%s' in group [%s]"),
	       abfd,
	       (unsigned int) idx->shdr->sh_type,
	       bfd_elf_string_from_elf_section (abfd,
						(elf_elfheader (abfd)
						 ->e_shstrndx),
						idx->shdr->sh_name),
	       shdr->bfd_section->name);
	    result = FALSE;
	  }
    }
  return result;
}

bfd_boolean
bfd_elf_is_group_section (bfd *abfd ATTRIBUTE_UNUSED, const asection *sec)
{
  return elf_next_in_group (sec) != NULL;
}

/* Make a BFD section from an ELF section.  We store a pointer to the
   BFD section in the bfd_section field of the header.  */

bfd_boolean
_bfd_elf_make_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name,
				 int shindex)
{
  asection *newsect;
  flagword flags;
  const struct elf_backend_data *bed;

  if (hdr->bfd_section != NULL)
    return TRUE;

  newsect = bfd_make_section_anyway (abfd, name);
  if (newsect == NULL)
    return FALSE;

  hdr->bfd_section = newsect;
  elf_section_data (newsect)->this_hdr = *hdr;
  elf_section_data (newsect)->this_idx = shindex;

  /* Always use the real type/flags.  */
  elf_section_type (newsect) = hdr->sh_type;
  elf_section_flags (newsect) = hdr->sh_flags;

  newsect->filepos = hdr->sh_offset;

  if (! bfd_set_section_vma (abfd, newsect, hdr->sh_addr)
      || ! bfd_set_section_size (abfd, newsect, hdr->sh_size)
      || ! bfd_set_section_alignment (abfd, newsect,
				      bfd_log2 (hdr->sh_addralign)))
    return FALSE;

  flags = SEC_NO_FLAGS;
  if (hdr->sh_type != SHT_NOBITS)
    flags |= SEC_HAS_CONTENTS;
  if (hdr->sh_type == SHT_GROUP)
    flags |= SEC_GROUP | SEC_EXCLUDE;
  if ((hdr->sh_flags & SHF_ALLOC) != 0)
    {
      flags |= SEC_ALLOC;
      if (hdr->sh_type != SHT_NOBITS)
	flags |= SEC_LOAD;
    }
  if ((hdr->sh_flags & SHF_WRITE) == 0)
    flags |= SEC_READONLY;
  if ((hdr->sh_flags & SHF_EXECINSTR) != 0)
    flags |= SEC_CODE;
  else if ((flags & SEC_LOAD) != 0)
    flags |= SEC_DATA;
  if ((hdr->sh_flags & SHF_MERGE) != 0)
    {
      flags |= SEC_MERGE;
      newsect->entsize = hdr->sh_entsize;
      if ((hdr->sh_flags & SHF_STRINGS) != 0)
	flags |= SEC_STRINGS;
    }
  if (hdr->sh_flags & SHF_GROUP)
    if (!setup_group (abfd, hdr, newsect))
      return FALSE;
  if ((hdr->sh_flags & SHF_TLS) != 0)
    flags |= SEC_THREAD_LOCAL;
  if ((hdr->sh_flags & SHF_EXCLUDE) != 0)
    flags |= SEC_EXCLUDE;

  if ((flags & SEC_ALLOC) == 0)
    {
      /* The debugging sections appear to be recognized only by name,
	 not any sort of flag.  Their SEC_ALLOC bits are cleared.  */
      if (name [0] == '.')
	{
	  const char *p;
	  int n;
	  if (name[1] == 'd')
	    p = ".debug", n = 6;
	  else if (name[1] == 'g' && name[2] == 'n')
	    p = ".gnu.linkonce.wi.", n = 17;
	  else if (name[1] == 'g' && name[2] == 'd')
	    p = ".gdb_index", n = 11; /* yes we really do mean 11.  */
	  else if (name[1] == 'l')
	    p = ".line", n = 5;
	  else if (name[1] == 's')
	    p = ".stab", n = 5;
	  else if (name[1] == 'z')
	    p = ".zdebug", n = 7;
	  else
	    p = NULL, n = 0;
	  if (p != NULL && strncmp (name, p, n) == 0)
	    flags |= SEC_DEBUGGING;
	}
    }

  /* As a GNU extension, if the name begins with .gnu.linkonce, we
     only link a single copy of the section.  This is used to support
     g++.  g++ will emit each template expansion in its own section.
     The symbols will be defined as weak, so that multiple definitions
     are permitted.  The GNU linker extension is to actually discard
     all but one of the sections.  */
  if (CONST_STRNEQ (name, ".gnu.linkonce")
      && elf_next_in_group (newsect) == NULL)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_flags)
    if (! bed->elf_backend_section_flags (&flags, hdr))
      return FALSE;

  if (! bfd_set_section_flags (abfd, newsect, flags))
    return FALSE;

  /* We do not parse the PT_NOTE segments as we are interested even in the
     separate debug info files which may have the segments offsets corrupted.
     PT_NOTEs from the core files are currently not parsed using BFD.  */
  if (hdr->sh_type == SHT_NOTE)
    {
      bfd_byte *contents;

      if (!bfd_malloc_and_get_section (abfd, newsect, &contents))
	return FALSE;

      elf_parse_notes (abfd, (char *) contents, hdr->sh_size, -1);
      free (contents);
    }

  if ((flags & SEC_ALLOC) != 0)
    {
      Elf_Internal_Phdr *phdr;
      unsigned int i, nload;

      /* Some ELF linkers produce binaries with all the program header
	 p_paddr fields zero.  If we have such a binary with more than
	 one PT_LOAD header, then leave the section lma equal to vma
	 so that we don't create sections with overlapping lma.  */
      phdr = elf_tdata (abfd)->phdr;
      for (nload = 0, i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
	if (phdr->p_paddr != 0)
	  break;
	else if (phdr->p_type == PT_LOAD && phdr->p_memsz != 0)
	  ++nload;
      if (i >= elf_elfheader (abfd)->e_phnum && nload > 1)
	return TRUE;

      phdr = elf_tdata (abfd)->phdr;
      for (i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
	{
	  if (((phdr->p_type == PT_LOAD
		&& (hdr->sh_flags & SHF_TLS) == 0)
	       || phdr->p_type == PT_TLS)
	      && ELF_SECTION_IN_SEGMENT (hdr, phdr))
	    {
	      if ((flags & SEC_LOAD) == 0)
		newsect->lma = (phdr->p_paddr
				+ hdr->sh_addr - phdr->p_vaddr);
	      else
		/* We used to use the same adjustment for SEC_LOAD
		   sections, but that doesn't work if the segment
		   is packed with code from multiple VMAs.
		   Instead we calculate the section LMA based on
		   the segment LMA.  It is assumed that the
		   segment will contain sections with contiguous
		   LMAs, even if the VMAs are not.  */
		newsect->lma = (phdr->p_paddr
				+ hdr->sh_offset - phdr->p_offset);

	      /* With contiguous segments, we can't tell from file
		 offsets whether a section with zero size should
		 be placed at the end of one segment or the
		 beginning of the next.  Decide based on vaddr.  */
	      if (hdr->sh_addr >= phdr->p_vaddr
		  && (hdr->sh_addr + hdr->sh_size
		      <= phdr->p_vaddr + phdr->p_memsz))
		break;
	    }
	}
    }

  /* Compress/decompress DWARF debug sections with names: .debug_* and
     .zdebug_*, after the section flags is set.  */
  if ((flags & SEC_DEBUGGING)
      && ((name[1] == 'd' && name[6] == '_')
	  || (name[1] == 'z' && name[7] == '_')))
    {
      enum { nothing, compress, decompress } action = nothing;
      char *new_name;

      if (bfd_is_section_compressed (abfd, newsect))
	{
	  /* Compressed section.  Check if we should decompress.  */
	  if ((abfd->flags & BFD_DECOMPRESS))
	    action = decompress;
	}
      else
	{
	  /* Normal section.  Check if we should compress.  */
	  if ((abfd->flags & BFD_COMPRESS) && newsect->size != 0)
	    action = compress;
	}

      new_name = NULL;
      switch (action)
	{
	case nothing:
	  break;
	case compress:
	  if (!bfd_init_section_compress_status (abfd, newsect))
	    {
	      (*_bfd_error_handler)
		(_("%B: unable to initialize compress status for section %s"),
		 abfd, name);
	      return FALSE;
	    }
	  if (name[1] != 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len + 2);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      new_name[1] = 'z';
	      memcpy (new_name + 2, name + 1, len);
	    }
	  break;
	case decompress:
	  if (!bfd_init_section_decompress_status (abfd, newsect))
	    {
	      (*_bfd_error_handler)
		(_("%B: unable to initialize decompress status for section %s"),
		 abfd, name);
	      return FALSE;
	    }
	  if (name[1] == 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      memcpy (new_name + 1, name + 2, len - 1);
	    }
	  break;
	}
      if (new_name != NULL)
	bfd_rename_section (abfd, newsect, new_name);
    }

  return TRUE;
}

const char *const bfd_elf_section_type_names[] = {
  "SHT_NULL", "SHT_PROGBITS", "SHT_SYMTAB", "SHT_STRTAB",
  "SHT_RELA", "SHT_HASH", "SHT_DYNAMIC", "SHT_NOTE",
  "SHT_NOBITS", "SHT_REL", "SHT_SHLIB", "SHT_DYNSYM",
};

/* ELF relocs are against symbols.  If we are producing relocatable
   output, and the reloc is against an external symbol, and nothing
   has given us any additional addend, the resulting reloc will also
   be against the same symbol.  In such a case, we don't want to
   change anything about the way the reloc is handled, since it will
   all be done at final link time.  Rather than put special case code
   into bfd_perform_relocation, all the reloc types use this howto
   function.  It just short circuits the reloc if producing
   relocatable output against an external symbol.  */

bfd_reloc_status_type
bfd_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol,
		       void *data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  return bfd_reloc_continue;
}

/* Copy the program header and other data from one object module to
   another.  */

bfd_boolean
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || (elf_elfheader (obfd)->e_flags
		  == elf_elfheader (ibfd)->e_flags));

  elf_gp (obfd) = elf_gp (ibfd);
  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = TRUE;

  /* Copy object attributes.  */
  _bfd_elf_copy_obj_attributes (ibfd, obfd);
  return TRUE;
}

static const char *
get_segment_type (unsigned int p_type)
{
  const char *pt;
  switch (p_type)
    {
    case PT_NULL: pt = "NULL"; break;
    case PT_LOAD: pt = "LOAD"; break;
    case PT_DYNAMIC: pt = "DYNAMIC"; break;
    case PT_INTERP: pt = "INTERP"; break;
    case PT_NOTE: pt = "NOTE"; break;
    case PT_SHLIB: pt = "SHLIB"; break;
    case PT_PHDR: pt = "PHDR"; break;
    case PT_TLS: pt = "TLS"; break;
    case PT_GNU_EH_FRAME: pt = "EH_FRAME"; break;
    case PT_GNU_STACK: pt = "STACK"; break;
    case PT_GNU_RELRO: pt = "RELRO"; break;
    default: pt = NULL; break;
    }
  return pt;
}

/* Print out the program headers.  */

bfd_boolean
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
{
  FILE *f = (FILE *) farg;
  Elf_Internal_Phdr *p;
  asection *s;
  bfd_byte *dynbuf = NULL;

  p = elf_tdata (abfd)->phdr;
  if (p != NULL)
    {
      unsigned int i, c;

      fprintf (f, _("\nProgram Header:\n"));
      c = elf_elfheader (abfd)->e_phnum;
      for (i = 0; i < c; i++, p++)
	{
	  const char *pt = get_segment_type (p->p_type);
	  char buf[20];

	  if (pt == NULL)
	    {
	      sprintf (buf, "0x%lx", p->p_type);
	      pt = buf;
	    }
	  fprintf (f, "%8s off    0x", pt);
	  bfd_fprintf_vma (abfd, f, p->p_offset);
	  fprintf (f, " vaddr 0x");
	  bfd_fprintf_vma (abfd, f, p->p_vaddr);
	  fprintf (f, " paddr 0x");
	  bfd_fprintf_vma (abfd, f, p->p_paddr);
	  fprintf (f, " align 2**%u\n", bfd_log2 (p->p_align));
	  fprintf (f, "         filesz 0x");
	  bfd_fprintf_vma (abfd, f, p->p_filesz);
	  fprintf (f, " memsz 0x");
	  bfd_fprintf_vma (abfd, f, p->p_memsz);
	  fprintf (f, " flags %c%c%c",
		   (p->p_flags & PF_R) != 0 ? 'r' : '-',
		   (p->p_flags & PF_W) != 0 ? 'w' : '-',
		   (p->p_flags & PF_X) != 0 ? 'x' : '-');
	  if ((p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (unsigned) (PF_R | PF_W | PF_X));
	  fprintf (f, "\n");
	}
    }

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      unsigned int elfsec;
      unsigned long shlink;
      bfd_byte *extdyn, *extdynend;
      size_t extdynsize;
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

      fprintf (f, _("\nDynamic Section:\n"));

      if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
	goto error_return;

      elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
      if (elfsec == SHN_BAD)
	goto error_return;
      shlink = elf_elfsections (abfd)[elfsec]->sh_link;

      extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
      swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

      extdyn = dynbuf;
      extdynend = extdyn + s->size;
      for (; extdyn < extdynend; extdyn += extdynsize)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name = "";
	  char ab[20];
	  bfd_boolean stringp;
	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

	  (*swap_dyn_in) (abfd, extdyn, &dyn);

	  if (dyn.d_tag == DT_NULL)
	    break;

	  stringp = FALSE;
	  switch (dyn.d_tag)
	    {
	    default:
	      if (bed->elf_backend_get_target_dtag)
		name = (*bed->elf_backend_get_target_dtag) (dyn.d_tag);

	      if (!strcmp (name, ""))
		{
		  sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
		  name = ab;
		}
	      break;

	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
	    case DT_PLTRELSZ: name = "PLTRELSZ"; break;
	    case DT_PLTGOT: name = "PLTGOT"; break;
	    case DT_HASH: name = "HASH"; break;
	    case DT_STRTAB: name = "STRTAB"; break;
	    case DT_SYMTAB: name = "SYMTAB"; break;
	    case DT_RELA: name = "RELA"; break;
	    case DT_RELASZ: name = "RELASZ"; break;
	    case DT_RELAENT: name = "RELAENT"; break;
	    case DT_STRSZ: name = "STRSZ"; break;
	    case DT_SYMENT: name = "SYMENT"; break;
	    case DT_INIT: name = "INIT"; break;
	    case DT_FINI: name = "FINI"; break;
	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
	    case DT_SYMBOLIC: name = "SYMBOLIC"; break;
	    case DT_REL: name = "REL"; break;
	    case DT_RELSZ: name = "RELSZ"; break;
	    case DT_RELENT: name = "RELENT"; break;
	    case DT_PLTREL: name = "PLTREL"; break;
	    case DT_DEBUG: name = "DEBUG"; break;
	    case DT_TEXTREL: name = "TEXTREL"; break;
	    case DT_JMPREL: name = "JMPREL"; break;
	    case DT_BIND_NOW: name = "BIND_NOW"; break;
	    case DT_INIT_ARRAY: name = "INIT_ARRAY"; break;
	    case DT_FINI_ARRAY: name = "FINI_ARRAY"; break;
	    case DT_INIT_ARRAYSZ: name = "INIT_ARRAYSZ"; break;
	    case DT_FINI_ARRAYSZ: name = "FINI_ARRAYSZ"; break;
	    case DT_RUNPATH: name = "RUNPATH"; stringp = TRUE; break;
	    case DT_FLAGS: name = "FLAGS"; break;
	    case DT_PREINIT_ARRAY: name = "PREINIT_ARRAY"; break;
	    case DT_PREINIT_ARRAYSZ: name = "PREINIT_ARRAYSZ"; break;
	    case DT_CHECKSUM: name = "CHECKSUM"; break;
	    case DT_PLTPADSZ: name = "PLTPADSZ"; break;
	    case DT_MOVEENT: name = "MOVEENT"; break;
	    case DT_MOVESZ: name = "MOVESZ"; break;
	    case DT_FEATURE: name = "FEATURE"; break;
	    case DT_POSFLAG_1: name = "POSFLAG_1"; break;
	    case DT_SYMINSZ: name = "SYMINSZ"; break;
	    case DT_SYMINENT: name = "SYMINENT"; break;
	    case DT_CONFIG: name = "CONFIG"; stringp = TRUE; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = TRUE; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = TRUE; break;
	    case DT_PLTPAD: name = "PLTPAD"; break;
	    case DT_MOVETAB: name = "MOVETAB"; break;
	    case DT_SYMINFO: name = "SYMINFO"; break;
	    case DT_RELACOUNT: name = "RELACOUNT"; break;
	    case DT_RELCOUNT: name = "RELCOUNT"; break;
	    case DT_FLAGS_1: name = "FLAGS_1"; break;
	    case DT_VERSYM: name = "VERSYM"; break;
	    case DT_VERDEF: name = "VERDEF"; break;
	    case DT_VERDEFNUM: name = "VERDEFNUM"; break;
	    case DT_VERNEED: name = "VERNEED"; break;
	    case DT_VERNEEDNUM: name = "VERNEEDNUM"; break;
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
	    case DT_USED: name = "USED"; break;
	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
	    case DT_GNU_HASH: name = "GNU_HASH"; break;
	    }

	  fprintf (f, "  %-20s ", name);
	  if (! stringp)
	    {
	      fprintf (f, "0x");
	      bfd_fprintf_vma (abfd, f, dyn.d_un.d_val);
	    }
	  else
	    {
	      const char *string;
	      unsigned int tagv = dyn.d_un.d_val;

	      string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
	      if (string == NULL)
		goto error_return;
	      fprintf (f, "%s", string);
	    }
	  fprintf (f, "\n");
	}

      free (dynbuf);
      dynbuf = NULL;
    }

  if ((elf_dynverdef (abfd) != 0 && elf_tdata (abfd)->verdef == NULL)
      || (elf_dynverref (abfd) != 0 && elf_tdata (abfd)->verref == NULL))
    {
      if (! _bfd_elf_slurp_version_tables (abfd, FALSE))
	return FALSE;
    }

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Verdef *t;

      fprintf (f, _("\nVersion definitions:\n"));
      for (t = elf_tdata (abfd)->verdef; t != NULL; t = t->vd_nextdef)
	{
	  fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
		   t->vd_flags, t->vd_hash,
		   t->vd_nodename ? t->vd_nodename : "<corrupt>");
	  if (t->vd_auxptr != NULL && t->vd_auxptr->vda_nextptr != NULL)
	    {
	      Elf_Internal_Verdaux *a;

	      fprintf (f, "\t");
	      for (a = t->vd_auxptr->vda_nextptr;
		   a != NULL;
		   a = a->vda_nextptr)
		fprintf (f, "%s ",
			 a->vda_nodename ? a->vda_nodename : "<corrupt>");
	      fprintf (f, "\n");
	    }
	}
    }

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Verneed *t;

      fprintf (f, _("\nVersion References:\n"));
      for (t = elf_tdata (abfd)->verref; t != NULL; t = t->vn_nextref)
	{
	  Elf_Internal_Vernaux *a;

	  fprintf (f, _("  required from %s:\n"),
		   t->vn_filename ? t->vn_filename : "<corrupt>");
	  for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
	    fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
		     a->vna_flags, a->vna_other,
		     a->vna_nodename ? a->vna_nodename : "<corrupt>");
	}
    }

  return TRUE;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return FALSE;
}

/* Display ELF-specific fields of a symbol.  */

void
bfd_elf_print_symbol (bfd *abfd,
		      void *filep,
		      asymbol *symbol,
		      bfd_print_symbol_type how)
{
  FILE *file = (FILE *) filep;
  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file, "elf ");
      bfd_fprintf_vma (abfd, file, symbol->value);
      fprintf (file, " %lx", (unsigned long) symbol->flags);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name;
	const char *name = NULL;
	const struct elf_backend_data *bed;
	unsigned char st_other;
	bfd_vma val;

	section_name = symbol->section ? symbol->section->name : "(*none*)";

	bed = get_elf_backend_data (abfd);
	if (bed->elf_backend_print_symbol_all)
	  name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);

	if (name == NULL)
	  {
	    name = symbol->name;
	    bfd_print_symbol_vandf (abfd, file, symbol);
	  }

	fprintf (file, " %s\t", section_name);
	/* Print the "other" value for a symbol.  For common symbols,
	   we've already printed the size; now print the alignment.
	   For other symbols, we have no specified alignment, and
	   we've printed the address; now print the size.  */
	if (symbol->section && bfd_is_com_section (symbol->section))
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_value;
	else
	  val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_size;
	bfd_fprintf_vma (abfd, file, val);

	/* If we have version information, print it.  */
	if (elf_dynversym (abfd) != 0
	    && (elf_dynverdef (abfd) != 0
		|| elf_dynverref (abfd) != 0))
	  {
	    unsigned int vernum;
	    const char *version_string;

	    vernum = ((elf_symbol_type *) symbol)->version & VERSYM_VERSION;

	    if (vernum == 0)
	      version_string = "";
	    else if (vernum == 1)
	      version_string = "Base";
	    else if (vernum <= elf_tdata (abfd)->cverdefs)
	      version_string =
		elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;
	    else
	      {
		Elf_Internal_Verneed *t;

		version_string = "";
		for (t = elf_tdata (abfd)->verref;
		     t != NULL;
		     t = t->vn_nextref)
		  {
		    Elf_Internal_Vernaux *a;

		    for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)
		      {
			if (a->vna_other == vernum)
			  {
			    version_string = a->vna_nodename;
			    break;
			  }
		      }
		  }
	      }

	    if ((((elf_symbol_type *) symbol)->version & VERSYM_HIDDEN) == 0)
	      fprintf (file, "  %-11s", version_string);
	    else
	      {
		int i;

		fprintf (file, " (%s)", version_string);
		for (i = 10 - strlen (version_string); i > 0; --i)
		  putc (' ', file);
	      }
	  }

	/* If the st_other field is not zero, print it.  */
	st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;

	switch (st_other)
	  {
	  case 0: break;
	  case STV_INTERNAL:  fprintf (file, " .internal");  break;
	  case STV_HIDDEN:    fprintf (file, " .hidden");    break;
	  case STV_PROTECTED: fprintf (file, " .protected"); break;
	  default:
	    /* Some other non-defined flags are also present, so print
	       everything hex.  */
	    fprintf (file, " 0x%02x", (unsigned int) st_other);
	  }

	fprintf (file, " %s", name);
      }
      break;
    }
}

/* Allocate an ELF string table--force the first byte to be zero.  */

struct bfd_strtab_hash *
_bfd_elf_stringtab_init (void)
{
  struct bfd_strtab_hash *ret;

  ret = _bfd_stringtab_init ();
  if (ret != NULL)
    {
      bfd_size_type loc;

      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
      BFD_ASSERT (loc == 0 || loc == (bfd_size_type) -1);
      if (loc == (bfd_size_type) -1)
	{
	  _bfd_stringtab_free (ret);
	  ret = NULL;
	}
    }
  return ret;
}

/* ELF .o/exec file reading */

/* Create a new bfd section from an ELF section header.  */

bfd_boolean
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Ehdr *ehdr;
  const struct elf_backend_data *bed;
  const char *name;

  if (shindex >= elf_numsections (abfd))
    return FALSE;

  hdr = elf_elfsections (abfd)[shindex];
  ehdr = elf_elfheader (abfd);
  name = bfd_elf_string_from_elf_section (abfd, ehdr->e_shstrndx,
					  hdr->sh_name);
  if (name == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);
  switch (hdr->sh_type)
    {
    case SHT_NULL:
      /* Inactive section. Throw it away.  */
      return TRUE;

    case SHT_PROGBITS:	/* Normal section with contents.  */
    case SHT_NOBITS:	/* .bss section.  */
    case SHT_HASH:	/* .hash section.  */
    case SHT_NOTE:	/* .note section.  */
    case SHT_INIT_ARRAY:	/* .init_array section.  */
    case SHT_FINI_ARRAY:	/* .fini_array section.  */
    case SHT_PREINIT_ARRAY:	/* .preinit_array section.  */
    case SHT_GNU_LIBLIST:	/* .gnu.liblist section.  */
    case SHT_GNU_HASH:		/* .gnu.hash section.  */
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_DYNAMIC:	/* Dynamic linking information.  */
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
	return FALSE;
      if (hdr->sh_link > elf_numsections (abfd))
	{
	  /* PR 10478: Accept Solaris binaries with a sh_link
	     field set to SHN_BEFORE or SHN_AFTER.  */
	  switch (bfd_get_arch (abfd))
	    {
	    case bfd_arch_i386:
	    case bfd_arch_sparc:
	      if (hdr->sh_link == (SHN_LORESERVE & 0xffff) /* SHN_BEFORE */
		  || hdr->sh_link == ((SHN_LORESERVE + 1) & 0xffff) /* SHN_AFTER */)
		break;
	      /* Otherwise fall through.  */
	    default:
	      return FALSE;
	    }
	}
      else if (elf_elfsections (abfd)[hdr->sh_link] == NULL)
	return FALSE;
      else if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
	{
	  Elf_Internal_Shdr *dynsymhdr;

	  /* The shared libraries distributed with hpux11 have a bogus
	     sh_link field for the ".dynamic" section.  Find the
	     string table for the ".dynsym" section instead.  */
	  if (elf_dynsymtab (abfd) != 0)
	    {
	      dynsymhdr = elf_elfsections (abfd)[elf_dynsymtab (abfd)];
	      hdr->sh_link = dynsymhdr->sh_link;
	    }
	  else
	    {
	      unsigned int i, num_sec;

	      num_sec = elf_numsections (abfd);
	      for (i = 1; i < num_sec; i++)
		{
		  dynsymhdr = elf_elfsections (abfd)[i];
		  if (dynsymhdr->sh_type == SHT_DYNSYM)
		    {
		      hdr->sh_link = dynsymhdr->sh_link;
		      break;
		    }
		}
	    }
	}
      break;

    case SHT_SYMTAB:		/* A symbol table */
      if (elf_onesymtab (abfd) == shindex)
	return TRUE;

      if (hdr->sh_entsize != bed->s->sizeof_sym)
	return FALSE;
      if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
	{
	  if (hdr->sh_size != 0)
	    return FALSE;
	  /* Some assemblers erroneously set sh_info to one with a
	     zero sh_size.  ld sees this as a global symbol count
	     of (unsigned) -1.  Fix it here.  */
	  hdr->sh_info = 0;
	  return TRUE;
	}
      BFD_ASSERT (elf_onesymtab (abfd) == 0);
      elf_onesymtab (abfd) = shindex;
      elf_tdata (abfd)->symtab_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = hdr = &elf_tdata (abfd)->symtab_hdr;
      abfd->flags |= HAS_SYMS;

      /* Sometimes a shared object will map in the symbol table.  If
	 SHF_ALLOC is set, and this is a shared object, then we also
	 treat this section as a BFD section.  We can not base the
	 decision purely on SHF_ALLOC, because that flag is sometimes
	 set in a relocatable object file, which would confuse the
	 linker.  */
      if ((hdr->sh_flags & SHF_ALLOC) != 0
	  && (abfd->flags & DYNAMIC) != 0
	  && ! _bfd_elf_make_section_from_shdr (abfd, hdr, name,
						shindex))
	return FALSE;

      /* Go looking for SHT_SYMTAB_SHNDX too, since if there is one we
	 can't read symbols without that section loaded as well.  It
	 is most likely specified by the next section header.  */
      if (elf_elfsections (abfd)[elf_symtab_shndx (abfd)]->sh_link != shindex)
	{
	  unsigned int i, num_sec;

	  num_sec = elf_numsections (abfd);
	  for (i = shindex + 1; i < num_sec; i++)
	    {
	      Elf_Internal_Shdr *hdr2 = elf_elfsections (abfd)[i];
	      if (hdr2->sh_type == SHT_SYMTAB_SHNDX
		  && hdr2->sh_link == shindex)
		break;
	    }
	  if (i == num_sec)
	    for (i = 1; i < shindex; i++)
	      {
		Elf_Internal_Shdr *hdr2 = elf_elfsections (abfd)[i];
		if (hdr2->sh_type == SHT_SYMTAB_SHNDX
		    && hdr2->sh_link == shindex)
		  break;
	      }
	  if (i != shindex)
	    return bfd_section_from_shdr (abfd, i);
	}
      return TRUE;

    case SHT_DYNSYM:		/* A dynamic symbol table */
      if (elf_dynsymtab (abfd) == shindex)
	return TRUE;

      if (hdr->sh_entsize != bed->s->sizeof_sym)
	return FALSE;
      if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
	{
	  if (hdr->sh_size != 0)
	    return FALSE;
	  /* Some linkers erroneously set sh_info to one with a
	     zero sh_size.  ld sees this as a global symbol count
	     of (unsigned) -1.  Fix it here.  */
	  hdr->sh_info = 0;
	  return TRUE;
	}
      BFD_ASSERT (elf_dynsymtab (abfd) == 0);
      elf_dynsymtab (abfd) = shindex;
      elf_tdata (abfd)->dynsymtab_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = hdr = &elf_tdata (abfd)->dynsymtab_hdr;
      abfd->flags |= HAS_SYMS;

      /* Besides being a symbol table, we also treat this as a regular
	 section, so that objcopy can handle it.  */
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_SYMTAB_SHNDX:	/* Symbol section indices when >64k sections */
      if (elf_symtab_shndx (abfd) == shindex)
	return TRUE;

      BFD_ASSERT (elf_symtab_shndx (abfd) == 0);
      elf_symtab_shndx (abfd) = shindex;
      elf_tdata (abfd)->symtab_shndx_hdr = *hdr;
      elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->symtab_shndx_hdr;
      return TRUE;

    case SHT_STRTAB:		/* A string table */
      if (hdr->bfd_section != NULL)
	return TRUE;
      if (ehdr->e_shstrndx == shindex)
	{
	  elf_tdata (abfd)->shstrtab_hdr = *hdr;
	  elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->shstrtab_hdr;
	  return TRUE;
	}
      if (elf_elfsections (abfd)[elf_onesymtab (abfd)]->sh_link == shindex)
	{
	symtab_strtab:
	  elf_tdata (abfd)->strtab_hdr = *hdr;
	  elf_elfsections (abfd)[shindex] = &elf_tdata (abfd)->strtab_hdr;
	  return TRUE;
	}
      if (elf_elfsections (abfd)[elf_dynsymtab (abfd)]->sh_link == shindex)
	{
	dynsymtab_strtab:
	  elf_tdata (abfd)->dynstrtab_hdr = *hdr;
	  hdr = &elf_tdata (abfd)->dynstrtab_hdr;
	  elf_elfsections (abfd)[shindex] = hdr;
	  /* We also treat this as a regular section, so that objcopy
	     can handle it.  */
	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
						  shindex);
	}

      /* If the string table isn't one of the above, then treat it as a
	 regular section.  We need to scan all the headers to be sure,
	 just in case this strtab section appeared before the above.  */
      if (elf_onesymtab (abfd) == 0 || elf_dynsymtab (abfd) == 0)
	{
	  unsigned int i, num_sec;

	  num_sec = elf_numsections (abfd);
	  for (i = 1; i < num_sec; i++)
	    {
	      Elf_Internal_Shdr *hdr2 = elf_elfsections (abfd)[i];
	      if (hdr2->sh_link == shindex)
		{
		  /* Prevent endless recursion on broken objects.  */
		  if (i == shindex)
		    return FALSE;
		  if (! bfd_section_from_shdr (abfd, i))
		    return FALSE;
		  if (elf_onesymtab (abfd) == i)
		    goto symtab_strtab;
		  if (elf_dynsymtab (abfd) == i)
		    goto dynsymtab_strtab;
		}
	    }
	}
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_REL:
    case SHT_RELA:
      /* *These* do a lot of work -- but build no sections!  */
      {
	asection *target_sect;
	Elf_Internal_Shdr *hdr2, **p_hdr;
	unsigned int num_sec = elf_numsections (abfd);
	struct bfd_elf_section_data *esdt;
	bfd_size_type amt;

	if (hdr->sh_entsize
	    != (bfd_size_type) (hdr->sh_type == SHT_REL
				? bed->s->sizeof_rel : bed->s->sizeof_rela))
	  return FALSE;

	/* Check for a bogus link to avoid crashing.  */
	if (hdr->sh_link >= num_sec)
	  {
	    ((*_bfd_error_handler)
	     (_("%B: invalid link %lu for reloc section %s (index %u)"),
	      abfd, hdr->sh_link, name, shindex));
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
						    shindex);
	  }

	/* For some incomprehensible reason Oracle distributes
	   libraries for Solaris in which some of the objects have
	   bogus sh_link fields.  It would be nice if we could just
	   reject them, but, unfortunately, some people need to use
	   them.  We scan through the section headers; if we find only
	   one suitable symbol table, we clobber the sh_link to point
	   to it.  I hope this doesn't break anything.

	   Don't do it on executable nor shared library.  */
	if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0
	    && elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_SYMTAB
	    && elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_DYNSYM)
	  {
	    unsigned int scan;
	    int found;

	    found = 0;
	    for (scan = 1; scan < num_sec; scan++)
	      {
		if (elf_elfsections (abfd)[scan]->sh_type == SHT_SYMTAB
		    || elf_elfsections (abfd)[scan]->sh_type == SHT_DYNSYM)
		  {
		    if (found != 0)
		      {
			found = 0;
			break;
		      }
		    found = scan;
		  }
	      }
	    if (found != 0)
	      hdr->sh_link = found;
	  }

	/* Get the symbol table.  */
	if ((elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_SYMTAB
	     || elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_DYNSYM)
	    && ! bfd_section_from_shdr (abfd, hdr->sh_link))
	  return FALSE;

	/* If this reloc section does not use the main symbol table we
	   don't treat it as a reloc section.  BFD can't adequately
	   represent such a section, so at least for now, we don't
	   try.  We just present it as a normal section.  We also
	   can't use it as a reloc section if it points to the null
	   section, an invalid section, another reloc section, or its
	   sh_link points to the null section.  */
	if (hdr->sh_link != elf_onesymtab (abfd)
	    || hdr->sh_link == SHN_UNDEF
	    || hdr->sh_info == SHN_UNDEF
	    || hdr->sh_info >= num_sec
	    || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_REL
	    || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)
	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
						  shindex);

	if (! bfd_section_from_shdr (abfd, hdr->sh_info))
	  return FALSE;
	target_sect = bfd_section_from_elf_index (abfd, hdr->sh_info);
	if (target_sect == NULL)
	  return FALSE;

	esdt = elf_section_data (target_sect);
	if (hdr->sh_type == SHT_RELA)
	  p_hdr = &esdt->rela.hdr;
	else
	  p_hdr = &esdt->rel.hdr;

	BFD_ASSERT (*p_hdr == NULL);
	amt = sizeof (*hdr2);
	hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
	if (hdr2 == NULL)
	  return FALSE;
	*hdr2 = *hdr;
	*p_hdr = hdr2;
	elf_elfsections (abfd)[shindex] = hdr2;
	target_sect->reloc_count += NUM_SHDR_ENTRIES (hdr);
	target_sect->flags |= SEC_RELOC;
	target_sect->relocation = NULL;
	target_sect->rel_filepos = hdr->sh_offset;
	/* In the section to which the relocations apply, mark whether
	   its relocations are of the REL or RELA variety.  */
	if (hdr->sh_size != 0)
	  {
	    if (hdr->sh_type == SHT_RELA)
	      target_sect->use_rela_p = 1;
	  }
	abfd->flags |= HAS_RELOC;
	return TRUE;
      }

    case SHT_GNU_verdef:
      elf_dynverdef (abfd) = shindex;
      elf_tdata (abfd)->dynverdef_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_GNU_versym:
      if (hdr->sh_entsize != sizeof (Elf_External_Versym))
	return FALSE;
      elf_dynversym (abfd) = shindex;
      elf_tdata (abfd)->dynversym_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_GNU_verneed:
      elf_dynverref (abfd) = shindex;
      elf_tdata (abfd)->dynverref_hdr = *hdr;
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);

    case SHT_SHLIB:
      return TRUE;

    case SHT_GROUP:
      if (! IS_VALID_GROUP_SECTION_HEADER (hdr, GRP_ENTRY_SIZE))
	return FALSE;
      if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
	return FALSE;
      if (hdr->contents != NULL)
	{
	  Elf_Internal_Group *idx = (Elf_Internal_Group *) hdr->contents;
	  unsigned int n_elt = hdr->sh_size / GRP_ENTRY_SIZE;
	  asection *s;

	  if (idx->flags & GRP_COMDAT)
	    hdr->bfd_section->flags
	      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

	  /* We try to keep the same section order as it comes in.  */
	  idx += n_elt;
	  while (--n_elt != 0)
	    {
	      --idx;

	      if (idx->shdr != NULL
		  && (s = idx->shdr->bfd_section) != NULL
		  && elf_next_in_group (s) != NULL)
		{
		  elf_next_in_group (hdr->bfd_section) = s;
		  break;
		}
	    }
	}
      break;

    default:
      /* Possibly an attributes section.  */
      if (hdr->sh_type == SHT_GNU_ATTRIBUTES
	  || hdr->sh_type == bed->obj_attrs_section_type)
	{
	  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
	    return FALSE;
	  _bfd_elf_parse_attributes (abfd, hdr);
	  return TRUE;
	}

      /* Check for any processor-specific section types.  */
      if (bed->elf_backend_section_from_shdr (abfd, hdr, name, shindex))
	return TRUE;

      if (hdr->sh_type >= SHT_LOUSER && hdr->sh_type <= SHT_HIUSER)
	{
	  if ((hdr->sh_flags & SHF_ALLOC) != 0)
	    /* FIXME: How to properly handle allocated section reserved
	       for applications?  */
	    (*_bfd_error_handler)
	      (_("%B: don't know how to handle allocated, application "
		 "specific section `%s' [0x%8x]"),
	       abfd, name, hdr->sh_type);
	  else
	    /* Allow sections reserved for applications.  */
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name,
						    shindex);
	}
      else if (hdr->sh_type >= SHT_LOPROC
	       && hdr->sh_type <= SHT_HIPROC)
	/* FIXME: We should handle this section.  */
	(*_bfd_error_handler)
	  (_("%B: don't know how to handle processor specific section "
	     "`%s' [0x%8x]"),
	   abfd, name, hdr->sh_type);
      else if (hdr->sh_type >= SHT_LOOS && hdr->sh_type <= SHT_HIOS)
	{
	  /* Unrecognised OS-specific sections.  */
	  if ((hdr->sh_flags & SHF_OS_NONCONFORMING) != 0)
	    /* SHF_OS_NONCONFORMING indicates that special knowledge is
	       required to correctly process the section and the file should
	       be rejected with an error message.  */
	    (*_bfd_error_handler)
	      (_("%B: don't know how to handle OS specific section "
		 "`%s' [0x%8x]"),
	       abfd, name, hdr->sh_type);
	  else
	    /* Otherwise it should be processed.  */
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
	}
      else
	/* FIXME: We should handle this section.  */
	(*_bfd_error_handler)
	  (_("%B: don't know how to handle section `%s' [0x%8x]"),
	   abfd, name, hdr->sh_type);

      return FALSE;
    }

  return TRUE;
}

/* Return the local symbol specified by ABFD, R_SYMNDX.  */

Elf_Internal_Sym *
bfd_sym_from_r_symndx (struct sym_cache *cache,
		       bfd *abfd,
		       unsigned long r_symndx)
{
  unsigned int ent = r_symndx % LOCAL_SYM_CACHE_SIZE;

  if (cache->abfd != abfd || cache->indx[ent] != r_symndx)
    {
      Elf_Internal_Shdr *symtab_hdr;
      unsigned char esym[sizeof (Elf64_External_Sym)];
      Elf_External_Sym_Shndx eshndx;

      symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
      if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
				&cache->sym[ent], esym, &eshndx) == NULL)
	return NULL;

      if (cache->abfd != abfd)
	{
	  memset (cache->indx, -1, sizeof (cache->indx));
	  cache->abfd = abfd;
	}
      cache->indx[ent] = r_symndx;
    }

  return &cache->sym[ent];
}

/* Given an ELF section number, retrieve the corresponding BFD
   section.  */

asection *
bfd_section_from_elf_index (bfd *abfd, unsigned int sec_index)
{
  if (sec_index >= elf_numsections (abfd))
    return NULL;
  return elf_elfsections (abfd)[sec_index]->bfd_section;
}

static const struct bfd_elf_special_section special_sections_b[] =
{
  { STRING_COMMA_LEN (".bss"), -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,                   0,  0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_c[] =
{
  { STRING_COMMA_LEN (".comment"), 0, SHT_PROGBITS, 0 },
  { NULL,                       0, 0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_d[] =
{
  { STRING_COMMA_LEN (".data"),         -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".data1"),         0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  /* There are more DWARF sections than these, but they needn't be added here
     unless you have to cope with broken compilers that don't emit section
     attributes or you want to help the user writing assembler.  */
  { STRING_COMMA_LEN (".debug"),         0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".debug_line"),    0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".debug_info"),    0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".debug_abbrev"),  0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".debug_aranges"), 0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".dynamic"),       0, SHT_DYNAMIC,  SHF_ALLOC },
  { STRING_COMMA_LEN (".dynstr"),        0, SHT_STRTAB,   SHF_ALLOC },
  { STRING_COMMA_LEN (".dynsym"),        0, SHT_DYNSYM,   SHF_ALLOC },
  { NULL,                      0,        0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_f[] =
{
  { STRING_COMMA_LEN (".fini"),       0, SHT_PROGBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".fini_array"), 0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { NULL,                          0, 0, 0,              0 }
};

static const struct bfd_elf_special_section special_sections_g[] =
{
  { STRING_COMMA_LEN (".gnu.linkonce.b"), -2, SHT_NOBITS,      SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".gnu.lto_"),       -1, SHT_PROGBITS,    SHF_EXCLUDE },
  { STRING_COMMA_LEN (".got"),             0, SHT_PROGBITS,    SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".gnu.version"),     0, SHT_GNU_versym,  0 },
  { STRING_COMMA_LEN (".gnu.version_d"),   0, SHT_GNU_verdef,  0 },
  { STRING_COMMA_LEN (".gnu.version_r"),   0, SHT_GNU_verneed, 0 },
  { STRING_COMMA_LEN (".gnu.liblist"),     0, SHT_GNU_LIBLIST, SHF_ALLOC },
  { STRING_COMMA_LEN (".gnu.conflict"),    0, SHT_RELA,        SHF_ALLOC },
  { STRING_COMMA_LEN (".gnu.hash"),        0, SHT_GNU_HASH,    SHF_ALLOC },
  { NULL,                        0,        0, 0,               0 }
};

static const struct bfd_elf_special_section special_sections_h[] =
{
  { STRING_COMMA_LEN (".hash"), 0, SHT_HASH,     SHF_ALLOC },
  { NULL,                    0, 0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_i[] =
{
  { STRING_COMMA_LEN (".init"),       0, SHT_PROGBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".init_array"), 0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".interp"),     0, SHT_PROGBITS,   0 },
  { NULL,                      0,     0, 0,              0 }
};

static const struct bfd_elf_special_section special_sections_l[] =
{
  { STRING_COMMA_LEN (".line"), 0, SHT_PROGBITS, 0 },
  { NULL,                    0, 0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_n[] =
{
  { STRING_COMMA_LEN (".note.GNU-stack"), 0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".note"),          -1, SHT_NOTE,     0 },
  { NULL,                    0,           0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_p[] =
{
  { STRING_COMMA_LEN (".preinit_array"), 0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".plt"),           0, SHT_PROGBITS,      SHF_ALLOC + SHF_EXECINSTR },
  { NULL,                   0,           0, 0,                 0 }
};

static const struct bfd_elf_special_section special_sections_r[] =
{
  { STRING_COMMA_LEN (".rodata"), -2, SHT_PROGBITS, SHF_ALLOC },
  { STRING_COMMA_LEN (".rodata1"), 0, SHT_PROGBITS, SHF_ALLOC },
  { STRING_COMMA_LEN (".rela"),   -1, SHT_RELA,     0 },
  { STRING_COMMA_LEN (".rel"),    -1, SHT_REL,      0 },
  { NULL,                   0,     0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_s[] =
{
  { STRING_COMMA_LEN (".shstrtab"), 0, SHT_STRTAB, 0 },
  { STRING_COMMA_LEN (".strtab"),   0, SHT_STRTAB, 0 },
  { STRING_COMMA_LEN (".symtab"),   0, SHT_SYMTAB, 0 },
  /* See struct bfd_elf_special_section declaration for the semantics of
     this special case where .prefix_length != strlen (.prefix).  */
  { ".stabstr",			5,  3, SHT_STRTAB, 0 },
  { NULL,                       0,  0, 0,          0 }
};

static const struct bfd_elf_special_section special_sections_t[] =
{
  { STRING_COMMA_LEN (".text"),  -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".tbss"),  -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { STRING_COMMA_LEN (".tdata"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { NULL,                     0,  0, 0,            0 }
};

static const struct bfd_elf_special_section special_sections_z[] =
{
  { STRING_COMMA_LEN (".zdebug_line"),    0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".zdebug_info"),    0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".zdebug_abbrev"),  0, SHT_PROGBITS, 0 },
  { STRING_COMMA_LEN (".zdebug_aranges"), 0, SHT_PROGBITS, 0 },
  { NULL,                     0,  0, 0,            0 }
};

static const struct bfd_elf_special_section * const special_sections[] =
{
  special_sections_b,		/* 'b' */
  special_sections_c,		/* 'c' */
  special_sections_d,		/* 'd' */
  NULL,				/* 'e' */
  special_sections_f,		/* 'f' */
  special_sections_g,		/* 'g' */
  special_sections_h,		/* 'h' */
  special_sections_i,		/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  special_sections_l,		/* 'l' */
  NULL,				/* 'm' */
  special_sections_n,		/* 'n' */
  NULL,				/* 'o' */
  special_sections_p,		/* 'p' */
  NULL,				/* 'q' */
  special_sections_r,		/* 'r' */
  special_sections_s,		/* 's' */
  special_sections_t,		/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  special_sections_z		/* 'z' */
};

const struct bfd_elf_special_section *
_bfd_elf_get_special_section (const char *name,
			      const struct bfd_elf_special_section *spec,
			      unsigned int rela)
{
  int i;
  int len;

  len = strlen (name);

  for (i = 0; spec[i].prefix != NULL; i++)
    {
      int suffix_len;
      int prefix_len = spec[i].prefix_length;

      if (len < prefix_len)
	continue;
      if (memcmp (name, spec[i].prefix, prefix_len) != 0)
	continue;

      suffix_len = spec[i].suffix_length;
      if (suffix_len <= 0)
	{
	  if (name[prefix_len] != 0)
	    {
	      if (suffix_len == 0)
		continue;
	      if (name[prefix_len] != '.'
		  && (suffix_len == -2
		      || (rela && spec[i].type == SHT_REL)))
		continue;
	    }
	}
      else
	{
	  if (len < prefix_len + suffix_len)
	    continue;
	  if (memcmp (name + len - suffix_len,
		      spec[i].prefix + prefix_len,
		      suffix_len) != 0)
	    continue;
	}
      return &spec[i];
    }

  return NULL;
}

const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  int i;
  const struct bfd_elf_special_section *spec;
  const struct elf_backend_data *bed;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  bed = get_elf_backend_data (abfd);
  spec = bed->special_sections;
  if (spec)
    {
      spec = _bfd_elf_get_special_section (sec->name,
					   bed->special_sections,
					   sec->use_rela_p);
      if (spec != NULL)
	return spec;
    }

  if (sec->name[0] != '.')
    return NULL;

  i = sec->name[1] - 'b';
  if (i < 0 || i > 'z' - 'b')
    return NULL;

  spec = special_sections[i];

  if (spec == NULL)
    return NULL;

  return _bfd_elf_get_special_section (sec->name, spec, sec->use_rela_p);
}

bfd_boolean
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
{
  struct bfd_elf_section_data *sdata;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;

  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == NULL)
    {
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd,
                                                          sizeof (*sdata));
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }

  /* Indicate whether or not this section should use RELA relocations.  */
  bed = get_elf_backend_data (abfd);
  sec->use_rela_p = bed->default_use_rela_p;

  /* When we read a file, we don't need to set ELF section type and
     flags.  They will be overridden in _bfd_elf_make_section_from_shdr
     anyway.  We will set ELF section type and flags for all linker
     created sections.  If user specifies BFD section flags, we will
     set ELF section type and flags based on BFD section flags in
     elf_fake_sections.  Special handling for .init_array/.fini_array
     output sections since they may contain .ctors/.dtors input
     sections.  We don't want _bfd_elf_init_private_section_data to
     copy ELF section type from .ctors/.dtors input sections.  */
  if (abfd->direction != read_direction
      || (sec->flags & SEC_LINKER_CREATED) != 0)
    {
      ssect = (*bed->get_sec_type_attr) (abfd, sec);
      if (ssect != NULL
	  && (!sec->flags
	      || (sec->flags & SEC_LINKER_CREATED) != 0
	      || ssect->type == SHT_INIT_ARRAY
	      || ssect->type == SHT_FINI_ARRAY))
	{
	  elf_section_type (sec) = ssect->type;
	  elf_section_flags (sec) = ssect->attr;
	}
    }

  return _bfd_generic_new_section_hook (abfd, sec);
}

/* Create a new bfd section from an ELF program header.

   Since program segments have no names, we generate a synthetic name
   of the form segment<NUM>, where NUM is generally the index in the
   program header table.  For segments that are split (see below) we
   generate the names segment<NUM>a and segment<NUM>b.

   Note that some program segments may have a file size that is different than
   (less than) the memory size.  All this means is that at execution the
   system must allocate the amount of memory specified by the memory size,
   but only initialize it with the first "file size" bytes read from the
   file.  This would occur for example, with program segments consisting
   of combined data+bss.

   To handle the above situation, this routine generates TWO bfd sections
   for the single program segment.  The first has the length specified by
   the file size of the segment, and the second has the length specified
   by the difference between the two sizes.  In effect, the segment is split
   into its initialized and uninitialized parts.

 */

bfd_boolean
_bfd_elf_make_section_from_phdr (bfd *abfd,
				 Elf_Internal_Phdr *hdr,
				 int hdr_index,
				 const char *type_name)
{
  asection *newsect;
  char *name;
  char namebuf[64];
  size_t len;
  int split;

  split = ((hdr->p_memsz > 0)
	    && (hdr->p_filesz > 0)
	    && (hdr->p_memsz > hdr->p_filesz));

  if (hdr->p_filesz > 0)
    {
      sprintf (namebuf, "%s%d%s", type_name, hdr_index, split ? "a" : "");
      len = strlen (namebuf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (!name)
	return FALSE;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == NULL)
	return FALSE;
      newsect->vma = hdr->p_vaddr;
      newsect->lma = hdr->p_paddr;
      newsect->size = hdr->p_filesz;
      newsect->filepos = hdr->p_offset;
      newsect->flags |= SEC_HAS_CONTENTS;
      newsect->alignment_power = bfd_log2 (hdr->p_align);
      if (hdr->p_type == PT_LOAD)
	{
	  newsect->flags |= SEC_ALLOC;
	  newsect->flags |= SEC_LOAD;
	  if (hdr->p_flags & PF_X)
	    {
	      /* FIXME: all we known is that it has execute PERMISSION,
		 may be data.  */
	      newsect->flags |= SEC_CODE;
	    }
	}
      if (!(hdr->p_flags & PF_W))
	{
	  newsect->flags |= SEC_READONLY;
	}
    }

  if (hdr->p_memsz > hdr->p_filesz)
    {
      bfd_vma align;

      sprintf (namebuf, "%s%d%s", type_name, hdr_index, split ? "b" : "");
      len = strlen (namebuf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (!name)
	return FALSE;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == NULL)
	return FALSE;
      newsect->vma = hdr->p_vaddr + hdr->p_filesz;
      newsect->lma = hdr->p_paddr + hdr->p_filesz;
      newsect->size = hdr->p_memsz - hdr->p_filesz;
      newsect->filepos = hdr->p_offset + hdr->p_filesz;
      align = newsect->vma & -newsect->vma;
      if (align == 0 || align > hdr->p_align)
	align = hdr->p_align;
      newsect->alignment_power = bfd_log2 (align);
      if (hdr->p_type == PT_LOAD)
	{
	  /* Hack for gdb.  Segments that have not been modified do
	     not have their contents written to a core file, on the
	     assumption that a debugger can find the contents in the
	     executable.  We flag this case by setting the fake
	     section size to zero.  Note that "real" bss sections will
	     always have their contents dumped to the core file.  */
	  if (bfd_get_format (abfd) == bfd_core)
	    newsect->size = 0;
	  newsect->flags |= SEC_ALLOC;
	  if (hdr->p_flags & PF_X)
	    newsect->flags |= SEC_CODE;
	}
      if (!(hdr->p_flags & PF_W))
	newsect->flags |= SEC_READONLY;
    }

  return TRUE;
}

bfd_boolean
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int hdr_index)
{
  const struct elf_backend_data *bed;

  switch (hdr->p_type)
    {
    case PT_NULL:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "null");

    case PT_LOAD:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "load");

    case PT_DYNAMIC:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "dynamic");

    case PT_INTERP:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "interp");

    case PT_NOTE:
      if (! _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "note"))
	return FALSE;
      if (! elf_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
	return FALSE;
      return TRUE;

    case PT_SHLIB:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "shlib");

    case PT_PHDR:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "phdr");

    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index,
					      "eh_frame_hdr");

    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "stack");

    case PT_GNU_RELRO:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "relro");

    default:
      /* Check for any processor-specific program segment types.  */
      bed = get_elf_backend_data (abfd);
      return bed->elf_backend_section_from_phdr (abfd, hdr, hdr_index, "proc");
    }
}

/* Return the REL_HDR for SEC, assuming there is only a single one, either
   REL or RELA.  */

Elf_Internal_Shdr *
_bfd_elf_single_rel_hdr (asection *sec)
{
  if (elf_section_data (sec)->rel.hdr)
    {
      BFD_ASSERT (elf_section_data (sec)->rela.hdr == NULL);
      return elf_section_data (sec)->rel.hdr;
    }
  else
    return elf_section_data (sec)->rela.hdr;
}

/* Allocate and initialize a section-header for a new reloc section,
   containing relocations against ASECT.  It is stored in RELDATA.  If
   USE_RELA_P is TRUE, we use RELA relocations; otherwise, we use REL
   relocations.  */

static bfd_boolean
_bfd_elf_init_reloc_shdr (bfd *abfd,
			  struct bfd_elf_section_reloc_data *reldata,
			  asection *asect,
			  bfd_boolean use_rela_p)
{
  Elf_Internal_Shdr *rel_hdr;
  char *name;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_size_type amt;

  amt = sizeof (Elf_Internal_Shdr);
  BFD_ASSERT (reldata->hdr == NULL);
  rel_hdr = bfd_zalloc (abfd, amt);
  reldata->hdr = rel_hdr;

  amt = sizeof ".rela" + strlen (asect->name);
  name = (char *) bfd_alloc (abfd, amt);
  if (name == NULL)
    return FALSE;
  sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", asect->name);
  rel_hdr->sh_name =
    (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd), name,
					FALSE);
  if (rel_hdr->sh_name == (unsigned int) -1)
    return FALSE;
  rel_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
  rel_hdr->sh_entsize = (use_rela_p
			 ? bed->s->sizeof_rela
			 : bed->s->sizeof_rel);
  rel_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;
  rel_hdr->sh_flags = 0;
  rel_hdr->sh_addr = 0;
  rel_hdr->sh_size = 0;
  rel_hdr->sh_offset = 0;

  return TRUE;
}

/* Return the default section type based on the passed in section flags.  */

int
bfd_elf_get_default_section_type (flagword flags)
{
  if ((flags & SEC_ALLOC) != 0
      && (flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
    return SHT_NOBITS;
  return SHT_PROGBITS;
}

struct fake_section_arg
{
  struct bfd_link_info *link_info;
  bfd_boolean failed;
};

/* Set up an ELF internal section header for a section.  */

static void
elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
{
  struct fake_section_arg *arg = (struct fake_section_arg *)fsarg;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct bfd_elf_section_data *esd = elf_section_data (asect);
  Elf_Internal_Shdr *this_hdr;
  unsigned int sh_type;

  if (arg->failed)
    {
      /* We already failed; just get out of the bfd_map_over_sections
	 loop.  */
      return;
    }

  this_hdr = &esd->this_hdr;

  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
    {
      arg->failed = TRUE;
      return;
    }

  /* Don't clear sh_flags. Assembler may set additional bits.  */

  if ((asect->flags & SEC_ALLOC) != 0
      || asect->user_set_vma)
    this_hdr->sh_addr = asect->vma;
  else
    this_hdr->sh_addr = 0;

  this_hdr->sh_offset = 0;
  this_hdr->sh_size = asect->size;
  this_hdr->sh_link = 0;
  this_hdr->sh_addralign = (bfd_vma) 1 << asect->alignment_power;
  /* The sh_entsize and sh_info fields may have been set already by
     copy_private_section_data.  */

  this_hdr->bfd_section = asect;
  this_hdr->contents = NULL;

  /* If the section type is unspecified, we set it based on
     asect->flags.  */
  if ((asect->flags & SEC_GROUP) != 0)
    sh_type = SHT_GROUP;
  else
    sh_type = bfd_elf_get_default_section_type (asect->flags);

  if (this_hdr->sh_type == SHT_NULL)
    this_hdr->sh_type = sh_type;
  else if (this_hdr->sh_type == SHT_NOBITS
	   && sh_type == SHT_PROGBITS
	   && (asect->flags & SEC_ALLOC) != 0)
    {
      /* Warn if we are changing a NOBITS section to PROGBITS, but
	 allow the link to proceed.  This can happen when users link
	 non-bss input sections to bss output sections, or emit data
	 to a bss output section via a linker script.  */
      (*_bfd_error_handler)
	(_("warning: section `%A' type changed to PROGBITS"), asect);
      this_hdr->sh_type = sh_type;
    }

  switch (this_hdr->sh_type)
    {
    default:
      break;

    case SHT_STRTAB:
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
    case SHT_NOTE:
    case SHT_NOBITS:
    case SHT_PROGBITS:
      break;

    case SHT_HASH:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;

    case SHT_DYNSYM:
      this_hdr->sh_entsize = bed->s->sizeof_sym;
      break;

    case SHT_DYNAMIC:
      this_hdr->sh_entsize = bed->s->sizeof_dyn;
      break;

    case SHT_RELA:
      if (get_elf_backend_data (abfd)->may_use_rela_p)
	this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case SHT_REL:
      if (get_elf_backend_data (abfd)->may_use_rel_p)
	this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case SHT_GNU_versym:
      this_hdr->sh_entsize = sizeof (Elf_External_Versym);
      break;

     case SHT_GNU_verdef:
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
	 cverdefs.  The linker will set cverdefs, but sh_info will be
	 zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverdefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverdefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverdefs);
      break;

    case SHT_GNU_verneed:
      this_hdr->sh_entsize = 0;
      /* objcopy or strip will copy over sh_info, but may not set
	 cverrefs.  The linker will set cverrefs, but sh_info will be
	 zero.  */
      if (this_hdr->sh_info == 0)
	this_hdr->sh_info = elf_tdata (abfd)->cverrefs;
      else
	BFD_ASSERT (elf_tdata (abfd)->cverrefs == 0
		    || this_hdr->sh_info == elf_tdata (abfd)->cverrefs);
      break;

    case SHT_GROUP:
      this_hdr->sh_entsize = GRP_ENTRY_SIZE;
      break;

    case SHT_GNU_HASH:
      this_hdr->sh_entsize = bed->s->arch_size == 64 ? 0 : 4;
      break;
    }

  if ((asect->flags & SEC_ALLOC) != 0)
    this_hdr->sh_flags |= SHF_ALLOC;
  if ((asect->flags & SEC_READONLY) == 0)
    this_hdr->sh_flags |= SHF_WRITE;
  if ((asect->flags & SEC_CODE) != 0)
    this_hdr->sh_flags |= SHF_EXECINSTR;
  if ((asect->flags & SEC_MERGE) != 0)
    {
      this_hdr->sh_flags |= SHF_MERGE;
      this_hdr->sh_entsize = asect->entsize;
      if ((asect->flags & SEC_STRINGS) != 0)
	this_hdr->sh_flags |= SHF_STRINGS;
    }
  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)
    this_hdr->sh_flags |= SHF_GROUP;
  if ((asect->flags & SEC_THREAD_LOCAL) != 0)
    {
      this_hdr->sh_flags |= SHF_TLS;
      if (asect->size == 0
	  && (asect->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *o = asect->map_tail.link_order;

	  this_hdr->sh_size = 0;
	  if (o != NULL)
	    {
	      this_hdr->sh_size = o->offset + o->size;
	      if (this_hdr->sh_size != 0)
		this_hdr->sh_type = SHT_NOBITS;
	    }
	}
    }
  if ((asect->flags & (SEC_GROUP | SEC_EXCLUDE)) == SEC_EXCLUDE)
    this_hdr->sh_flags |= SHF_EXCLUDE;

  /* If the section has relocs, set up a section header for the
     SHT_REL[A] section.  If two relocation sections are required for
     this section, it is up to the processor-specific back-end to
     create the other.  */
  if ((asect->flags & SEC_RELOC) != 0)
    {
      /* When doing a relocatable link, create both REL and RELA sections if
	 needed.  */
      if (arg->link_info
	  /* Do the normal setup if we wouldn't create any sections here.  */
	  && esd->rel.count + esd->rela.count > 0
	  && (arg->link_info->relocatable || arg->link_info->emitrelocations))
	{
	  if (esd->rel.count && esd->rel.hdr == NULL
	      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rel, asect, FALSE))
	    {
	      arg->failed = TRUE;
	      return;
	    }
	  if (esd->rela.count && esd->rela.hdr == NULL
	      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, asect, TRUE))
	    {
	      arg->failed = TRUE;
	      return;
	    }
	}
      else if (!_bfd_elf_init_reloc_shdr (abfd,
					  (asect->use_rela_p
					   ? &esd->rela : &esd->rel),
					  asect,
					  asect->use_rela_p))
	  arg->failed = TRUE;
    }

  /* Check for processor-specific section types.  */
  sh_type = this_hdr->sh_type;
  if (bed->elf_backend_fake_sections
      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))
    arg->failed = TRUE;

  if (sh_type == SHT_NOBITS && asect->size != 0)
    {
      /* Don't change the header type from NOBITS if we are being
	 called for objcopy --only-keep-debug.  */
      this_hdr->sh_type = sh_type;
    }
}

/* Fill in the contents of a SHT_GROUP section.  Called from
   _bfd_elf_compute_section_file_positions for gas, objcopy, and
   when ELF targets use the generic linker, ld.  Called for ld -r
   from bfd_elf_final_link.  */

void
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
{
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
  asection *elt, *first;
  unsigned char *loc;
  bfd_boolean gas;

  /* Ignore linker created group section.  See elfNN_ia64_object_p in
     elfxx-ia64.c.  */
  if (((sec->flags & (SEC_GROUP | SEC_LINKER_CREATED)) != SEC_GROUP)
      || *failedptr)
    return;

  if (elf_section_data (sec)->this_hdr.sh_info == 0)
    {
      unsigned long symindx = 0;

      /* elf_group_id will have been set up by objcopy and the
	 generic linker.  */
      if (elf_group_id (sec) != NULL)
	symindx = elf_group_id (sec)->udata.i;

      if (symindx == 0)
	{
	  /* If called from the assembler, swap_out_syms will have set up
	     elf_section_syms.  */
	  BFD_ASSERT (elf_section_syms (abfd) != NULL);
	  symindx = elf_section_syms (abfd)[sec->index]->udata.i;
	}
      elf_section_data (sec)->this_hdr.sh_info = symindx;
    }
  else if (elf_section_data (sec)->this_hdr.sh_info == (unsigned int) -2)
    {
      /* The ELF backend linker sets sh_info to -2 when the group
	 signature symbol is global, and thus the index can't be
	 set until all local symbols are output.  */
      asection *igroup = elf_sec_group (elf_next_in_group (sec));
      struct bfd_elf_section_data *sec_data = elf_section_data (igroup);
      unsigned long symndx = sec_data->this_hdr.sh_info;
      unsigned long extsymoff = 0;
      struct elf_link_hash_entry *h;

      if (!elf_bad_symtab (igroup->owner))
	{
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata (igroup->owner)->symtab_hdr;
	  extsymoff = symtab_hdr->sh_info;
	}
      h = elf_sym_hashes (igroup->owner)[symndx - extsymoff];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      elf_section_data (sec)->this_hdr.sh_info = h->indx;
    }

  /* The contents won't be allocated for "ld -r" or objcopy.  */
  gas = TRUE;
  if (sec->contents == NULL)
    {
      gas = FALSE;
      sec->contents = (unsigned char *) bfd_alloc (abfd, sec->size);

      /* Arrange for the section to be written out.  */
      elf_section_data (sec)->this_hdr.contents = sec->contents;
      if (sec->contents == NULL)
	{
	  *failedptr = TRUE;
	  return;
	}
    }

  loc = sec->contents + sec->size;

  /* Get the pointer to the first section in the group that gas
     squirreled away here.  objcopy arranges for this to be set to the
     start of the input section group.  */
  first = elt = elf_next_in_group (sec);

  /* First element is a flag word.  Rest of section is elf section
     indices for all the sections of the group.  Write them backwards
     just to keep the group in the same order as given in .section
     directives, not that it matters.  */
  while (elt != NULL)
    {
      asection *s;

      s = elt;
      if (!gas)
	s = s->output_section;
      if (s != NULL
	  && !bfd_is_abs_section (s))
	{
	  unsigned int idx = elf_section_data (s)->this_idx;

	  loc -= 4;
	  H_PUT_32 (abfd, idx, loc);
	}
      elt = elf_next_in_group (elt);
      if (elt == first)
	break;
    }

  if ((loc -= 4) != sec->contents)
    abort ();

  H_PUT_32 (abfd, sec->flags & SEC_LINK_ONCE ? GRP_COMDAT : 0, loc);
}

/* Assign all ELF section numbers.  The dummy first section is handled here
   too.  The link/info pointers for the standard section types are filled
   in here too, while we're at it.  */

static bfd_boolean
assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
{
  struct elf_obj_tdata *t = elf_tdata (abfd);
  asection *sec;
  unsigned int section_number, secn;
  Elf_Internal_Shdr **i_shdrp;
  struct bfd_elf_section_data *d;
  bfd_boolean need_symtab;

  section_number = 1;

  _bfd_elf_strtab_clear_all_refs (elf_shstrtab (abfd));

  /* SHT_GROUP sections are in relocatable files only.  */
  if (link_info == NULL || link_info->relocatable)
    {
      /* Put SHT_GROUP sections first.  */
      for (sec = abfd->sections; sec != NULL; sec = sec->next)
	{
	  d = elf_section_data (sec);

	  if (d->this_hdr.sh_type == SHT_GROUP)
	    {
	      if (sec->flags & SEC_LINKER_CREATED)
		{
		  /* Remove the linker created SHT_GROUP sections.  */
		  bfd_section_list_remove (abfd, sec);
		  abfd->section_count--;
		}
	      else
		d->this_idx = section_number++;
	    }
	}
    }

  for (sec = abfd->sections; sec; sec = sec->next)
    {
      d = elf_section_data (sec);

      if (d->this_hdr.sh_type != SHT_GROUP)
	d->this_idx = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->this_hdr.sh_name);
      if (d->rel.hdr)
	{
	  d->rel.idx = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel.hdr->sh_name);
	}
      else
	d->rel.idx = 0;

      if (d->rela.hdr)
	{
	  d->rela.idx = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rela.hdr->sh_name);
	}
      else
	d->rela.idx = 0;
    }

  elf_shstrtab_sec (abfd) = section_number++;
  _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->shstrtab_hdr.sh_name);
  elf_elfheader (abfd)->e_shstrndx = elf_shstrtab_sec (abfd);

  need_symtab = (bfd_get_symcount (abfd) > 0
		|| (link_info == NULL
		    && ((abfd->flags & (EXEC_P | DYNAMIC | HAS_RELOC))
			== HAS_RELOC)));
  if (need_symtab)
    {
      elf_onesymtab (abfd) = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->symtab_hdr.sh_name);
      if (section_number > ((SHN_LORESERVE - 2) & 0xFFFF))
	{
	  elf_symtab_shndx (abfd) = section_number++;
	  t->symtab_shndx_hdr.sh_name
	    = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
						  ".symtab_shndx", FALSE);
	  if (t->symtab_shndx_hdr.sh_name == (unsigned int) -1)
	    return FALSE;
	}
      elf_strtab_sec (abfd) = section_number++;
      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);
    }

  if (section_number >= SHN_LORESERVE)
    {
      _bfd_error_handler (_("%B: too many sections: %u"),
			  abfd, section_number);
      return FALSE;
    }

  _bfd_elf_strtab_finalize (elf_shstrtab (abfd));
  t->shstrtab_hdr.sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));

  elf_numsections (abfd) = section_number;
  elf_elfheader (abfd)->e_shnum = section_number;

  /* Set up the list of section header pointers, in agreement with the
     indices.  */
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,
                                                sizeof (Elf_Internal_Shdr *));
  if (i_shdrp == NULL)
    return FALSE;

  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd,
                                                 sizeof (Elf_Internal_Shdr));
  if (i_shdrp[0] == NULL)
    {
      bfd_release (abfd, i_shdrp);
      return FALSE;
    }

  elf_elfsections (abfd) = i_shdrp;

  i_shdrp[elf_shstrtab_sec (abfd)] = &t->shstrtab_hdr;
  if (need_symtab)
    {
      i_shdrp[elf_onesymtab (abfd)] = &t->symtab_hdr;
      if (elf_numsections (abfd) > (SHN_LORESERVE & 0xFFFF))
	{
	  i_shdrp[elf_symtab_shndx (abfd)] = &t->symtab_shndx_hdr;
	  t->symtab_shndx_hdr.sh_link = elf_onesymtab (abfd);
	}
      i_shdrp[elf_strtab_sec (abfd)] = &t->strtab_hdr;
      t->symtab_hdr.sh_link = elf_strtab_sec (abfd);
    }

  for (sec = abfd->sections; sec; sec = sec->next)
    {
      asection *s;
      const char *name;

      d = elf_section_data (sec);

      i_shdrp[d->this_idx] = &d->this_hdr;
      if (d->rel.idx != 0)
	i_shdrp[d->rel.idx] = d->rel.hdr;
      if (d->rela.idx != 0)
	i_shdrp[d->rela.idx] = d->rela.hdr;

      /* Fill in the sh_link and sh_info fields while we're at it.  */

      /* sh_link of a reloc section is the section index of the symbol
	 table.  sh_info is the section index of the section to which
	 the relocation entries apply.  */
      if (d->rel.idx != 0)
	{
	  d->rel.hdr->sh_link = elf_onesymtab (abfd);
	  d->rel.hdr->sh_info = d->this_idx;
	}
      if (d->rela.idx != 0)
	{
	  d->rela.hdr->sh_link = elf_onesymtab (abfd);
	  d->rela.hdr->sh_info = d->this_idx;
	}

      /* We need to set up sh_link for SHF_LINK_ORDER.  */
      if ((d->this_hdr.sh_flags & SHF_LINK_ORDER) != 0)
	{
	  s = elf_linked_to_section (sec);
	  if (s)
	    {
	      /* elf_linked_to_section points to the input section.  */
	      if (link_info != NULL)
		{
		  /* Check discarded linkonce section.  */
		  if (discarded_section (s))
		    {
		      asection *kept;
		      (*_bfd_error_handler)
			(_("%B: sh_link of section `%A' points to discarded section `%A' of `%B'"),
			 abfd, d->this_hdr.bfd_section,
			 s, s->owner);
		      /* Point to the kept section if it has the same
			 size as the discarded one.  */
		      kept = _bfd_elf_check_kept_section (s, link_info);
		      if (kept == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      s = kept;
		    }

		  s = s->output_section;
		  BFD_ASSERT (s != NULL);
		}
	      else
		{
		  /* Handle objcopy. */
		  if (s->output_section == NULL)
		    {
		      (*_bfd_error_handler)
			(_("%B: sh_link of section `%A' points to removed section `%A' of `%B'"),
			 abfd, d->this_hdr.bfd_section, s, s->owner);
		      bfd_set_error (bfd_error_bad_value);
		      return FALSE;
		    }
		  s = s->output_section;
		}
	      d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	    }
	  else
	    {
	      /* PR 290:
		 The Intel C compiler generates SHT_IA_64_UNWIND with
		 SHF_LINK_ORDER.  But it doesn't set the sh_link or
		 sh_info fields.  Hence we could get the situation
		 where s is NULL.  */
	      const struct elf_backend_data *bed
		= get_elf_backend_data (abfd);
	      if (bed->link_order_error_handler)
		bed->link_order_error_handler
		  (_("%B: warning: sh_link not set for section `%A'"),
		   abfd, sec);
	    }
	}

      switch (d->this_hdr.sh_type)
	{
	case SHT_REL:
	case SHT_RELA:
	  /* A reloc section which we are treating as a normal BFD
	     section.  sh_link is the section index of the symbol
	     table.  sh_info is the section index of the section to
	     which the relocation entries apply.  We assume that an
	     allocated reloc section uses the dynamic symbol table.
	     FIXME: How can we be sure?  */
	  s = bfd_get_section_by_name (abfd, ".dynsym");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;

	  /* We look up the section the relocs apply to by name.  */
	  name = sec->name;
	  if (d->this_hdr.sh_type == SHT_REL)
	    name += 4;
	  else
	    name += 5;
	  s = bfd_get_section_by_name (abfd, name);
	  if (s != NULL)
	    d->this_hdr.sh_info = elf_section_data (s)->this_idx;
	  break;

	case SHT_STRTAB:
	  /* We assume that a section named .stab*str is a stabs
	     string section.  We look for a section with the same name
	     but without the trailing ``str'', and set its sh_link
	     field to point to this section.  */
	  if (CONST_STRNEQ (sec->name, ".stab")
	      && strcmp (sec->name + strlen (sec->name) - 3, "str") == 0)
	    {
	      size_t len;
	      char *alc;

	      len = strlen (sec->name);
	      alc = (char *) bfd_malloc (len - 2);
	      if (alc == NULL)
		return FALSE;
	      memcpy (alc, sec->name, len - 3);
	      alc[len - 3] = '\0';
	      s = bfd_get_section_by_name (abfd, alc);
	      free (alc);
	      if (s != NULL)
		{
		  elf_section_data (s)->this_hdr.sh_link = d->this_idx;

		  /* This is a .stab section.  */
		  if (elf_section_data (s)->this_hdr.sh_entsize == 0)
		    elf_section_data (s)->this_hdr.sh_entsize
		      = 4 + 2 * bfd_get_arch_size (abfd) / 8;
		}
	    }
	  break;

	case SHT_DYNAMIC:
	case SHT_DYNSYM:
	case SHT_GNU_verneed:
	case SHT_GNU_verdef:
	  /* sh_link is the section header index of the string table
	     used for the dynamic entries, or the symbol table, or the
	     version strings.  */
	  s = bfd_get_section_by_name (abfd, ".dynstr");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  break;

	case SHT_GNU_LIBLIST:
	  /* sh_link is the section header index of the prelink library
	     list used for the dynamic entries, or the symbol table, or
	     the version strings.  */
	  s = bfd_get_section_by_name (abfd, (sec->flags & SEC_ALLOC)
					     ? ".dynstr" : ".gnu.libstr");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  break;

	case SHT_HASH:
	case SHT_GNU_HASH:
	case SHT_GNU_versym:
	  /* sh_link is the section header index of the symbol table
	     this hash table or version table is for.  */
	  s = bfd_get_section_by_name (abfd, ".dynsym");
	  if (s != NULL)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  break;

	case SHT_GROUP:
	  d->this_hdr.sh_link = elf_onesymtab (abfd);
	}
    }

  for (secn = 1; secn < section_number; ++secn)
    if (i_shdrp[secn] == NULL)
      i_shdrp[secn] = i_shdrp[0];
    else
      i_shdrp[secn]->sh_name = _bfd_elf_strtab_offset (elf_shstrtab (abfd),
						       i_shdrp[secn]->sh_name);
  return TRUE;
}

static bfd_boolean
sym_is_global (bfd *abfd, asymbol *sym)
{
  /* If the backend has a special mapping, use it.  */
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);

  return ((sym->flags & (BSF_GLOBAL | BSF_WEAK | BSF_GNU_UNIQUE)) != 0
	  || bfd_is_und_section (bfd_get_section (sym))
	  || bfd_is_com_section (bfd_get_section (sym)));
}

/* Don't output section symbols for sections that are not going to be
   output, that are duplicates or there is no BFD section.  */

static bfd_boolean
ignore_section_sym (bfd *abfd, asymbol *sym)
{
  elf_symbol_type *type_ptr;

  if ((sym->flags & BSF_SECTION_SYM) == 0)
    return FALSE;

  type_ptr = elf_symbol_from (abfd, sym);
  return ((type_ptr != NULL
	   && type_ptr->internal_elf_sym.st_shndx != 0
	   && bfd_is_abs_section (sym->section))
	  || !(sym->section->owner == abfd
	       || (sym->section->output_section->owner == abfd
		   && sym->section->output_offset == 0)
	       || bfd_is_abs_section (sym->section)));
}

/* Map symbol from it's internal number to the external number, moving
   all local symbols to be at the head of the list.  */

static bfd_boolean
elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)
{
  unsigned int symcount = bfd_get_symcount (abfd);
  asymbol **syms = bfd_get_outsymbols (abfd);
  asymbol **sect_syms;
  unsigned int num_locals = 0;
  unsigned int num_globals = 0;
  unsigned int num_locals2 = 0;
  unsigned int num_globals2 = 0;
  int max_index = 0;
  unsigned int idx;
  asection *asect;
  asymbol **new_syms;

#ifdef DEBUG
  fprintf (stderr, "elf_map_symbols\n");
  fflush (stderr);
#endif

  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (max_index < asect->index)
	max_index = asect->index;
    }

  max_index++;
  sect_syms = (asymbol **) bfd_zalloc2 (abfd, max_index, sizeof (asymbol *));
  if (sect_syms == NULL)
    return FALSE;
  elf_section_syms (abfd) = sect_syms;
  elf_num_section_syms (abfd) = max_index;

  /* Init sect_syms entries for any section symbols we have already
     decided to output.  */
  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];

      if ((sym->flags & BSF_SECTION_SYM) != 0
	  && sym->value == 0
	  && !ignore_section_sym (abfd, sym)
	  && !bfd_is_abs_section (sym->section))
	{
	  asection *sec = sym->section;

	  if (sec->owner != abfd)
	    sec = sec->output_section;

	  sect_syms[sec->index] = syms[idx];
	}
    }

  /* Classify all of the symbols.  */
  for (idx = 0; idx < symcount; idx++)
    {
      if (sym_is_global (abfd, syms[idx]))
	num_globals++;
      else if (!ignore_section_sym (abfd, syms[idx]))
	num_locals++;
    }

  /* We will be adding a section symbol for each normal BFD section.  Most
     sections will already have a section symbol in outsymbols, but
     eg. SHT_GROUP sections will not, and we need the section symbol mapped
     at least in that case.  */
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == NULL)
	{
	  if (!sym_is_global (abfd, asect->symbol))
	    num_locals++;
	  else
	    num_globals++;
	}
    }

  /* Now sort the symbols so the local symbols are first.  */
  new_syms = (asymbol **) bfd_alloc2 (abfd, num_locals + num_globals,
                                      sizeof (asymbol *));

  if (new_syms == NULL)
    return FALSE;

  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];
      unsigned int i;

      if (sym_is_global (abfd, sym))
	i = num_locals + num_globals2++;
      else if (!ignore_section_sym (abfd, sym))
	i = num_locals2++;
      else
	continue;
      new_syms[i] = sym;
      sym->udata.i = i + 1;
    }
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == NULL)
	{
	  asymbol *sym = asect->symbol;
	  unsigned int i;

	  sect_syms[asect->index] = sym;
	  if (!sym_is_global (abfd, sym))
	    i = num_locals2++;
	  else
	    i = num_locals + num_globals2++;
	  new_syms[i] = sym;
	  sym->udata.i = i + 1;
	}
    }

  bfd_set_symtab (abfd, new_syms, num_locals + num_globals);

  *pnum_locals = num_locals;
  return TRUE;
}

/* Align to the maximum file alignment that could be required for any
   ELF data structure.  */

static inline file_ptr
align_file_position (file_ptr off, int align)
{
  return (off + align - 1) & ~(align - 1);
}

/* Assign a file position to a section, optionally aligning to the
   required section alignment.  */

file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
					   file_ptr offset,
					   bfd_boolean align)
{
  if (align && i_shdrp->sh_addralign > 1)
    offset = BFD_ALIGN (offset, i_shdrp->sh_addralign);
  i_shdrp->sh_offset = offset;
  if (i_shdrp->bfd_section != NULL)
    i_shdrp->bfd_section->filepos = offset;
  if (i_shdrp->sh_type != SHT_NOBITS)
    offset += i_shdrp->sh_size;
  return offset;
}

/* Compute the file positions we are going to put the sections at, and
   otherwise prepare to begin writing out the ELF file.  If LINK_INFO
   is not NULL, this is being called by the ELF backend linker.  */

bfd_boolean
_bfd_elf_compute_section_file_positions (bfd *abfd,
					 struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct fake_section_arg fsargs;
  bfd_boolean failed;
  struct bfd_strtab_hash *strtab = NULL;
  Elf_Internal_Shdr *shstrtab_hdr;
  bfd_boolean need_symtab;

  if (abfd->output_has_begun)
    return TRUE;

  /* Do any elf backend specific processing first.  */
  if (bed->elf_backend_begin_write_processing)
    (*bed->elf_backend_begin_write_processing) (abfd, link_info);

  if (! prep_headers (abfd))
    return FALSE;

  /* Post process the headers if necessary.  */
  if (bed->elf_backend_post_process_headers)
    (*bed->elf_backend_post_process_headers) (abfd, link_info);

  fsargs.failed = FALSE;
  fsargs.link_info = link_info;
  bfd_map_over_sections (abfd, elf_fake_sections, &fsargs);
  if (fsargs.failed)
    return FALSE;

  if (!assign_section_numbers (abfd, link_info))
    return FALSE;

  /* The backend linker builds symbol table information itself.  */
  need_symtab = (link_info == NULL
		 && (bfd_get_symcount (abfd) > 0
		     || ((abfd->flags & (EXEC_P | DYNAMIC | HAS_RELOC))
			 == HAS_RELOC)));
  if (need_symtab)
    {
      /* Non-zero if doing a relocatable link.  */
      int relocatable_p = ! (abfd->flags & (EXEC_P | DYNAMIC));

      if (! swap_out_syms (abfd, &strtab, relocatable_p))
	return FALSE;
    }

  failed = FALSE;
  if (link_info == NULL)
    {
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
	return FALSE;
    }

  shstrtab_hdr = &elf_tdata (abfd)->shstrtab_hdr;
  /* sh_name was set in prep_headers.  */
  shstrtab_hdr->sh_type = SHT_STRTAB;
  shstrtab_hdr->sh_flags = 0;
  shstrtab_hdr->sh_addr = 0;
  shstrtab_hdr->sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));
  shstrtab_hdr->sh_entsize = 0;
  shstrtab_hdr->sh_link = 0;
  shstrtab_hdr->sh_info = 0;
  /* sh_offset is set in assign_file_positions_except_relocs.  */
  shstrtab_hdr->sh_addralign = 1;

  if (!assign_file_positions_except_relocs (abfd, link_info))
    return FALSE;

  if (need_symtab)
    {
      file_ptr off;
      Elf_Internal_Shdr *hdr;

      off = elf_next_file_pos (abfd);

      hdr = &elf_tdata (abfd)->symtab_hdr;
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      if (hdr->sh_size != 0)
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      hdr = &elf_tdata (abfd)->strtab_hdr;
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

      elf_next_file_pos (abfd) = off;

      /* Now that we know where the .strtab section goes, write it
	 out.  */
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || ! _bfd_stringtab_emit (abfd, strtab))
	return FALSE;
      _bfd_stringtab_free (strtab);
    }

  abfd->output_has_begun = TRUE;

  return TRUE;
}

/* Make an initial estimate of the size of the program header.  If we
   get the number wrong here, we'll redo section placement.  */

static bfd_size_type
get_program_header_size (bfd *abfd, struct bfd_link_info *info)
{
  size_t segs;
  asection *s;
  const struct elf_backend_data *bed;

  /* Assume we will need exactly two PT_LOAD segments: one for text
     and one for data.  */
  segs = 2;

  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* If we have a loadable interpreter section, we need a
	 PT_INTERP segment.  In this case, assume we also need a
	 PT_PHDR segment, although that may not be true for all
	 targets.  */
      segs += 2;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
    {
      /* We need a PT_DYNAMIC segment.  */
      ++segs;
    }

  if (info != NULL && info->relro)
    {
      /* We need a PT_GNU_RELRO segment.  */
      ++segs;
    }

  if (elf_eh_frame_hdr (abfd))
    {
      /* We need a PT_GNU_EH_FRAME segment.  */
      ++segs;
    }

  if (elf_stack_flags (abfd))
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && CONST_STRNEQ (s->name, ".note"))
	{
	  /* We need a PT_NOTE segment.  */
	  ++segs;
	  /* Try to create just one PT_NOTE segment
	     for all adjacent loadable .note* sections.
	     gABI requires that within a PT_NOTE segment
	     (and also inside of each SHT_NOTE section)
	     each note is padded to a multiple of 4 size,
	     so we check whether the sections are correctly
	     aligned.  */
	  if (s->alignment_power == 2)
	    while (s->next != NULL
		   && s->next->alignment_power == 2
		   && (s->next->flags & SEC_LOAD) != 0
		   && CONST_STRNEQ (s->next->name, ".note"))
	      s = s->next;
	}
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  /* We need a PT_TLS segment.  */
	  ++segs;
	  break;
	}
    }

  /* Let the backend count up any program headers it might need.  */
  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_additional_program_headers)
    {
      int a;

      a = (*bed->elf_backend_additional_program_headers) (abfd, info);
      if (a == -1)
	abort ();
      segs += a;
    }

  return segs * bed->s->sizeof_phdr;
}

/* Find the segment that contains the output_section of section.  */

Elf_Internal_Phdr *
_bfd_elf_find_segment_containing_section (bfd * abfd, asection * section)
{
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  for (m = elf_seg_map (abfd), p = elf_tdata (abfd)->phdr;
       m != NULL;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
	if (m->sections[i] == section)
	  return p;
    }

  return NULL;
}

/* Create a mapping from a set of sections to a program segment.  */

static struct elf_segment_map *
make_mapping (bfd *abfd,
	      asection **sections,
	      unsigned int from,
	      unsigned int to,
	      bfd_boolean phdr)
{
  struct elf_segment_map *m;
  unsigned int i;
  asection **hdrpp;
  bfd_size_type amt;

  amt = sizeof (struct elf_segment_map);
  amt += (to - from - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
  if (m == NULL)
    return NULL;
  m->next = NULL;
  m->p_type = PT_LOAD;
  for (i = from, hdrpp = sections + from; i < to; i++, hdrpp++)
    m->sections[i - from] = *hdrpp;
  m->count = to - from;

  if (from == 0 && phdr)
    {
      /* Include the headers in the first PT_LOAD segment.  */
      m->includes_filehdr = 1;
      m->includes_phdrs = 1;
    }

  return m;
}

/* Create the PT_DYNAMIC segment, which includes DYNSEC.  Returns NULL
   on failure.  */

struct elf_segment_map *
_bfd_elf_make_dynamic_segment (bfd *abfd, asection *dynsec)
{
  struct elf_segment_map *m;

  m = (struct elf_segment_map *) bfd_zalloc (abfd,
                                             sizeof (struct elf_segment_map));
  if (m == NULL)
    return NULL;
  m->next = NULL;
  m->p_type = PT_DYNAMIC;
  m->count = 1;
  m->sections[0] = dynsec;

  return m;
}

/* Possibly add or remove segments from the segment map.  */

static bfd_boolean
elf_modify_segment_map (bfd *abfd,
			struct bfd_link_info *info,
			bfd_boolean remove_empty_load)
{
  struct elf_segment_map **m;
  const struct elf_backend_data *bed;

  /* The placement algorithm assumes that non allocated sections are
     not in PT_LOAD segments.  We ensure this here by removing such
     sections from the segment map.  We also remove excluded
     sections.  Finally, any PT_LOAD segment without sections is
     removed.  */
  m = &elf_seg_map (abfd);
  while (*m)
    {
      unsigned int i, new_count;

      for (new_count = 0, i = 0; i < (*m)->count; i++)
	{
	  if (((*m)->sections[i]->flags & SEC_EXCLUDE) == 0
	      && (((*m)->sections[i]->flags & SEC_ALLOC) != 0
		  || (*m)->p_type != PT_LOAD))
	    {
	      (*m)->sections[new_count] = (*m)->sections[i];
	      new_count++;
	    }
	}
      (*m)->count = new_count;

      if (remove_empty_load && (*m)->p_type == PT_LOAD && (*m)->count == 0)
	*m = (*m)->next;
      else
	m = &(*m)->next;
    }

  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_modify_segment_map != NULL)
    {
      if (!(*bed->elf_backend_modify_segment_map) (abfd, info))
	return FALSE;
    }

  return TRUE;
}

/* Set up a mapping from BFD sections to program segments.  */

bfd_boolean
_bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
{
  unsigned int count;
  struct elf_segment_map *m;
  asection **sections = NULL;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean no_user_phdrs;

  no_user_phdrs = elf_seg_map (abfd) == NULL;

  if (info != NULL)
    info->user_phdrs = !no_user_phdrs;

  if (no_user_phdrs && bfd_count_sections (abfd) != 0)
    {
      asection *s;
      unsigned int i;
      struct elf_segment_map *mfirst;
      struct elf_segment_map **pm;
      asection *last_hdr;
      bfd_vma last_size;
      unsigned int phdr_index;
      bfd_vma maxpagesize;
      asection **hdrpp;
      bfd_boolean phdr_in_segment = TRUE;
      bfd_boolean writable;
      int tls_count = 0;
      asection *first_tls = NULL;
      asection *dynsec, *eh_frame_hdr;
      bfd_size_type amt;
      bfd_vma addr_mask, wrap_to = 0;

      /* Select the allocated sections, and sort them.  */

      sections = (asection **) bfd_malloc2 (bfd_count_sections (abfd),
                                            sizeof (asection *));
      if (sections == NULL)
	goto error_return;

      /* Calculate top address, avoiding undefined behaviour of shift
	 left operator when shift count is equal to size of type
	 being shifted.  */
      addr_mask = ((bfd_vma) 1 << (bfd_arch_bits_per_address (abfd) - 1)) - 1;
      addr_mask = (addr_mask << 1) + 1;

      i = 0;
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_ALLOC) != 0)
	    {
	      sections[i] = s;
	      ++i;
	      /* A wrapping section potentially clashes with header.  */
	      if (((s->lma + s->size) & addr_mask) < (s->lma & addr_mask))
		wrap_to = (s->lma + s->size) & addr_mask;
	    }
	}
      BFD_ASSERT (i <= bfd_count_sections (abfd));
      count = i;

      qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);

      /* Build the mapping.  */

      mfirst = NULL;
      pm = &mfirst;

      /* If we have a .interp section, then create a PT_PHDR segment for
	 the program headers and a PT_INTERP segment for the .interp
	 section.  */
      s = bfd_get_section_by_name (abfd, ".interp");
      if (s != NULL && (s->flags & SEC_LOAD) != 0)
	{
	  amt = sizeof (struct elf_segment_map);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_PHDR;
	  /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
	  m->p_flags = PF_R | PF_X;
	  m->p_flags_valid = 1;
	  m->includes_phdrs = 1;

	  *pm = m;
	  pm = &m->next;

	  amt = sizeof (struct elf_segment_map);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_INTERP;
	  m->count = 1;
	  m->sections[0] = s;

	  *pm = m;
	  pm = &m->next;
	}

      /* Look through the sections.  We put sections in the same program
	 segment when the start of the second section can be placed within
	 a few bytes of the end of the first section.  */
      last_hdr = NULL;
      last_size = 0;
      phdr_index = 0;
      maxpagesize = bed->maxpagesize;
      writable = FALSE;
      dynsec = bfd_get_section_by_name (abfd, ".dynamic");
      if (dynsec != NULL
	  && (dynsec->flags & SEC_LOAD) == 0)
	dynsec = NULL;

      /* Deal with -Ttext or something similar such that the first section
	 is not adjacent to the program headers.  This is an
	 approximation, since at this point we don't know exactly how many
	 program headers we will need.  */
      if (count > 0)
	{
	  bfd_size_type phdr_size = elf_program_header_size (abfd);

	  if (phdr_size == (bfd_size_type) -1)
	    phdr_size = get_program_header_size (abfd, info);
	  phdr_size += bed->s->sizeof_ehdr;
	  if ((abfd->flags & D_PAGED) == 0
	      || (sections[0]->lma & addr_mask) < phdr_size
	      || ((sections[0]->lma & addr_mask) % maxpagesize
		  < phdr_size % maxpagesize)
	      || (sections[0]->lma & addr_mask & -maxpagesize) < wrap_to)
	    phdr_in_segment = FALSE;
	}

      for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)
	{
	  asection *hdr;
	  bfd_boolean new_segment;

	  hdr = *hdrpp;

	  /* See if this section and the last one will fit in the same
	     segment.  */

	  if (last_hdr == NULL)
	    {
	      /* If we don't have a segment yet, then we don't need a new
		 one (we build the last one after this loop).  */
	      new_segment = FALSE;
	    }
	  else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)
	    {
	      /* If this section has a different relation between the
		 virtual address and the load address, then we need a new
		 segment.  */
	      new_segment = TRUE;
	    }
	  else if (hdr->lma < last_hdr->lma + last_size
		   || last_hdr->lma + last_size < last_hdr->lma)
	    {
	      /* If this section has a load address that makes it overlap
		 the previous section, then we need a new segment.  */
	      new_segment = TRUE;
	    }
	  /* In the next test we have to be careful when last_hdr->lma is close
	     to the end of the address space.  If the aligned address wraps
	     around to the start of the address space, then there are no more
	     pages left in memory and it is OK to assume that the current
	     section can be included in the current segment.  */
	  else if ((BFD_ALIGN (last_hdr->lma + last_size, maxpagesize) + maxpagesize
		    > last_hdr->lma)
		   && (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize) + maxpagesize
		       <= hdr->lma))
	    {
	      /* If putting this section in this segment would force us to
		 skip a page in the segment, then we need a new segment.  */
	      new_segment = TRUE;
	    }
	  else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
		   && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
	    {
	      /* We don't want to put a loadable section after a
		 nonloadable section in the same segment.
		 Consider .tbss sections as loadable for this purpose.  */
	      new_segment = TRUE;
	    }
	  else if ((abfd->flags & D_PAGED) == 0)
	    {
	      /* If the file is not demand paged, which means that we
		 don't require the sections to be correctly aligned in the
		 file, then there is no other reason for a new segment.  */
	      new_segment = FALSE;
	    }
	  else if (! writable
		   && (hdr->flags & SEC_READONLY) == 0
		   && (((last_hdr->lma + last_size - 1) & -maxpagesize)
		       != (hdr->lma & -maxpagesize)))
	    {
	      /* We don't want to put a writable section in a read only
		 segment, unless they are on the same page in memory
		 anyhow.  We already know that the last section does not
		 bring us past the current section on the page, so the
		 only case in which the new section is not on the same
		 page as the previous section is when the previous section
		 ends precisely on a page boundary.  */
	      new_segment = TRUE;
	    }
	  else
	    {
	      /* Otherwise, we can use the same segment.  */
	      new_segment = FALSE;
	    }

	  /* Allow interested parties a chance to override our decision.  */
	  if (last_hdr != NULL
	      && info != NULL
	      && info->callbacks->override_segment_assignment != NULL)
	    new_segment
	      = info->callbacks->override_segment_assignment (info, abfd, hdr,
							      last_hdr,
							      new_segment);

	  if (! new_segment)
	    {
	      if ((hdr->flags & SEC_READONLY) == 0)
		writable = TRUE;
	      last_hdr = hdr;
	      /* .tbss sections effectively have zero size.  */
	      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
		  != SEC_THREAD_LOCAL)
		last_size = hdr->size;
	      else
		last_size = 0;
	      continue;
	    }

	  /* We need a new program segment.  We must create a new program
	     header holding all the sections from phdr_index until hdr.  */

	  m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
	  if (m == NULL)
	    goto error_return;

	  *pm = m;
	  pm = &m->next;

	  if ((hdr->flags & SEC_READONLY) == 0)
	    writable = TRUE;
	  else
	    writable = FALSE;

	  last_hdr = hdr;
	  /* .tbss sections effectively have zero size.  */
	  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	    last_size = hdr->size;
	  else
	    last_size = 0;
	  phdr_index = i;
	  phdr_in_segment = FALSE;
	}

      /* Create a final PT_LOAD program segment, but not if it's just
	 for .tbss.  */
      if (last_hdr != NULL
	  && (i - phdr_index != 1
	      || ((last_hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
		  != SEC_THREAD_LOCAL)))
	{
	  m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
	  if (m == NULL)
	    goto error_return;

	  *pm = m;
	  pm = &m->next;
	}

      /* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
      if (dynsec != NULL)
	{
	  m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
	  if (m == NULL)
	    goto error_return;
	  *pm = m;
	  pm = &m->next;
	}

      /* For each batch of consecutive loadable .note sections,
	 add a PT_NOTE segment.  We don't use bfd_get_section_by_name,
	 because if we link together nonloadable .note sections and
	 loadable .note sections, we will generate two .note sections
	 in the output file.  FIXME: Using names for section types is
	 bogus anyhow.  */
      for (s = abfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LOAD) != 0
	      && CONST_STRNEQ (s->name, ".note"))
	    {
	      asection *s2;

	      count = 1;
	      amt = sizeof (struct elf_segment_map);
	      if (s->alignment_power == 2)
		for (s2 = s; s2->next != NULL; s2 = s2->next)
		  {
		    if (s2->next->alignment_power == 2
			&& (s2->next->flags & SEC_LOAD) != 0
			&& CONST_STRNEQ (s2->next->name, ".note")
			&& align_power (s2->lma + s2->size, 2)
			   == s2->next->lma)
		      count++;
		    else
		      break;
		  }
	      amt += (count - 1) * sizeof (asection *);
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	      if (m == NULL)
		goto error_return;
	      m->next = NULL;
	      m->p_type = PT_NOTE;
	      m->count = count;
	      while (count > 1)
		{
		  m->sections[m->count - count--] = s;
		  BFD_ASSERT ((s->flags & SEC_THREAD_LOCAL) == 0);
		  s = s->next;
		}
	      m->sections[m->count - 1] = s;
	      BFD_ASSERT ((s->flags & SEC_THREAD_LOCAL) == 0);
	      *pm = m;
	      pm = &m->next;
	    }
	  if (s->flags & SEC_THREAD_LOCAL)
	    {
	      if (! tls_count)
		first_tls = s;
	      tls_count++;
	    }
	}

      /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
      if (tls_count > 0)
	{
	  amt = sizeof (struct elf_segment_map);
	  amt += (tls_count - 1) * sizeof (asection *);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_TLS;
	  m->count = tls_count;
	  /* Mandated PF_R.  */
	  m->p_flags = PF_R;
	  m->p_flags_valid = 1;
	  for (i = 0; i < (unsigned int) tls_count; ++i)
	    {
	      BFD_ASSERT (first_tls->flags & SEC_THREAD_LOCAL);
	      m->sections[i] = first_tls;
	      first_tls = first_tls->next;
	    }

	  *pm = m;
	  pm = &m->next;
	}

      /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME
	 segment.  */
      eh_frame_hdr = elf_eh_frame_hdr (abfd);
      if (eh_frame_hdr != NULL
	  && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
	{
	  amt = sizeof (struct elf_segment_map);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_GNU_EH_FRAME;
	  m->count = 1;
	  m->sections[0] = eh_frame_hdr->output_section;

	  *pm = m;
	  pm = &m->next;
	}

      if (elf_stack_flags (abfd))
	{
	  amt = sizeof (struct elf_segment_map);
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_GNU_STACK;
	  m->p_flags = elf_stack_flags (abfd);
	  m->p_align = bed->stack_align;
	  m->p_flags_valid = 1;
	  m->p_align_valid = m->p_align != 0;
	  if (info->stacksize > 0)
	    {
	      m->p_size = info->stacksize;
	      m->p_size_valid = 1;
	    }

	  *pm = m;
	  pm = &m->next;
	}

      if (info != NULL && info->relro)
	{
	  for (m = mfirst; m != NULL; m = m->next)
	    {
	      if (m->p_type == PT_LOAD
		  && m->count != 0
		  && m->sections[0]->vma >= info->relro_start
		  && m->sections[0]->vma < info->relro_end)
		{
		  i = m->count;
		  while (--i != (unsigned) -1)
		    if ((m->sections[i]->flags & (SEC_LOAD | SEC_HAS_CONTENTS))
			== (SEC_LOAD | SEC_HAS_CONTENTS))
		      break;

		  if (i == (unsigned) -1)
		    continue;

		  if (m->sections[i]->vma + m->sections[i]->size
		      >= info->relro_end)
		    break;
		}
	    }

	  /* Make a PT_GNU_RELRO segment only when it isn't empty.  */
	  if (m != NULL)
	    {
	      amt = sizeof (struct elf_segment_map);
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
	      if (m == NULL)
		goto error_return;
	      m->next = NULL;
	      m->p_type = PT_GNU_RELRO;
	      m->p_flags = PF_R;
	      m->p_flags_valid = 1;

	      *pm = m;
	      pm = &m->next;
	    }
	}

      free (sections);
      elf_seg_map (abfd) = mfirst;
    }

  if (!elf_modify_segment_map (abfd, info, no_user_phdrs))
    return FALSE;

  for (count = 0, m = elf_seg_map (abfd); m != NULL; m = m->next)
    ++count;
  elf_program_header_size (abfd) = count * bed->s->sizeof_phdr;

  return TRUE;

 error_return:
  if (sections != NULL)
    free (sections);
  return FALSE;
}

/* Sort sections by address.  */

static int
elf_sort_sections (const void *arg1, const void *arg2)
{
  const asection *sec1 = *(const asection **) arg1;
  const asection *sec2 = *(const asection **) arg2;
  bfd_size_type size1, size2;

  /* Sort by LMA first, since this is the address used to
     place the section into a segment.  */
  if (sec1->lma < sec2->lma)
    return -1;
  else if (sec1->lma > sec2->lma)
    return 1;

  /* Then sort by VMA.  Normally the LMA and the VMA will be
     the same, and this will do nothing.  */
  if (sec1->vma < sec2->vma)
    return -1;
  else if (sec1->vma > sec2->vma)
    return 1;

  /* Put !SEC_LOAD sections after SEC_LOAD ones.  */

#define TOEND(x) (((x)->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)

  if (TOEND (sec1))
    {
      if (TOEND (sec2))
	{
	  /* If the indicies are the same, do not return 0
	     here, but continue to try the next comparison.  */
	  if (sec1->target_index - sec2->target_index != 0)
	    return sec1->target_index - sec2->target_index;
	}
      else
	return 1;
    }
  else if (TOEND (sec2))
    return -1;

#undef TOEND

  /* Sort by size, to put zero sized sections
     before others at the same address.  */

  size1 = (sec1->flags & SEC_LOAD) ? sec1->size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->size : 0;

  if (size1 < size2)
    return -1;
  if (size1 > size2)
    return 1;

  return sec1->target_index - sec2->target_index;
}

/* Ian Lance Taylor writes:

   We shouldn't be using % with a negative signed number.  That's just
   not good.  We have to make sure either that the number is not
   negative, or that the number has an unsigned type.  When the types
   are all the same size they wind up as unsigned.  When file_ptr is a
   larger signed type, the arithmetic winds up as signed long long,
   which is wrong.

   What we're trying to say here is something like ``increase OFF by
   the least amount that will cause it to be equal to the VMA modulo
   the page size.''  */
/* In other words, something like:

   vma_offset = m->sections[0]->vma % bed->maxpagesize;
   off_offset = off % bed->maxpagesize;
   if (vma_offset < off_offset)
     adjustment = vma_offset + bed->maxpagesize - off_offset;
   else
     adjustment = vma_offset - off_offset;

   which can can be collapsed into the expression below.  */

static file_ptr
vma_page_aligned_bias (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
{
  return ((vma - off) % maxpagesize);
}

static void
print_segment_map (const struct elf_segment_map *m)
{
  unsigned int j;
  const char *pt = get_segment_type (m->p_type);
  char buf[32];

  if (pt == NULL)
    {
      if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	sprintf (buf, "LOPROC+%7.7x",
		 (unsigned int) (m->p_type - PT_LOPROC));
      else if (m->p_type >= PT_LOOS && m->p_type <= PT_HIOS)
	sprintf (buf, "LOOS+%7.7x",
		 (unsigned int) (m->p_type - PT_LOOS));
      else
	snprintf (buf, sizeof (buf), "%8.8x",
		  (unsigned int) m->p_type);
      pt = buf;
    }
  fflush (stdout);
  fprintf (stderr, "%s:", pt);
  for (j = 0; j < m->count; j++)
    fprintf (stderr, " %s", m->sections [j]->name);
  putc ('\n',stderr);
  fflush (stderr);
}

static bfd_boolean
write_zeros (bfd *abfd, file_ptr pos, bfd_size_type len)
{
  void *buf;
  bfd_boolean ret;

  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    return FALSE;
  buf = bfd_zmalloc (len);
  if (buf == NULL)
    return FALSE;
  ret = bfd_bwrite (buf, len, abfd) == len;
  free (buf);
  return ret;
}

/* Assign file positions to the sections based on the mapping from
   sections to segments.  This function also sets up some fields in
   the file header.  */

static bfd_boolean
assign_file_positions_for_load_sections (bfd *abfd,
					 struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *phdrs;
  Elf_Internal_Phdr *p;
  file_ptr off;
  bfd_size_type maxpagesize;
  unsigned int alloc;
  unsigned int i, j;
  bfd_vma header_pad = 0;

  if (link_info == NULL
      && !_bfd_elf_map_sections_to_segments (abfd, link_info))
    return FALSE;

  alloc = 0;
  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
    {
      ++alloc;
      if (m->header_size)
	header_pad = m->header_size;
    }

  if (alloc)
    {
      elf_elfheader (abfd)->e_phoff = bed->s->sizeof_ehdr;
      elf_elfheader (abfd)->e_phentsize = bed->s->sizeof_phdr;
    }
  else
    {
      /* PR binutils/12467.  */
      elf_elfheader (abfd)->e_phoff = 0;
      elf_elfheader (abfd)->e_phentsize = 0;
    }

  elf_elfheader (abfd)->e_phnum = alloc;

  if (elf_program_header_size (abfd) == (bfd_size_type) -1)
    elf_program_header_size (abfd) = alloc * bed->s->sizeof_phdr;
  else
    BFD_ASSERT (elf_program_header_size (abfd)
		>= alloc * bed->s->sizeof_phdr);

  if (alloc == 0)
    {
      elf_next_file_pos (abfd) = bed->s->sizeof_ehdr;
      return TRUE;
    }

  /* We're writing the size in elf_program_header_size (abfd),
     see assign_file_positions_except_relocs, so make sure we have
     that amount allocated, with trailing space cleared.
     The variable alloc contains the computed need, while
     elf_program_header_size (abfd) contains the size used for the
     layout.
     See ld/emultempl/elf-generic.em:gld${EMULATION_NAME}_map_segments
     where the layout is forced to according to a larger size in the
     last iterations for the testcase ld-elf/header.  */
  BFD_ASSERT (elf_program_header_size (abfd) % bed->s->sizeof_phdr
	      == 0);
  phdrs = (Elf_Internal_Phdr *)
     bfd_zalloc2 (abfd,
                  (elf_program_header_size (abfd) / bed->s->sizeof_phdr),
                  sizeof (Elf_Internal_Phdr));
  elf_tdata (abfd)->phdr = phdrs;
  if (phdrs == NULL)
    return FALSE;

  maxpagesize = 1;
  if ((abfd->flags & D_PAGED) != 0)
    maxpagesize = bed->maxpagesize;

  off = bed->s->sizeof_ehdr;
  off += alloc * bed->s->sizeof_phdr;
  if (header_pad < (bfd_vma) off)
    header_pad = 0;
  else
    header_pad -= off;
  off += header_pad;

  for (m = elf_seg_map (abfd), p = phdrs, j = 0;
       m != NULL;
       m = m->next, p++, j++)
    {
      asection **secpp;
      bfd_vma off_adjust;
      bfd_boolean no_contents;

      /* If elf_segment_map is not from map_sections_to_segments, the
	 sections may not be correctly ordered.  NOTE: sorting should
	 not be done to the PT_NOTE section of a corefile, which may
	 contain several pseudo-sections artificially created by bfd.
	 Sorting these pseudo-sections breaks things badly.  */
      if (m->count > 1
	  && !(elf_elfheader (abfd)->e_type == ET_CORE
	       && m->p_type == PT_NOTE))
	qsort (m->sections, (size_t) m->count, sizeof (asection *),
	       elf_sort_sections);

      /* An ELF segment (described by Elf_Internal_Phdr) may contain a
	 number of sections with contents contributing to both p_filesz
	 and p_memsz, followed by a number of sections with no contents
	 that just contribute to p_memsz.  In this loop, OFF tracks next
	 available file offset for PT_LOAD and PT_NOTE segments.  */
      p->p_type = m->p_type;
      p->p_flags = m->p_flags;

      if (m->count == 0)
	p->p_vaddr = 0;
      else
	p->p_vaddr = m->sections[0]->vma - m->p_vaddr_offset;

      if (m->p_paddr_valid)
	p->p_paddr = m->p_paddr;
      else if (m->count == 0)
	p->p_paddr = 0;
      else
	p->p_paddr = m->sections[0]->lma - m->p_vaddr_offset;

      if (p->p_type == PT_LOAD
	  && (abfd->flags & D_PAGED) != 0)
	{
	  /* p_align in demand paged PT_LOAD segments effectively stores
	     the maximum page size.  When copying an executable with
	     objcopy, we set m->p_align from the input file.  Use this
	     value for maxpagesize rather than bed->maxpagesize, which
	     may be different.  Note that we use maxpagesize for PT_TLS
	     segment alignment later in this function, so we are relying
	     on at least one PT_LOAD segment appearing before a PT_TLS
	     segment.  */
	  if (m->p_align_valid)
	    maxpagesize = m->p_align;

	  p->p_align = maxpagesize;
	}
      else if (m->p_align_valid)
	p->p_align = m->p_align;
      else if (m->count == 0)
	p->p_align = 1 << bed->s->log_file_align;
      else
	p->p_align = 0;

      no_contents = FALSE;
      off_adjust = 0;
      if (p->p_type == PT_LOAD
	  && m->count > 0)
	{
	  bfd_size_type align;
	  unsigned int align_power = 0;

	  if (m->p_align_valid)
	    align = p->p_align;
	  else
	    {
	      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
		{
		  unsigned int secalign;

		  secalign = bfd_get_section_alignment (abfd, *secpp);
		  if (secalign > align_power)
		    align_power = secalign;
		}
	      align = (bfd_size_type) 1 << align_power;
	      if (align < maxpagesize)
		align = maxpagesize;
	    }

	  for (i = 0; i < m->count; i++)
	    if ((m->sections[i]->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      /* If we aren't making room for this section, then
		 it must be SHT_NOBITS regardless of what we've
		 set via struct bfd_elf_special_section.  */
	      elf_section_type (m->sections[i]) = SHT_NOBITS;

	  /* Find out whether this segment contains any loadable
	     sections.  */
	  no_contents = TRUE;
	  for (i = 0; i < m->count; i++)
	    if (elf_section_type (m->sections[i]) != SHT_NOBITS)
	      {
		no_contents = FALSE;
		break;
	      }

	  off_adjust = vma_page_aligned_bias (p->p_vaddr, off, align);
	  off += off_adjust;
	  if (no_contents)
	    {
	      /* We shouldn't need to align the segment on disk since
		 the segment doesn't need file space, but the gABI
		 arguably requires the alignment and glibc ld.so
		 checks it.  So to comply with the alignment
		 requirement but not waste file space, we adjust
		 p_offset for just this segment.  (OFF_ADJUST is
		 subtracted from OFF later.)  This may put p_offset
		 past the end of file, but that shouldn't matter.  */
	    }
	  else
	    off_adjust = 0;
	}
      /* Make sure the .dynamic section is the first section in the
	 PT_DYNAMIC segment.  */
      else if (p->p_type == PT_DYNAMIC
	       && m->count > 1
	       && strcmp (m->sections[0]->name, ".dynamic") != 0)
	{
	  _bfd_error_handler
	    (_("%B: The first section in the PT_DYNAMIC segment is not the .dynamic section"),
	     abfd);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      /* Set the note section type to SHT_NOTE.  */
      else if (p->p_type == PT_NOTE)
	for (i = 0; i < m->count; i++)
	  elf_section_type (m->sections[i]) = SHT_NOTE;

      p->p_offset = 0;
      p->p_filesz = 0;
      p->p_memsz = 0;

      if (m->includes_filehdr)
	{
	  if (!m->p_flags_valid)
	    p->p_flags |= PF_R;
	  p->p_filesz = bed->s->sizeof_ehdr;
	  p->p_memsz = bed->s->sizeof_ehdr;
	  if (m->count > 0)
	    {
	      if (p->p_vaddr < (bfd_vma) off)
		{
		  (*_bfd_error_handler)
		    (_("%B: Not enough room for program headers, try linking with -N"),
		     abfd);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}

	      p->p_vaddr -= off;
	      if (!m->p_paddr_valid)
		p->p_paddr -= off;
	    }
	}

      if (m->includes_phdrs)
	{
	  if (!m->p_flags_valid)
	    p->p_flags |= PF_R;

	  if (!m->includes_filehdr)
	    {
	      p->p_offset = bed->s->sizeof_ehdr;

	      if (m->count > 0)
		{
		  p->p_vaddr -= off - p->p_offset;
		  if (!m->p_paddr_valid)
		    p->p_paddr -= off - p->p_offset;
		}
	    }

	  p->p_filesz += alloc * bed->s->sizeof_phdr;
	  p->p_memsz += alloc * bed->s->sizeof_phdr;
	  if (m->count)
	    {
	      p->p_filesz += header_pad;
	      p->p_memsz += header_pad;
	    }
	}

      if (p->p_type == PT_LOAD
	  || (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core))
	{
	  if (!m->includes_filehdr && !m->includes_phdrs)
	    p->p_offset = off;
	  else
	    {
	      file_ptr adjust;

	      adjust = off - (p->p_offset + p->p_filesz);
	      if (!no_contents)
		p->p_filesz += adjust;
	      p->p_memsz += adjust;
	    }
	}

      /* Set up p_filesz, p_memsz, p_align and p_flags from the section
	 maps.  Set filepos for sections in PT_LOAD segments, and in
	 core files, for sections in PT_NOTE segments.
	 assign_file_positions_for_non_load_sections will set filepos
	 for other sections and update p_filesz for other segments.  */
      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
	{
	  asection *sec;
	  bfd_size_type align;
	  Elf_Internal_Shdr *this_hdr;

	  sec = *secpp;
	  this_hdr = &elf_section_data (sec)->this_hdr;
	  align = (bfd_size_type) 1 << bfd_get_section_alignment (abfd, sec);

	  if ((p->p_type == PT_LOAD
	       || p->p_type == PT_TLS)
	      && (this_hdr->sh_type != SHT_NOBITS
		  || ((this_hdr->sh_flags & SHF_ALLOC) != 0
		      && ((this_hdr->sh_flags & SHF_TLS) == 0
			  || p->p_type == PT_TLS))))
	    {
	      bfd_vma p_start = p->p_paddr;
	      bfd_vma p_end = p_start + p->p_memsz;
	      bfd_vma s_start = sec->lma;
	      bfd_vma adjust = s_start - p_end;

	      if (adjust != 0
		  && (s_start < p_end
		      || p_end < p_start))
		{
		  (*_bfd_error_handler)
		    (_("%B: section %A lma %#lx adjusted to %#lx"), abfd, sec,
		     (unsigned long) s_start, (unsigned long) p_end);
		  adjust = 0;
		  sec->lma = p_end;
		}
	      p->p_memsz += adjust;

	      if (this_hdr->sh_type != SHT_NOBITS)
		{
		  if (p->p_filesz + adjust < p->p_memsz)
		    {
		      /* We have a PROGBITS section following NOBITS ones.
		         Allocate file space for the NOBITS section(s) and
			 zero it.  */
		      adjust = p->p_memsz - p->p_filesz;
		      if (!write_zeros (abfd, off, adjust))
			return FALSE;
		    }
		  off += adjust;
		  p->p_filesz += adjust;
		}
	    }

	  if (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core)
	    {
	      /* The section at i == 0 is the one that actually contains
		 everything.  */
	      if (i == 0)
		{
		  this_hdr->sh_offset = sec->filepos = off;
		  off += this_hdr->sh_size;
		  p->p_filesz = this_hdr->sh_size;
		  p->p_memsz = 0;
		  p->p_align = 1;
		}
	      else
		{
		  /* The rest are fake sections that shouldn't be written.  */
		  sec->filepos = 0;
		  sec->size = 0;
		  sec->flags = 0;
		  continue;
		}
	    }
	  else
	    {
	      if (p->p_type == PT_LOAD)
		{
		  this_hdr->sh_offset = sec->filepos = off;
		  if (this_hdr->sh_type != SHT_NOBITS)
		    off += this_hdr->sh_size;
		}
	      else if (this_hdr->sh_type == SHT_NOBITS
		       && (this_hdr->sh_flags & SHF_TLS) != 0
		       && this_hdr->sh_offset == 0)
		{
		  /* This is a .tbss section that didn't get a PT_LOAD.
		     (See _bfd_elf_map_sections_to_segments "Create a
		     final PT_LOAD".)  Set sh_offset to the value it
		     would have if we had created a zero p_filesz and
		     p_memsz PT_LOAD header for the section.  This
		     also makes the PT_TLS header have the same
		     p_offset value.  */
		  bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
							  off, align);
		  this_hdr->sh_offset = sec->filepos = off + adjust;
		}

	      if (this_hdr->sh_type != SHT_NOBITS)
		{
		  p->p_filesz += this_hdr->sh_size;
		  /* A load section without SHF_ALLOC is something like
		     a note section in a PT_NOTE segment.  These take
		     file space but are not loaded into memory.  */
		  if ((this_hdr->sh_flags & SHF_ALLOC) != 0)
		    p->p_memsz += this_hdr->sh_size;
		}
	      else if ((this_hdr->sh_flags & SHF_ALLOC) != 0)
		{
		  if (p->p_type == PT_TLS)
		    p->p_memsz += this_hdr->sh_size;

		  /* .tbss is special.  It doesn't contribute to p_memsz of
		     normal segments.  */
		  else if ((this_hdr->sh_flags & SHF_TLS) == 0)
		    p->p_memsz += this_hdr->sh_size;
		}

	      if (align > p->p_align
		  && !m->p_align_valid
		  && (p->p_type != PT_LOAD
		      || (abfd->flags & D_PAGED) == 0))
		p->p_align = align;
	    }

	  if (!m->p_flags_valid)
	    {
	      p->p_flags |= PF_R;
	      if ((this_hdr->sh_flags & SHF_EXECINSTR) != 0)
		p->p_flags |= PF_X;
	      if ((this_hdr->sh_flags & SHF_WRITE) != 0)
		p->p_flags |= PF_W;
	    }
	}
      off -= off_adjust;

      /* Check that all sections are in a PT_LOAD segment.
	 Don't check funky gdb generated core files.  */
      if (p->p_type == PT_LOAD && bfd_get_format (abfd) != bfd_core)
	{
	  bfd_boolean check_vma = TRUE;

	  for (i = 1; i < m->count; i++)
	    if (m->sections[i]->vma == m->sections[i - 1]->vma
		&& ELF_SECTION_SIZE (&(elf_section_data (m->sections[i])
				       ->this_hdr), p) != 0
		&& ELF_SECTION_SIZE (&(elf_section_data (m->sections[i - 1])
				       ->this_hdr), p) != 0)
	      {
		/* Looks like we have overlays packed into the segment.  */
		check_vma = FALSE;
		break;
	      }

	  for (i = 0; i < m->count; i++)
	    {
	      Elf_Internal_Shdr *this_hdr;
	      asection *sec;

	      sec = m->sections[i];
	      this_hdr = &(elf_section_data(sec)->this_hdr);
	      if (!ELF_SECTION_IN_SEGMENT_1 (this_hdr, p, check_vma, 0)
		  && !ELF_TBSS_SPECIAL (this_hdr, p))
		{
		  (*_bfd_error_handler)
		    (_("%B: section `%A' can't be allocated in segment %d"),
		     abfd, sec, j);
		  print_segment_map (m);
		}
	    }
	}
    }

  elf_next_file_pos (abfd) = off;
  return TRUE;
}

/* Assign file positions for the other sections.  */

static bfd_boolean
assign_file_positions_for_non_load_sections (bfd *abfd,
					     struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  Elf_Internal_Shdr **i_shdrpp;
  Elf_Internal_Shdr **hdrpp;
  Elf_Internal_Phdr *phdrs;
  Elf_Internal_Phdr *p;
  struct elf_segment_map *m;
  struct elf_segment_map *hdrs_segment;
  bfd_vma filehdr_vaddr, filehdr_paddr;
  bfd_vma phdrs_vaddr, phdrs_paddr;
  file_ptr off;
  unsigned int num_sec;
  unsigned int i;
  unsigned int count;

  i_shdrpp = elf_elfsections (abfd);
  num_sec = elf_numsections (abfd);
  off = elf_next_file_pos (abfd);
  for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
    {
      Elf_Internal_Shdr *hdr;

      hdr = *hdrpp;
      if (hdr->bfd_section != NULL
	  && (hdr->bfd_section->filepos != 0
	      || (hdr->sh_type == SHT_NOBITS
		  && hdr->contents == NULL)))
	BFD_ASSERT (hdr->sh_offset == hdr->bfd_section->filepos);
      else if ((hdr->sh_flags & SHF_ALLOC) != 0)
	{
	  if (hdr->sh_size != 0)
	    (*_bfd_error_handler)
	      (_("%B: warning: allocated section `%s' not in segment"),
	       abfd,
	       (hdr->bfd_section == NULL
		? "*unknown*"
		: hdr->bfd_section->name));
	  /* We don't need to page align empty sections.  */
	  if ((abfd->flags & D_PAGED) != 0 && hdr->sh_size != 0)
	    off += vma_page_aligned_bias (hdr->sh_addr, off,
					  bed->maxpagesize);
	  else
	    off += vma_page_aligned_bias (hdr->sh_addr, off,
					  hdr->sh_addralign);
	  off = _bfd_elf_assign_file_position_for_section (hdr, off,
							   FALSE);
	}
      else if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
		&& hdr->bfd_section == NULL)
	       || hdr == i_shdrpp[elf_onesymtab (abfd)]
	       || hdr == i_shdrpp[elf_symtab_shndx (abfd)]
	       || hdr == i_shdrpp[elf_strtab_sec (abfd)])
	hdr->sh_offset = -1;
      else
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
    }

  /* Now that we have set the section file positions, we can set up
     the file positions for the non PT_LOAD segments.  */
  count = 0;
  filehdr_vaddr = 0;
  filehdr_paddr = 0;
  phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;
  phdrs_paddr = 0;
  hdrs_segment = NULL;
  phdrs = elf_tdata (abfd)->phdr;
  for (m = elf_seg_map (abfd), p = phdrs; m != NULL; m = m->next, p++)
    {
      ++count;
      if (p->p_type != PT_LOAD)
	continue;

      if (m->includes_filehdr)
	{
	  filehdr_vaddr = p->p_vaddr;
	  filehdr_paddr = p->p_paddr;
	}
      if (m->includes_phdrs)
	{
	  phdrs_vaddr = p->p_vaddr;
	  phdrs_paddr = p->p_paddr;
	  if (m->includes_filehdr)
	    {
	      hdrs_segment = m;
	      phdrs_vaddr += bed->s->sizeof_ehdr;
	      phdrs_paddr += bed->s->sizeof_ehdr;
	    }
	}
    }

  if (hdrs_segment != NULL && link_info != NULL)
    {
      /* There is a segment that contains both the file headers and the
	 program headers, so provide a symbol __ehdr_start pointing there.
	 A program can use this to examine itself robustly.  */

      struct elf_link_hash_entry *hash
	= elf_link_hash_lookup (elf_hash_table (link_info), "__ehdr_start",
				FALSE, FALSE, TRUE);
      /* If the symbol was referenced and not defined, define it.  */
      if (hash != NULL
	  && (hash->root.type == bfd_link_hash_new
	      || hash->root.type == bfd_link_hash_undefined
	      || hash->root.type == bfd_link_hash_undefweak
	      || hash->root.type == bfd_link_hash_common))
	{
	  asection *s = NULL;
	  if (hdrs_segment->count != 0)
	    /* The segment contains sections, so use the first one.  */
	    s = hdrs_segment->sections[0];
	  else
	    /* Use the first (i.e. lowest-addressed) section in any segment.  */
	    for (m = elf_seg_map (abfd); m != NULL; m = m->next)
	      if (m->count != 0)
		{
		  s = m->sections[0];
		  break;
		}

	  if (s != NULL)
	    {
	      hash->root.u.def.value = filehdr_vaddr - s->vma;
	      hash->root.u.def.section = s;
	    }
	  else
	    {
	      hash->root.u.def.value = filehdr_vaddr;
	      hash->root.u.def.section = bfd_abs_section_ptr;
	    }

	  hash->root.type = bfd_link_hash_defined;
	  hash->def_regular = 1;
	  hash->non_elf = 0;
	}
    }

  for (m = elf_seg_map (abfd), p = phdrs; m != NULL; m = m->next, p++)
    {
      if (p->p_type == PT_GNU_RELRO)
	{
	  const Elf_Internal_Phdr *lp;
	  struct elf_segment_map *lm;

	  if (link_info != NULL)
	    {
	      /* During linking the range of the RELRO segment is passed
		 in link_info.  */
	      for (lm = elf_seg_map (abfd), lp = phdrs;
		   lm != NULL;
		   lm = lm->next, lp++)
		{
		  if (lp->p_type == PT_LOAD
		      && lp->p_vaddr < link_info->relro_end
		      && lp->p_vaddr + lp->p_filesz >= link_info->relro_end
		      && lm->count != 0
		      && lm->sections[0]->vma >= link_info->relro_start)
		    break;
		}

	      /* PR ld/14207.  If the RELRO segment doesn't fit in the
		 LOAD segment, it should be removed.  */
	      BFD_ASSERT (lm != NULL);
	    }
	  else
	    {
	      /* Otherwise we are copying an executable or shared
		 library, but we need to use the same linker logic.  */
	      for (lp = phdrs; lp < phdrs + count; ++lp)
		{
		  if (lp->p_type == PT_LOAD
		      && lp->p_paddr == p->p_paddr)
		    break;
		}
	    }

	  if (lp < phdrs + count)
	    {
	      p->p_vaddr = lp->p_vaddr;
	      p->p_paddr = lp->p_paddr;
	      p->p_offset = lp->p_offset;
	      if (link_info != NULL)
		p->p_filesz = link_info->relro_end - lp->p_vaddr;
	      else if (m->p_size_valid)
		p->p_filesz = m->p_size;
	      else
		abort ();
	      p->p_memsz = p->p_filesz;
	      /* Preserve the alignment and flags if they are valid. The
	         gold linker generates RW/4 for the PT_GNU_RELRO section.
		 It is better for objcopy/strip to honor these attributes
		 otherwise gdb will choke when using separate debug files.
	       */
	      if (!m->p_align_valid)
		p->p_align = 1;
	      if (!m->p_flags_valid)
		p->p_flags = (lp->p_flags & ~PF_W);
	    }
	  else
	    {
	      memset (p, 0, sizeof *p);
	      p->p_type = PT_NULL;
	    }
	}
      else if (p->p_type == PT_GNU_STACK)
	{
	  if (m->p_size_valid)
	    p->p_memsz = m->p_size;
	}
      else if (m->count != 0)
	{
	  if (p->p_type != PT_LOAD
	      && (p->p_type != PT_NOTE
		  || bfd_get_format (abfd) != bfd_core))
	    {
	      BFD_ASSERT (!m->includes_filehdr && !m->includes_phdrs);

	      p->p_filesz = 0;
	      p->p_offset = m->sections[0]->filepos;
	      for (i = m->count; i-- != 0;)
		{
		  asection *sect = m->sections[i];
		  Elf_Internal_Shdr *hdr = &elf_section_data (sect)->this_hdr;
		  if (hdr->sh_type != SHT_NOBITS)
		    {
		      p->p_filesz = (sect->filepos - m->sections[0]->filepos
				     + hdr->sh_size);
		      break;
		    }
		}
	    }
	}
      else if (m->includes_filehdr)
	{
	  p->p_vaddr = filehdr_vaddr;
	  if (! m->p_paddr_valid)
	    p->p_paddr = filehdr_paddr;
	}
      else if (m->includes_phdrs)
	{
	  p->p_vaddr = phdrs_vaddr;
	  if (! m->p_paddr_valid)
	    p->p_paddr = phdrs_paddr;
	}
    }

  elf_next_file_pos (abfd) = off;

  return TRUE;
}

/* Work out the file positions of all the sections.  This is called by
   _bfd_elf_compute_section_file_positions.  All the section sizes and
   VMAs must be known before this is called.

   Reloc sections come in two flavours: Those processed specially as
   "side-channel" data attached to a section to which they apply, and
   those that bfd doesn't process as relocations.  The latter sort are
   stored in a normal bfd section by bfd_section_from_shdr.   We don't
   consider the former sort here, unless they form part of the loadable
   image.  Reloc sections not assigned here will be handled later by
   assign_file_positions_for_relocs.

   We also don't set the positions of the .symtab and .strtab here.  */

static bfd_boolean
assign_file_positions_except_relocs (bfd *abfd,
				     struct bfd_link_info *link_info)
{
  struct elf_obj_tdata *tdata = elf_tdata (abfd);
  Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);
  file_ptr off;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      && bfd_get_format (abfd) != bfd_core)
    {
      Elf_Internal_Shdr ** const i_shdrpp = elf_elfsections (abfd);
      unsigned int num_sec = elf_numsections (abfd);
      Elf_Internal_Shdr **hdrpp;
      unsigned int i;

      /* Start after the ELF header.  */
      off = i_ehdrp->e_ehsize;

      /* We are not creating an executable, which means that we are
	 not creating a program header, and that the actual order of
	 the sections in the file is unimportant.  */
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
	{
	  Elf_Internal_Shdr *hdr;

	  hdr = *hdrpp;
	  if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
	       && hdr->bfd_section == NULL)
	      || i == elf_onesymtab (abfd)
	      || i == elf_symtab_shndx (abfd)
	      || i == elf_strtab_sec (abfd))
	    {
	      hdr->sh_offset = -1;
	    }
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
	}
    }
  else
    {
      unsigned int alloc;

      /* Assign file positions for the loaded sections based on the
	 assignment of sections to segments.  */
      if (!assign_file_positions_for_load_sections (abfd, link_info))
	return FALSE;

      /* And for non-load sections.  */
      if (!assign_file_positions_for_non_load_sections (abfd, link_info))
	return FALSE;

      if (bed->elf_backend_modify_program_headers != NULL)
	{
	  if (!(*bed->elf_backend_modify_program_headers) (abfd, link_info))
	    return FALSE;
	}

      /* Write out the program headers.  */
      alloc = elf_program_header_size (abfd) / bed->s->sizeof_phdr;
      if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, SEEK_SET) != 0
	  || bed->s->write_out_phdrs (abfd, tdata->phdr, alloc) != 0)
	return FALSE;

      off = elf_next_file_pos (abfd);
    }

  /* Place the section headers.  */
  off = align_file_position (off, 1 << bed->s->log_file_align);
  i_ehdrp->e_shoff = off;
  off += i_ehdrp->e_shnum * i_ehdrp->e_shentsize;

  elf_next_file_pos (abfd) = off;

  return TRUE;
}

static bfd_boolean
prep_headers (bfd *abfd)
{
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form.  */
  struct elf_strtab_hash *shstrtab;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  i_ehdrp = elf_elfheader (abfd);

  shstrtab = _bfd_elf_strtab_init ();
  if (shstrtab == NULL)
    return FALSE;

  elf_shstrtab (abfd) = shstrtab;

  i_ehdrp->e_ident[EI_MAG0] = ELFMAG0;
  i_ehdrp->e_ident[EI_MAG1] = ELFMAG1;
  i_ehdrp->e_ident[EI_MAG2] = ELFMAG2;
  i_ehdrp->e_ident[EI_MAG3] = ELFMAG3;

  i_ehdrp->e_ident[EI_CLASS] = bed->s->elfclass;
  i_ehdrp->e_ident[EI_DATA] =
    bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;
  i_ehdrp->e_ident[EI_VERSION] = bed->s->ev_current;

  if ((abfd->flags & DYNAMIC) != 0)
    i_ehdrp->e_type = ET_DYN;
  else if ((abfd->flags & EXEC_P) != 0)
    i_ehdrp->e_type = ET_EXEC;
  else if (bfd_get_format (abfd) == bfd_core)
    i_ehdrp->e_type = ET_CORE;
  else
    i_ehdrp->e_type = ET_REL;

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_unknown:
      i_ehdrp->e_machine = EM_NONE;
      break;

      /* There used to be a long list of cases here, each one setting
	 e_machine to the same EM_* macro #defined as ELF_MACHINE_CODE
	 in the corresponding bfd definition.  To avoid duplication,
	 the switch was removed.  Machines that need special handling
	 can generally do it in elf_backend_final_write_processing(),
	 unless they need the information earlier than the final write.
	 Such need can generally be supplied by replacing the tests for
	 e_machine with the conditions used to determine it.  */
    default:
      i_ehdrp->e_machine = bed->elf_machine_code;
    }

  i_ehdrp->e_version = bed->s->ev_current;
  i_ehdrp->e_ehsize = bed->s->sizeof_ehdr;

  /* No program header, for now.  */
  i_ehdrp->e_phoff = 0;
  i_ehdrp->e_phentsize = 0;
  i_ehdrp->e_phnum = 0;

  /* Each bfd section is section header entry.  */
  i_ehdrp->e_entry = bfd_get_start_address (abfd);
  i_ehdrp->e_shentsize = bed->s->sizeof_shdr;

  /* If we're building an executable, we'll need a program header table.  */
  if (abfd->flags & EXEC_P)
    /* It all happens later.  */
    ;
  else
    {
      i_ehdrp->e_phentsize = 0;
      i_ehdrp->e_phoff = 0;
    }

  elf_tdata (abfd)->symtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", FALSE);
  elf_tdata (abfd)->strtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", FALSE);
  elf_tdata (abfd)->shstrtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", FALSE);
  if (elf_tdata (abfd)->symtab_hdr.sh_name == (unsigned int) -1
      || elf_tdata (abfd)->symtab_hdr.sh_name == (unsigned int) -1
      || elf_tdata (abfd)->shstrtab_hdr.sh_name == (unsigned int) -1)
    return FALSE;

  return TRUE;
}

/* Assign file positions for all the reloc sections which are not part
   of the loadable file image.  */

void
_bfd_elf_assign_file_positions_for_relocs (bfd *abfd)
{
  file_ptr off;
  unsigned int i, num_sec;
  Elf_Internal_Shdr **shdrpp;

  off = elf_next_file_pos (abfd);

  num_sec = elf_numsections (abfd);
  for (i = 1, shdrpp = elf_elfsections (abfd) + 1; i < num_sec; i++, shdrpp++)
    {
      Elf_Internal_Shdr *shdrp;

      shdrp = *shdrpp;
      if ((shdrp->sh_type == SHT_REL || shdrp->sh_type == SHT_RELA)
	  && shdrp->sh_offset == -1)
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, TRUE);
    }

  elf_next_file_pos (abfd) = off;
}

bfd_boolean
_bfd_elf_write_object_contents (bfd *abfd)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  Elf_Internal_Shdr **i_shdrp;
  bfd_boolean failed;
  unsigned int count, num_sec;
  struct elf_obj_tdata *t;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;

  i_shdrp = elf_elfsections (abfd);

  failed = FALSE;
  bfd_map_over_sections (abfd, bed->s->write_relocs, &failed);
  if (failed)
    return FALSE;

  _bfd_elf_assign_file_positions_for_relocs (abfd);

  /* After writing the headers, we need to write the sections too...  */
  num_sec = elf_numsections (abfd);
  for (count = 1; count < num_sec; count++)
    {
      if (bed->elf_backend_section_processing)
	(*bed->elf_backend_section_processing) (abfd, i_shdrp[count]);
      if (i_shdrp[count]->contents)
	{
	  bfd_size_type amt = i_shdrp[count]->sh_size;

	  if (bfd_seek (abfd, i_shdrp[count]->sh_offset, SEEK_SET) != 0
	      || bfd_bwrite (i_shdrp[count]->contents, amt, abfd) != amt)
	    return FALSE;
	}
    }

  /* Write out the section header names.  */
  t = elf_tdata (abfd);
  if (elf_shstrtab (abfd) != NULL
      && (bfd_seek (abfd, t->shstrtab_hdr.sh_offset, SEEK_SET) != 0
	  || !_bfd_elf_strtab_emit (abfd, elf_shstrtab (abfd))))
    return FALSE;

  if (bed->elf_backend_final_write_processing)
    (*bed->elf_backend_final_write_processing) (abfd, elf_linker (abfd));

  if (!bed->s->write_shdrs_and_ehdr (abfd))
    return FALSE;

  /* This is last since write_shdrs_and_ehdr can touch i_shdrp[0].  */
  if (t->o->build_id.after_write_object_contents != NULL)
    return (*t->o->build_id.after_write_object_contents) (abfd);

  return TRUE;
}

bfd_boolean
_bfd_elf_write_corefile_contents (bfd *abfd)
{
  /* Hopefully this can be done just like an object file.  */
  return _bfd_elf_write_object_contents (abfd);
}

/* Given a section, search the header to find them.  */

unsigned int
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
{
  const struct elf_backend_data *bed;
  unsigned int sec_index;

  if (elf_section_data (asect) != NULL
      && elf_section_data (asect)->this_idx != 0)
    return elf_section_data (asect)->this_idx;

  if (bfd_is_abs_section (asect))
    sec_index = SHN_ABS;
  else if (bfd_is_com_section (asect))
    sec_index = SHN_COMMON;
  else if (bfd_is_und_section (asect))
    sec_index = SHN_UNDEF;
  else
    sec_index = SHN_BAD;

  bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_section_from_bfd_section)
    {
      int retval = sec_index;

      if ((*bed->elf_backend_section_from_bfd_section) (abfd, asect, &retval))
	return retval;
    }

  if (sec_index == SHN_BAD)
    bfd_set_error (bfd_error_nonrepresentable_section);

  return sec_index;
}

/* Given a BFD symbol, return the index in the ELF symbol table, or -1
   on error.  */

int
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
{
  asymbol *asym_ptr = *asym_ptr_ptr;
  int idx;
  flagword flags = asym_ptr->flags;

  /* When gas creates relocations against local labels, it creates its
     own symbol for the section, but does put the symbol into the
     symbol chain, so udata is 0.  When the linker is generating
     relocatable output, this section symbol may be for one of the
     input sections rather than the output section.  */
  if (asym_ptr->udata.i == 0
      && (flags & BSF_SECTION_SYM)
      && asym_ptr->section)
    {
      asection *sec;
      int indx;

      sec = asym_ptr->section;
      if (sec->owner != abfd && sec->output_section != NULL)
	sec = sec->output_section;
      if (sec->owner == abfd
	  && (indx = sec->index) < elf_num_section_syms (abfd)
	  && elf_section_syms (abfd)[indx] != NULL)
	asym_ptr->udata.i = elf_section_syms (abfd)[indx]->udata.i;
    }

  idx = asym_ptr->udata.i;

  if (idx == 0)
    {
      /* This case can occur when using --strip-symbol on a symbol
	 which is used in a relocation entry.  */
      (*_bfd_error_handler)
	(_("%B: symbol `%s' required but not present"),
	 abfd, bfd_asymbol_name (asym_ptr));
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

#if DEBUG & 4
  {
    fprintf (stderr,
	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx\n",
	     (long) asym_ptr, asym_ptr->name, idx, (long) flags);
    fflush (stderr);
  }
#endif

  return idx;
}

/* Rewrite program header information.  */

static bfd_boolean
rewrite_elf_program_header (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_boolean p_paddr_valid;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
  const struct elf_backend_data *bed;

  bed = get_elf_backend_data (ibfd);
  iehdr = elf_elfheader (ibfd);

  map_first = NULL;
  pointer_to_map = &map_first;

  num_segments = elf_elfheader (ibfd)->e_phnum;
  maxpagesize = get_elf_backend_data (obfd)->maxpagesize;

  /* Returns the end address of the segment + 1.  */
#define SEGMENT_END(segment, start)					\
  (start + (segment->p_memsz > segment->p_filesz			\
	    ? segment->p_memsz : segment->p_filesz))

#define SECTION_SIZE(section, segment)					\
  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\
    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\
   ? section->size : 0)

  /* Returns TRUE if the given section is contained within
     the given segment.  VMA addresses are compared.  */
#define IS_CONTAINED_BY_VMA(section, segment)				\
  (section->vma >= segment->p_vaddr					\
   && (section->vma + SECTION_SIZE (section, segment)			\
       <= (SEGMENT_END (segment, segment->p_vaddr))))

  /* Returns TRUE if the given section is contained within
     the given segment.  LMA addresses are compared.  */
#define IS_CONTAINED_BY_LMA(section, segment, base)			\
  (section->lma >= base							\
   && (section->lma + SECTION_SIZE (section, segment)			\
       <= SEGMENT_END (segment, base)))

  /* Handle PT_NOTE segment.  */
#define IS_NOTE(p, s)							\
  (p->p_type == PT_NOTE							\
   && elf_section_type (s) == SHT_NOTE					\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->size					\
       <= p->p_offset + p->p_filesz))

  /* Special case: corefile "NOTE" section containing regs, prpsinfo
     etc.  */
#define IS_COREFILE_NOTE(p, s)						\
  (IS_NOTE (p, s)							\
   && bfd_get_format (ibfd) == bfd_core					\
   && s->vma == 0							\
   && s->lma == 0)

  /* The complicated case when p_vaddr is 0 is to handle the Solaris
     linker, which generates a PT_INTERP section with p_vaddr and
     p_memsz set to 0.  */
#define IS_SOLARIS_PT_INTERP(p, s)					\
  (p->p_vaddr == 0							\
   && p->p_paddr == 0							\
   && p->p_memsz == 0							\
   && p->p_filesz > 0							\
   && (s->flags & SEC_HAS_CONTENTS) != 0				\
   && s->size > 0							\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->size					\
       <= p->p_offset + p->p_filesz))

  /* Decide if the given section should be included in the given segment.
     A section will be included if:
       1. It is within the address space of the segment -- we use the LMA
	  if that is set for the segment and the VMA otherwise,
       2. It is an allocated section or a NOTE section in a PT_NOTE
	  segment.
       3. There is an output section associated with it,
       4. The section has not already been allocated to a previous segment.
       5. PT_GNU_STACK segments do not include any sections.
       6. PT_TLS segment includes only SHF_TLS sections.
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.
       8. PT_DYNAMIC should not contain empty sections at the beginning
	  (with the possible exception of .dynamic).  */
#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed)		\
  ((((segment->p_paddr							\
      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
      : IS_CONTAINED_BY_VMA (section, segment))				\
     && (section->flags & SEC_ALLOC) != 0)				\
    || IS_NOTE (segment, section))					\
   && segment->p_type != PT_GNU_STACK					\
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
   && (segment->p_type != PT_DYNAMIC					\
       || SECTION_SIZE (section, segment) > 0				\
       || (segment->p_paddr						\
	   ? segment->p_paddr != section->lma				\
	   : segment->p_vaddr != section->vma)				\
       || (strcmp (bfd_get_section_name (ibfd, section), ".dynamic")	\
	   == 0))							\
   && !section->segment_mark)

/* If the output section of a section in the input segment is NULL,
   it is removed from the corresponding output segment.   */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed)		\
   && section->output_section != NULL)

  /* Returns TRUE iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)			\
  (seg1->field >= SEGMENT_END (seg2, seg2->field))

  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both
     their VMA address ranges and their LMA address ranges overlap.
     It is possible to have overlapping VMA ranges without overlapping LMA
     ranges.  RedBoot images for example can have both .data and .bss mapped
     to the same VMA range, but with the .data section mapped to a different
     LMA.  */
#define SEGMENT_OVERLAPS(seg1, seg2)					\
  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\
	|| SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr))			\
   && !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\
	|| SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))

  /* Initialise the segment mark field.  */
  for (section = ibfd->sections; section != NULL; section = section->next)
    section->segment_mark = FALSE;

  /* The Solaris linker creates program headers in which all the
     p_paddr fields are zero.  When we try to objcopy or strip such a
     file, we get confused.  Check for this case, and if we find it
     don't set the p_paddr_valid fields.  */
  p_paddr_valid = FALSE;
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    if (segment->p_paddr != 0)
      {
	p_paddr_valid = TRUE;
	break;
      }

  /* Scan through the segments specified in the program header
     of the input BFD.  For this first scan we look for overlaps
     in the loadable segments.  These can be created by weird
     parameters to objcopy.  Also, fix some solaris weirdness.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    {
      unsigned int j;
      Elf_Internal_Phdr *segment2;

      if (segment->p_type == PT_INTERP)
	for (section = ibfd->sections; section; section = section->next)
	  if (IS_SOLARIS_PT_INTERP (segment, section))
	    {
	      /* Mininal change so that the normal section to segment
		 assignment code will work.  */
	      segment->p_vaddr = section->vma;
	      break;
	    }

      if (segment->p_type != PT_LOAD)
	{
	  /* Remove PT_GNU_RELRO segment.  */
	  if (segment->p_type == PT_GNU_RELRO)
	    segment->p_type = PT_NULL;
	  continue;
	}

      /* Determine if this segment overlaps any previous segments.  */
      for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2++)
	{
	  bfd_signed_vma extra_length;

	  if (segment2->p_type != PT_LOAD
	      || !SEGMENT_OVERLAPS (segment, segment2))
	    continue;

	  /* Merge the two segments together.  */
	  if (segment2->p_vaddr < segment->p_vaddr)
	    {
	      /* Extend SEGMENT2 to include SEGMENT and then delete
		 SEGMENT.  */
	      extra_length = (SEGMENT_END (segment, segment->p_vaddr)
			      - SEGMENT_END (segment2, segment2->p_vaddr));

	      if (extra_length > 0)
		{
		  segment2->p_memsz += extra_length;
		  segment2->p_filesz += extra_length;
		}

	      segment->p_type = PT_NULL;

	      /* Since we have deleted P we must restart the outer loop.  */
	      i = 0;
	      segment = elf_tdata (ibfd)->phdr;
	      break;
	    }
	  else
	    {
	      /* Extend SEGMENT to include SEGMENT2 and then delete
		 SEGMENT2.  */
	      extra_length = (SEGMENT_END (segment2, segment2->p_vaddr)
			      - SEGMENT_END (segment, segment->p_vaddr));

	      if (extra_length > 0)
		{
		  segment->p_memsz += extra_length;
		  segment->p_filesz += extra_length;
		}

	      segment2->p_type = PT_NULL;
	    }
	}
    }

  /* The second scan attempts to assign sections to segments.  */
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    {
      unsigned int section_count;
      asection **sections;
      asection *output_section;
      unsigned int isec;
      bfd_vma matching_lma;
      bfd_vma suggested_lma;
      unsigned int j;
      bfd_size_type amt;
      asection *first_section;
      bfd_boolean first_matching_lma;
      bfd_boolean first_suggested_lma;

      if (segment->p_type == PT_NULL)
	continue;

      first_section = NULL;
      /* Compute how many sections might be placed into this segment.  */
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
	{
	  /* Find the first section in the input segment, which may be
	     removed from the corresponding output segment.   */
	  if (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed))
	    {
	      if (first_section == NULL)
		first_section = section;
	      if (section->output_section != NULL)
		++section_count;
	    }
	}

      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
      amt = sizeof (struct elf_segment_map);
      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
      if (map == NULL)
	return FALSE;

      /* Initialise the fields of the segment map.  Default to
	 using the physical address of the segment in the input BFD.  */
      map->next = NULL;
      map->p_type = segment->p_type;
      map->p_flags = segment->p_flags;
      map->p_flags_valid = 1;

      /* If the first section in the input segment is removed, there is
	 no need to preserve segment physical address in the corresponding
	 output segment.  */
      if (!first_section || first_section->output_section != NULL)
	{
	  map->p_paddr = segment->p_paddr;
	  map->p_paddr_valid = p_paddr_valid;
	}

      /* Determine if this segment contains the ELF file header
	 and if it contains the program headers themselves.  */
      map->includes_filehdr = (segment->p_offset == 0
			       && segment->p_filesz >= iehdr->e_ehsize);
      map->includes_phdrs = 0;

      if (!phdr_included || segment->p_type != PT_LOAD)
	{
	  map->includes_phdrs =
	    (segment->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (segment->p_offset + segment->p_filesz
		 >= ((bfd_vma) iehdr->e_phoff
		     + iehdr->e_phnum * iehdr->e_phentsize)));

	  if (segment->p_type == PT_LOAD && map->includes_phdrs)
	    phdr_included = TRUE;
	}

      if (section_count == 0)
	{
	  /* Special segments, such as the PT_PHDR segment, may contain
	     no sections, but ordinary, loadable segments should contain
	     something.  They are allowed by the ELF spec however, so only
	     a warning is produced.  */
	  if (segment->p_type == PT_LOAD)
	    (*_bfd_error_handler) (_("%B: warning: Empty loadable segment"
				     " detected, is this intentional ?\n"),
				   ibfd);

	  map->count = 0;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  continue;
	}

      /* Now scan the sections in the input BFD again and attempt
	 to add their corresponding output sections to the segment map.
	 The problem here is how to handle an output section which has
	 been moved (ie had its LMA changed).  There are four possibilities:

	 1. None of the sections have been moved.
	    In this case we can continue to use the segment LMA from the
	    input BFD.

	 2. All of the sections have been moved by the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section.

	 3. Some of the sections have been moved, others have not.
	    In this case those sections which have not been moved can be
	    placed in the current segment which will have to have its size,
	    and possibly its LMA changed, and a new segment or segments will
	    have to be created to contain the other sections.

	 4. The sections have been moved, but not by the same amount.
	    In this case we can change the segment's LMA to match the LMA
	    of the first section and we will have to create a new segment
	    or segments to contain the other sections.

	 In order to save time, we allocate an array to hold the section
	 pointers that we are interested in.  As these sections get assigned
	 to a segment, they are removed from this array.  */

      sections = (asection **) bfd_malloc2 (section_count, sizeof (asection *));
      if (sections == NULL)
	return FALSE;

      /* Step One: Scan for segment vs section LMA conflicts.
	 Also add the sections to the section array allocated above.
	 Also add the sections to the current segment.  In the common
	 case, where the sections have not been moved, this means that
	 we have completely filled the segment, and there is nothing
	 more to do.  */
      isec = 0;
      matching_lma = 0;
      suggested_lma = 0;
      first_matching_lma = TRUE;
      first_suggested_lma = TRUE;

      for (section = ibfd->sections;
	   section != NULL;
	   section = section->next)
	if (section == first_section)
	  break;

      for (j = 0; section != NULL; section = section->next)
	{
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
	    {
	      output_section = section->output_section;

	      sections[j++] = section;

	      /* The Solaris native linker always sets p_paddr to 0.
		 We try to catch that case here, and set it to the
		 correct value.  Note - some backends require that
		 p_paddr be left as zero.  */
	      if (!p_paddr_valid
		  && segment->p_vaddr != 0
		  && !bed->want_p_paddr_set_to_zero
		  && isec == 0
		  && output_section->lma != 0
		  && output_section->vma == (segment->p_vaddr
					     + (map->includes_filehdr
						? iehdr->e_ehsize
						: 0)
					     + (map->includes_phdrs
						? (iehdr->e_phnum
						   * iehdr->e_phentsize)
						: 0)))
		map->p_paddr = segment->p_vaddr;

	      /* Match up the physical address of the segment with the
		 LMA address of the output section.  */
	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section)
		  || (bed->want_p_paddr_set_to_zero
		      && IS_CONTAINED_BY_VMA (output_section, segment)))
		{
		  if (first_matching_lma || output_section->lma < matching_lma)
		    {
		      matching_lma = output_section->lma;
		      first_matching_lma = FALSE;
		    }

		  /* We assume that if the section fits within the segment
		     then it does not overlap any other section within that
		     segment.  */
		  map->sections[isec++] = output_section;
		}
	      else if (first_suggested_lma)
		{
		  suggested_lma = output_section->lma;
		  first_suggested_lma = FALSE;
		}

	      if (j == section_count)
		break;
	    }
	}

      BFD_ASSERT (j == section_count);

      /* Step Two: Adjust the physical address of the current segment,
	 if necessary.  */
      if (isec == section_count)
	{
	  /* All of the sections fitted within the segment as currently
	     specified.  This is the default case.  Add the segment to
	     the list of built segments and carry on to process the next
	     program header in the input BFD.  */
	  map->count = section_count;
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  if (p_paddr_valid
	      && !bed->want_p_paddr_set_to_zero
	      && matching_lma != map->p_paddr
	      && !map->includes_filehdr
	      && !map->includes_phdrs)
	    /* There is some padding before the first section in the
	       segment.  So, we must account for that in the output
	       segment's vma.  */
	    map->p_vaddr_offset = matching_lma - map->p_paddr;

	  free (sections);
	  continue;
	}
      else
	{
	  if (!first_matching_lma)
	    {
	      /* At least one section fits inside the current segment.
		 Keep it, but modify its physical address to match the
		 LMA of the first section that fitted.  */
	      map->p_paddr = matching_lma;
	    }
	  else
	    {
	      /* None of the sections fitted inside the current segment.
		 Change the current segment's physical address to match
		 the LMA of the first section.  */
	      map->p_paddr = suggested_lma;
	    }

	  /* Offset the segment physical address from the lma
	     to allow for space taken up by elf headers.  */
	  if (map->includes_filehdr)
	    {
	      if (map->p_paddr >= iehdr->e_ehsize)
		map->p_paddr -= iehdr->e_ehsize;
	      else
		{
		  map->includes_filehdr = FALSE;
		  map->includes_phdrs = FALSE;
		}
	    }

	  if (map->includes_phdrs)
	    {
	      if (map->p_paddr >= iehdr->e_phnum * iehdr->e_phentsize)
		{
		  map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;

		  /* iehdr->e_phnum is just an estimate of the number
		     of program headers that we will need.  Make a note
		     here of the number we used and the segment we chose
		     to hold these headers, so that we can adjust the
		     offset when we know the correct value.  */
		  phdr_adjust_num = iehdr->e_phnum;
		  phdr_adjust_seg = map;
		}
	      else
		map->includes_phdrs = FALSE;
	    }
	}

      /* Step Three: Loop over the sections again, this time assigning
	 those that fit to the current segment and removing them from the
	 sections array; but making sure not to leave large gaps.  Once all
	 possible sections have been assigned to the current segment it is
	 added to the list of built segments and if sections still remain
	 to be assigned, a new segment is constructed before repeating
	 the loop.  */
      isec = 0;
      do
	{
	  map->count = 0;
	  suggested_lma = 0;
	  first_suggested_lma = TRUE;

	  /* Fill the current segment with sections that fit.  */
	  for (j = 0; j < section_count; j++)
	    {
	      section = sections[j];

	      if (section == NULL)
		continue;

	      output_section = section->output_section;

	      BFD_ASSERT (output_section != NULL);

	      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr)
		  || IS_COREFILE_NOTE (segment, section))
		{
		  if (map->count == 0)
		    {
		      /* If the first section in a segment does not start at
			 the beginning of the segment, then something is
			 wrong.  */
		      if (output_section->lma
			  != (map->p_paddr
			      + (map->includes_filehdr ? iehdr->e_ehsize : 0)
			      + (map->includes_phdrs
				 ? iehdr->e_phnum * iehdr->e_phentsize
				 : 0)))
			abort ();
		    }
		  else
		    {
		      asection *prev_sec;

		      prev_sec = map->sections[map->count - 1];

		      /* If the gap between the end of the previous section
			 and the start of this section is more than
			 maxpagesize then we need to start a new segment.  */
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->size,
				      maxpagesize)
			   < BFD_ALIGN (output_section->lma, maxpagesize))
			  || (prev_sec->lma + prev_sec->size
			      > output_section->lma))
			{
			  if (first_suggested_lma)
			    {
			      suggested_lma = output_section->lma;
			      first_suggested_lma = FALSE;
			    }

			  continue;
			}
		    }

		  map->sections[map->count++] = output_section;
		  ++isec;
		  sections[j] = NULL;
		  section->segment_mark = TRUE;
		}
	      else if (first_suggested_lma)
		{
		  suggested_lma = output_section->lma;
		  first_suggested_lma = FALSE;
		}
	    }

	  BFD_ASSERT (map->count > 0);

	  /* Add the current segment to the list of built segments.  */
	  *pointer_to_map = map;
	  pointer_to_map = &map->next;

	  if (isec < section_count)
	    {
	      /* We still have not allocated all of the sections to
		 segments.  Create a new segment here, initialise it
		 and carry on looping.  */
	      amt = sizeof (struct elf_segment_map);
	      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
	      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
	      if (map == NULL)
		{
		  free (sections);
		  return FALSE;
		}

	      /* Initialise the fields of the segment map.  Set the physical
		 physical address to the LMA of the first section that has
		 not yet been assigned.  */
	      map->next = NULL;
	      map->p_type = segment->p_type;
	      map->p_flags = segment->p_flags;
	      map->p_flags_valid = 1;
	      map->p_paddr = suggested_lma;
	      map->p_paddr_valid = p_paddr_valid;
	      map->includes_filehdr = 0;
	      map->includes_phdrs = 0;
	    }
	}
      while (isec < section_count);

      free (sections);
    }

  elf_seg_map (obfd) = map_first;

  /* If we had to estimate the number of program headers that were
     going to be needed, then check our estimate now and adjust
     the offset if necessary.  */
  if (phdr_adjust_seg != NULL)
    {
      unsigned int count;

      for (count = 0, map = map_first; map != NULL; map = map->next)
	count++;

      if (count > phdr_adjust_num)
	phdr_adjust_seg->p_paddr
	  -= (count - phdr_adjust_num) * iehdr->e_phentsize;
    }

#undef SEGMENT_END
#undef SECTION_SIZE
#undef IS_CONTAINED_BY_VMA
#undef IS_CONTAINED_BY_LMA
#undef IS_NOTE
#undef IS_COREFILE_NOTE
#undef IS_SOLARIS_PT_INTERP
#undef IS_SECTION_IN_INPUT_SEGMENT
#undef INCLUDE_SECTION_IN_SEGMENT
#undef SEGMENT_AFTER_SEGMENT
#undef SEGMENT_OVERLAPS
  return TRUE;
}

/* Copy ELF program header information.  */

static bfd_boolean
copy_elf_program_header (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_boolean p_paddr_valid;

  iehdr = elf_elfheader (ibfd);

  map_first = NULL;
  pointer_to_map = &map_first;

  /* If all the segment p_paddr fields are zero, don't set
     map->p_paddr_valid.  */
  p_paddr_valid = FALSE;
  num_segments = elf_elfheader (ibfd)->e_phnum;
  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    if (segment->p_paddr != 0)
      {
	p_paddr_valid = TRUE;
	break;
      }

  for (i = 0, segment = elf_tdata (ibfd)->phdr;
       i < num_segments;
       i++, segment++)
    {
      asection *section;
      unsigned int section_count;
      bfd_size_type amt;
      Elf_Internal_Shdr *this_hdr;
      asection *first_section = NULL;
      asection *lowest_section;

      /* Compute how many sections are in this segment.  */
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
	{
	  this_hdr = &(elf_section_data(section)->this_hdr);
	  if (ELF_SECTION_IN_SEGMENT (this_hdr, segment))
	    {
	      if (first_section == NULL)
		first_section = section;
	      section_count++;
	    }
	}

      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
      amt = sizeof (struct elf_segment_map);
      if (section_count != 0)
	amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
      if (map == NULL)
	return FALSE;

      /* Initialize the fields of the output segment map with the
	 input segment.  */
      map->next = NULL;
      map->p_type = segment->p_type;
      map->p_flags = segment->p_flags;
      map->p_flags_valid = 1;
      map->p_paddr = segment->p_paddr;
      map->p_paddr_valid = p_paddr_valid;
      map->p_align = segment->p_align;
      map->p_align_valid = 1;
      map->p_vaddr_offset = 0;

      if (map->p_type == PT_GNU_RELRO
	  || map->p_type == PT_GNU_STACK)
	{
	  /* The PT_GNU_RELRO segment may contain the first a few
	     bytes in the .got.plt section even if the whole .got.plt
	     section isn't in the PT_GNU_RELRO segment.  We won't
	     change the size of the PT_GNU_RELRO segment.
	     Similarly, PT_GNU_STACK size is significant on uclinux
	     systems.    */
	  map->p_size = segment->p_memsz;
	  map->p_size_valid = 1;
	}

      /* Determine if this segment contains the ELF file header
	 and if it contains the program headers themselves.  */
      map->includes_filehdr = (segment->p_offset == 0
			       && segment->p_filesz >= iehdr->e_ehsize);

      map->includes_phdrs = 0;
      if (! phdr_included || segment->p_type != PT_LOAD)
	{
	  map->includes_phdrs =
	    (segment->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (segment->p_offset + segment->p_filesz
		 >= ((bfd_vma) iehdr->e_phoff
		     + iehdr->e_phnum * iehdr->e_phentsize)));

	  if (segment->p_type == PT_LOAD && map->includes_phdrs)
	    phdr_included = TRUE;
	}

      lowest_section = first_section;
      if (section_count != 0)
	{
	  unsigned int isec = 0;

	  for (section = first_section;
	       section != NULL;
	       section = section->next)
	    {
	      this_hdr = &(elf_section_data(section)->this_hdr);
	      if (ELF_SECTION_IN_SEGMENT (this_hdr, segment))
		{
		  map->sections[isec++] = section->output_section;
		  if ((section->flags & SEC_ALLOC) != 0)
		    {
		      bfd_vma seg_off;

		      if (section->lma < lowest_section->lma)
			lowest_section = section;

		      /* Section lmas are set up from PT_LOAD header
			 p_paddr in _bfd_elf_make_section_from_shdr.
			 If this header has a p_paddr that disagrees
			 with the section lma, flag the p_paddr as
			 invalid.  */
		      if ((section->flags & SEC_LOAD) != 0)
			seg_off = this_hdr->sh_offset - segment->p_offset;
		      else
			seg_off = this_hdr->sh_addr - segment->p_vaddr;
		      if (section->lma - segment->p_paddr != seg_off)
			map->p_paddr_valid = FALSE;
		    }
		  if (isec == section_count)
		    break;
		}
	    }
	}

      if (map->includes_filehdr && lowest_section != NULL)
	/* We need to keep the space used by the headers fixed.  */
	map->header_size = lowest_section->vma - segment->p_vaddr;

      if (!map->includes_phdrs
	  && !map->includes_filehdr
	  && map->p_paddr_valid)
	/* There is some other padding before the first section.  */
	map->p_vaddr_offset = ((lowest_section ? lowest_section->lma : 0)
			       - segment->p_paddr);

      map->count = section_count;
      *pointer_to_map = map;
      pointer_to_map = &map->next;
    }

  elf_seg_map (obfd) = map_first;
  return TRUE;
}

/* Copy private BFD data.  This copies or rewrites ELF program header
   information.  */

static bfd_boolean
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (elf_tdata (ibfd)->phdr == NULL)
    return TRUE;

  if (ibfd->xvec == obfd->xvec)
    {
      /* Check to see if any sections in the input BFD
	 covered by ELF program header have changed.  */
      Elf_Internal_Phdr *segment;
      asection *section, *osec;
      unsigned int i, num_segments;
      Elf_Internal_Shdr *this_hdr;
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (ibfd);

      /* Regenerate the segment map if p_paddr is set to 0.  */
      if (bed->want_p_paddr_set_to_zero)
	goto rewrite;

      /* Initialize the segment mark field.  */
      for (section = obfd->sections; section != NULL;
	   section = section->next)
	section->segment_mark = FALSE;

      num_segments = elf_elfheader (ibfd)->e_phnum;
      for (i = 0, segment = elf_tdata (ibfd)->phdr;
	   i < num_segments;
	   i++, segment++)
	{
	  /* PR binutils/3535.  The Solaris linker always sets the p_paddr
	     and p_memsz fields of special segments (DYNAMIC, INTERP) to 0
	     which severly confuses things, so always regenerate the segment
	     map in this case.  */
	  if (segment->p_paddr == 0
	      && segment->p_memsz == 0
	      && (segment->p_type == PT_INTERP || segment->p_type == PT_DYNAMIC))
	    goto rewrite;

	  for (section = ibfd->sections;
	       section != NULL; section = section->next)
	    {
	      /* We mark the output section so that we know it comes
		 from the input BFD.  */
	      osec = section->output_section;
	      if (osec)
		osec->segment_mark = TRUE;

	      /* Check if this section is covered by the segment.  */
	      this_hdr = &(elf_section_data(section)->this_hdr);
	      if (ELF_SECTION_IN_SEGMENT (this_hdr, segment))
		{
		  /* FIXME: Check if its output section is changed or
		     removed.  What else do we need to check?  */
		  if (osec == NULL
		      || section->flags != osec->flags
		      || section->lma != osec->lma
		      || section->vma != osec->vma
		      || section->size != osec->size
		      || section->rawsize != osec->rawsize
		      || section->alignment_power != osec->alignment_power)
		    goto rewrite;
		}
	    }
	}

      /* Check to see if any output section do not come from the
	 input BFD.  */
      for (section = obfd->sections; section != NULL;
	   section = section->next)
	{
	  if (section->segment_mark == FALSE)
	    goto rewrite;
	  else
	    section->segment_mark = FALSE;
	}

      return copy_elf_program_header (ibfd, obfd);
    }

rewrite:
  if (ibfd->xvec == obfd->xvec)
    {
      /* When rewriting program header, set the output maxpagesize to
	 the maximum alignment of input PT_LOAD segments.  */
      Elf_Internal_Phdr *segment;
      unsigned int i;
      unsigned int num_segments = elf_elfheader (ibfd)->e_phnum;
      bfd_vma maxpagesize = 0;

      for (i = 0, segment = elf_tdata (ibfd)->phdr;
	   i < num_segments;
	   i++, segment++)
	if (segment->p_type == PT_LOAD
	    && maxpagesize < segment->p_align)
	  maxpagesize = segment->p_align;

      if (maxpagesize != get_elf_backend_data (obfd)->maxpagesize)
	bfd_emul_set_maxpagesize (bfd_get_target (obfd), maxpagesize);
    }

  return rewrite_elf_program_header (ibfd, obfd);
}

/* Initialize private output section information from input section.  */

bfd_boolean
_bfd_elf_init_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec,
				    struct bfd_link_info *link_info)

{
  Elf_Internal_Shdr *ihdr, *ohdr;
  bfd_boolean final_link = link_info != NULL && !link_info->relocatable;

  if (ibfd->xvec->flavour != bfd_target_elf_flavour
      || obfd->xvec->flavour != bfd_target_elf_flavour)
    return TRUE;

  BFD_ASSERT (elf_section_data (osec) != NULL);

  /* For objcopy and relocatable link, don't copy the output ELF
     section type from input if the output BFD section flags have been
     set to something different.  For a final link allow some flags
     that the linker clears to differ.  */
  if (elf_section_type (osec) == SHT_NULL
      && (osec->flags == isec->flags
	  || (final_link
	      && ((osec->flags ^ isec->flags)
		  & ~(SEC_LINK_ONCE | SEC_LINK_DUPLICATES | SEC_RELOC)) == 0)))
    elf_section_type (osec) = elf_section_type (isec);

  /* FIXME: Is this correct for all OS/PROC specific flags?  */
  elf_section_flags (osec) |= (elf_section_flags (isec)
			       & (SHF_MASKOS | SHF_MASKPROC));

  /* Set things up for objcopy and relocatable link.  The output
     SHT_GROUP section will have its elf_next_in_group pointing back
     to the input group members.  Ignore linker created group section.
     See elfNN_ia64_object_p in elfxx-ia64.c.  */
  if (!final_link)
    {
      if (elf_sec_group (isec) == NULL
	  || (elf_sec_group (isec)->flags & SEC_LINKER_CREATED) == 0)
	{
	  if (elf_section_flags (isec) & SHF_GROUP)
	    elf_section_flags (osec) |= SHF_GROUP;
	  elf_next_in_group (osec) = elf_next_in_group (isec);
	  elf_section_data (osec)->group = elf_section_data (isec)->group;
	}
    }

  ihdr = &elf_section_data (isec)->this_hdr;

  /* We need to handle elf_linked_to_section for SHF_LINK_ORDER. We
     don't use the output section of the linked-to section since it
     may be NULL at this point.  */
  if ((ihdr->sh_flags & SHF_LINK_ORDER) != 0)
    {
      ohdr = &elf_section_data (osec)->this_hdr;
      ohdr->sh_flags |= SHF_LINK_ORDER;
      elf_linked_to_section (osec) = elf_linked_to_section (isec);
    }

  osec->use_rela_p = isec->use_rela_p;

  return TRUE;
}

/* Copy private section information.  This copies over the entsize
   field, and sometimes the info field.  */

bfd_boolean
_bfd_elf_copy_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec)
{
  Elf_Internal_Shdr *ihdr, *ohdr;

  if (ibfd->xvec->flavour != bfd_target_elf_flavour
      || obfd->xvec->flavour != bfd_target_elf_flavour)
    return TRUE;

  ihdr = &elf_section_data (isec)->this_hdr;
  ohdr = &elf_section_data (osec)->this_hdr;

  ohdr->sh_entsize = ihdr->sh_entsize;

  if (ihdr->sh_type == SHT_SYMTAB
      || ihdr->sh_type == SHT_DYNSYM
      || ihdr->sh_type == SHT_GNU_verneed
      || ihdr->sh_type == SHT_GNU_verdef)
    ohdr->sh_info = ihdr->sh_info;

  return _bfd_elf_init_private_section_data (ibfd, isec, obfd, osec,
					     NULL);
}

/* Look at all the SHT_GROUP sections in IBFD, making any adjustments
   necessary if we are removing either the SHT_GROUP section or any of
   the group member sections.  DISCARDED is the value that a section's
   output_section has if the section will be discarded, NULL when this
   function is called from objcopy, bfd_abs_section_ptr when called
   from the linker.  */

bfd_boolean
_bfd_elf_fixup_group_sections (bfd *ibfd, asection *discarded)
{
  asection *isec;

  for (isec = ibfd->sections; isec != NULL; isec = isec->next)
    if (elf_section_type (isec) == SHT_GROUP)
      {
	asection *first = elf_next_in_group (isec);
	asection *s = first;
	bfd_size_type removed = 0;

	while (s != NULL)
	  {
	    /* If this member section is being output but the
	       SHT_GROUP section is not, then clear the group info
	       set up by _bfd_elf_copy_private_section_data.  */
	    if (s->output_section != discarded
		&& isec->output_section == discarded)
	      {
		elf_section_flags (s->output_section) &= ~SHF_GROUP;
		elf_group_name (s->output_section) = NULL;
	      }
	    /* Conversely, if the member section is not being output
	       but the SHT_GROUP section is, then adjust its size.  */
	    else if (s->output_section == discarded
		     && isec->output_section != discarded)
	      removed += 4;
	    s = elf_next_in_group (s);
	    if (s == first)
	      break;
	  }
	if (removed != 0)
	  {
	    if (discarded != NULL)
	      {
		/* If we've been called for ld -r, then we need to
		   adjust the input section size.  This function may
		   be called multiple times, so save the original
		   size.  */
		if (isec->rawsize == 0)
		  isec->rawsize = isec->size;
		isec->size = isec->rawsize - removed;
	      }
	    else
	      {
		/* Adjust the output section size when called from
		   objcopy. */
		isec->output_section->size -= removed;
	      }
	  }
      }

  return TRUE;
}

/* Copy private header information.  */

bfd_boolean
_bfd_elf_copy_private_header_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  */
  if (elf_seg_map (obfd) == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
      if (! copy_private_bfd_data (ibfd, obfd))
	return FALSE;
    }

  return _bfd_elf_fixup_group_sections (ibfd, NULL);
}

/* Copy private symbol information.  If this symbol is in a section
   which we did not map into a BFD section, try to map the section
   index correctly.  We use special macro definitions for the mapped
   section indices; these definitions are interpreted by the
   swap_out_syms function.  */

#define MAP_ONESYMTAB (SHN_HIOS + 1)
#define MAP_DYNSYMTAB (SHN_HIOS + 2)
#define MAP_STRTAB    (SHN_HIOS + 3)
#define MAP_SHSTRTAB  (SHN_HIOS + 4)
#define MAP_SYM_SHNDX (SHN_HIOS + 5)

bfd_boolean
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
				   asymbol *isymarg,
				   bfd *obfd,
				   asymbol *osymarg)
{
  elf_symbol_type *isym, *osym;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  isym = elf_symbol_from (ibfd, isymarg);
  osym = elf_symbol_from (obfd, osymarg);

  if (isym != NULL
      && isym->internal_elf_sym.st_shndx != 0
      && osym != NULL
      && bfd_is_abs_section (isym->symbol.section))
    {
      unsigned int shndx;

      shndx = isym->internal_elf_sym.st_shndx;
      if (shndx == elf_onesymtab (ibfd))
	shndx = MAP_ONESYMTAB;
      else if (shndx == elf_dynsymtab (ibfd))
	shndx = MAP_DYNSYMTAB;
      else if (shndx == elf_strtab_sec (ibfd))
	shndx = MAP_STRTAB;
      else if (shndx == elf_shstrtab_sec (ibfd))
	shndx = MAP_SHSTRTAB;
      else if (shndx == elf_symtab_shndx (ibfd))
	shndx = MAP_SYM_SHNDX;
      osym->internal_elf_sym.st_shndx = shndx;
    }

  return TRUE;
}

/* Swap out the symbols.  */

static bfd_boolean
swap_out_syms (bfd *abfd,
	       struct bfd_strtab_hash **sttp,
	       int relocatable_p)
{
  const struct elf_backend_data *bed;
  int symcount;
  asymbol **syms;
  struct bfd_strtab_hash *stt;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  bfd_byte *outbound_syms;
  bfd_byte *outbound_shndx;
  int idx;
  unsigned int num_locals;
  bfd_size_type amt;
  bfd_boolean name_local_sections;

  if (!elf_map_symbols (abfd, &num_locals))
    return FALSE;

  /* Dump out the symtabs.  */
  stt = _bfd_elf_stringtab_init ();
  if (stt == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);
  symcount = bfd_get_symcount (abfd);
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  symtab_hdr->sh_type = SHT_SYMTAB;
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
  symtab_hdr->sh_info = num_locals + 1;
  symtab_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;

  symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
  symstrtab_hdr->sh_type = SHT_STRTAB;

  outbound_syms = (bfd_byte *) bfd_alloc2 (abfd, 1 + symcount,
                                           bed->s->sizeof_sym);
  if (outbound_syms == NULL)
    {
      _bfd_stringtab_free (stt);
      return FALSE;
    }
  symtab_hdr->contents = outbound_syms;

  outbound_shndx = NULL;
  symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (symtab_shndx_hdr->sh_name != 0)
    {
      amt = (bfd_size_type) (1 + symcount) * sizeof (Elf_External_Sym_Shndx);
      outbound_shndx =  (bfd_byte *)
          bfd_zalloc2 (abfd, 1 + symcount, sizeof (Elf_External_Sym_Shndx));
      if (outbound_shndx == NULL)
	{
	  _bfd_stringtab_free (stt);
	  return FALSE;
	}

      symtab_shndx_hdr->contents = outbound_shndx;
      symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
      symtab_shndx_hdr->sh_size = amt;
      symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
      symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
    }

  /* Now generate the data (for "contents").  */
  {
    /* Fill in zeroth symbol and swap it out.  */
    Elf_Internal_Sym sym;
    sym.st_name = 0;
    sym.st_value = 0;
    sym.st_size = 0;
    sym.st_info = 0;
    sym.st_other = 0;
    sym.st_shndx = SHN_UNDEF;
    sym.st_target_internal = 0;
    bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
    outbound_syms += bed->s->sizeof_sym;
    if (outbound_shndx != NULL)
      outbound_shndx += sizeof (Elf_External_Sym_Shndx);
  }

  name_local_sections
    = (bed->elf_backend_name_local_section_symbols
       && bed->elf_backend_name_local_section_symbols (abfd));

  syms = bfd_get_outsymbols (abfd);
  for (idx = 0; idx < symcount; idx++)
    {
      Elf_Internal_Sym sym;
      bfd_vma value = syms[idx]->value;
      elf_symbol_type *type_ptr;
      flagword flags = syms[idx]->flags;
      int type;

      if (!name_local_sections
	  && (flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
	{
	  /* Local section symbols have no name.  */
	  sym.st_name = 0;
	}
      else
	{
	  sym.st_name = (unsigned long) _bfd_stringtab_add (stt,
							    syms[idx]->name,
							    TRUE, FALSE);
	  if (sym.st_name == (unsigned long) -1)
	    {
	      _bfd_stringtab_free (stt);
	      return FALSE;
	    }
	}

      type_ptr = elf_symbol_from (abfd, syms[idx]);

      if ((flags & BSF_SECTION_SYM) == 0
	  && bfd_is_com_section (syms[idx]->section))
	{
	  /* ELF common symbols put the alignment into the `value' field,
	     and the size into the `size' field.  This is backwards from
	     how BFD handles it, so reverse it here.  */
	  sym.st_size = value;
	  if (type_ptr == NULL
	      || type_ptr->internal_elf_sym.st_value == 0)
	    sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
	  else
	    sym.st_value = type_ptr->internal_elf_sym.st_value;
	  sym.st_shndx = _bfd_elf_section_from_bfd_section
	    (abfd, syms[idx]->section);
	}
      else
	{
	  asection *sec = syms[idx]->section;
	  unsigned int shndx;

	  if (sec->output_section)
	    {
	      value += sec->output_offset;
	      sec = sec->output_section;
	    }

	  /* Don't add in the section vma for relocatable output.  */
	  if (! relocatable_p)
	    value += sec->vma;
	  sym.st_value = value;
	  sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

	  if (bfd_is_abs_section (sec)
	      && type_ptr != NULL
	      && type_ptr->internal_elf_sym.st_shndx != 0)
	    {
	      /* This symbol is in a real ELF section which we did
		 not create as a BFD section.  Undo the mapping done
		 by copy_private_symbol_data.  */
	      shndx = type_ptr->internal_elf_sym.st_shndx;
	      switch (shndx)
		{
		case MAP_ONESYMTAB:
		  shndx = elf_onesymtab (abfd);
		  break;
		case MAP_DYNSYMTAB:
		  shndx = elf_dynsymtab (abfd);
		  break;
		case MAP_STRTAB:
		  shndx = elf_strtab_sec (abfd);
		  break;
		case MAP_SHSTRTAB:
		  shndx = elf_shstrtab_sec (abfd);
		  break;
		case MAP_SYM_SHNDX:
		  shndx = elf_symtab_shndx (abfd);
		  break;
		default:
		  shndx = SHN_ABS;
		  break;
		}
	    }
	  else
	    {
	      shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

	      if (shndx == SHN_BAD)
		{
		  asection *sec2;

		  /* Writing this would be a hell of a lot easier if
		     we had some decent documentation on bfd, and
		     knew what to expect of the library, and what to
		     demand of applications.  For example, it
		     appears that `objcopy' might not set the
		     section of a symbol to be a section that is
		     actually in the output file.  */
		  sec2 = bfd_get_section_by_name (abfd, sec->name);
		  if (sec2 == NULL)
		    {
		      _bfd_error_handler (_("\
Unable to find equivalent output section for symbol '%s' from section '%s'"),
					  syms[idx]->name ? syms[idx]->name : "<Local sym>",
					  sec->name);
		      bfd_set_error (bfd_error_invalid_operation);
		      _bfd_stringtab_free (stt);
		      return FALSE;
		    }

		  shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
		  BFD_ASSERT (shndx != SHN_BAD);
		}
	    }

	  sym.st_shndx = shndx;
	}

      if ((flags & BSF_THREAD_LOCAL) != 0)
	type = STT_TLS;
      else if ((flags & BSF_GNU_INDIRECT_FUNCTION) != 0)
	type = STT_GNU_IFUNC;
      else if ((flags & BSF_FUNCTION) != 0)
	type = STT_FUNC;
      else if ((flags & BSF_OBJECT) != 0)
	type = STT_OBJECT;
      else if ((flags & BSF_RELC) != 0)
	type = STT_RELC;
      else if ((flags & BSF_SRELC) != 0)
	type = STT_SRELC;
      else
	type = STT_NOTYPE;

      if (syms[idx]->section->flags & SEC_THREAD_LOCAL)
	type = STT_TLS;

      /* Processor-specific types.  */
      if (type_ptr != NULL
	  && bed->elf_backend_get_symbol_type)
	type = ((*bed->elf_backend_get_symbol_type)
		(&type_ptr->internal_elf_sym, type));

      if (flags & BSF_SECTION_SYM)
	{
	  if (flags & BSF_GLOBAL)
	    sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	  else
	    sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	}
      else if (bfd_is_com_section (syms[idx]->section))
	{
#ifdef USE_STT_COMMON
	  if (type == STT_OBJECT)
	    sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_COMMON);
	  else
#endif
	    sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
	}
      else if (bfd_is_und_section (syms[idx]->section))
	sym.st_info = ELF_ST_INFO (((flags & BSF_WEAK)
				    ? STB_WEAK
				    : STB_GLOBAL),
				   type);
      else if (flags & BSF_FILE)
	sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
      else
	{
	  int bind = STB_LOCAL;

	  if (flags & BSF_LOCAL)
	    bind = STB_LOCAL;
	  else if (flags & BSF_GNU_UNIQUE)
	    bind = STB_GNU_UNIQUE;
	  else if (flags & BSF_WEAK)
	    bind = STB_WEAK;
	  else if (flags & BSF_GLOBAL)
	    bind = STB_GLOBAL;

	  sym.st_info = ELF_ST_INFO (bind, type);
	}

      if (type_ptr != NULL)
	{
	  sym.st_other = type_ptr->internal_elf_sym.st_other;
	  sym.st_target_internal
	    = type_ptr->internal_elf_sym.st_target_internal;
	}
      else
	{
	  sym.st_other = 0;
	  sym.st_target_internal = 0;
	}

      bed->s->swap_symbol_out (abfd, &sym, outbound_syms, outbound_shndx);
      outbound_syms += bed->s->sizeof_sym;
      if (outbound_shndx != NULL)
	outbound_shndx += sizeof (Elf_External_Sym_Shndx);
    }

  *sttp = stt;
  symstrtab_hdr->sh_size = _bfd_stringtab_size (stt);
  symstrtab_hdr->sh_type = SHT_STRTAB;

  symstrtab_hdr->sh_flags = 0;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  symstrtab_hdr->sh_addralign = 1;

  return TRUE;
}

/* Return the number of bytes required to hold the symtab vector.

   Note that we base it on the count plus 1, since we will null terminate
   the vector allocated based on this size.  However, the ELF symbol table
   always has a dummy entry as symbol #0, so it ends up even.  */

long
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->symtab_hdr;

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &elf_tdata (abfd)->dynsymtab_hdr;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  symcount = hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
				sec_ptr asect)
{
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

/* Canonicalize the relocs.  */

long
_bfd_elf_canonicalize_reloc (bfd *abfd,
			     sec_ptr section,
			     arelent **relptr,
			     asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count;
}

long
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);

  if (symcount >= 0)
    bfd_get_symcount (abfd) = symcount;
  return symcount;
}

long
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
				      asymbol **allocation)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);

  if (symcount >= 0)
    bfd_get_dynamic_symcount (abfd) = symcount;
  return symcount;
}

/* Return the size required for the dynamic reloc entries.  Any loadable
   section that was actually installed in the BFD, and has type SHT_REL
   or SHT_RELA, and uses the dynamic symbol table, is considered to be a
   dynamic reloc section.  */

long
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  long ret;
  asection *s;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  ret = sizeof (arelent *);
  for (s = abfd->sections; s != NULL; s = s->next)
    if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	&& (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	    || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
      ret += ((s->size / elf_section_data (s)->this_hdr.sh_entsize)
	      * sizeof (arelent *));

  return ret;
}

/* Canonicalize the dynamic relocation entries.  Note that we return the
   dynamic relocations as a single block, although they are actually
   associated with particular sections; the interface, which was
   designed for SunOS style shared libraries, expects that there is only
   one set of dynamic relocs.  Any loadable section that was actually
   installed in the BFD, and has type SHT_REL or SHT_RELA, and uses the
   dynamic symbol table, is considered to be a dynamic reloc section.  */

long
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
				     arelent **storage,
				     asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->size / elf_section_data (s)->this_hdr.sh_entsize;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read in the version information.  */

bfd_boolean
_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)
{
  bfd_byte *contents = NULL;
  unsigned int freeidx = 0;

  if (elf_dynverref (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verneed *everneed;
      Elf_Internal_Verneed *iverneed;
      unsigned int i;
      bfd_byte *contents_end;

      hdr = &elf_tdata (abfd)->dynverref_hdr;

      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)
          bfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));
      if (elf_tdata (abfd)->verref == NULL)
	goto error_return;

      elf_tdata (abfd)->cverrefs = hdr->sh_info;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	{
error_return_verref:
	  elf_tdata (abfd)->verref = NULL;
	  elf_tdata (abfd)->cverrefs = 0;
	  goto error_return;
	}
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return_verref;

      if (hdr->sh_info && hdr->sh_size < sizeof (Elf_External_Verneed))
	goto error_return_verref;

      BFD_ASSERT (sizeof (Elf_External_Verneed)
		  == sizeof (Elf_External_Vernaux));
      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);
      everneed = (Elf_External_Verneed *) contents;
      iverneed = elf_tdata (abfd)->verref;
      for (i = 0; i < hdr->sh_info; i++, iverneed++)
	{
	  Elf_External_Vernaux *evernaux;
	  Elf_Internal_Vernaux *ivernaux;
	  unsigned int j;

	  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);

	  iverneed->vn_bfd = abfd;

	  iverneed->vn_filename =
	    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					     iverneed->vn_file);
	  if (iverneed->vn_filename == NULL)
	    goto error_return_verref;

	  if (iverneed->vn_cnt == 0)
	    iverneed->vn_auxptr = NULL;
	  else
	    {
	      iverneed->vn_auxptr = (struct elf_internal_vernaux *)
                  bfd_alloc2 (abfd, iverneed->vn_cnt,
                              sizeof (Elf_Internal_Vernaux));
	      if (iverneed->vn_auxptr == NULL)
		goto error_return_verref;
	    }

	  if (iverneed->vn_aux
	      > (size_t) (contents_end - (bfd_byte *) everneed))
	    goto error_return_verref;

	  evernaux = ((Elf_External_Vernaux *)
		      ((bfd_byte *) everneed + iverneed->vn_aux));
	  ivernaux = iverneed->vn_auxptr;
	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
	    {
	      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);

	      ivernaux->vna_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 ivernaux->vna_name);
	      if (ivernaux->vna_nodename == NULL)
		goto error_return_verref;

	      if (j + 1 < iverneed->vn_cnt)
		ivernaux->vna_nextptr = ivernaux + 1;
	      else
		ivernaux->vna_nextptr = NULL;

	      if (ivernaux->vna_next
		  > (size_t) (contents_end - (bfd_byte *) evernaux))
		goto error_return_verref;

	      evernaux = ((Elf_External_Vernaux *)
			  ((bfd_byte *) evernaux + ivernaux->vna_next));

	      if (ivernaux->vna_other > freeidx)
		freeidx = ivernaux->vna_other;
	    }

	  if (i + 1 < hdr->sh_info)
	    iverneed->vn_nextref = iverneed + 1;
	  else
	    iverneed->vn_nextref = NULL;

	  if (iverneed->vn_next
	      > (size_t) (contents_end - (bfd_byte *) everneed))
	    goto error_return_verref;

	  everneed = ((Elf_External_Verneed *)
		      ((bfd_byte *) everneed + iverneed->vn_next));
	}

      free (contents);
      contents = NULL;
    }

  if (elf_dynverdef (abfd) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verdef *everdef;
      Elf_Internal_Verdef *iverdef;
      Elf_Internal_Verdef *iverdefarr;
      Elf_Internal_Verdef iverdefmem;
      unsigned int i;
      unsigned int maxidx;
      bfd_byte *contents_end_def, *contents_end_aux;

      hdr = &elf_tdata (abfd)->dynverdef_hdr;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;

      if (hdr->sh_info && hdr->sh_size < sizeof (Elf_External_Verdef))
	goto error_return;

      BFD_ASSERT (sizeof (Elf_External_Verdef)
		  >= sizeof (Elf_External_Verdaux));
      contents_end_def = contents + hdr->sh_size
			 - sizeof (Elf_External_Verdef);
      contents_end_aux = contents + hdr->sh_size
			 - sizeof (Elf_External_Verdaux);

      /* We know the number of entries in the section but not the maximum
	 index.  Therefore we have to run through all entries and find
	 the maximum.  */
      everdef = (Elf_External_Verdef *) contents;
      maxidx = 0;
      for (i = 0; i < hdr->sh_info; ++i)
	{
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)
	    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);

	  if (iverdefmem.vd_next
	      > (size_t) (contents_end_def - (bfd_byte *) everdef))
	    goto error_return;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdefmem.vd_next));
	}

      if (default_imported_symver)
	{
	  if (freeidx > maxidx)
	    maxidx = ++freeidx;
	  else
	    freeidx = ++maxidx;
	}
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
          bfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = maxidx;

      everdef = (Elf_External_Verdef *) contents;
      iverdefarr = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++)
	{
	  Elf_External_Verdaux *everdaux;
	  Elf_Internal_Verdaux *iverdaux;
	  unsigned int j;

	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)
	    {
error_return_verdef:
	      elf_tdata (abfd)->verdef = NULL;
	      elf_tdata (abfd)->cverdefs = 0;
	      goto error_return;
	    }

	  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];
	  memcpy (iverdef, &iverdefmem, sizeof (Elf_Internal_Verdef));

	  iverdef->vd_bfd = abfd;

	  if (iverdef->vd_cnt == 0)
	    iverdef->vd_auxptr = NULL;
	  else
	    {
	      iverdef->vd_auxptr = (struct elf_internal_verdaux *)
                  bfd_alloc2 (abfd, iverdef->vd_cnt,
                              sizeof (Elf_Internal_Verdaux));
	      if (iverdef->vd_auxptr == NULL)
		goto error_return_verdef;
	    }

	  if (iverdef->vd_aux
	      > (size_t) (contents_end_aux - (bfd_byte *) everdef))
	    goto error_return_verdef;

	  everdaux = ((Elf_External_Verdaux *)
		      ((bfd_byte *) everdef + iverdef->vd_aux));
	  iverdaux = iverdef->vd_auxptr;
	  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
	    {
	      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);

	      iverdaux->vda_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 iverdaux->vda_name);
	      if (iverdaux->vda_nodename == NULL)
		goto error_return_verdef;

	      if (j + 1 < iverdef->vd_cnt)
		iverdaux->vda_nextptr = iverdaux + 1;
	      else
		iverdaux->vda_nextptr = NULL;

	      if (iverdaux->vda_next
		  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))
		goto error_return_verdef;

	      everdaux = ((Elf_External_Verdaux *)
			  ((bfd_byte *) everdaux + iverdaux->vda_next));
	    }

	  if (iverdef->vd_cnt)
	    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;

	  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)
	    iverdef->vd_nextdef = iverdef + 1;
	  else
	    iverdef->vd_nextdef = NULL;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdef->vd_next));
	}

      free (contents);
      contents = NULL;
    }
  else if (default_imported_symver)
    {
      if (freeidx < 3)
	freeidx = 3;
      else
	freeidx++;

      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = freeidx;
    }

  /* Create a default version based on the soname.  */
  if (default_imported_symver)
    {
      Elf_Internal_Verdef *iverdef;
      Elf_Internal_Verdaux *iverdaux;

      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];

      iverdef->vd_version = VER_DEF_CURRENT;
      iverdef->vd_flags = 0;
      iverdef->vd_ndx = freeidx;
      iverdef->vd_cnt = 1;

      iverdef->vd_bfd = abfd;

      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);
      if (iverdef->vd_nodename == NULL)
	goto error_return_verdef;
      iverdef->vd_nextdef = NULL;
      iverdef->vd_auxptr = (struct elf_internal_verdaux *)
          bfd_alloc (abfd, sizeof (Elf_Internal_Verdaux));
      if (iverdef->vd_auxptr == NULL)
	goto error_return_verdef;

      iverdaux = iverdef->vd_auxptr;
      iverdaux->vda_nodename = iverdef->vd_nodename;
      iverdaux->vda_nextptr = NULL;
    }

  return TRUE;

 error_return:
  if (contents != NULL)
    free (contents);
  return FALSE;
}

asymbol *
_bfd_elf_make_empty_symbol (bfd *abfd)
{
  elf_symbol_type *newsym;
  bfd_size_type amt = sizeof (elf_symbol_type);

  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
  if (!newsym)
    return NULL;
  else
    {
      newsym->symbol.the_bfd = abfd;
      return &newsym->symbol;
    }
}

void
_bfd_elf_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			  asymbol *symbol,
			  symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

/* Return whether a symbol name implies a local symbol.  Most targets
   use this function for the is_local_label_name entry point, but some
   override it.  */

bfd_boolean
_bfd_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *name)
{
  /* Normal local symbols start with ``.L''.  */
  if (name[0] == '.' && name[1] == 'L')
    return TRUE;

  /* At least some SVR4 compilers (e.g., UnixWare 2.1 cc) generate
     DWARF debugging symbols starting with ``..''.  */
  if (name[0] == '.' && name[1] == '.')
    return TRUE;

  /* gcc will sometimes generate symbols beginning with ``_.L_'' when
     emitting DWARF debugging output.  I suspect this is actually a
     small bug in gcc (it calls ASM_OUTPUT_LABEL when it should call
     ASM_GENERATE_INTERNAL_LABEL, and this causes the leading
     underscore to be emitted on some ELF targets).  For ease of use,
     we treat such symbols as local.  */
  if (name[0] == '_' && name[1] == '.' && name[2] == 'L' && name[3] == '_')
    return TRUE;

  return FALSE;
}

alent *
_bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol ATTRIBUTE_UNUSED)
{
  abort ();
  return NULL;
}

bfd_boolean
_bfd_elf_set_arch_mach (bfd *abfd,
			enum bfd_architecture arch,
			unsigned long machine)
{
  /* If this isn't the right architecture for this backend, and this
     isn't the generic backend, fail.  */
  if (arch != get_elf_backend_data (abfd)->arch
      && arch != bfd_arch_unknown
      && get_elf_backend_data (abfd)->arch != bfd_arch_unknown)
    return FALSE;

  return bfd_default_set_arch_mach (abfd, arch, machine);
}

/* Find the function to a particular section and offset,
   for error reporting.  */

static bfd_boolean
elf_find_function (bfd *abfd,
		   asection *section,
		   asymbol **symbols,
		   bfd_vma offset,
		   const char **filename_ptr,
		   const char **functionname_ptr)
{
  struct elf_find_function_cache
  {
    asection *last_section;
    asymbol *func;
    const char *filename;
    bfd_size_type func_size;
  } *cache;

  if (symbols == NULL)
    return FALSE;

  cache = elf_tdata (abfd)->elf_find_function_cache;
  if (cache == NULL)
    {
      cache = bfd_zalloc (abfd, sizeof (*cache));
      elf_tdata (abfd)->elf_find_function_cache = cache;
      if (cache == NULL)
	return FALSE;
    }
  if (cache->last_section != section
      || cache->func == NULL
      || offset < cache->func->value
      || offset >= cache->func->value + cache->func_size)
    {
      asymbol *file;
      bfd_vma low_func;
      asymbol **p;
      /* ??? Given multiple file symbols, it is impossible to reliably
	 choose the right file name for global symbols.  File symbols are
	 local symbols, and thus all file symbols must sort before any
	 global symbols.  The ELF spec may be interpreted to say that a
	 file symbol must sort before other local symbols, but currently
	 ld -r doesn't do this.  So, for ld -r output, it is possible to
	 make a better choice of file name for local symbols by ignoring
	 file symbols appearing after a given local symbol.  */
      enum { nothing_seen, symbol_seen, file_after_symbol_seen } state;
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);

      file = NULL;
      low_func = 0;
      state = nothing_seen;
      cache->filename = NULL;
      cache->func = NULL;
      cache->func_size = 0;
      cache->last_section = section;

      for (p = symbols; *p != NULL; p++)
	{
	  asymbol *sym = *p;
	  bfd_vma code_off;
	  bfd_size_type size;

	  if ((sym->flags & BSF_FILE) != 0)
	    {
	      file = sym;
	      if (state == symbol_seen)
		state = file_after_symbol_seen;
	      continue;
	    }

	  size = bed->maybe_function_sym (sym, section, &code_off);
	  if (size != 0
	      && code_off <= offset
	      && (code_off > low_func
		  || (code_off == low_func
		      && size > cache->func_size)))
	    {
	      cache->func = sym;
	      cache->func_size = size;
	      cache->filename = NULL;
	      low_func = code_off;
	      if (file != NULL
		  && ((sym->flags & BSF_LOCAL) != 0
		      || state != file_after_symbol_seen))
		cache->filename = bfd_asymbol_name (file);
	    }
	  if (state == nothing_seen)
	    state = symbol_seen;
	}
    }

  if (cache->func == NULL)
    return FALSE;

  if (filename_ptr)
    *filename_ptr = cache->filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (cache->func);

  return TRUE;
}

/* Find the nearest line to a particular section and offset,
   for error reporting.  */

bfd_boolean
_bfd_elf_find_nearest_line (bfd *abfd,
			    asection *section,
			    asymbol **symbols,
			    bfd_vma offset,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
{
  return _bfd_elf_find_nearest_line_discriminator (abfd, section, symbols,
                                                   offset, filename_ptr,
                                                   functionname_ptr,
                                                   line_ptr,
                                                   NULL);
}

bfd_boolean
_bfd_elf_find_nearest_line_discriminator (bfd *abfd,
                                          asection *section,
                                          asymbol **symbols,
                                          bfd_vma offset,
                                          const char **filename_ptr,
                                          const char **functionname_ptr,
                                          unsigned int *line_ptr,
                                          unsigned int *discriminator_ptr)
{
  bfd_boolean found;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return TRUE;
    }

  if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
                                     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, discriminator_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return TRUE;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return FALSE;
  if (found && (*functionname_ptr || *line_ptr))
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  if (! elf_find_function (abfd, section, symbols, offset,
			   filename_ptr, functionname_ptr))
    return FALSE;

  *line_ptr = 0;
  return TRUE;
}

/* Find the line for a symbol.  */

bfd_boolean
_bfd_elf_find_line (bfd *abfd, asymbol **symbols, asymbol *symbol,
		    const char **filename_ptr, unsigned int *line_ptr)
{
  return _bfd_elf_find_line_discriminator (abfd, symbols, symbol,
		                           filename_ptr, line_ptr,
                                           NULL);
}

bfd_boolean
_bfd_elf_find_line_discriminator (bfd *abfd, asymbol **symbols, asymbol *symbol,
                                  const char **filename_ptr,
                                  unsigned int *line_ptr,
                                  unsigned int *discriminator_ptr)
{
  return _bfd_dwarf2_find_line (abfd, symbols, symbol,
				filename_ptr, line_ptr, discriminator_ptr, 0,
				&elf_tdata (abfd)->dwarf2_find_line_info);
}

/* After a call to bfd_find_nearest_line, successive calls to
   bfd_find_inliner_info can be used to get source information about
   each level of function inlining that terminated at the address
   passed to bfd_find_nearest_line.  Currently this is only supported
   for DWARF2 with appropriate DWARF3 extensions. */

bfd_boolean
_bfd_elf_find_inliner_info (bfd *abfd,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
{
  bfd_boolean found;
  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
					 functionname_ptr, line_ptr,
					 & elf_tdata (abfd)->dwarf2_find_line_info);
  return found;
}

int
_bfd_elf_sizeof_headers (bfd *abfd, struct bfd_link_info *info)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  int ret = bed->s->sizeof_ehdr;

  if (!info->relocatable)
    {
      bfd_size_type phdr_size = elf_program_header_size (abfd);

      if (phdr_size == (bfd_size_type) -1)
	{
	  struct elf_segment_map *m;

	  phdr_size = 0;
	  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
	    phdr_size += bed->s->sizeof_phdr;

	  if (phdr_size == 0)
	    phdr_size = get_program_header_size (abfd, info);
	}

      elf_program_header_size (abfd) = phdr_size;
      ret += phdr_size;
    }

  return ret;
}

bfd_boolean
_bfd_elf_set_section_contents (bfd *abfd,
			       sec_ptr section,
			       const void *location,
			       file_ptr offset,
			       bfd_size_type count)
{
  Elf_Internal_Shdr *hdr;
  bfd_signed_vma pos;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;

  hdr = &elf_section_data (section)->this_hdr;
  pos = hdr->sh_offset + offset;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

void
_bfd_elf_no_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *cache_ptr ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  abort ();
}

/* Try to convert a non-ELF reloc into an ELF one.  */

bfd_boolean
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
{
  /* Check whether we really have an ELF howto.  */

  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec)
    {
      bfd_reloc_code_real_type code;
      reloc_howto_type *howto;

      /* Alien reloc: Try to determine its type to replace it with an
	 equivalent ELF reloc.  */

      if (areloc->howto->pc_relative)
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8_PCREL;
	      break;
	    case 12:
	      code = BFD_RELOC_12_PCREL;
	      break;
	    case 16:
	      code = BFD_RELOC_16_PCREL;
	      break;
	    case 24:
	      code = BFD_RELOC_24_PCREL;
	      break;
	    case 32:
	      code = BFD_RELOC_32_PCREL;
	      break;
	    case 64:
	      code = BFD_RELOC_64_PCREL;
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);

	  if (areloc->howto->pcrel_offset != howto->pcrel_offset)
	    {
	      if (howto->pcrel_offset)
		areloc->addend += areloc->address;
	      else
		areloc->addend -= areloc->address; /* addend is unsigned!! */
	    }
	}
      else
	{
	  switch (areloc->howto->bitsize)
	    {
	    case 8:
	      code = BFD_RELOC_8;
	      break;
	    case 14:
	      code = BFD_RELOC_14;
	      break;
	    case 16:
	      code = BFD_RELOC_16;
	      break;
	    case 26:
	      code = BFD_RELOC_26;
	      break;
	    case 32:
	      code = BFD_RELOC_32;
	      break;
	    case 64:
	      code = BFD_RELOC_64;
	      break;
	    default:
	      goto fail;
	    }

	  howto = bfd_reloc_type_lookup (abfd, code);
	}

      if (howto)
	areloc->howto = howto;
      else
	goto fail;
    }

  return TRUE;

 fail:
  (*_bfd_error_handler)
    (_("%B: unsupported relocation type %s"),
     abfd, areloc->howto->name);
  bfd_set_error (bfd_error_bad_value);
  return FALSE;
}

bfd_boolean
_bfd_elf_close_and_cleanup (bfd *abfd)
{
  struct elf_obj_tdata *tdata = elf_tdata (abfd);
  if (bfd_get_format (abfd) == bfd_object && tdata != NULL)
    {
      if (elf_tdata (abfd)->o != NULL && elf_shstrtab (abfd) != NULL)
	_bfd_elf_strtab_free (elf_shstrtab (abfd));
      _bfd_dwarf2_cleanup_debug_info (abfd, &tdata->dwarf2_find_line_info);
    }

  return _bfd_generic_close_and_cleanup (abfd);
}

/* For Rel targets, we encode meaningful data for BFD_RELOC_VTABLE_ENTRY
   in the relocation's offset.  Thus we cannot allow any sort of sanity
   range-checking to interfere.  There is nothing else to do in processing
   this reloc.  */

bfd_reloc_status_type
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd ATTRIBUTE_UNUSED, arelent *re ATTRIBUTE_UNUSED,
   struct bfd_symbol *symbol ATTRIBUTE_UNUSED,
   void *data ATTRIBUTE_UNUSED, asection *is ATTRIBUTE_UNUSED,
   bfd *obfd ATTRIBUTE_UNUSED, char **errmsg ATTRIBUTE_UNUSED)
{
  return bfd_reloc_ok;
}

/* Elf core file support.  Much of this only works on native
   toolchains, since we rely on knowing the
   machine-dependent procfs structure in order to pick
   out details about the corefile.  */

#ifdef HAVE_SYS_PROCFS_H
/* Needed for new procfs interface on sparc-solaris.  */
# define _STRUCTURED_PROC 1
# include <sys/procfs.h>
#endif

/* Return a PID that identifies a "thread" for threaded cores, or the
   PID of the main process for non-threaded cores.  */

static int
elfcore_make_pid (bfd *abfd)
{
  int pid;

  pid = elf_tdata (abfd)->core->lwpid;
  if (pid == 0)
    pid = elf_tdata (abfd)->core->pid;

  return pid;
}

/* If there isn't a section called NAME, make one, using
   data from SECT.  Note, this function will generate a
   reference to NAME, so you shouldn't deallocate or
   overwrite it.  */

static bfd_boolean
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
{
  asection *sect2;

  if (bfd_get_section_by_name (abfd, name) != NULL)
    return TRUE;

  sect2 = bfd_make_section_with_flags (abfd, name, sect->flags);
  if (sect2 == NULL)
    return FALSE;

  sect2->size = sect->size;
  sect2->filepos = sect->filepos;
  sect2->alignment_power = sect->alignment_power;
  return TRUE;
}

/* Create a pseudosection containing SIZE bytes at FILEPOS.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents. */
bfd_boolean
_bfd_elfcore_make_pseudosection (bfd *abfd,
				 char *name,
				 size_t size,
				 ufile_ptr filepos)
{
  char buf[100];
  char *threaded_name;
  size_t len;
  asection *sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  threaded_name = (char *) bfd_alloc (abfd, len);
  if (threaded_name == NULL)
    return FALSE;
  memcpy (threaded_name, buf, len);

  sect = bfd_make_section_anyway_with_flags (abfd, threaded_name,
					     SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;
  sect->size = size;
  sect->filepos = filepos;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, name, sect);
}

/* prstatus_t exists on:
     solaris 2.5+
     linux 2.[01] + glibc
     unixware 4.2
*/

#if defined (HAVE_PRSTATUS_T)

static bfd_boolean
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t size;
  int offset;

  if (note->descsz == sizeof (prstatus_t))
    {
      prstatus_t prstat;

      size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core->signal == 0)
	elf_tdata (abfd)->core->signal = prstat.pr_cursig;
      if (elf_tdata (abfd)->core->pid == 0)
	elf_tdata (abfd)->core->pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
#if defined (HAVE_PRSTATUS_T_PR_WHO)
      elf_tdata (abfd)->core->lwpid = prstat.pr_who;
#else
      elf_tdata (abfd)->core->lwpid = prstat.pr_pid;
#endif
    }
#if defined (HAVE_PRSTATUS32_T)
  else if (note->descsz == sizeof (prstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      prstatus32_t prstat;

      size = sizeof (prstat.pr_reg);
      offset   = offsetof (prstatus32_t, pr_reg);
      memcpy (&prstat, note->descdata, sizeof (prstat));

      /* Do not overwrite the core signal if it
	 has already been set by another thread.  */
      if (elf_tdata (abfd)->core->signal == 0)
	elf_tdata (abfd)->core->signal = prstat.pr_cursig;
      if (elf_tdata (abfd)->core->pid == 0)
	elf_tdata (abfd)->core->pid = prstat.pr_pid;

      /* pr_who exists on:
	 solaris 2.5+
	 unixware 4.2
	 pr_who doesn't exist on:
	 linux 2.[01]
	 */
#if defined (HAVE_PRSTATUS32_T_PR_WHO)
      elf_tdata (abfd)->core->lwpid = prstat.pr_who;
#else
      elf_tdata (abfd)->core->lwpid = prstat.pr_pid;
#endif
    }
#endif /* HAVE_PRSTATUS32_T */
  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return TRUE;
    }

  /* Make a ".reg/999" section and a ".reg" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}
#endif /* defined (HAVE_PRSTATUS_T) */

/* Create a pseudosection containing the exact contents of NOTE.  */
static bfd_boolean
elfcore_make_note_pseudosection (bfd *abfd,
				 char *name,
				 Elf_Internal_Note *note)
{
  return _bfd_elfcore_make_pseudosection (abfd, name,
					  note->descsz, note->descpos);
}

/* There isn't a consistent prfpregset_t across platforms,
   but it doesn't matter, because we don't have to pick this
   data structure apart.  */

static bfd_boolean
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg2", note);
}

/* Linux dumps the Intel SSE regs in a note named "LINUX" with a note
   type of NT_PRXFPREG.  Just include the whole note's contents
   literally.  */

static bfd_boolean
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);
}

/* Linux dumps the Intel XSAVE extended state in a note named "LINUX"
   with a note type of NT_X86_XSTATE.  Just include the whole note's
   contents literally.  */

static bfd_boolean
elfcore_grok_xstatereg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xstate", note);
}

static bfd_boolean
elfcore_grok_ppc_vmx (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-ppc-vmx", note);
}

static bfd_boolean
elfcore_grok_ppc_vsx (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-ppc-vsx", note);
}

static bfd_boolean
elfcore_grok_s390_high_gprs (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-high-gprs", note);
}

static bfd_boolean
elfcore_grok_s390_timer (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-timer", note);
}

static bfd_boolean
elfcore_grok_s390_todcmp (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-todcmp", note);
}

static bfd_boolean
elfcore_grok_s390_todpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-todpreg", note);
}

static bfd_boolean
elfcore_grok_s390_ctrs (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-ctrs", note);
}

static bfd_boolean
elfcore_grok_s390_prefix (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-prefix", note);
}

static bfd_boolean
elfcore_grok_s390_last_break (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-last-break", note);
}

static bfd_boolean
elfcore_grok_s390_system_call (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-system-call", note);
}

static bfd_boolean
elfcore_grok_s390_tdb (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-tdb", note);
}

static bfd_boolean
elfcore_grok_arm_vfp (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-arm-vfp", note);
}

static bfd_boolean
elfcore_grok_aarch_tls (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-tls", note);
}

static bfd_boolean
elfcore_grok_aarch_hw_break (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-hw-break", note);
}

static bfd_boolean
elfcore_grok_aarch_hw_watch (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-hw-watch", note);
}

#if defined (HAVE_PRPSINFO_T)
typedef prpsinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PRPSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef prpsinfo32_t elfcore_psinfo32_t;
#endif
#endif

#if defined (HAVE_PSINFO_T)
typedef psinfo_t   elfcore_psinfo_t;
#if defined (HAVE_PSINFO32_T)		/* Sparc64 cross Sparc32 */
typedef psinfo32_t elfcore_psinfo32_t;
#endif
#endif

/* return a malloc'ed copy of a string at START which is at
   most MAX bytes long, possibly without a terminating '\0'.
   the copy will always have a terminating '\0'.  */

char *
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
{
  char *dups;
  char *end = (char *) memchr (start, '\0', max);
  size_t len;

  if (end == NULL)
    len = max;
  else
    len = end - start;

  dups = (char *) bfd_alloc (abfd, len + 1);
  if (dups == NULL)
    return NULL;

  memcpy (dups, start, len);
  dups[len] = '\0';

  return dups;
}

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
static bfd_boolean
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz == sizeof (elfcore_psinfo_t))
    {
      elfcore_psinfo_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));

#if defined (HAVE_PSINFO_T_PR_PID) || defined (HAVE_PRPSINFO_T_PR_PID)
      elf_tdata (abfd)->core->pid = psinfo.pr_pid;
#endif
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));

      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
    }
#if defined (HAVE_PRPSINFO32_T) || defined (HAVE_PSINFO32_T)
  else if (note->descsz == sizeof (elfcore_psinfo32_t))
    {
      /* 64-bit host, 32-bit corefile */
      elfcore_psinfo32_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));

#if defined (HAVE_PSINFO32_T_PR_PID) || defined (HAVE_PRPSINFO32_T_PR_PID)
      elf_tdata (abfd)->core->pid = psinfo.pr_pid;
#endif
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
				sizeof (psinfo.pr_fname));

      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
				sizeof (psinfo.pr_psargs));
    }
#endif

  else
    {
      /* Fail - we don't know how to handle any other
	 note size (ie. data object type).  */
      return TRUE;
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}
#endif /* defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T) */

#if defined (HAVE_PSTATUS_T)
static bfd_boolean
elfcore_grok_pstatus (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz == sizeof (pstatus_t)
#if defined (HAVE_PXSTATUS_T)
      || note->descsz == sizeof (pxstatus_t)
#endif
      )
    {
      pstatus_t pstat;

      memcpy (&pstat, note->descdata, sizeof (pstat));

      elf_tdata (abfd)->core->pid = pstat.pr_pid;
    }
#if defined (HAVE_PSTATUS32_T)
  else if (note->descsz == sizeof (pstatus32_t))
    {
      /* 64-bit host, 32-bit corefile */
      pstatus32_t pstat;

      memcpy (&pstat, note->descdata, sizeof (pstat));

      elf_tdata (abfd)->core->pid = pstat.pr_pid;
    }
#endif
  /* Could grab some more details from the "representative"
     lwpstatus_t in pstat.pr_lwp, but we'll catch it all in an
     NT_LWPSTATUS note, presumably.  */

  return TRUE;
}
#endif /* defined (HAVE_PSTATUS_T) */

#if defined (HAVE_LWPSTATUS_T)
static bfd_boolean
elfcore_grok_lwpstatus (bfd *abfd, Elf_Internal_Note *note)
{
  lwpstatus_t lwpstat;
  char buf[100];
  char *name;
  size_t len;
  asection *sect;

  if (note->descsz != sizeof (lwpstat)
#if defined (HAVE_LWPXSTATUS_T)
      && note->descsz != sizeof (lwpxstatus_t)
#endif
      )
    return TRUE;

  memcpy (&lwpstat, note->descdata, sizeof (lwpstat));

  elf_tdata (abfd)->core->lwpid = lwpstat.pr_lwpid;
  /* Do not overwrite the core signal if it has already been set by
     another thread.  */
  if (elf_tdata (abfd)->core->signal == 0)
    elf_tdata (abfd)->core->signal = lwpstat.pr_cursig;

  /* Make a ".reg/999" section.  */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, buf, len);

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->size = sizeof (lwpstat.pr_context.uc_mcontext.gregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.gregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_REG)
  sect->size = sizeof (lwpstat.pr_reg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_reg);
#endif

  sect->alignment_power = 2;

  if (!elfcore_maybe_make_sect (abfd, ".reg", sect))
    return FALSE;

  /* Make a ".reg2/999" section */

  sprintf (buf, ".reg2/%d", elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, buf, len);

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

#if defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
  sect->size = sizeof (lwpstat.pr_context.uc_mcontext.fpregs);
  sect->filepos = note->descpos
    + offsetof (lwpstatus_t, pr_context.uc_mcontext.fpregs);
#endif

#if defined (HAVE_LWPSTATUS_T_PR_FPREG)
  sect->size = sizeof (lwpstat.pr_fpreg);
  sect->filepos = note->descpos + offsetof (lwpstatus_t, pr_fpreg);
#endif

  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, ".reg2", sect);
}
#endif /* defined (HAVE_LWPSTATUS_T) */

static bfd_boolean
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
{
  char buf[30];
  char *name;
  size_t len;
  asection *sect;
  int type;
  int is_active_thread;
  bfd_vma base_addr;

  if (note->descsz < 728)
    return TRUE;

  if (! CONST_STRNEQ (note->namedata, "win32"))
    return TRUE;

  type = bfd_get_32 (abfd, note->descdata);

  switch (type)
    {
    case 1 /* NOTE_INFO_PROCESS */:
      /* FIXME: need to add ->core->command.  */
      /* process_info.pid */
      elf_tdata (abfd)->core->pid = bfd_get_32 (abfd, note->descdata + 8);
      /* process_info.signal */
      elf_tdata (abfd)->core->signal = bfd_get_32 (abfd, note->descdata + 12);
      break;

    case 2 /* NOTE_INFO_THREAD */:
      /* Make a ".reg/999" section.  */
      /* thread_info.tid */
      sprintf (buf, ".reg/%ld", (long) bfd_get_32 (abfd, note->descdata + 8));

      len = strlen (buf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (name == NULL)
	return FALSE;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
      if (sect == NULL)
	return FALSE;

      /* sizeof (thread_info.thread_context) */
      sect->size = 716;
      /* offsetof (thread_info.thread_context) */
      sect->filepos = note->descpos + 12;
      sect->alignment_power = 2;

      /* thread_info.is_active_thread */
      is_active_thread = bfd_get_32 (abfd, note->descdata + 8);

      if (is_active_thread)
	if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
	  return FALSE;
      break;

    case 3 /* NOTE_INFO_MODULE */:
      /* Make a ".module/xxxxxxxx" section.  */
      /* module_info.base_address */
      base_addr = bfd_get_32 (abfd, note->descdata + 4);
      sprintf (buf, ".module/%08lx", (unsigned long) base_addr);

      len = strlen (buf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (name == NULL)
	return FALSE;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);

      if (sect == NULL)
	return FALSE;

      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 2;
      break;

    default:
      return TRUE;
    }

  return TRUE;
}

static bfd_boolean
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  switch (note->type)
    {
    default:
      return TRUE;

    case NT_PRSTATUS:
      if (bed->elf_backend_grok_prstatus)
	if ((*bed->elf_backend_grok_prstatus) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRSTATUS_T)
      return elfcore_grok_prstatus (abfd, note);
#else
      return TRUE;
#endif

#if defined (HAVE_PSTATUS_T)
    case NT_PSTATUS:
      return elfcore_grok_pstatus (abfd, note);
#endif

#if defined (HAVE_LWPSTATUS_T)
    case NT_LWPSTATUS:
      return elfcore_grok_lwpstatus (abfd, note);
#endif

    case NT_FPREGSET:		/* FIXME: rename to NT_PRFPREG */
      return elfcore_grok_prfpreg (abfd, note);

    case NT_WIN32PSTATUS:
      return elfcore_grok_win32pstatus (abfd, note);

    case NT_PRXFPREG:		/* Linux SSE extension */
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_prxfpreg (abfd, note);
      else
	return TRUE;

    case NT_X86_XSTATE:		/* Linux XSAVE extension */
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_xstatereg (abfd, note);
      else
	return TRUE;

    case NT_PPC_VMX:
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_ppc_vmx (abfd, note);
      else
	return TRUE;

    case NT_PPC_VSX:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_ppc_vsx (abfd, note);
      else
        return TRUE;

    case NT_S390_HIGH_GPRS:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_high_gprs (abfd, note);
      else
        return TRUE;

    case NT_S390_TIMER:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_timer (abfd, note);
      else
        return TRUE;

    case NT_S390_TODCMP:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_todcmp (abfd, note);
      else
        return TRUE;

    case NT_S390_TODPREG:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_todpreg (abfd, note);
      else
        return TRUE;

    case NT_S390_CTRS:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_ctrs (abfd, note);
      else
        return TRUE;

    case NT_S390_PREFIX:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_prefix (abfd, note);
      else
        return TRUE;

    case NT_S390_LAST_BREAK:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_last_break (abfd, note);
      else
        return TRUE;

    case NT_S390_SYSTEM_CALL:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_system_call (abfd, note);
      else
        return TRUE;

    case NT_S390_TDB:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_tdb (abfd, note);
      else
        return TRUE;

    case NT_ARM_VFP:
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_arm_vfp (abfd, note);
      else
	return TRUE;

    case NT_ARM_TLS:
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_aarch_tls (abfd, note);
      else
	return TRUE;

    case NT_ARM_HW_BREAK:
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_aarch_hw_break (abfd, note);
      else
	return TRUE;

    case NT_ARM_HW_WATCH:
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
	return elfcore_grok_aarch_hw_watch (abfd, note);
      else
	return TRUE;

    case NT_PRPSINFO:
    case NT_PSINFO:
      if (bed->elf_backend_grok_psinfo)
	if ((*bed->elf_backend_grok_psinfo) (abfd, note))
	  return TRUE;
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
      return elfcore_grok_psinfo (abfd, note);
#else
      return TRUE;
#endif

    case NT_AUXV:
      {
	asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
							     SEC_HAS_CONTENTS);

	if (sect == NULL)
	  return FALSE;
	sect->size = note->descsz;
	sect->filepos = note->descpos;
	sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

	return TRUE;
      }

    case NT_FILE:
      return elfcore_make_note_pseudosection (abfd, ".note.linuxcore.file",
					      note);

    case NT_SIGINFO:
      return elfcore_make_note_pseudosection (abfd, ".note.linuxcore.siginfo",
					      note);
    }
}

static bfd_boolean
elfobj_grok_gnu_build_id (bfd *abfd, Elf_Internal_Note *note)
{
  struct elf_obj_tdata *t;

  if (note->descsz == 0)
    return FALSE;

  t = elf_tdata (abfd);
  t->build_id = bfd_alloc (abfd, sizeof (*t->build_id) - 1 + note->descsz);
  if (t->build_id == NULL)
    return FALSE;

  t->build_id->size = note->descsz;
  memcpy (t->build_id->data, note->descdata, note->descsz);

  return TRUE;
}

static bfd_boolean
elfobj_grok_gnu_note (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->type)
    {
    default:
      return TRUE;

    case NT_GNU_BUILD_ID:
      return elfobj_grok_gnu_build_id (abfd, note);
    }
}

static bfd_boolean
elfobj_grok_stapsdt_note_1 (bfd *abfd, Elf_Internal_Note *note)
{
  struct sdt_note *cur =
    (struct sdt_note *) bfd_alloc (abfd, sizeof (struct sdt_note)
				   + note->descsz);

  cur->next = (struct sdt_note *) (elf_tdata (abfd))->sdt_note_head;
  cur->size = (bfd_size_type) note->descsz;
  memcpy (cur->data, note->descdata, note->descsz);

  elf_tdata (abfd)->sdt_note_head = cur;

  return TRUE;
}

static bfd_boolean
elfobj_grok_stapsdt_note (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->type)
    {
    case NT_STAPSDT:
      return elfobj_grok_stapsdt_note_1 (abfd, note);

    default:
      return TRUE;
    }
}

static bfd_boolean
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
{
  char *cp;

  cp = strchr (note->namedata, '@@');
  if (cp != NULL)
    {
      *lwpidp = atoi(cp + 1);
      return TRUE;
    }
  return FALSE;
}

static bfd_boolean
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{
  /* Signal number at offset 0x08. */
  elf_tdata (abfd)->core->signal
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x08);

  /* Process ID at offset 0x50. */
  elf_tdata (abfd)->core->pid
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x50);

  /* Command name at 0x7c (max 32 bytes, including nul). */
  elf_tdata (abfd)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x7c, 31);

  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
					  note);
}

static bfd_boolean
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  int lwp;

  if (elfcore_netbsd_get_lwpid (note, &lwp))
    elf_tdata (abfd)->core->lwpid = lwp;

  if (note->type == NT_NETBSDCORE_PROCINFO)
    {
      /* NetBSD-specific core "procinfo".  Note that we expect to
	 find this note before any of the others, which is fine,
	 since the kernel writes this note out first when it
	 creates a core file.  */

      return elfcore_grok_netbsd_procinfo (abfd, note);
    }

  /* As of Jan 2002 there are no other machine-independent notes
     defined for NetBSD core files.  If the note type is less
     than the start of the machine-dependent note types, we don't
     understand it.  */

  if (note->type < NT_NETBSDCORE_FIRSTMACH)
    return TRUE;


  switch (bfd_get_arch (abfd))
    {
      /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0 and
	 PT_GETFPREGS == mach+2.  */

    case bfd_arch_alpha:
    case bfd_arch_sparc:
      switch (note->type)
	{
	case NT_NETBSDCORE_FIRSTMACH+0:
	  return elfcore_make_note_pseudosection (abfd, ".reg", note);

	case NT_NETBSDCORE_FIRSTMACH+2:
	  return elfcore_make_note_pseudosection (abfd, ".reg2", note);

	default:
	  return TRUE;
	}

      /* On all other arch's, PT_GETREGS == mach+1 and
	 PT_GETFPREGS == mach+3.  */

    default:
      switch (note->type)
	{
	case NT_NETBSDCORE_FIRSTMACH+1:
	  return elfcore_make_note_pseudosection (abfd, ".reg", note);

	case NT_NETBSDCORE_FIRSTMACH+3:
	  return elfcore_make_note_pseudosection (abfd, ".reg2", note);

	default:
	  return TRUE;
	}
    }
    /* NOTREACHED */
}

static bfd_boolean
elfcore_grok_openbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{
  /* Signal number at offset 0x08. */
  elf_tdata (abfd)->core->signal
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x08);

  /* Process ID at offset 0x20. */
  elf_tdata (abfd)->core->pid
    = bfd_h_get_32 (abfd, (bfd_byte *) note->descdata + 0x20);

  /* Command name at 0x48 (max 32 bytes, including nul). */
  elf_tdata (abfd)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x48, 31);

  return TRUE;
}

static bfd_boolean
elfcore_grok_openbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->type == NT_OPENBSD_PROCINFO)
    return elfcore_grok_openbsd_procinfo (abfd, note);

  if (note->type == NT_OPENBSD_REGS)
    return elfcore_make_note_pseudosection (abfd, ".reg", note);

  if (note->type == NT_OPENBSD_FPREGS)
    return elfcore_make_note_pseudosection (abfd, ".reg2", note);

  if (note->type == NT_OPENBSD_XFPREGS)
    return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);

  if (note->type == NT_OPENBSD_AUXV)
    {
      asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
							   SEC_HAS_CONTENTS);

      if (sect == NULL)
	return FALSE;
      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return TRUE;
    }

  if (note->type == NT_OPENBSD_WCOOKIE)
    {
      asection *sect = bfd_make_section_anyway_with_flags (abfd, ".wcookie",
							   SEC_HAS_CONTENTS);

      if (sect == NULL)
	return FALSE;
      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return TRUE;
    }

  return TRUE;
}

static bfd_boolean
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;
  short sig;
  unsigned flags;

  /* nto_procfs_status 'pid' field is at offset 0.  */
  elf_tdata (abfd)->core->pid = bfd_get_32 (abfd, (bfd_byte *) ddata);

  /* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
  *tid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'flags' field is at offset 8.  */
  flags = bfd_get_32 (abfd, (bfd_byte *) ddata + 8);

  /* nto_procfs_status 'what' field is at offset 14.  */
  if ((sig = bfd_get_16 (abfd, (bfd_byte *) ddata + 14)) > 0)
    {
      elf_tdata (abfd)->core->signal = sig;
      elf_tdata (abfd)->core->lwpid = *tid;
    }

  /* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores
     do not come from signals so we make sure we set the current
     thread just in case.  */
  if (flags & 0x00000080)
    elf_tdata (abfd)->core->lwpid = *tid;

  /* Make a ".qnx_core_status/%d" section.  */
  sprintf (buf, ".qnx_core_status/%ld", *tid);

  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

  sect->size            = note->descsz;
  sect->filepos         = note->descpos;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_regs (bfd *abfd,
		       Elf_Internal_Note *note,
		       long tid,
		       char *base)
{
  char buf[100];
  char *name;
  asection *sect;

  /* Make a "(base)/%d" section.  */
  sprintf (buf, "%s/%ld", base, tid);

  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

  sect->size            = note->descsz;
  sect->filepos         = note->descpos;
  sect->alignment_power = 2;

  /* This is the current thread.  */
  if (elf_tdata (abfd)->core->lwpid == tid)
    return elfcore_maybe_make_sect (abfd, base, sect);

  return TRUE;
}

#define BFD_QNT_CORE_INFO	7
#define BFD_QNT_CORE_STATUS	8
#define BFD_QNT_CORE_GREG	9
#define BFD_QNT_CORE_FPREG	10

static bfd_boolean
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
{
  /* Every GREG section has a STATUS section before it.  Store the
     tid from the previous call to pass down to the next gregs
     function.  */
  static long tid = 1;

  switch (note->type)
    {
    case BFD_QNT_CORE_INFO:
      return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS:
      return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:
      return elfcore_grok_nto_regs (abfd, note, tid, ".reg");
    case BFD_QNT_CORE_FPREG:
      return elfcore_grok_nto_regs (abfd, note, tid, ".reg2");
    default:
      return TRUE;
    }
}

static bfd_boolean
elfcore_grok_spu_note (bfd *abfd, Elf_Internal_Note *note)
{
  char *name;
  asection *sect;
  size_t len;

  /* Use note name as section name.  */
  len = note->namesz;
  name = (char *) bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, note->namedata, len);
  name[len - 1] = '\0';

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

  sect->size            = note->descsz;
  sect->filepos         = note->descpos;
  sect->alignment_power = 1;

  return TRUE;
}

/* Function: elfcore_write_note

   Inputs:
     buffer to hold note, and current size of buffer
     name of note
     type of note
     data for note
     size of data for note

   Writes note to end of buffer.  ELF64 notes are written exactly as
   for ELF32, despite the current (as of 2006) ELF gabi specifying
   that they ought to have 8-byte namesz and descsz field, and have
   8-byte alignment.  Other writers, eg. Linux kernel, do the same.

   Return:
   Pointer to realloc'd buffer, *BUFSIZ updated.  */

char *
elfcore_write_note (bfd *abfd,
		    char *buf,
		    int *bufsiz,
		    const char *name,
		    int type,
		    const void *input,
		    int size)
{
  Elf_External_Note *xnp;
  size_t namesz;
  size_t newspace;
  char *dest;

  namesz = 0;
  if (name != NULL)
    namesz = strlen (name) + 1;

  newspace = 12 + ((namesz + 3) & -4) + ((size + 3) & -4);

  buf = (char *) realloc (buf, *bufsiz + newspace);
  if (buf == NULL)
    return buf;
  dest = buf + *bufsiz;
  *bufsiz += newspace;
  xnp = (Elf_External_Note *) dest;
  H_PUT_32 (abfd, namesz, xnp->namesz);
  H_PUT_32 (abfd, size, xnp->descsz);
  H_PUT_32 (abfd, type, xnp->type);
  dest = xnp->name;
  if (name != NULL)
    {
      memcpy (dest, name, namesz);
      dest += namesz;
      while (namesz & 3)
	{
	  *dest++ = '\0';
	  ++namesz;
	}
    }
  memcpy (dest, input, size);
  dest += size;
  while (size & 3)
    {
      *dest++ = '\0';
      ++size;
    }
  return buf;
}

char *
elfcore_write_prpsinfo (bfd  *abfd,
			char *buf,
			int  *bufsiz,
			const char *fname,
			const char *psargs)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (bed->elf_backend_write_core_note != NULL)
    {
      char *ret;
      ret = (*bed->elf_backend_write_core_note) (abfd, buf, bufsiz,
						 NT_PRPSINFO, fname, psargs);
      if (ret != NULL)
	return ret;
    }

#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
#if defined (HAVE_PRPSINFO32_T) || defined (HAVE_PSINFO32_T)
  if (bed->s->elfclass == ELFCLASS32)
    {
#if defined (HAVE_PSINFO32_T)
      psinfo32_t data;
      int note_type = NT_PSINFO;
#else
      prpsinfo32_t data;
      int note_type = NT_PRPSINFO;
#endif

      memset (&data, 0, sizeof (data));
      strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
      strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
      return elfcore_write_note (abfd, buf, bufsiz,
				 "CORE", note_type, &data, sizeof (data));
    }
  else
#endif
    {
#if defined (HAVE_PSINFO_T)
      psinfo_t data;
      int note_type = NT_PSINFO;
#else
      prpsinfo_t data;
      int note_type = NT_PRPSINFO;
#endif

      memset (&data, 0, sizeof (data));
      strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
      strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
      return elfcore_write_note (abfd, buf, bufsiz,
				 "CORE", note_type, &data, sizeof (data));
    }
#endif	/* PSINFO_T or PRPSINFO_T */

  free (buf);
  return NULL;
}

char *
elfcore_write_linux_prpsinfo32
  (bfd *abfd, char *buf, int *bufsiz,
   const struct elf_internal_linux_prpsinfo *prpsinfo)
{
  struct elf_external_linux_prpsinfo32 data;

  memset (&data, 0, sizeof (data));
  LINUX_PRPSINFO32_SWAP_FIELDS (abfd, prpsinfo, data);

  return elfcore_write_note (abfd, buf, bufsiz, "CORE", NT_PRPSINFO,
			     &data, sizeof (data));
}

char *
elfcore_write_linux_prpsinfo64
  (bfd *abfd, char *buf, int *bufsiz,
   const struct elf_internal_linux_prpsinfo *prpsinfo)
{
  struct elf_external_linux_prpsinfo64 data;

  memset (&data, 0, sizeof (data));
  LINUX_PRPSINFO64_SWAP_FIELDS (abfd, prpsinfo, data);

  return elfcore_write_note (abfd, buf, bufsiz,
			     "CORE", NT_PRPSINFO, &data, sizeof (data));
}

char *
elfcore_write_prstatus (bfd *abfd,
			char *buf,
			int *bufsiz,
			long pid,
			int cursig,
			const void *gregs)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (bed->elf_backend_write_core_note != NULL)
    {
      char *ret;
      ret = (*bed->elf_backend_write_core_note) (abfd, buf, bufsiz,
						 NT_PRSTATUS,
						 pid, cursig, gregs);
      if (ret != NULL)
	return ret;
    }

#if defined (HAVE_PRSTATUS_T)
#if defined (HAVE_PRSTATUS32_T)
  if (bed->s->elfclass == ELFCLASS32)
    {
      prstatus32_t prstat;

      memset (&prstat, 0, sizeof (prstat));
      prstat.pr_pid = pid;
      prstat.pr_cursig = cursig;
      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
      return elfcore_write_note (abfd, buf, bufsiz, "CORE",
				 NT_PRSTATUS, &prstat, sizeof (prstat));
    }
  else
#endif
    {
      prstatus_t prstat;

      memset (&prstat, 0, sizeof (prstat));
      prstat.pr_pid = pid;
      prstat.pr_cursig = cursig;
      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
      return elfcore_write_note (abfd, buf, bufsiz, "CORE",
				 NT_PRSTATUS, &prstat, sizeof (prstat));
    }
#endif /* HAVE_PRSTATUS_T */

  free (buf);
  return NULL;
}

#if defined (HAVE_LWPSTATUS_T)
char *
elfcore_write_lwpstatus (bfd *abfd,
			 char *buf,
			 int *bufsiz,
			 long pid,
			 int cursig,
			 const void *gregs)
{
  lwpstatus_t lwpstat;
  const char *note_name = "CORE";

  memset (&lwpstat, 0, sizeof (lwpstat));
  lwpstat.pr_lwpid  = pid >> 16;
  lwpstat.pr_cursig = cursig;
#if defined (HAVE_LWPSTATUS_T_PR_REG)
  memcpy (lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
#elif defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
#if !defined(gregs)
  memcpy (lwpstat.pr_context.uc_mcontext.gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.gregs));
#else
  memcpy (lwpstat.pr_context.uc_mcontext.__gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.__gregs));
#endif
#endif
  return elfcore_write_note (abfd, buf, bufsiz, note_name,
			     NT_LWPSTATUS, &lwpstat, sizeof (lwpstat));
}
#endif /* HAVE_LWPSTATUS_T */

#if defined (HAVE_PSTATUS_T)
char *
elfcore_write_pstatus (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       long pid,
		       int cursig ATTRIBUTE_UNUSED,
		       const void *gregs ATTRIBUTE_UNUSED)
{
  const char *note_name = "CORE";
#if defined (HAVE_PSTATUS32_T)
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (bed->s->elfclass == ELFCLASS32)
    {
      pstatus32_t pstat;

      memset (&pstat, 0, sizeof (pstat));
      pstat.pr_pid = pid & 0xffff;
      buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
				NT_PSTATUS, &pstat, sizeof (pstat));
      return buf;
    }
  else
#endif
    {
      pstatus_t pstat;

      memset (&pstat, 0, sizeof (pstat));
      pstat.pr_pid = pid & 0xffff;
      buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
				NT_PSTATUS, &pstat, sizeof (pstat));
      return buf;
    }
}
#endif /* HAVE_PSTATUS_T */

char *
elfcore_write_prfpreg (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *fpregs,
		       int size)
{
  const char *note_name = "CORE";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_FPREGSET, fpregs, size);
}

char *
elfcore_write_prxfpreg (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *xfpregs,
			int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRXFPREG, xfpregs, size);
}

char *
elfcore_write_xstatereg (bfd *abfd, char *buf, int *bufsiz,
			 const void *xfpregs, int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_X86_XSTATE, xfpregs, size);
}

char *
elfcore_write_ppc_vmx (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *ppc_vmx,
		       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PPC_VMX, ppc_vmx, size);
}

char *
elfcore_write_ppc_vsx (bfd *abfd,
                       char *buf,
                       int *bufsiz,
                       const void *ppc_vsx,
                       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_PPC_VSX, ppc_vsx, size);
}

static char *
elfcore_write_s390_high_gprs (bfd *abfd,
			      char *buf,
			      int *bufsiz,
			      const void *s390_high_gprs,
			      int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_HIGH_GPRS,
			     s390_high_gprs, size);
}

char *
elfcore_write_s390_timer (bfd *abfd,
                          char *buf,
                          int *bufsiz,
                          const void *s390_timer,
                          int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_TIMER, s390_timer, size);
}

char *
elfcore_write_s390_todcmp (bfd *abfd,
                           char *buf,
                           int *bufsiz,
                           const void *s390_todcmp,
                           int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_TODCMP, s390_todcmp, size);
}

char *
elfcore_write_s390_todpreg (bfd *abfd,
                            char *buf,
                            int *bufsiz,
                            const void *s390_todpreg,
                            int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_TODPREG, s390_todpreg, size);
}

char *
elfcore_write_s390_ctrs (bfd *abfd,
                         char *buf,
                         int *bufsiz,
                         const void *s390_ctrs,
                         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_CTRS, s390_ctrs, size);
}

char *
elfcore_write_s390_prefix (bfd *abfd,
                           char *buf,
                           int *bufsiz,
                           const void *s390_prefix,
                           int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_PREFIX, s390_prefix, size);
}

char *
elfcore_write_s390_last_break (bfd *abfd,
			       char *buf,
			       int *bufsiz,
			       const void *s390_last_break,
			       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_LAST_BREAK,
			     s390_last_break, size);
}

char *
elfcore_write_s390_system_call (bfd *abfd,
				char *buf,
				int *bufsiz,
				const void *s390_system_call,
				int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_SYSTEM_CALL,
			     s390_system_call, size);
}

char *
elfcore_write_s390_tdb (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *s390_tdb,
			int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, NT_S390_TDB, s390_tdb, size);
}

char *
elfcore_write_arm_vfp (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *arm_vfp,
		       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_ARM_VFP, arm_vfp, size);
}

char *
elfcore_write_aarch_tls (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *aarch_tls,
		       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_ARM_TLS, aarch_tls, size);
}

char *
elfcore_write_aarch_hw_break (bfd *abfd,
			    char *buf,
			    int *bufsiz,
			    const void *aarch_hw_break,
			    int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_ARM_HW_BREAK, aarch_hw_break, size);
}

char *
elfcore_write_aarch_hw_watch (bfd *abfd,
			    char *buf,
			    int *bufsiz,
			    const void *aarch_hw_watch,
			    int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_ARM_HW_WATCH, aarch_hw_watch, size);
}

char *
elfcore_write_register_note (bfd *abfd,
			     char *buf,
			     int *bufsiz,
			     const char *section,
			     const void *data,
			     int size)
{
  if (strcmp (section, ".reg2") == 0)
    return elfcore_write_prfpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-xfp") == 0)
    return elfcore_write_prxfpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-xstate") == 0)
    return elfcore_write_xstatereg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-ppc-vmx") == 0)
    return elfcore_write_ppc_vmx (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-ppc-vsx") == 0)
    return elfcore_write_ppc_vsx (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-high-gprs") == 0)
    return elfcore_write_s390_high_gprs (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-timer") == 0)
    return elfcore_write_s390_timer (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-todcmp") == 0)
    return elfcore_write_s390_todcmp (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-todpreg") == 0)
    return elfcore_write_s390_todpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-ctrs") == 0)
    return elfcore_write_s390_ctrs (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-prefix") == 0)
    return elfcore_write_s390_prefix (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-last-break") == 0)
    return elfcore_write_s390_last_break (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-system-call") == 0)
    return elfcore_write_s390_system_call (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-tdb") == 0)
    return elfcore_write_s390_tdb (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-arm-vfp") == 0)
    return elfcore_write_arm_vfp (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-tls") == 0)
    return elfcore_write_aarch_tls (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-hw-break") == 0)
    return elfcore_write_aarch_hw_break (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-hw-watch") == 0)
    return elfcore_write_aarch_hw_watch (abfd, buf, bufsiz, data, size);
  return NULL;
}

static bfd_boolean
elf_parse_notes (bfd *abfd, char *buf, size_t size, file_ptr offset)
{
  char *p;

  p = buf;
  while (p < buf + size)
    {
      /* FIXME: bad alignment assumption.  */
      Elf_External_Note *xnp = (Elf_External_Note *) p;
      Elf_Internal_Note in;

      if (offsetof (Elf_External_Note, name) > buf - p + size)
	return FALSE;

      in.type = H_GET_32 (abfd, xnp->type);

      in.namesz = H_GET_32 (abfd, xnp->namesz);
      in.namedata = xnp->name;
      if (in.namesz > buf - in.namedata + size)
	return FALSE;

      in.descsz = H_GET_32 (abfd, xnp->descsz);
      in.descdata = in.namedata + BFD_ALIGN (in.namesz, 4);
      in.descpos = offset + (in.descdata - buf);
      if (in.descsz != 0
	  && (in.descdata >= buf + size
	      || in.descsz > buf - in.descdata + size))
	return FALSE;

      switch (bfd_get_format (abfd))
        {
	default:
	  return TRUE;

	case bfd_core:
	  if (CONST_STRNEQ (in.namedata, "NetBSD-CORE"))
	    {
	      if (! elfcore_grok_netbsd_note (abfd, &in))
		return FALSE;
	    }
	  else if (CONST_STRNEQ (in.namedata, "OpenBSD"))
	    {
	      if (! elfcore_grok_openbsd_note (abfd, &in))
		return FALSE;
	    }
	  else if (CONST_STRNEQ (in.namedata, "QNX"))
	    {
	      if (! elfcore_grok_nto_note (abfd, &in))
		return FALSE;
	    }
	  else if (CONST_STRNEQ (in.namedata, "SPU/"))
	    {
	      if (! elfcore_grok_spu_note (abfd, &in))
		return FALSE;
	    }
	  else
	    {
	      if (! elfcore_grok_note (abfd, &in))
		return FALSE;
	    }
	  break;

	case bfd_object:
	  if (in.namesz == sizeof "GNU" && strcmp (in.namedata, "GNU") == 0)
	    {
	      if (! elfobj_grok_gnu_note (abfd, &in))
		return FALSE;
	    }
	  else if (in.namesz == sizeof "stapsdt"
		   && strcmp (in.namedata, "stapsdt") == 0)
	    {
	      if (! elfobj_grok_stapsdt_note (abfd, &in))
		return FALSE;
	    }
	  break;
	}

      p = in.descdata + BFD_ALIGN (in.descsz, 4);
    }

  return TRUE;
}

static bfd_boolean
elf_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
{
  char *buf;

  if (size <= 0)
    return TRUE;

  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;

  buf = (char *) bfd_malloc (size);
  if (buf == NULL)
    return FALSE;

  if (bfd_bread (buf, size, abfd) != size
      || !elf_parse_notes (abfd, buf, size, offset))
    {
      free (buf);
      return FALSE;
    }

  free (buf);
  return TRUE;
}

/* Providing external access to the ELF program header table.  */

/* Return an upper bound on the number of bytes required to store a
   copy of ABFD's program header table entries.  Return -1 if an error
   occurs; bfd_get_error will return an appropriate code.  */

long
bfd_get_elf_phdr_upper_bound (bfd *abfd)
{
  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return elf_elfheader (abfd)->e_phnum * sizeof (Elf_Internal_Phdr);
}

/* Copy ABFD's program header table entries to *PHDRS.  The entries
   will be stored as an array of Elf_Internal_Phdr structures, as
   defined in include/elf/internal.h.  To find out how large the
   buffer needs to be, call bfd_get_elf_phdr_upper_bound.

   Return the number of program header table entries read, or -1 if an
   error occurs; bfd_get_error will return an appropriate code.  */

int
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
{
  int num_phdrs;

  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  num_phdrs = elf_elfheader (abfd)->e_phnum;
  memcpy (phdrs, elf_tdata (abfd)->phdr,
	  num_phdrs * sizeof (Elf_Internal_Phdr));

  return num_phdrs;
}

enum elf_reloc_type_class
_bfd_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   const asection *rel_sec ATTRIBUTE_UNUSED,
			   const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
{
  return reloc_class_normal;
}

/* For RELA architectures, return the relocation value for a
   relocation against a local symbol.  */

bfd_vma
_bfd_elf_rela_local_sym (bfd *abfd,
			 Elf_Internal_Sym *sym,
			 asection **psec,
			 Elf_Internal_Rela *rel)
{
  asection *sec = *psec;
  bfd_vma relocation;

  relocation = (sec->output_section->vma
		+ sec->output_offset
		+ sym->st_value);
  if ((sec->flags & SEC_MERGE)
      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
    {
      rel->r_addend =
	_bfd_merged_section_offset (abfd, psec,
				    elf_section_data (sec)->sec_info,
				    sym->st_value + rel->r_addend);
      if (sec != *psec)
	{
	  /* If we have changed the section, and our original section is
	     marked with SEC_EXCLUDE, it means that the original
	     SEC_MERGE section has been completely subsumed in some
	     other SEC_MERGE section.  In this case, we need to leave
	     some info around for --emit-relocs.  */
	  if ((sec->flags & SEC_EXCLUDE) != 0)
	    sec->kept_section = *psec;
	  sec = *psec;
	}
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
    }
  return relocation;
}

bfd_vma
_bfd_elf_rel_local_sym (bfd *abfd,
			Elf_Internal_Sym *sym,
			asection **psec,
			bfd_vma addend)
{
  asection *sec = *psec;

  if (sec->sec_info_type != SEC_INFO_TYPE_MERGE)
    return sym->st_value + addend;

  return _bfd_merged_section_offset (abfd, psec,
				     elf_section_data (sec)->sec_info,
				     sym->st_value + addend);
}

bfd_vma
_bfd_elf_section_offset (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 bfd_vma offset)
{
  switch (sec->sec_info_type)
    {
    case SEC_INFO_TYPE_STABS:
      return _bfd_stab_section_offset (sec, elf_section_data (sec)->sec_info,
				       offset);
    case SEC_INFO_TYPE_EH_FRAME:
      return _bfd_elf_eh_frame_section_offset (abfd, info, sec, offset);
    default:
      if ((sec->flags & SEC_ELF_REVERSE_COPY) != 0)
	{
	  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
	  bfd_size_type address_size = bed->s->arch_size / 8;
	  offset = sec->size - offset - address_size;
	}
      return offset;
    }
}

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */

bfd *
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type))
{
  return (*get_elf_backend_data (templ)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, loadbasep, target_read_memory);
}

long
_bfd_elf_get_synthetic_symtab (bfd *abfd,
			       long symcount ATTRIBUTE_UNUSED,
			       asymbol **syms ATTRIBUTE_UNUSED,
			       long dynsymcount,
			       asymbol **dynsyms,
			       asymbol **ret)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  asection *relplt;
  asymbol *s;
  const char *relplt_name;
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  arelent *p;
  long count, i, n;
  size_t size;
  Elf_Internal_Shdr *hdr;
  char *names;
  asection *plt;

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  if (!bed->plt_sym_val)
    return 0;

  relplt_name = bed->relplt_name;
  if (relplt_name == NULL)
    relplt_name = bed->rela_plts_and_copies_p ? ".rela.plt" : ".rel.plt";
  relplt = bfd_get_section_by_name (abfd, relplt_name);
  if (relplt == NULL)
    return 0;

  hdr = &elf_section_data (relplt)->this_hdr;
  if (hdr->sh_link != elf_dynsymtab (abfd)
      || (hdr->sh_type != SHT_REL && hdr->sh_type != SHT_RELA))
    return 0;

  plt = bfd_get_section_by_name (abfd, ".plt");
  if (plt == NULL)
    return 0;

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
    return -1;

  count = relplt->size / hdr->sh_entsize;
  size = count * sizeof (asymbol);
  p = relplt->relocation;
  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)
    {
      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
      if (p->addend != 0)
	{
#ifdef BFD64
	  size += sizeof ("+0x") - 1 + 8 + 8 * (bed->s->elfclass == ELFCLASS64);
#else
	  size += sizeof ("+0x") - 1 + 8;
#endif
	}
    }

  s = *ret = (asymbol *) bfd_malloc (size);
  if (s == NULL)
    return -1;

  names = (char *) (s + count);
  p = relplt->relocation;
  n = 0;
  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)
    {
      size_t len;
      bfd_vma addr;

      addr = bed->plt_sym_val (i, plt, p);
      if (addr == (bfd_vma) -1)
	continue;

      *s = **p->sym_ptr_ptr;
      /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since
	 we are defining a symbol, ensure one of them is set.  */
      if ((s->flags & BSF_LOCAL) == 0)
	s->flags |= BSF_GLOBAL;
      s->flags |= BSF_SYNTHETIC;
      s->section = plt;
      s->value = addr - plt->vma;
      s->name = names;
      s->udata.p = NULL;
      len = strlen ((*p->sym_ptr_ptr)->name);
      memcpy (names, (*p->sym_ptr_ptr)->name, len);
      names += len;
      if (p->addend != 0)
	{
	  char buf[30], *a;

	  memcpy (names, "+0x", sizeof ("+0x") - 1);
	  names += sizeof ("+0x") - 1;
	  bfd_sprintf_vma (abfd, buf, p->addend);
	  for (a = buf; *a == '0'; ++a)
	    ;
	  len = strlen (a);
	  memcpy (names, a, len);
	  names += len;
	}
      memcpy (names, "@@plt", sizeof ("@@plt"));
      names += sizeof ("@@plt");
      ++s, ++n;
    }

  return n;
}

/* It is only used by x86-64 so far.  */
asection _bfd_elf_large_com_section
  = BFD_FAKE_SECTION (_bfd_elf_large_com_section,
		      SEC_IS_COMMON, NULL, "LARGE_COMMON", 0);

void
_bfd_elf_set_osabi (bfd * abfd,
		    struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI] = get_elf_backend_data (abfd)->elf_osabi;

  /* To make things simpler for the loader on Linux systems we set the
     osabi field to ELFOSABI_GNU if the binary contains symbols of
     the STT_GNU_IFUNC type or STB_GNU_UNIQUE binding.  */
  if (i_ehdrp->e_ident[EI_OSABI] == ELFOSABI_NONE
      && elf_tdata (abfd)->has_gnu_symbols)
    i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_GNU;
}


/* Return TRUE for ELF symbol types that represent functions.
   This is the default version of this function, which is sufficient for
   most targets.  It returns true if TYPE is STT_FUNC or STT_GNU_IFUNC.  */

bfd_boolean
_bfd_elf_is_function_type (unsigned int type)
{
  return (type == STT_FUNC
	  || type == STT_GNU_IFUNC);
}

/* If the ELF symbol SYM might be a function in SEC, return the
   function size and set *CODE_OFF to the function's entry point,
   otherwise return zero.  */

bfd_size_type
_bfd_elf_maybe_function_sym (const asymbol *sym, asection *sec,
			     bfd_vma *code_off)
{
  bfd_size_type size;

  if ((sym->flags & (BSF_SECTION_SYM | BSF_FILE | BSF_OBJECT
		     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC)) != 0
      || sym->section != sec)
    return 0;

  *code_off = sym->value;
  size = 0;
  if (!(sym->flags & BSF_SYNTHETIC))
    size = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
  if (size == 0)
    size = 1;
  return size;
}
@


1.591
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@a6228 2
		  if (section->lma < lowest_section->lma)
		    lowest_section = section;
d6233 3
@


1.591.2.1
log
@	PR 16056
	* elf.c (copy_elf_program_header): Only consider SEC_ALLOC sections
	when finding lowest_section.
@
text
@d6229 2
a6234 3
		      if (section->lma < lowest_section->lma)
			lowest_section = section;

@


1.590
log
@	* elf-bfd.h (struct elf_backend_data <merge_symbol>): Update proto.
	(_bfd_elf_init_reloc_shdr): Delete.
	* elf.c (_bfd_elf_init_reloc_shdr): Make static.
	* elf64-x86-64.c (elf_x86_64_merge_symbol): Trim parameters to
	just what is needed.
	* elflink.c (_bfd_elf_merge_symbol): Update bed->merge_symbol call.
@
text
@d9759 3
a9761 1
_bfd_elf_reloc_type_class (const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
@


1.589
log
@	* elf-bfd.h (elfcore_write_s390_tdb): Add prototype.
	* elf.c (elfcore_write_s390_tdb): New function.
	(elfcore_write_register_note): Call it.
	(elfcore_grok_s390_tdb): New function.
	(elfcore_grok_note): Call it.

	* readelf.c (get_note_type): Add NT_S390_TDB.
@
text
@d2524 1
a2524 1
bfd_boolean
@


1.588
log
@bfd/
	* elf-bfd.h (struct elf_build_id): Extracted from..
	(struct elf_build_id_info): ..here.  Delete.
	(struct output_elf_obj_tdata): New, extracted from..
	(struct elf_obj_tdata): ..here.  Reorganize for better packing.
	Add "o" field.
	(elf_program_header_size): Reference tdata->o.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_shstrtab, elf_strtab_sec, elf_shstrtab_sec,
	elf_section_syms, elf_num_section_syms, elf_flags_init): Likewise.
	* elf.c (bfd_elf_allocate_object): Allocate output_elf_obj_tdata
	when opening bfd in any mode that might write.
	(_bfd_elf_write_object_contents): Use build_id field in
	output_elf_obj_tdata.
	(_bfd_elf_close_and_cleanup): Tweak elf_shstrtab test.
	(elfobj_grok_gnu_build_id): Adjust for elf_tdata changes.
gdb/
	* elfread.c (build_id_bfd_get): Adjust for elf_tdata changes.
ld/
	* emultempl/elf32.em (write_build_id, setup_build_id): Adjust
	for elf_tdata changes.
@
text
@d3 1
a3 4
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
   2013
   Free Software Foundation, Inc.
d8175 6
d8637 7
d9498 12
d9591 2
@


1.587
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d249 8
a256 1
  elf_program_header_size (abfd) = (bfd_size_type) -1;
d5343 2
a5344 3
  if (t->build_id != NULL
      && t->build_id->u.o.zero == 0)
    return (*t->build_id->u.o.after_write_object_contents) (abfd);
d7883 1
a7883 1
      if (elf_shstrtab (abfd) != NULL)
d8706 1
a8706 1
  t->build_id = bfd_alloc (abfd, sizeof (t->build_id->u.i) - 1 + note->descsz);
d8710 2
a8711 2
  t->build_id->u.i.size = note->descsz;
  memcpy (t->build_id->u.i.data, note->descdata, note->descsz);
@


1.586
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@d266 4
a269 1
  return abfd->xvec->_bfd_set_format[(int) bfd_object] (abfd);
d7919 1
a7919 1
  pid = elf_tdata (abfd)->core_lwpid;
d7921 1
a7921 1
    pid = elf_tdata (abfd)->core_pid;
d8011 4
a8014 4
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      if (elf_tdata (abfd)->core_pid == 0)
	elf_tdata (abfd)->core_pid = prstat.pr_pid;
d8023 1
a8023 1
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
d8025 1
a8025 1
      elf_tdata (abfd)->core_lwpid = prstat.pr_pid;
d8040 4
a8043 4
      if (elf_tdata (abfd)->core_signal == 0)
	elf_tdata (abfd)->core_signal = prstat.pr_cursig;
      if (elf_tdata (abfd)->core_pid == 0)
	elf_tdata (abfd)->core_pid = prstat.pr_pid;
d8052 1
a8052 1
      elf_tdata (abfd)->core_lwpid = prstat.pr_who;
d8054 1
a8054 1
      elf_tdata (abfd)->core_lwpid = prstat.pr_pid;
d8246 1
a8246 1
      elf_tdata (abfd)->core_pid = psinfo.pr_pid;
d8248 1
a8248 1
      elf_tdata (abfd)->core_program
d8252 1
a8252 1
      elf_tdata (abfd)->core_command
d8265 1
a8265 1
      elf_tdata (abfd)->core_pid = psinfo.pr_pid;
d8267 1
a8267 1
      elf_tdata (abfd)->core_program
d8271 1
a8271 1
      elf_tdata (abfd)->core_command
d8289 1
a8289 1
    char *command = elf_tdata (abfd)->core_command;
d8314 1
a8314 1
      elf_tdata (abfd)->core_pid = pstat.pr_pid;
d8324 1
a8324 1
      elf_tdata (abfd)->core_pid = pstat.pr_pid;
d8354 1
a8354 1
  elf_tdata (abfd)->core_lwpid = lwpstat.pr_lwpid;
d8357 2
a8358 2
  if (elf_tdata (abfd)->core_signal == 0)
    elf_tdata (abfd)->core_signal = lwpstat.pr_cursig;
d8441 1
a8441 1
      /* FIXME: need to add ->core_command.  */
d8443 1
a8443 1
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 8);
d8445 1
a8445 1
      elf_tdata (abfd)->core_signal = bfd_get_32 (abfd, note->descdata + 12);
d8770 1
a8770 1
  elf_tdata (abfd)->core_signal
d8774 1
a8774 1
  elf_tdata (abfd)->core_pid
d8778 1
a8778 1
  elf_tdata (abfd)->core_command
d8791 1
a8791 1
    elf_tdata (abfd)->core_lwpid = lwp;
d8854 1
a8854 1
  elf_tdata (abfd)->core_signal
d8858 1
a8858 1
  elf_tdata (abfd)->core_pid
d8862 1
a8862 1
  elf_tdata (abfd)->core_command
d8925 1
a8925 1
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, (bfd_byte *) ddata);
d8936 2
a8937 2
      elf_tdata (abfd)->core_signal = sig;
      elf_tdata (abfd)->core_lwpid = *tid;
d8944 1
a8944 1
    elf_tdata (abfd)->core_lwpid = *tid;
d8992 1
a8992 1
  if (elf_tdata (abfd)->core_lwpid == tid)
@


1.585
log
@include/
	* bfdlink.h (struct bfd_link_info): Delete emit_note_gnu_build_id.
bfd/
	* configure.in: Bump version to 2.23.52.
	* elf-bfd.h (struct elf_build_id_info): New.
	(struct elf_obj_tdata): Delete after_write_object_contents,
	after_write_object_contents_info and build_id_size.  Make build_id
	a pointer to struct elf_build_id_info.
	* elf.c (_bfd_elf_write_object_contents): Style.  Update
	after_write_ibject_contents invocation.
	(elfobj_grok_gnu_build_id): Update for new build_id struct.  Don't
	allow zero size notes.
	* configure: Regenerate.
gdb/
	* elfread.c (struct build_id): Delete.  Use struct elf_build_id
	throughout file instead.
	(build_id_bfd_get): Update to use new elf_tdata build_id field.
	Don't xmalloc return value.
	(build_id_verify): Similarly.  Don't xfree.
	(build_id_to_debug_filename): Update.
	(find_separate_debug_file_by_buildid): Update, don't xfree.
ld/
	* emultempl/elf32.em (emit_note_gnu_build_id): New static var.
	Replace all info->emit_note_gnu_build_id refs.
	(id_note_section_size): Rename from
	gld${EMULATION_NAME}_id_note_section_size.
	(struct build_id_info): Delete.
	(write_build_id): Rename from
	gld${EMULATION_NAME}_write_build_id_section.
	Update elf_tdata usage.  Style, formatting.
	(setup_build_id): New function.
	(gld${EMULATION_NAME}_after_open): Use setup_build_id.
@
text
@d1439 3
a1441 3
	if (elf_tdata (abfd)->dynversym_section != 0
	    && (elf_tdata (abfd)->dynverdef_section != 0
		|| elf_tdata (abfd)->dynverref_section != 0))
d2977 1
a2977 1
  t->shstrtab_section = section_number++;
d2979 1
a2979 1
  elf_elfheader (abfd)->e_shstrndx = t->shstrtab_section;
d2987 1
a2987 1
      t->symtab_section = section_number++;
d2991 1
a2991 1
	  t->symtab_shndx_section = section_number++;
d2998 1
a2998 1
      t->strtab_section = section_number++;
d3032 1
a3032 1
  i_shdrp[t->shstrtab_section] = &t->shstrtab_hdr;
d3035 1
a3035 1
      i_shdrp[t->symtab_section] = &t->symtab_hdr;
d3038 2
a3039 2
	  i_shdrp[t->symtab_shndx_section] = &t->symtab_shndx_hdr;
	  t->symtab_shndx_hdr.sh_link = t->symtab_section;
d3041 2
a3042 2
      i_shdrp[t->strtab_section] = &t->strtab_hdr;
      t->symtab_hdr.sh_link = t->strtab_section;
d3065 1
a3065 1
	  d->rel.hdr->sh_link = t->symtab_section;
d3070 1
a3070 1
	  d->rela.hdr->sh_link = t->symtab_section;
d3225 1
a3225 1
	  d->this_hdr.sh_link = t->symtab_section;
d3276 1
a3276 1
elf_map_symbols (bfd *abfd)
d3392 1
a3392 2
  elf_num_locals (abfd) = num_locals;
  elf_num_globals (abfd) = num_globals;
d3503 1
a3503 1
      off = elf_tdata (abfd)->next_file_pos;
d3515 1
a3515 1
      elf_tdata (abfd)->next_file_pos = off;
d3566 1
a3566 1
  if (elf_tdata (abfd)->eh_frame_hdr)
d3572 1
a3572 1
  if (elf_tdata (abfd)->stack_flags)
d3634 1
a3634 2
  for (m = elf_tdata (abfd)->segment_map,
	 p = elf_tdata (abfd)->phdr;
d3718 1
a3718 1
  m = &elf_tdata (abfd)->segment_map;
d3762 1
a3762 1
  no_user_phdrs = elf_tdata (abfd)->segment_map == NULL;
d3873 1
a3873 1
	  bfd_size_type phdr_size = elf_tdata (abfd)->program_header_size;
d4118 1
a4118 1
      eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
d4135 1
a4135 1
      if (elf_tdata (abfd)->stack_flags)
d4143 1
a4143 1
	  m->p_flags = elf_tdata (abfd)->stack_flags;
d4199 1
a4199 1
      elf_tdata (abfd)->segment_map = mfirst;
d4205 1
a4205 1
  for (count = 0, m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d4207 1
a4207 1
  elf_tdata (abfd)->program_header_size = count * bed->s->sizeof_phdr;
d4371 1
a4371 1
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d4392 2
a4393 2
  if (elf_tdata (abfd)->program_header_size == (bfd_size_type) -1)
    elf_tdata (abfd)->program_header_size = alloc * bed->s->sizeof_phdr;
d4395 1
a4395 1
    BFD_ASSERT (elf_tdata (abfd)->program_header_size
d4400 1
a4400 1
      elf_tdata (abfd)->next_file_pos = bed->s->sizeof_ehdr;
d4404 1
a4404 1
  /* We're writing the size in elf_tdata (abfd)->program_header_size,
d4407 2
a4408 2
     The variable alloc contains the computed need, while elf_tdata
     (abfd)->program_header_size contains the size used for the
d4413 1
a4413 1
  BFD_ASSERT (elf_tdata (abfd)->program_header_size % bed->s->sizeof_phdr
d4417 1
a4417 1
                  (elf_tdata (abfd)->program_header_size / bed->s->sizeof_phdr),
d4435 1
a4435 1
  for (m = elf_tdata (abfd)->segment_map, p = phdrs, j = 0;
d4816 1
a4816 1
  elf_tdata (abfd)->next_file_pos = off;
d4842 1
a4842 1
  off = elf_tdata (abfd)->next_file_pos;
a4844 1
      struct elf_obj_tdata *tdata = elf_tdata (abfd);
d4874 3
a4876 3
	       || hdr == i_shdrpp[tdata->symtab_section]
	       || hdr == i_shdrpp[tdata->symtab_shndx_section]
	       || hdr == i_shdrpp[tdata->strtab_section])
d4891 1
a4891 3
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
d4937 1
a4937 1
	    for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d4961 1
a4961 3
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
       m != NULL;
       m = m->next, p++)
d4972 1
a4972 1
	      for (lm = elf_tdata (abfd)->segment_map, lp = phdrs;
d5070 1
a5070 1
  elf_tdata (abfd)->next_file_pos = off;
d5119 3
a5121 3
	      || i == tdata->symtab_section
	      || i == tdata->symtab_shndx_section
	      || i == tdata->strtab_section)
d5149 1
a5149 1
      alloc = tdata->program_header_size / bed->s->sizeof_phdr;
d5154 1
a5154 1
      off = tdata->next_file_pos;
d5162 1
a5162 1
  tdata->next_file_pos = off;
d5265 1
a5265 1
  off = elf_tdata (abfd)->next_file_pos;
d5278 1
a5278 1
  elf_tdata (abfd)->next_file_pos = off;
d5327 1
a5327 1
    (*bed->elf_backend_final_write_processing) (abfd, t->linker);
d6069 1
a6069 1
  elf_tdata (obfd)->segment_map = map_first;
d6263 1
a6263 1
  elf_tdata (obfd)->segment_map = map_first;
d6554 1
a6554 1
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
d6602 1
a6602 1
      else if (shndx == elf_tdata (ibfd)->strtab_section)
d6604 1
a6604 1
      else if (shndx == elf_tdata (ibfd)->shstrtab_section)
d6606 1
a6606 1
      else if (shndx == elf_tdata (ibfd)->symtab_shndx_section)
d6631 1
d6635 1
a6635 1
  if (!elf_map_symbols (abfd))
d6649 1
a6649 1
  symtab_hdr->sh_info = elf_num_locals (abfd) + 1;
d6783 1
a6783 1
		  shndx = elf_tdata (abfd)->strtab_section;
d6786 1
a6786 1
		  shndx = elf_tdata (abfd)->shstrtab_section;
d6789 1
a6789 1
		  shndx = elf_tdata (abfd)->symtab_shndx_section;
d7720 1
a7720 1
      bfd_size_type phdr_size = elf_tdata (abfd)->program_header_size;
d7727 1
a7727 1
	  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d7734 1
a7734 1
      elf_tdata (abfd)->program_header_size = phdr_size;
@


1.584
log
@	PR binutils/15106
	* elf-bfd.h (struct elf_obj_tdata): Add elf_find_function_cache.
	* elf.c (elf_find_function): Revert last change.  Use new
	tdata field rather than static vars for cache.
@
text
@d5295 1
d5327 1
d5329 1
a5329 1
      && (bfd_seek (abfd, elf_tdata (abfd)->shstrtab_hdr.sh_offset, SEEK_SET) != 0
d5334 1
a5334 2
    (*bed->elf_backend_final_write_processing) (abfd,
						elf_tdata (abfd)->linker);
d5340 3
a5342 2
  if (elf_tdata (abfd)->after_write_object_contents)
    return (*elf_tdata (abfd)->after_write_object_contents) (abfd);
d8697 8
a8704 3
  elf_tdata (abfd)->build_id_size = note->descsz;
  elf_tdata (abfd)->build_id = (bfd_byte *) bfd_alloc (abfd, note->descsz);
  if (elf_tdata (abfd)->build_id == NULL)
d8707 2
a8708 1
  memcpy (elf_tdata (abfd)->build_id, note->descdata, note->descsz);
@


1.583
log
@	PR binutils/15106
	* elf.c (elf_find_function): Don't cache if symbols change.
@
text
@d7507 7
a7513 5
  static asection *last_section;
  static asymbol **last_symbols;
  static asymbol *func;
  static const char *filename;
  static bfd_size_type func_size;
d7518 12
a7529 5
  if (last_section != section
      || last_symbols != symbols
      || func == NULL
      || offset < func->value
      || offset >= func->value + func_size)
a7544 2
      filename = NULL;
      func = NULL;
d7548 4
a7551 3
      func_size = 0;
      last_section = section;
      last_symbols = symbols;
d7572 1
a7572 1
		      && size > func_size)))
d7574 3
a7576 2
	      func = sym;
	      func_size = size;
a7577 1
	      filename = NULL;
d7581 1
a7581 1
		filename = bfd_asymbol_name (file);
d7588 1
a7588 1
  if (func == NULL)
d7592 1
a7592 1
    *filename_ptr = filename;
d7594 1
a7594 1
    *functionname_ptr = bfd_asymbol_name (func);
@


1.582
log
@2013-02-04  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* Makefile.in (SOURCE_HFILES): Add `elf-linux-psinfo.h'.
	* elf-bfd.h (elf_internal_linux_prpsinfo): New structure
	declaration.
	(elfcore_write_linux_prpsinfo32, elfcore_write_linux_prpsinfo64)
	(elfcore_write_ppc32_linux_prpsinfo32): New declarations.
	* elf-linux-psinfo.h: New file.
	* elf.c: Include elf-linux-psinfo.h.
	(elfcore_write_linux_prpsinfo32, elfcore_write_linux_prpsinfo64):
	New functions.
	* elf32-ppc.c: Include `elf-linux-psinfo.h'.
	(elf_external_ppc_linux_prpsinfo32): New structure declaration.
	(PPC_LINUX_PRPSINFO32_SWAP_FIELDS): New macro.
	(elfcore_write_ppc_linux_prpsinfo32): New function.
@
text
@d7508 1
d7517 1
d7543 1
@


1.581
log
@include/elf/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* common.h (NT_ARM_TLS, NT_ARM_HW_BREAK, NT_ARM_HW_WATCH): New macro
	definitions.

bfd/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* elf-bfd.h (elfcore_write_aarch_tls): Add prototype.
	(elfcore_write_aarch_hw_break): Likewise.
	(elfcore_write_aarch_hw_watch): Likewise.
	* elf.c (elfcore_grok_aarch_tls): New function.
	(elfcore_grok_aarch_hw_break): Likewise.
	(elfcore_grok_aarch_hw_watch): Likewise.
	(elfcore_grok_note): Call the new functions to handle the
	corresponding notes.
	(elfcore_write_aarch_tls): New function.
	(elfcore_write_aarch_hw_break): Likewise.
	(elfcore_write_aarch_hw_watch): Likewise.
	(elfcore_write_register_note): Call the new functions to handle the
	corresponding pseudo sections.

binutils/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* readelf.c (get_note_type): Handle NT_ARM_TLS, NT_ARM_HW_BREAK
	and NT_ARM_HW_WATCH.
@
text
@d48 1
d9163 28
@


1.580
log
@	* elf.c (swap_out_syms): Set shndx to SHN_ABS when not one of
	the special MAP_* values.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d8166 18
d8624 21
d9449 36
d9520 6
@


1.579
log
@gdb
        * NEWS: Mention "info proc" and core files.
        * corelow.c (core_info_proc): New function.
        (init_core_ops): Set to_info_proc.
        * gdbarch.c, gdbarch.h: Rebuild.
        * gdbarch.sh (core_info_proc): New method.
        * infcmd.c (info_proc_cmd_1): Invoke target_info_proc first.
        * linux-tdep.c (linux_core_info_proc_mappings)
        (linux_core_info_proc): New functions.
        (linux_find_memory_region_ftype): New typedef.
        (linux_find_memory_regions_full): New function, from
        linux_find_memory_regions.
        (struct linux_find_memory_regions_data): New.
        (linux_find_memory_regions_thunk): New function.
        (linux_find_memory_regions): Rewrite.
        (struct linux_make_mappings_data): New.
        (linux_make_mappings_callback)
        (linux_make_mappings_corefile_notes): New functions.
        (linux_make_corefile_notes): Call linux_make_mappings_corefile_notes.
        (linux_init_abi): Call set_gdbarch_core_info_proc.
        * target.c (target_info_proc): Return 'int'.
        * target.h (target_info_proc): Update.
gdb/doc
        * gdb.texinfo (SVR4 Process Information): Mention core files.
gdb/testsuite
        * gdb.base/info-proc.exp: Add core file tests.
bfd
        * elf.c (elfcore_grok_note) <NT_FILE>: New case.
@
text
@d6794 1
@


1.578
log
@	PR ld/14926
	* elf.c (_bfd_elf_map_sections_to_segments): Include elf header
	size when determining phdr_in_segment.
@
text
@d8629 4
@


1.577
log
@Set output maxpagesize when rewriting program header

bfd/

	PR binutils/14493
	* elf.c (copy_elf_program_header): When rewriting program
	header, set the output maxpagesize to the maximum alignment
	of input PT_LOAD segments.

2012-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/14493
	* ld-elf/maxpage5.d: New file.
	* ld-elf/maxpage5.s: Likewise.
	* ld-elf/maxpage5.t: Likewise.
@
text
@d3877 1
@


1.576
log
@Allocate elf_segment_map with bfd_zalloc

	* elf.c (rewrite_elf_program_header): Allocate elf_segment_map
	with bfd_zalloc, instead of bfd_alloc.
@
text
@d6359 20
@


1.575
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d6046 1
a6046 1
	      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
@


1.574
log
@gdb
	* linux-tdep.c (linux_make_siginfo_note): New function.
	(linux_make_corefile_notes): Use it.
	* corelow.c (get_core_siginfo): New function.
	(core_xfer_partial) <TARGET_OBJECT_SIGNAL_INFO>: New case.
gdb/testsuite
	* gdb.base/siginfo-obj.exp: Create core file.  Test siginfo from
	core files, if possible.
	* gdb.base/siginfo-thread.c: New file
	* gdb.base/siginfo-thread.exp: New file
bfd
	* elf.c (elfcore_grok_note) <NT_SIGINFO>: New case; make
	pseudosection.
@
text
@d7365 1
a7365 1
      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];;
@


1.573
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d8607 4
@


1.572
log
@	* elf.c (special_sections_d): Add comment.
@
text
@d4143 1
d4145 6
d5032 5
d6181 2
a6182 1
      if (map->p_type == PT_GNU_RELRO)
d6187 3
a6189 1
	     change the size of the PT_GNU_RELRO segment.  */
@


1.571
log
@	PR binutils/14662
	* elf.c (_bfd_elf_make_section_from_shdr): Treat .gdb_index as
	SEC_DEBUGGING.
@
text
@d2064 3
@


1.570
log
@Ignore section symbols without a BFD section

bfd/

	PR binutils/14493
	* elf.c (ignore_section_sym): Also ignore section symbols without
	a BFD section.

binutils/

	PR binutils/14493
	* readelf.c (get_symbol_index_type): Check bad section index.
@
text
@a882 31
      static const struct
	{
	  const char *name;
	  int len;
	} debug_sections [] =
	{
	  { STRING_COMMA_LEN ("debug") },	/* 'd' */
	  { NULL,		 0  },	/* 'e' */
	  { NULL,		 0  },	/* 'f' */
	  { STRING_COMMA_LEN ("gnu.linkonce.wi.") },	/* 'g' */
	  { NULL,		 0  },	/* 'h' */
	  { NULL,		 0  },	/* 'i' */
	  { NULL,		 0  },	/* 'j' */
	  { NULL,		 0  },	/* 'k' */
	  { STRING_COMMA_LEN ("line") },	/* 'l' */
	  { NULL,		 0  },	/* 'm' */
	  { NULL,		 0  },	/* 'n' */
	  { NULL,		 0  },	/* 'o' */
	  { NULL,		 0  },	/* 'p' */
	  { NULL,		 0  },	/* 'q' */
	  { NULL,		 0  },	/* 'r' */
	  { STRING_COMMA_LEN ("stab") },	/* 's' */
	  { NULL,		 0  },	/* 't' */
	  { NULL,		 0  },	/* 'u' */
	  { NULL,		 0  },	/* 'v' */
	  { NULL,		 0  },	/* 'w' */
	  { NULL,		 0  },	/* 'x' */
	  { NULL,		 0  },	/* 'y' */
	  { STRING_COMMA_LEN ("zdebug") }	/* 'z' */
	};

d885 17
a901 6
	  int i = name [1] - 'd';
	  if (i >= 0
	      && i < (int) ARRAY_SIZE (debug_sections)
	      && debug_sections [i].name != NULL
	      && strncmp (&name [1], debug_sections [i].name,
			  debug_sections [i].len) == 0)
@


1.569
log
@	PR binutils/14444
	* elf.c (IS_VALID_GROUP_SECTION_HEADER) Add minsize param.
	(setup_group): Adjust uses.
	(bfd_section_from_shdr): Allow SHT_GROUP sections with just a flag
	word.
@
text
@d3267 1
a3267 1
   output, or that are duplicates.  */
d3272 10
a3281 2
  return ((sym->flags & BSF_SECTION_SYM) != 0
	  && !(sym->section->owner == abfd
@


1.568
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d548 1
a548 1
#define IS_VALID_GROUP_SECTION_HEADER(shdr)		\
d550 1
a550 1
	 && (shdr)->sh_size >= (2 * GRP_ENTRY_SIZE)	\
d558 1
a558 1
	  if (IS_VALID_GROUP_SECTION_HEADER (shdr))
d584 1
a584 1
	      if (IS_VALID_GROUP_SECTION_HEADER (shdr))
d1932 1
a1932 1
      if (! IS_VALID_GROUP_SECTION_HEADER (hdr))
@


1.568.2.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d883 31
d916 6
a921 17
	  const char *p;
	  int n;
	  if (name[1] == 'd')
	    p = ".debug", n = 6;
	  else if (name[1] == 'g' && name[2] == 'n')
	    p = ".gnu.linkonce.wi.", n = 17;
	  else if (name[1] == 'g' && name[2] == 'd')
	    p = ".gdb_index", n = 11; /* yes we really do mean 11.  */
	  else if (name[1] == 'l')
	    p = ".line", n = 5;
	  else if (name[1] == 's')
	    p = ".stab", n = 5;
	  else if (name[1] == 'z')
	    p = ".zdebug", n = 7;
	  else
	    p = NULL, n = 0;
	  if (p != NULL && strncmp (name, p, n) == 0)
d3267 1
a3267 1
   output, that are duplicates or there is no BFD section.  */
d3272 2
a3273 10
  elf_symbol_type *type_ptr;

  if ((sym->flags & BSF_SECTION_SYM) == 0)
    return FALSE;

  type_ptr = elf_symbol_from (abfd, sym);
  return ((type_ptr != NULL
	   && type_ptr->internal_elf_sym.st_shndx != 0
	   && bfd_is_abs_section (sym->section))
	  || !(sym->section->owner == abfd
a3885 1
	  phdr_size += bed->s->sizeof_ehdr;
d6043 1
a6043 1
	      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
a6352 20
  if (ibfd->xvec == obfd->xvec)
    {
      /* When rewriting program header, set the output maxpagesize to
	 the maximum alignment of input PT_LOAD segments.  */
      Elf_Internal_Phdr *segment;
      unsigned int i;
      unsigned int num_segments = elf_elfheader (ibfd)->e_phnum;
      bfd_vma maxpagesize = 0;

      for (i = 0, segment = elf_tdata (ibfd)->phdr;
	   i < num_segments;
	   i++, segment++)
	if (segment->p_type == PT_LOAD
	    && maxpagesize < segment->p_align)
	  maxpagesize = segment->p_align;

      if (maxpagesize != get_elf_backend_data (obfd)->maxpagesize)
	bfd_emul_set_maxpagesize (bfd_get_target (obfd), maxpagesize);
    }

a6766 1
		  shndx = SHN_ABS;
@


1.568.2.2
log
@	PR binutils/15106
	* elf.c (elf_find_function): Don't cache if symbols change.
@
text
@a7487 1
  static asymbol **last_symbols;
a7495 1
      || last_symbols != symbols
a7520 1
      last_symbols = symbols;
@


1.568.2.3
log
@	PR binutils/15106
	* elf-bfd.h (struct elf_obj_tdata): Add elf_find_function_cache.
	* elf.c (elf_find_function): Revert last change.  Use new
	tdata field rather than static vars for cache.
@
text
@d7487 5
a7491 7
  struct elf_find_function_cache
  {
    asection *last_section;
    asymbol *func;
    const char *filename;
    bfd_size_type func_size;
  } *cache;
d7496 5
a7500 12
  cache = elf_tdata (abfd)->elf_find_function_cache;
  if (cache == NULL)
    {
      cache = bfd_zalloc (abfd, sizeof (*cache));
      elf_tdata (abfd)->elf_find_function_cache = cache;
      if (cache == NULL)
	return FALSE;
    }
  if (cache->last_section != section
      || cache->func == NULL
      || offset < cache->func->value
      || offset >= cache->func->value + cache->func_size)
d7516 2
d7521 3
a7523 4
      cache->filename = NULL;
      cache->func = NULL;
      cache->func_size = 0;
      cache->last_section = section;
d7544 1
a7544 1
		      && size > cache->func_size)))
d7546 2
a7547 3
	      cache->func = sym;
	      cache->func_size = size;
	      cache->filename = NULL;
d7549 1
d7553 1
a7553 1
		cache->filename = bfd_asymbol_name (file);
d7560 1
a7560 1
  if (cache->func == NULL)
d7564 1
a7564 1
    *filename_ptr = cache->filename;
d7566 1
a7566 1
    *functionname_ptr = bfd_asymbol_name (cache->func);
@


1.567
log
@Check number of sections overflow

	* elf.c (assign_section_numbers): Check if number of sections
	>= SHN_LORESERVE.
	* elfcode.h (elf_object_p): Likewise.
@
text
@d7570 17
d7604 1
a7604 1
				     line_ptr, 0,
d7640 11
d7652 1
a7652 1
				filename_ptr, line_ptr, 0,
@


1.566
log
@Don't compress empty debug section

2012-07-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/14319
	* elf.c (_bfd_elf_make_section_from_shdr): Don't compress empty
	debug section.

2012-07-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/14319
	* binutils-all/compress.exp: Test compress empty debug sections.

	* binutils-all/dw2-empty.S: New file.
@
text
@d3017 7
@


1.565
log
@	PR ld/14207
	* elf.c (assign_file_positions_for_load_sections): Remove assertions
	that only PT_LOAD headers include file header and section headers.
	(assign_file_positions_for_non_load_sections): Similarly don't
	assert PT_GNU_RELRO header does not include file and section headers.
	Compare first section vma rather than PT_LOAD p_vaddr against
	relro_start when looking for PT_LOAD covering PT_GNU_RELRO.  Replace
	abort with assertion.
@
text
@d1028 1
a1028 1
	  if ((abfd->flags & BFD_COMPRESS))
@


1.564
log
@* elf.c (_bfd_elf_make_section_from_shdr): Fix typo in error
message.
@
text
@a4577 2
	      BFD_ASSERT (p->p_type == PT_LOAD);

a4603 1
		  BFD_ASSERT (p->p_type == PT_LOAD);
d4965 1
a4965 2

	  BFD_ASSERT (!m->includes_filehdr && !m->includes_phdrs);
d4971 3
a4973 1
	      for (lp = phdrs; lp < phdrs + count; ++lp)
a4975 1
		      && lp->p_vaddr >= link_info->relro_start
d4977 3
a4979 1
		      && lp->p_vaddr + lp->p_filesz >= link_info->relro_end)
d4985 1
a4985 2
	      if (lp == (phdrs + count))
		abort ();
@


1.563
log
@bfd/
	* elf.c (assign_file_positions_for_non_load_sections): Define
	__ehdr_start symbol if it's referenced and there's a PT_LOAD
	segment that covers both the file and program headers.

ld/
	* NEWS: Mention __ehdr_start.

ld/testsuite/
	* ld-elf/ehdr_start.s: New file.
	* ld-elf/ehdr_start.d: New file.
@
text
@d1041 1
a1041 1
		(_("%B: unable to initialize commpress status for section %s"),
d1061 1
a1061 1
		(_("%B: unable to initialize decommpress status for section %s"),
@


1.562
log
@Abort if PT_GNU_RELRO segment doesn't fit in PT_LOAD segment

bfd/

	PR bfd/14207
	* elf.c (assign_file_positions_for_non_load_sections): Abort if
	PT_GNU_RELRO segment doesn't fit in PT_LOAD segment.

ld/testsuite/

	PR ld/14207
	* ld-x86-64/x86-64.exp: Run pr14207.

	* ld-x86-64/pr14207.d: New file.
	* ld-x86-64/pr14207.s: Likewise.
@
text
@d4829 1
d4887 1
d4908 1
d4915 46
@


1.561
log
@	PR ld/14207
	* elf.c (_bfd_elf_map_sections_to_segments): Disregard bss type
	sections at end of PT_LOAD segment when searching for segment
	that contains end of relro extent.
@
text
@d4934 5
@


1.560
log
@Reindent assign_file_positions_for_non_load_sections

	* elf.c (assign_file_positions_for_non_load_sections): Reindent.
@
text
@d4155 4
a4158 1
	      if (m->p_type == PT_LOAD)
d4160 11
a4170 7
		  asection *last = m->sections[m->count - 1];
		  bfd_vma vaddr = m->sections[0]->vma;
		  bfd_vma filesz = last->vma - vaddr + last->size;

		  if (vaddr < info->relro_end
		      && vaddr >= info->relro_start
		      && (vaddr + filesz) >= info->relro_end)
@


1.559
log
@Reindent _bfd_elf_map_sections_to_segments

	* elf.c (_bfd_elf_map_sections_to_segments): Reindent.
@
text
@d4952 9
a4960 8
          /* Preserve the alignment and flags if they are valid. The gold
             linker generates RW/4 for the PT_GNU_RELRO section. It is better
             for objcopy/strip to honor these attributes otherwise gdb will
             choke when using separate debug files. */
          if (!m->p_align_valid)
            p->p_align = 1;
          if (!m->p_flags_valid)
            p->p_flags = (lp->p_flags & ~PF_W);
@


1.558
log
@bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Make LEN argument
	of target_read_memory as bfd_size_type.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (elf_backend_bfd_from_remote_memory): Make LEN
	argument of target_read_memory as bfd_size_type.
	(_bfd_elf32_bfd_from_remote_memory): Likewise.
	(_bfd_elf64_bfd_from_remote_memory): Likewise.
	* elf.c (bfd_elf_bfd_from_remote_memory): Likewise.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): Likewise.

gdb/
	* symfile-mem.c: 3 new gdb_static_assert for target_read_memory_bfd
	parameters.
	(target_read_memory_bfd): New function.
	(symbol_file_add_from_memory): Use it.
@
text
@d4166 1
a4166 1
	      }
@


1.557
log
@	PR binutils/13897
	* elf.c (elf_find_function): Cache last function sym info.
	(_bfd_elf_maybe_function_sym): Return function size, pass in
	section of interest.
	* elf-bfd.h (struct elf_backend_data <maybe_function_sym>): Likewise.
	(_bfd_elf_maybe_function_sym): Likewise.
	* elf64-ppc.c (ppc64_elf_maybe_function_sym): Likewise.
	(opd_entry_value): Add in_code_sec param.  Revert caching code.
	Return -1 if in_code_sec and function found in wrong section.
	Update all calls.
@
text
@d9574 1
a9574 1
   int (*target_read_memory) (bfd_vma, bfd_byte *, size_t))
@


1.556
log
@bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Make LEN argument
	of target_read_memory as size_t.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (elf_backend_bfd_from_remote_memory): Make LEN
	argument of target_read_memory as size_t.
	(_bfd_elf32_bfd_from_remote_memory): Likewise.
	(_bfd_elf64_bfd_from_remote_memory): Likewise.
	* elf.c (bfd_elf_bfd_from_remote_memory): Likewise.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): Likewise.

gdb/
	* target.c (target_read_memory): Make LEN argument as size_t.
	* target.h (target_read_memory): Likewise.
@
text
@d7410 4
a7413 14
  const char *filename;
  asymbol *func, *file;
  bfd_vma low_func;
  asymbol **p;
  /* ??? Given multiple file symbols, it is impossible to reliably
     choose the right file name for global symbols.  File symbols are
     local symbols, and thus all file symbols must sort before any
     global symbols.  The ELF spec may be interpreted to say that a
     file symbol must sort before other local symbols, but currently
     ld -r doesn't do this.  So, for ld -r output, it is possible to
     make a better choice of file name for local symbols by ignoring
     file symbols appearing after a given local symbol.  */
  enum { nothing_seen, symbol_seen, file_after_symbol_seen } state;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d7418 26
a7443 11
  filename = NULL;
  func = NULL;
  file = NULL;
  low_func = 0;
  state = nothing_seen;

  for (p = symbols; *p != NULL; p++)
    {
      asymbol *sym = *p;
      asection *code_sec;
      bfd_vma code_off;
d7445 1
a7445 1
      if ((sym->flags & BSF_FILE) != 0)
d7447 11
a7457 5
	  file = sym;
	  if (state == symbol_seen)
	    state = file_after_symbol_seen;
	  continue;
	}
d7459 18
a7476 12
      if (bed->maybe_function_sym (sym, &code_sec, &code_off)
	  && code_sec == section
	  && code_off >= low_func
	  && code_off <= offset)
	{
	  func = sym;
	  low_func = code_off;
	  filename = NULL;
	  if (file != NULL
	      && ((sym->flags & BSF_LOCAL) != 0
		  || state != file_after_symbol_seen))
	    filename = bfd_asymbol_name (file);
a7477 2
      if (state == nothing_seen)
	state = symbol_seen;
d9732 9
a9740 2
/* Return TRUE iff the ELF symbol SYM might be a function.  Set *CODE_SEC
   and *CODE_OFF to the function's entry point.  */
a9741 4
bfd_boolean
_bfd_elf_maybe_function_sym (const asymbol *sym,
			     asection **code_sec, bfd_vma *code_off)
{
d9743 3
a9745 2
		     | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC)) != 0)
    return FALSE;
a9746 1
  *code_sec = sym->section;
d9748 6
a9753 1
  return TRUE;
@


1.555
log
@	* elf.c (ignore_section_sym): Correct comment.  Don't return
	true for absolute section.
	(elf_map_symbols): Move stray comment.  Adjust for above change.
	Don't discard global section symbols.
@
text
@d9559 1
a9559 1
   int (*target_read_memory) (bfd_vma, bfd_byte *, int))
@


1.554
log
@ 	PR ld/13962
 	PR ld/7023
	* elf.c (bfd_section_from_shdr): Fail when .dynsym sh_info is
	out of range.  As a special case, fix sh_info for zero sh_size.
	Do the same for .symtab.
@
text
@a3245 3
/* Map symbol from it's internal number to the external number, moving
   all local symbols to be at the head of the list.  */

d3260 1
a3260 1
   output.  */
d3268 2
a3269 1
		   && sym->section->output_offset == 0)));
d3272 3
d3316 2
a3317 1
	  && !ignore_section_sym (abfd, sym))
d3331 3
a3333 3
      if (ignore_section_sym (abfd, syms[idx]))
	continue;
      if (!sym_is_global (abfd, syms[idx]))
a3334 2
      else
	num_globals++;
d3364 3
a3366 3
      if (ignore_section_sym (abfd, sym))
	continue;
      if (!sym_is_global (abfd, sym))
d3369 1
a3369 1
	i = num_locals + num_globals2++;
@


1.553
log
@2012-05-08  Ben Cheng  <bccheng@@google.com>

	* bfd/elf.c: Preserve the original p_align and p_flags if they are
	valid.
@
text
@d1649 9
a1657 1
	return FALSE;
d1710 10
@


1.552
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4934 8
a4941 2
	      p->p_align = 1;
	      p->p_flags = (lp->p_flags & ~PF_W);
@


1.551
log
@bfd/
	* elf.c (_bfd_elf_map_sections_to_segments): Set INFO->user_phdrs.
	* elf-nacl.c (nacl_modify_segment_map): Do nothing if INFO->user_phdrs.
	(nacl_modify_program_headers): Likewise.

include/
	* bfdlink.h (struct bfd_link_info): Add new member user_phdrs.
@
text
@d3074 1
a3074 1
		  if (elf_discarded_section (s))
d9454 1
a9454 1
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d9485 1
a9485 1
  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
d9501 1
a9501 1
    case ELF_INFO_TYPE_STABS:
d9504 1
a9504 1
    case ELF_INFO_TYPE_EH_FRAME:
@


1.550
log
@	* elf.c (assign_file_positions_for_non_load_sections): Don't warn
	on empty alloc sections.
@
text
@d2530 1
a2530 1
  amt = sizeof ".rela" + strlen (asect->name);      
d3747 4
d4358 1
a4358 1
  
d5435 1
a5435 1
	  segment.         
d6155 1
a6155 1
      
d9640 1
a9640 1
	  
@


1.549
log
@	* elf.c (elf_find_function): Don't use internal_elf_sym.
	(_bfd_elf_maybe_function_sym): Likewise.  Replace elf_symbol_type
	parameter with asymbol.
	* elf64-ppc.c (ppc64_elf_maybe_function_sym): Likewise.
	* elf-bfd.h (_bfd_elf_maybe_function_sym): Update prototype.
	(struct elf_backend_data <maybe_function_sym>): Likewise.
@
text
@d4823 7
a4829 6
	  (*_bfd_error_handler)
	    (_("%B: warning: allocated section `%s' not in segment"),
	     abfd,
	     (hdr->bfd_section == NULL
	      ? "*unknown*"
	      : hdr->bfd_section->name));
@


1.548
log
@	* elf-bfd.h: Formatting.
	(struct elf_backend_data): Add "maybe_function_sym".
	(_bfd_elf_maybe_function_sym): Declare.
	* elfxx-target.h (elf_backend_maybe_function_sym): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_find_function): Use maybe_function_sym.
	(_bfd_elf_maybe_function_sym): New function.
	* elf64-ppc.c (elf_backend_maybe_function_sym): Define.
	(ppc64_elf_maybe_function_sym): New function.
@
text
@d7407 1
a7407 2
      elf_symbol_type *q;
      unsigned int type;
d7411 1
a7411 4
      q = (elf_symbol_type *) *p;

      type = ELF_ST_TYPE (q->internal_elf_sym.st_info);
      switch (type)
d7413 1
a7413 2
	case STT_FILE:
	  file = &q->symbol;
d7417 14
a7430 15
	default:
	  if (bed->maybe_function_sym (q, &code_sec, &code_off)
	      && code_sec == section
	      && code_off >= low_func
	      && code_off <= offset)
	    {
	      func = (asymbol *) q;
	      low_func = code_off;
	      filename = NULL;
	      if (file != NULL
		  && (ELF_ST_BIND (q->internal_elf_sym.st_info) == STB_LOCAL
		      || state != file_after_symbol_seen))
		filename = bfd_asymbol_name (file);
	    }
	  break;
d9692 1
a9692 1
_bfd_elf_maybe_function_sym (const elf_symbol_type *sym,
d9695 7
a9701 10
  unsigned int type = ELF_ST_TYPE (sym->internal_elf_sym.st_info);
  if (type == STT_NOTYPE
      || type == STT_FUNC
      || type == STT_GNU_IFUNC)
    {
      *code_sec = sym->symbol.section;
      *code_off = sym->symbol.value;
      return TRUE;
    }
  return FALSE;
@


1.547
log
@	* elf.c (elfcore_write_prpsinfo): Provide unconditionally.
	Return NULL if core file generation is unsupported.
	(elfcore_write_prstatus): Likewise.
	* elf32-arm.c (elf32_arm_nabi_write_core_note): New function.
	(elf_backend_write_core_note): Define.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d7409 2
d7423 4
a7426 6
	  if (!bed->is_function_type (type))
	    break;
	case STT_NOTYPE:
	  if (bfd_get_section (&q->symbol) == section
	      && q->symbol.value >= low_func
	      && q->symbol.value <= offset)
d7429 1
a7429 1
	      low_func = q->symbol.value;
d9693 19
@


1.546
log
@2011-12-13  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* dwarf2.c (bfd_dwarf2_cleanup_debug_info): Accept stash as an
	argument like other functions to support formats other than ELF.
	* elf-bfd.h (bfd_dwarf2_cleanup_debug_info): Move to bfd-in.h.
	* elf.c (_bfd_elf_close_and_cleanup): Pass dwarf2_find_line_info
	in tdata as a parameter.
	* libbfd-in.h (bfd_dwarf2_cleanup_debug_info): Move from
	elf-bfd.h.
	* libbfd.h (bfd_dwarf2_cleanup_debug_info): Regenerate.
	* mach-o-target.c (bfd_mach_o_close_and_cleanup): Remove the
	fallback macro.
	(bfd_mach_o_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Add the definition
	which calls _bfd_dwarf2_find_nearest_line.
	(bfd_mach_o_close_and_cleanup): Likewise.
	* mach-o.h (mach_o_data_struct): Add dwarf2_find_line_info.
	(bfd_mach_o_find_nearest_line): Add declaration.
	(bfd_mach_o_close_and_cleanup): Add declaration.
@
text
@a8892 1
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
a8899 1
  const char *note_name = "CORE";
d8911 1
d8927 1
a8927 1
				 note_name, note_type, &data, sizeof (data));
d8944 1
a8944 1
				 note_name, note_type, &data, sizeof (data));
d8946 4
a8950 1
#endif	/* PSINFO_T or PRPSINFO_T */
a8951 1
#if defined (HAVE_PRSTATUS_T)
a8959 1
  const char *note_name = "CORE";
d8972 1
d8982 1
a8982 1
      return elfcore_write_note (abfd, buf, bufsiz, note_name,
d8994 1
a8994 1
      return elfcore_write_note (abfd, buf, bufsiz, note_name,
d8997 4
a9001 1
#endif /* HAVE_PRSTATUS_T */
@


1.545
log
@include/elf/ChangeLog:

	* common.h (NT_S390_LAST_BREAK): Define.
	(NT_S390_SYSTEM_CALL): Likewise.

bfd/ChangeLog:

	* elf-bfd.h (elfcore_write_s390_last_break): Add prototype.
	(elfcore_write_s390_system_call): Likewise.
	* elf.c (elfcore_write_s390_last_break): New function.
	(elfcore_write_s390_system_call): Likewise.
	(elfcore_write_register_note): Call them.
	(elfcore_grok_s390_last_break): New function.
	(elfcore_grok_s390_system_call): Likewise.
	(elfcore_grok_note): Call them.
@
text
@d7701 2
a7702 1
  if (bfd_get_format (abfd) == bfd_object)
d7704 1
a7704 1
      if (elf_tdata (abfd) != NULL && elf_shstrtab (abfd) != NULL)
d7706 1
a7706 1
      _bfd_dwarf2_cleanup_debug_info (abfd);
@


1.544
log
@2011-09-30  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2.c (struct dwarf2_debug): Add field debug_sections.
	(read_section): Add sec argument. Adjust the code to get section
	names from it.
	(read_indirect_string): Adjust call to read_section.
	(read_abbrevs): Ditto.
	(decode_line_info): Ditto.
	(read_debug_ranges): Ditto.
	(DWARF2_DEBUG_INFO, DWARF2_COMPRESSED_DEBUG_INFO): Remove.
	(find_debug_info): Add debug_sections parameter.  Use it instead
	the above macros.
	(place_sections): Get section names from stash.
	(find_line): Add debug_sections argument.  Initialize
	debug_sections field of stash from it.
	Adjust calls to find_debug_info.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	Adjust call to find_line.
	(_bfd_dwarf2_find_line): Adjust call to find_line.
	* libcoff-in.h (struct dwarf_debug_section): New declaration.
	(coff_find_nearest_line_with_names): Likewise.
	* libcoff.h: Regenerate.
	* libbfd-in.h (struct dwarf_debug_section): Move declaration.
	(dwarf_debug_sections): Likewise.
	(_bfd_dwarf2_find_nearest_line): Add debug_sections argument.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Ditto.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Ditto.
	* elf32-arm.c (elf32_arm_find_nearest_line): Ditto.
	* coffgen.c (coff_find_nearest_line_with_names): New function.
	(coff_find_nearest_line): Calls coff_find_nearest_line_with_names.
	* coff-rs6000.c (xcoff_debug_sections): New constant.
	(xcoff_find_nearest_line): New function.
	(rs6000coff_vec): Use xcoff_find_nearest_line.
	(pmac_xcoff_vec): Ditto.
@
text
@d7986 12
d8422 14
d9197 26
d9264 4
@


1.543
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d7479 2
a7480 1
  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
@


1.543.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3074 1
a3074 1
		  if (discarded_section (s))
d9393 1
a9393 1
      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
d9424 1
a9424 1
  if (sec->sec_info_type != SEC_INFO_TYPE_MERGE)
d9440 1
a9440 1
    case SEC_INFO_TYPE_STABS:
d9443 1
a9443 1
    case SEC_INFO_TYPE_EH_FRAME:
@


1.542
log
@	PR ld/12921
	* elf.c (assign_file_positions_for_load_sections): Don't align
	sh_offset for all SHT_NOBITS sections here, just .tbss sections
	that don't get a PT_LOAD.
@
text
@d9613 1
a9613 1
     osabi field to ELFOSABI_LINUX if the binary contains symbols of
d9617 1
a9617 1
    i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_LINUX;
@


1.541
log
@	* elf.c (elf_find_function): Fail if not provided with a symbol
	table.
@
text
@d4687 1
a4687 4
	      if (p->p_type == PT_LOAD
		  || (this_hdr->sh_type == SHT_NOBITS
		      && (this_hdr->sh_flags & SHF_TLS) != 0
		      && this_hdr->sh_offset == 0))
d4689 18
a4706 13
		  if (this_hdr->sh_type == SHT_NOBITS)
		    {
		      /* These sections don't really need sh_offset,
			 but give them one anyway.  */
		      bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
							      off, align);
		      this_hdr->sh_offset = sec->filepos = off + adjust;
		    }
		  else
		    {
		      this_hdr->sh_offset = sec->filepos = off;
		      off += this_hdr->sh_size;
		    }
@


1.540
log
@include/elf/
	* common.h (NT_ARM_VFP): Define.

bfd/
	* elf-bfd.h (elfcore_write_arm_vfp): Add prototype.
	* elf.c (elfcore_grok_arm_vfp): New function.
	(elfcore_grok_note): Call it to handle NT_ARM_VFP notes.
	(elfcore_write_arm_vfp): New function.
	(elfcore_write_register_note): Call it to handle .reg-arm-vfp.

binutils/
	* readelf.c (get_note_type): Handle NT_ARM_VFP.
@
text
@d7394 3
@


1.539
log
@	PR ld/12845
	* elf.c (_bfd_elf_init_private_section_data): Add an assertion
	that the output section has an allocated bfd_elf_section_data
	structure.
	* elfxx-mips.c (mips_elf_check_symbols): Do not create a stub for
	symbols in sections that have been removed by garbage collection.

	* emultempl/mipself.em (mips_add_stub_section): Do not add stubs
	for sections that have been removed by garbage collection.
@
text
@d7979 6
d8404 7
d9165 12
d9206 2
@


1.538
log
@	PR 12763
bfd/
	* elf.c (assign_file_positions_for_load_sections): Set sh_offset for
	.tbss, and page align same for all SHT_NOBITS sections.
ld/
	* ldlang.c (lang_output_section_find_by_flags): Match orphan .sdata2
	like sections to existing .sdata2, and similarly for orphan TLS
	sections.
	* emultempl/elf32.em (place_orphan): Exclude .tbss from orphan_bss.
@
text
@d6275 2
@


1.537
log
@	PR 12763
	* elf.c (_bfd_elf_make_section_from_shdr): Set up TLS section LMAs
	from PT_TLS header.
	(_bfd_elf_map_sections_to_segments): Don't create a final PT_LOAD
	segment if just for .tbss.
	(assign_file_positions_for_load_sections): Don't report "can't
	allocate in segment" errors for .tbss.
	(assign_file_positions_for_non_load_sections): Don't set p_filesz
	from SHT_NOBITS section filepos.
@
text
@d4687 4
a4690 1
	      if (p->p_type == PT_LOAD)
d4692 13
a4704 3
		  this_hdr->sh_offset = sec->filepos = off;
		  if (this_hdr->sh_type != SHT_NOBITS)
		    off += this_hdr->sh_size;
@


1.536
log
@bfd/
	* config.in: Regenerated.
	* configure: Regenerated.
	* configure.in: New tests for HAVE_PRPSINFO_T_PR_PID,
	HAVE_PRPSINFO32_T_PR_PID, HAVE_PSINFO_T_PR_PID and
	HAVE_PSINFO32_T_PR_PID.
	* elf.c (elfcore_grok_psinfo): Protect reading psinfo.pr_pid by
	HAVE_PRPSINFO_T_PR_PID, HAVE_PRPSINFO32_T_PR_PID, HAVE_PSINFO_T_PR_PID
	and HAVE_PSINFO32_T_PR_PID.
	* hosts/x86-64linux.h (HAVE_PRPSINFO32_T_PR_PID): New redefinition.
@
text
@d979 3
a981 1
	  if (phdr->p_type == PT_LOAD
d3992 6
a3997 2
      /* Create a final PT_LOAD program segment.  */
      if (last_hdr != NULL)
d4757 2
a4758 1
	      if (!ELF_SECTION_IN_SEGMENT_1 (this_hdr, p, check_vma, 0))
a4928 3
	      Elf_Internal_Shdr *hdr;
	      asection *sect;

d4931 1
a4931 5
	      sect = m->sections[m->count - 1];
	      hdr = &elf_section_data (sect)->this_hdr;
	      p->p_filesz = sect->filepos - m->sections[0]->filepos;
	      if (hdr->sh_type != SHT_NOBITS)
		p->p_filesz += hdr->sh_size;
d4933 11
@


1.535
log
@bfd/
	* elf.c (elfcore_grok_psinfo): Initialize CORE_PID for both native and
	32bit psinfo.
	* elf32-ppc.c (ppc_elf_grok_psinfo): Initialize core_pid.
	* elf64-ppc.c (ppc64_elf_grok_psinfo): Likewise.
@
text
@d8003 1
d8005 1
d8022 1
d8024 1
@


1.534
log
@Reverse copy .ctors/.dtors sections if needed.

bfd/

2011-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12730
	* elf.c (_bfd_elf_section_offset): Check SEC_ELF_REVERSE_COPY.

	* elflink.c (elf_link_input_bfd): Reverse copy .ctors/.dtors
	sections if needed.

	* section.c (SEC_ELF_REVERSE_COPY): New.
	* bfd-in2.h: Regenerated.

ld/testsuite/

2011-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12730
	* ld-elf/elf.exp (array_tests): Add "pr12730".
	(array_tests_pie): New.
	(array_tests_static): Add -static for "static init array mixed".
	Add "static pr12730".  Run array_tests_pie for Linux.

	* ld-elf/init-mixed.c (ctor1007): Renamed to ...
	(ctor1007a): This.
	(ctor1007b): New.
	(ctors1007): Remove ctor1007.  Add ctor1007b and ctor1007a.
	(dtor1007): Renamed to ...
	(dtor1007a): This.
	(dtor1007b): New.
	(dtors1007): Remove dtor1007.  Add dtor1007b and dtor1007a.
	(ctor65535): Renamed to ...
	(ctor65535a): This.
	(ctor65535b): New.
	(ctors65535): Remove ctor65535.  Add ctor65535b and ctor65535a.
	(dtor65535): Renamed to ...
	(dtor65535a): This.
	(dtor65535b): New.
	(dtors65535): Remove dtor65535.  Add dtor65535b and dtor65535a.

	* ld-elf/pr12730.cc: New.
	* ld-elf/pr12730.out: Likewise.
@
text
@d8003 1
d8020 1
@


1.533
log
@bfd: constify a few arrays
@
text
@d9382 6
@


1.532
log
@	* elf-bfd.h (struct sdt_note): New struct.
	(struct elf_obj_tdata) <sdt_note_head>: New field.
	* elf.c (elfobj_grok_stapsdt_note_1): New function.
	(elfobj_grok_stapsdt_note): Likewise.
	(elf_parse_notes): Added code to treat SystemTap note
	sections.
	* common.h (NT_STAPSDT): New define.
@
text
@d2167 1
a2167 1
static const struct bfd_elf_special_section *special_sections[] =
@


1.531
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d8420 29
d9221 6
@


1.530
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d9509 1
a9509 1
     the STT_GNU_IFUNC type.  */
d9511 1
a9511 1
      && elf_tdata (abfd)->has_ifunc_symbols)
@


1.529
log
@	PR binutils/12467
	* readelf.c (process_program_headers): Issue a warning if there
	are no program headers but the file header has a non-zero program
	header offset.
	(process_section_headers): Issue a warning if there are no section
	headers but the file header has a non-zero section header offset.
	(process_section_groups): Reword the no section message so that it
	can be distinguished from the one issued by process_section_headers.

	* elf.c (assign_file_positions_for_load_sections): Set the program
	header offset and entry size to zero if there are no program
	headers.
@
text
@d6545 1
d6745 5
a6749 1
	sym.st_other = type_ptr->internal_elf_sym.st_other;
d6751 4
a6754 1
	sym.st_other = 0;
@


1.528
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d4337 12
a4348 2
  elf_elfheader (abfd)->e_phoff = bed->s->sizeof_ehdr;
  elf_elfheader (abfd)->e_phentsize = bed->s->sizeof_phdr;
@


1.527
log
@Add SORT_BY_INIT_PRIORITY.

bfd/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_new_section_hook): Special handling for
	.init_array/.fini_array output sections.

ld/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (GENSCRIPTS): Add @@enable_initfini_array@@.

	* NEWS: Mention SORT_BY_INIT_PRIORITY.

	* configure.in: Add AC_CANONICAL_BUILD.
	Add --enable-initfini-array.

	* genscripts.sh (ENABLE_INITFINI_ARRAY): New.

	* ld.h (sort_type): Add by_init_priority.

	* ld.texinfo: Document SORT_BY_INIT_PRIORITY.

	* ldgram.y (SORT_BY_INIT_PRIORITY): New.
	(wildcard_spec): Handle SORT_BY_INIT_PRIORITY.

	* ldlang.c (get_init_priority): New.
	(compare_section): Use get_init_priority for by_init_priority.

	* ldlex.l (SORT_BY_INIT_PRIORITY): New.

	* scripttempl/elf.sc: Support ENABLE_INITFINI_ARRAY.

	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* config.in: Likewise.
	* configure: Likewise.

ld/testsuite/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/elf.exp (array_tests): Add init-mixed.
	(array_tests_static): Likewise.
	Also delete tmpdir/init-mixed.

	* ld-elf/init-mixed.c: New.
	* ld-elf/init-mixed.out: Likewise.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d4283 1
d4288 1
@


1.526
log
@Mark .gnu.lto_* sections with SHF_EXCLUDE.

bfd/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (special_sections_g): Add ".gnu.lto_".

gas/testsuite/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/elf.exp: Run section9.

	* gas/elf/section9.d: New.
	* gas/elf/section9.s: Likewise.
@
text
@d2307 5
a2311 2
     elf_fake_sections.  */
  if ((!sec->flags && abfd->direction != read_direction)
d2315 5
a2319 1
      if (ssect != NULL)
@


1.525
log
@bfd/
	* hash.c (bfd_hash_hash): Extract from..
	(bfd_hash_lookup): ..here.
	(bfd_hash_rename): New function.
	* section.c (bfd_rename_section): New function.
	* bfd-in.h (bfd_hash_rename): Declare.
	* bfd-in2.h: Regenerate.
	* elf.c (_bfd_elf_make_section_from_shdr): Rename input sections
	when compressing or decompressing.  Don't assert name match.
	* elf64-hppa.c (get_reloc_section): Don't assert name match.
	* elfxx-ia64.c (get_reloc_section): Likewise.
binutils/
	* objcopy.c (copy_main): No need to rename sections when compressing
	or decompressing.
binutils/testsuite/
	* binutils-all/objdump.W: Adjust expected result for debug section
	rename.
@
text
@d2085 1
@


1.524
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d825 1
a825 5
    {
      BFD_ASSERT (strcmp (name,
			  bfd_get_section_name (abfd, hdr->bfd_section)) == 0);
      return TRUE;
    }
d1015 1
d1030 1
d1043 11
d1063 10
d1075 2
@


1.524.2.1
log
@backport from mainline
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d825 5
a829 1
    return TRUE;
a1018 1
      char *new_name;
a1032 1
      new_name = NULL;
a1044 11
	  if (name[1] != 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len + 2);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      new_name[1] = 'z';
	      memcpy (new_name + 2, name + 1, len);
	    }
a1053 10
	  if (name[1] == 'z')
	    {
	      unsigned int len = strlen (name);

	      new_name = bfd_alloc (abfd, len);
	      if (new_name == NULL)
		return FALSE;
	      new_name[0] = '.';
	      memcpy (new_name + 1, name + 2, len - 1);
	    }
a1055 2
      if (new_name != NULL)
	bfd_rename_section (abfd, newsect, new_name);
a4253 1
  fflush (stdout);
a4257 1
  fflush (stderr);
@


1.524.2.2
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@a2084 1
  { STRING_COMMA_LEN (".gnu.lto_"),       -1, SHT_PROGBITS,    SHF_EXCLUDE },
d9483 1
a9483 1
     the STT_GNU_IFUNC type or STB_GNU_UNIQUE binding.  */
d9485 1
a9485 1
      && elf_tdata (abfd)->has_gnu_symbols)
@


1.524.2.3
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d979 1
a979 3
	  if (((phdr->p_type == PT_LOAD
		&& (hdr->sh_flags & SHF_TLS) == 0)
	       || phdr->p_type == PT_TLS)
d3983 2
a3984 6
      /* Create a final PT_LOAD program segment, but not if it's just
	 for .tbss.  */
      if (last_hdr != NULL
	  && (i - phdr_index != 1
	      || ((last_hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
		  != SEC_THREAD_LOCAL)))
d4664 1
a4664 4
	      if (p->p_type == PT_LOAD
		  || (this_hdr->sh_type == SHT_NOBITS
		      && (this_hdr->sh_flags & SHF_TLS) != 0
		      && this_hdr->sh_offset == 0))
d4666 3
a4668 13
		  if (this_hdr->sh_type == SHT_NOBITS)
		    {
		      /* These sections don't really need sh_offset,
			 but give them one anyway.  */
		      bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
							      off, align);
		      this_hdr->sh_offset = sec->filepos = off + adjust;
		    }
		  else
		    {
		      this_hdr->sh_offset = sec->filepos = off;
		      off += this_hdr->sh_size;
		    }
d4734 1
a4734 2
	      if (!ELF_SECTION_IN_SEGMENT_1 (this_hdr, p, check_vma, 0)
		  && !ELF_TBSS_SPECIAL (this_hdr, p))
d4905 3
d4910 5
a4914 1
	      p->p_filesz = 0;
a4915 11
	      for (i = m->count; i-- != 0;)
		{
		  asection *sect = m->sections[i];
		  Elf_Internal_Shdr *hdr = &elf_section_data (sect)->this_hdr;
		  if (hdr->sh_type != SHT_NOBITS)
		    {
		      p->p_filesz = (sect->filepos - m->sections[0]->filepos
				     + hdr->sh_size);
		      break;
		    }
		}
a7977 3
#if defined (HAVE_PSINFO_T_PR_PID) || defined (HAVE_PRPSINFO_T_PR_PID)
      elf_tdata (abfd)->core_pid = psinfo.pr_pid;
#endif
a7993 3
#if defined (HAVE_PSINFO32_T_PR_PID) || defined (HAVE_PRPSINFO32_T_PR_PID)
      elf_tdata (abfd)->core_pid = psinfo.pr_pid;
#endif
@


1.524.2.4
log
@	PR ld/12921
	* elf.c (assign_file_positions_for_load_sections): Don't align
	sh_offset for all SHT_NOBITS sections here, just .tbss sections
	that don't get a PT_LOAD.
@
text
@d4670 4
a4673 1
	      if (p->p_type == PT_LOAD)
d4675 13
a4687 18
		  this_hdr->sh_offset = sec->filepos = off;
		  if (this_hdr->sh_type != SHT_NOBITS)
		    off += this_hdr->sh_size;
		}
	      else if (this_hdr->sh_type == SHT_NOBITS
		       && (this_hdr->sh_flags & SHF_TLS) != 0
		       && this_hdr->sh_offset == 0)
		{
		  /* This is a .tbss section that didn't get a PT_LOAD.
		     (See _bfd_elf_map_sections_to_segments "Create a
		     final PT_LOAD".)  Set sh_offset to the value it
		     would have if we had created a zero p_filesz and
		     p_memsz PT_LOAD header for the section.  This
		     also makes the PT_TLS header have the same
		     p_offset value.  */
		  bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
							  off, align);
		  this_hdr->sh_offset = sec->filepos = off + adjust;
@


1.523
log
@Fix build with -DDEBUG=7
@
text
@d1012 46
@


1.522
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d5220 2
a5221 3
	     "elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n",
	     (long) asym_ptr, asym_ptr->name, idx, flags,
	     elf_symbol_flags (flags));
@


1.521
log
@ld/
	* ldlang.c (lang_add_section): Don't copy SEC_RELOC from input
	to output section on a final link.
bfd/
	* elf.c (_bfd_elf_init_private_section_data): Allow for SEC_RELOC
	difference between input and output section.
@
text
@d1713 1
a1713 1
	Elf_Internal_Shdr *hdr2;
d1715 2
d1795 3
a1797 3
	if ((target_sect->flags & SEC_RELOC) == 0
	    || target_sect->reloc_count == 0)
	  hdr2 = &elf_section_data (target_sect)->rel_hdr;
d1799 7
a1805 9
	  {
	    bfd_size_type amt;
	    BFD_ASSERT (elf_section_data (target_sect)->rel_hdr2 == NULL);
	    amt = sizeof (*hdr2);
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
	    if (hdr2 == NULL)
	      return FALSE;
	    elf_section_data (target_sect)->rel_hdr2 = hdr2;
	  }
d1807 1
d1816 4
a1819 1
	  target_sect->use_rela_p = hdr->sh_type == SHT_RELA;
d2417 19
a2435 3
/* Initialize REL_HDR, the section-header for new section, containing
   relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA
   relocations; otherwise, we use REL relocations.  */
d2439 1
a2439 1
			  Elf_Internal_Shdr *rel_hdr,
d2443 1
d2446 1
a2446 1
  bfd_size_type amt = sizeof ".rela" + strlen (asect->name);
d2448 6
d2487 6
d2496 1
a2496 1
elf_fake_sections (bfd *abfd, asection *asect, void *failedptrarg)
d2498 1
d2500 1
a2500 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2504 1
a2504 1
  if (*failedptr)
d2511 1
a2511 1
  this_hdr = &elf_section_data (asect)->this_hdr;
d2517 1
a2517 1
      *failedptr = TRUE;
d2669 34
d2707 1
a2707 1
    *failedptr = TRUE;
a2714 11

  /* If the section has relocs, set up a section header for the
     SHT_REL[A] section.  If two relocation sections are required for
     this section, it is up to the processor-specific back-end to
     create the other.  */
  if ((asect->flags & SEC_RELOC) != 0
      && !_bfd_elf_init_reloc_shdr (abfd,
				    &elf_section_data (asect)->rel_hdr,
				    asect,
				    asect->use_rela_p))
    *failedptr = TRUE;
d2880 1
a2880 3
      if ((sec->flags & SEC_RELOC) == 0)
	d->rel_idx = 0;
      else
d2882 2
a2883 2
	  d->rel_idx = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr.sh_name);
d2885 2
d2888 1
a2888 1
      if (d->rel_hdr2)
d2890 2
a2891 2
	  d->rel_idx2 = section_number++;
	  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel_hdr2->sh_name);
d2894 1
a2894 1
	d->rel_idx2 = 0;
d2966 4
a2969 4
      if (d->rel_idx != 0)
	i_shdrp[d->rel_idx] = &d->rel_hdr;
      if (d->rel_idx2 != 0)
	i_shdrp[d->rel_idx2] = d->rel_hdr2;
d2976 1
a2976 1
      if (d->rel_idx != 0)
d2978 2
a2979 2
	  d->rel_hdr.sh_link = t->symtab_section;
	  d->rel_hdr.sh_info = d->this_idx;
d2981 1
a2981 1
      if (d->rel_idx2 != 0)
d2983 2
a2984 2
	  d->rel_hdr2->sh_link = t->symtab_section;
	  d->rel_hdr2->sh_info = d->this_idx;
d3338 1
d3358 4
a3361 3
  failed = FALSE;
  bfd_map_over_sections (abfd, elf_fake_sections, &failed);
  if (failed)
d3381 1
@


1.520
log
@bfd/
	* elf.c (bfd_elf_get_default_section_type): Don't test SEC_NEVER_LOAD.
	* elflink.c (elf_link_input_bfd): Likewise.
ld/
	* ld.texinfo (NOLOAD): Do not erroneously state that contents will
	appear in output file.
	* ldlang.c (lang_add_section): Clear SEC_HAS_CONTENTS on noload
	unless SEC_COFF_SHARED_LIBRARY.
	(map_input_to_output_sections): Don't set SEC_HAS_CONTENTS for noload
	output sections.
	(lang_size_sections_1): Don't test SEC_NEVER_LOAD when deciding
	to update dot in region.  Ditto when setting SEC_ALLOC if dot
	advanced due to assignment.
	* ldwrite.c (build_link_order): Don't test SEC_NEVER_LOAD.
@
text
@d6113 1
a6113 1
		  & ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES)) == 0)))
@


1.519
log
@Don't warn zero LMA adjustment.

bfd/

2010-09-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11998
	* elf.c (assign_file_positions_for_load_sections): Don't warn
	zero LMA adjustment.

ld/testsuite/

2010-09-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11998
	* ld-scripts/rgn-at5.d: New.
	* ld-scripts/rgn-at5.s: Likewise.
	* ld-scripts/rgn-at5.t: Likewise.
@
text
@d2455 1
a2455 2
      && ((flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0
	  || (flags & SEC_NEVER_LOAD) != 0))
@


1.518
log
@	PR binutils/11953
	* elf.c (copy_elf_program_header): Calculate map->header_size
	from lowest_section, not first_section.  Validate program
	header p_paddr against section lma.  Find lowest_section in
	second loop over headers.
@
text
@d4484 3
a4486 2
	      if (s_start < p_end
		  || p_end < p_start)
@


1.517
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d5873 1
a5873 1
      asection *lowest_section = NULL;
d5883 2
a5884 4
	      if (!first_section)
		first_section = lowest_section = section;
	      if (section->lma < lowest_section->lma)
		lowest_section = section;
d5938 1
a5938 11
      if (map->includes_filehdr && first_section)
	/* We need to keep the space used by the headers fixed.  */
	map->header_size = first_section->vma - segment->p_vaddr;
      
      if (!map->includes_phdrs
	  && !map->includes_filehdr
	  && map->p_paddr_valid)
	/* There is some other padding before the first section.  */
	map->p_vaddr_offset = ((lowest_section ? lowest_section->lma : 0)
			       - segment->p_paddr);

d5951 18
d5975 11
@


1.516
log
@	* elf.c (_bfd_elf_map_sections_to_segments): Don't load program
	headers if any loaded section wraps the address space.  Simplify
	~(m-1) to -m.  Use lma rather than vma when determining whether
	note sections are adjacent.
@
text
@d253 1
a253 1
bfd_elf_make_generic_object (bfd *abfd)
d255 1
d257 1
a257 1
				  GENERIC_ELF_DATA);
d264 1
a264 1
  return bfd_elf_make_generic_object (abfd);
@


1.515
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d3627 1
d3636 6
d3649 3
d3721 4
a3724 2
	      || sections[0]->lma < phdr_size
	      || sections[0]->lma % maxpagesize < phdr_size % maxpagesize)
d3789 2
a3790 3
		   && (((last_hdr->lma + last_size - 1)
			& ~(maxpagesize - 1))
		       != (hdr->lma & ~(maxpagesize - 1))))
d3897 2
a3898 2
			&& align_power (s2->vma + s2->size, 2)
			   == s2->next->vma)
@


1.514
log
@	PR 11866
	* elf.c (assign_file_positions_for_load_sections): Use p_vaddr to
	calculate off_adjust rather than first section vma.
@
text
@d7522 2
a7523 1
/* FIXME: this is kinda wrong, but it's what gdb wants.  */
d7528 7
a7534 2
  return ((elf_tdata (abfd)->core_lwpid << 16)
	  + (elf_tdata (abfd)->core_pid));
d7624 2
a7625 1
      elf_tdata (abfd)->core_pid = prstat.pr_pid;
d7635 2
d7653 2
a7654 1
      elf_tdata (abfd)->core_pid = prstat.pr_pid;
d7664 2
@


1.513
log
@include/elf/
	* internal.h (ELF_TBSS_SPECIAL): New macro, extracted from..
	(ELF_SECTION_SIZE): ..here.
	(ELF_SECTION_IN_SEGMENT_1): Add "strict" arg.
	(ELF_SECTION_IN_SEGMENT_STRICT): New macro.
bfd/
	* elf.c (assign_file_positions_for_load_sections): Check that
	zero size sections are allocated in segments too.
	(assign_file_positions_for_non_load_sections): Warn if zero
	size alloc sections are found here.
	(copy_elf_program_header): Don't drop zero size sections from
	segment map.
	(copy_private_bfd_data): Check for changes in zero size sections.
binutils/
	* readelf.c (process_program_headers): Don't ignore all zero size
	sections.
ld/testsuite/
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@d4340 1
a4340 1
	  off_adjust = vma_page_aligned_bias (m->sections[0]->vma, off, align);
@


1.512
log
@	* elf.c (_bfd_elf_map_sections_to_segments): Force new segment
	for sections with overlapping LMAs.
	(assign_file_positions_for_load_sections): Catch overlap for
	sections that wrap around the address space.  Replace a
	warning that duplicates ld's --check-sections error with a
	warning that lma has been adjusted for overlapping sections.
@
text
@d4592 1
a4592 2
	      if (this_hdr->sh_size != 0
		  && !ELF_SECTION_IN_SEGMENT_1 (this_hdr, p, check_vma))
d4642 6
a4647 7
	  if (hdr->sh_size != 0)
	    ((*_bfd_error_handler)
	     (_("%B: warning: allocated section `%s' not in segment"),
	      abfd,
	      (hdr->bfd_section == NULL
	       ? "*unknown*"
	       : hdr->bfd_section->name)));
d5869 1
a5869 2
	  if (this_hdr->sh_size != 0
	      && ELF_SECTION_IN_SEGMENT (this_hdr, segment))
d5948 1
a5948 2
	      if (this_hdr->sh_size != 0
		  && ELF_SECTION_IN_SEGMENT (this_hdr, segment))
d6025 1
a6025 2
	      if (this_hdr->sh_size != 0
		  && ELF_SECTION_IN_SEGMENT (this_hdr, segment))
@


1.511
log
@Implement generic SHF_EXCLUDE.

bfd/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* elf.c (_bfd_elf_make_section_from_shdr): Handle SHF_EXCLUDE
	(elf_fake_sections): Likewise.

	* elf32-i370.c (i370_elf_section_from_shdr): Don't handle
	SHF_EXCLUDE here.
	* elf32-ppc.c (ppc_elf_fake_sections): Likewise.

binutils/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* readelf.c (get_elf_section_flags): Treat SHF_EXCLUDE as a
	generic flag.

binutils/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* binutils-all/objcopy.exp: Run exclude-1a and exclude-1b for
	ELF targets.

	* binutils-all/exclude-1.s: New.
	* binutils-all/exclude-1a.d: Likewise.
	* binutils-all/exclude-1b.d: Likewise.

gas/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* obj-elf.c (obj_elf_change_section): Handle SHF_EXCLUDE.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.

	* config/tc-ppc.c (ppc_section_letter): Removed.
	(ppc_section_word): Likewise.
	* config/tc-ppc.h (ppc_section_letter): Likewise.
	(ppc_section_word): Likewise.
	(md_elf_section_letter): Likewise.
	(md_elf_section_word): Likewise.

	* doc/as.texinfo: Document `e' and `#exclude'.

gas/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* gas/elf/elf.exp: Run section8.

	* gas/elf/section8.d: New.
	* gas/elf/section8.s: Likewise.

include/elf/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* common.h (SHF_EXCLUDE): New.

	* i370.h (SHF_EXCLUDE): Removed.
	* or32.h (SHF_EXCLUDE): Likewise.
	* ppc.h (SHF_EXCLUDE): Likewise.
	* sparc.h (SHF_EXCLUDE): Likewise.

ld/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* ld-elf/exclude3.s: New.
	* ld-elf/exclude3a.d: Likewise.
	* ld-elf/exclude3b.d: Likewise.
	* ld-elf/exclude3c.d: Likewise.
@
text
@d3739 7
d4467 4
a4470 1
	      bfd_vma adjust = sec->lma - (p->p_paddr + p->p_memsz);
d4472 2
a4473 1
	      if (sec->lma < p->p_paddr + p->p_memsz)
d4476 2
a4477 2
		    (_("%B: section %A lma 0x%lx overlaps previous sections"),
		     abfd, sec, (unsigned long) sec->lma);
d4479 1
a4479 1
		  sec->lma = p->p_paddr + p->p_memsz;
@


1.510
log
@include/elf/
	* internal.h (ELF_SECTION_SIZE): Protect macro args with parentheses.
	Invert logic to clarify test for .tbss.
	(ELF_IS_SECTION_IN_SEGMENT): Rename to..
	(ELF_SECTION_IN_SEGMENT_1): ..this.  Add check_vma param.  Protect
	macro args with parentheses.
	(ELF_SECTION_IN_SEGMENT): Define.
	(ELF_IS_SECTION_IN_SEGMENT_FILE): Delete.
	(ELF_IS_SECTION_IN_SEGMENT_MEMORY): Delete.
bfd/
	* elf.c: Replace use of ELF_IS_SECTION_IN_SEGMENT and
	ELF_IS_SECTION_IN_SEGMENT_FILE with ELF_SECTION_IN_SEGMENT
	throughout file.
	(assign_file_positions_for_load_sections): Modify section in
	segment warning to ignore overlay vmas.
	* elf32-spu.c (spu_elf_object_p): Replace use of
	ELF_IS_SECTION_IN_SEGMENT_MEMORY with ELF_SECTION_IN_SEGMENT.
binutils/
	* readelf.c (process_program_headers): Replace use of
	ELF_IS_SECTION_IN_SEGMENT_MEMORY with ELF_SECTION_IN_SEGMENT.
@
text
@d879 2
d2632 2
@


1.509
log
@bfd/
	* elf.c (assign_file_positions_for_load_sections): Revert 2008-05-29
	change.  Tidy.  Don't error on sections not allocated in segment.
ld/testsuite/
	* ld-elf/extract-symbol-1sec.d: Update lma.
	* ld-i386/alloc.d: Expect a warning, not an error.
@
text
@d981 1
a981 1
	      && ELF_IS_SECTION_IN_SEGMENT (hdr, phdr))
d4555 2
a4556 4
	for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
	  {
	    Elf_Internal_Shdr *this_hdr;
	    asection *sec;
d4558 6
a4563 4
	    sec = *secpp;
	    this_hdr = &(elf_section_data(sec)->this_hdr);
	    if (this_hdr->sh_size != 0
		&& !ELF_IS_SECTION_IN_SEGMENT_FILE (this_hdr, p))
d4565 3
a4567 4
		(*_bfd_error_handler)
		  (_("%B: section `%A' can't be allocated in segment %d"),
		   abfd, sec, j);
		print_segment_map (m);
d4569 18
a4586 1
	  }
d5856 2
a5857 1
	  if (ELF_IS_SECTION_IN_SEGMENT_FILE (this_hdr, segment))
d5936 2
a5937 1
	      if (ELF_IS_SECTION_IN_SEGMENT_FILE (this_hdr, segment))
d6014 2
a6015 1
	      if (ELF_IS_SECTION_IN_SEGMENT_FILE (this_hdr, segment))
@


1.508
log
@Support 32bit core note sections on Linux/x86-64.

2010-04-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR corefiles/11467
	* configure.in (CORE_HEADER): New. Set to hosts/x86-64linux.h
	for x86_64-*-linux*.
	* config.in: Regenerated.
	* configure: Likewise.

	* elf.c: Include CORE_HEADER if it is defined.

2010-04-10  H.J. Lu  <hongjiu.lu@@intel.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* hosts/x86-64linux.h: New.
@
text
@d4456 1
a4456 1
	      bfd_signed_vma adjust = sec->vma - (p->p_vaddr + p->p_memsz);
d4458 1
a4458 1
	      if (sec->vma < p->p_vaddr + p->p_memsz)
d4461 2
a4462 2
		    (_("%B: section %A vma 0x%lx overlaps previous sections"),
		     abfd, sec, (unsigned long) sec->vma);
d4464 1
a4467 16
	      if (p->p_paddr + p->p_memsz != sec->lma)
		{
		  /* This behavior is a compromise--ld has long
		     silently changed the lma of sections when
		     lma - vma is not equal for every section in a
		     pheader--but only in the internal elf structures.
		     Silently changing the lma is probably a bug, but
		     changing it would have subtle and unknown
		     consequences for existing scripts.

		     Instead modify the bfd data structure to reflect
		     what happened.  This at least fixes the values
		     for the lma in the mapfile.  */
		  sec->lma = p->p_paddr + p->p_memsz;
		}

a4568 2
		bfd_set_error (bfd_error_bad_value);
		return FALSE;
@


1.507
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d48 4
@


1.506
log
@Avoid overflow.

2010-03-17  Jie Zhang  <jie@@codesourcery.com>

	* elf.c (assign_file_positions_for_load_sections): Avoid
	overflow.
@
text
@a1064 1

d4874 1
a4874 2
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
  Elf_Internal_Phdr *i_phdrp = 0; /* Program header table, internal form */
a4941 1
      i_phdrp = 0;
a4988 1
  Elf_Internal_Ehdr *i_ehdrp;
a4997 1
  i_ehdrp = elf_elfheader (abfd);
@


1.505
log
@bfd/
	PR ld/11304
	* elf.c (_bfd_elf_init_private_section_data): Rename need_group
	to final_link and invert.  For final link allow some flags to
	differ.  Don't specially allow flags to be all zero.
ld/
	* ldlang.c (init_os): Remove isec param.  Don't check for
	bfd_section already set or call bfd_init_private_section_data
	here.
	(exp_init_os): Update init_os call.
	(lang_add_section): Tidy.  Really don't set SEC_LINK_ONCE
	flags.  Call bfd_init_private_section_data here.
	(map_input_to_output_sections): Tidy.  Update init_os calls.
	Use os->sectype to select sec flags for lang_data_statement.
@
text
@d4455 1
a4455 1
	      if (adjust < 0)
@


1.504
log
@bfd/
	* elf.c (_bfd_elf_fixup_group_sections): New function, split out from..
	(_bfd_elf_copy_private_header_data): ..here.
	* elflink.c (_bfd_elf_size_group_sections): New function.
	(bfd_elf_size_dynamic_sections): Call it.
	* elf-bfd.h (_bfd_elf_size_group_sections): Declare.
	(_bfd_elf_fixup_group_sections): Declare.
ld/
	* ldlang.c (unique_section_p): Add os param.  Allow group
	sections to match /DISCARD/.  Update all callers.
	* emultempl/genelf.em (gld${EMULATION_NAME}_before_allocation): New.
	(LDEMUL_BEFORE_ALLOCATION): Define.
ld/testsuite/
	* ld-elf/group.ld: Discard .dropme sections.
	* ld-elf/group10.d, * ld-elf/group10.s: New test.
@
text
@d6059 1
a6059 1
  bfd_boolean need_group = link_info == NULL || link_info->relocatable;
d6065 4
a6068 4
  /* Don't copy the output ELF section type from input if the
     output BFD section flags have been set to something different.
     elf_fake_sections will set ELF section type based on BFD
     section flags.  */
d6070 4
a6073 1
      && (osec->flags == isec->flags || !osec->flags))
d6084 1
a6084 1
  if (need_group)
@


1.503
log
@	* elf.c (bfd_elf_set_group_contents): Revert accidental 2009-01-15
	commit.  Don't write zeros for removed group members.
	(_bfd_elf_copy_private_header_data): Adjust size of group section
	when group members are removed by objcopy.
@
text
@d6140 6
a6145 1
/* Copy private header information.  */
d6148 1
a6148 1
_bfd_elf_copy_private_header_data (bfd *ibfd, bfd *obfd)
a6151 15
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  */
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
      if (! copy_private_bfd_data (ibfd, obfd))
	return FALSE;
    }

d6157 2
d6164 2
a6165 2
	    if (s->output_section != NULL
		&& isec->output_section == NULL)
d6172 3
a6174 3
	    else if (s->output_section == NULL
		     && isec->output_section != NULL)
	      isec->output_section->size -= 4;
d6179 19
d6203 23
@


1.502
log
@bfd/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* elf-bfd.h (elfcore_write_s390_timer, elfcore_write_s390_todcmp,
	elfcore_write_s390_todpreg, elfcore_write_s390_ctrs,
	elfcore_write_s390_prefix): New.
	* elf.c (elfcore_write_s390_timer, elfcore_write_s390_todcmp,
	elfcore_write_s390_todpreg, elfcore_write_s390_ctrs,
	elfcore_write_s390_prefix): New.
	(elfcore_grok_note): Handle NT_S390_TIMER, NT_S390_TODCMP,
	NT_S390_TODPREG, NT_S390_CTRS and NT_S390_PREFIX.
	(elfcore_write_register_note): Handle .reg-s390-timer,
	.reg-s390-todcmp, .reg-s390-todpreg, .reg-s390-ctrs,
	.reg-s390-prefix section.

binutils/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* readelf.c (get_note_type): Handle NT_S390_TIMER, NT_S390_TODCMP,
	NT_S390_TODPREG, NT_S390_CTRS and NT_S390_PREFIX.

include/elf/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* common.h (NT_S390_TIMER, NT_S390_TODCMP, NT_S390_TODPREG,
	NT_S390_CTRS and NT_S390_PREFIX): Define.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a2745 1
      unsigned int idx;
d2748 4
a2751 1
      if (! elf_discarded_section (s))
d2753 2
a2755 5
	  if (!gas)
	    s = s->output_section;
	  idx = 0;
	  if (s != NULL)
	    idx = elf_section_data (s)->this_idx;
a6161 2
  /* _bfd_elf_copy_private_section_data copied over the SHF_GROUP flag
     but this might be wrong if we deleted the group section.  */
d6163 1
a6163 2
    if (elf_section_type (isec) == SHT_GROUP
	&& isec->output_section == NULL)
d6169 5
a6173 1
	    if (s->output_section != NULL)
d6178 5
@


1.501
log
@2010-02-05  Sterling Augustine  <sterling@@tensilica.com>

	* elf.c (assign_file_positions_for_load_sections) Update lma of
	section	if necessary.
@
text
@d7675 30
d8083 35
d8783 60
d8862 10
@


1.500
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d4465 16
@


1.499
log
@Add NT_386_XSTATE.

bfd/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elfcore_write_xstatereg): New.

	* elf.c (elfcore_grok_xstatereg): New.
	(elfcore_write_xstatereg): Likewise.
	(elfcore_grok_note): Handle NT_X86_XSTATE.
	(elfcore_write_register_note): Handle .reg-xstate section.

binutils/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (get_note_type): Handle NT_X86_XSTATE.

include/elf/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (NT_386_XSTATE): New.
@
text
@d235 1
a235 1
			 enum elf_object_id object_id)
d252 1
a252 1
				  GENERIC_ELF_TDATA);
@


1.498
log
@core files: wrong signal number with threaded program on sparc-solaris.

        * elf.c (elfcore_grok_lwpstatus): Do not overwrite the core signal
        if it has already been set.
@
text
@d7631 10
d8009 7
d8656 9
d8713 2
@


1.497
log
@2010-01-04  Daniel Gutson  <dgutson@@codesourcery.com>

        * bfd.m4 (BFD_HAVE_SYS_PROCFS_TYPE): Define _STRUCTURE_PROC
        before including procfs.h.
        (BFD_HAVE_SYS_PROCFS_TYPE_MEMBER): Likewise.
        * configure.in: Added autoconf probe for the pr_fpreg member.
        * configure: Regenerated.
        * config.in: Regenerated.
        * elf.c: Define _STRUCTURE_PROC before including procfs.h.
@
text
@d7803 4
a7806 1
  elf_tdata (abfd)->core_signal = lwpstat.pr_cursig;
@


1.496
log
@include/elf/
	* common.h (NT_S390_HIGH_GPRS): Define.

bfd/
	* elf.c (elfcore_grok_s390_high_gprs): New function.
	(elfcore_grok_note): Handle NT_S390_HIGH_GPRS notes.
	(elfcore_write_s390_high_gprs): New function.
	(elfcore_write_register_note): Call it.

binutils/
	* readelf.c (get_note_type): Handle NT_S390_HIGH_GPRS notes.
@
text
@d7448 2
@


1.495
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d7641 6
d8008 7
d8657 13
d8686 2
@


1.494
log
@	* elf.c (write_zeros): New function.
	(assign_file_positions_for_load_sections): Allocate file space for
	NOBITS sections that are followed by PROGBITS sections in a segment.
@
text
@d737 1
a737 1
	      asection *link = NULL;
d742 1
a742 1
		  link = this_hdr->bfd_section;
d748 1
a748 1
	      if (link == NULL)
d756 1
a756 1
	      elf_linked_to_section (s) = link;
d1964 1
a1964 1
bfd_section_from_elf_index (bfd *abfd, unsigned int index)
d1966 1
a1966 1
  if (index >= elf_numsections (abfd))
d1968 1
a1968 1
  return elf_elfsections (abfd)[index]->bfd_section;
d2269 1
a2269 1
				 int index,
d2284 1
a2284 1
      sprintf (namebuf, "%s%d%s", type_name, index, split ? "a" : "");
d2320 1
a2320 1
      sprintf (namebuf, "%s%d%s", type_name, index, split ? "b" : "");
d2359 1
a2359 1
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index)
d2366 1
a2366 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "null");
d2369 1
a2369 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "load");
d2372 1
a2372 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "dynamic");
d2375 1
a2375 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "interp");
d2378 1
a2378 1
      if (! _bfd_elf_make_section_from_phdr (abfd, hdr, index, "note"))
d2385 1
a2385 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "shlib");
d2388 1
a2388 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "phdr");
d2391 1
a2391 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
d2395 1
a2395 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");
d2398 1
a2398 1
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "relro");
d2403 1
a2403 1
      return bed->elf_backend_section_from_phdr (abfd, hdr, index, "proc");
a2896 1
      struct bfd_elf_section_data *d = elf_section_data (sec);
d2900 2
d3864 2
a3865 1
	      unsigned count = 1;
a3907 2
	  int i;

d3919 1
a3919 1
	  for (i = 0; i < tls_count; ++i)
d5045 1
a5045 1
  unsigned int index;
d5052 1
a5052 1
    index = SHN_ABS;
d5054 1
a5054 1
    index = SHN_COMMON;
d5056 1
a5056 1
    index = SHN_UNDEF;
d5058 1
a5058 1
    index = SHN_BAD;
d5063 1
a5063 1
      int retval = index;
d5069 1
a5069 1
  if (index == SHN_BAD)
d5072 1
a5072 1
  return index;
d9014 1
a9014 1
	  int len;
@


1.493
log
@        PR 10478
        * elf.c (bfd_section_from_shdr): Allow SHN_BEFORE and SHN_AFTER
        section link values in x86 binaries.
        * elfcode.h (elf_object_p): Likewise.
        * readelf.c (get_elf_section_flags): Allow SHN_BEFORE and
        SHN_AFTER section link values in x86 binaries.
        (process_section_headers): Likewise.
@
text
@d4130 16
d4467 9
@


1.492
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d1521 1
a1521 1
	  /* PR 10478: Accept sparc binaries with a sh_link
d1525 1
@


1.491
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d286 1
a286 1
	  || (shstrtab = bfd_alloc (abfd, shstrtabsize + 1)) == NULL
d410 2
a411 2
	  alloc_extshndx = bfd_malloc2 (symcount,
					sizeof (Elf_External_Sym_Shndx));
d425 2
a426 1
      alloc_intsym = bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));
d434 2
a435 1
  for (esym = extsym_buf, isym = intsym_buf, shndx = extshndx_buf;
d569 2
a570 2
	  elf_tdata (abfd)->group_sect_ptr
	    = bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));
d591 2
a592 2
		  shdr->contents = bfd_alloc2 (abfd, shdr->sh_size,
					       sizeof (*dest) / 4);
d1096 1
a1096 1
  FILE *f = farg;
d1339 1
a1339 1
  FILE *file = filep;
d1794 1
a1794 1
	    hdr2 = bfd_alloc (abfd, amt);
d2212 2
a2213 1
      sdata = bfd_zalloc (abfd, sizeof (*sdata));
d2269 1
a2269 1
				 const char *typename)
d2283 1
a2283 1
      sprintf (namebuf, "%s%d%s", typename, index, split ? "a" : "");
d2285 1
a2285 1
      name = bfd_alloc (abfd, len);
d2319 1
a2319 1
      sprintf (namebuf, "%s%d%s", typename, index, split ? "b" : "");
d2321 1
a2321 1
      name = bfd_alloc (abfd, len);
d2420 1
a2420 1
  name = bfd_alloc (abfd, amt);
d2460 1
a2460 1
  bfd_boolean *failedptr = failedptrarg;
d2660 1
a2660 1
  bfd_boolean *failedptr = failedptrarg;
d2720 1
a2720 1
      sec->contents = bfd_alloc (abfd, sec->size);
d2866 2
a2867 1
  i_shdrp = bfd_zalloc2 (abfd, section_number, sizeof (Elf_Internal_Shdr *));
d2871 2
a2872 1
  i_shdrp[0] = bfd_zalloc (abfd, sizeof (Elf_Internal_Shdr));
d3021 1
a3021 1
	      alc = bfd_malloc (len - 2);
d3141 1
a3141 1
  sect_syms = bfd_zalloc2 (abfd, max_index, sizeof (asymbol *));
d3193 2
a3194 1
  new_syms = bfd_alloc2 (abfd, num_locals + num_globals, sizeof (asymbol *));
d3503 1
a3503 1
  m = bfd_zalloc (abfd, amt);
d3530 2
a3531 1
  m = bfd_zalloc (abfd, sizeof (struct elf_segment_map));
d3622 2
a3623 1
      sections = bfd_malloc2 (bfd_count_sections (abfd), sizeof (asection *));
d3653 1
a3653 1
	  m = bfd_zalloc (abfd, amt);
d3667 1
a3667 1
	  m = bfd_zalloc (abfd, amt);
d3877 1
a3877 1
	      m = bfd_zalloc (abfd, amt);
d3909 1
a3909 1
	  m = bfd_zalloc (abfd, amt);
d3936 1
a3936 1
	  m = bfd_zalloc (abfd, amt);
d3951 1
a3951 1
	  m = bfd_zalloc (abfd, amt);
d3984 1
a3984 1
	      m = bfd_zalloc (abfd, amt);
d4186 4
a4189 4
  phdrs = bfd_zalloc2 (abfd,
		       (elf_tdata (abfd)->program_header_size
			/ bed->s->sizeof_phdr),
		       sizeof (Elf_Internal_Phdr));
d5381 1
a5381 1
      map = bfd_zalloc (obfd, amt);
d5465 1
a5465 1
      sections = bfd_malloc2 (section_count, sizeof (asection *));
d5711 1
a5711 1
	      map = bfd_alloc (obfd, amt);
d5832 1
a5832 1
      map = bfd_zalloc (obfd, amt);
d6236 2
a6237 1
  outbound_syms = bfd_alloc2 (abfd, 1 + symcount, bed->s->sizeof_sym);
d6250 2
a6251 2
      outbound_shndx = bfd_zalloc2 (abfd, 1 + symcount,
				    sizeof (Elf_External_Sym_Shndx));
d6689 2
a6690 2
      elf_tdata (abfd)->verref = bfd_zalloc2 (abfd, hdr->sh_info,
					      sizeof (Elf_Internal_Verneed));
d6696 1
a6696 1
      contents = bfd_malloc (hdr->sh_size);
d6736 3
a6738 2
	      iverneed->vn_auxptr = bfd_alloc2 (abfd, iverneed->vn_cnt,
						sizeof (Elf_Internal_Vernaux));
d6806 1
a6806 1
      contents = bfd_malloc (hdr->sh_size);
d6850 2
a6851 2
      elf_tdata (abfd)->verdef = bfd_zalloc2 (abfd, maxidx,
					      sizeof (Elf_Internal_Verdef));
d6884 3
a6886 2
	      iverdef->vd_auxptr = bfd_alloc2 (abfd, iverdef->vd_cnt,
					       sizeof (Elf_Internal_Verdaux));
d6943 2
a6944 2
      elf_tdata (abfd)->verdef = bfd_zalloc2 (abfd, freeidx,
					      sizeof (Elf_Internal_Verdef));
d6970 2
a6971 1
      iverdef->vd_auxptr = bfd_alloc (abfd, sizeof (Elf_Internal_Verdaux));
d6994 1
a6994 1
  newsym = bfd_zalloc (abfd, amt);
d7479 1
a7479 1
  threaded_name = bfd_alloc (abfd, len);
d7637 1
a7637 1
  char *end = memchr (start, '\0', max);
d7645 1
a7645 1
  dups = bfd_alloc (abfd, len + 1);
d7865 1
a7865 1
      name = bfd_alloc (abfd, len);
d7896 1
a7896 1
      name = bfd_alloc (abfd, len);
d8007 1
a8007 1
  elf_tdata (abfd)->build_id = bfd_alloc (abfd, note->descsz);
d8226 1
a8226 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d8255 1
a8255 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d8312 1
a8312 1
  name = bfd_alloc (abfd, len);
d8366 1
a8366 1
  buf = realloc (buf, *bufsiz + newspace);
d8726 1
a8726 1
  buf = bfd_malloc (size);
d8956 1
a8956 1
  s = *ret = bfd_malloc (size);
@


1.490
log
@bfd/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* elf-bfd.h (bfd_elf_get_default_section_type): Declare.
	* elf.c (bfd_elf_get_default_section_type): New.
	(elf_fake_sections): Use bfd_elf_get_default_section_type.

gas/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* config/obj-elf.c (obj_elf_change_section): Set default type
	by calling bfd_elf_get_default_section_type.

gas/testsuite/
2009-08-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/section5.l: Remove no longer issued warning pattern.
@
text
@d1517 16
a1532 2
      if (hdr->sh_link > elf_numsections (abfd)
	  || elf_elfsections (abfd)[hdr->sh_link] == NULL)
d1534 1
a1534 1
      if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
@


1.490.2.1
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d1517 2
a1518 16
      if (hdr->sh_link > elf_numsections (abfd))
	{
	  /* PR 10478: Accept sparc binaries with a sh_link
	     field set to SHN_BEFORE or SHN_AFTER.  */
	  switch (bfd_get_arch (abfd))
	    {
	    case bfd_arch_sparc:
	      if (hdr->sh_link == (SHN_LORESERVE & 0xffff) /* SHN_BEFORE */
		  || hdr->sh_link == ((SHN_LORESERVE + 1) & 0xffff) /* SHN_AFTER */)
		break;
	      /* Otherwise fall through.  */
	    default:
	      return FALSE;
	    }
	}
      else if (elf_elfsections (abfd)[hdr->sh_link] == NULL)
d1520 1
a1520 1
      else if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
@


1.490.2.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d286 1
a286 1
	  || (shstrtab = (bfd_byte *) bfd_alloc (abfd, shstrtabsize + 1)) == NULL
d410 2
a411 2
	  alloc_extshndx = (Elf_External_Sym_Shndx *)
              bfd_malloc2 (symcount, sizeof (Elf_External_Sym_Shndx));
d425 1
a425 2
      alloc_intsym = (Elf_Internal_Sym *)
          bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));
d433 1
a433 2
  for (esym = (const bfd_byte *) extsym_buf, isym = intsym_buf,
           shndx = extshndx_buf;
d567 2
a568 2
	  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)
              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));
d589 2
a590 2
		  shdr->contents = (unsigned char *)
                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);
d1094 1
a1094 1
  FILE *f = (FILE *) farg;
d1337 1
a1337 1
  FILE *file = (FILE *) filep;
d1792 1
a1792 1
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d2210 1
a2210 2
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd,
                                                          sizeof (*sdata));
d2266 1
a2266 1
				 const char *type_name)
d2280 1
a2280 1
      sprintf (namebuf, "%s%d%s", type_name, index, split ? "a" : "");
d2282 1
a2282 1
      name = (char *) bfd_alloc (abfd, len);
d2316 1
a2316 1
      sprintf (namebuf, "%s%d%s", type_name, index, split ? "b" : "");
d2318 1
a2318 1
      name = (char *) bfd_alloc (abfd, len);
d2417 1
a2417 1
  name = (char *) bfd_alloc (abfd, amt);
d2457 1
a2457 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2657 1
a2657 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2717 1
a2717 1
      sec->contents = (unsigned char *) bfd_alloc (abfd, sec->size);
d2863 1
a2863 2
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,
                                                sizeof (Elf_Internal_Shdr *));
d2867 1
a2867 2
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd,
                                                 sizeof (Elf_Internal_Shdr));
d3016 1
a3016 1
	      alc = (char *) bfd_malloc (len - 2);
d3136 1
a3136 1
  sect_syms = (asymbol **) bfd_zalloc2 (abfd, max_index, sizeof (asymbol *));
d3188 1
a3188 2
  new_syms = (asymbol **) bfd_alloc2 (abfd, num_locals + num_globals,
                                      sizeof (asymbol *));
d3497 1
a3497 1
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3524 1
a3524 2
  m = (struct elf_segment_map *) bfd_zalloc (abfd,
                                             sizeof (struct elf_segment_map));
d3615 1
a3615 2
      sections = (asection **) bfd_malloc2 (bfd_count_sections (abfd),
                                            sizeof (asection *));
d3645 1
a3645 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3659 1
a3659 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3869 1
a3869 1
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3901 1
a3901 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3928 1
a3928 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3943 1
a3943 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3976 1
a3976 1
	      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d4178 4
a4181 4
  phdrs = (Elf_Internal_Phdr *)
     bfd_zalloc2 (abfd,
                  (elf_tdata (abfd)->program_header_size / bed->s->sizeof_phdr),
                  sizeof (Elf_Internal_Phdr));
d5373 1
a5373 1
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
d5457 1
a5457 1
      sections = (asection **) bfd_malloc2 (section_count, sizeof (asection *));
d5703 1
a5703 1
	      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d5824 1
a5824 1
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
d6228 1
a6228 2
  outbound_syms = (bfd_byte *) bfd_alloc2 (abfd, 1 + symcount,
                                           bed->s->sizeof_sym);
d6241 2
a6242 2
      outbound_shndx =  (bfd_byte *)
          bfd_zalloc2 (abfd, 1 + symcount, sizeof (Elf_External_Sym_Shndx));
d6680 2
a6681 2
      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)
          bfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));
d6687 1
a6687 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d6727 2
a6728 3
	      iverneed->vn_auxptr = (struct elf_internal_vernaux *)
                  bfd_alloc2 (abfd, iverneed->vn_cnt,
                              sizeof (Elf_Internal_Vernaux));
d6796 1
a6796 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d6840 2
a6841 2
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
          bfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));
d6874 2
a6875 3
	      iverdef->vd_auxptr = (struct elf_internal_verdaux *)
                  bfd_alloc2 (abfd, iverdef->vd_cnt,
                              sizeof (Elf_Internal_Verdaux));
d6932 2
a6933 2
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)
          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));
d6959 1
a6959 2
      iverdef->vd_auxptr = (struct elf_internal_verdaux *)
          bfd_alloc (abfd, sizeof (Elf_Internal_Verdaux));
d6982 1
a6982 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d7467 1
a7467 1
  threaded_name = (char *) bfd_alloc (abfd, len);
d7625 1
a7625 1
  char *end = (char *) memchr (start, '\0', max);
d7633 1
a7633 1
  dups = (char *) bfd_alloc (abfd, len + 1);
d7853 1
a7853 1
      name = (char *) bfd_alloc (abfd, len);
d7884 1
a7884 1
      name = (char *) bfd_alloc (abfd, len);
d7995 1
a7995 1
  elf_tdata (abfd)->build_id = (bfd_byte *) bfd_alloc (abfd, note->descsz);
d8214 1
a8214 1
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
d8243 1
a8243 1
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
d8300 1
a8300 1
  name = (char *) bfd_alloc (abfd, len);
d8354 1
a8354 1
  buf = (char *) realloc (buf, *bufsiz + newspace);
d8714 1
a8714 1
  buf = (char *) bfd_malloc (size);
d8944 1
a8944 1
  s = *ret = (asymbol *) bfd_malloc (size);
@


1.489
log
@	PR 10494
	* elf.c (_bfd_elf_make_section_from_shdr): When setting up section
	LMAs, use ELF_IS_SECTION_IN_SEGMENT to match sections with headers.
@
text
@d2425 12
a2485 4
  else if ((asect->flags & SEC_ALLOC) != 0
	   && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	       || (asect->flags & SEC_NEVER_LOAD) != 0))
    sh_type = SHT_NOBITS;
d2487 1
a2487 1
    sh_type = SHT_PROGBITS;
@


1.488
log
@	PR binutils/10492
	* elf.c (sym_is_global): Return true even for BSF_GNU_UNIQUE
	symbols.
	* elf32-mips.c (mips_elf_sym_is_global): Likewise.
	* elfn32-mips.c (mips_elf_sym_is_global): Likewise.
@
text
@a973 12
	  /* This section is part of this segment if its file
	     offset plus size lies within the segment's memory
	     span and, if the section is loaded, the extent of the
	     loaded data lies within the extent of the segment.

	     Note - we used to check the p_paddr field as well, and
	     refuse to set the LMA if it was 0.  This is wrong
	     though, as a perfectly valid initialised segment can
	     have a p_paddr of zero.  Some architectures, eg ARM,
	     place special significance on the address 0 and
	     executables need to be able to have a segment which
	     covers this address.  */
d975 1
a975 6
	      && (bfd_vma) hdr->sh_offset >= phdr->p_offset
	      && (hdr->sh_offset + hdr->sh_size
		  <= phdr->p_offset + phdr->p_memsz)
	      && ((flags & SEC_LOAD) == 0
		  || (hdr->sh_offset + hdr->sh_size
		      <= phdr->p_offset + phdr->p_filesz)))
@


1.487
log
@2009-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10363
	* elf.c (bfd_elf_string_from_elf_section): Return NULL on
	invalid string offset.
@
text
@d3087 1
a3087 1
  return ((sym->flags & (BSF_GLOBAL | BSF_WEAK)) != 0
@


1.486
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d334 1
a334 1
      return "";
@


1.485
log
@bfd/

2009-07-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_get_synthetic_symtab): Remove leading zeros
	when reporting  addends.


ld/testsuite/

2009-07-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc-1-local-x86.d: Updated.
	* ld-ifunc/ifunc-1-x86.d: Likewise.Likewise.
	* ld-ifunc/ifunc-2-local-x86-64.d: Likewise.Likewise.
	* ld-ifunc/ifunc-2-x86-64.d: Likewise.
	* ld-ifunc/ifunc-3a-x86.d: Likewise.Likewise.
@
text
@d6449 2
@


1.484
log
@	* elf.c (_bfd_elf_get_synthetic_symtab): Report addends.
@
text
@d8968 2
d8972 6
a8977 2
	  bfd_sprintf_vma (abfd, names, p->addend);
	  names += strlen (names);
@


1.483
log
@bfd/

2009-06-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10337
	* elf.c (bfd_section_from_shdr): Don't change sh_link for
	SHT_REL/SHT_RELA sections on executable nor shared library.
	Treat SHT_REL/SHT_RELA sections with sh_link set to SHN_UNDEF
	as a normal section.

ld/testsuite/

2009-06-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10337
	* ld-ifunc/binutils.exp: New.
@
text
@d8925 11
a8935 1
    size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
d8966 7
@


1.482
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d1731 5
a1735 2
	   to it.  I hope this doesn't break anything.  */
	if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_SYMTAB
d1770 2
a1771 1
	   section, an invalid section, or another reloc section.  */
d1773 1
@


1.481
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d1924 1
a1924 2
/* Return the section for the local symbol specified by ABFD, R_SYMNDX.
   Return SEC for sections that have no elf section, and NULL on error.  */
d1926 4
a1929 5
asection *
bfd_section_from_r_symndx (bfd *abfd,
			   struct sym_sec_cache *cache,
			   asection *sec,
			   unsigned long r_symndx)
a1931 1
  asection *s;
a1937 1
      Elf_Internal_Sym isym;
d1941 1
a1941 1
				&isym, esym, &eshndx) == NULL)
a1949 1
      cache->shndx[ent] = isym.st_shndx;
d1952 1
a1952 5
  s = bfd_section_from_elf_index (abfd, cache->shndx[ent]);
  if (s != NULL)
    return s;

  return sec;
@


1.480
log
@	PR 6494
	* elf.c (copy_elf_program_header): Do not check that PT_GNU_RELRO
	p_filesz and p_memsz are equal.  Use p_memsz as the segment size.
	(assign_file_positions_for_non_load_sections): Zap PT_GNU_RELRO
	if we don't find matching PT_LOAD when copying.
@
text
@d6402 2
d8982 7
d8994 1
a8994 1
   most targets.  It returns true if TYPE is STT_FUNC.  */
d8999 2
a9000 1
  return (type == STT_FUNC);
@


1.479
log
@* elf.c (elfcore_grok_openbsd_procinfo)
(elfcore_grok_openbsd_note): New functions.
(elf_parse_notes): Handle notes from OpenBSD ELF core files.
@
text
@d4686 1
a4686 1
	  else if (link_info != NULL)
a4690 2
	  else
	    abort ();
d5839 1
a5839 2
      if (map->p_type == PT_GNU_RELRO
	  && segment->p_filesz == segment->p_memsz)
d5845 1
a5845 1
	  map->p_size = segment->p_filesz;
@


1.478
log
@bfd/

2009-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9945
	* elf.c (assign_section_numbers): Generate symbol table if there
	is any relocation in output.
	(_bfd_elf_compute_section_file_positions): Likewise.

binutils/

2009-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9945
	* objcopy.c (copy_object): Clear HAS_RELOC when stripping all.
@
text
@d8114 64
d8664 5
@


1.477
log
@2009-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (elf_find_function): Use is_function_type to check
	function symbol.
@
text
@d2777 1
d2833 5
a2837 1
  if (bfd_get_symcount (abfd) > 0)
d2876 1
a2876 1
  if (bfd_get_symcount (abfd) > 0)
d3269 1
d3294 5
a3298 1
  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
d3329 1
a3329 1
  if (link_info == NULL && bfd_get_symcount (abfd) > 0)
@


1.476
log
@	* elf-bfd.h (bfd_elf_get_str_section): Don't declare.
	(bfd_elf_find_section, _sh_elf_set_mach_from_flags): Likewise.
	* elf.c (bfd_elf_get_str_section): Make static.
	(bfd_elf_find_section): Delete.
	* libbfd.h: Regenerate.
@
text
@d7044 1
a7044 1
elf_find_function (bfd *abfd ATTRIBUTE_UNUSED,
d7064 1
d7075 1
d7079 2
a7080 1
      switch (ELF_ST_TYPE (q->internal_elf_sym.st_info))
a7081 2
	default:
	  break;
d7087 3
a7090 1
	case STT_FUNC:
@


1.475
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d262 1
a262 1
char *
a1022 39
/*
INTERNAL_FUNCTION
	bfd_elf_find_section

SYNOPSIS
	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);

DESCRIPTION
	Helper functions for GDB to locate the string tables.
	Since BFD hides string tables from callers, GDB needs to use an
	internal hook to find them.  Sun's .stabstr, in particular,
	isn't even pointed to by the .stab section, so ordinary
	mechanisms wouldn't work to find it, even if we had some.
*/

struct elf_internal_shdr *
bfd_elf_find_section (bfd *abfd, char *name)
{
  Elf_Internal_Shdr **i_shdrp;
  char *shstrtab;
  unsigned int max;
  unsigned int i;

  i_shdrp = elf_elfsections (abfd);
  if (i_shdrp != NULL)
    {
      shstrtab = bfd_elf_get_str_section (abfd,
					  elf_elfheader (abfd)->e_shstrndx);
      if (shstrtab != NULL)
	{
	  max = elf_numsections (abfd);
	  for (i = 1; i < max; i++)
	    if (!strcmp (&shstrtab[i_shdrp[i]->sh_name], name))
	      return i_shdrp[i];
	}
    }
  return 0;
}

@


1.474
log
@Remove STT_IFUNC support.
@
text
@a2780 1
      loc -= 4;
d2782 10
a2791 6
      if (!gas)
	s = s->output_section;
      idx = 0;
      if (s != NULL)
	idx = elf_section_data (s)->this_idx;
      H_PUT_32 (abfd, idx, loc);
@


1.473
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a6429 2
      else if ((flags & BSF_INDIRECT_FUNCTION) != 0)
	type = STT_IFUNC;
a7122 1
	case STT_IFUNC:
d8941 1
a8941 1
   most targets.  It returns true if TYPE is STT_FUNC or STT_IFUNC.  */
d8946 1
a8946 1
  return (type == STT_FUNC || type == STT_IFUNC);
@


1.472
log
@        * elf.c (swap_out_syms) [USE_STT_COMMON]: Fix syntax error.
@
text
@d6430 2
d7125 1
d8944 1
a8944 1
   most targets.  It returns true if TYPE is STT_FUNC.  */
d8949 1
a8949 1
  return (type == STT_FUNC);
@


1.471
log
@        bfd/
        * elf.c (assign_file_positions_for_load_sections): Use header_size
        to avoid moving the load address of file headers.
        (assign_file_positions_for_load_sections): Set header_size for
        segments containing the file header.

        include/elf/
        * internal.h (struct elf_segment_map): Add header_size field.
@
text
@d6463 1
a6463 1
#else
a6464 1
#endif
@


1.470
log
@	PR ld/7028
	* elf.c (assign_file_positions_for_load_sections): Allocate phrds
	with bfd_zalloc2 instead of bfd_alloc2.  For the amount, use
	the possibly-preset header-size, not the computed one.
@
text
@d4161 1
d4169 5
a4173 1
    ++alloc;
d4216 5
d4408 5
d5895 4
@


1.469
log
@	PR 7023
	* elf.c (bfd_section_from_shdr <SHT_SYMTAB>): Fail on invalid sh_info.
@
text
@d4186 15
a4200 1
  phdrs = bfd_alloc2 (abfd, alloc, sizeof (Elf_Internal_Phdr));
@


1.468
log
@	* elf.c (assign_file_positions_for_non_load_sections): Consolidate
	PT_GNU_RELRO handling.
@
text
@d1611 2
@


1.467
log
@	PR 7011
	* elf.c (assign_file_positions_for_non_load_sections): Handle
	PT_GNU_RELRO specially.
@
text
@d4636 2
a4643 2
	      Elf_Internal_Phdr *lp;

a4646 1
		      && lp->p_vaddr <= link_info->relro_end
d4648 2
a4649 2
		      && (lp->p_vaddr + lp->p_filesz
			  >= link_info->relro_end))
a4651 17

	      if (lp < phdrs + count
		  && link_info->relro_end > lp->p_vaddr)
		{
		  p->p_vaddr = lp->p_vaddr;
		  p->p_paddr = lp->p_paddr;
		  p->p_offset = lp->p_offset;
		  p->p_filesz = link_info->relro_end - lp->p_vaddr;
		  p->p_memsz = p->p_filesz;
		  p->p_align = 1;
		  p->p_flags = (lp->p_flags & ~PF_W);
		}
	      else
		{
		  memset (p, 0, sizeof *p);
		  p->p_type = PT_NULL;
		}
d4656 1
a4656 3
		 library. But we need to use the same linker logic.  */
	      Elf_Internal_Phdr *lp;

d4663 11
a4673 15
	  
	      if (lp < phdrs + count)
		{
		  /* We should use p_size if it is valid since it
		     may contain the first few bytes of the next
		     SEC_ALLOC section.  */
		  if (m->p_size_valid)
		    p->p_filesz = m->p_size;
		  else
		    abort ();
		  p->p_vaddr = lp->p_vaddr;
		  p->p_offset = lp->p_offset;
		  p->p_memsz = p->p_filesz;
		  p->p_align = 1;
		}
d4676 8
d4685 2
@


1.466
log
@	* elf.c (assign_file_positions_for_load_sections): When checking
	a segment for contents, don't assume that a non-TLS nobits section
	must only be followed by nobits sections.
@
text
@d4634 1
a4634 1
      if (m->count != 0)
d4636 1
a4636 8
	  if (p->p_type != PT_LOAD
	      && (p->p_type != PT_NOTE
		  || bfd_get_format (abfd) != bfd_core))
	    {
	      Elf_Internal_Shdr *hdr;
	      asection *sect;

	      BFD_ASSERT (!m->includes_filehdr && !m->includes_phdrs);
d4638 1
a4638 56
	      sect = m->sections[m->count - 1];
	      hdr = &elf_section_data (sect)->this_hdr;
	      p->p_filesz = sect->filepos - m->sections[0]->filepos;
	      if (hdr->sh_type != SHT_NOBITS)
		p->p_filesz += hdr->sh_size;

	      if (p->p_type == PT_GNU_RELRO)
		{
		  /* When we get here, we are copying executable
		     or shared library. But we need to use the same
		     linker logic.  */
		  Elf_Internal_Phdr *lp;

		  for (lp = phdrs; lp < phdrs + count; ++lp)
		    {
		      if (lp->p_type == PT_LOAD
			  && lp->p_paddr == p->p_paddr)
			break;
		    }
	  
		  if (lp < phdrs + count)
		    {
		      /* We should use p_size if it is valid since it
			 may contain the first few bytes of the next
			 SEC_ALLOC section.  */
		      if (m->p_size_valid)
			p->p_filesz = m->p_size;
		      else
			abort ();
		      p->p_vaddr = lp->p_vaddr;
		      p->p_offset = lp->p_offset;
		      p->p_memsz = p->p_filesz;
		      p->p_align = 1;
		    }
		  else
		    abort ();
		}
	      else
		p->p_offset = m->sections[0]->filepos;
	    }
	}
      else
	{
	  if (m->includes_filehdr)
	    {
	      p->p_vaddr = filehdr_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = filehdr_paddr;
	    }
	  else if (m->includes_phdrs)
	    {
	      p->p_vaddr = phdrs_vaddr;
	      if (! m->p_paddr_valid)
		p->p_paddr = phdrs_paddr;
	    }
	  else if (p->p_type == PT_GNU_RELRO)
d4640 2
d4671 61
@


1.465
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d4291 8
a4298 15
	     sections.  If the first section isn't loadable, the same
	     holds for any other sections.  */
	  i = 0;
	  while (elf_section_type (m->sections[i]) == SHT_NOBITS)
	    {
	      /* If a segment starts with .tbss, we need to look
		 at the next section to decide whether the segment
		 has any loadable sections.  */
	      if ((elf_section_flags (m->sections[i]) & SHF_TLS) == 0
		  || ++i >= m->count)
		{
		  no_contents = TRUE;
		  break;
		}
	    }
@


1.464
log
@bfd/
	PR 6789
	* elf.c (assign_file_positions_for_load_sections): Call
	_bfd_elf_map_sections_to_segments, not elf_modify_segment_map.
	(get_program_header_size): Protect against NULL info.
	(_bfd_elf_map_sections_to_segments): Likewise.
	* elf32-spu.c (spu_elf_additional_program_headers): Likewise.
ld/testsuite/
	* ld-elf/extract-symbol-1sec.d: Correct section lma.
@
text
@d2684 4
a2687 1
/* Fill in the contents of a SHT_GROUP section.  */
a2692 1
  unsigned long symindx;
d2703 42
a2744 12
  symindx = 0;
  if (elf_group_id (sec) != NULL)
    symindx = elf_group_id (sec)->udata.i;

  if (symindx == 0)
    {
      /* If called from the assembler, swap_out_syms will have set up
	 elf_section_syms;  If called for "ld -r", use target_index.  */
      if (elf_section_syms (abfd) != NULL)
	symindx = elf_section_syms (abfd)[sec->index]->udata.i;
      else
	symindx = sec->target_index;
a2745 1
  elf_section_data (sec)->this_hdr.sh_info = symindx;
@


1.463
log
@	* elf.c (_bfd_elf_init_private_section_data): Tweak union copy.
	(bfd_section_from_shdr): Don't change SHT_GROUP section name.
	* elflink.c (section_signature): New function.
	(_bfd_elf_section_already_linked): Use it.
@
text
@d3383 1
a3383 1
  if (info->relro)
d3765 7
a3771 2
	  if (last_hdr && info->callbacks->override_segment_assignment)
	    new_segment = info->callbacks->override_segment_assignment (info, abfd, hdr, last_hdr, new_segment);
d3946 1
a3946 1
      if (info->relro)
d4130 1
a4130 1
      && !elf_modify_segment_map (abfd, link_info, FALSE))
@


1.462
log
@	* elf.c (bfd_elf_get_elf_syms): Don't leak memory on error.
	* elflink.c (_bfd_elf_link_read_relocs): bfd_release on error.
	(elf_link_add_object_symbols): Don't leak memory on error.
	(bfd_elf_size_dynsym_hash_dynstr): Likewise.
	(elf_fixup_link_order): Free sections.
@
text
@a1865 3
      /* We need a BFD section for objcopy and relocatable linking,
	 and it's handy to have the signature available as the section
	 name.  */
a1867 3
      name = group_signature (abfd, hdr);
      if (name == NULL)
	return FALSE;
d6016 1
a6016 1
	  elf_group_name (osec) = elf_group_name (isec);
@


1.462.2.1
log
@bfd/
	PR 6789
	* elf.c (assign_file_positions_for_load_sections): Call
	_bfd_elf_map_sections_to_segments, not elf_modify_segment_map.
	(get_program_header_size): Protect against NULL info.
	(_bfd_elf_map_sections_to_segments): Likewise.
	* elf32-spu.c (spu_elf_additional_program_headers): Likewise.
ld/testsuite/
	* ld-elf/extract-symbol-1sec.d: Correct section lma.
@
text
@d3389 1
a3389 1
  if (info != NULL && info->relro)
d3771 2
a3772 7
	  if (last_hdr != NULL
	      && info != NULL
	      && info->callbacks->override_segment_assignment != NULL)
	    new_segment
	      = info->callbacks->override_segment_assignment (info, abfd, hdr,
							      last_hdr,
							      new_segment);
d3947 1
a3947 1
      if (info != NULL && info->relro)
d4131 1
a4131 1
      && !_bfd_elf_map_sections_to_segments (abfd, link_info))
@


1.462.2.2
log
@	* elf.c (assign_file_positions_for_load_sections): When checking
	a segment for contents, don't assume that a non-TLS nobits section
	must only be followed by nobits sections.
@
text
@d4266 15
a4280 8
	     sections.  */
	  no_contents = TRUE;
	  for (i = 0; i < m->count; i++)
	    if (elf_section_type (m->sections[i]) != SHT_NOBITS)
	      {
		no_contents = FALSE;
		break;
	      }
@


1.462.2.3
log
@        * Import this patch from the mainline:
        2008-11-10  Andreas Schwab  <schwab@@suse.de>

        PR 7011
        * elf.c (assign_file_positions_for_non_load_sections): Handle
        PT_GNU_RELRO specially.
@
text
@d4609 1
a4609 55
      if (p->p_type == PT_GNU_RELRO)
	{
	  const Elf_Internal_Phdr *lp;

	  BFD_ASSERT (!m->includes_filehdr && !m->includes_phdrs);

	  if (link_info != NULL)
	    {
	      /* During linking the range of the RELRO segment is passed
		 in link_info.  */
	      for (lp = phdrs; lp < phdrs + count; ++lp)
		{
		  if (lp->p_type == PT_LOAD
		      && lp->p_vaddr >= link_info->relro_start
		      && lp->p_vaddr < link_info->relro_end
		      && lp->p_vaddr + lp->p_filesz >= link_info->relro_end)
		    break;
		}
	    }
	  else
	    {
	      /* Otherwise we are copying an executable or shared
		 library, but we need to use the same linker logic.  */
	      for (lp = phdrs; lp < phdrs + count; ++lp)
		{
		  if (lp->p_type == PT_LOAD
		      && lp->p_paddr == p->p_paddr)
		    break;
		}
	    }

	  if (lp < phdrs + count)
	    {
	      p->p_vaddr = lp->p_vaddr;
	      p->p_paddr = lp->p_paddr;
	      p->p_offset = lp->p_offset;
	      if (link_info != NULL)
		p->p_filesz = link_info->relro_end - lp->p_vaddr;
	      else if (m->p_size_valid)
		p->p_filesz = m->p_size;
	      else
		abort ();
	      p->p_memsz = p->p_filesz;
	      p->p_align = 1;
	      p->p_flags = (lp->p_flags & ~PF_W);
	    }
	  else if (link_info != NULL)
	    {
	      memset (p, 0, sizeof *p);
	      p->p_type = PT_NULL;
	    }
	  else
	    abort ();
	}
      else if (m->count != 0)
d4625 34
a4658 1
	      p->p_offset = m->sections[0]->filepos;
d4661 1
a4661 1
      else if (m->includes_filehdr)
d4663 43
a4705 9
	  p->p_vaddr = filehdr_vaddr;
	  if (! m->p_paddr_valid)
	    p->p_paddr = filehdr_paddr;
	}
      else if (m->includes_phdrs)
	{
	  p->p_vaddr = phdrs_vaddr;
	  if (! m->p_paddr_valid)
	    p->p_paddr = phdrs_paddr;
@


1.462.2.4
log
@backport 2008-09-28  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d1866 3
d1871 3
d6007 1
a6007 1
	  elf_section_data (osec)->group = elf_section_data (isec)->group;
@


1.462.2.5
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d2684 1
a2684 4
/* Fill in the contents of a SHT_GROUP section.  Called from
   _bfd_elf_compute_section_file_positions for gas, objcopy, and
   when ELF targets use the generic linker, ld.  Called for ld -r
   from bfd_elf_final_link.  */
d2690 1
d2701 12
a2712 42
  if (elf_section_data (sec)->this_hdr.sh_info == 0)
    {
      unsigned long symindx = 0;

      /* elf_group_id will have been set up by objcopy and the
	 generic linker.  */
      if (elf_group_id (sec) != NULL)
	symindx = elf_group_id (sec)->udata.i;

      if (symindx == 0)
	{
	  /* If called from the assembler, swap_out_syms will have set up
	     elf_section_syms.  */
	  BFD_ASSERT (elf_section_syms (abfd) != NULL);
	  symindx = elf_section_syms (abfd)[sec->index]->udata.i;
	}
      elf_section_data (sec)->this_hdr.sh_info = symindx;
    }
  else if (elf_section_data (sec)->this_hdr.sh_info == (unsigned int) -2)
    {
      /* The ELF backend linker sets sh_info to -2 when the group
	 signature symbol is global, and thus the index can't be
	 set until all local symbols are output.  */
      asection *igroup = elf_sec_group (elf_next_in_group (sec));
      struct bfd_elf_section_data *sec_data = elf_section_data (igroup);
      unsigned long symndx = sec_data->this_hdr.sh_info;
      unsigned long extsymoff = 0;
      struct elf_link_hash_entry *h;

      if (!elf_bad_symtab (igroup->owner))
	{
	  Elf_Internal_Shdr *symtab_hdr;

	  symtab_hdr = &elf_tdata (igroup->owner)->symtab_hdr;
	  extsymoff = symtab_hdr->sh_info;
	}
      h = elf_sym_hashes (igroup->owner)[symndx - extsymoff];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      elf_section_data (sec)->this_hdr.sh_info = h->indx;
d2714 1
@


1.462.2.6
log
@backport 2008-11-13  Alan Modra  <amodra@@bigpond.net.au>
@
text
@a1610 2
      if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
	return FALSE;
@


1.462.2.7
log
@backport 2008-11-13  Hans-Peter Nilsson  <hp@@axis.com>
@
text
@d4186 1
a4186 15
  /* We're writing the size in elf_tdata (abfd)->program_header_size,
     see assign_file_positions_except_relocs, so make sure we have
     that amount allocated, with trailing space cleared.
     The variable alloc contains the computed need, while elf_tdata
     (abfd)->program_header_size contains the size used for the
     layout.
     See ld/emultempl/elf-generic.em:gld${EMULATION_NAME}_map_segments
     where the layout is forced to according to a larger size in the
     last iterations for the testcase ld-elf/header.  */
  BFD_ASSERT (elf_tdata (abfd)->program_header_size % bed->s->sizeof_phdr
	      == 0);
  phdrs = bfd_zalloc2 (abfd,
		       (elf_tdata (abfd)->program_header_size
			/ bed->s->sizeof_phdr),
		       sizeof (Elf_Internal_Phdr));
@


1.462.2.8
log
@backport 2008-11-14  Nathan Sidwell  <nathan@@codesourcery.com>
@
text
@a4160 1
  bfd_vma header_pad = 0;
d4168 1
a4168 5
    {
      ++alloc;
      if (m->header_size)
	header_pad = m->header_size;
    }
a4210 5
  if (header_pad < (bfd_vma) off)
    header_pad = 0;
  else
    header_pad -= off;
  off += header_pad;
a4397 5
	  if (m->count)
	    {
	      p->p_filesz += header_pad;
	      p->p_memsz += header_pad;
	    }
a5879 4
      if (map->includes_filehdr && first_section)
	/* We need to keep the space used by the headers fixed.  */
	map->header_size = first_section->vma - segment->p_vaddr;
      
@


1.461
log
@bfd/
	* elf-bfd.h (elf_backend_data): Add a "rela_plts_and_copies_p" field.
	* elfxx-target.h (elf_backend_rela_plts_and_copies_p): New macro.
	(elfNN_bed): Use it.
	* elf.c (_bfd_elf_get_synthetic_symtab): Use rela_plts_and_copies_p
	instead of default_use_rela_p to choose between ".rel.plt" and
	".rela.plt".
	* elflink.c (_bfd_elf_create_dynamic_sections): Use
	rela_plts_and_copies_p instead of default_use_rela_p to choose
	between ".rel.plt" and ".rela.plt", and between ".rel.bss" and
	".rela.bss".
@
text
@d361 1
d383 1
d424 2
a425 1
      intsym_buf = bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));
d441 2
@


1.460
log
@	* elf.c (rewrite_elf_program_header): Don't wrap p_paddr to
	include file or program headers.
@
text
@d8812 1
a8812 1
    relplt_name = bed->default_use_rela_p ? ".rela.plt" : ".rel.plt";
@


1.459
log
@Silence gcc printf warnings
@
text
@d5562 9
a5570 1
	    map->p_paddr -= iehdr->e_ehsize;
d5574 3
a5576 1
	      map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
d5578 10
a5587 7
	      /* iehdr->e_phnum is just an estimate of the number
		 of program headers that we will need.  Make a note
		 here of the number we used and the segment we chose
		 to hold these headers, so that we can adjust the
		 offset when we know the correct value.  */
	      phdr_adjust_num = iehdr->e_phnum;
	      phdr_adjust_seg = map;
@


1.458
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Ignore return from
	elf_parse_notes.  Use bfd_malloc_and_get_section.
	(elf_parse_notes): Validate note namesz and descsz.
@
text
@d1396 1
a1396 1
      fprintf (file, " %lx", (long) symbol->flags);
d7839 1
a7839 1
      sprintf (buf, ".module/%08lx", (long) base_addr);
@


1.457
log
@        * elf.c (_bfd_elf_map_sections_to_segments): Catch off by one
        error assigning sections to segments.
@
text
@d938 1
a938 1
      char *contents;
d940 1
a940 2
      contents = bfd_malloc (hdr->sh_size);
      if (!contents)
d943 1
a943 8
      if (!bfd_get_section_contents (abfd, hdr->bfd_section, contents, 0,
				     hdr->sh_size)
	  || !elf_parse_notes (abfd, contents, hdr->sh_size, -1))
	{
	  free (contents);
	  return FALSE;
	}
      
d8531 3
d8538 2
d8544 4
@


1.456
log
@        * elf.c (_bfd_elf_map_sections_to_segments): Allow sections in
        adjoining pages to be included in the same segment.
@
text
@d3731 1
a3731 1
		       < hdr->lma))
@


1.455
log
@        * elf.c (assign_file_positions_for_load_sections): Print vma in
        error message about overlapping section vmas.
@
text
@d3723 9
a3731 2
	  else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
		   < BFD_ALIGN (hdr->lma, maxpagesize))
@


1.454
log
@	* bfd/elf-bfd.h: Declare elfcore_write_ppc_vsx.
	* bfd/elf.c (elfcore_grok_ppc_vsx): New function.
	(elfcore_write_ppc_vsx): New function
	(elfcore_grok_note): Handle VSX notes.
	(elfcore_write_register_note): Handle VSX notes.
	* include/elf/common.h: Define NT_PPC_VSX.
	* binutils/readelf.c (get_note_type): Handle VSX notes.
@
text
@d4401 1
a4401 1
		     abfd, sec, (unsigned long) sec->lma);
@


1.453
log
@Revert my last change since it has not been approved.
@
text
@d7556 5
d7916 7
d8490 12
d8515 2
@


1.452
log
@	bfd/
	* elf.c (_bfd_elf_map_sections_to_segments): Don't put
	executable sections into the same segment with other
	read only sections if --sep-code.
	* elf32-bfin.c (elf32_bfin_code_in_l1): New variable.
	(elf32_bfin_data_in_l1): New variable.
	(elf32_bfin_final_write_processing): New.
	(elf32_bfin_special_sections[]): New.
	(elf_backend_final_write_processing): Define.
	(elf_backend_special_sections): Define.

	binutils/
	* readelf.c (get_machine_flags): Deal with Blackfin specific
	flags.

	include/
	* bfdlink.h (struct bfd_link_info): Add sep_code member
	variable.
	* elf/bfin.h (EF_BFIN_CODE_IN_L1): Define.
	(EF_BFIN_DATA_IN_L1): Define.

	ld/
	* Makefile.am (eelf32bfin.c): Depend on bfin.em.
	(eelf32bfinfd.c): Likewise.
	* Makefile.in: Regenerate.
	* gen-doc.texi: Set Blackfin.
	* ld.texinfo: Document --sep-code and Blackfin specific
	options.
	* ldmain.c (main): Initialize link_info.sep_code.
	* lexsup.c (enum option_values): Add OPTION_SEP_CODE.
	(ld_options[]): Add --sep-code.
	(parse_args): Deal with --sep-code.
	* emulparams/bfin.sh (EXTRA_EM_FILE): Define.
	* emulparams/elf32bfinfd.sh (OTHER_SECTIONS): Define.
	* emultempl/bfin.em: New file.
@
text
@a3607 1
      bfd_boolean executable;
a3678 1
      executable = FALSE;
a3759 8
	  else if (info->sep_code
		   && ((! executable && (hdr->flags & SEC_CODE) != 0)
		       || (executable && (hdr->flags & SEC_CODE) == 0)))
	    {
	      /* We don't want to put a executable section in a non-executable
		 segment.  */
	      new_segment = TRUE;
	    }
a3773 2
	      if ((hdr->flags & SEC_CODE) != 0)
		executable = TRUE;
a3798 5
	  if ((hdr->flags & SEC_CODE) != 0)
	    executable = TRUE;
	  else
	    executable = FALSE;

@


1.451
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d3608 1
d3680 1
d3762 8
d3784 2
d3811 5
@


1.450
log
@bfd/
	* elf.c (_bfd_elf_get_synthetic_symtab): Increment p by
	bed->s->int_rels_per_ext_rel.
@
text
@d893 8
a900 1
	  { STRING_COMMA_LEN ("stab") }	/* 's' */
d2129 9
d2159 6
d2241 1
a2241 1
  if (i < 0 || i > 't' - 'b')
@


1.449
log
@bfd/
	* syms.c (BSF_SYNTHETIC): New flag.
	* elf.c (_bfd_elf_get_synthetic_symtab): Set it.
	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Likewise.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
	* bfd-in.h (bfd_asymbol_flavour): Return bfd_target_unknown_flavour
	for synthetic symbols.
	* bfd-in2.h: Regenerate.

opcodes/
	* mips-dis.c (_print_insn_mips): Use bfd_asymbol_flavour to check
	for ELF symbols.
@
text
@d8764 1
a8764 1
  for (i = 0; i < count; i++, p++)
d8774 1
a8774 1
  for (i = 0; i < count; i++, p++)
@


1.448
log
@	* elf.c (ignore_section_sym): Don't test section sym value here.
	(elf_map_symbols): Instead check zero value here as was done prior
	to 2006-05-26 change.
@
text
@d8788 1
@


1.447
log
@bfd/
	* elf.c (assign_file_positions_for_load_sections): Adjust pre-section
	gaps based on VMA and P_VADDR instead of LMA and P_PADDR addresses.
binutils/testsuite/
	* binutils-all/objcopy.exp: Call KEEP_DEBUG_SYMBOLS_AND_TEST_COPY.
	(keep_debug_symbols_and_test_copy): New function.
	(test5, test6): New variables.
@
text
@d3081 1
a3081 2
   output.  Also, don't output section symbols for reloc and other
   special sections.  */
d3087 3
a3089 4
	  && (sym->value != 0
	      || (sym->section->owner != abfd
		  && (sym->section->output_section->owner != abfd
		      || sym->section->output_offset != 0))));
d3132 1
@


1.446
log
@
	* elf.c (elfcore_write_register_note): New function.
	* elf-bfd.h (elfcore_write_register_note): New prototype.
@
text
@d4374 1
a4374 1
	      bfd_signed_vma adjust = sec->lma - (p->p_paddr + p->p_memsz);
d4379 1
a4379 1
		    (_("%B: section %A lma 0x%lx overlaps previous sections"),
@


1.445
log
@	PR 2995, PR 6473
	* elf.c (_bfd_elf_make_section_from_shdr): Leave lma equal to
	vma when all p_paddr fields are zero and there is more than
	one PT_LOAD header.
@
text
@d8456 17
@


1.444
log
@	PR 2995, PR 6473
	* elf.c (rewrite_elf_program_header): Rather than clearing
	p_paddr_valid at end, don't set it in the first place.  Delete
	comment no longer relevant.  When not p_paddr_valid, don't set
	paddr from vaddr, and don't set p_vaddr_offset.
@
text
@d951 14
a964 1
      unsigned int i;
@


1.443
log
@	* elf.c (bfd_elf_get_str_section): Fix memory leak caused by
	corrupt string table.
@
text
@d5059 1
d5188 14
d5337 1
a5337 1
	  map->p_paddr_valid = 1;
a5403 2
      /* Gcc 2.96 miscompiles this code on mips. Don't do casting here
	 to work around this long long bug.  */
d5438 1
a5438 1
	      if (segment->p_paddr == 0
d5496 2
a5497 1
	  if (!bed->want_p_paddr_set_to_zero
d5499 2
a5500 1
	      && !map->includes_filehdr && !map->includes_phdrs)
d5652 1
a5652 1
	      map->p_paddr_valid = 1;
a5661 11
  /* The Solaris linker creates program headers in which all the
     p_paddr fields are zero.  When we try to objcopy or strip such a
     file, we get confused.  Check for this case, and if we find it
     reset the p_paddr_valid fields.  */
  for (map = map_first; map != NULL; map = map->next)
    if (map->p_paddr != 0)
      break;
  if (map == NULL)
    for (map = map_first; map != NULL; map = map->next)
      map->p_paddr_valid = 0;

@


1.442
log
@	PR 2995, PR 6473
	* elf.c (_bfd_elf_make_section_from_shdr): Always set lma from p_paddr.
	(assign_file_positions_for_load_sections): Combine nested "if".
	(copy_elf_program_header): Don't set p_paddr_valid or p_vaddr_offset
	when all header p_paddr fields are zero.
@
text
@d284 1
a284 1
      if (shstrtabsize + 1 == 0
d293 4
@


1.441
log
@	* elf.c (_bfd_elf_get_dynamic_reloc_upper_bound)
	(_bfd_elf_canonicalize_dynamic_reloc): Find dynamic relocations
	even if they are not loaded.
	* elflink.c (_bfd_elf_init_2_index_sections): Set data_index_section
	first.

	* ld-arm/symbian-seg1.s, ld-arm/symbian-seg1.d: New files.
	* ld-arm/arm-elf.exp: Run symbian-seg1.
@
text
@a948 3
      /* Look through the phdrs to see if we need to adjust the lma.
	 If all the p_paddr fields are zero, we ignore them, since
	 some ELF linkers produce such output.  */
d952 42
a993 51
	  if (phdr->p_paddr != 0)
	    break;
	}
      if (i < elf_elfheader (abfd)->e_phnum)
	{
	  phdr = elf_tdata (abfd)->phdr;
	  for (i = 0; i < elf_elfheader (abfd)->e_phnum; i++, phdr++)
	    {
	      /* This section is part of this segment if its file
		 offset plus size lies within the segment's memory
		 span and, if the section is loaded, the extent of the
		 loaded data lies within the extent of the segment.

		 Note - we used to check the p_paddr field as well, and
		 refuse to set the LMA if it was 0.  This is wrong
		 though, as a perfectly valid initialised segment can
		 have a p_paddr of zero.  Some architectures, eg ARM,
		 place special significance on the address 0 and
		 executables need to be able to have a segment which
		 covers this address.  */
	      if (phdr->p_type == PT_LOAD
		  && (bfd_vma) hdr->sh_offset >= phdr->p_offset
		  && (hdr->sh_offset + hdr->sh_size
		      <= phdr->p_offset + phdr->p_memsz)
		  && ((flags & SEC_LOAD) == 0
		      || (hdr->sh_offset + hdr->sh_size
			  <= phdr->p_offset + phdr->p_filesz)))
		{
		  if ((flags & SEC_LOAD) == 0)
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_addr - phdr->p_vaddr);
		  else
		    /* We used to use the same adjustment for SEC_LOAD
		       sections, but that doesn't work if the segment
		       is packed with code from multiple VMAs.
		       Instead we calculate the section LMA based on
		       the segment LMA.  It is assumed that the
		       segment will contain sections with contiguous
		       LMAs, even if the VMAs are not.  */
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_offset - phdr->p_offset);

		  /* With contiguous segments, we can't tell from file
		     offsets whether a section with zero size should
		     be placed at the end of one segment or the
		     beginning of the next.  Decide based on vaddr.  */
		  if (hdr->sh_addr >= phdr->p_vaddr
		      && (hdr->sh_addr + hdr->sh_size
			  <= phdr->p_vaddr + phdr->p_memsz))
		    break;
		}
d4350 6
a4355 2
	  if (p->p_type == PT_LOAD
	      || p->p_type == PT_TLS)
d4359 1
a4359 4
	      if (this_hdr->sh_type != SHT_NOBITS
		  || ((this_hdr->sh_flags & SHF_ALLOC) != 0
		      && ((this_hdr->sh_flags & SHF_TLS) == 0
			  || p->p_type == PT_TLS)))
d4361 6
a4366 8
		  if (adjust < 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: section %A lma 0x%lx overlaps previous sections"),
			 abfd, sec, (unsigned long) sec->lma);
		      adjust = 0;
		    }
		  p->p_memsz += adjust;
d4368 4
a4371 5
		  if (this_hdr->sh_type != SHT_NOBITS)
		    {
		      off += adjust;
		      p->p_filesz += adjust;
		    }
d5698 1
d5705 3
d5712 9
d5761 1
a5761 1
      map->p_paddr_valid = 1;
d5795 3
a5797 1
      if (!map->includes_phdrs && !map->includes_filehdr)
@


1.440
log
@	* elf.c (_bfd_elf_print_private_bfd_data): Use bfd_fprintf_vma to
	print the values from the dynamic section.
@
text
@d6523 1
a6523 2
    if ((s->flags & SEC_LOAD) != 0
	&& elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
d6559 1
a6559 2
      if ((s->flags & SEC_LOAD) != 0
	  && elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
@


1.439
log
@include/elf/
	* internal.h (Elf_Internal_Shdr): Change sh_link and sh_info from
	unsigned long to unsigned int.  Change sh_addralign to bfd_vma.
	Order struct as for external version.
bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Remove unnecessary cast.
	(_bfd_elf_assign_file_position_for_section): Simplify align.
	(_bfd_elf_init_reloc_shdr): Ensure shift expression wide enough
	for sh_addralign.
	(elf_fake_sections, swap_out_syms): Likewise.
	* elflink.c (bfd_elf_final_link): Likewise.
binutils/
	* readelf.c: Use %u throughout when printing sh_link or sh_info,
	%lu when printing sh_addralign.
	(process_version_sections): Use identical formats when printing
	all offset and sh_link fields.
@
text
@d1296 4
a1299 1
	    fprintf (f, "0x%lx", (unsigned long) dyn.d_un.d_val);
@


1.438
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d831 1
a831 1
				      bfd_log2 ((bfd_vma) hdr->sh_addralign)))
d2452 1
a2452 1
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
d2499 1
a2499 1
  this_hdr->sh_addralign = 1 << asect->alignment_power;
d3224 2
a3225 8
  if (align)
    {
      unsigned int al;

      al = i_shdrp->sh_addralign;
      if (al > 1)
	offset = BFD_ALIGN (offset, al);
    }
d6142 1
a6142 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
@


1.437
log
@	* elf-bfd.h (_bfd_elf_section_from_bfd_section): Update prototype.
	* elf.c (_bfd_elf_section_from_bfd_section): Return unsigned int,
	SHN_BAD on error.
	(_bfd_elf_print_private_bfd_data): Test for SHN_BAD result from
	_bfd_elf_section_from_bfd_section, not -1.
	(swap_out_syms): Likewise.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	(bfd_elf_get_bfd_needed_list): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.
	(elf_link_add_object_symbols): Don't bother testing for symbols
	using normal sections before calling bfd_section_from_elf_index.
	(elf_link_input_bfd, bfd_elf_final_link): Likewise.
	(bfd_elf_reloc_symbol_deleted_p): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elf32-spu.c (get_sym_h): Likewise.
	* elf32-xtensa.c (get_elf_r_symndx_section): Likewise.
	* elf64-ppc.c (opd_entry_value, get_sym_h, ppc64_elf_edit_toc): Ditto.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
@
text
@d460 1
a460 2
      && isym->st_shndx < elf_numsections (abfd)
      && !(isym->st_shndx >= SHN_LORESERVE && isym->st_shndx <= SHN_HIRESERVE))
d497 2
d717 1
a717 2
	      const struct elf_backend_data *bed
		= get_elf_backend_data (abfd);
d725 1
a725 1
	      asection *link;
d727 5
a731 1
	      this_hdr = elf_elfsections (abfd)[elfsec];
a735 1
	      link = this_hdr->bfd_section;
d1524 3
a1526 3
  Elf_Internal_Shdr *hdr = elf_elfsections (abfd)[shindex];
  Elf_Internal_Ehdr *ehdr = elf_elfheader (abfd);
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1529 6
a1534 2
  name = bfd_elf_string_from_elf_section (abfd,
					  elf_elfheader (abfd)->e_shstrndx,
d1539 1
d1740 1
a1740 2
	if ((hdr->sh_link >= SHN_LORESERVE && hdr->sh_link <= SHN_HIRESERVE)
	    || hdr->sh_link >= num_sec)
a1793 1
	    || (hdr->sh_info >= SHN_LORESERVE && hdr->sh_info <= SHN_HIRESERVE)
d2780 1
a2780 5
		{
		  if (section_number == SHN_LORESERVE)
		    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
		  d->this_idx = section_number++;
		}
d2790 1
a2790 5
	{
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->this_idx = section_number++;
	}
a2795 2
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a2801 2
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a2808 2
  if (section_number == SHN_LORESERVE)
    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a2814 2
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
d2817 1
a2817 1
      if (section_number > SHN_LORESERVE - 2)
a2818 2
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a2825 2
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
a2834 2
  if (section_number > SHN_LORESERVE)
    elf_elfheader (abfd)->e_shnum -= SHN_HIRESERVE + 1 - SHN_LORESERVE;
d2855 1
a2855 1
      if (elf_numsections (abfd) > SHN_LORESERVE)
a4546 6

      if (i == SHN_LORESERVE - 1)
	{
	  i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	}
a4742 6

	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
a4787 1
  Elf_Internal_Shdr **i_shdrp;	/* Section header table, internal form */
a4791 1
  i_shdrp = elf_elfsections (abfd);
a4935 2
      if (count == SHN_LORESERVE - 1)
	count += SHN_HIRESERVE + 1 - SHN_LORESERVE;
@


1.436
log
@        * elf.c ( _bfd_elf_print_private_bfd_data): Call
        elf_backend_get_target_dtag if defined.
        * elf32-mips.c (elf_backend_get_target_dtag): Define.
        * elf64-mips.c: Likewise.
        * elfn32-mips.c: Likewise.
        * elfxx-mips.c (_bfd_mips_elf_get_target_dtag): New.
        * elfxx-mips.h (_bfd_mips_elf_get_target_dtag): Declare.
        * elf-bfd.h (elf_backend_get_target_dtag): Add prototype.
        * elfxx-target.h (elf_backend_get_target_dtag): Add default.
        (elf_backend_data): Add elf_backend_get_target_dtag.
@
text
@d1183 1
a1183 1
      int elfsec;
d1195 1
a1195 1
      if (elfsec == -1)
d4999 1
a4999 1
int
d5003 1
a5003 1
  int index;
d5016 1
a5016 1
    index = -1;
d5027 1
a5027 1
  if (index == -1)
d6280 1
a6280 1
	  int shndx;
d6327 1
a6327 1
	      if (shndx == -1)
d6351 1
a6351 1
		  BFD_ASSERT (shndx != -1);
@


1.435
log
@* elf.c (swap_out_syms): Avoid preprocessing directive within
macro arg.
@
text
@d1207 1
a1207 1
	  const char *name;
d1210 1
d1221 8
a1228 2
	      sprintf (ab, "0x%lx", (unsigned long) dyn.d_tag);
	      name = ab;
d1291 1
a1291 1
	  fprintf (f, "  %-11s ", name);
@


1.434
log
@* elf.c (assign_file_positions_for_load_sections): Set the type of
PT_NOTE sections to SHT_NOTE.
@
text
@d6381 1
a6381 1
	sym.st_info = ELF_ST_INFO (STB_GLOBAL,
d6383 5
a6387 1
				   type == STT_OBJECT ? STT_COMMON :
d6389 1
a6389 1
				   type);
@


1.433
log
@	* elf-bfd.h (enum elf_object_id): Add HPPA_ELF_TDATA.
	* elf.c (bfd_elf_allocate_object): Don't check for already allocated
	tdata.
	* elf32-hppa.c (elf32_hppa_mkobject): New function.
	(bfd_elf32_mkobject): Define.
	* elf32-ppc.c (is_ppc_elf_target): Delete.  Replace all uses with..
	(is_ppc_elf): ..this new macro.
	* elf64-ppc.c (is_ppc64_elf_target): Delete.  Replace all uses with..
	(is_ppc64_elf): ..this new macro.
@
text
@d4287 4
@


1.432
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d229 2
a230 3
/* If ABFD does not already have an allocated tdata field then create
   one, OBJECT_SIZE bytes is length, zeroed out and with the object_id
   field of an elf_obj_tdata field set to OBJECT_ID.  */
d232 1
a232 1
bfd_elf_allocate_object (bfd * abfd,
a235 3
  if (abfd->tdata.any != NULL)
    return TRUE;

@


1.431
log
@	PR ld/5692
	* elf.c (bfd_elf_get_elf_syms): Revert 2008-01-31.  Instead abort
	on non-ELF input.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Skip glue
	processing on non-ELF input.
@
text
@d229 3
d233 3
a235 1
bfd_elf_mkobject (bfd *abfd)
d237 5
d243 6
a248 5
    {
      abfd->tdata.any = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
a249 1
  elf_tdata (abfd)->program_header_size = (bfd_size_type) -1;
d251 5
a255 1
  return TRUE;
d262 1
a262 1
  return bfd_elf_mkobject (abfd);
@


1.430
log
@PR ld/5692
* elf.c (bfd_elf_get_elf_syms): Check the return value of get_elf_backend_data.
@
text
@d354 3
a368 3
  /* PR ld/5692: Check for non-ELF files.  */
  if (bed == NULL)
    return NULL;
@


1.429
log
@* elf.c (_bfd_elf_find_segment_containing_section): New function:
  Scan the segment map looking for the segment containing a
  specified function.
* elf-bfd.h: Prototype the new function.
* elf-hppa.h (elf_hppa_osec_to_segment): Delete.
  (elf_hppa_record_segment_addrs): Use new function.
* elf32-bfin.c (_bfdfdpic_osec_to_segment): Use new function.
* elf32-frv.c (_frvfdpic_osec_to_segment): Use new function.
* elf32-hppa.c (hppa_record_segment_addr): Use new function.
* elfxx-ia64.c (elfNN_ia64_relocate_section): Use new function.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d329 3
a331 1
   symbols, and symbol section index extensions, respectively.  */
d366 3
@


1.428
log
@bfd/

2007-12-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5488
	* elf.c (IS_NOTE): New.
	(IS_COREFILE_NOTE): Use IS_NOTE.
	(IS_SECTION_IN_INPUT_SEGMENT): Use IS_NOTE instead of
	IS_COREFILE_NOTE.

ld/testsuite/

2007-12-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5488
	* ld-elf/note-2.d: New.
	* ld-elf/note-2.s: Likewise.
	* ld-elf/note-2.t: Likewise.
@
text
@d3429 23
@


1.427
log
@2007-12-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5449
	* elf.c (rewrite_elf_program_header): Don't adjust p_paddr if
	p_paddr is set to 0.
	(copy_private_bfd_data): Call rewrite_elf_program_header if
	p_paddr is set to 0.

	* elfcode.h (elf_swap_phdr_out): Set p_paddr to 0 if needed.

	* elfxx-ia64.c (ELF_MAXPAGESIZE): Don't redefine it for HPUX.
@
text
@d5093 2
a5094 2
  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc.  */
#define IS_COREFILE_NOTE(p, s)						\
d5096 1
a5096 2
   && bfd_get_format (ibfd) == bfd_core					\
   && s->vma == 0 && s->lma == 0					\
d5101 8
d5127 2
a5128 1
       2. It is an allocated segment,
d5141 1
a5141 1
    || IS_COREFILE_NOTE (segment, section))				\
d5675 1
@


1.426
log
@        * bfd/elf.c (_bfd_elf_copy_private_symbol_data): Don't copy shndx if
        the symbol's section is the undefined section.
        * gas/testsuite/gas/elf/symtab.s: New test.
        gas/testsuite/gas/elf/symtab.d: New expected output.
        gas/testsuite/gas/elf/elf.exp: Run the new symbtab test.
@
text
@d5395 1
a5395 1
      for (j = 0, section = ibfd->sections;
d5398 4
d5451 3
d5471 2
a5472 1
	  if (matching_lma != map->p_paddr
d5826 7
@


1.425
log
@warning messages should contain "warning:"
@
text
@d6049 1
@


1.424
log
@	PR 5233
	* elf.c (rewrite_elf_program_header): Formatting.  Add
	first_matching_lma and first_suggested_lma booleans and use
	instead of testing matching_lma and suggested_lma for zero.
@
text
@d2500 1
a2500 1
	(_("section `%A' type changed to PROGBITS"), asect);
@


1.423
log
@	* elf.c (_bfd_elf_get_synthetic_symtab): Only bump the symbol
        pointer when we have a valid symbol.  Init udata.p to NULL.
@
text
@d5147 1
a5147 1
   && ! section->segment_mark)
d5205 1
a5205 1
      for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j++, segment2 ++)
d5210 1
a5210 1
	      || ! SEGMENT_OVERLAPS (segment, segment2))
d5218 2
a5219 3
	      extra_length =
		SEGMENT_END (segment, segment->p_vaddr)
		- SEGMENT_END (segment2, segment2->p_vaddr);
d5223 1
a5223 1
		  segment2->p_memsz  += extra_length;
d5238 2
a5239 3
	      extra_length =
		SEGMENT_END (segment2, segment2->p_vaddr)
		- SEGMENT_END (segment, segment->p_vaddr);
d5243 1
a5243 1
		  segment->p_memsz  += extra_length;
d5255 1
a5255 1
       i ++, segment ++)
d5257 7
a5263 7
      unsigned int  section_count;
      asection **   sections;
      asection *    output_section;
      unsigned int  isec;
      bfd_vma       matching_lma;
      bfd_vma       suggested_lma;
      unsigned int  j;
d5265 3
a5267 1
      asection *    first_section;
d5299 3
a5301 3
      map->next          = NULL;
      map->p_type        = segment->p_type;
      map->p_flags       = segment->p_flags;
a5316 1

d5319 1
a5319 1
      if (! phdr_included || segment->p_type != PT_LOAD)
d5338 3
a5340 3
	    (*_bfd_error_handler)
	      (_("%B: warning: Empty loadable segment detected, is this intentional ?\n"),
	       ibfd);
d5392 2
d5403 1
a5403 1
	      sections[j ++] = section;
d5411 1
a5411 1
		  && (! bed->want_p_paddr_set_to_zero)
d5414 8
a5421 8
		  && (output_section->vma == (segment->p_vaddr
					      + (map->includes_filehdr
						 ? iehdr->e_ehsize
						 : 0)
					      + (map->includes_phdrs
						 ? (iehdr->e_phnum
						    * iehdr->e_phentsize)
						 : 0))))
d5428 2
a5429 2
		  || (bed->want_p_paddr_set_to_zero &&
		      IS_CONTAINED_BY_VMA (output_section, segment)))
d5431 5
a5435 2
		  if (matching_lma == 0 || output_section->lma < matching_lma)
		    matching_lma = output_section->lma;
d5440 6
a5445 1
		  map->sections[isec ++] = output_section;
a5446 2
	      else if (suggested_lma == 0)
		suggested_lma = output_section->lma;
d5476 1
a5476 1
	  if (matching_lma != 0)
d5522 1
d5544 6
a5549 6
		      if (output_section->lma !=
			  (map->p_paddr
			   + (map->includes_filehdr ? iehdr->e_ehsize : 0)
			   + (map->includes_phdrs
			      ? iehdr->e_phnum * iehdr->e_phentsize
			      : 0)))
d5554 1
a5554 1
		      asection * prev_sec;
d5564 1
a5564 1
			  || ((prev_sec->lma + prev_sec->size)
d5567 5
a5571 2
			  if (suggested_lma == 0)
			    suggested_lma = output_section->lma;
d5582 5
a5586 2
	      else if (suggested_lma == 0)
		suggested_lma = output_section->lma;
d5612 6
a5617 6
	      map->next             = NULL;
	      map->p_type           = segment->p_type;
	      map->p_flags          = segment->p_flags;
	      map->p_flags_valid    = 1;
	      map->p_paddr          = suggested_lma;
	      map->p_paddr_valid    = 1;
d5619 1
a5619 1
	      map->includes_phdrs   = 0;
@


1.422
log
@	* elf.c (elfcore_grok_ppc_vmx): New function.
	(elfcore_grok_note): Handle NT_PPC_VMX.
	(elfcore_write_ppc_vmx): New function.
	* elf-bfd.h (elfcore_write_ppc_vmx): Declare.
@
text
@d8681 1
a8681 1
  for (i = 0; i < count; i++, s++, p++)
d8698 1
d8704 1
a8704 1
      ++n;
@


1.421
log
@Support the use of the STT_COMMON type.  (In source and object files only at the moment)
@
text
@d7452 7
d7806 7
d8367 12
@


1.420
log
@	* elf.c (elfcore_grok_prxfpreg): Fix comment typo.
@
text
@d6300 5
a6304 1
	sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
@


1.419
log
@2007-10-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (get_program_header_size): Always add a PT_GNU_RELRO
	segment for -z relro.
	(_bfd_elf_map_sections_to_segments): Make a PT_GNU_RELRO
	segment only when needed.
@
text
@d7439 1
a7439 1
   type of 5 (NT_PRXFPREG).  Just include the whole note's contents
@


1.418
log
@	* elf.c (assign_file_positions_for_load_sections): Trust
	p_align_valid.
	(copy_elf_program_header): Copy PT_NULL segments.
@
text
@d3361 1
d3363 4
a3366 6
      if (info->relro)
	{
	  /* We need a PT_GNU_RELRO segment only when there is a
	     PT_DYNAMIC segment.  */
	  ++segs;
	}
d3891 1
a3891 1
      if (dynsec != NULL && info->relro)
d3893 26
a3918 10
	  /* We make a PT_GNU_RELRO segment only when there is a
	     PT_DYNAMIC segment.  */
	  amt = sizeof (struct elf_segment_map);
	  m = bfd_zalloc (abfd, amt);
	  if (m == NULL)
	    goto error_return;
	  m->next = NULL;
	  m->p_type = PT_GNU_RELRO;
	  m->p_flags = PF_R;
	  m->p_flags_valid = 1;
d3920 3
a3922 2
	  *pm = m;
	  pm = &m->next;
@


1.417
log
@	* elf.c (bfd_section_from_shdr): Check bfd_alloc return.
	(elfcore_write_note): Check realloc return.
	* elflink.c (_bfd_elf_link_find_version_dependencies): Check
	bfd_zalloc return.
	(_bfd_elf_link_assign_sym_version): Check bfd_malloc return.
	(elf_link_add_object_symbols): Likewise.
	(struct hash_codes_info): New.
	(elf_collect_hash_codes): Return bfd_malloc error.
	(struct collect_gnu_hash_codes): Add "error".
	(elf_collect_gnu_hash_codes): Return bfd_malloc error.
	(bfd_elf_size_dynamic_sections): Check return status of
	_bfd_elf_link_find_version_dependencies.
	(bfd_elf_size_dynsym_hash_dynstr): Adjust for elf_collect_hash_codes
	and elf_collect_gnu_hash_codes changes.
	(elf_sym_name_compare): Formatting.
	(elf_fixup_link_order): Use bfd_malloc, not xmalloc.
@
text
@d4149 2
a4152 2
      else if (m->p_align_valid)
	p->p_align = m->p_align;
a5668 4
      /* FIXME: Do we need to copy PT_NULL segment?  */
      if (segment->p_type == PT_NULL)
	continue;

@


1.416
log
@bfd/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* elf-bfd.h (elf_obj_tdata): Remove relro.

	* elf.c (get_program_header_size): Check info->relro instead
	of elf_tdata (abfd)->relro.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Don't set
	PT_GNU_RELRO segment alignment here.
	(assign_file_positions_for_non_load_sections): Properly set up
	PT_GNU_RELRO segment for copying executable/shared library.
	(rewrite_elf_program_header): Remove PT_GNU_RELRO segment.
	(copy_elf_program_header): Set p_size and p_size_valid fields for
	PT_GNU_RELRO segment.

include/elf/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* internal.h (elf_segment_map): Add p_size and p_size_valid.
	(ELF_IS_SECTION_IN_SEGMENT): Allow SHF_TLS sections in
	PT_GNU_RELRO segments.

ld/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ldexp.h (ldexp_control): Add relro, relro_start_stat and
	relro_end_stat.

	* ldexp.c (fold_binary): Set expld.dataseg.relro to
	exp_dataseg_relro_start or exp_dataseg_relro_end when
	seeing DATA_SEGMENT_ALIGN or DATA_SEGMENT_RELRO_END,
	respectively.

	* ldlang.c (lang_size_sections_1): Properly set
	expld.dataseg.relro_start_stat and
	expld.dataseg.relro_end_stat.
	(find_relro_section_callback): New function.
	(lang_find_relro_sections_1): Likewise.
	(lang_find_relro_sections): Likewise.
	(lang_process): Call lang_find_relro_sections for
	non-relocatable link.

ld/testsuite/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ld-elf/binutils.exp: Update "-z relro" tests to use relro1.s.
	Add "-z relro" tests with relro2.s.  Add "-z relro" tests with
	TLS for objcopy.

	* ld-elf/relro1.s: New file.
	* ld-elf/relro2.s: Likewise.
@
text
@d1787 2
d8110 2
@


1.415
log
@	* elf-bfd.h (struct elf_backend_data): Delete elf_backend_sprintf_vma
	and elf_backend_fprintf_vma.
	(_bfd_elf_sprintf_vma, _bfd_elf_fprintf_vma): Delete.
	* elf.c (_bfd_elf_sprintf_vma, _bfd_elf_fprintf_vma): Delete.
	* elfxx-target.h (elf_backend_sprintf_vma): Don't define.
	(elf_backend_fprintf_vma): Likewise.
	(elfNN_bed): Don't init removed fields.
	* bfd.c (is32bit): New function.
	(bfd_sprintf_vma, bfd_fprintf_vma): Use the above.
@
text
@d3360 1
a3360 1
      if (elf_tdata (abfd)->relro)
d3890 1
a3890 1
      if (dynsec != NULL && elf_tdata (abfd)->relro)
d4391 4
a4394 6
	      if (p->p_type == PT_GNU_RELRO)
		p->p_align = 1;
	      else if (align > p->p_align
		       && !m->p_align_valid
		       && (p->p_type != PT_LOAD
			   || (abfd->flags & D_PAGED) == 0))
d4544 2
a4545 1
	      && (p->p_type != PT_NOTE || bfd_get_format (abfd) != bfd_core))
d4548 2
d4552 3
a4554 3
	      hdr = &elf_section_data (m->sections[m->count - 1])->this_hdr;
	      p->p_filesz = (m->sections[m->count - 1]->filepos
			     - m->sections[0]->filepos);
d4558 33
a4590 1
	      p->p_offset = m->sections[0]->filepos;
d5179 6
a5184 1
	continue;
d5708 11
@


1.414
log
@	PR ld/2864, ld/5006
	* elf.c (special_sections): Comment typo.
	(elf_fake_sections): Force SHT_PROGBITS for sections that are
	SHT_NOBITS if BFD section flags say they have contents.
@
text
@a8417 57
void
_bfd_elf_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    sprintf_vma (buf, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  sprintf (buf, "%016lx", value);
#else
	  sprintf (buf, "%08lx%08lx", _bfd_int64_high (value),
		   _bfd_int64_low (value));
#endif
	}
      else
	sprintf (buf, "%08lx", (unsigned long) (value & 0xffffffff));
    }
#else
  sprintf_vma (buf, value);
#endif
}

void
_bfd_elf_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
{
#ifdef BFD64
  Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */

  i_ehdrp = elf_elfheader (abfd);
  if (i_ehdrp == NULL)
    fprintf_vma ((FILE *) stream, value);
  else
    {
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
	{
#if BFD_HOST_64BIT_LONG
	  fprintf ((FILE *) stream, "%016lx", value);
#else
	  fprintf ((FILE *) stream, "%08lx%08lx",
		   _bfd_int64_high (value), _bfd_int64_low (value));
#endif
	}
      else
	fprintf ((FILE *) stream, "%08lx",
		 (unsigned long) (value & 0xffffffff));
    }
#else
  fprintf_vma ((FILE *) stream, value);
#endif
}

@


1.413
log
@include/elf/
	* common.h (NT_SPU): Define.
bfd/
	* elf.c (elfcore_grok_spu_note): New function.
	(elf_parse_notes): Call it.
binutils/
	* readelf.c (process_note): Recognize SPU core file notes.
@
text
@d2087 1
a2087 1
  special_sections_c,		/* 'b' */
d2478 9
d2488 12
a2499 9
    {
      if ((asect->flags & SEC_GROUP) != 0)
	this_hdr->sh_type = SHT_GROUP;
      else if ((asect->flags & SEC_ALLOC) != 0
	       && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
		   || (asect->flags & SEC_NEVER_LOAD) != 0))
	this_hdr->sh_type = SHT_NOBITS;
      else
	this_hdr->sh_type = SHT_PROGBITS;
@


1.412
log
@	* elf.c (elfcore_grok_win32pstatus): Remove HAVE_WIN32_PSTATUS_T
	guard.  Make it host independent.
	(elfcore_grok_note): Remove HAVE_WIN32_PSTATUS_T guard around
	NT_WIN32PSTATUS.
@
text
@d7983 26
d8309 5
@


1.411
log
@2007-08-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* elf-bfd.h (struct elf_obj_tdata): New BUILD_ID_SIZE, BUILD_ID.
	* elf.c (elfcore_read_notes): Split to ...
	(elf_read_notes) ... here ...
	(elf_parse_notes): ... and here.  Check `bfd_get_format (abfd)' with
	the former subfunctions called only for BFD_CORE.
	Call ELFOBJ_GROK_GNU_NOTE for BFD_OBJECT files with the owner "GNU".
	(_bfd_elf_make_section_from_shdr): Call ELF_PARSE_NOTES for SHT_NOTEs.
	(bfd_section_from_phdr): Update the call for renamed ELFCORE_READ_NOTES.
	(elfobj_grok_gnu_build_id, elfobj_grok_gnu_note): New functions.
	Code advisory: Roland McGrath
@
text
@a7587 1
#if defined (HAVE_WIN32_PSTATUS_T)
d7595 3
a7597 1
  win32_pstatus_t pstatus;
d7599 1
a7599 1
  if (note->descsz < sizeof (pstatus))
d7602 4
a7605 1
  memcpy (&pstatus, note->descdata, sizeof (pstatus));
d7607 1
a7607 1
  switch (pstatus.data_type)
d7609 1
a7609 1
    case NOTE_INFO_PROCESS:
d7611 4
a7614 2
      elf_tdata (abfd)->core_signal = pstatus.data.process_info.signal;
      elf_tdata (abfd)->core_pid = pstatus.data.process_info.pid;
d7617 1
a7617 1
    case NOTE_INFO_THREAD:
d7619 2
a7620 1
      sprintf (buf, ".reg/%ld", (long) pstatus.data.thread_info.tid);
d7633 4
a7636 4
      sect->size = sizeof (pstatus.data.thread_info.thread_context);
      sect->filepos = (note->descpos
		       + offsetof (struct win32_pstatus,
				   data.thread_info.thread_context));
d7639 4
a7642 1
      if (pstatus.data.thread_info.is_active_thread)
d7647 1
a7647 1
    case NOTE_INFO_MODULE:
d7649 3
a7651 2
      sprintf (buf, ".module/%08lx",
	       (long) pstatus.data.module_info.base_address);
a7675 1
#endif /* HAVE_WIN32_PSTATUS_T */
a7709 1
#if defined (HAVE_WIN32_PSTATUS_T)
a7711 1
#endif
@


1.410
log
@bfd/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c: Revert last change.

binutils/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c: Revert last change.

include/elf/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h: Revert last change.
@
text
@d51 3
a53 1
static bfd_boolean elfcore_read_notes (bfd *, file_ptr, bfd_size_type) ;
d904 22
d2368 1
a2368 1
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
d7740 26
d8239 1
a8239 1
elfcore_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
a8240 1
  char *buf;
a8242 17
  if (size <= 0)
    return TRUE;

  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;

  buf = bfd_malloc (size);
  if (buf == NULL)
    return FALSE;

  if (bfd_bread (buf, size, abfd) != size)
    {
    error:
      free (buf);
      return FALSE;
    }

d8259 30
a8288 14
      if (CONST_STRNEQ (in.namedata, "NetBSD-CORE"))
	{
	  if (! elfcore_grok_netbsd_note (abfd, &in))
	    goto error;
	}
      else if (CONST_STRNEQ (in.namedata, "QNX"))
	{
	  if (! elfcore_grok_nto_note (abfd, &in))
	    goto error;
	}
      else
	{
	  if (! elfcore_grok_note (abfd, &in))
	    goto error;
d8294 25
@


1.409
log
@bfd/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (get_segment_type): Change PT_GNU_STACK to PT_GNU_ATTR.
	(bfd_section_from_phdr): Likewise.
	(get_program_header_size): Likewise. Add a PT_GNU_ATTR segment
	if there is an attribute section.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(IS_SECTION_IN_INPUT_SEGMENT): Likewise.

binutils/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (get_segment_type): Change PT_GNU_STACK to
	PT_GNU_ATTR.

include/elf/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (PT_GNU_STACK): Renamed to ...
	(PT_GNU_ATTR): This.
	(PT_GNU_STACK): New.  Make an alias of PT_GNU_ATTR.
@
text
@d1086 1
a1086 1
    case PT_GNU_ATTR: pt = "ATTR"; break;
d2358 2
a2359 2
    case PT_GNU_ATTR:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "attr");
d3303 1
a3303 2
  asection *attr = NULL;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3338 6
a3345 18
      if (elf_section_type (s) == bed->obj_attrs_section_type)
	{
	  BFD_ASSERT (attr == NULL);
	  attr = s;

	  /* elf_tdata (abfd)->stack_flags is checked for the
	     PT_GNU_ATTR segment.  If there is an attribute
	     section, we make sure that stack_flags isn't zero so
	     that the PT_GNU_ATTR segment will be created.  */
	  if (! elf_tdata (abfd)->stack_flags)
	    {
	      if (bed->default_execstack)
		elf_tdata (abfd)->stack_flags = PF_R | PF_W | PF_X;
	      else
		elf_tdata (abfd)->stack_flags = PF_R | PF_W;
	    }
	}

a3366 6
  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_ATTR segment.  */
      ++segs;
    }

d3378 1
a3522 1
      asection *attr = NULL;
a3532 6
	  if (elf_section_type (s) == bed->obj_attrs_section_type)
	    {
	      BFD_ASSERT (attr == NULL);
	      attr = s;
	    }

d3846 1
a3846 1
	  m->p_type = PT_GNU_ATTR;
a3849 7
	  if (attr)
	    {
	      /* Add the attribute section if needed.  */
	      m->count = 1;
	      m->sections[0] = attr;
	    } 

d5036 1
a5036 1
       5. PT_GNU_ATTR only contains attribute section.
d5042 19
a5060 21
  ((segment->p_type == PT_GNU_ATTR					\
    && elf_section_type (section) == bed->obj_attrs_section_type)	\
   || ((((segment->p_paddr						\
	  ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
	  : IS_CONTAINED_BY_VMA (section, segment))			\
	 && (section->flags & SEC_ALLOC) != 0)				\
	|| IS_COREFILE_NOTE (segment, section))				\
       && segment->p_type != PT_GNU_ATTR				\
       && (segment->p_type != PT_TLS					\
	   || (section->flags & SEC_THREAD_LOCAL))			\
       && (segment->p_type == PT_LOAD					\
	   || segment->p_type == PT_TLS					\
	   || (section->flags & SEC_THREAD_LOCAL) == 0)			\
       && (segment->p_type != PT_DYNAMIC				\
	   || SECTION_SIZE (section, segment) > 0			\
	   || (segment->p_paddr						\
	       ? segment->p_paddr != section->lma			\
	       : segment->p_vaddr != section->vma)			\
	   || (strcmp (bfd_get_section_name (ibfd, section),		\
		       ".dynamic") == 0))				\
       && ! section->segment_mark))
@


1.408
log
@	* elf.c (elf_modify_segment_map): Add remove_empty_load param.
	Don't remove empty PT_LOAD header if false.
	(_bfd_elf_map_sections_to_segments): If user phdrs, pass false
	to elf_modify_segment_map.
	(assign_file_positions_for_load_sections): Pass false to
	elf_modify_segment_map.
@
text
@d1086 1
a1086 1
    case PT_GNU_STACK: pt = "STACK"; break;
d2358 2
a2359 2
    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");
d3303 2
a3304 1
  const struct elf_backend_data *bed;
d3339 1
a3339 1
  if (elf_tdata (abfd)->stack_flags)
d3341 17
a3357 3
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }
a3358 2
  for (s = abfd->sections; s != NULL; s = s->next)
    {
d3380 6
a3396 1
  bed = get_elf_backend_data (abfd);
d3541 1
d3552 6
d3871 1
a3871 1
	  m->p_type = PT_GNU_STACK;
d3875 7
d5068 1
a5068 1
       5. PT_GNU_STACK segments do not include any sections.
d5074 21
a5094 19
  ((((segment->p_paddr							\
      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
      : IS_CONTAINED_BY_VMA (section, segment))				\
     && (section->flags & SEC_ALLOC) != 0)				\
    || IS_COREFILE_NOTE (segment, section))				\
   && segment->p_type != PT_GNU_STACK					\
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
   && (segment->p_type != PT_DYNAMIC					\
       || SECTION_SIZE (section, segment) > 0				\
       || (segment->p_paddr						\
	   ? segment->p_paddr != section->lma				\
	   : segment->p_vaddr != section->vma)				\
       || (strcmp (bfd_get_section_name (ibfd, section), ".dynamic")	\
	   == 0))							\
   && ! section->segment_mark)
@


1.407
log
@2007-08-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4909
	* elf.c (print_segment_map): New function.
	(assign_file_positions_for_load_sections): Call print_segment_map
	when a section can't be allocated in segment.
@
text
@d3449 3
a3451 1
elf_modify_segment_map (bfd *abfd, struct bfd_link_info *info)
d3478 1
a3478 1
      if ((*m)->p_type == PT_LOAD && (*m)->count == 0)
d3503 1
d3505 2
a3506 2
  if (elf_tdata (abfd)->segment_map == NULL
      && bfd_count_sections (abfd) != 0)
d3875 1
a3875 1
  if (!elf_modify_segment_map (abfd, info))
d4021 1
a4021 1
      && !elf_modify_segment_map (abfd, link_info))
@


1.406
log
@	* elf.c: (_bfd_elf_make_section_from_phdr): Properly handle
	bss segments.
@
text
@d3974 26
d4388 1
@


1.405
log
@	* elf.c (rewrite_elf_program_header): Handle sections not sorted
	by address.
	(copy_elf_program_header): Likewise.
@
text
@d2226 1
a2226 1
   into it's initialized and uninitialized parts.
d2245 2
a2246 16
  sprintf (namebuf, "%s%d%s", typename, index, split ? "a" : "");
  len = strlen (namebuf) + 1;
  name = bfd_alloc (abfd, len);
  if (!name)
    return FALSE;
  memcpy (name, namebuf, len);
  newsect = bfd_make_section (abfd, name);
  if (newsect == NULL)
    return FALSE;
  newsect->vma = hdr->p_vaddr;
  newsect->lma = hdr->p_paddr;
  newsect->size = hdr->p_filesz;
  newsect->filepos = hdr->p_offset;
  newsect->flags |= SEC_HAS_CONTENTS;
  newsect->alignment_power = bfd_log2 (hdr->p_align);
  if (hdr->p_type == PT_LOAD)
d2248 16
a2263 3
      newsect->flags |= SEC_ALLOC;
      newsect->flags |= SEC_LOAD;
      if (hdr->p_flags & PF_X)
d2265 12
a2276 3
	  /* FIXME: all we known is that it has execute PERMISSION,
	     may be data.  */
	  newsect->flags |= SEC_CODE;
d2279 2
a2280 1
  if (!(hdr->p_flags & PF_W))
d2282 1
a2282 2
      newsect->flags |= SEC_READONLY;
    }
d2284 1
a2284 3
  if (split)
    {
      sprintf (namebuf, "%s%db", typename, index);
d2296 5
d2303 8
@


1.405.2.1
log
@	* elf.c: (_bfd_elf_make_section_from_phdr): Properly handle
	bss segments.
@
text
@d2226 1
a2226 1
   into its initialized and uninitialized parts.
d2245 16
a2260 2

  if (hdr->p_filesz > 0)
d2262 3
a2264 16
      sprintf (namebuf, "%s%d%s", typename, index, split ? "a" : "");
      len = strlen (namebuf) + 1;
      name = bfd_alloc (abfd, len);
      if (!name)
	return FALSE;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == NULL)
	return FALSE;
      newsect->vma = hdr->p_vaddr;
      newsect->lma = hdr->p_paddr;
      newsect->size = hdr->p_filesz;
      newsect->filepos = hdr->p_offset;
      newsect->flags |= SEC_HAS_CONTENTS;
      newsect->alignment_power = bfd_log2 (hdr->p_align);
      if (hdr->p_type == PT_LOAD)
d2266 3
a2268 12
	  newsect->flags |= SEC_ALLOC;
	  newsect->flags |= SEC_LOAD;
	  if (hdr->p_flags & PF_X)
	    {
	      /* FIXME: all we known is that it has execute PERMISSION,
		 may be data.  */
	      newsect->flags |= SEC_CODE;
	    }
	}
      if (!(hdr->p_flags & PF_W))
	{
	  newsect->flags |= SEC_READONLY;
d2270 4
d2276 1
a2276 1
  if (hdr->p_memsz > hdr->p_filesz)
d2278 1
a2278 3
      bfd_vma align;

      sprintf (namebuf, "%s%d%s", typename, index, split ? "b" : "");
a2289 5
      newsect->filepos = hdr->p_offset + hdr->p_filesz;
      align = newsect->vma & -newsect->vma;
      if (align == 0 || align > hdr->p_align)
	align = hdr->p_align;
      newsect->alignment_power = bfd_log2 (align);
a2291 8
	  /* Hack for gdb.  Segments that have not been modified do
	     not have their contents written to a core file, on the
	     assumption that a debugger can find the contents in the
	     executable.  We flag this case by setting the fake
	     section size to zero.  Note that "real" bss sections will
	     always have their contents dumped to the core file.  */
	  if (bfd_get_format (abfd) == bfd_core)
	    newsect->size = 0;
@


1.405.2.2
log
@	* elf.c (elf_modify_segment_map): Add remove_empty_load param.
	Don't remove empty PT_LOAD header if false.
	(_bfd_elf_map_sections_to_segments): If user phdrs, pass false
	to elf_modify_segment_map.
	(assign_file_positions_for_load_sections): Pass false to
	elf_modify_segment_map.
@
text
@d3449 1
a3449 3
elf_modify_segment_map (bfd *abfd,
			struct bfd_link_info *info,
			bfd_boolean remove_empty_load)
d3476 1
a3476 1
      if (remove_empty_load && (*m)->p_type == PT_LOAD && (*m)->count == 0)
a3500 1
  bfd_boolean no_user_phdrs;
d3502 2
a3503 2
  no_user_phdrs = elf_tdata (abfd)->segment_map == NULL;
  if (no_user_phdrs && bfd_count_sections (abfd) != 0)
d3872 1
a3872 1
  if (!elf_modify_segment_map (abfd, info, no_user_phdrs))
d3992 1
a3992 1
      && !elf_modify_segment_map (abfd, link_info, FALSE))
@


1.405.2.3
log
@include/elf/
	* common.h (NT_SPU): Define.
bfd/
	* elf.c (elfcore_grok_spu_note): New function.
	(elfcore_read_notes): Call it.
binutils/
	* readelf.c (process_note): Recognize SPU core file notes.
@
text
@a7897 26
static bfd_boolean
elfcore_grok_spu_note (bfd *abfd, Elf_Internal_Note *note)
{
  char *name;
  asection *sect;
  size_t len;

  /* Use note name as section name.  */
  len = note->namesz;
  name = bfd_alloc (abfd, len);
  if (name == NULL)
    return FALSE;
  memcpy (name, note->namedata, len);
  name[len - 1] = '\0';

  sect = bfd_make_section_anyway_with_flags (abfd, name, SEC_HAS_CONTENTS);
  if (sect == NULL)
    return FALSE;

  sect->size            = note->descsz;
  sect->filepos         = note->descpos;
  sect->alignment_power = 1;

  return TRUE;
}

a8209 5
      else if (CONST_STRNEQ (in.namedata, "SPU/"))
	{
	  if (! elfcore_grok_spu_note (abfd, &in))
	    return FALSE;
	}
@


1.405.2.4
log
@2007-10-25  Daniel Jacobowitz  <dan@@codesourcery.com>

	* elf.c (assign_file_positions_for_load_sections): Trust
	p_align_valid.
	(copy_elf_program_header): Copy PT_NULL segments.
@
text
@d4085 2
a4088 2
      else if (m->count == 0)
	p->p_align = 1 << bed->s->log_file_align;
d5566 4
@


1.404
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* elf.c (bfd_elf_print_symbol): Macro dereferences pointer, so
	pointer must be non-null.
@
text
@d5289 1
a5289 1
		  if (matching_lma == 0)
d5542 1
d5557 3
a5559 1
		first_section = section;
d5605 1
a5605 1
	map->p_vaddr_offset = ((first_section ? first_section->lma : 0)
@


1.403
log
@	* elf.c (_bfd_elf_map_sections_to_segments): Work around buggy
	GCC 3.4.x warning.
@
text
@d1367 1
a1367 1
	if (bfd_is_com_section (symbol->section))
@


1.402
log
@	* elf.c (get_program_header_size): Adjacent loadable .note*
	sections need just one PT_NOTE segment.
	(_bfd_elf_map_sections_to_segments): Likewise.
@
text
@d3735 10
a3744 7
		  if (s2->next->alignment_power == 2
		      && (s2->next->flags & SEC_LOAD) != 0
		      && CONST_STRNEQ (s2->next->name, ".note")
		      && align_power (s2->vma + s2->size, 2) == s2->next->vma)
		    count++;
		  else
		    break;
@


1.401
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* elf.c (_bfd_elf_get_synthetic_symtab): Remove meaningless
	pointer increment.
@
text
@d3332 13
d3719 6
a3724 5
      /* For each loadable .note section, add a PT_NOTE segment.  We don't
	 use bfd_get_section_by_name, because if we link together
	 nonloadable .note sections and loadable .note sections, we will
	 generate two .note sections in the output file.  FIXME: Using
	 names for section types is bogus anyhow.  */
d3730 2
d3733 10
d3748 9
a3756 3
	      m->count = 1;
	      m->sections[0] = s;

@


1.400
log
@	* elflink.c (_bfd_elf_link_just_syms, merge_sections_remove_hook,
	_bfd_elf_merge_sections, _bfd_elf_link_hash_newfunc,
	_bfd_elf_link_hash_copy_indirect, _bfd_elf_link_hash_hide_symbol,
	_bfd_elf_link_hash_table_init, _bfd_elf_link_hash_table_create,
	bfd_elf_set_dt_needed_name, bfd_elf_get_dyn_lib_class,
	bfd_elf_set_dyn_lib_class, bfd_elf_get_needed_list,
	bfd_elf_get_runpath_list, bfd_elf_get_dt_soname,
	bfd_elf_get_bfd_needed_list, struct elf_symbuf_symbol,
	struct elf_symbuf_head, struct elf_symbol, elf_sort_elf_symbol,
	elf_sym_name_compare, elf_create_symbuf,
	bfd_elf_match_symbols_in_sections,
	_bfd_elf_match_sections_by_type): Move to here..
	* elf.c: ..from here.
@
text
@d8422 1
a8422 1
  for (i = 0; i < count; i++, s++, p++)
@


1.399
log
@	* elf-bfd.h (struct sym_sec_cache): Delete "sec".  Add "shndx".
	* elf.c (bfd_section_from_r_symndx): Don't cache bfd section of
	symbol.  Instead cache ELF section index.  Remove redundant
	checks of st_shndx.
@
text
@a1046 55
/* Make sure sec_info_type is cleared if sec_info is cleared too.  */

static void
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
{
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
}

/* Finish SHF_MERGE section merging.  */

bfd_boolean
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;

  if (!is_elf_hash_table (info->hash))
    return FALSE;

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    if ((ibfd->flags & DYNAMIC) == 0)
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if ((sec->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (sec->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (sec);
	    if (! _bfd_add_merge_section (abfd,
					  &elf_hash_table (info)->merge_info,
					  sec, &secdata->sec_info))
	      return FALSE;
	    else if (secdata->sec_info)
	      sec->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }

  if (elf_hash_table (info)->merge_info != NULL)
    _bfd_merge_sections (abfd, info, elf_hash_table (info)->merge_info,
			 merge_sections_remove_hook);
  return TRUE;
}

void
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
{
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
  if (!is_elf_hash_table (info->hash))
    return;

  sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
}

a1443 252

/* Create an entry in an ELF linker hash table.  */

struct bfd_hash_entry *
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;
      struct elf_link_hash_table *htab = (struct elf_link_hash_table *) table;

      /* Set local fields.  */
      ret->indx = -1;
      ret->dynindx = -1;
      ret->got = htab->init_got_refcount;
      ret->plt = htab->init_plt_refcount;
      memset (&ret->size, 0, (sizeof (struct elf_link_hash_entry)
			      - offsetof (struct elf_link_hash_entry, size)));
      /* Assume that we have been called by a non-ELF symbol reader.
	 This flag is then reset by the code which reads an ELF input
	 file.  This ensures that a symbol created by a non-ELF symbol
	 reader will have the flag set correctly.  */
      ret->non_elf = 1;
    }

  return entry;
}

/* Copy data from an indirect symbol to its direct symbol, hiding the
   old indirect symbol.  Also used for copying flags to a weakdef.  */

void
_bfd_elf_link_hash_copy_indirect (struct bfd_link_info *info,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
{
  struct elf_link_hash_table *htab;

  /* Copy down any references that we may have already seen to the
     symbol which just became indirect.  */

  dir->ref_dynamic |= ind->ref_dynamic;
  dir->ref_regular |= ind->ref_regular;
  dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
  dir->non_got_ref |= ind->non_got_ref;
  dir->needs_plt |= ind->needs_plt;
  dir->pointer_equality_needed |= ind->pointer_equality_needed;

  if (ind->root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the global and procedure linkage table refcount entries.
     These may have been already set up by a check_relocs routine.  */
  htab = elf_hash_table (info);
  if (ind->got.refcount > htab->init_got_refcount.refcount)
    {
      if (dir->got.refcount < 0)
	dir->got.refcount = 0;
      dir->got.refcount += ind->got.refcount;
      ind->got.refcount = htab->init_got_refcount.refcount;
    }

  if (ind->plt.refcount > htab->init_plt_refcount.refcount)
    {
      if (dir->plt.refcount < 0)
	dir->plt.refcount = 0;
      dir->plt.refcount += ind->plt.refcount;
      ind->plt.refcount = htab->init_plt_refcount.refcount;
    }

  if (ind->dynindx != -1)
    {
      if (dir->dynindx != -1)
	_bfd_elf_strtab_delref (htab->dynstr, dir->dynstr_index);
      dir->dynindx = ind->dynindx;
      dir->dynstr_index = ind->dynstr_index;
      ind->dynindx = -1;
      ind->dynstr_index = 0;
    }
}

void
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
{
  h->plt = elf_hash_table (info)->init_plt_offset;
  h->needs_plt = 0;
  if (force_local)
    {
      h->forced_local = 1;
      if (h->dynindx != -1)
	{
	  h->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  h->dynstr_index);
	}
    }
}

/* Initialize an ELF linker hash table.  */

bfd_boolean
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *),
   unsigned int entsize)
{
  bfd_boolean ret;
  int can_refcount = get_elf_backend_data (abfd)->can_refcount;

  memset (table, 0, sizeof * table);
  table->init_got_refcount.refcount = can_refcount - 1;
  table->init_plt_refcount.refcount = can_refcount - 1;
  table->init_got_offset.offset = -(bfd_vma) 1;
  table->init_plt_offset.offset = -(bfd_vma) 1;
  /* The first dynamic symbol is a dummy.  */
  table->dynsymcount = 1;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);
  table->root.type = bfd_link_elf_hash_table;

  return ret;
}

/* Create an ELF linker hash table.  */

struct bfd_link_hash_table *
_bfd_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_link_hash_table);

  ret = bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (ret, abfd, _bfd_elf_link_hash_newfunc,
				       sizeof (struct elf_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

/* This is a hook for the ELF emulation code in the generic linker to
   tell the backend linker what file name to use for the DT_NEEDED
   entry for a dynamic object.  */

void
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dt_name (abfd) = name;
}

int
bfd_elf_get_dyn_lib_class (bfd *abfd)
{
  int lib_class;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    lib_class = elf_dyn_lib_class (abfd);
  else
    lib_class = 0;
  return lib_class;
}

void
bfd_elf_set_dyn_lib_class (bfd *abfd, enum dynamic_lib_link_class lib_class)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    elf_dyn_lib_class (abfd) = lib_class;
}

/* Get the list of DT_NEEDED entries for a link.  This is a hook for
   the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->needed;
}

/* Get the list of DT_RPATH/DT_RUNPATH entries for a link.  This is a
   hook for the linker ELF emulation code.  */

struct bfd_link_needed_list *
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return NULL;
  return elf_hash_table (info)->runpath;
}

/* Get the name actually used for a dynamic object for a link.  This
   is the SONAME entry if there is one.  Otherwise, it is the string
   passed to bfd_elf_set_dt_needed_name, or it is the filename.  */

const char *
bfd_elf_get_dt_soname (bfd *abfd)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    return elf_dt_name (abfd);
  return NULL;
}

/* Get the list of DT_NEEDED entries from a BFD.  This is a hook for
   the ELF linker emulation code.  */

bfd_boolean
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
{
  asection *s;
  bfd_byte *dynbuf = NULL;
  int elfsec;
  unsigned long shlink;
  bfd_byte *extdyn, *extdynend;
  size_t extdynsize;
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

  *pneeded = NULL;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || bfd_get_format (abfd) != bfd_object)
    return TRUE;
a1444 60
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s == NULL || s->size == 0)
    return TRUE;

  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
    goto error_return;

  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
  if (elfsec == -1)
    goto error_return;

  shlink = elf_elfsections (abfd)[elfsec]->sh_link;

  extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
  swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

  extdyn = dynbuf;
  extdynend = extdyn + s->size;
  for (; extdyn < extdynend; extdyn += extdynsize)
    {
      Elf_Internal_Dyn dyn;

      (*swap_dyn_in) (abfd, extdyn, &dyn);

      if (dyn.d_tag == DT_NULL)
	break;

      if (dyn.d_tag == DT_NEEDED)
	{
	  const char *string;
	  struct bfd_link_needed_list *l;
	  unsigned int tagv = dyn.d_un.d_val;
	  bfd_size_type amt;

	  string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
	  if (string == NULL)
	    goto error_return;

	  amt = sizeof *l;
	  l = bfd_alloc (abfd, amt);
	  if (l == NULL)
	    goto error_return;

	  l->by = abfd;
	  l->name = string;
	  l->next = *pneeded;
	  *pneeded = l;
	}
    }

  free (dynbuf);

  return TRUE;

 error_return:
  if (dynbuf != NULL)
    free (dynbuf);
  return FALSE;
}

a8459 339
struct elf_symbuf_symbol
{
  unsigned long st_name;	/* Symbol name, index in string tbl */
  unsigned char st_info;	/* Type and binding attributes */
  unsigned char st_other;	/* Visibilty, and target specific */
};

struct elf_symbuf_head
{
  struct elf_symbuf_symbol *ssym;
  bfd_size_type count;
  unsigned int st_shndx;
};

struct elf_symbol
{
  union
    {
      Elf_Internal_Sym *isym;
      struct elf_symbuf_symbol *ssym;
    } u;
  const char *name;
};

/* Sort references to symbols by ascending section number.  */

static int
elf_sort_elf_symbol (const void *arg1, const void *arg2)
{
  const Elf_Internal_Sym *s1 = *(const Elf_Internal_Sym **) arg1;
  const Elf_Internal_Sym *s2 = *(const Elf_Internal_Sym **) arg2;

  return s1->st_shndx - s2->st_shndx;
}

static int
elf_sym_name_compare (const void *arg1, const void *arg2)
{
  const struct elf_symbol *s1 = (const struct elf_symbol *) arg1;
  const struct elf_symbol *s2 = (const struct elf_symbol *) arg2;
  return strcmp (s1->name, s2->name);
}

static struct elf_symbuf_head *
elf_create_symbuf (bfd_size_type symcount, Elf_Internal_Sym *isymbuf)
{
  Elf_Internal_Sym **ind, **indbufend, **indbuf
    = bfd_malloc2 (symcount, sizeof (*indbuf));
  struct elf_symbuf_symbol *ssym;
  struct elf_symbuf_head *ssymbuf, *ssymhead;
  bfd_size_type i, shndx_count;

  if (indbuf == NULL)
    return NULL;

  for (ind = indbuf, i = 0; i < symcount; i++)
    if (isymbuf[i].st_shndx != SHN_UNDEF)
      *ind++ = &isymbuf[i];
  indbufend = ind;

  qsort (indbuf, indbufend - indbuf, sizeof (Elf_Internal_Sym *),
	 elf_sort_elf_symbol);

  shndx_count = 0;
  if (indbufend > indbuf)
    for (ind = indbuf, shndx_count++; ind < indbufend - 1; ind++)
      if (ind[0]->st_shndx != ind[1]->st_shndx)
	shndx_count++;

  ssymbuf = bfd_malloc ((shndx_count + 1) * sizeof (*ssymbuf)
			+ (indbufend - indbuf) * sizeof (*ssymbuf));
  if (ssymbuf == NULL)
    {
      free (indbuf);
      return NULL;
    }

  ssym = (struct elf_symbuf_symbol *) (ssymbuf + shndx_count);
  ssymbuf->ssym = NULL;
  ssymbuf->count = shndx_count;
  ssymbuf->st_shndx = 0;
  for (ssymhead = ssymbuf, ind = indbuf; ind < indbufend; ssym++, ind++)
    {
      if (ind == indbuf || ssymhead->st_shndx != (*ind)->st_shndx)
	{
	  ssymhead++;
	  ssymhead->ssym = ssym;
	  ssymhead->count = 0;
	  ssymhead->st_shndx = (*ind)->st_shndx;
	}
      ssym->st_name = (*ind)->st_name;
      ssym->st_info = (*ind)->st_info;
      ssym->st_other = (*ind)->st_other;
      ssymhead->count++;
    }
  BFD_ASSERT ((bfd_size_type) (ssymhead - ssymbuf) == shndx_count);

  free (indbuf);
  return ssymbuf;
}

/* Check if 2 sections define the same set of local and global
   symbols.  */

bfd_boolean
bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
				   struct bfd_link_info *info)
{
  bfd *bfd1, *bfd2;
  const struct elf_backend_data *bed1, *bed2;
  Elf_Internal_Shdr *hdr1, *hdr2;
  bfd_size_type symcount1, symcount2;
  Elf_Internal_Sym *isymbuf1, *isymbuf2;
  struct elf_symbuf_head *ssymbuf1, *ssymbuf2;
  Elf_Internal_Sym *isym, *isymend;
  struct elf_symbol *symtable1 = NULL, *symtable2 = NULL;
  bfd_size_type count1, count2, i;
  int shndx1, shndx2;
  bfd_boolean result;

  bfd1 = sec1->owner;
  bfd2 = sec2->owner;

  /* If both are .gnu.linkonce sections, they have to have the same
     section name.  */
  if (CONST_STRNEQ (sec1->name, ".gnu.linkonce")
      && CONST_STRNEQ (sec2->name, ".gnu.linkonce"))
    return strcmp (sec1->name + sizeof ".gnu.linkonce",
		   sec2->name + sizeof ".gnu.linkonce") == 0;

  /* Both sections have to be in ELF.  */
  if (bfd_get_flavour (bfd1) != bfd_target_elf_flavour
      || bfd_get_flavour (bfd2) != bfd_target_elf_flavour)
    return FALSE;

  if (elf_section_type (sec1) != elf_section_type (sec2))
    return FALSE;

  if ((elf_section_flags (sec1) & SHF_GROUP) != 0
      && (elf_section_flags (sec2) & SHF_GROUP) != 0)
    {
      /* If both are members of section groups, they have to have the
	 same group name.  */
      if (strcmp (elf_group_name (sec1), elf_group_name (sec2)) != 0)
	return FALSE;
    }

  shndx1 = _bfd_elf_section_from_bfd_section (bfd1, sec1);
  shndx2 = _bfd_elf_section_from_bfd_section (bfd2, sec2);
  if (shndx1 == -1 || shndx2 == -1)
    return FALSE;

  bed1 = get_elf_backend_data (bfd1);
  bed2 = get_elf_backend_data (bfd2);
  hdr1 = &elf_tdata (bfd1)->symtab_hdr;
  symcount1 = hdr1->sh_size / bed1->s->sizeof_sym;
  hdr2 = &elf_tdata (bfd2)->symtab_hdr;
  symcount2 = hdr2->sh_size / bed2->s->sizeof_sym;

  if (symcount1 == 0 || symcount2 == 0)
    return FALSE;

  result = FALSE;
  isymbuf1 = NULL;
  isymbuf2 = NULL;
  ssymbuf1 = elf_tdata (bfd1)->symbuf;
  ssymbuf2 = elf_tdata (bfd2)->symbuf;

  if (ssymbuf1 == NULL)
    {
      isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
				       NULL, NULL, NULL);
      if (isymbuf1 == NULL)
	goto done;

      if (!info->reduce_memory_overheads)
	elf_tdata (bfd1)->symbuf = ssymbuf1
	  = elf_create_symbuf (symcount1, isymbuf1);
    }

  if (ssymbuf1 == NULL || ssymbuf2 == NULL)
    {
      isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
				       NULL, NULL, NULL);
      if (isymbuf2 == NULL)
	goto done;

      if (ssymbuf1 != NULL && !info->reduce_memory_overheads)
	elf_tdata (bfd2)->symbuf = ssymbuf2
	  = elf_create_symbuf (symcount2, isymbuf2);
    }

  if (ssymbuf1 != NULL && ssymbuf2 != NULL)
    {
      /* Optimized faster version.  */
      bfd_size_type lo, hi, mid;
      struct elf_symbol *symp;
      struct elf_symbuf_symbol *ssym, *ssymend;

      lo = 0;
      hi = ssymbuf1->count;
      ssymbuf1++;
      count1 = 0;
      while (lo < hi)
	{
	  mid = (lo + hi) / 2;
	  if ((unsigned int) shndx1 < ssymbuf1[mid].st_shndx)
	    hi = mid;
	  else if ((unsigned int) shndx1 > ssymbuf1[mid].st_shndx)
	    lo = mid + 1;
	  else
	    {
	      count1 = ssymbuf1[mid].count;
	      ssymbuf1 += mid;
	      break;
	    }
	}

      lo = 0;
      hi = ssymbuf2->count;
      ssymbuf2++;
      count2 = 0;
      while (lo < hi)
	{
	  mid = (lo + hi) / 2;
	  if ((unsigned int) shndx2 < ssymbuf2[mid].st_shndx)
	    hi = mid;
	  else if ((unsigned int) shndx2 > ssymbuf2[mid].st_shndx)
	    lo = mid + 1;
	  else
	    {
	      count2 = ssymbuf2[mid].count;
	      ssymbuf2 += mid;
	      break;
	    }
	}

      if (count1 == 0 || count2 == 0 || count1 != count2)
	goto done;

      symtable1 = bfd_malloc (count1 * sizeof (struct elf_symbol));
      symtable2 = bfd_malloc (count2 * sizeof (struct elf_symbol));
      if (symtable1 == NULL || symtable2 == NULL)
	goto done;

      symp = symtable1;
      for (ssym = ssymbuf1->ssym, ssymend = ssym + count1;
	   ssym < ssymend; ssym++, symp++)
	{
	  symp->u.ssym = ssym;
	  symp->name = bfd_elf_string_from_elf_section (bfd1,
							hdr1->sh_link,
							ssym->st_name);
	}

      symp = symtable2;
      for (ssym = ssymbuf2->ssym, ssymend = ssym + count2;
	   ssym < ssymend; ssym++, symp++)
	{
	  symp->u.ssym = ssym;
	  symp->name = bfd_elf_string_from_elf_section (bfd2,
							hdr2->sh_link,
							ssym->st_name);
	}

      /* Sort symbol by name.  */
      qsort (symtable1, count1, sizeof (struct elf_symbol),
	     elf_sym_name_compare);
      qsort (symtable2, count1, sizeof (struct elf_symbol),
	     elf_sym_name_compare);

      for (i = 0; i < count1; i++)
	/* Two symbols must have the same binding, type and name.  */
	if (symtable1 [i].u.ssym->st_info != symtable2 [i].u.ssym->st_info
	    || symtable1 [i].u.ssym->st_other != symtable2 [i].u.ssym->st_other
	    || strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
	  goto done;

      result = TRUE;
      goto done;
    }

  symtable1 = bfd_malloc (symcount1 * sizeof (struct elf_symbol));
  symtable2 = bfd_malloc (symcount2 * sizeof (struct elf_symbol));
  if (symtable1 == NULL || symtable2 == NULL)
    goto done;

  /* Count definitions in the section.  */
  count1 = 0;
  for (isym = isymbuf1, isymend = isym + symcount1; isym < isymend; isym++)
    if (isym->st_shndx == (unsigned int) shndx1)
      symtable1[count1++].u.isym = isym;

  count2 = 0;
  for (isym = isymbuf2, isymend = isym + symcount2; isym < isymend; isym++)
    if (isym->st_shndx == (unsigned int) shndx2)
      symtable2[count2++].u.isym = isym;

  if (count1 == 0 || count2 == 0 || count1 != count2)
    goto done;

  for (i = 0; i < count1; i++)
    symtable1[i].name
      = bfd_elf_string_from_elf_section (bfd1, hdr1->sh_link,
					 symtable1[i].u.isym->st_name);

  for (i = 0; i < count2; i++)
    symtable2[i].name
      = bfd_elf_string_from_elf_section (bfd2, hdr2->sh_link,
					 symtable2[i].u.isym->st_name);

  /* Sort symbol by name.  */
  qsort (symtable1, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);
  qsort (symtable2, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);

  for (i = 0; i < count1; i++)
    /* Two symbols must have the same binding, type and name.  */
    if (symtable1 [i].u.isym->st_info != symtable2 [i].u.isym->st_info
	|| symtable1 [i].u.isym->st_other != symtable2 [i].u.isym->st_other
	|| strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
      goto done;

  result = TRUE;

done:
  if (symtable1)
    free (symtable1);
  if (symtable2)
    free (symtable2);
  if (isymbuf1)
    free (isymbuf1);
  if (isymbuf2)
    free (isymbuf2);

  return result;
}

a8464 15
/* Return TRUE if 2 section types are compatible.  */

bfd_boolean
_bfd_elf_match_sections_by_type (bfd *abfd, const asection *asec,
				 bfd *bbfd, const asection *bsec)
{
  if (asec == NULL
      || bsec == NULL
      || abfd->xvec->flavour != bfd_target_elf_flavour
      || bbfd->xvec->flavour != bfd_target_elf_flavour)
    return TRUE;

  return elf_section_type (asec) == elf_section_type (bsec);
}

@


1.398
log
@2007-07-13  Roland McGrath  <roland@@redhat.com>

	* elf-bfd.h (struct elf_obj_tdata): Revert last change.
	Add after_write_object_contents, after_write_object_contents_info.
	* elf.c (_bfd_elf_write_object_contents): Revert last change.
	Instead, call after_write_object_contents if set.
@
text
@a2275 4
  Elf_Internal_Shdr *symtab_hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
d2277 1
d2279 6
a2284 2
  if (cache->abfd == abfd && cache->indx[ent] == r_symndx)
    return cache->sec[ent];
d2286 4
a2289 4
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
			    &isym, esym, &eshndx) == NULL)
    return NULL;
d2291 7
a2297 4
  if (cache->abfd != abfd)
    {
      memset (cache->indx, -1, sizeof (cache->indx));
      cache->abfd = abfd;
d2299 6
a2304 11
  cache->indx[ent] = r_symndx;
  cache->sec[ent] = sec;
  if ((isym.st_shndx != SHN_UNDEF && isym.st_shndx < SHN_LORESERVE)
      || isym.st_shndx > SHN_HIRESERVE)
    {
      asection *s;
      s = bfd_section_from_elf_index (abfd, isym.st_shndx);
      if (s != NULL)
	cache->sec[ent] = s;
    }
  return cache->sec[ent];
@


1.397
log
@2007-07-09  Roland McGrath  <roland@@redhat.com>

	* elf-bfd.h (struct elf_obj_tdata): Add members
	emit_note_gnu_build_id and note_gnu_build_id_sec.
	* elf.c (_bfd_id_note_section_size): New global function.
	(read_hex, _bfd_elf_write_build_id_section): New static functions.
	(_bfd_elf_write_object_contents): Call _bfd_elf_write_build_id_section
	if emit_note_gnu_build_id is set.
	* Makefile.am (elf.lo): Update dependencies.
@
text
@a45 1
#include "md5.h"
a5076 143
bfd_size_type
_bfd_id_note_section_size (bfd *abfd, struct bfd_link_info *link_info)
{
  const char *style = link_info->emit_note_gnu_build_id;
  bfd_size_type size;

  abfd = abfd;

  size = offsetof (Elf_External_Note, name[sizeof "GNU"]);
  size = BFD_ALIGN (size, 4);

  if (!strcmp (style, "md5") || !strcmp (style, "uuid"))
    size += 128 / 8;
#if 0				/* libiberty has md5 but not sha1 */
  else if (!strcmp (style, "sha1"))
    size += 160 / 8;
#endif
  else if (!strncmp (style, "0x", 2))
    {
      /* ID is in string form (hex).  Convert to bits.  */
      const char *id = style + 2;
      do
	{
	  if (ISXDIGIT (id[0]) && ISXDIGIT (id[1]))
	    {
	      ++size;
	      id += 2;
	    }
	  else if (*id == '-' || *id == ':')
	    ++id;
	  else
	    {
	      size = 0;
	      break;
	    }
	} while (*id != '\0');
    }
  else
    size = 0;

  return size;
}

static unsigned char
read_hex (const char xdigit)
{
  if (ISDIGIT (xdigit))
    return xdigit - '0';
  if (ISUPPER (xdigit))
    return xdigit - 'A' + 0xa;
  if (ISLOWER (xdigit))
    return xdigit - 'a' + 0xa;
  abort ();
  return 0;
}

static bfd_boolean
_bfd_elf_write_build_id_section (bfd *abfd, const char *style)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  asection *asec;
  Elf_Internal_Shdr *i_shdr;
  unsigned char *contents, *id_bits;
  bfd_size_type size;
  Elf_External_Note *e_note;

  asec = elf_tdata (abfd)->note_gnu_build_id_sec;
  if (asec->output_section == NULL)
    {
      _bfd_error_handler (_(".note.gnu.build-id section missing"));
      return FALSE;
    }
  i_shdr = &elf_section_data (asec->output_section)->this_hdr;

  if (i_shdr->contents == NULL)
    {
      BFD_ASSERT (asec->output_offset == 0);
      i_shdr->contents = bfd_zalloc (abfd, i_shdr->sh_size);
      if (i_shdr->contents == NULL)
	return FALSE;
    }
  contents = i_shdr->contents + asec->output_offset;

  e_note = (void *) contents;
  size = offsetof (Elf_External_Note, name[sizeof "GNU"]);
  size = BFD_ALIGN (size, 4);
  id_bits = contents + size;
  size = asec->size - size;

  bfd_h_put_32 (abfd, sizeof "GNU", &e_note->namesz);
  bfd_h_put_32 (abfd, size, &e_note->descsz);
  bfd_h_put_32 (abfd, NT_GNU_BUILD_ID, &e_note->type);
  memcpy (e_note->name, "GNU", sizeof "GNU");

  if (!strcmp (style, "md5"))
    {
      struct md5_ctx ctx;
      md5_init_ctx (&ctx);
      if (bed->s->checksum_contents (abfd,
				     (void (*) (const void *, size_t, void *))
				     &md5_process_bytes,
				     &ctx))
	md5_finish_ctx (&ctx, id_bits);
      else
	return FALSE;
    }
  else if (!strcmp (style, "uuid"))
    {
      int n;
      int fd = open ("/dev/urandom", O_RDONLY);
      if (fd < 0)
	return FALSE;
      n = read (fd, id_bits, size);
      close (fd);
      if (n < (int) size)
	return FALSE;
    }
  else if (!strncmp (style, "0x", 2))
    {
      /* ID is in string form (hex).  Convert to bits.  */
      const char *id = style + 2;
      size_t n = 0;
      do
	{
	  if (ISXDIGIT (id[0]) && ISXDIGIT (id[1]))
	    {
	      id_bits[n] = read_hex (*id++) << 4;
	      id_bits[n++] |= read_hex (*id++);
	    }
	  else if (*id == '-' || *id == ':')
	    ++id;
	  else
	    abort ();		/* Should have been validated earlier.  */
	} while (*id != '\0');
    }
  else
    abort ();			/* Should have been validated earlier.  */

  size = i_shdr->sh_size;
  return (bfd_seek (abfd, i_shdr->sh_offset, SEEK_SET) == 0
	  && bfd_bwrite (i_shdr->contents, size, abfd) == size);
}

a5084 1
  char *id_style;
d5132 2
a5133 3
  id_style = elf_tdata (abfd)->emit_note_gnu_build_id;
  if (id_style && !_bfd_elf_write_build_id_section (abfd, id_style))
    return FALSE;
@


1.396
log
@Switch sources over to use the GPL version 3
@
text
@d45 2
d5078 143
d5229 1
d5273 9
a5281 1
  return bed->s->write_shdrs_and_ehdr (abfd);
@


1.395
log
@	PR 4712
	* elf.c (assign_file_positions_for_load_sections): Adjust lma
	by p_vaddr_offset.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.394
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d509 1
a509 1
      
d515 1
a515 1
	
d868 1
a868 1
      
d905 2
a906 2
         If all the p_paddr fields are zero, we ignore them, since
         some ELF linkers produce such output.  */
d927 3
a929 3
	         place special significance on the address 0 and
	         executables need to be able to have a segment which
	         covers this address.  */
d1528 3
a1530 3
         This flag is then reset by the code which reads an ELF input
         file.  This ensures that a symbol created by a non-ELF symbol
         reader will have the flag set correctly.  */
d1916 5
a1920 5
         SHF_ALLOC is set, and this is a shared object, then we also
         treat this section as a BFD section.  We can not base the
         decision purely on SHF_ALLOC, because that flag is sometimes
         set in a relocatable object file, which would confuse the
         linker.  */
d2242 1
a2242 1
	       required to correctly process the section and the file should 
d2766 1
a2766 1
         loop.  */
d2855 2
a2856 2
         cverdefs.  The linker will set cverdefs, but sh_info will be
         zero.  */
d2867 2
a2868 2
         cverrefs.  The linker will set cverrefs, but sh_info will be
         zero.  */
d3052 1
a3052 1
	    { 
d3059 1
a3059 1
	      else 
d3246 1
a3246 1
	         where s is NULL.  */
d3326 2
a3327 3
	     list 
	     used for the dynamic entries, or the symbol table, or the
	     version strings.  */
d3629 1
a3629 1
         out.  */
d3669 1
a3669 1
      
d3775 1
a3775 1
  
d4276 1
a4276 1
     
d4347 1
a4347 1
         sections may not be correctly ordered.  NOTE: sorting should
d4375 1
a4375 1
	p->p_paddr = m->sections[0]->lma;
d4415 1
a4415 1
		  
d4923 1
a4923 1
         assignment of sections to segments.  */
d5118 1
a5118 1
          || ! _bfd_elf_strtab_emit (abfd, elf_shstrtab (abfd))))
d5207 1
a5207 1
         which is used in a relocation entry.  */
d5306 1
a5306 1
          if that is set for the segment and the VMA otherwise,
d5314 1
a5314 1
          (with the possible exception of .dynamic).  */
d5330 2
a5331 2
           ? segment->p_paddr != section->lma				\
           : segment->p_vaddr != section->vma)				\
d5333 1
a5333 1
           == 0))							\
d5354 1
a5354 1
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\
d5356 1
a5356 1
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))
d5399 1
a5399 1
                 SEGMENT.  */
d5420 1
a5420 1
                 SEGMENT2.  */
d5610 1
a5610 2
		      IS_CONTAINED_BY_VMA (output_section, segment))
                )
d5638 1
a5638 1
	  
d5645 1
a5645 1
	  
d5927 1
a5927 1
      
a8002 1

d8030 3
a8032 3
         find this note before any of the others, which is fine,
         since the kernel writes this note out first when it
         creates a core file.  */
d8048 2
a8049 2
    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0 and
       PT_GETFPREGS == mach+2.  */
d8054 3
a8056 10
        {
        case NT_NETBSDCORE_FIRSTMACH+0:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+2:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }
d8058 9
a8066 2
    /* On all other arch's, PT_GETREGS == mach+1 and
       PT_GETFPREGS == mach+3.  */
d8070 10
a8079 10
        {
        case NT_NETBSDCORE_FIRSTMACH+1:
          return elfcore_make_note_pseudosection (abfd, ".reg", note);

        case NT_NETBSDCORE_FIRSTMACH+3:
          return elfcore_make_note_pseudosection (abfd, ".reg2", note);

        default:
          return TRUE;
        }
d8499 4
a8502 4
        {
          if (! elfcore_grok_netbsd_note (abfd, &in))
            goto error;
        }
d8509 4
a8512 4
        {
          if (! elfcore_grok_note (abfd, &in))
            goto error;
        }
@


1.393
log
@	* elf.c (assign_file_positions_for_load_sections): Use elf
	section header sh_size rather than bfd section size, simplifying
	.tbss handling.
@
text
@d1116 4
d2202 10
@


1.392
log
@	* elf.c (assign_file_positions_for_load_sections): Ensure bss
	segments meet gABI alignment requirements.  Don't allocate
	file space for bss sections in a segment also containing file
	or program headers.
@
text
@d4581 2
a4582 2
		  off += sec->size;
		  p->p_filesz = sec->size;
d4601 1
a4601 1
		    off += sec->size;
d4606 1
a4606 1
		  p->p_filesz += sec->size;
d4611 1
a4611 1
		    p->p_memsz += sec->size;
d4613 4
d4618 4
a4621 14
	      /* .tbss is special.  It doesn't contribute to p_memsz of
		 normal segments.  */
	      else if ((this_hdr->sh_flags & SHF_ALLOC) != 0
		       && ((this_hdr->sh_flags & SHF_TLS) == 0
			   || p->p_type == PT_TLS))
		p->p_memsz += sec->size;

	      if (p->p_type == PT_TLS
		  && sec->size == 0
		  && (sec->flags & SEC_HAS_CONTENTS) == 0)
		{
		  struct bfd_link_order *o = sec->map_tail.link_order;
		  if (o != NULL)
		    p->p_memsz += o->offset + o->size;
@


1.391
log
@bfd/
	* elf.c (elf_fake_sections): Adjust test for SHT_NOBITS sections
	created by objcopy --only-keep-debug.
	(_bfd_elf_init_private_section_data): Only change elf_section_type
	if it is SHT_NULL.
binutils/
	* objcopy.c (copy_object): Revert 2007-05-11 change.  Don't
	avoid calling bfd_copy_private_bfd_data for ELF STRIP_NONDEBUG.
	(setup_section): Don't modify flags, and don't avoid calling
	bfd_copy_private_section_data for ELF STRIP_NONDEBUG.
	* readelf.c (process_program_headers): Ignore .dynamic of type
	SHT_NOBITS.
@
text
@d4330 2
d4387 2
a4392 1
	  bfd_vma adjust;
d4419 11
a4429 9
	  adjust = vma_page_aligned_bias (m->sections[0]->vma, off, align);
	  if (adjust != 0)
	    {
	      /* If the first section isn't loadable, the same holds
		 for any other sections.  We don't need to align the
		 segment on disk since the segment doesn't need file
		 space.  */
	      i = 0;
	      while (elf_section_type (m->sections[i]) == SHT_NOBITS)
d4431 2
a4432 9
		  /* If a segment starts with .tbss, we need to look
		     at the next section to decide whether the segment
		     has any loadable sections.  */
		  if ((elf_section_flags (m->sections[i]) & SHF_TLS) == 0
		      || ++i >= m->count)
		    {
		      adjust = 0;
		      break;
		    }
a4433 1
	      off += adjust;
d4435 16
d4471 1
a4471 1
	  if (! m->p_flags_valid)
d4489 1
a4489 1
	      if (! m->p_paddr_valid)
d4496 1
a4496 1
	  if (! m->p_flags_valid)
d4507 1
a4507 1
		  if (! m->p_paddr_valid)
d4519 1
a4519 1
	  if (! m->includes_filehdr && ! m->includes_phdrs)
d4526 2
a4527 1
	      p->p_filesz += adjust;
d4639 1
a4639 1
	  if (! m->p_flags_valid)
d4648 1
@


1.390
log
@	* elf.c (assign_file_positions_for_load_sections): Correct sh_type
	to SHT_NOBITS earlier.  Base actions in rest of function on sh_type
	and sh_flags instead of bfd section flags.  Delete voff and code
	keeping nobits segments aligned.
@
text
@d2910 1
a2910 2
  if (sh_type == SHT_NOBITS
      && elf_elfheader (abfd)->e_phnum == 0)
d2913 1
a2913 1
	 called for strip/objcopy --only-keep-debug.  */
d6041 3
a6043 7
  if (osec->flags == isec->flags || !osec->flags)
    {
      BFD_ASSERT (osec->flags == isec->flags 
		  || (!osec->flags
		      && elf_section_type (osec) == SHT_NULL));
      elf_section_type (osec) = elf_section_type (isec);
    }
@


1.389
log
@	PR 4479
	* elf.c (elf_fake_sections): Don't allow backend to change
	SHT_NOBITS if called for strip/objcopy --only-keep-debug.
	* elfxx-mips.c (_bfd_mips_elf_fake_sections): Remove similar
	fix from here.
@
text
@d4285 1
a4285 1
  file_ptr off, voff;
d4347 1
a4347 4
	 available file offset for PT_LOAD and PT_NOTE segments.  VOFF is
	 an adjustment we use for segments that have no file contents
	 but need zero filled memory allocation.  */
      voff = 0;
d4410 7
d4418 6
a4423 12
	  off += adjust;
	  if (adjust != 0
	      && !m->includes_filehdr
	      && !m->includes_phdrs
	      && (ufile_ptr) off >= align)
	    {
	      /* If the first section isn't loadable, the same holds for
		 any other sections.  Since the segment won't need file
		 space, we can make p_offset overlap some prior segment.
		 However, .tbss is special.  If a segment starts with
		 .tbss, we need to look at the next section to decide
		 whether the segment has any loadable sections.  */
d4425 1
a4425 2
	      while ((m->sections[i]->flags & SEC_LOAD) == 0
		     && (m->sections[i]->flags & SEC_HAS_CONTENTS) == 0)
d4427 4
a4430 1
		  if ((m->sections[i]->flags & SEC_THREAD_LOCAL) == 0
d4433 1
a4433 2
		      off -= adjust;
		      voff = adjust - align;
d4437 1
d4508 1
a4508 1
	    p->p_offset = off + voff;
a4526 1
	  flagword flags;
d4531 1
a4531 1
	  flags = sec->flags;
d4539 3
a4541 3
	      if ((flags & SEC_LOAD) != 0
		  || ((flags & SEC_ALLOC) != 0
		      && ((flags & SEC_THREAD_LOCAL) == 0
d4553 1
a4553 1
		  if ((flags & SEC_LOAD) != 0)
a4560 1
	  this_hdr = &elf_section_data (sec)->this_hdr;
d4586 2
a4587 17
		  this_hdr->sh_offset = sec->filepos = off + voff;
		  /* FIXME: The SEC_HAS_CONTENTS test here dates back to
		     1997, and the exact reason for it isn't clear.  One
		     plausible explanation is that it is to work around
		     a problem we have with linker scripts using data
		     statements in NOLOAD sections.  I don't think it
		     makes a great deal of sense to have such a section
		     assigned to a PT_LOAD segment, but apparently
		     people do this.  The data statement results in a
		     bfd_data_link_order being built, and these need
		     section contents to write into.  Eventually, we get
		     to _bfd_elf_write_object_contents which writes any
		     section with contents to the output.  Make room
		     here for the write, so that following segments are
		     not trashed.  */
		  if ((flags & SEC_LOAD) != 0
		      || (flags & SEC_HAS_CONTENTS) != 0)
a4588 5
		  else
		    /* If we aren't making room for this section, then
		       it must be SHT_NOBITS regardless of what we've
		       set via struct bfd_elf_special_section.  */
		    this_hdr->sh_type = SHT_NOBITS;
d4591 1
a4591 1
	      if ((flags & SEC_LOAD) != 0)
d4594 4
a4597 5
		  /* SEC_LOAD without SEC_ALLOC is a weird combination
		     used by note sections to signify that a PT_NOTE
		     segment should be created.  These take file space
		     but are not actually loaded into memory.  */
		  if ((flags & SEC_ALLOC) != 0)
d4603 2
a4604 2
	      else if ((flags & SEC_ALLOC) != 0
		       && ((flags & SEC_THREAD_LOCAL) == 0
d4629 1
a4629 1
	      if ((flags & SEC_CODE) != 0)
d4631 1
a4631 1
	      if ((flags & SEC_READONLY) == 0)
@


1.388
log
@	* elf.c (bfd_elf_string_from_elf_section): Return NULL on
	invalid shstrndx.
	(bfd_elf_get_str_section): Likewise.
@
text
@d2747 1
d2905 1
d2910 8
@


1.387
log
@bfd/
	* elf.c (assign_file_positions_for_load_sections): Use p_memsz
	rather than p_filesz to calculate the LMA of the end of a segment.

ld/testsuite/
	* ld-elf/multibss1.d, ld-elf/multibss1.s: New test.
@
text
@d255 3
a257 1
  if (i_shdrp == 0 || i_shdrp[shindex] == 0)
d296 3
@


1.386
log
@	* elf.c (assign_file_positions_for_load_sections): Don't check
	core segment.
@
text
@d4523 1
a4523 1
	      bfd_signed_vma adjust = sec->lma - (p->p_paddr + p->p_filesz);
@


1.385
log
@include/elf/
	* internal.h (ELF_IS_SECTION_IN_SEGMENT): Check both file offset
	and vma for appropriate sections.
bfd/
	* elf.c (assign_file_positions_for_load_sections): Set sh_offset
	here.  Set sh_type to SHT_NOBITS if we won't be allocating
	file space.  Don't bump p_memsz for non-alloc sections.  Adjust
	section-in-segment check.
	(assign_file_positions_for_non_load_sections): Don't set sh_offset
	here for sections that have already been handled above.
@
text
@d4644 3
a4646 3
      /* Check that all sections are in the segment.  */
      if (p->p_type == PT_LOAD
	  || (p->p_type == PT_NOTE && bfd_get_format (abfd) == bfd_core))
@


1.384
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d4514 1
d4547 1
d4554 1
a4554 1
		  sec->filepos = off;
d4573 1
a4573 1
		  sec->filepos = off + voff;
d4591 5
d4601 6
a4606 1
		  p->p_memsz += sec->size;
d4644 3
a4646 5
      /* Check if all sections are in the segment.  Skip PT_GNU_RELRO
	 and PT_NOTE segments since they will be processed by
	 assign_file_positions_for_non_load_sections later.  */
      if (p->p_type != PT_GNU_RELRO
	  && p->p_type != PT_NOTE)
d4702 1
a4702 1
	hdr->sh_offset = hdr->bfd_section->filepos;
@


1.383
log
@2007-04-17  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf.c (_bfd_elf_is_function_type): New function.
	* elflink.c (_bfd_elf_merge_symbol): Use bed->is_function_type.
	(_bfd_elf_dynamic_symbol_p, _bfd_elf_symbol_refs_local_p,
	is_global_data_symbol_definition, elf_link_add_object_symbols): Ditto.
	* elf-bfd.h (elf_backend_data): Add is_function_type.
	(_bfd_elf_is_function_type): Add prototype.
	* elfxx-target.h (elf_backend_is_function_type): Add default
	definition.
	(elfNN_bed): Add elf_backend_is_function_type.
	* elf32-arm.c (elf32_arm_is_function_type): New function.
	(elf_backend_is_function_type): Define.

	ld/testsuite/
	* ld-arm/preempt-app.s: New test.
	* ld-arm/preempt-app.sym: New.
	* ld-arm/arm-elf.exp: Add preempt-app.
@
text
@d36 1
a37 1
#include "sysdep.h"
@


1.382
log
@PR binutils/4110
* elf.c (IS_VALID_GROUP_SECTION_HEADER): New macro.
  (setup_group): Use it.  Report corrupt group section headers.
  (bfd_section_from_shdr): Use new macro.  Replace constant 4 with
      GRP_ENTRY_SIZE.  Cope with NULLs in the group section table.
  (elf_fake_section): Replace constant 4 with GRP_ENTRY_SIZE.
@
text
@d9170 11
@


1.381
log
@bfd/

2007-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4007
	* elf.c (assign_file_positions_for_load_sections): Check if
	all sections are in the segment.

ld/testsuite/

2007-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4007
	* ld-elf/note-1.d: New file.
	* ld-elf/note-1.s: Likewise.
	* ld-elf/note-1.t: Likewise.
	* ld-i386/alloc.d: Likewise.
	* ld-i386/alloc.s: Likewise.
	* ld-i386/alloc.t: Likewise.

	* ld-i386/i386.exp: Run "alloc".
@
text
@d504 7
d514 2
a515 1
	  if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
d540 2
a541 1
	      if (shdr->sh_type == SHT_GROUP && shdr->sh_size >= 8)
d555 12
a566 2
		  if (shdr->contents == NULL
		      || bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0
d2158 1
a2158 1
      if (hdr->sh_entsize != GRP_ENTRY_SIZE)
d2168 1
a2168 1
	  unsigned int n_elt = hdr->sh_size / 4;
d2178 11
a2188 6
	    if ((s = (--idx)->shdr->bfd_section) != NULL
		&& elf_next_in_group (s) != NULL)
	      {
		elf_next_in_group (hdr->bfd_section) = s;
		break;
	      }
d2857 1
a2857 1
      this_hdr->sh_entsize = 4;
@


1.380
log
@PR binutils/3535
* elf.c (copy_private_bfd_data): Widen the scope of Solaris specific
  conditions that need the program headers to be rewritten.
@
text
@d4249 1
a4249 1
  unsigned int i;
d4287 1
a4287 1
  for (m = elf_tdata (abfd)->segment_map, p = phdrs;
d4289 1
a4289 1
       m = m->next, p++)
d4607 23
@


1.379
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d5918 7
a5924 13
	  /* This is a different version of the IS_SOLARIS_PT_INTERP
	     macro to the one defined in rewrite_elf_program_header().  */
#define IS_SOLARIS_PT_INTERP(p)			\
  (p->p_type == PT_INTERP			\
   && p->p_vaddr == 0				\
   && p->p_paddr == 0				\
   && p->p_memsz == 0				\
   && p->p_filesz > 0)
 
	  /* PR binutils/3535.  The Solaris interpreter program header
	     needs special treatment, so we always rewrite the headers
	     when one is detected.  */
	  if (IS_SOLARIS_PT_INTERP (segment))
d5926 1
a5926 1
	  
@


1.378
log
@	PR 4144
	* elf.c (assign_file_positions_for_load_sections): Don't
	adjust p_memsz for !SEC_LOAD section vma modulo page size.
	Instead, use the same lma based adjustment for SEC_LOAD
	sections.
@
text
@d9118 11
@


1.377
log
@PR binutils/3535
* elf.c (copy_private_bfd_data): Always rewrite the program headers when a
  Solaris interpreter segment is involved.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d4498 1
a4498 1
	      bfd_signed_vma adjust;
d4500 4
a4503 1
	      if ((flags & SEC_LOAD) != 0)
a4504 1
		  adjust = sec->lma - (p->p_paddr + p->p_filesz);
a4511 18
		  off += adjust;
		  p->p_filesz += adjust;
		  p->p_memsz += adjust;
		}
	      /* .tbss is special.  It doesn't contribute to p_memsz of
		 normal segments.  */
	      else if ((flags & SEC_ALLOC) != 0
		       && ((flags & SEC_THREAD_LOCAL) == 0
			   || p->p_type == PT_TLS))
		{
		  /* The section VMA must equal the file position
		     modulo the page size.  */
		  bfd_size_type page = align;
		  if (page < maxpagesize)
		    page = maxpagesize;
		  adjust = vma_page_aligned_bias (sec->vma,
						  p->p_vaddr + p->p_memsz,
						  page);
d4513 6
@


1.376
log
@Take into account MEMORY regions when creating a segment map.
@
text
@a4421 1
	  p->p_offset = 0;
d5226 1
a5226 1
   && ((bfd_vma) s->filepos + s->size				\
d5240 1
a5240 1
   && ((bfd_vma) s->filepos + s->size				\
d5911 2
a5912 2
      /* Check if any sections in the input BFD covered by ELF program
	 header are changed.  */
d5928 15
d5970 1
a5970 1
      /* Check to see if any output section doesn't come from the
@


1.375
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d3956 4
@


1.374
log
@	* elf-bfd.h (struct elf_obj_tdata): Change symbuf type to void *.
	* elf.c (struct elf_symbuf_symbol, struct elf_symbuf_head): New types.
	(struct elf_symbol): Change first member into union.
	(elf_sort_elf_symbol): Compare pointers to internal syms rather than
	internal syms.  Only compare st_shndx fields.
	(elf_create_symbuf): New function.
	(bfd_elf_match_symbols_in_sections): Use it.  If symbufs are available
	for bfds, use a binary search, otherwise don't qsort symbols
	unnecessarily only to select which symbols are for the particular
	shndx.
@
text
@d6381 4
@


1.373
log
@PR ld/3852
* elf.c (_bfd_elf_link_hash_table_init): Initialize all the fields in the
elf_link_hash_table structure.
@
text
@d8748 6
a8753 2
/* Sort symbol by binding and section. We want to put definitions
   sorted by section at the beginning.  */
d8755 1
a8755 2
static int
elf_sort_elf_symbol (const void *arg1, const void *arg2)
d8757 4
a8760 20
  const Elf_Internal_Sym *s1;
  const Elf_Internal_Sym *s2;
  int shndx;

  /* Make sure that undefined symbols are at the end.  */
  s1 = (const Elf_Internal_Sym *) arg1;
  if (s1->st_shndx == SHN_UNDEF)
    return 1;
  s2 = (const Elf_Internal_Sym *) arg2;
  if (s2->st_shndx == SHN_UNDEF)
    return -1;

  /* Sorted by section index.  */
  shndx = s1->st_shndx - s2->st_shndx;
  if (shndx != 0)
    return shndx;

  /* Sorted by binding.  */
  return ELF_ST_BIND (s1->st_info)  - ELF_ST_BIND (s2->st_info);
}
d8764 5
a8768 1
  Elf_Internal_Sym *sym;
d8772 11
d8791 58
d8861 3
a8863 3
  Elf_Internal_Sym *isymstart1 = NULL, *isymstart2 = NULL, *isym;
  Elf_Internal_Sym *isymend;
  struct elf_symbol *symp, *symtable1 = NULL, *symtable2 = NULL;
d8911 4
a8914 2
  isymbuf1 = elf_tdata (bfd1)->symbuf;
  isymbuf2 = elf_tdata (bfd2)->symbuf;
d8916 1
a8916 1
  if (isymbuf1 == NULL)
d8922 1
a8922 4
      /* Sort symbols by binding and section. Global definitions are at
	 the beginning.  */
      qsort (isymbuf1, symcount1, sizeof (Elf_Internal_Sym),
	     elf_sort_elf_symbol);
d8924 2
a8925 1
	elf_tdata (bfd1)->symbuf = isymbuf1;
d8928 1
a8928 1
  if (isymbuf2 == NULL)
d8934 4
a8937 6
      /* Sort symbols by binding and section. Global definitions are at
	 the beginning.  */
      qsort (isymbuf2, symcount2, sizeof (Elf_Internal_Sym),
	     elf_sort_elf_symbol);
      if (!info->reduce_memory_overheads)
	elf_tdata (bfd2)->symbuf = isymbuf2;
d8940 1
a8940 4
  /* Count definitions in the section.  */
  count1 = 0;
  for (isym = isymbuf1, isymend = isym + symcount1;
       isym < isymend; isym++)
d8942 29
a8970 1
      if (isym->st_shndx == (unsigned int) shndx1)
d8972 11
a8982 3
	  if (count1 == 0)
	    isymstart1 = isym;
	  count1++;
d8985 17
a9001 3
      if (count1 && isym->st_shndx != (unsigned int) shndx1)
	break;
    }
d9003 3
a9005 5
  count2 = 0;
  for (isym = isymbuf2, isymend = isym + symcount2;
       isym < isymend; isym++)
    {
      if (isym->st_shndx == (unsigned int) shndx2)
d9007 4
a9010 3
	  if (count2 == 0)
	    isymstart2 = isym;
	  count2++;
d9013 15
a9027 2
      if (count2 && isym->st_shndx != (unsigned int) shndx2)
	break;
d9030 3
a9032 1
  if (count1 == 0 || count2 == 0 || count1 != count2)
d9035 10
a9044 2
  symtable1 = bfd_malloc (count1 * sizeof (struct elf_symbol));
  symtable2 = bfd_malloc (count1 * sizeof (struct elf_symbol));
d9046 1
a9046 1
  if (symtable1 == NULL || symtable2 == NULL)
d9049 10
a9058 22
  symp = symtable1;
  for (isym = isymstart1, isymend = isym + count1;
       isym < isymend; isym++)
    {
      symp->sym = isym;
      symp->name = bfd_elf_string_from_elf_section (bfd1,
						    hdr1->sh_link,
						    isym->st_name);
      symp++;
    }
 
  symp = symtable2;
  for (isym = isymstart2, isymend = isym + count1;
       isym < isymend; isym++)
    {
      symp->sym = isym;
      symp->name = bfd_elf_string_from_elf_section (bfd2,
						    hdr2->sh_link,
						    isym->st_name);
      symp++;
    }
  
d9067 2
a9068 2
    if (symtable1 [i].sym->st_info != symtable2 [i].sym->st_info
	|| symtable1 [i].sym->st_other != symtable2 [i].sym->st_other
d9079 4
a9082 7
  if (info->reduce_memory_overheads)
    {
      if (isymbuf1)
	free (isymbuf1);
      if (isymbuf2)
	free (isymbuf2);
    }
@


1.372
log
@	* elf-bfd.h (struct elf_backend_data): Add elf_backend_write_core_note.
	* elfxx-target.h (elf_backend_write_core_note): Define and use.
	* elf.c (elfcore_write_prpsinfo): Call the above.  Add support for
	32-bit core note on 64-bit target.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_lwpstatus): Make note_name const.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_pstatus): Add support for 32-bit core note on 64-bit
	target.
	* elf32-ppc.c (ppc_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
	* elf64-ppc.c (ppc64_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
@
text
@d1595 1
a1595 2
  table->dynamic_sections_created = FALSE;
  table->dynobj = NULL;
a1601 14
  table->dynstr = NULL;
  table->bucketcount = 0;
  table->needed = NULL;
  table->hgot = NULL;
  table->hplt = NULL;
  table->merge_info = NULL;
  memset (&table->stab_info, 0, sizeof (table->stab_info));
  memset (&table->eh_info, 0, sizeof (table->eh_info));
  table->dynlocal = NULL;
  table->runpath = NULL;
  table->tls_sec = NULL;
  table->tls_size = 0;
  table->loaded = NULL;
  table->is_relocatable_executable = FALSE;
@


1.371
log
@2007-01-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (copy_elf_program_header): Start from the first section
	in a segment and stop when all sections in a segment are
	accounted for.
@
text
@d8214 22
a8235 2
  int note_type;
  char *note_name = "CORE";
d8237 9
d8247 2
a8248 2
  psinfo_t  data;
  note_type = NT_PSINFO;
d8250 2
a8251 2
  prpsinfo_t data;
  note_type = NT_PRPSINFO;
d8254 6
a8259 5
  memset (&data, 0, sizeof (data));
  strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
  strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, note_type, &data, sizeof (data));
d8272 29
a8300 2
  prstatus_t prstat;
  char *note_name = "CORE";
d8302 7
a8308 6
  memset (&prstat, 0, sizeof (prstat));
  prstat.pr_pid = pid;
  prstat.pr_cursig = cursig;
  memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
  return elfcore_write_note (abfd, buf, bufsiz,
			     note_name, NT_PRSTATUS, &prstat, sizeof (prstat));
d8322 1
a8322 1
  char *note_name = "CORE";
d8352 3
a8354 2
  pstatus_t pstat;
  char *note_name = "CORE";
d8356 21
a8376 5
  memset (&pstat, 0, sizeof (pstat));
  pstat.pr_pid = pid & 0xffff;
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
			    NT_PSTATUS, &pstat, sizeof (pstat));
  return buf;
d8387 1
a8387 1
  char *note_name = "CORE";
@


1.370
log
@bfd/
	* elf.c (assign_file_positions_for_load_sections): We can
	require fewer phdrs than expected.
ld/
	* emultempl/elf-generic.em (gdl_map_segments): Only allow header
	shrinkage for the first few iterations.
ld/testsuite/
	* ld-elf/header.d: New.
	* ld-elf/header.t: New.
	* ld-elf/header.s: New.
@
text
@d5817 1
a5817 1
      bfd_vma first_lma = 0;
d5831 2
a5832 2
	      if (!section_count || section->lma < first_lma)
		first_lma = section->lma;
d5878 2
a5879 1
	map->p_vaddr_offset = first_lma - segment->p_paddr;
d5885 1
a5885 1
	  for (section = ibfd->sections;
d5891 5
a5895 1
		map->sections[isec++] = section->output_section;
@


1.369
log
@	bfd/
	* elf.c (assign_file_positions_for_load_sections): Adjust p_vaddr
	by p_vaddr_offset.  Copy alignment & use if it is valid.
	(rewrite_elf_program_headers): Cope with leading padding in a
	segment that does not contain file or program headers.
	(copy_elf_program_header): Likewise.

	include/elf/
	* internal.h (struct elf_segment_map): Add p_vaddr_offset field.
@
text
@d4278 1
a4278 1
		== alloc * bed->s->sizeof_phdr);
@


1.368
log
@2006-12-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3609
	* elf.c (rewrite_elf_program_header): Preserve segment physical
	address in the output segment if the first section in the
	corresponding input segment is null.
@
text
@d4329 1
a4329 1
	p->p_vaddr = m->sections[0]->vma;
d4356 2
d4368 3
a4370 1
	  for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
d4372 11
a4382 5
	      unsigned int secalign;

	      secalign = bfd_get_section_alignment (abfd, *secpp);
	      if (secalign > align_power)
		align_power = secalign;
a4383 4
	  align = (bfd_size_type) 1 << align_power;

	  if (align < maxpagesize)
	    align = maxpagesize;
d4614 1
d5591 8
a5598 1

d5817 1
d5830 5
a5834 1
	    section_count++;
d5856 1
d5876 4
@


1.367
log
@PR 3609
* elf.c (rewrite_elf_program_header): Do not use the first_section pointer if it is null.
@
text
@d5434 1
a5434 1
      if (first_section != NULL && first_section->output_section != NULL)
@


1.366
log
@2006-11-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (IS_SECTION_IN_INPUT_SEGMENT): New.
	(INCLUDE_SECTION_IN_SEGMENT): Use IS_SECTION_IN_INPUT_SEGMENT.
	(rewrite_elf_program_header): Don't preserve segment physical
	address in the output segment if the first section in the
	corresponding input segment is removed.
@
text
@d5430 1
d5434 1
a5434 1
      if (first_section->output_section != NULL)
@


1.365
log
@	* elf.c (elfcore_write_note): Pad note descriptor to 4-byte
	boundary.  Tidy.  Comment.
@
text
@d5260 1
a5260 1
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
a5265 1
   && section->output_section != NULL					\
d5281 6
d5394 1
d5399 1
d5404 11
a5414 2
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
	  ++section_count;
d5430 8
a5437 2
      map->p_paddr       = segment->p_paddr;
      map->p_paddr_valid = 1;
d5767 1
@


1.364
log
@bfd/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* elf-bfd.h (elf_obj_tdata): Add symbuf.
	(_bfd_elf_section_already_linked): Add struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elf.c (assign_section_numbers): Updated to add
	struct bfd_link_info *.
	(bfd_elf_match_symbols_in_sections): Updated. Cache symbol
	buffer if info->reduce_memory_overheads is false.

	* elflink.c (match_group_member): Updated to add
	struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(elf_link_input_bfd): Likewise.
	(_bfd_elf_section_already_linked): Likewise.
	(bfd_elf_final_link): Free symbol buffer if
	info->reduce_memory_overheads is false.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* libbfd.h: Regenerated.

	* linker.c (bfd_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* targets.c (bfd_target): Add struct bfd_link_info * to
	_section_already_linked.
	* bfd-in2.h: Regenerated.

include/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* bfdlink.h (bfd_link_info): Add reduce_memory_overheads.

ld/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* ld.h (args_type): Remove reduce_memory_overheads.

	* ldlang.c (lang_map): Updated.
	(section_already_linked): Likewise.
	(print_input_section): Likewise.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
@
text
@d8091 1
a8091 1
     buffer to hold note
d8097 5
d8103 1
a8103 1
   End of buffer containing note.  */
d8106 1
a8106 1
elfcore_write_note (bfd  *abfd,
d8108 1
a8108 1
		    int  *bufsiz,
d8110 1
a8110 1
		    int  type,
d8112 1
a8112 1
		    int  size)
a8115 1
  size_t pad;
d8117 1
a8117 1
  char *p, *dest;
a8119 1
  pad = 0;
d8121 1
a8121 7
    {
      const struct elf_backend_data *bed;

      namesz = strlen (name) + 1;
      bed = get_elf_backend_data (abfd);
      pad = -namesz & 3;
    }
d8123 1
a8123 1
  newspace = 12 + namesz + pad + size;
d8125 2
a8126 2
  p = realloc (buf, *bufsiz + newspace);
  dest = p + *bufsiz;
d8137 1
a8137 1
      while (pad != 0)
d8140 1
a8140 1
	  --pad;
d8144 7
a8150 1
  return p;
@


1.363
log
@	* elf.c (elfcore_write_note): Pad to 4-byte boundary.
@
text
@d3176 1
a3176 1
		      kept = _bfd_elf_check_kept_section (s);
d8677 2
a8678 1
bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2)
a8733 5
  isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
				   NULL, NULL, NULL);
  isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
				   NULL, NULL, NULL);

d8735 2
a8736 2
  if (isymbuf1 == NULL || isymbuf2 == NULL)
    goto done;
d8738 27
a8764 6
  /* Sort symbols by binding and section. Global definitions are at
     the beginning.  */
  qsort (isymbuf1, symcount1, sizeof (Elf_Internal_Sym),
	 elf_sort_elf_symbol);
  qsort (isymbuf2, symcount2, sizeof (Elf_Internal_Sym),
	 elf_sort_elf_symbol);
d8848 7
a8854 4
  if (isymbuf1)
    free (isymbuf1);
  if (isymbuf2)
    free (isymbuf2);
@


1.362
log
@2006-10-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_init_private_section_data): Assert output
	section ELF type instead of check if it is SHT_NULL.  Copy
	OS/PROC specific flags from input section to output section.
@
text
@d8123 1
a8123 1
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
@


1.361
log
@	* elf.c (bfd_section_from_shdr): Remove extraneous breaks.
	* targets.c (find_target): Remove extraneous break.
@
text
@d5953 11
a5963 3
  if (osec->flags == isec->flags
      || (osec->flags == 0 && elf_section_type (osec) == SHT_NULL))
    elf_section_type (osec) = elf_section_type (isec);
@


1.360
log
@	* elf.c (bfd_elf_set_dyn_lib_class): Change second argument type
	from int to enum dynamic_lib_link_class lib_class.
	* bfd-in.h (bfd_elf_set_dyn_lib_class): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a2128 1
      break;
a2133 1
      break;
@


1.359
log
@2006-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3314
	* elf.c (assign_file_positions_for_non_load_sections): Don't
	page align empty SHF_ALLOC sections.
@
text
@d1671 1
a1671 1
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
@


1.358
log
@bfd/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* elf.c (assign_file_positions_for_non_load_sections): Don't
	warn zero size allocated sections.

ld/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* ld.texinfo: Updated Output Section Discarding.

	* ldlang.h (lang_output_section_statement_type): Add
	section_relative_symbol.
	* ldlang.c (strip_excluded_output_sections): Don't strip a
	section with a symbol relative to it.
	(lang_size_sections_1): Mark if an output section has a symbol
	symbol relative to it.

ld/testsuite/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* ld-scripts/empty-address-1.d: New file.
	* ld-scripts/empty-address-1.s: Likewise.
	* ld-scripts/empty-address-1.t: Likewise.
	* ld-scripts/empty-address-2.s: Likewise.
	* ld-scripts/empty-address-2a.d: Likewise.
	* ld-scripts/empty-address-2a.t: Likewise.
	* ld-scripts/empty-address-2b.d: Likewise.
	* ld-scripts/empty-address-2b.t: Likewise.
	* ld-scripts/empty-address-3.s: Likewise.
	* ld-scripts/empty-address-3a.d: Likewise.
	* ld-scripts/empty-address-3a.t: Likewise.
	* ld-scripts/empty-address-3b.d: Likewise.
	* ld-scripts/empty-address-3b.t: Likewise.
	* ld-scripts/empty-address-3c.d: Likewise.
	* ld-scripts/empty-address-3c.t: Likewise.
	* ld-scripts/empty-address.exp: Likewise.
@
text
@d4668 6
a4673 5
		abfd,
		(hdr->bfd_section == NULL
		 ? "*unknown*" 
		 : hdr->bfd_section->name)));
	  if ((abfd->flags & D_PAGED) != 0)
@


1.357
log
@2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3262
	* elf.c (rewrite_elf_program_header): Use bfd_zalloc instead of
	bfd_alloc to allocate segment map.
	(copy_elf_program_header): Likewise.
@
text
@d4665 7
a4671 6
	  ((*_bfd_error_handler)
	   (_("%B: warning: allocated section `%s' not in segment"),
	    abfd,
	    (hdr->bfd_section == NULL
	     ? "*unknown*"
	     : hdr->bfd_section->name)));
@


1.356
log
@	* elfcode.h (elf_swap_symbol_in): Return bfd_boolean.  Don't abort
	on error.
	* elf-bfd.h (elf_size_info <swap_symbol_in>): Adjust decl.
	(bfd_elf32_swap_symbol_in, bfd_elf64_swap_symbol_in): Likewise.
	* elf.c (bfd_elf_get_elf_syms): Test return of swap_symbol_in,
	and report error.
	* elf32-arm.c (elf32_arm_swap_symbol_in): Return bfd_boolean.
@
text
@d5404 1
a5404 1
      map = bfd_alloc (obfd, amt);
d5799 1
a5799 1
      map = bfd_alloc (obfd, amt);
@


1.355
log
@	* elf.c (special_sections_s): Revert last STRING_COMMA_LEN change
	for .stabstr entry, explain why.
@
text
@d403 9
a411 1
    (*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym);
@


1.354
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2377 3
a2379 1
  { STRING_COMMA_LEN (".stabstr"),  3, SHT_STRTAB, 0 },
@


1.353
log
@	PR 3182
	* elf.c (_bfd_elf_copy_private_header_data): Fix group members
	that have had their SHT_GROUP section removed.
	* objcopy.c (group_signature): New function, split out from..
	(setup_section): ..here.
	(is_strip_section): Return true for SHT_GROUP sections that are
	going to lose their group signature symbol.
@
text
@d819 1
a819 1
	  { "debug",		 5  },	/* 'd' */
d822 1
a822 1
	  { "gnu.linkonce.wi.", 16 },	/* 'g' */
d827 1
a827 1
	  { "line",		 4  },	/* 'l' */
d834 1
a834 1
	  { "stab",		 4  }	/* 's' */
d855 1
a855 1
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0
d2284 2
a2285 2
  { ".bss",            4, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { NULL,              0,  0, 0,            0 }
d2290 2
a2291 2
  { ".comment",        8,  0, SHT_PROGBITS, 0 },
  { NULL,              0,  0, 0,            0 }
d2296 11
a2306 11
  { ".data",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".data1",          6,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".debug",          6,  0, SHT_PROGBITS, 0 },
  { ".debug_line",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_info",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_abbrev",  13,  0, SHT_PROGBITS, 0 },
  { ".debug_aranges", 14,  0, SHT_PROGBITS, 0 },
  { ".dynamic",        8,  0, SHT_DYNAMIC,  SHF_ALLOC },
  { ".dynstr",         7,  0, SHT_STRTAB,   SHF_ALLOC },
  { ".dynsym",         7,  0, SHT_DYNSYM,   SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
d2311 3
a2313 3
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { NULL,              0,  0, 0,            0 }
d2318 9
a2326 9
  { ".gnu.linkonce.b",15, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".got",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".gnu.version",   12,  0, SHT_GNU_versym, 0 },
  { ".gnu.version_d", 14,  0, SHT_GNU_verdef, 0 },
  { ".gnu.version_r", 14,  0, SHT_GNU_verneed, 0 },
  { ".gnu.liblist",   12,  0, SHT_GNU_LIBLIST, SHF_ALLOC },
  { ".gnu.conflict",  13,  0, SHT_RELA,     SHF_ALLOC },
  { ".gnu.hash",       9,  0, SHT_GNU_HASH, SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
d2331 2
a2332 2
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { NULL,              0,  0, 0,            0 }
d2337 4
a2340 4
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { NULL,              0,  0, 0,            0 }
d2345 2
a2346 2
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { NULL,              0,  0, 0,            0 }
d2351 3
a2353 3
  { ".note.GNU-stack",15,  0, SHT_PROGBITS, 0 },
  { ".note",           5, -1, SHT_NOTE,     0 },
  { NULL,              0,  0, 0,            0 }
d2358 3
a2360 3
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { NULL,              0,  0, 0,            0 }
d2365 5
a2369 5
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".rela",           5, -1, SHT_RELA,     0 },
  { ".rel",            4, -1, SHT_REL,      0 },
  { NULL,              0,  0, 0,            0 }
d2374 5
a2378 5
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
  { ".stabstr",        5,  3, SHT_STRTAB,   0 },
  { NULL,              0,  0, 0,            0 }
d2383 4
a2386 4
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { NULL,              0,  0, 0,            0 }
d3241 1
a3241 1
	  if (strncmp (sec->name, ".stab", sizeof ".stab" - 1) == 0
d3649 1
a3649 1
	  && strncmp (s->name, ".note", 5) == 0)
d4031 1
a4031 1
	      && strncmp (s->name, ".note", 5) == 0)
d8294 1
a8294 1
      if (strncmp (in.namedata, "NetBSD-CORE", 11) == 0)
d8299 1
a8299 1
      else if (strncmp (in.namedata, "QNX", 3) == 0)
d8678 2
a8679 4
  if (strncmp (sec1->name, ".gnu.linkonce",
	       sizeof ".gnu.linkonce" - 1) == 0
      && strncmp (sec2->name, ".gnu.linkonce",
		  sizeof ".gnu.linkonce" - 1) == 0)
@


1.352
log
@2006-09-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3186
	* elf.c (_bfd_elf_make_section_from_shdr): Correct length of
	"gnu.linkonce.wi.".
@
text
@d6015 2
d6032 21
@


1.351
log
@bfd/

2006-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3015
	* elf.c (get_program_header_size): Add a PT_GNU_RELRO segment
	only if there is a PT_DYNAMIC segment.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Set PT_GNU_RELRO
	segment alignment to 1.

ld/testsuite/

2006-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3015
	* ld-elf/binutils.exp: Add tests for "-z relro".
@
text
@d822 1
a822 1
	  { "gnu.linkonce.wi.", 17 },	/* 'g' */
@


1.350
log
@	* elf.c (elf_modify_segment_map): Delete empty PT_LOAD segments.
	* elf32-xtensa.c (elf_xtensa_modify_segment_map): Delete.
	(define elf_backend_modify_segment_map): Don't define.
@
text
@d3625 7
a3645 6
  if (elf_tdata (abfd)->relro)
    {
      /* We need a PT_GNU_RELRO segment.  */
      ++segs;
    }

d4114 1
a4114 1
      if (elf_tdata (abfd)->relro)
d4116 2
d4597 5
a4601 3
	      if (align > p->p_align
		  && (p->p_type != PT_LOAD
		      || (abfd->flags & D_PAGED) == 0))
@


1.349
log
@* emulparams/elf_x86_64.sh (LIBPATH_SUFFIX, ELF_INTERPRETER_NAME): Set for *-*-solaris2*.
* elf.c (bfd_section_from_shdr): Reject unrecognised OS-specific sections
  only if the SHF_OS_NONCONFORMING flag is present.
@
text
@d3739 1
a3739 1
  struct elf_segment_map *m;
d3745 4
a3748 4
     sections.  */
  for (m = elf_tdata (abfd)->segment_map;
       m != NULL;
       m = m->next)
d3752 1
a3752 2
      new_count = 0;
      for (i = 0; i < m->count; i ++)
d3754 3
a3756 3
	  if ((m->sections[i]->flags & SEC_EXCLUDE) == 0
	      && ((m->sections[i]->flags & SEC_ALLOC) != 0
		  || m->p_type != PT_LOAD))
d3758 2
a3759 4
	      if (i != new_count)
		m->sections[new_count] = m->sections[i];

	      new_count ++;
d3762 1
d3764 4
a3767 2
      if (new_count != m->count)
	m->count = new_count;
d3773 1
a3773 1
      if (! (*bed->elf_backend_modify_segment_map) (abfd, info))
d4382 2
a4383 1
	      while ((m->sections[i]->flags & SEC_LOAD) == 0)
d4552 1
a4552 1
		  sec->filepos = off;
d4644 3
a4646 1
	  && hdr->bfd_section->filepos != 0)
@


1.348
log
@include/
	* bfdlink.h (struct bfd_link_info): Add emit_hash and
	emit_gnu_hash bitfields.
include/elf/
	* common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.
ld/
	* scripttempl/elf.sc: Add .gnu.hash section.
	* emultempl/elf32.em (OPTION_HASH_STYLE): Define.
	(gld${EMULATION_NAME}_add_options): Register --hash-style option.
	(gld${EMULATION_NAME}_handle_option): Handle it.
	(gld${EMULATION_NAME}_list_options): Document it.
	* ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
	* ld.texinfo: Document --hash-style option.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
	(bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
	Handle SHT_GNU_HASH.
	(special_sections_g): Include .gnu.hash section.
	(bfd_elf_gnu_hash): New function.
	* elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
	(struct elf_backend_data): Add elf_hash_symbol method.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
	only if info->emit_hash, create .gnu.hash section if
	info->emit_gnu_hash.
	(struct collect_gnu_hash_codes): New type.
	(elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
	_bfd_elf_hash_symbol): New functions.
	(compute_bucket_count): Don't compute HASHCODES array, instead add
	that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
	instead of bed->s->arch_size / 8.  Fix .hash size estimation.
	When not optimizing, use the number of hashed symbols rather than
	dynsymcount.
	(bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
	and ADD DT_GNU_HASH if info->emit_gnu_hash.
	(bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
	adjust compute_bucket_count caller.  Create and populate .gnu.hash
	section if info->emit_gnu_hash.
	(elf_link_output_extsym): Only populate .hash section if
	finfo->hash_sec != NULL.
	(bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
	* elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
	(elfNN_bed): Add elf_backend_hash_symbol.
	* elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	* elf32-i386.c (elf_i386_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
binutils/
	* readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
	(get_section_type_name): Handle SHT_GNU_HASH.
	(dynamic_info_DT_GNU_HASH): New variable.
	(process_dynamic_section): Handle DT_GNU_HASH.
	(process_symbol_table): Print also DT_GNU_HASH histogram.
ld/testsuite/
	* ld-powerpc/tlsso32.r: Adjust.
	* ld-powerpc/tlsso32.d: Adjust.
	* ld-powerpc/tlsso32.g: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlsso.g: Adjust.
	* ld-powerpc/tlstocso.g: Adjust.
@
text
@d2204 14
a2217 5
	/* FIXME: We should handle this section.  */
	(*_bfd_error_handler)
	  (_("%B: don't know how to handle OS specific section "
	     "`%s' [0x%8x]"),
	   abfd, name, hdr->sh_type);
@


1.347
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d209 15
d1258 1
d1843 1
d2316 1
d2833 4
d3282 1
@


1.346
log
@	* elf-bfd.h (struct elf_backend_data): Add
	elf_backend_modify_program_headers.
	* elfxx-target.h (elf_backend_modify_program_headers): Define.
	(elfNN_bed): Init new field.
	* elf.c (elf_modify_segment_map): Remove comment.
	(assign_file_positions_for_load_sections): Only call
	elf_modify_segment_map for objcopy/strip.
	(assign_file_positions_except_relocs): Call
	elf_backend_modify_program_headers.
	* elf32-frv.c (elf32_frvfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_frvfdpic_modify_segment_map): Delete.
	(elf32_frvfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Don't make
	.stack section.
	(elf32_bfinfdpic_modify_segment_map): Delete.
	(elf32_bfinfdpic_modify_program_headers): New.
	(elf_backend_modify_segment_map): Don't define.
	(elf_backend_modify_program_headers): Define.
	* elfxx-ia64.c (elfNN_ia64_modify_program_headers): New function.
	Split out from..
	(elfNN_ia64_modify_segment_map): ..here.
	(elf_backend_modify_program_headers): Define.
@
text
@d212 8
a219 7
  /* This just does initialization.  */
  /* coff_mkobject zalloc's space for tdata.coff_obj_data ...  */
  elf_tdata (abfd) = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
  if (elf_tdata (abfd) == 0)
    return FALSE;
  /* Since everything is done at close time, do we need any
     initialization?  */
d3856 1
a3856 1
	  if (phdr_size == 0)
d4231 1
a4231 1
  if (elf_tdata (abfd)->program_header_size == 0)
d7067 1
a7067 2
      struct elf_segment_map *m;
      bfd_size_type phdr_size = 0;
d7069 7
a7075 2
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	phdr_size += bed->s->sizeof_phdr;
d7077 3
a7079 2
      if (phdr_size == 0)
	phdr_size = get_program_header_size (abfd, info);
@


1.345
log
@	* bfd.c (bfd_record_phdr): Clear p_align and p_align_valid fields.
	* elf.c (_bfd_elf_link_hash_table_init): Clear hplt field.
@
text
@a3736 2
  /* Yes, we call elf_backend_modify_segment_map at least two times
     for the linker.  The final time the link_orders are available.  */
d4218 2
a4219 1
  if (!elf_modify_segment_map (abfd, link_info))
d4722 2
a4723 2
		      && lp->p_vaddr + lp->p_filesz
			 >= link_info->relro_end)
d4825 6
@


1.344
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d1582 1
@


1.343
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d3563 83
d3700 1
a3700 1
/* Set up a mapping from BFD sections to program segments.  */
d3703 1
a3703 1
map_sections_to_segments (bfd *abfd)
a3704 6
  asection **sections = NULL;
  asection *s;
  unsigned int i;
  unsigned int count;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
d3706 1
a3706 11
  asection *last_hdr;
  bfd_vma last_size;
  unsigned int phdr_index;
  bfd_vma maxpagesize;
  asection **hdrpp;
  bfd_boolean phdr_in_segment = TRUE;
  bfd_boolean writable;
  int tls_count = 0;
  asection *first_tls = NULL;
  asection *dynsec, *eh_frame_hdr;
  bfd_size_type amt;
d3708 9
a3716 2
  if (elf_tdata (abfd)->segment_map != NULL)
    return TRUE;
d3718 9
a3726 2
  if (bfd_count_sections (abfd) == 0)
    return TRUE;
d3728 3
a3730 1
  /* Select the allocated sections, and sort them.  */
d3732 3
a3734 3
  sections = bfd_malloc2 (bfd_count_sections (abfd), sizeof (asection *));
  if (sections == NULL)
    goto error_return;
d3736 4
a3739 2
  i = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
d3741 2
a3742 5
      if ((s->flags & SEC_ALLOC) != 0)
	{
	  sections[i] = s;
	  ++i;
	}
a3743 2
  BFD_ASSERT (i <= bfd_count_sections (abfd));
  count = i;
d3745 2
a3746 1
  qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);
d3748 1
a3748 1
  /* Build the mapping.  */
d3750 7
a3756 2
  mfirst = NULL;
  pm = &mfirst;
d3758 2
a3759 5
  /* If we have a .interp section, then create a PT_PHDR segment for
     the program headers and a PT_INTERP segment for the .interp
     section.  */
  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
d3761 15
a3775 10
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_PHDR;
      /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
      m->p_flags = PF_R | PF_X;
      m->p_flags_valid = 1;
      m->includes_phdrs = 1;
d3777 1
a3777 2
      *pm = m;
      pm = &m->next;
d3779 2
a3780 3
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
a3781 29
      m->next = NULL;
      m->p_type = PT_INTERP;
      m->count = 1;
      m->sections[0] = s;

      *pm = m;
      pm = &m->next;
    }

  /* Look through the sections.  We put sections in the same program
     segment when the start of the second section can be placed within
     a few bytes of the end of the first section.  */
  last_hdr = NULL;
  last_size = 0;
  phdr_index = 0;
  maxpagesize = get_elf_backend_data (abfd)->maxpagesize;
  writable = FALSE;
  dynsec = bfd_get_section_by_name (abfd, ".dynamic");
  if (dynsec != NULL
      && (dynsec->flags & SEC_LOAD) == 0)
    dynsec = NULL;

  /* Deal with -Ttext or something similar such that the first section
     is not adjacent to the program headers.  This is an
     approximation, since at this point we don't know exactly how many
     program headers we will need.  */
  if (count > 0)
    {
      bfd_size_type phdr_size;
d3783 11
a3793 8
      phdr_size = elf_tdata (abfd)->program_header_size;
      if (phdr_size == 0)
	phdr_size = get_elf_backend_data (abfd)->s->sizeof_phdr;
      if ((abfd->flags & D_PAGED) == 0
	  || sections[0]->lma < phdr_size
	  || sections[0]->lma % maxpagesize < phdr_size % maxpagesize)
	phdr_in_segment = FALSE;
    }
d3795 1
a3795 4
  for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)
    {
      asection *hdr;
      bfd_boolean new_segment;
d3797 1
a3797 1
      hdr = *hdrpp;
d3799 2
a3800 2
      /* See if this section and the last one will fit in the same
         segment.  */
d3802 5
a3806 1
      if (last_hdr == NULL)
d3808 25
a3832 47
	  /* If we don't have a segment yet, then we don't need a new
	     one (we build the last one after this loop).  */
	  new_segment = FALSE;
	}
      else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)
	{
	  /* If this section has a different relation between the
             virtual address and the load address, then we need a new
             segment.  */
	  new_segment = TRUE;
	}
      else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
	       < BFD_ALIGN (hdr->lma, maxpagesize))
	{
	  /* If putting this section in this segment would force us to
             skip a page in the segment, then we need a new segment.  */
	  new_segment = TRUE;
	}
      else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
	       && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
	{
	  /* We don't want to put a loadable section after a
             nonloadable section in the same segment.
             Consider .tbss sections as loadable for this purpose.  */
	  new_segment = TRUE;
	}
      else if ((abfd->flags & D_PAGED) == 0)
	{
	  /* If the file is not demand paged, which means that we
             don't require the sections to be correctly aligned in the
             file, then there is no other reason for a new segment.  */
	  new_segment = FALSE;
	}
      else if (! writable
	       && (hdr->flags & SEC_READONLY) == 0
	       && (((last_hdr->lma + last_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
	{
	  /* We don't want to put a writable section in a read only
             segment, unless they are on the same page in memory
             anyhow.  We already know that the last section does not
             bring us past the current section on the page, so the
             only case in which the new section is not on the same
             page as the previous section is when the previous section
             ends precisely on a page boundary.  */
	  new_segment = TRUE;
d3834 28
a3861 4
      else
	{
	  /* Otherwise, we can use the same segment.  */
	  new_segment = FALSE;
d3864 1
a3864 1
      if (! new_segment)
d3866 88
d3956 3
d3965 2
a3966 1
	  continue;
d3969 6
a3974 2
      /* We need a new program segment.  We must create a new program
         header holding all the sections from phdr_index until hdr.  */
d3976 3
a3978 3
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
      if (m == NULL)
	goto error_return;
d3980 9
a3988 2
      *pm = m;
      pm = &m->next;
d3990 18
a4007 4
      if ((hdr->flags & SEC_READONLY) == 0)
	writable = TRUE;
      else
	writable = FALSE;
d4009 10
a4018 9
      last_hdr = hdr;
      /* .tbss sections effectively have zero size.  */
      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	last_size = hdr->size;
      else
	last_size = 0;
      phdr_index = i;
      phdr_in_segment = FALSE;
    }
d4020 4
a4023 6
  /* Create a final PT_LOAD program segment.  */
  if (last_hdr != NULL)
    {
      m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
      if (m == NULL)
	goto error_return;
d4025 17
a4041 3
      *pm = m;
      pm = &m->next;
    }
d4043 3
a4045 9
  /* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
  if (dynsec != NULL)
    {
      m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
      if (m == NULL)
	goto error_return;
      *pm = m;
      pm = &m->next;
    }
d4047 5
a4051 9
  /* For each loadable .note section, add a PT_NOTE segment.  We don't
     use bfd_get_section_by_name, because if we link together
     nonloadable .note sections and loadable .note sections, we will
     generate two .note sections in the output file.  FIXME: Using
     names for section types is bogus anyhow.  */
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
d4058 1
a4058 1
	  m->p_type = PT_NOTE;
d4060 1
a4060 1
	  m->sections[0] = s;
d4065 2
a4066 1
      if (s->flags & SEC_THREAD_LOCAL)
d4068 11
a4078 3
	  if (! tls_count)
	    first_tls = s;
	  tls_count++;
a4079 1
    }
d4081 10
a4090 4
  /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
  if (tls_count > 0)
    {
      int i;
d4092 3
a4094 36
      amt = sizeof (struct elf_segment_map);
      amt += (tls_count - 1) * sizeof (asection *);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_TLS;
      m->count = tls_count;
      /* Mandated PF_R.  */
      m->p_flags = PF_R;
      m->p_flags_valid = 1;
      for (i = 0; i < tls_count; ++i)
	{
	  BFD_ASSERT (first_tls->flags & SEC_THREAD_LOCAL);
	  m->sections[i] = first_tls;
	  first_tls = first_tls->next;
	}

      *pm = m;
      pm = &m->next;
    }

  /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME
     segment.  */
  eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
  if (eh_frame_hdr != NULL
      && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_EH_FRAME;
      m->count = 1;
      m->sections[0] = eh_frame_hdr->output_section;
d4096 2
a4097 2
      *pm = m;
      pm = &m->next;
d4100 2
a4101 10
  if (elf_tdata (abfd)->stack_flags)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_STACK;
      m->p_flags = elf_tdata (abfd)->stack_flags;
      m->p_flags_valid = 1;
d4103 3
a4105 3
      *pm = m;
      pm = &m->next;
    }
a4106 19
  if (elf_tdata (abfd)->relro)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_RELRO;
      m->p_flags = PF_R;
      m->p_flags_valid = 1;

      *pm = m;
      pm = &m->next;
    }

  free (sections);
  sections = NULL;

  elf_tdata (abfd)->segment_map = mfirst;
a4201 36
static void
print_segment_map (bfd *abfd)
{
  struct elf_segment_map *m;
  unsigned int i, j;

  fprintf (stderr, _(" Section to Segment mapping:\n"));
  fprintf (stderr, _("  Segment              Sections...\n"));

  for (i= 0, m = elf_tdata (abfd)->segment_map;
       m != NULL;
       i++, m = m->next)
    {
      const char *pt = get_segment_type (m->p_type);
      char buf[32];

      if (pt == NULL)
	{
	  if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	    sprintf (buf, "LOPROC+%7.7x",
		     (unsigned int) (m->p_type - PT_LOPROC));
	  else if (m->p_type >= PT_LOOS && m->p_type <= PT_HIOS)
	    sprintf (buf, "LOOS+%7.7x",
		     (unsigned int) (m->p_type - PT_LOOS));
	  else
	    snprintf (buf, sizeof (buf), "%8.8x",
		      (unsigned int) m->p_type);
	  pt = buf;
	}
      fprintf (stderr, "  %2.2d: %14.14s:  ", i, pt);
      for (j = 0; j < m->count; j++)
	fprintf (stderr, "%s ", m->sections [j]->name);
      putc ('\n',stderr);
    }
}

a4215 1
  unsigned int count;
d4219 2
a4220 41
  if (elf_tdata (abfd)->segment_map == NULL)
    {
      if (! map_sections_to_segments (abfd))
	return FALSE;
    }
  else
    {
      /* The placement algorithm assumes that non allocated sections are
	 not in PT_LOAD segments.  We ensure this here by removing such
	 sections from the segment map.  We also remove excluded
	 sections.  */
      for (m = elf_tdata (abfd)->segment_map;
	   m != NULL;
	   m = m->next)
	{
	  unsigned int new_count;

	  new_count = 0;
	  for (i = 0; i < m->count; i ++)
	    {
	      if ((m->sections[i]->flags & SEC_EXCLUDE) == 0
		  && ((m->sections[i]->flags & SEC_ALLOC) != 0
		      || m->p_type != PT_LOAD))
		{
		  if (i != new_count)
		    m->sections[new_count] = m->sections[i];

		  new_count ++;
		}
	    }

	  if (new_count != m->count)
	    m->count = new_count;
	}
    }

  if (bed->elf_backend_modify_segment_map)
    {
      if (! (*bed->elf_backend_modify_segment_map) (abfd, link_info))
	return FALSE;
    }
d4222 1
a4222 1
  count = 0;
d4224 1
a4224 1
    ++count;
d4228 7
a4234 1
  elf_elfheader (abfd)->e_phnum = count;
d4236 1
a4236 1
  if (count == 0)
a4241 20
  /* If we already counted the number of program segments, make sure
     that we allocated enough space.  This happens when SIZEOF_HEADERS
     is used in a linker script.  */
  alloc = elf_tdata (abfd)->program_header_size / bed->s->sizeof_phdr;
  if (alloc != 0 && count > alloc)
    {
      ((*_bfd_error_handler)
       (_("%B: Not enough room for program headers (allocated %u, need %u)"),
	abfd, alloc, count));
      print_segment_map (abfd);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (alloc == 0)
    {
      alloc = count;
      elf_tdata (abfd)->program_header_size = alloc * bed->s->sizeof_phdr;
    }

a4576 7
  /* Clear out any program headers we allocated but did not use.  */
  for (; count < alloc; count++, p++)
    {
      memset (p, 0, sizeof *p);
      p->p_type = PT_NULL;
    }

a4751 106
/* Get the size of the program header.

   If this is called by the linker before any of the section VMA's are set, it
   can't calculate the correct value for a strange memory layout.  This only
   happens when SIZEOF_HEADERS is used in a linker script.  In this case,
   SORTED_HDRS is NULL and we assume the normal scenario of one text and one
   data segment (exclusive of .interp and .dynamic).

   ??? User written scripts must either not use SIZEOF_HEADERS, or assume there
   will be two segments.  */

static bfd_size_type
get_program_header_size (bfd *abfd, struct bfd_link_info *info)
{
  size_t segs;
  asection *s;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* We can't return a different result each time we're called.  */
  if (elf_tdata (abfd)->program_header_size != 0)
    return elf_tdata (abfd)->program_header_size;

  if (elf_tdata (abfd)->segment_map != NULL)
    {
      struct elf_segment_map *m;

      segs = 0;
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
	++segs;
      elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
      return elf_tdata (abfd)->program_header_size;
    }

  /* Assume we will need exactly two PT_LOAD segments: one for text
     and one for data.  */
  segs = 2;

  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL && (s->flags & SEC_LOAD) != 0)
    {
      /* If we have a loadable interpreter section, we need a
	 PT_INTERP segment.  In this case, assume we also need a
	 PT_PHDR segment, although that may not be true for all
	 targets.  */
      segs += 2;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != NULL)
    {
      /* We need a PT_DYNAMIC segment.  */
      ++segs;
    }

  if (elf_tdata (abfd)->eh_frame_hdr)
    {
      /* We need a PT_GNU_EH_FRAME segment.  */
      ++segs;
    }

  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

  if (elf_tdata (abfd)->relro)
    {
      /* We need a PT_GNU_RELRO segment.  */
      ++segs;
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LOAD) != 0
	  && strncmp (s->name, ".note", 5) == 0)
	{
	  /* We need a PT_NOTE segment.  */
	  ++segs;
	}
    }

  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  /* We need a PT_TLS segment.  */
	  ++segs;
	  break;
	}
    }

  /* Let the backend count up any program headers it might need.  */
  if (bed->elf_backend_additional_program_headers)
    {
      int a;

      a = (*bed->elf_backend_additional_program_headers) (abfd, info);
      if (a == -1)
	abort ();
      segs += a;
    }

  elf_tdata (abfd)->program_header_size = segs * bed->s->sizeof_phdr;
  return elf_tdata (abfd)->program_header_size;
}

d7055 2
a7056 1
  int ret;
a7057 1
  ret = get_elf_backend_data (abfd)->s->sizeof_ehdr;
d7059 14
a7072 1
    ret += get_program_header_size (abfd, info);
@


1.342
log
@	* elf.c (_bfd_elf_init_private_section_data): Comment typo.
	(elfcore_grok_nto_status): Use long instead of pid_t.
	(elfcore_grok_nto_regs, elfcore_grok_nto_note): Likewise.
@
text
@d4724 1
a4724 1
get_program_header_size (bfd *abfd)
d4808 1
a4808 1
      a = (*bed->elf_backend_additional_program_headers) (abfd);
d7119 1
a7119 1
_bfd_elf_sizeof_headers (bfd *abfd, bfd_boolean reloc)
d7124 2
a7125 2
  if (! reloc)
    ret += get_program_header_size (abfd);
@


1.341
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d5959 1
a5959 1
     output BFD section flags has been set to something different.
a5969 1

d7937 1
a7937 1
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, pid_t *tid)
d7969 1
a7969 1
  sprintf (buf, ".qnx_core_status/%ld", (long) *tid);
d7990 1
a7990 1
		       pid_t tid,
d7998 1
a7998 1
  sprintf (buf, "%s/%ld", base, (long) tid);
d8031 1
a8031 1
  static pid_t tid = 1;
@


1.340
log
@bfd/
	* elf.c (assign_file_positions_for_load_sections): Retrieve
	maxpagesize from m->p_align if it is valid.  Set p_vaddr,
	p_paddr and p_align earlier.  Revert 2006-05-19 change to p_align.
	(copy_elf_program_header): Copy p_align.  Set p_align_valid.
include/elf/
	* internal.h (elf_segment_map): Add p_align and p_align_valid.
@
text
@d7316 1
a7316 1
  sect2 = bfd_make_section (abfd, name);
a7321 1
  sect2->flags = sect->flags;
d7353 2
a7354 1
  sect = bfd_make_section_anyway (abfd, threaded_name);
a7358 1
  sect->flags = SEC_HAS_CONTENTS;
d7637 1
a7637 1
  sect = bfd_make_section_anyway (abfd, name);
a7651 1
  sect->flags = SEC_HAS_CONTENTS;
d7666 1
a7666 1
  sect = bfd_make_section_anyway (abfd, name);
a7680 1
  sect->flags = SEC_HAS_CONTENTS;
d7721 1
a7721 1
      sect = bfd_make_section_anyway (abfd, name);
a7728 1
      sect->flags = SEC_HAS_CONTENTS;
d7748 1
a7748 1
      sect = bfd_make_section_anyway (abfd, name);
a7754 1
      sect->flags = SEC_HAS_CONTENTS;
d7824 2
a7825 1
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");
a7830 1
	sect->flags = SEC_HAS_CONTENTS;
d7977 1
a7977 1
  sect = bfd_make_section_anyway (abfd, name);
a7982 1
  sect->flags           = SEC_HAS_CONTENTS;
d8006 1
a8006 1
  sect = bfd_make_section_anyway (abfd, name);
a8011 1
  sect->flags           = SEC_HAS_CONTENTS;
@


1.339
log
@	* elf.c (sym_is_global): Return a bfd_boolean.
	(ignore_section_sym): New function.
	(elf_map_symbols): Use ignore_section_sym to discard some syms.
	(_bfd_elf_symbol_from_bfd_symbol): Ensure section belongs to
	bfd before using elf_section_syms.
@
text
@d4114 1
d4200 4
d4235 33
d4285 2
a4286 2
	  if ((abfd->flags & D_PAGED) != 0 && bed->maxpagesize > align)
	    align = bed->maxpagesize;
a4326 20
      if (m->count == 0)
	p->p_vaddr = 0;
      else
	p->p_vaddr = m->sections[0]->vma;

      if (m->p_paddr_valid)
	p->p_paddr = m->p_paddr;
      else if (m->count == 0)
	p->p_paddr = 0;
      else
	p->p_paddr = m->sections[0]->lma;

      if (p->p_type == PT_LOAD
	  && (abfd->flags & D_PAGED) != 0)
	p->p_align = bed->maxpagesize;
      else if (m->count == 0)
	p->p_align = 1 << bed->s->log_file_align;
      else
	p->p_align = 0;

d4407 1
a4407 1
	  align = 1 << bfd_get_section_alignment (abfd, sec);
d4437 2
a4438 2
		  if ((abfd->flags & D_PAGED) != 0 && bed->maxpagesize > page)
		    page = bed->maxpagesize;
d4515 1
a4515 2
		      || (abfd->flags & D_PAGED) == 0
		      || ((p->p_vaddr - p->p_offset) & (align - 1)) == 0))
d5820 2
@


1.338
log
@	* elf.c (elf_fake_sections): Formatting.
	(assign_file_positions_for_load_sections): Only add SEC_ALLOC
	sections to p_memsz.  Remove hack for PT_NOTE sections.  Allow
	section alignment to increase p_align for PT_LOAD.
	(assign_file_positions_for_non_load_sections): Remove ARM BPABI
	hack for PT_DYNAMIC.  Instead, set p_filesz for all segments
	other than PT_LOAD, and PT_NOTE in core.
@
text
@d3283 1
a3283 1
static int
d3296 14
d3350 1
a3350 1
	  && sym->value == 0)
d3352 1
a3352 3
	  asection *sec;

	  sec = sym->section;
d3354 2
a3355 8
	  if (sec->owner != NULL)
	    {
	      if (sec->owner != abfd)
		{
		  if (sec->output_offset != 0)
		    continue;

		  sec = sec->output_section;
d3357 1
a3357 17
		  /* Empty sections in the input files may have had a
		     section symbol created for them.  (See the comment
		     near the end of _bfd_generic_link_output_symbols in
		     linker.c).  If the linker script discards such
		     sections then we will reach this point.  Since we know
		     that we cannot avoid this case, we detect it and skip
		     the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the
		     linker testsuite test ld-scripts/weak.exp for an ELF
		     port that uses the generic linker.  */
		  if (sec->owner == NULL)
		    continue;

		  BFD_ASSERT (sec->owner == abfd);
		}
	      sect_syms[sec->index] = syms[idx];
	    }
d3364 2
d3372 1
a3372 1
  /* We will be adding a section symbol for each BFD section.  Most normal
d3398 2
d5127 1
d5130 5
a5134 5
      if (asym_ptr->section->output_section != NULL)
	indx = asym_ptr->section->output_section->index;
      else
	indx = asym_ptr->section->index;
      if (indx < elf_num_section_syms (abfd)
@


1.337
log
@	* elf.c (assign_file_positions_for_segments): Split into..
	(assign_file_positions_for_load_sections): ..this, and..
	(assign_file_positions_for_non_load_sections): ..this new function,..
	(assign_file_positions_except_relocs): ..writing program headers here.
@
text
@d2739 2
a2740 2
	  && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      || (asect->flags & SEC_NEVER_LOAD) != 0))
d4382 5
d4418 3
a4420 2
	      else if ((flags & SEC_THREAD_LOCAL) == 0
		       || p->p_type == PT_TLS)
a4483 5
	      /* PR ld/594:  Sections in note segments which are not loaded
		 contribute to the file size but not the in-memory size.  */
	      else if (p->p_type == PT_NOTE
		  && (flags & SEC_HAS_CONTENTS) != 0)
		p->p_filesz += sec->size;
d4487 3
a4489 2
	      else if ((flags & SEC_THREAD_LOCAL) == 0
		       || p->p_type == PT_TLS)
d4502 3
a4504 1
		  && (p->p_type != PT_LOAD || (abfd->flags & D_PAGED) == 0))
d4631 1
a4631 1
      if (p->p_type != PT_LOAD && m->count > 0)
d4633 13
a4645 15
	  BFD_ASSERT (! m->includes_filehdr && ! m->includes_phdrs);
	  /* If the section has not yet been assigned a file position,
	     do so now.  The ARM BPABI requires that .dynamic section
	     not be marked SEC_ALLOC because it is not part of any
	     PT_LOAD segment, so it will not be processed above.  */
	  if (p->p_type == PT_DYNAMIC && m->sections[0]->filepos == 0)
	    {
	      Elf_Internal_Shdr ** const i_shdrpp = elf_elfsections (abfd);

	      i = 1;
	      while (i_shdrpp[i]->bfd_section != m->sections[0])
		++i;
	      off = (_bfd_elf_assign_file_position_for_section 
		     (i_shdrpp[i], off, TRUE));
	      p->p_filesz = m->sections[0]->size;
a4646 1
	  p->p_offset = m->sections[0]->filepos;
d4648 1
a4648 1
      if (m->count == 0)
@


1.336
log
@	* elf.c (_bfd_elf_init_private_section_data): Don't change
	section type if already set.
@
text
@d4109 1
a4109 1
   the file header, and writes out the program headers.  */
d4112 2
a4113 1
assign_file_positions_for_segments (bfd *abfd, struct bfd_link_info *link_info)
a4115 1
  unsigned int count;
a4116 1
  unsigned int alloc;
d4118 1
d4120 2
a4121 5
  bfd_vma filehdr_vaddr, filehdr_paddr;
  bfd_vma phdrs_vaddr, phdrs_paddr;
  Elf_Internal_Phdr *p;
  Elf_Internal_Shdr **i_shdrpp;
  Elf_Internal_Shdr **hdrpp;
a4122 1
  unsigned int num_sec;
d4195 4
a4198 1
    alloc = count;
d4201 1
a4207 5
  filehdr_vaddr = 0;
  filehdr_paddr = 0;
  phdrs_vaddr = 0;
  phdrs_paddr = 0;

a4342 5
	  if (p->p_type == PT_LOAD)
	    {
	      filehdr_vaddr = p->p_vaddr;
	      filehdr_paddr = p->p_paddr;
	    }
d4350 1
a4350 9
	  if (m->includes_filehdr)
	    {
	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr + bed->s->sizeof_ehdr;
		  phdrs_paddr = p->p_paddr + bed->s->sizeof_ehdr;
		}
	    }
	  else
a4360 8

	      if (p->p_type == PT_LOAD)
		{
		  phdrs_vaddr = p->p_vaddr;
		  phdrs_paddr = p->p_paddr;
		}
	      else
		phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;
d4515 30
a4544 1
  /* Assign file positions for the other sections.  */
d4547 1
d4592 31
a4694 9
  /* Clear out any program headers we allocated but did not use.  */
  for (; count < alloc; count++, p++)
    {
      memset (p, 0, sizeof *p);
      p->p_type = PT_NULL;
    }

  elf_tdata (abfd)->phdr = phdrs;

a4696 5
  /* Write out the program headers.  */
  if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, SEEK_SET) != 0
      || bed->s->write_out_phdrs (abfd, phdrs, alloc) != 0)
    return FALSE;

d4868 2
d4872 11
a4882 1
      if (! assign_file_positions_for_segments (abfd, link_info))
@


1.335
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d5914 2
a5915 1
  if (osec->flags == isec->flags || !osec->flags)
@


1.334
log
@	* archive.c (bfd_generic_archive_p): Remove unused local variable
	`fail'.
	* dwarf2.c (decode_line_info): Remove unused local variable
	`basic_block'.
	* elfcode.h (elf_slurp_reloc_table_from_section): Remove unsed
	local varibale `s'.
	* tekhex.c (tekhex_write_object_contents): Remove unused local
	variable `bytes_written'.
	* aout-ns32k.c (MY_swap_std_reloc_out): Remove unused local
	variable `r_addend'.
	* elf32-dlx.c (dlx_rtype_to_howto): Remove breaks after returns.
	* elfxx-mips.c (_bfd_elf_mips_mach): Remove breaks after returns.
	(_bfd_ns32k_relocate_contents): Remove break after return.
	* elf.c (bfd_section_from_shdr): Remove breaks after returns.
@
text
@d2505 1
a2505 1
  return TRUE;
d8763 1
a8763 2
		      SEC_IS_COMMON, NULL, NULL, "LARGE_COMMON",
		      0);
@


1.333
log
@2006-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2593
	* elf.c (_bfd_elf_new_section_hook): Don't set section ELF type
	and flags if its BFD flags have been set.
	(_bfd_elf_init_private_section_data): Don't copy the output ELF
	section type from input if it has been set to something
	different.
@
text
@a2115 1
      break;
a2120 1
      break;
@


1.332
log
@2006-04-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2467
	* elf.c (_bfd_elf_close_and_cleanup): Check elf_tdata (abfd)
	is NULL first.

	* elf32-arm.c (elf32_arm_close_and_cleanup): Check if
	abfd->sections is NULL.
	(elf32_arm_bfd_free_cached_info): New.
	(bfd_elf32_bfd_free_cached_info): Defined.

	* elfxx-target.h (bfd_elfNN_bfd_free_cached_info): Default it
	to _bfd_free_cached_info.

	* libbfd-in.h (_bfd_free_cached_info): New.
	* libbfd: Regenerated.

	* opncls.c (_bfd_delete_bfd): Check if abfd->memory is NULL.
	(_bfd_free_cached_info): New.
@
text
@d2490 7
a2496 4
  /* When we read a file, we don't need section type and flags unless
     it is a linker created section.  They will be overridden in
     _bfd_elf_make_section_from_shdr anyway.  */
  if (abfd->direction != read_direction
d5912 5
a5916 3
  /* FIXME: What if the output ELF section type has been set to
     something different?  */
  if (elf_section_type (osec) == SHT_NULL)
@


1.331
log
@	* elf.c (assign_file_positions_except_relocs): Move code setting
	file position of non-loaded sections..
	(assign_file_positions_for_segments): ..to here.
@
text
@d7210 1
a7210 1
      if (elf_shstrtab (abfd) != NULL)
@


1.330
log
@2006-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2537
	* elf.c (bfd_section_from_shdr): Allow sections reserved for
	applications. Issue an error on sections we don't know how
	to handle.
@
text
@d4122 4
a4142 1
	  unsigned int i;
a4215 1
      unsigned int i;
d4540 45
a4599 1
	      unsigned int i;
d4802 2
a4803 4
  struct elf_obj_tdata * const tdata = elf_tdata (abfd);
  Elf_Internal_Ehdr * const i_ehdrp = elf_elfheader (abfd);
  Elf_Internal_Shdr ** const i_shdrpp = elf_elfsections (abfd);
  unsigned int num_sec = elf_numsections (abfd);
d4810 2
a4845 3
      unsigned int i;
      Elf_Internal_Shdr **hdrpp;

d4851 1
a4851 43
      /* Assign file positions for the other sections.  */

      off = elf_tdata (abfd)->next_file_pos;
      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
	{
	  Elf_Internal_Shdr *hdr;

	  hdr = *hdrpp;
	  if (hdr->bfd_section != NULL
	      && hdr->bfd_section->filepos != 0)
	    hdr->sh_offset = hdr->bfd_section->filepos;
	  else if ((hdr->sh_flags & SHF_ALLOC) != 0)
	    {
	      ((*_bfd_error_handler)
	       (_("%B: warning: allocated section `%s' not in segment"),
		abfd,
		(hdr->bfd_section == NULL
		 ? "*unknown*"
		 : hdr->bfd_section->name)));
	      if ((abfd->flags & D_PAGED) != 0)
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      bed->maxpagesize);
	      else
		off += vma_page_aligned_bias (hdr->sh_addr, off,
					      hdr->sh_addralign);
	      off = _bfd_elf_assign_file_position_for_section (hdr, off,
							       FALSE);
	    }
	  else if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
		    && hdr->bfd_section == NULL)
		   || hdr == i_shdrpp[tdata->symtab_section]
		   || hdr == i_shdrpp[tdata->symtab_shndx_section]
		   || hdr == i_shdrpp[tdata->strtab_section])
	    hdr->sh_offset = -1;
	  else
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);

	  if (i == SHN_LORESERVE - 1)
	    {
	      i += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	      hdrpp += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	    }
	}
d4859 1
a4859 1
  elf_tdata (abfd)->next_file_pos = off;
@


1.329
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2162 37
a2198 2
      return bed->elf_backend_section_from_shdr (abfd, hdr, name,
						 shindex);
@


1.329.2.1
log
@	* elf.c (sym_is_global): Return a bfd_boolean.
	(ignore_section_sym): New function.
	(elf_map_symbols): Use ignore_section_sym to discard some syms.
	(_bfd_elf_symbol_from_bfd_symbol): Ensure section belongs to
	bfd before using elf_section_syms.
@
text
@d3247 1
a3247 1
static bfd_boolean
a3259 14
/* Don't output section symbols for sections that are not going to be
   output.  Also, don't output section symbols for reloc and other
   special sections.  */

static bfd_boolean
ignore_section_sym (bfd *abfd, asymbol *sym)
{
  return ((sym->flags & BSF_SECTION_SYM) != 0
	  && (sym->value != 0
	      || (sym->section->owner != abfd
		  && (sym->section->output_section->owner != abfd
		      || sym->section->output_offset != 0))));
}

d3300 1
a3300 1
	  && !ignore_section_sym (abfd, sym))
d3302 3
a3304 1
	  asection *sec = sym->section;
d3306 8
a3313 2
	  if (sec->owner != abfd)
	    sec = sec->output_section;
d3315 17
a3331 1
	  sect_syms[sec->index] = syms[idx];
a3337 2
      if (ignore_section_sym (abfd, syms[idx]))
	continue;
d3344 1
a3344 1
  /* We will be adding a section symbol for each normal BFD section.  Most
a3369 2
      if (ignore_section_sym (abfd, sym))
	continue;
a5061 1
      asection *sec;
d5064 5
a5068 5
      sec = asym_ptr->section;
      if (sec->owner != abfd && sec->output_section != NULL)
	sec = sec->output_section;
      if (sec->owner == abfd
	  && (indx = sec->index) < elf_num_section_syms (abfd)
@


1.329.2.2
log
@        Backport from mainline:

        2006-07-29  Richard Sandiford  <richard@@codesourcery.com>

        ld/
        * Makefile.am (eelf32b4300.c): Update dependencies.
        (eelf32bmip.c): Likewise.
        (eelf32bsmip.c): Likewise.
        (eelf32btsmip.c): Likewise.
        (eelf32btsmipn32.c): Likewise.
        (eelf32ltsmip.c): Likewise.
        (eelf32ltsmipn32.c): Likewise.
        (eelf32ebmip.c): Likewise.
        (eelf32ebmipvxworks.c): Likewise.
        (eelf32elmip.c): Likewise.
        (eelf32elmipvxworks.c): Likewise.
        (eelf32bmipn32.c): Likewise.
        (eelf32lmip.c): Likewise.
        (eelf32mipswindiss.c): Likewise.
        (eelf32lsmip.c): Likewise.
        (eelf64bmip.c): Likewise.
        (eelf64btsmip.c): Likewise.
        (eelf64ltsmip.c): Likewise.
        (emipsbig.c): Likewise.  Canonicalize ${GENSCRIPTS} line.
        (emipsbsd.c): Likewise.
        (emipsidt.c): Update dependencies.
        (emipsidtl.c): Likewise.
        (emipslit.c): Likewise.
        (emipslnews.c): Likewise.
        (emipspe.c): Likewise.  Fix ${GENSCRIPTS} invocation.
        * Makefile.in: Regenerate.
        * emulparams/elf32bmip.sh (EXTRA_EM_FILE): Define.
        * emulparams/elf32bmipn32-defs.sh (EXTRA_EM_FILE): Likewise.
        * emultempl/irix.em: Include emultempl/mipself.em.
        * emultempl/mipself.em: New file.

        ld/testsuite/
        * ld-mips-elf/hash1.s, ld-mips-elf/hash1a.d,
        * ld-mips-elf/hash1b.d, ld-mips-elf/hash1c.d: New tests.
        * ld-mips-elf/mips-elf.exp: Run them.

        2006-07-14  Jakub Jelinek  <jakub@@redhat.com>

        * elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.

        2006-07-10  Jakub Jelinek  <jakub@@redhat.com>

        include/
        * bfdlink.h (struct bfd_link_info): Add emit_hash and
        emit_gnu_hash bitfields.

        include/elf/
        * common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.

        ld/
        * scripttempl/elf.sc: Add .gnu.hash section.
        * emultempl/elf32.em (OPTION_HASH_STYLE): Define.
        (gld${EMULATION_NAME}_add_options): Register --hash-style option.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        (gld${EMULATION_NAME}_list_options): Document it.
        * ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
        * ld.texinfo: Document --hash-style option.

        ld/testsuite/
        * ld-powerpc/tlsso32.r: Adjust.
        * ld-powerpc/tlsso32.d: Adjust.
        * ld-powerpc/tlsso32.g: Adjust.
        * ld-powerpc/tlsso.r: Adjust.
        * ld-powerpc/tlsso.g: Adjust.
        * ld-powerpc/tlstocso.g: Adjust.

        bfd/
        * elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
        (bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
        Handle SHT_GNU_HASH.
        (special_sections_g): Include .gnu.hash section.
        (bfd_elf_gnu_hash): New function.
        * elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
        (struct elf_backend_data): Add elf_hash_symbol method.
        * elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
        only if info->emit_hash, create .gnu.hash section if
        info->emit_gnu_hash.
        (struct collect_gnu_hash_codes): New type.
        (elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
        _bfd_elf_hash_symbol): New functions.
        (compute_bucket_count): Don't compute HASHCODES array, instead add
        that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
        instead of bed->s->arch_size / 8.  Fix .hash size estimation.
        When not optimizing, use the number of hashed symbols rather than
        dynsymcount.
        (bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
        and ADD DT_GNU_HASH if info->emit_gnu_hash.
        (bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
        adjust compute_bucket_count caller.  Create and populate .gnu.hash
        section if info->emit_gnu_hash.
        (elf_link_output_extsym): Only populate .hash section if
        finfo->hash_sec != NULL.
        (bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
        * elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
        (elfNN_bed): Add elf_backend_hash_symbol.
        * elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.
        * elf32-i386.c (elf_i386_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.

        binutils/
        * readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
        (get_section_type_name): Handle SHT_GNU_HASH.
        (dynamic_info_DT_GNU_HASH): New variable.
        (process_dynamic_section): Handle DT_GNU_HASH.
        (process_symbol_table): Print also DT_GNU_HASH histogram.
@
text
@a208 15
/* DT_GNU_HASH hash function.  Do not change this function; you will
   cause invalid hash tables to be generated.  */

unsigned long
bfd_elf_gnu_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 5381;
  unsigned char ch;

  while ((ch = *name++) != '\0')
    h = (h << 5) + h + ch;
  return h & 0xffffffff;
}

a1241 1
	    case DT_GNU_HASH: name = "GNU_HASH"; break;
a1824 1
    case SHT_GNU_HASH:		/* .gnu.hash section.  */
a2263 1
  { ".gnu.hash",       9,  0, SHT_GNU_HASH, SHF_ALLOC },
a2776 4

    case SHT_GNU_HASH:
      this_hdr->sh_entsize = bed->s->arch_size == 64 ? 0 : 4;
      break;
a3221 1
	case SHT_GNU_HASH:
@


1.328
log
@2006-02-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2322
	* elf.c (get_segment_type): New function.
	(_bfd_elf_print_private_bfd_data): Use it.
	(print_segment_map): New function.
	(assign_file_positions_for_segments): Call print_segment_map
	when there are not enough room for program headers.
@
text
@d1564 2
a1565 1
				      const char *))
d1592 1
a1592 1
  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d1610 2
a1611 1
  if (! _bfd_elf_link_hash_table_init (ret, abfd, _bfd_elf_link_hash_newfunc))
@


1.327
log
@2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (copy_private_bfd_data): Minor update.
@
text
@d1071 22
d1112 1
a1112 1
	  const char *pt;
d1115 1
a1115 1
	  switch (p->p_type)
d1117 2
a1118 12
	    case PT_NULL: pt = "NULL"; break;
	    case PT_LOAD: pt = "LOAD"; break;
	    case PT_DYNAMIC: pt = "DYNAMIC"; break;
	    case PT_INTERP: pt = "INTERP"; break;
	    case PT_NOTE: pt = "NOTE"; break;
	    case PT_SHLIB: pt = "SHLIB"; break;
	    case PT_PHDR: pt = "PHDR"; break;
	    case PT_TLS: pt = "TLS"; break;
	    case PT_GNU_EH_FRAME: pt = "EH_FRAME"; break;
	    case PT_GNU_STACK: pt = "STACK"; break;
	    case PT_GNU_RELRO: pt = "RELRO"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); pt = buf; break;
d4033 36
d4152 1
@


1.326
log
@bfd/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* elf.c (copy_private_bfd_data): Renamed to ...
	(rewrite_elf_program_header): This.
	(copy_elf_program_header): New function.
	(copy_private_bfd_data): Likewise.

binutils/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* readelf.c (process_program_headers): Use
	ELF_IS_SECTION_IN_SEGMENT_MEMORY.

include/elf/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* internal.h (ELF_IS_SECTION_IN_SEGMENT_FILE): New.
	(ELF_IS_SECTION_IN_SEGMENT_MEMORY): Likewise.
@
text
@a5733 2
  Elf_Internal_Phdr *segment;

d5745 1
@


1.325
log
@Update copyright date
@
text
@d5048 1
a5048 1
/* Copy private BFD data.  This copies any program header information.  */
d5051 1
a5051 1
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
a5066 7
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  if (elf_tdata (ibfd)->phdr == NULL)
    return TRUE;

d5626 180
@


1.324
log
@PR binutils/2159
* elf.c (elfcore_write_pstatus): Add ATTRIBUTE_UNUSED to unused	parameters.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.323
log
@	* elf.c (elf_find_function): Don't ignore section syms.
	Simplify filename logic.
@
text
@d7892 2
a7893 2
		       int cursig,
		       const void *gregs)
@


1.322
log
@	* elf.c (bfd_section_from_shdr): Treat invalid reloc sections as
	normal sections rather than returning false.
@
text
@a6688 2
	case STT_SECTION:
	  continue;
d6697 4
a6700 6
	      if (file == NULL)
		filename = NULL;
	      else if (ELF_ST_BIND (q->internal_elf_sym.st_info) != STB_LOCAL
		       && state == file_after_symbol_seen)
		filename = NULL;
	      else
@


1.321
log
@2005-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2008
	* elf.c (_bfd_elf_setup_sections): Return FALSE if
	elf_linked_to_section will be set to NULL.

	* format.c (bfd_check_format_matches): Don't check the default
	target twice.
@
text
@d2048 7
a2054 2
	   section.  */
	if (hdr->sh_link != elf_onesymtab (abfd) || hdr->sh_info == SHN_UNDEF)
a2057 4
	/* Prevent endless recursion on broken objects.  */
	if (elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_REL
	    || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)
	  return FALSE;
@


1.320
log
@2005-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (assign_section_numbers): Remove extra code in the last
	change.
@
text
@d657 2
d660 14
a673 1
	      elf_linked_to_section (s) = this_hdr->bfd_section;
@


1.319
log
@2005-12-07  H.J. Lu  <hongjiu.lu@@intel.com>
	    Andreas Schwab  <schwab@@suse.de>

	PR binutils/1991
	* elf.c (assign_section_numbers): Always use the output section
	when setting up sh_link for SHF_LINK_ORDER.
@
text
@d3077 1
a3077 4
		}
	      if (link_info != NULL)
		{
		  /* Handle linker.  */
@


1.318
log
@	* elf.c (elf_fake_sections): When calculating tbss size, just use
	the last link_order.
	(assign_file_positions_for_segments): Likewise.
	* elflink.c (bfd_elf_final_link): Likewise.
	(elf_reloc_link_order): Correct comment.
@
text
@d3056 1
d3059 1
a3059 2
		  /* For linker, elf_linked_to_section points to the
		     input section.  */
d3077 4
d3084 13
@


1.317
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2767 2
a2768 1
      if (asect->size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
d2770 1
a2770 1
	  struct bfd_link_order *o;
d2773 2
a2774 2
	  for (o = asect->map_head.link_order; o != NULL; o = o->next)
	    if (this_hdr->sh_size < o->offset + o->size)
d2776 3
a2778 2
	  if (this_hdr->sh_size)
	    this_hdr->sh_type = SHT_NOBITS;
d4401 3
a4403 8
		  struct bfd_link_order *o;
		  bfd_vma tbss_size = 0;

		  for (o = sec->map_head.link_order; o != NULL; o = o->next)
		    if (tbss_size < o->offset + o->size)
		      tbss_size = o->offset + o->size;

		  p->p_memsz += tbss_size;
@


1.316
log
@bfd/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* elf-bfd.h (_bfd_generic_init_private_section_data): New.
	(_bfd_elf_init_private_section_data): New.

	* elf.c (elf_fake_sections): Don't set SHF_GROUP for
	relocatable link.
	(bfd_elf_set_group_contents): Don't handle relocatable link
	specially.
	(assign_section_numbers): If it isn't called by assembler,
	use the output section of elf_linked_to_section for
	SHF_LINK_ORDER.
	(_bfd_elf_init_private_section_data): New.
	(_bfd_elf_copy_private_section_data): Call it.

	* libbfd-in.h (_bfd_generic_init_private_section_data): New.

	* libbfd.c (_bfd_generic_init_private_section_data): New.

	* targets.c (BFD_JUMP_TABLE_COPY): Add
	_bfd_generic_init_private_section_data.
	(bfd_init_private_section_data): Likewise.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

ld/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Call
	bfd_match_sections_by_type to match section types.

	* ldlang.c (init_os): Take the input section. Call
	bfd_init_private_section_data if the input section isn't NULL.
	(exp_init_os): Pass NULL to init_os.
	(map_input_to_output_sections): Likewise.
	(lang_add_section): Pass the input section to init_os.

ld/testsuite/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* ld-ia64/tlspic.rd: Updated.
@
text
@d1461 1
a1461 1
_bfd_elf_link_hash_copy_indirect (const struct elf_backend_data *bed,
d1465 1
a1465 2
  bfd_signed_vma tmp;
  bfd_signed_vma lowest_valid = bed->can_refcount;
d1482 2
a1483 2
  tmp = dir->got.refcount;
  if (tmp < lowest_valid)
d1485 4
a1488 2
      dir->got.refcount = ind->got.refcount;
      ind->got.refcount = tmp;
a1489 2
  else
    BFD_ASSERT (ind->got.refcount < lowest_valid);
d1491 1
a1491 2
  tmp = dir->plt.refcount;
  if (tmp < lowest_valid)
d1493 4
a1496 2
      dir->plt.refcount = ind->plt.refcount;
      ind->plt.refcount = tmp;
a1497 2
  else
    BFD_ASSERT (ind->plt.refcount < lowest_valid);
d1499 1
a1499 1
  if (dir->dynindx == -1)
d1501 2
a1507 2
  else
    BFD_ASSERT (ind->dynindx == -1);
@


1.315
log
@bfd/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* elf-bfd.h (_bfd_elf_match_sections_by_type): New.
	(_bfd_generic_match_sections_by_type): New. Defined.

	* elf.c (_bfd_elf_match_sections_by_type): New.

	* libbfd-in.h (_bfd_generic_match_sections_by_type): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_match_sections_by_type): New.

	* targets.c (BFD_JUMP_TABLE_LINK): Initialize
	_bfd_match_sections_by_type with
	_bfd_generic_match_sections_by_type.
	(bfd_target): Add _bfd_match_sections_by_type.

ld/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* emultempl/elf32.em: Include "elf-bfd.h".
	(gld${EMULATION_NAME}_place_orphan): Check section type and
	don't use section name for ELF input sections.

	* ld.texinfo: Document orphan section processing.

	* ldlang.c (lang_output_section_find_by_flags): Match section
	types by calling bfd_match_sections_by_type.
@
text
@d2673 1
a2673 23
	{
	  /* We also need to mark SHF_GROUP here for relocatable
	     link.  */
	  struct bfd_link_order *l;
	  asection *elt;

	  for (l = asect->map_head.link_order; l != NULL; l = l->next)
	    if (l->type == bfd_indirect_link_order
		&& (elt = elf_next_in_group (l->u.indirect.section)) != NULL)
	      do
		{
		  /* The name is not important. Anything will do.  */
		  elf_group_name (elt->output_section) = "G";
		  elf_section_flags (elt->output_section) |= SHF_GROUP;

		  elt = elf_next_in_group (elt);
		  /* During a relocatable link, the lists are
		     circular.  */
		}
	      while (elt != elf_next_in_group (l->u.indirect.section));

	  this_hdr->sh_type = SHT_GROUP;
	}
a2807 1
  struct bfd_link_order *l;
a2875 16
  /* If this is a relocatable link, then the above did nothing because
     SEC is the output section.  Look through the input sections
     instead.  */
  for (l = sec->map_head.link_order; l != NULL; l = l->next)
    if (l->type == bfd_indirect_link_order
	&& (elt = elf_next_in_group (l->u.indirect.section)) != NULL)
      do
	{
	  loc -= 4;
	  H_PUT_32 (abfd,
		    elf_section_data (elt->output_section)->this_idx, loc);
	  elt = elf_next_in_group (elt);
	  /* During a relocatable link, the lists are circular.  */
	}
      while (elt != elf_next_in_group (l->u.indirect.section));

a3054 2
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  else
d3056 1
a3056 5
	      struct bfd_link_order *p;

	      /* Find out what the corresponding section in output
		 is.  */
	      for (p = sec->map_head.link_order; p != NULL; p = p->next)
d3058 3
a3060 4
		  s = p->u.indirect.section;
		  if (p->type == bfd_indirect_link_order
		      && (bfd_get_flavour (s->owner)
			  == bfd_target_elf_flavour))
d3062 9
a3070 11
		      Elf_Internal_Shdr ** const elf_shdrp
			= elf_elfsections (s->owner);
		      int elfsec
			= _bfd_elf_section_from_bfd_section (s->owner, s);
		      elfsec = elf_shdrp[elfsec]->sh_link;
		      /* PR 290:
			 The Intel C compiler generates SHT_IA_64_UNWIND with
			 SHF_LINK_ORDER.  But it doesn't set the sh_link or
			 sh_info fields.  Hence we could get the situation
		         where elfsec is 0.  */
		      if (elfsec == 0)
d3072 2
a3073 6
			  const struct elf_backend_data *bed
			    = get_elf_backend_data (abfd);
			  if (bed->link_order_error_handler)
			    bed->link_order_error_handler
			      (_("%B: warning: sh_link not set for section `%A'"),
			       abfd, s);
d3075 1
a3075 26
		      else
			{
			  s = elf_shdrp[elfsec]->bfd_section;
			  if (elf_discarded_section (s))
			    {
			      asection *kept;
			       (*_bfd_error_handler)
				  (_("%B: sh_link of section `%A' points to discarded section `%A' of `%B'"),
				   abfd, d->this_hdr.bfd_section,
				   s, s->owner);
			       /* Point to the kept section if it has
				  the same size as the discarded
				  one.  */
			       kept = _bfd_elf_check_kept_section (s);
			       if (kept == NULL)
				 {
				   bfd_set_error (bfd_error_bad_value);
				   return FALSE;
				 }
			       s = kept;
			    }
			  s = s->output_section;
			  BFD_ASSERT (s != NULL);
			  d->this_hdr.sh_link = elf_section_data (s)->this_idx;
			}
		      break;
d3077 2
d3080 15
d5608 56
d5690 2
a5691 21
  /* Set things up for objcopy.  The output SHT_GROUP section will
     have its elf_next_in_group pointing back to the input group
     members.  Ignore linker created group section.  See
     elfNN_ia64_object_p in elfxx-ia64.c.  We also need to handle
     elf_linked_to_section for SHF_LINK_ORDER.  */

  if ((ihdr->sh_flags & SHF_LINK_ORDER) != 0
      && elf_linked_to_section (isec) != 0)
    elf_linked_to_section (osec)
      = elf_linked_to_section (isec)->output_section;

  if (elf_sec_group (isec) == NULL
      || (elf_sec_group (isec)->flags & SEC_LINKER_CREATED) == 0)
    {
      elf_next_in_group (osec) = elf_next_in_group (isec);
      elf_group_name (osec) = elf_group_name (isec);
    }

  osec->use_rela_p = isec->use_rela_p;

  return TRUE;
@


1.314
log
@        * archive.c: Add missing SUBSECTION for documentation.
        * bfd.c: Likewise.
        * cache.c: Likewise.
        * corefile.c: Likewise.
        * format.c: Likewise.
        * init.c: Likewise.
        * libbfd.c: Likewise.
        * opncls.c: Likewise.
        * elf.c: Remove blank line after SECTION heading.
        * reloc.c: Change "howto manager" SECTION to a SUBSECTION.
@
text
@d8505 15
@


1.313
log
@	* elf.c (_bfd_elf_get_synthetic_symtab): Set BSF_GLOBAL on
	synthetic syms.
@
text
@d22 2
a23 2
/*  SECTION

@


1.312
log
@2005-09-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1321
	* elf-bfd.h (_bfd_elf_setup_group_pointers): Renamed to ...
	(_bfd_elf_setup_sections): This.
	* elf.c: Likewise.
	* elfcode.h (elf_object_p): Likewise.

	* elf.c (_bfd_elf_setup_sections): Process SHF_LINK_ORDER.
	(_bfd_elf_copy_private_section_data): Likewise.
@
text
@d8273 4
@


1.311
log
@bfd/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_large_com_section): New.
	* elf.c (_bfd_elf_large_com_section): New. Defined.

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): New.
	(elf64_x86_64_elf_section_from_bfd_section): New.
	(elf64_x86_64_symbol_processing): New.
	(elf64_x86_64_common_definition): New.
	(elf64_x86_64_common_section_index): New.
	(elf64_x86_64_common_section): New.
	(elf64_x86_64_merge_symbol): New.
	(elf64_x86_64_additional_program_headers): New.
	(elf64_x86_64_special_sections): New.
	(elf_backend_section_from_bfd_section): New. Defined.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.
	(elf_backend_special_sections): Likewise.
	(elf_backend_additional_program_headers): Likewise.

binutils/

2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Handle SHN_X86_64_LCOMMON.
	(get_symbol_index_type): Likewise.
	(get_elf_section_flags): Handle SHF_X86_64_LARGE.

gas/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c: Include "elf/x86-64.h" if TC_I386 is
	defined.
	(elf_com_section_ptr): New.
	(elf_begin): Set elf_com_section_ptr to bfd_com_section_ptr.
	(elf_common_parse): Make it global. Use elf_com_section_ptr
	instead of bfd_com_section_ptr.
	(obj_elf_change_section): Handle x86-64 large bss sections.

	* config/obj-elf.h (elf_com_section_ptr): New.
	(elf_common_parse): New.

	* config/tc-i386.c (handle_large_common): New.
	(md_pseudo_table): Add "largecomm".
	(x86_64_section_letter): New.
	(x86_64_section_word): New.

	* config/tc-i386.h (x86_64_section_word): New.
	(x86_64_section_letter): New.
	(md_elf_section_letter): New. Defined.
	(md_elf_section_word): Likewise.

include/elf/

2005-07-25  Jan Hubicka  <jh@@suse.cz>

	* x86-64.h (SHN_X86_64_LCOMMON): New.
	(SHF_X86_64_LARGE): New.

ld/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (LARGE_SECTIONS): New.

	* scripttempl/elf.sc: Updated for large section support.
@
text
@d629 1
a629 1
_bfd_elf_setup_group_pointers (bfd *abfd)
d634 1
d636 28
d5697 8
a5704 1
     elfNN_ia64_object_p in elfxx-ia64.c.  */
@


1.310
log
@2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add common_definition,
	common_section_index, common_section, and merge_symbol.
	(_bfd_elf_common_definition): New.
	(_bfd_elf_common_section_index): New.
	(_bfd_elf_common_section): New.

	* elf.c (elf_fake_sections): Don't clear sh_flags.

	* elflink.c (_bfd_elf_merge_symbol): Call backend merge_symbol
	if it is available.
	(is_global_data_symbol_definition): Call backend
	common_definition instead of checking SHN_COMMON.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_output_extsym): Call backend common_section_index
	for common section index.
	(_bfd_elf_common_definition): New.
	(_bfd_elf_common_section_index): New.
	(_bfd_elf_common_section): New.

	* elfxx-target.h (elf_backend_common_definition): New.
	(elf_backend_common_section_index): New.
	(elf_backend_common_section): New.
	(elf_backend_merge_symbol): New.
	(elfNN_bed): Initialize common_definition, common_section_index,
	common_section, and merge_symbol.

	* section.c (BFD_FAKE_SECTION): New.
	(STD_SECTION): Use it.
	* bfd-in2.h: Regenerated.
@
text
@d8459 6
@


1.309
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@d2621 1
a2621 1
  this_hdr->sh_flags = 0;
@


1.308
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d2342 1
a2342 1
_bfd_elf_get_sec_type_attr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d2346 1
d2352 11
@


1.307
log
@	* elf.c (bfd_elf_get_str_section): Allocate an extra byte after
	the end of strtab and clear it.
	(elf_read): Remove.
@
text
@d343 1
a343 1
      alloc_ext = bfd_malloc (amt);
d362 2
a363 1
	  alloc_extshndx = bfd_malloc (amt);
d377 1
a377 2
      bfd_size_type amt = symcount * sizeof (Elf_Internal_Sym);
      intsym_buf = bfd_malloc (amt);
d497 1
a497 1
	  
d499 2
a500 2
	  amt = num_group * sizeof (Elf_Internal_Shdr *);
	  elf_tdata (abfd)->group_sect_ptr = bfd_alloc (abfd, amt);
d520 2
a521 1
		  shdr->contents = bfd_alloc (abfd, amt);
d1223 3
a1225 2
		   t->vd_flags, t->vd_hash, t->vd_nodename);
	  if (t->vd_auxptr->vda_nextptr != NULL)
d1233 2
a1234 1
		fprintf (f, "%s ", a->vda_nodename);
d1249 2
a1250 1
	  fprintf (f, _("  required from %s:\n"), t->vn_filename);
d1253 2
a1254 1
		     a->vna_flags, a->vna_other, a->vna_nodename);
a2890 1
  bfd_size_type amt;
d2994 1
a2994 2
  amt = section_number * sizeof (Elf_Internal_Shdr *);
  i_shdrp = bfd_zalloc (abfd, amt);
d2998 1
a2998 2
  amt = sizeof (Elf_Internal_Shdr);
  i_shdrp[0] = bfd_zalloc (abfd, amt);
a3248 1
  bfd_size_type amt;
d3262 1
a3262 2
  amt = max_index * sizeof (asymbol *);
  sect_syms = bfd_zalloc (abfd, amt);
d3335 1
a3335 2
  amt = (num_locals + num_globals) * sizeof (asymbol *);
  new_syms = bfd_alloc (abfd, amt);
d3594 1
a3594 2
  amt = bfd_count_sections (abfd) * sizeof (asection *);
  sections = bfd_malloc (amt);
a4025 1
  bfd_size_type amt;
d4100 1
a4100 2
  amt = alloc * sizeof (Elf_Internal_Phdr);
  phdrs = bfd_alloc (abfd, amt);
d5360 1
a5360 2
      amt = section_count * sizeof (asection *);
      sections = bfd_malloc (amt);
d5782 1
a5782 2
  amt = (bfd_size_type) (1 + symcount) * bed->s->sizeof_sym;
  outbound_syms = bfd_alloc (abfd, amt);
d5795 2
a5796 1
      outbound_shndx = bfd_zalloc (abfd, amt);
a6208 1
  bfd_size_type amt;
d6217 1
d6221 2
a6222 2
      amt = (bfd_size_type) hdr->sh_info * sizeof (Elf_Internal_Verneed);
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
d6230 6
a6235 1
	goto error_return;
d6238 4
a6241 1
	goto error_return;
d6243 3
d6262 11
a6272 1
	    goto error_return;
d6274 3
a6276 3
	  amt = iverneed->vn_cnt;
	  amt *= sizeof (Elf_Internal_Vernaux);
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);
d6289 1
a6289 1
		goto error_return;
d6296 4
d6312 4
d6333 1
d6344 10
d6366 4
d6381 2
a6382 2
      amt = (bfd_size_type) maxidx * sizeof (Elf_Internal_Verdef);
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
d6398 8
d6411 13
a6423 4
	  amt = (bfd_size_type) iverdef->vd_cnt * sizeof (Elf_Internal_Verdaux);
	  iverdef->vd_auxptr = bfd_alloc (abfd, amt);
	  if (iverdef->vd_auxptr == NULL)
	    goto error_return;
d6436 1
a6436 1
		goto error_return;
d6443 4
d6451 2
a6452 1
	  iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;
d6454 1
a6454 1
	  if (i + 1 < hdr->sh_info)
d6473 2
a6474 2
      amt = (bfd_size_type) freeidx * sizeof (Elf_Internal_Verdef);
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
d6498 1
a6498 1
	goto error_return;
d6500 3
a6502 2
      amt = (bfd_size_type) sizeof (Elf_Internal_Verdaux);
      iverdef->vd_auxptr = bfd_alloc (abfd, amt);
@


1.306
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a208 22
/* Read a specified number of bytes at a specified offset in an ELF
   file, into a newly allocated buffer, and return a pointer to the
   buffer.  */

static bfd_byte *
elf_read (bfd *abfd, file_ptr offset, bfd_size_type size)
{
  bfd_byte *buf;

  if ((buf = bfd_alloc (abfd, size)) == NULL)
    return NULL;
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return NULL;
  if (bfd_bread (buf, size, abfd) != size)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_file_truncated);
      return NULL;
    }
  return buf;
}

d248 15
a262 1
      shstrtab = elf_read (abfd, offset, shstrtabsize);
@


1.305
log
@	PR 1042
	* elf.c (assign_file_positions_for_segments): Remove excluded
	sections from the segment map.
@
text
@d2167 1
a2167 1
static struct bfd_elf_special_section const special_sections_b[] =
d2173 1
a2173 1
static struct bfd_elf_special_section const special_sections_c[] =
d2179 1
a2179 1
static struct bfd_elf_special_section const special_sections_d[] =
d2194 1
a2194 1
static struct bfd_elf_special_section const special_sections_f[] =
d2201 1
a2201 1
static struct bfd_elf_special_section const special_sections_g[] =
d2213 1
a2213 1
static struct bfd_elf_special_section const special_sections_h[] =
d2219 1
a2219 1
static struct bfd_elf_special_section const special_sections_i[] =
d2227 1
a2227 1
static struct bfd_elf_special_section const special_sections_l[] =
d2233 1
a2233 1
static struct bfd_elf_special_section const special_sections_n[] =
d2240 1
a2240 1
static struct bfd_elf_special_section const special_sections_p[] =
d2247 1
a2247 1
static struct bfd_elf_special_section const special_sections_r[] =
d2256 1
a2256 1
static struct bfd_elf_special_section const special_sections_s[] =
d2265 1
a2265 1
static struct bfd_elf_special_section const special_sections_t[] =
d2273 1
a2273 1
static struct bfd_elf_special_section const *special_sections[] =
@


1.304
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d4047 2
a4048 1
	 sections from the segment map.  */
a4055 3
	  if (m->p_type != PT_LOAD)
	    continue;

d4059 3
a4061 1
	      if ((m->sections[i]->flags & SEC_ALLOC) != 0)
@


1.303
log
@	* elf.c (bfd_section_from_shdr): Kill bogus warning.
@
text
@d2273 1
a2273 1
static struct bfd_elf_special_section const *special_sections [27] =
a2274 1
  NULL,				/* 'a' */
a2293 7
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
d2296 4
a2299 4
static const struct bfd_elf_special_section *
get_special_section (const char *name,
		     const struct bfd_elf_special_section **special_sections_p,
		     unsigned int rela)
a2302 12
  const struct bfd_elf_special_section *special_sections;

  if (name [0] == '.')
    {
      i = name [1] - 'a';
      if (i < 0 || i > 25)
	i = 26;
    }
  else
    i = 26;

  special_sections = special_sections_p [i];
d2304 1
a2304 2
  if (!special_sections)
    return special_sections;
d2306 1
a2306 3
  len= strlen (name);

  for (i = 0; special_sections[i].prefix != NULL; i++)
d2309 1
a2309 1
      int prefix_len = special_sections[i].prefix_length;
d2313 1
a2313 1
      if (memcmp (name, special_sections[i].prefix, prefix_len) != 0)
d2316 1
a2316 1
      suffix_len = special_sections[i].suffix_length;
d2325 1
a2325 1
		      || (rela && special_sections[i].type == SHT_REL)))
d2334 1
a2334 1
		      special_sections[i].prefix + prefix_len,
d2338 1
a2338 1
      return &special_sections[i];
d2345 1
a2345 1
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name)
d2347 2
a2348 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct bfd_elf_special_section *ssect = NULL;
d2351 9
a2359 3
  if (name)
    {
      unsigned int rela = bed->default_use_rela_p;
d2361 1
a2361 2
      if (bed->special_sections)
	ssect = get_special_section (name, bed->special_sections, rela);
d2363 2
a2364 3
      if (! ssect)
	ssect = get_special_section (name, special_sections, rela);
    }
d2366 1
a2366 1
  return ssect;
d2373 1
d2385 4
d2395 1
a2395 1
      ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
a2402 3
  /* Indicate whether or not this section should use RELA relocations.  */
  sec->use_rela_p = get_elf_backend_data (abfd)->default_use_rela_p;

@


1.302
log
@	* elf.c (bfd_section_from_shdr): Fail if sh_entsize is bogus for
	symbol, relocation, group or versym sections.

	* coffcode.h (coff_slurp_reloc_table): Don't crash if native_relocs
	is NULL.
	* peXXigen.c (pe_print_idata): Don't crash if dll_name or start_address
	doesn't point into the section.
@
text
@d1951 2
a1952 1
	if (hdr->sh_entsize != (hdr->sh_type == SHT_REL
@


1.301
log
@	* elf.c (bfd_section_from_shdr): Fail if name is NULL.
	Prevent endless recursion on broken objects.

	* archive.c (do_slurp_coff_armap): Check for overflows.
@
text
@d1814 2
a1815 1
      BFD_ASSERT (hdr->sh_entsize == bed->s->sizeof_sym);
d1866 2
a1867 1
      BFD_ASSERT (hdr->sh_entsize == bed->s->sizeof_sym);
d1951 4
d2013 4
a2016 4
        /* Prevent endless recursion on broken objects.  */
        if (elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_REL
            || elf_elfsections (abfd)[hdr->sh_info]->sh_type == SHT_RELA)
          return FALSE;
d2056 2
d2076 2
@


1.300
log
@bfd/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* bfd.c (bfd_find_line): New.

	* dwarf2.c (comp_unit): Add variable_table.
	(funcinfo): Add file, line, and sec.
	(varinfo): New.
	(lookup_symbol_in_function_table): New.
	(lookup_symbol_in_variable_table): New.
	(scan_unit_for_functions): Renamed to ...
	(scan_unit_for_symbols): This. Handle DW_TAG_entry_point and
	DW_TAG_variable.
	(comp_unit_find_nearest_line): Updated.
	(comp_unit_find_line): New.
	(_bfd_dwarf2_find_line): New.

	* elf-bfd.h (_bfd_elf_find_line): New.
	(_bfd_generic_find_line): New. Defined.

	* elf.c (_bfd_elf_find_line): New.

	* libbfd-in.h (_bfd_dwarf2_find_line): New.
	(_bfd_generic_find_line): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_find_line): New.

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize _bfd_find_line
	with _bfd_generic_find_line.
	(bfd_target): Add _bfd_find_line.

binutils/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* nm.c (print_symbol): Call bfd_find_line before
	bfd_find_nearest_line.
@
text
@d1755 2
d1927 3
d2007 4
@


1.299
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d6675 11
@


1.298
log
@	* elf-bfd.h (struct elf_link_hash_table): Delete init_refcount and
	init_offset.  Add init_got_refcount, init_plt_refcount,
	init_got_offset and init_plt_offset.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust for above change.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	(_bfd_elf_link_hash_table_init): Likewise.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (GLINK_PLTRESOLVE): Now 16 insns.
	(LWZU_0_X_12, LWZ_0_4_30, LWZ_0_X_12, LWZ_11_X_11, LWZ_11_X_30,
	LWZ_12_4_12, LWZ_12_8_30, LWZ_12_X_12, SUB_11_11_30): Delete.
	(ADDIS_12_12, BCL_20_31, LWZU_0_12, LWZ_0_12, LWZ_11_11, LWZ_11_30,
	LWZ_12_12, MFLR_0, MFLR_12, MTLR_0, SUB_11_11_12): Define.
	(struct plt_entry): New.
	(ppc_elf_link_hash_table_create): Set new init_plt fields.
	(ppc_elf_copy_indirect_symbol): Handle merge of plt plist.  Don't
	use _bfd_elf_link_hash_copy_indirect.
	(update_plt_info, find_plt_ent): New functions.
	(ppc_elf_check_relocs): Handle R_PPC_PLTREL24 with non-zero addend
	and adjust for use of plt list rather than refcount.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_tls_optimize): Likewise.
	(ppc_elf_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.  Adjust R_PPC_PLTREL24 addends
	when performing a relocatable link.
	(ppc_elf_finish_dynamic_symbol): Likewise.  Write .glink stubs here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Use new
	pic resolver stub.
@
text
@d6675 19
@


1.297
log
@	* elf.c (assign_file_positions_for_segments): Use maximum of
	maxpagesize and section alignment when adjusting initial
	segment offset and section offsets.
@
text
@d1417 2
a1418 1
      ret->got = ret->plt = htab->init_refcount;
d1491 1
a1491 1
  h->plt = elf_hash_table (info)->init_offset;
d1516 1
d1520 4
a1523 5
  /* Make sure can_refcount is extended to the width and signedness of
     init_refcount before we subtract one from it.  */
  table->init_refcount.refcount = get_elf_backend_data (abfd)->can_refcount;
  table->init_refcount.refcount -= 1;
  table->init_offset.offset = -(bfd_vma) 1;
@


1.296
log
@2005-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (group_signature): Check if the symbol table section is
	correct.
@
text
@d4154 1
d4156 1
a4156 3
	  if ((abfd->flags & D_PAGED) != 0)
	    align = bed->maxpagesize;
	  else
d4158 1
a4158 4
	      unsigned int align_power = 0;
	      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
		{
		  unsigned int secalign;
d4160 3
a4162 5
		  secalign = bfd_get_section_alignment (abfd, *secpp);
		  if (secalign > align_power)
		    align_power = secalign;
		}
	      align = (bfd_size_type) 1 << align_power;
d4164 4
d4353 1
a4353 1
		  if ((abfd->flags & D_PAGED) != 0)
@


1.295
log
@	* elf.c (_bfd_elf_write_object_contents): Check for non-NULL
	elf_shstrtab.
	* format.c (bfd_check_format_matches): Set output_has_begun
	for both_direction.
	* section.c (bfd_set_section_contents): Use bfd_write_p.  Remove
	special case for both_direction.
@
text
@a453 15
  unsigned int i;

  if (ghdr == NULL)
    return NULL;

  /* If this section is linked to by other sections then it is a symbol or
     string section which is masquerading as a group.  This is a bad thing,
     and if we carry on to the call to bfd_section_from_shdr below we will
     enter an infinite loop.  So check now and break out if we detect this
     case.  See:    
     http://sources.redhat.com/ml/binutils/2005-05/msg00421.html
     for a report of a case that tirggers this code.  */
  for (i = elf_numsections (abfd); i--;)
    if (elf_elfsections (abfd) [elf_elfsections (abfd) [i]->sh_link] == ghdr)
      return NULL;
d455 5
a459 2
  /* Next we need to ensure the symbol table is available.  */
  if (! bfd_section_from_shdr (abfd, ghdr->sh_link))
@


1.294
log
@(group_signature): Check for a group section which is actually a (corrupt)
symbol table section in disguise and prevent an infinite loop from occurring.
@
text
@d4953 3
a4955 2
  if (bfd_seek (abfd, elf_tdata (abfd)->shstrtab_hdr.sh_offset, SEEK_SET) != 0
      || ! _bfd_elf_strtab_emit (abfd, elf_shstrtab (abfd)))
@


1.293
log
@(bfd_section_from_shdr): Add sanity check when parsing dynamic sections.
@
text
@d454 15
d470 1
a470 1
  /* First we need to ensure the symbol table is available.  */
@


1.292
log
@2005-05-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_make_section_from_shdr): Only check debug
	section if SEC_ALLOC isn't set.
@
text
@d1771 3
@


1.291
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d753 1
a753 4
  /* The debugging sections appear to be recognized only by name, not
     any sort of flag.  */
  {
    static const char *debug_sec_names [] =
d755 37
a791 14
      ".debug",
      ".gnu.linkonce.wi.",
      ".line",
      ".stab"
    };
    int i;

    for (i = ARRAY_SIZE (debug_sec_names); i--;)
      if (strncmp (name, debug_sec_names[i], strlen (debug_sec_names[i])) == 0)
	break;

    if (i >= 0)
      flags |= SEC_DEBUGGING;
  }
@


1.290
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_close_and_cleanup): Only call
	_bfd_dwarf2_cleanup_debug_info on bfd_object.
@
text
@d2120 1
a2120 1
static struct bfd_elf_special_section const special_sections[] =
d2123 5
a2127 1
  { ".gnu.linkonce.b",15, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
d2129 5
a2136 11
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
d2144 13
a2157 6
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
d2161 27
d2190 14
d2206 8
a2214 2
  { ".gnu.liblist",   12,  0, SHT_GNU_LIBLIST, SHF_ALLOC },
  { ".gnu.conflict",  13,  0, SHT_RELA,     SHF_ALLOC },
d2218 39
d2259 1
a2259 1
		     const struct bfd_elf_special_section *special_sections,
d2263 18
a2280 1
  int len = strlen (name);
@


1.289
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d6686 1
a6688 2
  _bfd_dwarf2_cleanup_debug_info (abfd);

@


1.288
log
@* dwarf2.c (read_abbrevs): If bfd_realloc fails, free currently allocated memory
  before returning.
  (decode_line_info): Likewise.
  (_bfd_dwarf2_cleanup_debug_info): New function:  Frees memory	allocated by
  functions in this file.
* elf-bfd.h (_bfd_dwarf2_cleanup_debug_info): Prototype.
* elf.c (bfd_elf_close_and_cleanup): Call _bfd_dwarf2_cleanup_debug_info.
@
text
@d2248 5
a2252 4
  /* When we read a file, we don't need section type and flags.
     They will be overridden in _bfd_elf_make_section_from_shdr
     anyway.  */
  if (abfd->direction != read_direction)
@


1.287
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d6687 2
@


1.286
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.285
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2502 1
a2502 1
	  for (l = asect->link_order_head; l != NULL; l = l->next)
d2619 1
a2619 1
	  for (o = asect->link_order_head; o != NULL; o = o->next)
d2725 1
a2725 1
  for (l = sec->link_order_head; l != NULL; l = l->next)
d2927 1
a2927 1
	      for (p = sec->link_order_head; p != NULL; p = p->next)
d4298 1
a4298 1
		  for (o = sec->link_order_head; o != NULL; o = o->next)
@


1.284
log
@	* section.c (bfd_section_list_remove): Don't clear s->next.
	(bfd_section_list_append): Always init s->prev.
	(bfd_section_list_prepend): Define.
	(bfd_section_list_insert_after): Minor optimization.
	(bfd_section_removed_from_list): Rewrite.
	* elf.c (assign_section_numbers): Simplify list traversal now that
	bfd_section_list_remove doesn't destroy removed section next ptr.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Use bfd_section_list_prepend.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Simplify list traversal.
	* bfd-in2.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.283
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@a2764 2
      asection *n;

d2766 1
a2766 1
      for (sec = abfd->sections; sec; sec = n)
a2769 1
	  n = sec->next;
@


1.282
log
@2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_new_section_hook): Don't call
	_bfd_elf_get_sec_type_attr on sections from input files.
@
text
@d2765 1
a2765 1
      asection **secp;
d2768 1
a2768 2
      secp = &abfd->sections;
      while (*secp)
d2770 1
a2770 1
	  d = elf_section_data (*secp);
d2772 1
d2775 1
a2775 1
	      if ((*secp)->flags & SEC_LINKER_CREATED)
d2778 1
a2778 1
		  bfd_section_list_remove (abfd, secp);
a2779 1
		  continue;
a2787 2

	  secp = &(*secp)->next;
@


1.281
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@d2248 4
a2251 3
  elf_section_type (sec) = SHT_NULL;
  ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
  if (ssect != NULL)
d2253 6
a2258 2
      elf_section_type (sec) = ssect->type;
      elf_section_flags (sec) = ssect->attr;
@


1.280
log
@	* elf.c (assign_section_numbers): Fix comment.
@
text
@d410 2
a411 1
		  Elf_Internal_Sym *isym)
d413 1
d416 1
d426 7
a432 1
  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
d465 1
a465 1
  return bfd_elf_sym_name (abfd, hdr, &isym);
@


1.279
log
@2005-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 855
	* elf.c (_bfd_elf_copy_private_section_data): Don't copy linker
	created group data.
@
text
@d2933 1
a2933 1
			 SHF_LINK_ORDER.  But it doesn't set theh sh_link or
@


1.278
log
@2005-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 855
	* elf.c (setup_group): Properly handle zero group count.
@
text
@d5522 8
a5529 3
     members.  */
  elf_next_in_group (osec) = elf_next_in_group (isec);
  elf_group_name (osec) = elf_group_name (isec);
@


1.277
log
@bfd/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (bfd_elf_set_group_contents): Ignore linker created
	group section.
	(assign_section_numbers): Accept link_info. Check SHT_GROUP
	sections for relocatable files only. Remove the linker created
	group sections.
	(_bfd_elf_compute_section_file_positions): Pass link_info to
	assign_section_numbers.

	* elfxx-ia64.c (elfNN_ia64_object_p): New.
	(elf_backend_object_p): Defined.

gas/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Undo the change
	of 2004-08-18.
	(generate_unwind_image, dot_endp): Likewise.
@
text
@d484 5
a488 4
	num_group = (unsigned) -1;
      elf_tdata (abfd)->num_group = num_group;

      if (num_group > 0)
d492 4
a495 1
	  bfd_size_type amt = num_group * sizeof (Elf_Internal_Shdr *);
@


1.276
log
@2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (bfd_elf_set_group_contents): Ignore linker created
	group section.
@
text
@d2731 1
a2731 1
assign_section_numbers (bfd *abfd)
d2744 2
a2745 2
  /* Put SHT_GROUP sections first.  */
  for (sec = abfd->sections; sec; sec = sec->next)
d2747 1
a2747 1
      d = elf_section_data (sec);
d2749 3
a2751 1
      if (d->this_hdr.sh_type == SHT_GROUP)
d2753 20
a2772 3
	  if (section_number == SHN_LORESERVE)
	    section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
	  d->this_idx = section_number++;
d3299 1
a3299 1
  if (!assign_section_numbers (abfd))
@


1.275
log
@2005-04-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (assign_section_numbers): Really use the kept section.
@
text
@d2638 3
a2640 1
  if (elf_section_data (sec)->this_hdr.sh_type != SHT_GROUP
@


1.274
log
@2005-03-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_check_kept_section): New.

	* elf.c (assign_section_numbers): When sh_link points to a
	discarded section, call _bfd_elf_check_kept_section to see if
	the kept section can be used. Otherwise reject sh_link
	pointing to discarded section.

	* elflink.c (_bfd_elf_check_kept_section): New.
	(elf_link_input_bfd): Use it.
@
text
@d2939 1
@


1.273
log
@2005-03-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (assign_section_numbers): Fix a typo.
@
text
@d2922 19
a2940 1
			  s = elf_shdrp[elfsec]->bfd_section->output_section;
@


1.272
log
@        * elf.c (elfcore_grok_nto_status): Print tid as long.
        (elfcore_grok_nto_regs): Likewise.
@
text
@d2917 1
a2917 1
			      (_("%B: warning: sh_link not set for section `%S'"),
@


1.271
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d7338 1
a7338 1
  sprintf (buf, ".qnx_core_status/%d", *tid);
d7368 1
a7368 1
  sprintf (buf, "%s/%d", base, tid);
@


1.270
log
@	* elf.c (elfcore_grok_win32pstatus): Warning fixes.
@
text
@d676 2
a677 1
				 const char *name)
d696 1
d1733 1
a1733 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1736 1
a1736 1
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
d1787 2
a1788 1
	  && ! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
d1832 1
a1832 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1868 2
a1869 1
	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1894 1
a1894 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1911 2
a1912 1
	    return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1959 2
a1960 1
	  return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d1997 1
a1997 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d2003 1
a2003 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d2009 1
a2009 1
      return _bfd_elf_make_section_from_shdr (abfd, hdr, name);
d2022 1
a2022 1
      if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name))
d2048 2
a2049 1
      return bed->elf_backend_section_from_shdr (abfd, hdr, name);
d4791 1
a4791 13
    {
      Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
      int maxindex = elf_numsections (abfd);

      for (index = 1; index < maxindex; index++)
	{
	  Elf_Internal_Shdr *hdr = i_shdrp[index];

	  if (hdr != NULL && hdr->bfd_section == asect)
	    return index;
	}
      index = -1;
    }
@


1.270.2.1
log
@	Backport from mainline:
	2005-05-29  Jakub Jelinek  <jakub@@redhat.com>
	* elfcode.h (elf_object_p): Fail if e_shoff != 0, e_shnum == 0 and
	first shdr has sh_size == 0.  Fail if e_shnum is large to cause
	arithmetic overflow when allocating the i_shdr array.
	Sanity check sh_link and sh_info fields.  Fix e_shstrndx sanity check.

	2005-05-18  H.J. Lu  <hongjiu.lu@@intel.com>
	* elf.c (group_signature): Undo the last change. Check if the
	symbol table section is correct.

	2005-05-17  Nick Clifton  <nickc@@redhat.com>
	* elf.c (group_signature): Check for a group section which is
	actually a (corrupt) symbol table section in disguise and prevent
	an infinite loop from occurring.

	2005-05-17  Tavis Ormandy <taviso@@gentoo.org>
	* elf.c (bfd_section_from_shdr): Add sanity check when parsing
	dynamic sections.

	2005-05-09  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_object_p): Add more sanity checks on elf header.
@
text
@d446 2
a447 5
  /* First we need to ensure the symbol table is available.  Make sure
     that it is a symbol table section.  */
  hdr = elf_elfsections (abfd) [ghdr->sh_link];
  if (hdr->sh_type != SHT_SYMTAB
      || ! bfd_section_from_shdr (abfd, ghdr->sh_link))
a1735 3
      if (hdr->sh_link > elf_numsections (abfd)
	  || elf_elfsections (abfd)[hdr->sh_link] == NULL)
	return FALSE;
@


1.269
log
@2005-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add "const char *" to
	elf_backend_section_from_phdr.

	* elf.c (bfd_section_from_phdr): Pass "proc" to the
	elf_backend_section_from_phdr hook.
@
text
@d7083 1
a7083 1
      sprintf (buf, ".reg/%d", pstatus.data.thread_info.tid);
d7110 2
a7111 1
      sprintf (buf, ".module/%08x", pstatus.data.module_info.base_address);
@


1.268
log
@	* elf.c (bfd_section_from_shdr <default case>): Call
	elf_backend_section_from_shdr hook unconditionally, and return
	what it returns.
	(bfd_section_from_phdr): Similarly, for elf_backend_section_from_phdr.
	* elfxx-target.h (elf_backend_section_from_shdr)
	(elf_backend_section_from_phdr): Default to
	_bfd_elf_make_section_from_shdr and _bfd_elf_make_section_from_phdr
	respectively.
@
text
@d2382 1
a2382 1
      return bed->elf_backend_section_from_phdr (abfd, hdr, index);
@


1.267
log
@(_bfd_elf_compute_section_file_positions): Initialise strtab to avoid compile
time warning.
@
text
@d2042 1
a2042 3
      if (bed->elf_backend_section_from_shdr)
	(*bed->elf_backend_section_from_shdr) (abfd, hdr, name);
      break;
d2380 1
a2380 2
      /* Check for any processor-specific program segment types.
         If no handler for them, default to making "segment" sections.  */
d2382 1
a2382 4
      if (bed->elf_backend_section_from_phdr)
	return (*bed->elf_backend_section_from_phdr) (abfd, hdr, index);
      else
	return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "segment");
@


1.266
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d3236 1
a3236 1
  struct bfd_strtab_hash *strtab;
d4226 6
@


1.265
log
@2005-02-11  Paul Brook  <paul@@codesourcery.com>

	* elf-bfd.h (struct elf_link_hash_table): Add
	is_relocatable_executable.
	* elf.c (_bfd_elf_link_hash_table_init): Initialize it.
	* elflink.c (bfd_elf_link_record_dynamic_symbol): Create local dynamic
	symbols in relocatable executables.
	(bfd_elf_record_link_assignment): Create dynamic section symbols in
	relocatable executables.
	(_bfd_elf_link_renumber_dynsyms): Ditto.
	(bfd_elf_final_link): Ditto.
	* elf32-arm.c (elf32_arm_final_link_relocate): Copy absolute
	relocations into relocatable executables.
	(elf32_arm_check_relocs): Crate dynamic sections for relocatable
	executables.  Also copy absolute relocations.
	(elf32_arm_adjust_dynamic_symbol): Don't create copy relocations
	in relocatable executables.
	(allocate_dynrelocs): Copy relocations for relocatable executables.
	Output dynamic symbols for symbols defined in linker scripts.
@
text
@d213 1
a213 1
static char *
d216 1
a216 1
  char *buf;
d256 1
a256 1
  char *shstrtab = NULL;
d262 1
a262 1
    return 0;
d264 1
a264 1
  shstrtab = (char *) i_shdrp[shindex]->contents;
d273 1
a273 1
  return shstrtab;
d5579 2
a5580 2
  char *outbound_syms;
  char *outbound_shndx;
d7869 1
a7869 1
   int (*target_read_memory) (bfd_vma, char *, int))
@


1.264
log
@	* elf-bfd.h (elf_string_from_elf_strtab): Delete macro.
	* elf.c (bfd_elf_string_from_elf_section): Expand occurrence of
	elf_string_from_elf_strtab.
	(_bfd_elf_setup_group_pointers, bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): For SHT_SYMTAB, load SHT_SYMTAB_SHNDX too
	if it exists.  Don't do the reverse for SHT_SYMTAB_SHNDX.  For
	SHT_STRTAB, check whether the strtab is for symtab or dynsymtab by
	looking at cached symtab info first, before iterating over headers.
	For SHT_REL and SHT_RELA, load dynsymtab if needed.
	* elfcode.h (elf_object_p): Don't load section header stringtab
@
text
@d1499 1
@


1.263
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d294 1
d298 1
a298 2
	 ((shindex == elf_elfheader(abfd)->e_shstrndx
	   && strindex == hdr->sh_name)
d300 1
a300 1
	  : elf_string_from_elf_strtab (abfd, hdr->sh_name)));
d653 4
a656 1
	       elf_string_from_elf_strtab (abfd, idx->shdr->sh_name),
d1712 3
a1714 1
  name = elf_string_from_elf_strtab (abfd, hdr->sh_name);
d1787 26
d1834 1
a1834 5
      /* Get the associated symbol table.  */
      if (! bfd_section_from_shdr (abfd, hdr->sh_link)
	  || hdr->sh_link != elf_onesymtab (abfd))
	return FALSE;

d1849 17
a1865 2
      {
	unsigned int i, num_sec;
d1867 6
a1872 27
	num_sec = elf_numsections (abfd);
	for (i = 1; i < num_sec; i++)
	  {
	    Elf_Internal_Shdr *hdr2 = elf_elfsections (abfd)[i];
	    if (hdr2->sh_link == shindex)
	      {
		if (! bfd_section_from_shdr (abfd, i))
		  return FALSE;
		if (elf_onesymtab (abfd) == i)
		  {
		    elf_tdata (abfd)->strtab_hdr = *hdr;
		    elf_elfsections (abfd)[shindex] =
		      &elf_tdata (abfd)->strtab_hdr;
		    return TRUE;
		  }
		if (elf_dynsymtab (abfd) == i)
		  {
		    elf_tdata (abfd)->dynstrtab_hdr = *hdr;
		    elf_elfsections (abfd)[shindex] = hdr =
		      &elf_tdata (abfd)->dynstrtab_hdr;
		    /* We also treat this as a regular section, so
		       that objcopy can handle it.  */
		    break;
		  }
	      }
	  }
      }
d1874 15
d1941 2
a1942 1
	if (elf_elfsections (abfd)[hdr->sh_link]->sh_type == SHT_SYMTAB
d2041 2
a2042 4
      {
	if (bed->elf_backend_section_from_shdr)
	  (*bed->elf_backend_section_from_shdr) (abfd, hdr, name);
      }
@


1.262
log
@	* elf-bfd.h (bfd_elf_discard_group): Remove.
	* elf.c (bfd_elf_discard_group): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Remove macro.
@
text
@a1848 11
#if 0 /* Not handling other string tables specially right now.  */
		hdr2 = elf_elfsections (abfd)[i];	/* in case it moved */
		/* We have a strtab for some random other section.  */
		newsect = (asection *) hdr2->bfd_section;
		if (!newsect)
		  break;
		hdr->bfd_section = newsect;
		hdr2 = &elf_section_data (newsect)->str_hdr;
		*hdr2 = *hdr;
		elf_elfsections (abfd)[shindex] = hdr2;
#endif
d4620 2
a4621 12
    {
      /* It all happens later.  */
#if 0
      i_ehdrp->e_phentsize = sizeof (Elf_External_Phdr);

      /* elf_build_phdrs() returns a (NULL-terminated) array of
	 Elf_Internal_Phdrs.  */
      i_phdrp = elf_build_phdrs (abfd, i_ehdrp, i_shdrp, &i_ehdrp->e_phnum);
      i_ehdrp->e_phoff = outbase;
      outbase += i_ehdrp->e_phentsize * i_ehdrp->e_phnum;
#endif
    }
a5406 25
#if 0
  /* Final Step: Sort the segments into ascending order of physical
     address.  */
  if (map_first != NULL)
    {
      struct elf_segment_map *prev;

      prev = map_first;
      for (map = map_first->next; map != NULL; prev = map, map = map->next)
	{
	  /* Yes I know - its a bubble sort....  */
	  if (map->next != NULL && (map->next->p_paddr < map->p_paddr))
	    {
	      /* Swap map and map->next.  */
	      prev->next = map->next;
	      map->next = map->next->next;
	      prev->next->next = map;

	      /* Restart loop.  */
	      map = map_first;
	    }
	}
    }
#endif

@


1.261
log
@bfd/
	* elf.c (_bfd_elf_get_dynamic_reloc_upper_bound): Only include
	loadable reloc sections.
	(_bfd_elf_canonicalize_dynamic_reloc): Likewise.
	(_bfd_elf_get_synthetic_symtab): Return 0 if no dynamic syms.
binutils/
	* nm.c (display_rel_file): Read dynamic syms before calling
	bfd_get_synthetic_symtab.
@
text
@a666 23
bfd_boolean
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *group ATTRIBUTE_UNUSED)
{
#if 0
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      s->output_section = bfd_abs_section_ptr;
      s = elf_next_in_group (s);
      /* These lists are circular.  */
      if (s == first)
	break;
    }
#else
  /* FIXME: Never used. Remove it!  */
  abort ();
#endif
  return TRUE;
}

@


1.260
log
@	* bfd/elf.c (INCLUDE_SECTION_IN_SEGMENT): Don't put empty sections into
	PT_DYNAMIC segment, unless .dynamic.
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d5980 4
a5983 4
/* Return the size required for the dynamic reloc entries.  Any
   section that was actually installed in the BFD, and has type
   SHT_REL or SHT_RELA, and uses the dynamic symbol table, is
   considered to be a dynamic reloc section.  */
d5999 2
a6000 1
    if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
d6009 7
a6015 8
/* Canonicalize the dynamic relocation entries.  Note that we return
   the dynamic relocations as a single block, although they are
   actually associated with particular sections; the interface, which
   was designed for SunOS style shared libraries, expects that there
   is only one set of dynamic relocs.  Any section that was actually
   installed in the BFD, and has type SHT_REL or SHT_RELA, and uses
   the dynamic symbol table, is considered to be a dynamic reloc
   section.  */
d6036 2
a6037 1
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
d7912 1
a7912 1
			       long dynsymcount ATTRIBUTE_UNUSED,
d7928 2
d7933 3
a7935 1
  *ret = NULL;
@


1.259
log
@* elf.c (elfcore_grok_nto_gregs): Change name to elfcore_grok_nto_regs.
Add 'base' argument for constructing register sections.  Reformat.
(elfcore_grok_nto_note): Call elfcore_grok_nto_regs for both
gp and fp regs.  Reformat.
@
text
@d4968 3
a4970 1
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
d4984 7
@


1.258
log
@	* elf.c (bfd_elf_sym_name): Add symtab_hdr param.
	(group_signature): Update call.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d7385 4
a7388 1
elfcore_grok_nto_gregs (bfd *abfd, Elf_Internal_Note *note, pid_t tid)
d7394 2
a7395 2
  /* Make a ".reg/%d" section.  */
  sprintf (buf, ".reg/%d", tid);
d7413 1
a7413 1
    return elfcore_maybe_make_sect (abfd, ".reg", sect);
d7433 10
a7442 5
    case BFD_QNT_CORE_INFO:   return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS: return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:   return elfcore_grok_nto_gregs (abfd, note, tid);
    case BFD_QNT_CORE_FPREG:  return elfcore_grok_prfpreg (abfd, note);
    default:                  return TRUE;
@


1.257
log
@	* elf.c (bfd_elf_sym_name): Rename from bfd_elf_local_sym_name.
	(group_signature): Update calls.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d408 3
a410 1
bfd_elf_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
d413 1
a413 1
  unsigned int shindex = elf_tdata (abfd)->symtab_hdr.sh_link;
d456 1
a456 1
  return bfd_elf_sym_name (abfd, &isym);
@


1.256
log
@	* elf.c (bfd_elf_local_sym_name): Avoid crashes with invalid
	st_shndx on STT_SECTION sections.
@
text
@d408 1
a408 1
bfd_elf_local_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
d454 1
a454 1
  return bfd_elf_local_sym_name (abfd, &isym);
@


1.255
log
@bfd/
2004-12-03 Jan Beulich  <jbeulich@@novell.com>

	* elf.c (elf_find_function): Don't use the last file symbol ever,
	seen, but the last one seen prior to the symbol being reported.
	Don't report a filename at all for global symbols when that might
	be ambiguous/wrong.
@
text
@d412 4
a415 1
  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION)
@


1.254
log
@2004-11-24  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf.c (assign_section_numbers): Number SHT_GROUP sections first.
gas/testsuite/
	* gas/elf/group0a.d: Adjust expected secion ordering.
	* gas/elf/group1a.d: Ditto.
	* gas/elf/section4.d: Ditto.
@
text
@d6379 1
a6379 1
  asymbol *func;
d6382 9
d6394 1
d6396 1
d6409 6
a6414 2
	  filename = bfd_asymbol_name (&q->symbol);
	  break;
d6423 7
d6433 2
@


1.253
log
@bfd/
	* elf-bfd.h (_bfd_elf_slurp_version_tables): Update prototype.
	* elf.c (_bfd_elf_print_private_bfd_data): Pass extra argument.
	(_bfd_elf_slurp_version_tables): Add extra argument.  Create extra
	default version definition for unversioned symbols.
	* elfcode.h (elf_slurp_symbol_table): Pass extra argument.
	* elflink.c (elf_link_add_object_symbols): Pass extra argument to
	_bfd_elf_slurp_version_tables.  Set default version for unversioned
	imported symbols.
include/
	* bfdlink.h (bfd_link_info): Add default_imported_symver.
ld/
	* ld.texinfo: Document --default-imported-symver.
	* ldmain.c (main): Set link_info.default_imported_symver.
	* lexsup.c (option_values): Add OPTION_DEFAULT_IMPORTED_SYMVER.
	(ld_options): Add --default-imported-symver.
	(parse_args): Handle OPTION_DEFAULT_IMPORTED_SYMVER.
@
text
@d2728 1
d2734 1
d2737 13
a2749 1
      struct bfd_elf_section_data *d = elf_section_data (sec);
d2751 6
a2756 3
      if (section_number == SHN_LORESERVE)
	section_number += SHN_HIRESERVE + 1 - SHN_LORESERVE;
      d->this_idx = section_number++;
@


1.252
log
@	* elf.c (assign_file_positions_for_segments): Set next_file_pos even
	if there are no segments.
@
text
@d1195 1
a1195 1
      if (! _bfd_elf_slurp_version_tables (abfd))
d6030 1
a6030 1
_bfd_elf_slurp_version_tables (bfd *abfd)
d6034 84
d6154 7
d6224 1
a6224 2

  if (elf_dynverref (abfd) != 0)
d6226 4
a6229 4
      Elf_Internal_Shdr *hdr;
      Elf_External_Verneed *everneed;
      Elf_Internal_Verneed *iverneed;
      unsigned int i;
d6231 3
a6233 5
      hdr = &elf_tdata (abfd)->dynverref_hdr;

      amt = (bfd_size_type) hdr->sh_info * sizeof (Elf_Internal_Verneed);
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
      if (elf_tdata (abfd)->verref == NULL)
d6236 2
a6237 1
      elf_tdata (abfd)->cverrefs = hdr->sh_info;
d6239 5
a6243 6
      contents = bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	goto error_return;
      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
	goto error_return;
d6245 1
a6245 7
      everneed = (Elf_External_Verneed *) contents;
      iverneed = elf_tdata (abfd)->verref;
      for (i = 0; i < hdr->sh_info; i++, iverneed++)
	{
	  Elf_External_Vernaux *evernaux;
	  Elf_Internal_Vernaux *ivernaux;
	  unsigned int j;
d6247 4
a6250 1
	  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);
d6252 1
a6252 1
	  iverneed->vn_bfd = abfd;
d6254 10
a6263 43
	  iverneed->vn_filename =
	    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
					     iverneed->vn_file);
	  if (iverneed->vn_filename == NULL)
	    goto error_return;

	  amt = iverneed->vn_cnt;
	  amt *= sizeof (Elf_Internal_Vernaux);
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);

	  evernaux = ((Elf_External_Vernaux *)
		      ((bfd_byte *) everneed + iverneed->vn_aux));
	  ivernaux = iverneed->vn_auxptr;
	  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
	    {
	      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);

	      ivernaux->vna_nodename =
		bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
						 ivernaux->vna_name);
	      if (ivernaux->vna_nodename == NULL)
		goto error_return;

	      if (j + 1 < iverneed->vn_cnt)
		ivernaux->vna_nextptr = ivernaux + 1;
	      else
		ivernaux->vna_nextptr = NULL;

	      evernaux = ((Elf_External_Vernaux *)
			  ((bfd_byte *) evernaux + ivernaux->vna_next));
	    }

	  if (i + 1 < hdr->sh_info)
	    iverneed->vn_nextref = iverneed + 1;
	  else
	    iverneed->vn_nextref = NULL;

	  everneed = ((Elf_External_Verneed *)
		      ((bfd_byte *) everneed + iverneed->vn_next));
	}

      free (contents);
      contents = NULL;
@


1.251
log
@	* elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Add "info"
	parameter.  If called after _bfd_elf_write_section_eh_frame,
	don't allow a -2 return unless need_* bit is already set, and
	handle offsets adjusted for output_offset.
	* elf-bfd.h (_bfd_elf_eh_frame_section_offset): Update prototype.
	* elf.c (_bfd_elf_section_offset): Update call.
@
text
@d3874 4
a3877 1
    return TRUE;
@


1.250
log
@	* elf.c (bfd_section_from_shdr): Handle SHT_GNU_LIBLIST.
	(special_sections): Add .gnu.liblist and .gnu.conflict.
	(assign_section_numbers): Handle SHT_GNU_LIBLIST.
@
text
@d7749 1
a7749 1
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
d7759 1
a7759 1
      return _bfd_elf_eh_frame_section_offset (abfd, sec, offset);
@


1.249
log
@apply mising piece of previous patch
@
text
@d1742 1
d2136 2
d2975 11
@


1.248
log
@Skip redundant/bogus test for section membership when examining symbols.
@
text
@d6316 1
a6316 1
	  if (q->symbol.section == section
@


1.247
log
@	* elf.c (IS_LOADED): Delete.
	(assign_file_positions_for_segments): Just test SEC_LOAD instead.
	Restore SEC_HAS_CONTENTS test to the one place it was used prior
	to 2004-09-22.
@
text
@a6306 3
      if (bfd_get_section (&q->symbol) != section)
	continue;

@


1.246
log
@bfd/
	* elf.c (IS_LOADED): Define.
	(assign_file_positions_for_segments): Don't round up file offset of
	PT_LOAD segments containing no SEC_LOAD sections, instead round down.
	Delete code handling link script adjustment of lma.  Do the adjust
	in later code handling similar ajustments.  Remove dead code error
	check.  Warn if section lma would require a negative offset
	adjustment.  Tweak lma adjustment to use p_filesz rather than p_memsz.
	Use p_vaddr + p_memsz inside section loop in place of voff.  Don't
	update voff in section loop.  Change voff in segment loop to be an
	adjustment on top of "off".  Set sec->filepos and update "off" later.
	Test for loadable sections consistently using IS_LOADED.  Similarly,
	test for alloc-only sections other than .tbss consistently.
	Don't bother checking SEC_ALLOC in PT_LOAD segments.  Remove FIXME.
	Tidy PT_NOTE handling.  Use %B and %A in error messages.
	(assign_file_positions_except_relocs): Use %B in error message.

ld/testsuite/
	* ld-scripts/overlay-size.d: Don't check .mbss lma.
	* ld-sh/sh64/mix1.xd: Update for changed .bss file offset.
	* ld-sh/sh64/shdl32.xd: Likewise.
	* ld-sh/sh64/shdl64.xd: Likewise.
@
text
@a3789 6
/* We check SEC_HAS_CONTENTS here because if NOLOAD is used in a linker
   script we may have a section with SEC_LOAD clear but which is
   supposed to have contents.  */
#define IS_LOADED(FLAGS) \
  (((FLAGS) & SEC_LOAD) != 0 || ((FLAGS) & SEC_HAS_CONTENTS) != 0)

d3956 1
a3956 1
	      while (!IS_LOADED (m->sections[i]->flags))
d4104 1
a4104 1
	      if (IS_LOADED (flags))
d4161 16
a4176 1
		  if (IS_LOADED (flags))
d4180 1
a4180 1
	      if (IS_LOADED (flags))
@


1.245
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d3790 6
d3875 2
a3876 2
       (_("%s: Not enough room for program headers (allocated %u, need %u)"),
	bfd_get_filename (abfd), alloc, count));
d3915 8
d3927 1
a3927 2
	  && m->count > 0
	  && (m->sections[0]->flags & SEC_ALLOC) != 0)
d3929 3
d3933 1
a3933 2
	    off += vma_page_aligned_bias (m->sections[0]->vma, off,
					  bed->maxpagesize);
d3936 1
a3936 3
	      bfd_size_type align;

	      align = 0;
d3939 1
a3939 1
		  bfd_size_type secalign;
d3942 2
a3943 2
		  if (secalign > align)
		    align = secalign;
d3945 2
d3948 24
a3971 2
	      off += vma_page_aligned_bias (m->sections[0]->vma, off,
					    1 << align);
d3981 2
a3982 2
	    (_("%s: The first section in the PT_DYNAMIC segment is not the .dynamic section"),
	     bfd_get_filename (abfd));
d4025 2
a4026 2
		    (_("%s: Not enough room for program headers, try linking with -N"),
		     bfd_get_filename (abfd));
d4084 1
a4084 1
	    p->p_offset = off;
a4094 2
      voff = off;

d4105 2
a4106 21
	  /* The section may have artificial alignment forced by a
	     link script.  Notice this case by the gap between the
	     cumulative phdr lma and the section's lma.  */
	  if (p->p_paddr + p->p_memsz < sec->lma)
	    {
	      bfd_vma adjust = sec->lma - (p->p_paddr + p->p_memsz);

	      p->p_memsz += adjust;
	      if (p->p_type == PT_LOAD
		  || (p->p_type == PT_NOTE
		      && bfd_get_format (abfd) == bfd_core))
		{
		  off += adjust;
		  voff += adjust;
		}
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_THREAD_LOCAL) != 0)
		p->p_filesz += adjust;
	    }

	  if (p->p_type == PT_LOAD)
d4110 1
a4110 1
	      if ((flags & SEC_LOAD) != 0)
d4112 1
a4112 1
		  adjust = sec->lma - (p->p_paddr + p->p_memsz);
d4114 9
a4122 1
		    adjust = 0;
d4124 4
a4127 1
	      else if ((flags & SEC_ALLOC) != 0)
d4130 2
a4131 4
		     modulo the page size.  FIXME: I'm not sure if
		     this adjustment is really necessary.  We used to
		     not have the SEC_LOAD case just above, and then
		     this was necessary, but now I'm not sure.  */
d4133 4
a4136 20
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    bed->maxpagesize);
		  else
		    adjust = vma_page_aligned_bias (sec->vma, voff,
						    align);
		}
	      else
		adjust = 0;

	      if (adjust != 0)
		{
		  if (i == 0)
		    {
		      (* _bfd_error_handler) (_("\
Error: First section in segment (%s) starts at 0x%x whereas the segment starts at 0x%x"),
					      bfd_section_name (abfd, sec),
					      sec->lma,
					      p->p_paddr);
		      return FALSE;
		    }
a4137 4
		  off += adjust;
		  voff += adjust;
		  if ((flags & SEC_LOAD) != 0)
		    p->p_filesz += adjust;
a4138 15

	      sec->filepos = off;

	      /* We check SEC_HAS_CONTENTS here because if NOLOAD is
                 used in a linker script we may have a section with
                 SEC_LOAD clear but which is supposed to have
                 contents.  */
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_HAS_CONTENTS) != 0)
		off += sec->size;

	      if ((flags & SEC_ALLOC) != 0
		  && ((flags & SEC_LOAD) != 0
		      || (flags & SEC_THREAD_LOCAL) == 0))
		voff += sec->size;
d4143 2
a4144 2
	      /* The actual "note" segment has i == 0.
		 This is the one that actually contains everything.  */
d4148 1
d4150 2
a4151 2
		  off += sec->size;
		  voff = off;
d4155 1
a4155 1
		  /* Fake sections -- don't need to be written.  */
d4158 2
a4159 1
		  flags = sec->flags = 0;
a4160 2
	      p->p_memsz = 0;
	      p->p_align = 1;
d4164 6
a4169 4
	      if ((sec->flags & SEC_LOAD) != 0
		  || (sec->flags & SEC_THREAD_LOCAL) == 0
		  || p->p_type == PT_TLS)
	      p->p_memsz += sec->size;
d4171 10
a4180 2
	      if ((flags & SEC_LOAD) != 0)
		p->p_filesz += sec->size;
d4496 2
a4497 2
	       (_("%s: warning: allocated section `%s' not in segment"),
		bfd_get_filename (abfd),
@


1.244
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1394 3
a1396 12
      ret->dynstr_index = 0;
      ret->elf_hash_value = 0;
      ret->weakdef = NULL;
      ret->verinfo.verdef = NULL;
      ret->vtable_entries_size = 0;
      ret->vtable_entries_used = NULL;
      ret->vtable_parent = NULL;
      ret->got = htab->init_refcount;
      ret->plt = htab->init_refcount;
      ret->size = 0;
      ret->type = STT_NOTYPE;
      ret->other = 0;
a1400 8
      ret->ref_regular = 0;
      ret->def_regular = 0;
      ret->ref_dynamic = 0;
      ret->def_dynamic = 0;
      ret->ref_regular_nonweak = 0;
      ret->dynamic_adjusted = 0;
      ret->needs_copy = 0;
      ret->needs_plt = 0;
a1401 7
      ret->hidden = 0;
      ret->forced_local = 0;
      ret->mark = 0;
      ret->non_got_ref = 0;
      ret->dynamic_def = 0;
      ret->dynamic_weak = 0;
      ret->pointer_equality_needed = 0;
@


1.243
log
@	* elf.c  (assign_file_positions_except_relocs): Assign relocs
	stored in a bfd section.
@
text
@d1410 16
a1425 1
      ret->elf_link_hash_flags = ELF_LINK_NON_ELF;
d1445 6
a1450 7
  dir->elf_link_hash_flags
    |= ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_NON_GOT_REF
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED);
d1492 1
a1492 1
  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1495 1
a1495 1
      h->elf_link_hash_flags |= ELF_LINK_FORCED_LOCAL;
@


1.242
log
@	* elf-bfd.h (_bfd_elf_make_dynamic_segment): Declare it.
	* elf.c (_bfd_elf_make_dynamic_segment): New function, split out
	from ...
	(map_sections_to_segments): ... here.  Use it.  Assign a file
	position to the .dynamic section if it is not loadable, but part
	of the PT_DYNAMIC segment.
	* elf32-arm.h (elf32_arm_finish_dynamic_sections): Use file
	offsets, not VMAs, for the BPABI.  Do not fill in the header in
	the .got.plt section for the BPABI.
	* elfarm-nabi.c (elf32_arm_symbian_modify_segment_map): Add a
	PT_DYNAMIC segment.
	(elf_backend_want_got_plt): Define to zero for Symbian OS.

	* emulparams/armsymbian.sh: Use armbpabi script.
	* scripttempl/armbpabi.sc: New script.
@
text
@d4426 7
a4432 4
   We do not consider reloc sections at this point, unless they form
   part of the loadable image.  Reloc sections are assigned file
   positions in assign_file_positions_for_relocs, which is called by
   write_object_contents and final_link.
d4464 2
a4465 2
	  if (hdr->sh_type == SHT_REL
	      || hdr->sh_type == SHT_RELA
d4520 2
a4521 2
	  else if (hdr->sh_type == SHT_REL
		   || hdr->sh_type == SHT_RELA
@


1.241
log
@	* elf.c (special_sections): Add .gnu.linkonce.b modelled on .bss.
@
text
@d3332 19
d3588 1
a3588 2
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
a3590 5
      m->next = NULL;
      m->p_type = PT_DYNAMIC;
      m->count = 1;
      m->sections[0] = dynsec;

d4231 16
@


1.240
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Pass counts and both symbol tables.
	* elf-bfd.h (_bfd_elf_get_synthetic_symtab): Adjust.
	* elf.c (_bfd_elf_get_synthetic_symtab): Adjust.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Adjust.
	* targets.c (struct bfd_target <_bfd_get_synthetic_symtab>): Adjust.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't read symbols.
	Use both symbol tables on non-relocatable objects.  Use a common
	error exit.  Fix "mid" warning.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
binutils/
	* objdump.c (dump_bfd): Pass both symbol tables to
	bfd_get_synthetic_symtab.
@
text
@d2107 1
@


1.239
log
@bfd/
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Only define
	if not yet defined.
	* elf64-ppc.c (bfd_elf64_get_synthetic_symtab): Define.
	(synthetic_opd, synthetic_relocatable): New variables.
	(compare_symbols, compare_relocs): New helper routines.
	(ppc64_elf_get_synthetic_symtab): New function.
	* bfd.c (bfd_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.  Return 0 if abfd is relocatable.
binutils/
	* objdump.c (dump_bfd): For relocatable objects, pass syms instead
	of dynsyms to bfd_get_synthetic_symtab.
@
text
@d7747 6
a7752 1
_bfd_elf_get_synthetic_symtab (bfd *abfd, asymbol **relsyms, asymbol **ret)
d7790 1
a7790 1
  if (! (*slurp_relocs) (abfd, relplt, relsyms, TRUE))
@


1.238
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d7747 1
a7747 1
_bfd_elf_get_synthetic_symtab (bfd *abfd, asymbol **dynsyms, asymbol **ret)
d7761 3
d7785 1
a7785 1
  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
@


1.237
log
@2004-07-30  H.J. Lu  <hongjiu.lu@@intel.com>
	    Nick Clifton  <nickc@@redhat.com>

	PR 290
	* bfd.c (_bfd_default_error_handler): Make it global.

	* elf-bfd.h (elf_backend_data): Add link_order_error_handler.

	* elf.c (assign_section_numbers): Cope gracefully with sections
	which have SHF_LINK_ORDER set but no sh_link set up.
	* elflink.c (elf_get_linked_section_vma): Likewise.

	* elfxx-ia64.c (elf_backend_link_order_error_handler): New. Set
	it to NULL.

	* elfxx-target.h (elf_backend_link_order_error_handler): New.
	Set it to _bfd_default_error_handler.
	(elfNN_bed): Add elf_backend_link_order_error_handler.

	* libbfd-in.h (_bfd_default_error_handler): New.

	* libbfd.h: Regenerated.
@
text
@d295 2
a296 2
	(_("%s: invalid string offset %u >= %lu for section `%s'"),
	 bfd_archive_filename (abfd), strindex, (unsigned long) hdr->sh_size,
d538 1
a538 2
			   (_("%s: invalid SHT_GROUP entry"),
			    bfd_archive_filename (abfd)));
d608 2
a609 2
      (*_bfd_error_handler) (_("%s: no group info for section %s"),
			     bfd_archive_filename (abfd), newsect->name);
d645 2
a646 2
	      (_("%s: unknown [%d] section `%s' in group [%s]"),
	       bfd_archive_filename (abfd),
d1906 2
a1907 2
	     (_("%s: invalid link %lu for reloc section %s (index %u)"),
	      bfd_archive_filename (abfd), hdr->sh_link, name, shindex));
d2897 3
a2899 9
			    {
			      char *name = bfd_get_section_ident (s);
			      bed->link_order_error_handler
				(_("%s: warning: sh_link not set for section `%s'"),
				 bfd_archive_filename (abfd),
				 name ? name : s->name);
			      if (name)
				free (name);
			    }
d4787 2
a4788 2
	(_("%s: symbol `%s' required but not present"),
	 bfd_archive_filename (abfd), bfd_asymbol_name (asym_ptr));
d5075 2
a5076 2
	      (_("%s: warning: Empty loadable segment detected, is this intentional ?\n"),
	       bfd_archive_filename (ibfd));
d6499 2
a6500 2
    (_("%s: unsupported relocation type %s"),
     bfd_archive_filename (abfd), areloc->howto->name);
@


1.236
log
@2004-07-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 161/251
	* elf-bfd.h (bfd_elf_section_data): Add sec_group.
	(elf_sec_group): Defined.
	(bfd_elf_match_symbols_in_sections): New prototype.
	(_bfd_elf_setup_group_pointers): Likewise.

	* elf.c (bfd_elf_discard_group): Abort.
	(bfd_elf_set_group_contents): Also include relocation sections.
	Remove zero-fill for ld -r.
	(_bfd_elf_setup_group_pointers): New function.
	(elf_sort_elf_symbol): Likewise.
	(elf_sym_name_compare): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elfcode.h (elf_object_p): Call _bfd_elf_setup_group_pointers.

	* elflink.c (match_group_member): New.
	(elf_link_input_bfd): Check group member for discarded section.
	(try_match_symbols_in_sections): New function.
	(already_linked): Likewise.
	(_bfd_elf_section_already_linked): Support mixing comdat group
	and linkonce section.

	* libbfd-in.h (bfd_section_already_linked_table_traverse): New.
	* linker.c (bfd_section_already_linked_table_traverse): New.

	* libbfd.h: Regenerated.
@
text
@d2888 26
a2913 4
		      BFD_ASSERT (elfsec != 0);
		      s = elf_shdrp[elfsec]->bfd_section->output_section;
		      BFD_ASSERT (s != NULL);
		      d->this_hdr.sh_link = elf_section_data (s)->this_idx;
@


1.235
log
@bfd/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_section_data): Add a pointer for the
	linked-to section.
	(elf_linked_to_section): New.

	* elf.c (assign_section_numbers): Set up sh_link for
	SHF_LINK_ORDER.

	* elfxx-ia64.c (elfNN_ia64_final_write_processing): Set sh_info
	to sh_link for SHT_IA_64_UNWIND sections.

gas/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Set the linked-to
	section.
	(ia64_elf_section_change_hook): Set the linked-to section for
	SHT_IA_64_UNWIND.
@
text
@d616 42
d664 2
a665 1
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED, asection *group)
d667 1
d679 4
d2717 1
a2717 7
  /* With ld -r, merging SHT_GROUP sections results in wasted space
     due to allowing for the flag word on each input.  We may well
     duplicate entries too.  */
  while ((loc -= 4) > sec->contents)
    H_PUT_32 (abfd, 0, loc);

  if (loc != sec->contents)
d7806 209
@


1.234
log
@bfd/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (dynamic_lib_link_class): Add DYN_NO_ADD_NEEDED and
	DYN_NO_NEEDED.
	(bfd_elf_get_dyn_lib_class): New prototype.
	* elf.c (bfd_elf_get_dyn_lib_class): New function.

	* elflink.c (elf_link_add_object_symbols): Check DYN_AS_NEEDED,
	DYN_DT_NEEDED and DYN_NO_NEEDED bits to see if a DT_NEEDED
	entry is needed. Issue an error if a DT_NEEDED entry is needed
	for a file marked DYN_NO_NEEDED.
	(elf_link_check_versioned_symbol): Check the DYN_DT_NEEDED bit
	for DT_NEEDED tags.

	* bfd-in2.h: Regenerated.

ld/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): Also
	check the add_needed field.
	(dt_needed): New struct.
	(gld${EMULATION_NAME}_try_needed): Change the first argument
	to a pointer to struct dt_needed. Check the DYN_NO_ADD_NEEDED
	bit in the file where the DT_NEEDED entry comes from.
	(gld${EMULATION_NAME}_search_needed): Change the second
	argument to a pointer to struct dt_needed.
	(gld${EMULATION_NAME}_check_ld_so_conf): Updated.
	(gld${EMULATION_NAME}_after_open): Likewise.

	* ld.texinfo: Add --add-needed document.
	* ldlang.c (new_afile): Set p->add_needed.
	* ldlang.h (lang_input_statement_type): Add add_needed field.
	* ldmain.h (add_needed): Declare.
	* ldmain.c (add_needed): New global var.
	* lexsup.c (option_values): Add OPTION_ADD_NEEDED and
	OPTION_NO_ADD_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
@
text
@d2793 1
d2822 34
@


1.233
log
@* elf.c (assign_file_positions_for_segments): Make sure the .dynamic section
is the first section in the PT_DYNAMIC segment
@
text
@d1517 12
@


1.232
log
@	* bfd-in.h (struct stab_info): Move from stabs.c.
	* stabs.c (struct stab_link_includes_table): Delete.
	(stab_link_includes_lookup): Delete.
	(_bfd_write_section_stabs, _bfd_write_stab_strings): Remove one
	level of indirection from sinfo parm.
	(_bfd_link_section_stabs): Likewise.  Set SEC_LINKER_CREATED on
	stabstr section.  Adjust hash table accesses.
	* coff-ppc.c (ppc_bfd_coff_final_link): Do include rawsize in contents
	alloc.  Adjust stab_info test.
	* cofflink.c (_bfd_coff_link_hash_table_init): Clear stab_info.
	(_bfd_coff_final_link): Adjust stab_info test.
	(_bfd_coff_link_input_bfd): Ignore SEC_LINKER_CREATED sections.
	* elf-bfd.h (struct elf_link_hash_table): Include struct stab_info
	in place.
	* libcoff-in.h (struct coff_link_hash_table): Likewise.
	* elf.c (_bfd_elf_link_hash_table_init): Clear stab_info.
	* elflink.c (bfd_elf_final_link): Don't attempt to link linker created
	stabstr section.  Adjust stab_info test.
	* libbfd-in.h (_bfd_link_section_stabs, _bfd_write_section_stabs)
	(_bfd_write_stab_strings): Adjust prototypes.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3829 12
@


1.231
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1468 1
  table->stab_info = NULL;
d1470 1
@


1.230
log
@bfd/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_make_section_from_shdr): Undo the last
	change.

ld/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Clear
	SEC_EXCLUDE on non-SEC_DEBUGGING sections for relocatable link.
	* ldlang.c (lang_add_section): Likewise.
@
text
@d1033 1
a1033 4
      dynbuf = bfd_malloc (s->_raw_size);
      if (dynbuf == NULL)
	goto error_return;
      if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1045 1
a1045 1
      extdynend = extdyn + s->_raw_size;
d1584 1
a1584 1
  if (s == NULL || s->_raw_size == 0)
d1587 1
a1587 5
  dynbuf = bfd_malloc (s->_raw_size);
  if (dynbuf == NULL)
    goto error_return;

  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1600 1
a1600 1
  extdynend = extdyn + s->_raw_size;
d2232 1
a2232 1
  newsect->_raw_size = hdr->p_filesz;
d2265 1
a2265 1
      newsect->_raw_size = hdr->p_memsz - hdr->p_filesz;
d2403 1
a2403 1
  this_hdr->sh_size = asect->_raw_size;
d2535 1
a2535 1
      if (asect->_raw_size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
d2601 1
a2601 1
      sec->contents = bfd_alloc (abfd, sec->_raw_size);
d2612 1
a2612 1
  loc = sec->contents + sec->_raw_size;
d3419 1
a3419 1
	    last_size = hdr->_raw_size;
d3443 1
a3443 1
	last_size = hdr->_raw_size;
d3642 2
a3643 2
  size1 = (sec1->flags & SEC_LOAD) ? sec1->_raw_size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->_raw_size : 0;
d4023 1
a4023 1
		off += sec->_raw_size;
d4028 1
a4028 1
		voff += sec->_raw_size;
d4038 2
a4039 2
		  p->p_filesz = sec->_raw_size;
		  off += sec->_raw_size;
d4046 1
a4046 1
		  sec->_raw_size = 0;
d4057 1
a4057 1
	      p->p_memsz += sec->_raw_size;
d4060 1
a4060 1
		p->p_filesz += sec->_raw_size;
d4063 1
a4063 1
		  && sec->_raw_size == 0
d4733 1
a4733 1
   ? section->_raw_size : 0)
d4755 1
a4755 1
   && ((bfd_vma) s->filepos + s->_raw_size				\
d4767 1
a4767 1
   && s->_raw_size > 0							\
d4769 1
a4769 1
   && ((bfd_vma) s->filepos + s->_raw_size				\
d5167 1
a5167 1
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size,
d5170 1
a5170 1
			  || ((prev_sec->lma + prev_sec->_raw_size)
d5806 1
a5806 1
      ret += ((s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize)
d5849 1
a5849 1
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize;
d6451 1
a6451 1
  sect2->_raw_size = sect->_raw_size;
d6488 1
a6488 1
  sect->_raw_size = size;
d6507 1
a6507 1
  size_t raw_size;
d6514 1
a6514 1
      raw_size = sizeof (prstat.pr_reg);
d6540 1
a6540 1
      raw_size = sizeof (prstat.pr_reg);
d6570 1
a6570 1
					  raw_size, note->descpos + offset);
d6774 1
a6774 1
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.gregs);
d6780 1
a6780 1
  sect->_raw_size = sizeof (lwpstat.pr_reg);
d6804 1
a6804 1
  sect->_raw_size = sizeof (lwpstat.pr_context.uc_mcontext.fpregs);
d6810 1
a6810 1
  sect->_raw_size = sizeof (lwpstat.pr_fpreg);
d6859 1
a6859 1
      sect->_raw_size = sizeof (pstatus.data.thread_info.thread_context);
d6887 1
a6887 1
      sect->_raw_size = note->descsz;
d6963 1
a6963 1
	sect->_raw_size = note->descsz;
d7116 1
a7116 1
  sect->_raw_size       = note->descsz;
d7143 1
a7143 1
  sect->_raw_size       = note->descsz;
d7590 1
a7590 1
			 struct bfd_link_info *info,
a7593 3
  struct bfd_elf_section_data *sec_data;

  sec_data = elf_section_data (sec);
d7597 2
a7598 3
      return _bfd_stab_section_offset (abfd,
				       &elf_hash_table (info)->merge_info,
				       sec, &sec_data->sec_info, offset);
d7669 1
a7669 1
  count = relplt->_raw_size / hdr->sh_entsize;
@


1.229
log
@bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set SEC_EXCLUDE
	for SHT_GROUP sections.
ld/
	* ldlang.c (lang_add_section): Set SEC_EXCLUDE for SEC_GROUP
	sections when doing a final link.  Clear SEC_EXCLUDE when doing
	a relocable link, except for SEC_DEBUGGING sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Use the
	same condition here to drop SEC_EXCLUDE orphan sections.
@
text
@d680 1
a680 1
    flags |= SEC_GROUP;
@


1.228
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't set up merge
	section data here..
	* elf.c (_bfd_elf_merge_sections): .. Do it here instead.
	* merge.c: Formatting.  Remove unnecessary casts.  Expand
	bfd_get_section_alignment macro.
	(struct sec_merge_sec_info): Rename "first" to "first_str".  Update
	use throughout file.
	(_bfd_add_merge_section): Rename from _bfd_merge_section.  Update
	comment.  Abort on dynamic or non-SEC_MERGE input.  Don't test
	section name to determine sinfo group, instead test output section
	and alignment.
	(_bfd_merge_sections): Add struct bfd_link_info param.  Call
	_bfd_strip_section_from_output rather than just twiddling flags.
	* libbfd-in.h (_bfd_add_merge_section): Rename, update comment.
	(_bfd_merge_sections): Update prototype.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_process): Call bfd_merge_sections later, and
	only when not a relocatable link.
	(print_input_section): Handle SEC_EXCLUDE sections.
	(size_input_section): Don't update dot on SEC_EXCLUDE sections.
	(lang_do_assignments_1): Likewise.
	* ldwrite.c (build_link_order): Ignore SEC_EXCLUDE input sections.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/hppaelf.em (build_section_lists): Likewise.
	* emultempl/ppc64elf.em (build_toc_list): Likewise.
	(build_section_lists): Likewise.
@
text
@d680 1
a680 1
    flags |= SEC_GROUP | SEC_EXCLUDE;
@


1.227
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d904 3
d909 20
a928 2
  if (elf_hash_table (info)->merge_info)
    _bfd_merge_sections (abfd, elf_hash_table (info)->merge_info,
@


1.226
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d7540 12
a7551 3
				    sym->st_value + rel->r_addend,
				    0);
      sec = *psec;
d7571 1
a7571 1
				     sym->st_value + addend, 0);
@


1.225
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@a5292 18
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
	asection *s;

	/* Only set up the segments if there are no more SEC_ALLOC
	   sections.  FIXME: This won't do the right thing if objcopy is
	   used to remove the last SEC_ALLOC section, since objcopy
	   won't call this routine in that case.  */
	for (s = isec->next; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) != 0)
	    break;
	if (s == NULL)
	  {
	    if (! copy_private_bfd_data (ibfd, obfd))
	      return FALSE;
	  }
    }

d5311 23
@


1.224
log
@2004-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (bfd_section_from_shdr): Maintain the section order in
	a section group.
	(special_sections): Add ".note.GNU-stack".
	(elf_fake_sections): Handle section group for relocatable
	link..
@
text
@d977 1
d2304 3
d3554 15
d4103 31
d4218 6
@


1.223
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1954 2
d1957 1
a1957 1
	    if ((s = (++idx)->shdr->bfd_section) != NULL
d2065 1
d2398 25
a2422 1
      if ((asect->flags & SEC_ALLOC) != 0
@


1.222
log
@	* elf64-alpha.c (elf64_alpha_read_ecoff_info): Don't assign
	structure field removed in 2004-04-24 patch.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): Warning fix.

	* elf-bfd.h (struct elf_backend_data <elf_backend_section_flags>):
	Constify hdr arg.
	* elf32-arm.h (elf32_arm_section_flags): Likewise.
	* elf64-alpha.c (elf64_alpha_section_flags): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_flags): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set the bfd_section
	field before calling elf_backend_section_flags.
@
text
@d616 6
@


1.221
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d655 3
a802 3

  hdr->bfd_section = newsect;
  elf_section_data (newsect)->this_hdr = *hdr;
@


1.220
log
@	* elf.c (map_sections_to_segments): Fix handling of .tbss.
@
text
@d7516 76
@


1.219
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Delete dt_soname field.  Add
	dyn_lib_class field.  Rearrange for better packing.
	(elf_dt_soname): Delete.
	(elf_dyn_lib_class): Define.
	* elf.c (bfd_elf_set_dt_needed_name): Update comment.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): New function.
	* elflink.h (add_dt_needed_tag): New function.  Split out from..
	(elf_link_add_object_symbols): ..here.  Rename "name" to "soname".
	Use elf_dyn_lib_class to set dt_needed and add_needed.  Move fallback
	initialization of soname.
	(elf_link_check_versioned_symbol): Test elf_dyn_lib_class instead of
	elf_dt_soname.
	* bfd-in.h (enum dynamic_lib_link_class): New.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ld.texinfo: Add --as-needed doco.
	* ldmain.c (as_needed): New global var.
	* ldmain.h (as_needed): Declare.
	* lexsup.c (option_values): Add OPTION_AS_NEEDED and
	OPTION_NO_AS_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
	* ldlang.h (lang_input_statement_type): Add as_needed field.
	* ldlang.c (new_afile): Set p->as_needed.
	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): New function.
	(gld${EMULATION_NAME}_try_needed): Use bfd_elf_set_dyn_lib_class.
	(ld_${EMULATION_NAME}_emulation): Set LDEMUL_RECOGNIZED_FILE entry.

	* ldlang.c (open_input_bfds): Remove useless cast.
	(lang_do_assignments_1): Likewise.
	(lang_for_each_input_section): Delete.
@
text
@d3189 1
d3269 1
d3318 1
a3318 1
      else if (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
d3325 2
a3326 2
      else if ((last_hdr->flags & SEC_LOAD) == 0
	       && (hdr->flags & SEC_LOAD) != 0)
d3329 2
a3330 1
             nonloadable section in the same segment.  */
d3342 1
a3342 1
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
d3365 2
a3366 1
	  /* Ignore .tbss section for segment layout purposes.  */
d3368 3
a3370 1
	    last_hdr = hdr;
d3390 5
@


1.218
log
@	* elf.c (map_sections_to_segments): Ignore .tbss sections for
	layout purposes.

	* ldlang.c (lang_add_section): Don't force SEC_LOAD on
	SEC_THREAD_LOCAL.
	(IGNORE_SECTION): Ignore .tbss sections too.
	(lang_size_sections_1): .tbss sections do not advance dot.

	* ld-scripts/size.exp: New.
	* ld-scripts/size-[12].{d,s,t}: New.
@
text
@d1482 1
a1482 2
   entry for a dynamic object.  The generic linker passes name as an
   empty string to indicate that no DT_NEEDED entry should be made.  */
d1493 1
a1493 1
bfd_elf_set_dt_needed_soname (bfd *abfd, const char *name)
d1497 1
a1497 1
    elf_dt_soname (abfd) = name;
@


1.218.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d1482 2
a1483 1
   entry for a dynamic object.  */
d1494 1
a1494 1
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
d1498 1
a1498 1
    elf_dyn_lib_class (abfd) = lib_class;
@


1.217
log
@2004-02-13  Andrew Cagney  <cagney@@redhat.com>

	* elf.c	(vma_page_aligned_bias): New function.
	(assign_file_positions_except_relocs)
	(assign_file_positions_for_segments): Replace broken modulo
	arithmetic with call to vma_page_aligned_bias.
@
text
@d3363 3
a3365 1
	  last_hdr = hdr;
@


1.217.6.1
log
@Merge mainline to intercu branch.
@
text
@d1482 2
a1483 1
   entry for a dynamic object.  */
d1494 1
a1494 1
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
d1498 1
a1498 1
    elf_dyn_lib_class (abfd) = lib_class;
d3363 1
a3363 3
	  /* Ignore .tbss section for segment layout purposes.  */
	  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	    last_hdr = hdr;
@


1.217.6.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a3188 1
  bfd_vma last_size;
a3267 1
  last_size = 0;
d3316 1
a3316 1
      else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
d3323 2
a3324 2
      else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
	       && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
d3327 1
a3327 2
             nonloadable section in the same segment.
             Consider .tbss sections as loadable for this purpose.  */
d3339 1
a3339 1
	       && (((last_hdr->lma + last_size - 1)
d3362 1
a3362 2
	  last_hdr = hdr;
	  /* .tbss sections effectively have zero size.  */
d3364 1
a3364 3
	    last_size = hdr->_raw_size;
	  else
	    last_size = 0;
a3383 5
      /* .tbss sections effectively have zero size.  */
      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	last_size = hdr->_raw_size;
      else
	last_size = 0;
@


1.217.6.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d295 2
a296 2
	(_("%B: invalid string offset %u >= %lu for section `%s'"),
	 abfd, strindex, (unsigned long) hdr->sh_size,
d538 2
a539 1
			   (_("%B: invalid SHT_GROUP entry"), abfd));
d609 2
a610 2
      (*_bfd_error_handler) (_("%B: no group info for section %A"),
			     abfd, newsect);
d616 1
a616 1
_bfd_elf_setup_group_pointers (bfd *abfd)
a617 50
  unsigned int i;
  unsigned int num_group = elf_tdata (abfd)->num_group;
  bfd_boolean result = TRUE;

  if (num_group == (unsigned) -1)
    return result;

  for (i = 0; i < num_group; i++)
    {
      Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];
      Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;
      unsigned int n_elt = shdr->sh_size / 4;

      while (--n_elt != 0)
	if ((++idx)->shdr->bfd_section)
	  elf_sec_group (idx->shdr->bfd_section) = shdr->bfd_section;
	else if (idx->shdr->sh_type == SHT_RELA
		 || idx->shdr->sh_type == SHT_REL)
	  /* We won't include relocation sections in section groups in
	     output object files. We adjust the group section size here
	     so that relocatable link will work correctly when
	     relocation sections are in section group in input object
	     files.  */
	  shdr->bfd_section->size -= 4;
	else
	  {
	    /* There are some unknown sections in the group.  */
	    (*_bfd_error_handler)
	      (_("%B: unknown [%d] section `%s' in group [%s]"),
	       abfd,
	       (unsigned int) idx->shdr->sh_type,
	       elf_string_from_elf_strtab (abfd, idx->shdr->sh_name),
	       shdr->bfd_section->name);
	    result = FALSE;
	  }
    }
  return result;
}

bfd_boolean
bfd_elf_is_group_section (bfd *abfd ATTRIBUTE_UNUSED, const asection *sec)
{
  return elf_next_in_group (sec) != NULL;
}

bfd_boolean
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *group ATTRIBUTE_UNUSED)
{
#if 0
a628 4
#else
  /* FIXME: Never used. Remove it!  */
  abort ();
#endif
a654 3
  hdr->bfd_section = newsect;
  elf_section_data (newsect)->this_hdr = *hdr;

d801 3
a897 3
  bfd *ibfd;
  asection *sec;

d900 2
a901 20

  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    if ((ibfd->flags & DYNAMIC) == 0)
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if ((sec->flags & SEC_MERGE) != 0
	    && !bfd_is_abs_section (sec->output_section))
	  {
	    struct bfd_elf_section_data *secdata;

	    secdata = elf_section_data (sec);
	    if (! _bfd_add_merge_section (abfd,
					  &elf_hash_table (info)->merge_info,
					  sec, &secdata->sec_info))
	      return FALSE;
	    else if (secdata->sec_info)
	      sec->sec_info_type = ELF_INFO_TYPE_MERGE;
	  }

  if (elf_hash_table (info)->merge_info != NULL)
    _bfd_merge_sections (abfd, info, elf_hash_table (info)->merge_info,
a970 1
	    case PT_GNU_RELRO: pt = "RELRO"; break;
d1005 4
a1008 1
      if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
d1020 1
a1020 1
      extdynend = extdyn + s->size;
d1444 1
a1445 1
  memset (&table->stab_info, 0, sizeof (table->stab_info));
a1491 12
int
bfd_elf_get_dyn_lib_class (bfd *abfd)
{
  int lib_class;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    lib_class = elf_dyn_lib_class (abfd);
  else
    lib_class = 0;
  return lib_class;
}

d1559 1
a1559 1
  if (s == NULL || s->size == 0)
d1562 5
a1566 1
  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
d1579 1
a1579 1
  extdynend = extdyn + s->size;
d1826 2
a1827 2
	     (_("%B: invalid link %lu for reloc section %s (index %u)"),
	      abfd, hdr->sh_link, name, shindex));
a1947 2
	  /* We try to keep the same section order as it comes in.  */
	  idx += n_elt;
d1949 1
a1949 1
	    if ((s = (--idx)->shdr->bfd_section) != NULL
a2024 1
  { ".gnu.linkonce.b",15, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
a2056 1
  { ".note.GNU-stack",15,  0, SHT_PROGBITS, 0 },
d2208 1
a2208 1
  newsect->size = hdr->p_filesz;
d2241 1
a2241 1
      newsect->size = hdr->p_memsz - hdr->p_filesz;
a2293 3
    case PT_GNU_RELRO:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "relro");

d2376 1
a2376 1
  this_hdr->sh_size = asect->size;
d2389 1
a2389 25
      if ((asect->flags & SEC_GROUP) != 0)
	{
	  /* We also need to mark SHF_GROUP here for relocatable
	     link.  */
	  struct bfd_link_order *l;
	  asection *elt;

	  for (l = asect->link_order_head; l != NULL; l = l->next)
	    if (l->type == bfd_indirect_link_order
		&& (elt = elf_next_in_group (l->u.indirect.section)) != NULL)
	      do
		{
		  /* The name is not important. Anything will do.  */
		  elf_group_name (elt->output_section) = "G";
		  elf_section_flags (elt->output_section) |= SHF_GROUP;

		  elt = elf_next_in_group (elt);
		  /* During a relocatable link, the lists are
		     circular.  */
		}
	      while (elt != elf_next_in_group (l->u.indirect.section));

	  this_hdr->sh_type = SHT_GROUP;
	}
      else if ((asect->flags & SEC_ALLOC) != 0
d2484 1
a2484 1
      if (asect->size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
d2550 1
a2550 1
      sec->contents = bfd_alloc (abfd, sec->size);
d2561 1
a2561 1
  loc = sec->contents + sec->size;
d2606 7
a2612 1
  if ((loc -= 4) != sec->contents)
a2729 1

a2757 50
      /* We need to set up sh_link for SHF_LINK_ORDER.  */
      if ((d->this_hdr.sh_flags & SHF_LINK_ORDER) != 0)
	{
	  s = elf_linked_to_section (sec);
	  if (s)
	    d->this_hdr.sh_link = elf_section_data (s)->this_idx;
	  else
	    {
	      struct bfd_link_order *p;

	      /* Find out what the corresponding section in output
		 is.  */
	      for (p = sec->link_order_head; p != NULL; p = p->next)
		{
		  s = p->u.indirect.section;
		  if (p->type == bfd_indirect_link_order
		      && (bfd_get_flavour (s->owner)
			  == bfd_target_elf_flavour))
		    {
		      Elf_Internal_Shdr ** const elf_shdrp
			= elf_elfsections (s->owner);
		      int elfsec
			= _bfd_elf_section_from_bfd_section (s->owner, s);
		      elfsec = elf_shdrp[elfsec]->sh_link;
		      /* PR 290:
			 The Intel C compiler generates SHT_IA_64_UNWIND with
			 SHF_LINK_ORDER.  But it doesn't set theh sh_link or
			 sh_info fields.  Hence we could get the situation
		         where elfsec is 0.  */
		      if (elfsec == 0)
			{
			  const struct elf_backend_data *bed
			    = get_elf_backend_data (abfd);
			  if (bed->link_order_error_handler)
			    bed->link_order_error_handler
			      (_("%B: warning: sh_link not set for section `%S'"),
			       abfd, s);
			}
		      else
			{
			  s = elf_shdrp[elfsec]->bfd_section->output_section;
			  BFD_ASSERT (s != NULL);
			  d->this_hdr.sh_link = elf_section_data (s)->this_idx;
			}
		      break;
		    }
		}
	    }
	}

a3175 19
/* Create the PT_DYNAMIC segment, which includes DYNSEC.  Returns NULL
   on failure.  */

struct elf_segment_map *
_bfd_elf_make_dynamic_segment (bfd *abfd, asection *dynsec)
{
  struct elf_segment_map *m;

  m = bfd_zalloc (abfd, sizeof (struct elf_segment_map));
  if (m == NULL)
    return NULL;
  m->next = NULL;
  m->p_type = PT_DYNAMIC;
  m->count = 1;
  m->sections[0] = dynsec;
  
  return m;
}

d3368 1
a3368 1
	    last_size = hdr->size;
d3392 1
a3392 1
	last_size = hdr->size;
d3413 2
a3414 1
      m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
d3417 5
a3516 15
  if (elf_tdata (abfd)->relro)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_RELRO;
      m->p_flags = PF_R;
      m->p_flags_valid = 1;

      *pm = m;
      pm = &m->next;
    }

d3576 2
a3577 2
  size1 = (sec1->flags & SEC_LOAD) ? sec1->size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->size : 0;
a3762 12
      /* Make sure the .dynamic section is the first section in the
	 PT_DYNAMIC segment.  */
      else if (p->p_type == PT_DYNAMIC
	       && m->count > 1
	       && strcmp (m->sections[0]->name, ".dynamic") != 0)
	{
	  _bfd_error_handler
	    (_("%s: The first section in the PT_DYNAMIC segment is not the .dynamic section"),
	     bfd_get_filename (abfd));
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
d3957 1
a3957 1
		off += sec->size;
d3962 1
a3962 1
		voff += sec->size;
d3972 2
a3973 2
		  p->p_filesz = sec->size;
		  off += sec->size;
d3980 1
a3980 1
		  sec->size = 0;
d3991 1
a3991 1
	      p->p_memsz += sec->size;
d3994 1
a3994 1
		p->p_filesz += sec->size;
d3997 1
a3997 1
		  && sec->size == 0
a4034 16
	  /* If the section has not yet been assigned a file position,
	     do so now.  The ARM BPABI requires that .dynamic section
	     not be marked SEC_ALLOC because it is not part of any
	     PT_LOAD segment, so it will not be processed above.  */
	  if (p->p_type == PT_DYNAMIC && m->sections[0]->filepos == 0)
	    {
	      unsigned int i;
	      Elf_Internal_Shdr ** const i_shdrpp = elf_elfsections (abfd);

	      i = 1;
	      while (i_shdrpp[i]->bfd_section != m->sections[0])
		++i;
	      off = (_bfd_elf_assign_file_position_for_section 
		     (i_shdrpp[i], off, TRUE));
	      p->p_filesz = m->sections[0]->size;
	    }
a4050 31
	  else if (p->p_type == PT_GNU_RELRO)
	    {
	      Elf_Internal_Phdr *lp;

	      for (lp = phdrs; lp < phdrs + count; ++lp)
		{
		  if (lp->p_type == PT_LOAD
		      && lp->p_vaddr <= link_info->relro_end
		      && lp->p_vaddr >= link_info->relro_start
		      && lp->p_vaddr + lp->p_filesz
			 >= link_info->relro_end)
		    break;
		}

	      if (lp < phdrs + count
		  && link_info->relro_end > lp->p_vaddr)
		{
		  p->p_vaddr = lp->p_vaddr;
		  p->p_paddr = lp->p_paddr;
		  p->p_offset = lp->p_offset;
		  p->p_filesz = link_info->relro_end - lp->p_vaddr;
		  p->p_memsz = p->p_filesz;
		  p->p_align = 1;
		  p->p_flags = (lp->p_flags & ~PF_W);
		}
	      else
		{
		  memset (p, 0, sizeof *p);
		  p->p_type = PT_NULL;
		}
	    }
a4137 6
  if (elf_tdata (abfd)->relro)
    {
      /* We need a PT_GNU_RELRO segment.  */
      ++segs;
    }

d4177 4
a4180 7
   Reloc sections come in two flavours: Those processed specially as
   "side-channel" data attached to a section to which they apply, and
   those that bfd doesn't process as relocations.  The latter sort are
   stored in a normal bfd section by bfd_section_from_shdr.   We don't
   consider the former sort here, unless they form part of the loadable
   image.  Reloc sections not assigned here will be handled later by
   assign_file_positions_for_relocs.
d4212 2
a4213 2
	  if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
	       && hdr->bfd_section == NULL)
d4268 2
a4269 2
	  else if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
		    && hdr->bfd_section == NULL)
d4568 2
a4569 2
	(_("%B: symbol `%s' required but not present"),
	 abfd, bfd_asymbol_name (asym_ptr));
d4630 1
a4630 1
   ? section->size : 0)
d4652 1
a4652 1
   && ((bfd_vma) s->filepos + s->size				\
d4664 1
a4664 1
   && s->size > 0							\
d4666 1
a4666 1
   && ((bfd_vma) s->filepos + s->size				\
d4856 2
a4857 2
	      (_("%B: warning: Empty loadable segment detected, is this intentional ?\n"),
	       ibfd);
d5064 1
a5064 1
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->size,
d5067 1
a5067 1
			  || ((prev_sec->lma + prev_sec->size)
d5204 18
a5243 23
/* Copy private header information.  */

bfd_boolean
_bfd_elf_copy_private_header_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  */
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
      if (! copy_private_bfd_data (ibfd, obfd))
	return FALSE;
    }

  return TRUE;
}

d5698 1
a5698 1
      ret += ((s->size / elf_section_data (s)->this_hdr.sh_entsize)
d5741 1
a5741 1
	  count = s->size / elf_section_data (s)->this_hdr.sh_entsize;
d6275 2
a6276 2
    (_("%B: unsupported relocation type %s"),
     abfd, areloc->howto->name);
d6343 1
a6343 1
  sect2->size = sect->size;
d6380 1
a6380 1
  sect->size = size;
d6399 1
a6399 1
  size_t size;
d6406 1
a6406 1
      size = sizeof (prstat.pr_reg);
d6432 1
a6432 1
      size = sizeof (prstat.pr_reg);
d6462 1
a6462 1
					  size, note->descpos + offset);
d6666 1
a6666 1
  sect->size = sizeof (lwpstat.pr_context.uc_mcontext.gregs);
d6672 1
a6672 1
  sect->size = sizeof (lwpstat.pr_reg);
d6696 1
a6696 1
  sect->size = sizeof (lwpstat.pr_context.uc_mcontext.fpregs);
d6702 1
a6702 1
  sect->size = sizeof (lwpstat.pr_fpreg);
d6751 1
a6751 1
      sect->size = sizeof (pstatus.data.thread_info.thread_context);
d6779 1
a6779 1
      sect->size = note->descsz;
d6855 1
a6855 1
	sect->size = note->descsz;
d7008 1
a7008 1
  sect->size            = note->descsz;
d7035 1
a7035 1
  sect->size            = note->descsz;
d7446 3
a7448 12
				    sym->st_value + rel->r_addend);
      if (sec != *psec)
	{
	  /* If we have changed the section, and our original section is
	     marked with SEC_EXCLUDE, it means that the original
	     SEC_MERGE section has been completely subsumed in some
	     other SEC_MERGE section.  In this case, we need to leave
	     some info around for --emit-relocs.  */
	  if ((sec->flags & SEC_EXCLUDE) != 0)
	    sec->kept_section = *psec;
	  sec = *psec;
	}
d7468 1
a7468 1
				     sym->st_value + addend);
d7473 1
a7473 1
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
d7477 3
d7483 3
a7485 2
      return _bfd_stab_section_offset (sec, elf_section_data (sec)->sec_info,
				       offset);
a7515 293

long
_bfd_elf_get_synthetic_symtab (bfd *abfd,
			       long symcount ATTRIBUTE_UNUSED,
			       asymbol **syms ATTRIBUTE_UNUSED,
			       long dynsymcount ATTRIBUTE_UNUSED,
			       asymbol **dynsyms,
			       asymbol **ret)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  asection *relplt;
  asymbol *s;
  const char *relplt_name;
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  arelent *p;
  long count, i, n;
  size_t size;
  Elf_Internal_Shdr *hdr;
  char *names;
  asection *plt;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  *ret = NULL;
  if (!bed->plt_sym_val)
    return 0;

  relplt_name = bed->relplt_name;
  if (relplt_name == NULL)
    relplt_name = bed->default_use_rela_p ? ".rela.plt" : ".rel.plt";
  relplt = bfd_get_section_by_name (abfd, relplt_name);
  if (relplt == NULL)
    return 0;

  hdr = &elf_section_data (relplt)->this_hdr;
  if (hdr->sh_link != elf_dynsymtab (abfd)
      || (hdr->sh_type != SHT_REL && hdr->sh_type != SHT_RELA))
    return 0;

  plt = bfd_get_section_by_name (abfd, ".plt");
  if (plt == NULL)
    return 0;

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
    return -1;

  count = relplt->size / hdr->sh_entsize;
  size = count * sizeof (asymbol);
  p = relplt->relocation;
  for (i = 0; i < count; i++, s++, p++)
    size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");

  s = *ret = bfd_malloc (size);
  if (s == NULL)
    return -1;

  names = (char *) (s + count);
  p = relplt->relocation;
  n = 0;
  for (i = 0; i < count; i++, s++, p++)
    {
      size_t len;
      bfd_vma addr;

      addr = bed->plt_sym_val (i, plt, p);
      if (addr == (bfd_vma) -1)
	continue;

      *s = **p->sym_ptr_ptr;
      s->section = plt;
      s->value = addr - plt->vma;
      s->name = names;
      len = strlen ((*p->sym_ptr_ptr)->name);
      memcpy (names, (*p->sym_ptr_ptr)->name, len);
      names += len;
      memcpy (names, "@@plt", sizeof ("@@plt"));
      names += sizeof ("@@plt");
      ++n;
    }

  return n;
}

/* Sort symbol by binding and section. We want to put definitions
   sorted by section at the beginning.  */

static int
elf_sort_elf_symbol (const void *arg1, const void *arg2)
{
  const Elf_Internal_Sym *s1;
  const Elf_Internal_Sym *s2;
  int shndx;

  /* Make sure that undefined symbols are at the end.  */
  s1 = (const Elf_Internal_Sym *) arg1;
  if (s1->st_shndx == SHN_UNDEF)
    return 1;
  s2 = (const Elf_Internal_Sym *) arg2;
  if (s2->st_shndx == SHN_UNDEF)
    return -1;

  /* Sorted by section index.  */
  shndx = s1->st_shndx - s2->st_shndx;
  if (shndx != 0)
    return shndx;

  /* Sorted by binding.  */
  return ELF_ST_BIND (s1->st_info)  - ELF_ST_BIND (s2->st_info);
}

struct elf_symbol
{
  Elf_Internal_Sym *sym;
  const char *name;
};

static int
elf_sym_name_compare (const void *arg1, const void *arg2)
{
  const struct elf_symbol *s1 = (const struct elf_symbol *) arg1;
  const struct elf_symbol *s2 = (const struct elf_symbol *) arg2;
  return strcmp (s1->name, s2->name);
}

/* Check if 2 sections define the same set of local and global
   symbols.  */

bfd_boolean
bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2)
{
  bfd *bfd1, *bfd2;
  const struct elf_backend_data *bed1, *bed2;
  Elf_Internal_Shdr *hdr1, *hdr2;
  bfd_size_type symcount1, symcount2;
  Elf_Internal_Sym *isymbuf1, *isymbuf2;
  Elf_Internal_Sym *isymstart1 = NULL, *isymstart2 = NULL, *isym;
  Elf_Internal_Sym *isymend;
  struct elf_symbol *symp, *symtable1 = NULL, *symtable2 = NULL;
  bfd_size_type count1, count2, i;
  int shndx1, shndx2;
  bfd_boolean result;

  bfd1 = sec1->owner;
  bfd2 = sec2->owner;

  /* If both are .gnu.linkonce sections, they have to have the same
     section name.  */
  if (strncmp (sec1->name, ".gnu.linkonce",
	       sizeof ".gnu.linkonce" - 1) == 0
      && strncmp (sec2->name, ".gnu.linkonce",
		  sizeof ".gnu.linkonce" - 1) == 0)
    return strcmp (sec1->name + sizeof ".gnu.linkonce",
		   sec2->name + sizeof ".gnu.linkonce") == 0;

  /* Both sections have to be in ELF.  */
  if (bfd_get_flavour (bfd1) != bfd_target_elf_flavour
      || bfd_get_flavour (bfd2) != bfd_target_elf_flavour)
    return FALSE;

  if (elf_section_type (sec1) != elf_section_type (sec2))
    return FALSE;

  if ((elf_section_flags (sec1) & SHF_GROUP) != 0
      && (elf_section_flags (sec2) & SHF_GROUP) != 0)
    {
      /* If both are members of section groups, they have to have the
	 same group name.  */
      if (strcmp (elf_group_name (sec1), elf_group_name (sec2)) != 0)
	return FALSE;
    }

  shndx1 = _bfd_elf_section_from_bfd_section (bfd1, sec1);
  shndx2 = _bfd_elf_section_from_bfd_section (bfd2, sec2);
  if (shndx1 == -1 || shndx2 == -1)
    return FALSE;

  bed1 = get_elf_backend_data (bfd1);
  bed2 = get_elf_backend_data (bfd2);
  hdr1 = &elf_tdata (bfd1)->symtab_hdr;
  symcount1 = hdr1->sh_size / bed1->s->sizeof_sym;
  hdr2 = &elf_tdata (bfd2)->symtab_hdr;
  symcount2 = hdr2->sh_size / bed2->s->sizeof_sym;

  if (symcount1 == 0 || symcount2 == 0)
    return FALSE;

  isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
				   NULL, NULL, NULL);
  isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
				   NULL, NULL, NULL);

  result = FALSE;
  if (isymbuf1 == NULL || isymbuf2 == NULL)
    goto done;

  /* Sort symbols by binding and section. Global definitions are at
     the beginning.  */
  qsort (isymbuf1, symcount1, sizeof (Elf_Internal_Sym),
	 elf_sort_elf_symbol);
  qsort (isymbuf2, symcount2, sizeof (Elf_Internal_Sym),
	 elf_sort_elf_symbol);

  /* Count definitions in the section.  */
  count1 = 0;
  for (isym = isymbuf1, isymend = isym + symcount1;
       isym < isymend; isym++)
    {
      if (isym->st_shndx == (unsigned int) shndx1)
	{
	  if (count1 == 0)
	    isymstart1 = isym;
	  count1++;
	}

      if (count1 && isym->st_shndx != (unsigned int) shndx1)
	break;
    }

  count2 = 0;
  for (isym = isymbuf2, isymend = isym + symcount2;
       isym < isymend; isym++)
    {
      if (isym->st_shndx == (unsigned int) shndx2)
	{
	  if (count2 == 0)
	    isymstart2 = isym;
	  count2++;
	}

      if (count2 && isym->st_shndx != (unsigned int) shndx2)
	break;
    }

  if (count1 == 0 || count2 == 0 || count1 != count2)
    goto done;

  symtable1 = bfd_malloc (count1 * sizeof (struct elf_symbol));
  symtable2 = bfd_malloc (count1 * sizeof (struct elf_symbol));

  if (symtable1 == NULL || symtable2 == NULL)
    goto done;

  symp = symtable1;
  for (isym = isymstart1, isymend = isym + count1;
       isym < isymend; isym++)
    {
      symp->sym = isym;
      symp->name = bfd_elf_string_from_elf_section (bfd1,
						    hdr1->sh_link,
						    isym->st_name);
      symp++;
    }
 
  symp = symtable2;
  for (isym = isymstart2, isymend = isym + count1;
       isym < isymend; isym++)
    {
      symp->sym = isym;
      symp->name = bfd_elf_string_from_elf_section (bfd2,
						    hdr2->sh_link,
						    isym->st_name);
      symp++;
    }
  
  /* Sort symbol by name.  */
  qsort (symtable1, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);
  qsort (symtable2, count1, sizeof (struct elf_symbol),
	 elf_sym_name_compare);

  for (i = 0; i < count1; i++)
    /* Two symbols must have the same binding, type and name.  */
    if (symtable1 [i].sym->st_info != symtable2 [i].sym->st_info
	|| symtable1 [i].sym->st_other != symtable2 [i].sym->st_other
	|| strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
      goto done;

  result = TRUE;

done:
  if (symtable1)
    free (symtable1);
  if (symtable2)
    free (symtable2);
  if (isymbuf1)
    free (isymbuf1);
  if (isymbuf2)
    free (isymbuf2);

  return result;
}
@


1.217.6.4
log
@Merge from mainline.
@
text
@d1394 12
a1405 3
      ret->got = ret->plt = htab->init_refcount;
      memset (&ret->size, 0, (sizeof (struct elf_link_hash_entry)
			      - offsetof (struct elf_link_hash_entry, size)));
d1410 1
a1410 1
      ret->non_elf = 1;
d1430 7
a1436 6
  dir->ref_dynamic |= ind->ref_dynamic;
  dir->ref_regular |= ind->ref_regular;
  dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
  dir->non_got_ref |= ind->non_got_ref;
  dir->needs_plt |= ind->needs_plt;
  dir->pointer_equality_needed |= ind->pointer_equality_needed;
d1478 1
a1478 1
  h->needs_plt = 0;
d1481 1
a1481 1
      h->forced_local = 1;
@


1.217.4.1
log
@	* elf.c (map_sections_to_segments): Ignore .tbss sections for
	layout purposes.

	* ldlang.c (lang_add_section): Don't force SEC_LOAD on
	SEC_THREAD_LOCAL.
	(IGNORE_SECTION): Ignore .tbss sections too.
	(lang_size_sections_1): .tbss sections do not advance dot.

	* ld-scripts/size.exp: New.
	* ld-scripts/size-[12].{d,s,t}: New.
@
text
@d3363 1
a3363 3
	  /* Ignore .tbss section for segment layout purposes.  */
	  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	    last_hdr = hdr;
@


1.217.4.2
log
@Merge from mainline
@
text
@d1482 2
a1483 1
   entry for a dynamic object.  */
d1494 1
a1494 1
bfd_elf_set_dyn_lib_class (bfd *abfd, int lib_class)
d1498 1
a1498 1
    elf_dyn_lib_class (abfd) = lib_class;
a3189 1
  bfd_vma last_size;
a3268 1
  last_size = 0;
d3317 1
a3317 1
      else if (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize)
d3324 2
a3325 2
      else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0
	       && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)
d3328 1
a3328 2
             nonloadable section in the same segment.
             Consider .tbss sections as loadable for this purpose.  */
d3340 1
a3340 1
	       && (((last_hdr->lma + last_size - 1)
d3363 1
a3363 2
	  last_hdr = hdr;
	  /* .tbss sections effectively have zero size.  */
d3365 1
a3365 3
	    last_size = hdr->_raw_size;
	  else
	    last_size = 0;
a3384 5
      /* .tbss sections effectively have zero size.  */
      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)
	last_size = hdr->_raw_size;
      else
	last_size = 0;
d4258 3
a4260 1
	  else if (hdr == i_shdrpp[tdata->symtab_section]
@


1.217.4.3
log
@	* elf.c (assign_file_positions_except_relocs): Revert unintended
	change from 2004-04-08.
@
text
@d4268 1
a4268 3
	  else if (hdr->sh_type == SHT_REL
		   || hdr->sh_type == SHT_RELA
		   || hdr == i_shdrpp[tdata->symtab_section]
@


1.217.4.4
log
@	Merge from mainline:
	2004-08-31  Eric Botcazou  <ebotcazou@@libertysurf.fr>
	* elf.c (special_sections): Add .gnu.linkonce.b modelled on .bss.

	2004-06-09  Alexandre Oliva  <aoliva@@redhat.com>
	* elflink.c (elf_sort_symbol): Compare section id, not pointers.
	(elf_link_add_object_symbols): Likewise.
@
text
@a2024 1
  { ".gnu.linkonce.b",15, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
@


1.216
log
@	* bfd-elf.h (elf_backend_name_local_section_symbols): New hook.
	* elf.c (swap_out_syms): Use it to decide whether local section
	symbols should be named.
	* elfxx-target.h (elf_backend_name_local_section_symbols): New macro.
	* elfxx-mips.h (_bfd_mips_elf_name_local_section_symbols): Declare.
	(elf_backend_name_local_section_symbols): Define.
	* elfxx-mips.c (_bfd_mips_elf_name_local_section_symbols): New.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d3575 29
d3731 2
a3732 1
	    off += (m->sections[0]->vma - off) % bed->maxpagesize;
d3747 2
a3748 1
	      off += (m->sections[0]->vma - off) % (1 << align);
d3910 2
a3911 1
		    adjust = (sec->vma - voff) % bed->maxpagesize;
d3913 2
a3914 1
		    adjust = (sec->vma - voff) % align;
d4248 2
a4249 1
		off += (hdr->sh_addr - off) % bed->maxpagesize;
d4251 2
a4252 1
		off += (hdr->sh_addr - off) % hdr->sh_addralign;
@


1.215
log
@(INCLUDE_SECTION_IN_SEGMENT): Skip PT_GNU_STACK segments.
@
text
@d5264 1
d5330 4
d5343 2
a5344 1
      if ((flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
@


1.215.2.1
log
@Index: bfd/ChangeLog
2004-01-21  Andrew Cagney  <cagney@@redhat.com>

	* bfdio.c: Update copyright.  Include "bfdio.h".
	(real_ftell, real_fseek): New functions.
	(bfd_tell): Use real_ftell, change return-type to file_ptr.
	(bfd_seek): Use real_ftell and real_fseek.  Change type of
	file_position to a file_ptr.
	* cache.c: Update copyright.  Include "bfdio.h".
	(close_one): Use real_ftell.
	(bfd_cache_lookup_worker): Use real_fseek, use ufile_ptr in cast.
	* bfd-in.h: Update copyright.
	(file_ptr, ufile_ptr): Specify type using @@BFD_FILE_PTR@@.
	(bfd_tell): Make return-type "file_ptr".
	* bfd-in2.h: Re-generate.
	* configure.in (AC_CHECK_FUNCS): Check for ftello, ftello64,
	fseeko and fseeko64.
	* config.in, configure: Re-generate.
	* libbfd-in.h: Update copyright.
	(real_ftell, real_fseek): Declare.
	* libbfd.h: Re-generate.
	* elf.c (offset_vma_page_alignment): New function.
	(assign_file_positions_for_segments): Replace broken modulo code
	with offset_vma_page_alignment.
	(assign_file_positions_except_relocs): Ditto.

Index: gdb/testsuite/ChangeLog
2004-01-22  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/bigcore.exp: New file.
	* gdb.base/bigcore.c: New file.
@
text
@a3573 28
/* Ian Lance Taylor writes:

   We shouldn't be using % with a negative signed number.  That's just
   not good.  We have to make sure either that the number is not
   negative, or that the number has an unsigned type.  When the types
   are all the same size they wind up as unsigned.  When file_ptr is a
   larger signed type, the arithmetic winds up as signed long long,
   which is wrong.

   What we're trying to say here is something like ``increase OFF by
   the least amount that will cause it to be equal to the VMA modulo
   the page size.''  */
/* In other words, something like:

   vma_offset = m->sections[0]->vma % bed->maxpagesize;
   off_offset = off % bed->maxpagesize;
   if (vma_offset < off_offset)
     adjustment = vma_offset + bed->maxpagesize - off_offset;
   else
     adjustment = vma_offset - off_offset;
     
   this can be colapsed into the expression below.  */
static file_ptr
offset_vma_page_adjustment (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
{
  return ((vma - off) % maxpagesize);
}

d3701 1
a3701 2
	    off += offset_vma_page_adjustment (m->sections[0]->vma, off,
					       bed->maxpagesize);
d3716 1
a3716 2
	      off += offset_vma_page_adjustment (m->sections[0]->vma, off,
						 1 << align);
d3878 1
a3878 2
		    adjust = offset_vma_page_adjustment (sec->vma, voff,
							 bed->maxpagesize);
d3880 1
a3880 2
		    adjust = offset_vma_page_adjustment (sec->vma, voff,
							 align);
d4214 1
a4214 2
		off += offset_vma_page_adjustment (hdr->sh_addr, off,
						   bed->maxpagesize);
d4216 1
a4216 2
		off += offset_vma_page_adjustment (hdr->sh_addr, off,
						   hdr->sh_addralign);
@


1.214
log
@	* elf-bfd.h (is_elf_hash_table): Take hash tab rather than info arg.
	* elf.c (_bfd_elf_merge_sections): Adjust to suit.
	(_bfd_elf_link_just_syms): Likewise.
	(bfd_elf_get_needed_list): Likewise.
	(bfd_elf_get_runpath_list): Likewise.
	(_bfd_elf_link_hash_copy_indirect): Remove unneeded parens.
	* elf32-hppa.c (elf32_hppa_setup_section_lists): Don't check hash tab
	creator flavour.
	(elf32_hppa_set_gp): Look up output sections rather than using htab.
	* elf32-i960.c: Comment fix.  Formatting.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Use is_elf_hash_table
	rather than testing creator flavour.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Adjust for
	is_elf_hash_table change.  Remove redundant test.
	(bfd_elf_record_link_assignment): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_link_record_local_dynamic_symbol): Adjust for is_elf_hash_table.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.  Remove redundant
	checks.  Use is_elf_hash_table rather than testing creator flavour.
	Use hash_table throughout in place of info->hash.
	(elf_add_dynamic_entry): Adjust for is_elf_hash_table change.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.  Remove redundant
	check.
	(elf_bfd_final_link): Adjust for is_elf_hash_table change.
	(elf_link_check_versioned_symbol): Use is_elf_hash_table rather than
	testing creator flavour.
	(elf_gc_sections): Add is_elf_hash_table check.
	(elf_gc_common_finalize_got_offsets): Likewise.
	(elf_bfd_discard_info): Adjust for is_elf_hash_table change.  Remove
	redundant check.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use is_elf_hash_table
	rather than testing creator flavour.
@
text
@d4628 3
a4630 2
       5. PT_TLS segment includes only SHF_TLS sections.
       6. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
d4638 1
@


1.213
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d897 1
a897 1
  if (!is_elf_hash_table (info))
d910 1
a910 1
  if (!is_elf_hash_table (info))
d1358 6
a1363 6
    |= (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				    | ELF_LINK_HASH_REF_REGULAR
				    | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				    | ELF_LINK_NON_GOT_REF
				    | ELF_LINK_HASH_NEEDS_PLT
				    | ELF_LINK_POINTER_EQUALITY_NEEDED));
d1507 1
a1507 1
  if (! is_elf_hash_table (info))
d1519 1
a1519 1
  if (! is_elf_hash_table (info))
@


1.212
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d4680 1
a4680 1
		 assigment code will work.  */
@


1.211
log
@* elf.c (elfcore_grok_netbsd_procinfo): Make a pseudosection out
of the note.
@
text
@d44 1
a44 1
static bfd_boolean assign_file_positions_except_relocs (bfd *);
d3106 1
a3106 1
  if (!assign_file_positions_except_relocs (abfd))
d3579 1
a3579 1
assign_file_positions_for_segments (bfd *abfd)
d3631 1
a3631 1
      if (! (*bed->elf_backend_modify_segment_map) (abfd))
d4139 2
a4140 1
assign_file_positions_except_relocs (bfd *abfd)
d4191 1
a4191 1
      if (! assign_file_positions_for_segments (abfd))
@


1.210
log
@2003-11-22  Jakub Jelinek  <jakub@@redhat.com>

	* elf-bfd.h (ELF_LINK_POINTER_EQUALITY_NEEDED): Define new flag.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy it.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	(elf_i386_check_relocs): Set it.
	(elf_i386_finish_dynamic_symbol): If it is not set,
	clear st_value of SHN_UNDEF symbol.
@
text
@d6838 2
a6839 1
  return TRUE;
@


1.209
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d1362 2
a1363 1
				    | ELF_LINK_HASH_NEEDS_PLT));
@


1.208
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1357 6
a1362 6
  dir->elf_link_hash_flags |=
    (ind->elf_link_hash_flags
     & (ELF_LINK_HASH_REF_DYNAMIC
	| ELF_LINK_HASH_REF_REGULAR
	| ELF_LINK_HASH_REF_REGULAR_NONWEAK
	| ELF_LINK_NON_GOT_REF));
@


1.207
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d7371 1
a7371 1
			 asection *sec,
d7374 1
a7383 3
      asection *msec;

      msec = sec;
d7385 1
a7385 1
	_bfd_merged_section_offset (abfd, &msec,
d7388 4
a7391 3
				    0)
	- relocation;
      rel->r_addend += msec->output_section->vma + msec->output_offset;
@


1.206
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d6099 1
a6099 1
			       void *location,
@


1.205
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d1447 2
a1448 1
  table->tls_segment = NULL;
@


1.204
log
@	* elf.c (_bfd_elfcore_make_pseudosection): Allow multiple
	sections with the same name.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_grok_note): Likewise.
	(elfcore_grok_nto_status): Likewise.
	(elfcore_grok_nto_gregs): Likewise.
@
text
@d6242 1
a6242 1
   struct symbol_cache_entry *symbol ATTRIBUTE_UNUSED,
@


1.203
log
@2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* targets.c: Replace "struct sec" with "struct bfd_section"
	* syms.c, sparclynx.c, section.c, opncls.c: Ditto.
	* libcoff-in.h, libbfd-in.h, elfxx-target.h: Ditto.
	* elf.c, coffgen.c, bfd.c, bfd-in.h, aoutf1.h: Ditto.
	* aout-tic30.c, aout-target.h:
	* bfd-in2.h, libcoff.h, libbfd.h: Regenerate.

Index: binutils/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* coffgrok.h (coff_section): Replace 'struct sec" with "struct
	bfd_section".

Index: gdb/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* symtab.c: Replace "struct sec" with "struct bfd_section".
	* objfiles.c, linespec.c, blockframe.c, block.c: Ditto.

Index: ld/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* pe-dll.c: Replace "struct sec" with "struct bfd_section".

Index: sim/common/ChangeLog
2003-10-19  Andrew Cagney  <cagney@@redhat.com>

	* sim-base.h: Replace "struct sec" with "struct bfd_section".
@
text
@d6318 1
a6318 1
  sect = bfd_make_section (abfd, threaded_name);
d6602 1
a6602 1
  sect = bfd_make_section (abfd, name);
d6632 1
a6632 1
  sect = bfd_make_section (abfd, name);
d6688 1
a6688 1
      sect = bfd_make_section (abfd, name);
d6715 1
a6715 1
      sect = bfd_make_section (abfd, name);
d6792 1
a6792 1
	asection *sect = bfd_make_section (abfd, ".auxv");
d6944 1
a6944 1
  sect = bfd_make_section (abfd, name);
d6971 1
a6971 1
  sect = bfd_make_section (abfd, name);
@


1.202
log
@2003-10-07  Roland McGrath  <roland@@redhat.com>

	* elf.c (_bfd_elf_make_section_from_phdr): Set alignment_power of
	new section from p_align header field.
@
text
@d4435 1
a4435 1
_bfd_elf_section_from_bfd_section (bfd *abfd, struct sec *asect)
@


1.201
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d2209 1
@


1.200
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@d5594 1
a5594 1
_bfd_elf_get_symtab (bfd *abfd, asymbol **allocation)
@


1.199
log
@	* elf.c (elfcore_write_note): Don't use sizeof(Elf_External_note)
	since some ABIs round up the size of the struct.
@
text
@d2022 38
a2059 76
  { ".bss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".comment",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".data",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".data1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".debug",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".fini",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".line",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".rodata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".rodata1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".tbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",	0,	NULL,	0,
    SHT_INIT_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".fini_array",	0,	NULL,	0,
    SHT_FINI_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".preinit_array",	0,	NULL,	0,
    SHT_PREINIT_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".debug_line",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_info",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_abbrev",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_aranges",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".dynamic",		0,	NULL,	0,
    SHT_DYNAMIC,	SHF_ALLOC },
  { ".dynstr",		0,	NULL,	0,
    SHT_STRTAB,		SHF_ALLOC },
  { ".dynsym",		0,	NULL,	0,
    SHT_DYNSYM,		SHF_ALLOC },
  { ".got",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".hash",		0,	NULL,	0,
    SHT_HASH,		SHF_ALLOC },
  { ".interp",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".plt",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",	0,	NULL,	0,
    SHT_STRTAB,		0 },
  { ".strtab",		0,	NULL,	0,
    SHT_STRTAB,		0 },
  { ".symtab",		0,	NULL,	0,
    SHT_SYMTAB,		0 },
  { ".gnu.version",	0,	NULL,	0,
    SHT_GNU_versym,	0 },
  { ".gnu.version_d",	0,	NULL,	0,
    SHT_GNU_verdef,	0 },
  { ".gnu.version_r",	0,	NULL,	0,
    SHT_GNU_verneed,	0 },
  { ".note",		5,	NULL,	0,
    SHT_NOTE,		0 },
  { ".rela",		5,	NULL,	0,
    SHT_RELA,		0 },
  { ".rel",		4,	NULL,	0,
    SHT_REL,		0 },
  { ".stab",		5,	"str",	3,
    SHT_STRTAB,		0 },
  { NULL,		0,	NULL,	0,
    0,		 0 }
d2068 1
d2071 31
a2101 9
    if (((special_sections[i].prefix_length
	  && strncmp (name, special_sections[i].prefix,
		      special_sections[i].prefix_length) == 0
	  && (! special_sections[i].suffix_length
	      || strcmp ((name + strlen (name)
			  - special_sections[i].suffix_length),
			 special_sections[i].suffix) == 0))
	 || strcmp (name, special_sections[i].prefix) == 0)
	&& (rela || special_sections[i].type != SHT_RELA))
d2103 1
d2108 2
a2109 2
bfd_boolean
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name, int *type, int *attr)
a2110 1
  bfd_boolean found = FALSE;
d2112 1
a2116 1
      const struct bfd_elf_special_section *ssect = NULL;
a2123 7

      if (ssect)
	{
	  *type = ssect->type;
	  *attr = ssect->attributes;
	  found = TRUE;
	}
d2126 1
a2126 1
  return found;
d2133 1
a2133 1
  int type, attr;
d2145 2
a2146 2
  if (sec->name && _bfd_elf_get_sec_type_attr (abfd, sec->name,
					       &type, &attr))
d2148 2
a2149 2
      elf_section_type (sec) = type;
      elf_section_flags (sec) = attr;
@


1.198
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2433 1
a2433 1
  
d7069 1
a7069 1
  newspace = sizeof (Elf_External_Note) - 1 + namesz + pad + size;
@


1.198.6.1
log
@* elf.c (elfcore_grok_note): Allow multiple .auxv sections.
@
text
@d6813 1
a6813 1
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");
@


1.197
log
@	* elfcode.h: Convert to C90, remove unneeded casts and prototypes.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf.c (sym_is_global): Remove INLINE.
	(align_file_position): Replace INLINE with inline.
	* elfcode.h (elf_swap_dyn_in, elf_swap_dyn_out): Remove INLINE.
	(elf_file_p): Replace INLINE with inline.
@
text
@d328 1
a328 1
  struct elf_backend_data *bed;
d641 1
a641 1
  struct elf_backend_data *bed;
d1196 1
a1196 1
	struct elf_backend_data *bed;
d1347 1
a1347 1
_bfd_elf_link_hash_copy_indirect (struct elf_backend_data *bed,
d1652 1
a1652 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2126 1
a2126 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2132 1
a2132 1
      unsigned int rela = get_elf_backend_data (abfd)->default_use_rela_p;
d2277 1
a2277 1
  struct elf_backend_data *bed;
d2335 1
a2335 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2365 1
a2365 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2875 1
a2875 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3069 1
a3069 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4062 1
a4062 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4165 1
a4165 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4272 1
a4272 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4317 2
a4318 5
      if (get_elf_backend_data (abfd) != NULL)
	i_ehdrp->e_machine = get_elf_backend_data (abfd)->elf_machine_code;
      else
	i_ehdrp->e_machine = EM_NONE;
      }
d4396 1
a4396 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4458 1
a4458 1
  struct elf_backend_data *bed;
d4574 1
a4574 1
  struct elf_backend_data *bed;
d5269 1
a5269 1
  struct elf_backend_data *bed;
d5601 1
a5601 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5618 1
a5618 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5630 1
a5630 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6758 1
a6758 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d7062 1
a7062 1
      struct elf_backend_data *bed;
@


1.196
log
@	* elf.c (bfd_section_from_r_symndx): Test for SHN_UNDEF.
	* elf64-ppc.c (get_fdh): New function, split out from
	ppc64_elf_edit_opd.
	(ppc64_elf_check_relocs): Use get_fdh.
	(func_desc_adjust): Likewise.  Tidy.
	(ppc64_elf_edit_opd): Tighten reloc checks.  Free local_syms on error
	exit.  Use get_fdh.  Account for superfluous dynamic relocs.
	(ppc64_elf_relocate_section): Warning fix.
@
text
@d2871 1
a2871 1
static INLINE int
d3031 1
a3031 1
static INLINE file_ptr
@


1.195
log
@	* elf.c: Convert to C90, remove unnecessary prototypes and casts.
	Replace PTR with void *.  Formatting.
	(_bfd_elf_assign_file_position_for_section): Remove INLINE.
	(make_mapping): Likewise.
@
text
@d1998 2
a1999 1
  if (isym.st_shndx < SHN_LORESERVE || isym.st_shndx > SHN_HIRESERVE)
@


1.194
log
@	* elf.c (special_sections): Set attributes for .got and .plt.
@
text
@d43 5
a47 63
static INLINE struct elf_segment_map *make_mapping
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, bfd_boolean));
static bfd_boolean map_sections_to_segments
  PARAMS ((bfd *));
static int elf_sort_sections
  PARAMS ((const PTR, const PTR));
static bfd_boolean assign_file_positions_for_segments
  PARAMS ((bfd *));
static bfd_boolean assign_file_positions_except_relocs
  PARAMS ((bfd *));
static bfd_boolean prep_headers
  PARAMS ((bfd *));
static bfd_boolean swap_out_syms
  PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static bfd_boolean copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static char *elf_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static const char *group_signature
  PARAMS ((bfd *, Elf_Internal_Shdr *));
static bfd_boolean setup_group
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void merge_sections_remove_hook
  PARAMS ((bfd *, asection *));
static void elf_fake_sections
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean assign_section_numbers
  PARAMS ((bfd *));
static INLINE int sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean elf_map_symbols
  PARAMS ((bfd *));
static bfd_size_type get_program_header_size
  PARAMS ((bfd *));
static bfd_boolean elfcore_read_notes
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean elf_find_function
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **));
static int elfcore_make_pid
  PARAMS ((bfd *));
static bfd_boolean elfcore_maybe_make_sect
  PARAMS ((bfd *, char *, asection *));
static bfd_boolean elfcore_make_note_pseudosection
  PARAMS ((bfd *, char *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prxfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_netbsd_get_lwpid
  PARAMS ((Elf_Internal_Note *, int *));
static bfd_boolean elfcore_grok_netbsd_procinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_netbsd_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_nto_gregs
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t));
static bfd_boolean elfcore_grok_nto_status
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t *));
static bfd_boolean elfcore_grok_nto_note
  PARAMS ((bfd *, Elf_Internal_Note *));
d56 3
a58 4
_bfd_elf_swap_verdef_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdef *src;
     Elf_Internal_Verdef *dst;
d72 3
a74 4
_bfd_elf_swap_verdef_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdef *src;
     Elf_External_Verdef *dst;
d88 3
a90 4
_bfd_elf_swap_verdaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verdaux *src;
     Elf_Internal_Verdaux *dst;
d99 3
a101 4
_bfd_elf_swap_verdaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verdaux *src;
     Elf_External_Verdaux *dst;
d110 3
a112 4
_bfd_elf_swap_verneed_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Verneed *src;
     Elf_Internal_Verneed *dst;
d124 3
a126 4
_bfd_elf_swap_verneed_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Verneed *src;
     Elf_External_Verneed *dst;
d138 3
a140 4
_bfd_elf_swap_vernaux_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Vernaux *src;
     Elf_Internal_Vernaux *dst;
d152 3
a154 4
_bfd_elf_swap_vernaux_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Vernaux *src;
     Elf_External_Vernaux *dst;
d166 3
a168 4
_bfd_elf_swap_versym_in (abfd, src, dst)
     bfd *abfd;
     const Elf_External_Versym *src;
     Elf_Internal_Versym *dst;
d176 3
a178 4
_bfd_elf_swap_versym_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Versym *src;
     Elf_External_Versym *dst;
d187 1
a187 2
bfd_elf_hash (namearg)
     const char *namearg;
d213 1
a213 4
elf_read (abfd, offset, size)
     bfd *abfd;
     file_ptr offset;
     bfd_size_type size;
d221 1
a221 1
  if (bfd_bread ((PTR) buf, size, abfd) != size)
d231 1
a231 2
bfd_elf_mkobject (abfd)
     bfd *abfd;
d235 1
a235 2
  bfd_size_type amt = sizeof (struct elf_obj_tdata);
  elf_tdata (abfd) = (struct elf_obj_tdata *) bfd_zalloc (abfd, amt);
d245 1
a245 2
bfd_elf_mkcorefile (abfd)
     bfd *abfd;
d252 1
a252 3
bfd_elf_get_str_section (abfd, shindex)
     bfd *abfd;
     unsigned int shindex;
d270 1
a270 1
      i_shdrp[shindex]->contents = (PTR) shstrtab;
d276 3
a278 4
bfd_elf_string_from_elf_section (abfd, shindex, strindex)
     bfd *abfd;
     unsigned int shindex;
     unsigned int strindex;
d313 7
a319 9
bfd_elf_get_elf_syms (ibfd, symtab_hdr, symcount, symoffset,
		      intsym_buf, extsym_buf, extshndx_buf)
     bfd *ibfd;
     Elf_Internal_Shdr *symtab_hdr;
     size_t symcount;
     size_t symoffset;
     Elf_Internal_Sym *intsym_buf;
     PTR extsym_buf;
     Elf_External_Sym_Shndx *extshndx_buf;
d322 1
a322 1
  PTR alloc_ext;
d369 1
a369 1
	  alloc_extshndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
d384 1
a384 1
      intsym_buf = (Elf_Internal_Sym *) bfd_malloc (amt);
d394 1
a394 1
    (*bed->s->swap_symbol_in) (ibfd, esym, (const PTR) shndx, isym);
d407 1
a407 3
bfd_elf_local_sym_name (abfd, isym)
     bfd *abfd;
     Elf_Internal_Sym *isym;
d433 1
a433 3
group_signature (abfd, ghdr)
     bfd *abfd;
     Elf_Internal_Shdr *ghdr;
d456 1
a456 4
setup_group (abfd, hdr, newsect)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     asection *newsect;
d615 1
a615 3
bfd_elf_discard_group (abfd, group)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *group;
d635 3
a637 4
_bfd_elf_make_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d822 1
a822 3
bfd_elf_find_section (abfd, name)
     bfd *abfd;
     char *name;
d862 7
a868 14
bfd_elf_generic_reloc (abfd,
		       reloc_entry,
		       symbol,
		       data,
		       input_section,
		       output_bfd,
		       error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d870 1
a870 1
  if (output_bfd != (bfd *) NULL
d885 2
a886 3
merge_sections_remove_hook (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d895 1
a895 3
_bfd_elf_merge_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d906 1
a906 3
_bfd_elf_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info;
d920 1
a920 3
_bfd_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d939 1
a939 3
_bfd_elf_print_private_bfd_data (abfd, farg)
     bfd *abfd;
     PTR farg;
d941 1
a941 1
  FILE *f = (FILE *) farg;
d1000 1
a1000 1
      void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1004 1
a1004 1
      dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
d1007 1
a1007 2
      if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				      s->_raw_size))
d1027 1
a1027 1
	  (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);
d1176 4
a1179 5
bfd_elf_print_symbol (abfd, filep, symbol, how)
     bfd *abfd;
     PTR filep;
     asymbol *symbol;
     bfd_print_symbol_type how;
d1181 1
a1181 1
  FILE *file = (FILE *) filep;
d1209 1
a1209 1
	    bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d1298 3
a1300 4
_bfd_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d1347 3
a1349 3
_bfd_elf_link_hash_copy_indirect (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d1399 3
a1401 4
_bfd_elf_link_hash_hide_symbol (info, h, force_local)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     bfd_boolean force_local;
d1420 6
a1425 6
_bfd_elf_link_hash_table_init (table, abfd, newfunc)
     struct elf_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d1459 1
a1459 2
_bfd_elf_link_hash_table_create (abfd)
     bfd *abfd;
d1464 2
a1465 2
  ret = (struct elf_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_link_hash_table *) NULL)
d1483 1
a1483 3
bfd_elf_set_dt_needed_name (abfd, name)
     bfd *abfd;
     const char *name;
d1491 1
a1491 3
bfd_elf_set_dt_needed_soname (abfd, name)
     bfd *abfd;
     const char *name;
d1502 2
a1503 3
bfd_elf_get_needed_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1514 2
a1515 3
bfd_elf_get_runpath_list (abfd, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1527 1
a1527 2
bfd_elf_get_dt_soname (abfd)
     bfd *abfd;
d1539 2
a1540 3
bfd_elf_get_bfd_needed_list (abfd, pneeded)
     bfd *abfd;
     struct bfd_link_needed_list **pneeded;
d1548 1
a1548 1
  void (*swap_dyn_in) PARAMS ((bfd *, const PTR, Elf_Internal_Dyn *));
d1560 1
a1560 1
  dynbuf = (bfd_byte *) bfd_malloc (s->_raw_size);
d1564 1
a1564 2
  if (! bfd_get_section_contents (abfd, s, (PTR) dynbuf, (file_ptr) 0,
				  s->_raw_size))
d1582 1
a1582 1
      (*swap_dyn_in) (abfd, (PTR) extdyn, &dyn);
d1599 1
a1599 1
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
d1623 1
a1623 1
_bfd_elf_stringtab_init ()
d1648 1
a1648 3
bfd_section_from_shdr (abfd, shindex)
     bfd *abfd;
     unsigned int shindex;
d1888 1
a1888 1
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
d1972 4
a1975 5
bfd_section_from_r_symndx (abfd, cache, sec, r_symndx)
     bfd *abfd;
     struct sym_sec_cache *cache;
     asection *sec;
     unsigned long r_symndx;
d2012 1
a2012 3
bfd_section_from_elf_index (abfd, index)
     bfd *abfd;
     unsigned int index;
d2122 1
a2122 2
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name,
			    int *type, int *attr)
d2151 1
a2151 3
_bfd_elf_new_section_hook (abfd, sec)
     bfd *abfd;
     asection *sec;
d2159 1
a2159 2
      bfd_size_type amt = sizeof (*sdata);
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, amt);
d2162 1
a2162 1
      sec->used_by_bfd = (PTR) sdata;
d2202 4
a2205 5
_bfd_elf_make_section_from_phdr (abfd, hdr, index, typename)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
     int index;
     const char *typename;
d2218 1
a2218 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d2250 1
a2250 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d2274 1
a2274 4
bfd_section_from_phdr (abfd, hdr, index)
     bfd *abfd;
     Elf_Internal_Phdr *hdr;
     int index;
d2295 1
a2295 1
      if (! elfcore_read_notes (abfd, (file_ptr) hdr->p_offset, hdr->p_filesz))
d2328 4
a2331 5
_bfd_elf_init_reloc_shdr (abfd, rel_hdr, asect, use_rela_p)
     bfd *abfd;
     Elf_Internal_Shdr *rel_hdr;
     asection *asect;
     bfd_boolean use_rela_p;
d2362 1
a2362 4
elf_fake_sections (abfd, asect, failedptrarg)
     bfd *abfd;
     asection *asect;
     PTR failedptrarg;
d2365 1
a2365 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2535 1
a2535 4
bfd_elf_set_group_contents (abfd, sec, failedptrarg)
     bfd *abfd;
     asection *sec;
     PTR failedptrarg;
d2537 1
a2537 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2641 1
a2641 2
assign_section_numbers (abfd)
     bfd *abfd;
d2722 1
a2722 1
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
d2727 1
a2727 1
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d2813 1
a2813 1
	      alc = (char *) bfd_malloc ((bfd_size_type) (len - 2));
d2871 1
a2871 3
sym_is_global (abfd, sym)
     bfd *abfd;
     asymbol *sym;
d2874 3
a2876 3
  if (get_elf_backend_data (abfd)->elf_backend_sym_is_global)
    return ((*get_elf_backend_data (abfd)->elf_backend_sym_is_global)
	    (abfd, sym));
d2884 1
a2884 2
elf_map_symbols (abfd)
     bfd *abfd;
d2912 1
a2912 1
  sect_syms = (asymbol **) bfd_zalloc (abfd, amt);
d2986 1
a2986 1
  new_syms = (asymbol **) bfd_alloc (abfd, amt);
a3029 2
static INLINE file_ptr align_file_position
  PARAMS ((file_ptr, int));
d3031 1
a3031 3
align_file_position (off, align)
     file_ptr off;
     int align;
d3039 4
a3042 5
INLINE file_ptr
_bfd_elf_assign_file_position_for_section (i_shdrp, offset, align)
     Elf_Internal_Shdr *i_shdrp;
     file_ptr offset;
     bfd_boolean align;
d3065 2
a3066 3
_bfd_elf_compute_section_file_positions (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info;
d3161 6
a3166 7
static INLINE struct elf_segment_map *
make_mapping (abfd, sections, from, to, phdr)
     bfd *abfd;
     asection **sections;
     unsigned int from;
     unsigned int to;
     bfd_boolean phdr;
d3175 1
a3175 1
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3197 1
a3197 2
map_sections_to_segments (abfd)
     bfd *abfd;
d3226 1
a3226 1
  sections = (asection **) bfd_malloc (amt);
d3256 1
a3256 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3270 1
a3270 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3419 1
a3419 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3442 1
a3442 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3468 1
a3468 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3495 1
a3495 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3510 1
a3510 1
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
d3537 1
a3537 3
elf_sort_sections (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d3597 1
a3597 2
assign_file_positions_for_segments (abfd)
     bfd *abfd;
d3681 1
a3681 1
  phdrs = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);
d4057 1
a4057 2
get_program_header_size (abfd)
     bfd *abfd;
d4157 1
a4157 2
assign_file_positions_except_relocs (abfd)
     bfd *abfd;
d4265 1
a4265 2
prep_headers (abfd)
     bfd *abfd;
d4373 1
a4373 2
_bfd_elf_assign_file_positions_for_relocs (abfd)
     bfd *abfd;
d4396 1
a4396 2
_bfd_elf_write_object_contents (abfd)
     bfd *abfd;
d4405 1
a4405 2
      && ! _bfd_elf_compute_section_file_positions
             (abfd, (struct bfd_link_info *) NULL))
d4449 1
a4449 2
_bfd_elf_write_corefile_contents (abfd)
     bfd *abfd;
d4458 1
a4458 3
_bfd_elf_section_from_bfd_section (abfd, asect)
     bfd *abfd;
     struct sec *asect;
d4507 1
a4507 3
_bfd_elf_symbol_from_bfd_symbol (abfd, asym_ptr_ptr)
     bfd *abfd;
     asymbol **asym_ptr_ptr;
d4562 1
a4562 3
copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d4786 1
a4786 1
      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d4867 1
a4867 1
      sections = (asection **) bfd_malloc (amt);
d5069 1
a5069 1
	      map = (struct elf_segment_map *) bfd_alloc (obfd, amt);
d5163 4
a5166 5
_bfd_elf_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
d5227 4
a5230 5
_bfd_elf_copy_private_symbol_data (ibfd, isymarg, obfd, osymarg)
     bfd *ibfd;
     asymbol *isymarg;
     bfd *obfd;
     asymbol *osymarg;
d5267 3
a5269 4
swap_out_syms (abfd, sttp, relocatable_p)
     bfd *abfd;
     struct bfd_strtab_hash **sttp;
     int relocatable_p;
d5310 1
a5310 1
  symtab_hdr->contents = (PTR) outbound_syms;
d5551 1
a5551 2
_bfd_elf_get_symtab_upper_bound (abfd)
     bfd *abfd;
d5566 1
a5566 2
_bfd_elf_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
d5587 2
a5588 3
_bfd_elf_get_reloc_upper_bound (abfd, asect)
     bfd *abfd ATTRIBUTE_UNUSED;
     sec_ptr asect;
d5596 4
a5599 5
_bfd_elf_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d5618 1
a5618 3
_bfd_elf_get_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d5621 1
a5621 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, FALSE);
d5629 2
a5630 3
_bfd_elf_canonicalize_dynamic_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d5633 1
a5633 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, TRUE);
d5646 1
a5646 2
_bfd_elf_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d5678 3
a5680 4
_bfd_elf_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d5682 1
a5682 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d5721 1
a5721 2
_bfd_elf_slurp_version_tables (abfd)
     bfd *abfd;
d5738 1
a5738 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d5742 1
a5742 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d5762 1
a5762 1
      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *) bfd_zalloc (abfd, amt);
d5784 1
a5784 1
	  iverdef->vd_auxptr = (Elf_Internal_Verdaux *) bfd_alloc (abfd, amt);
d5835 1
a5835 2
      elf_tdata (abfd)->verref =
	(Elf_Internal_Verneed *) bfd_zalloc (abfd, amt);
d5841 1
a5841 1
      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
d5845 1
a5845 1
	  || bfd_bread ((PTR) contents, hdr->sh_size, abfd) != hdr->sh_size)
d5868 1
a5868 1
	  iverneed->vn_auxptr = (Elf_Internal_Vernaux *) bfd_alloc (abfd, amt);
d5914 1
a5914 2
_bfd_elf_make_empty_symbol (abfd)
     bfd *abfd;
d5919 1
a5919 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, amt);
d5930 3
a5932 4
_bfd_elf_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d5942 2
a5943 3
_bfd_elf_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d5967 2
a5968 3
_bfd_elf_get_lineno (ignore_abfd, symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
d5975 3
a5977 4
_bfd_elf_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d5993 6
a5998 8
elf_find_function (abfd, section, symbols, offset,
		   filename_ptr, functionname_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
d6053 7
a6059 9
_bfd_elf_find_nearest_line (abfd, section, symbols, offset,
			    filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d6108 1
a6108 3
_bfd_elf_sizeof_headers (abfd, reloc)
     bfd *abfd;
     bfd_boolean reloc;
d6119 5
a6123 6
_bfd_elf_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d6129 1
a6129 2
      && ! (_bfd_elf_compute_section_file_positions
	    (abfd, (struct bfd_link_info *) NULL)))
d6142 3
a6144 4
_bfd_elf_no_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d6152 1
a6152 3
_bfd_elf_validate_reloc (abfd, areloc)
     bfd *abfd;
     arelent *areloc;
d6246 1
a6246 2
_bfd_elf_close_and_cleanup (abfd)
     bfd *abfd;
d6263 5
a6267 8
_bfd_elf_rel_vtable_reloc_fn (abfd, re, symbol, data, is, obfd, errmsg)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *re ATTRIBUTE_UNUSED;
     struct symbol_cache_entry *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *is ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     char **errmsg ATTRIBUTE_UNUSED;
d6284 1
a6284 2
elfcore_make_pid (abfd)
     bfd *abfd;
d6296 1
a6296 4
elfcore_maybe_make_sect (abfd, name, sect)
     bfd *abfd;
     char *name;
     asection *sect;
d6322 4
a6325 5
_bfd_elfcore_make_pseudosection (abfd, name, size, filepos)
     bfd *abfd;
     char *name;
     size_t size;
     ufile_ptr filepos;
d6336 1
a6336 1
  threaded_name = bfd_alloc (abfd, (bfd_size_type) len);
a6358 2
static bfd_boolean elfcore_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d6361 1
a6361 3
elfcore_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6432 3
a6434 4
elfcore_make_note_pseudosection (abfd, name, note)
     bfd *abfd;
     char *name;
     Elf_Internal_Note *note;
d6445 1
a6445 3
elfcore_grok_prfpreg (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6455 1
a6455 3
elfcore_grok_prxfpreg (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6479 1
a6479 4
_bfd_elfcore_strndup (abfd, start, max)
     bfd *abfd;
     char *start;
     size_t max;
d6490 1
a6490 1
  dups = bfd_alloc (abfd, (bfd_size_type) len + 1);
a6500 3
static bfd_boolean elfcore_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));

d6502 1
a6502 3
elfcore_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
a6559 3
static bfd_boolean elfcore_grok_pstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

d6561 1
a6561 3
elfcore_grok_pstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
a6594 3
static bfd_boolean elfcore_grok_lwpstatus
  PARAMS ((bfd *, Elf_Internal_Note *));

d6596 1
a6596 3
elfcore_grok_lwpstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6620 1
a6620 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6650 1
a6650 1
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6679 1
a6679 3
elfcore_grok_win32pstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6705 1
a6705 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6732 1
a6732 1
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6758 1
a6758 3
elfcore_grok_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6830 1
a6830 3
elfcore_netbsd_get_lwpid (note, lwpidp)
     Elf_Internal_Note *note;
     int *lwpidp;
d6844 1
a6844 3
elfcore_grok_netbsd_procinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6863 1
a6863 3
elfcore_grok_netbsd_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d6928 1
a6928 4
elfcore_grok_nto_status (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t *tid;
d6962 1
a6962 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6980 1
a6980 4
elfcore_grok_nto_gregs (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t tid;
d6989 1
a6989 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d7016 1
a7016 3
elfcore_grok_nto_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d7046 7
a7052 8
elfcore_write_note (abfd, buf, bufsiz, name, type, input, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *name;
     int  type;
     const PTR input;
     int  size;
d7097 5
a7101 6
elfcore_write_prpsinfo (abfd, buf, bufsiz, fname, psargs)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const char *fname;
     const char *psargs;
d7124 6
a7129 7
elfcore_write_prstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7145 6
a7150 7
elfcore_write_lwpstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7176 6
a7181 7
elfcore_write_pstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     const PTR gregs;
d7195 5
a7199 6
elfcore_write_prfpreg (abfd, buf, bufsiz, fpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR fpregs;
     int size;
d7207 5
a7211 6
elfcore_write_prxfpreg (abfd, buf, bufsiz, xfpregs, size)
     bfd  *abfd;
     char *buf;
     int  *bufsiz;
     const PTR xfpregs;
     int size;
d7219 1
a7219 4
elfcore_read_notes (abfd, offset, size)
     bfd *abfd;
     file_ptr offset;
     bfd_size_type size;
d7287 1
a7287 2
bfd_get_elf_phdr_upper_bound (abfd)
     bfd *abfd;
d7307 1
a7307 3
bfd_get_elf_phdrs (abfd, phdrs)
     bfd *abfd;
     void *phdrs;
d7325 1
a7325 4
_bfd_elf_sprintf_vma (abfd, buf, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     char *buf;
     bfd_vma value;
d7353 1
a7353 4
_bfd_elf_fprintf_vma (abfd, stream, value)
     bfd *abfd ATTRIBUTE_UNUSED;
     PTR stream;
     bfd_vma value;
d7382 1
a7382 2
_bfd_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED;
d7391 4
a7394 5
_bfd_elf_rela_local_sym (abfd, sym, sec, rel)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection *sec;
     Elf_Internal_Rela *rel;
d7412 1
a7412 1
				    (bfd_vma) 0)
d7420 4
a7423 5
_bfd_elf_rel_local_sym (abfd, sym, psec, addend)
     bfd *abfd;
     Elf_Internal_Sym *sym;
     asection **psec;
     bfd_vma addend;
d7432 1
a7432 1
				     sym->st_value + addend, (bfd_vma) 0);
d7436 4
a7439 5
_bfd_elf_section_offset (abfd, info, sec, offset)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     bfd_vma offset;
d7471 5
a7475 5
bfd_elf_bfd_from_remote_memory (templ, ehdr_vma, loadbasep, target_read_memory)
     bfd *templ;
     bfd_vma ehdr_vma;
     bfd_vma *loadbasep;
     int (*target_read_memory) PARAMS ((bfd_vma vma, char *myaddr, int len));
@


1.193
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_new_section_hook): Set the default section
	type to SHT_NULL.
	(elf_fake_sections): Set the section type based on asect->flags
	if it is SHT_NULL. Don't abort on processor specific section
	types.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Update
	elf_section_type and elf_section_flags only when they are
	specified.
@
text
@d2177 1
a2177 1
    SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
d2179 1
a2179 1
    SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
d2195 1
a2195 1
    SHT_PROGBITS,	0 },
d2201 1
a2201 1
    SHT_PROGBITS,	0 },
d2219 1
a2219 1
    SHT_REL,	0 },
d2223 1
a2223 1
    0,		0 }
@


1.192
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d2296 1
a2296 6
  if ((sec->flags & SEC_ALLOC) != 0
      && (((sec->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	  || (sec->flags & SEC_NEVER_LOAD) != 0))
    elf_section_type (sec) = SHT_NOBITS;
  else
    elf_section_type (sec) = SHT_PROGBITS;
d2542 12
a2556 5
      (*_bfd_error_handler)
       (_("%s: Section `%s' has unknown type 0x%0x"),
	bfd_get_filename (asect->owner), asect->name,
	this_hdr->sh_type);
      abort ();
@


1.191
log
@	* elf-bfd.h (struct elf_link_hash_entry): Remove linker_section_pointer
	field.
	(enum elf_linker_section_enum): Delete.
	(struct elf_linker_section): Delete.
	(struct elf_linker_section_pointers): Delete.
	(struct elf_obj_tdata): Remove #if 0 chunk.  Remove linker_section.
	Make linker_section_pointers a void**.
	(elf_local_ptr_offsets, elf_linker_section): Don't define.
	* elf32-ppc.c (enum elf_linker_section_enum): New, cut-down version
	of old item in elf-bfd.h.
	(struct elf_linker_section): Likewise.
	(struct elf_linker_section_pointers): Likewise.
	(elf_local_ptr_offsets): Define.
	(struct ppc_elf_link_hash_entry): Add linker_section_pointer.
	(ppc_elf_link_hash_newfunc): Init it.
	(struct ppc_elf_link_hash_table): Add sbss.
	(ppc_elf_link_hash_table_create): zmalloc rather than clearing
	individual fields.
	(elf_create_linker_section): Fold into..
	(ppc_elf_create_linker_section): ..here.  Remove hole_size code.
	Make rela section here if shared.
	(elf_find_pointer_linker_section): Pass lsect rather than enum.
	(elf_create_pointer_linker_section): Adjust.  zalloc rather than
	clearing in a loop.
	(elf_finish_pointer_linker_section): Adjust.  Don't make rela
	section here.
	(ppc_elf_check_relocs): Adjust.
	(ppc_elf_add_symbol_hook): Tighten hash creator test.  Remove code
	creating .sbss by hand.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust.
@
text
@d744 4
d2146 132
d2284 1
d2296 13
d2547 1
a2547 4
  /* FIXME: This should not be based on section names.  */
  if (strcmp (asect->name, ".dynstr") == 0)
    this_hdr->sh_type = SHT_STRTAB;
  else if (strcmp (asect->name, ".hash") == 0)
d2549 18
a2566 1
      this_hdr->sh_type = SHT_HASH;
d2568 3
a2570 4
    }
  else if (strcmp (asect->name, ".dynsym") == 0)
    {
      this_hdr->sh_type = SHT_DYNSYM;
d2572 3
a2574 4
    }
  else if (strcmp (asect->name, ".dynamic") == 0)
    {
      this_hdr->sh_type = SHT_DYNAMIC;
d2576 13
a2588 27
    }
  else if (strncmp (asect->name, ".rela", 5) == 0
	   && get_elf_backend_data (abfd)->may_use_rela_p)
    {
      this_hdr->sh_type = SHT_RELA;
      this_hdr->sh_entsize = bed->s->sizeof_rela;
    }
  else if (strncmp (asect->name, ".rel", 4) == 0
	   && get_elf_backend_data (abfd)->may_use_rel_p)
    {
      this_hdr->sh_type = SHT_REL;
      this_hdr->sh_entsize = bed->s->sizeof_rel;
    }
  else if (strcmp (asect->name, ".init_array") == 0)
    this_hdr->sh_type = SHT_INIT_ARRAY;
  else if (strcmp (asect->name, ".fini_array") == 0)
    this_hdr->sh_type = SHT_FINI_ARRAY;
  else if (strcmp (asect->name, ".preinit_array") == 0)
    this_hdr->sh_type = SHT_PREINIT_ARRAY;
  else if (strncmp (asect->name, ".note", 5) == 0)
    this_hdr->sh_type = SHT_NOTE;
  else if (strncmp (asect->name, ".stab", 5) == 0
	   && strcmp (asect->name + strlen (asect->name) - 3, "str") == 0)
    this_hdr->sh_type = SHT_STRTAB;
  else if (strcmp (asect->name, ".gnu.version") == 0)
    {
      this_hdr->sh_type = SHT_GNU_versym;
d2590 3
a2592 4
    }
  else if (strcmp (asect->name, ".gnu.version_d") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verdef;
d2602 3
a2604 4
    }
  else if (strcmp (asect->name, ".gnu.version_r") == 0)
    {
      this_hdr->sh_type = SHT_GNU_verneed;
d2614 3
a2616 4
    }
  else if ((asect->flags & SEC_GROUP) != 0)
    {
      this_hdr->sh_type = SHT_GROUP;
d2618 1
a2619 6
  else if ((asect->flags & SEC_ALLOC) != 0
	   && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	       || (asect->flags & SEC_NEVER_LOAD) != 0))
    this_hdr->sh_type = SHT_NOBITS;
  else
    this_hdr->sh_type = SHT_PROGBITS;
@


1.190
log
@Correct spelling of "relocatable".
@
text
@a1430 1
      ret->linker_section_pointer = NULL;
@


1.189
log
@binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_STACK.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_STACK.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Create PT_GNU_STACK segment header.
	(get_program_header_size): Count with PT_GNU_STACK.
	* elf-bfd.h (struct elf_obj_tdata): Add stack_flags.
	* elflink.h (bfd_elfNN_size_dynamic_sections): Set stack_flags.
include/
	* bfdlink.h (struct bfd_link_info): Add execstack and noexecstack.
	* elf/common.h (PT_GNU_STACK): Define.
ld/
	* ldgram.y (phdr_type): Grok PT_GNU_STACK.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z execstack and -z noexecstack.
	(gld${EMULATION_NAME}_list_options): Likewise.
	* scripttempl/elf.sc: If not -r, discard .note.GNU-stack section.
@
text
@d939 1
a939 1
/* ELF relocs are against symbols.  If we are producing relocateable
d947 1
a947 1
   relocateable output against an external symbol.  */
d1841 1
a1841 1
         set in a relocateable object file, which would confuse the
@


1.188
log
@	* elf.c (elfcore_grok_nto_status): Only set lwpid for the active or
	signalled thread.
	(elfcore_grok_nto_gregs): Only make .reg section for the active thread.
@
text
@d1073 1
d2300 3
d3520 15
d4118 6
@


1.187
log
@USe is_elf_hash_table() to check for the presence of an elf_link_hash_table
@
text
@d7018 2
d7024 5
a7028 2
  /* nto_procfs_status 'tid' field is at offset 4.  */
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);
d7031 11
a7041 4
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, (bfd_byte *) ddata + 14);

  /* Pass tid back.  */
  *tid = elf_tdata (abfd)->core_lwpid;
d7090 5
a7094 1
  return elfcore_maybe_make_sect (abfd, ".reg", sect);
@


1.186
log
@2003-05-19  Roland McGrath  <roland@@redhat.com>

	* elf.c (bfd_elf_bfd_from_remote_memory): New function.
	* bfd-in.h: Declare it.
	* elfcode.h (NAME(_bfd_elf,bfd_from_remote_memory)): New function.
	* elf-bfd.h (struct elf_backend_data): New function pointer member
	elf_backend_bfd_from_remote_memory.
	(_bfd_elf32_bfd_from_remote_memory, _bfd_elf64_bfd_from_remote_memory):
	Declare them.
	* elfxx-target.h (elf_backend_bfd_from_remote_memory): New macro.
	(elfNN_bed): Add that to the initializer.
2003-05-15  Roland McGrath  <roland@@redhat.com>

	* elf.c (elfcore_grok_note): Grok NT_AUXV note, make ".auxv" section.
@
text
@d1619 1
a1619 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
d1632 1
a1632 1
  if (info->hash->creator->flavour != bfd_target_elf_flavour)
@


1.185
log
@2003-05-13  Andrew Haley  <aph@@redhat.com>

        * elf.c (bfd_elf_hash): Mask lower 32 bits of hash.
@
text
@d6887 14
d7551 24
@


1.184
log
@	* elf.c (elf_fake_sections): Use correct cast for sh_name.
@
text
@d274 1
a274 1
  return h;
@


1.183
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d2368 3
a2370 3
  this_hdr->sh_name = (unsigned long) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							   asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned long) -1)
@


1.182
log
@2003-04-24  Roland McGrath  <roland@@redhat.com>

	* elf.c (bfd_section_from_phdr): Map PT_GNU_EH_FRAME to "eh_frame_hdr".
@
text
@d2338 1
a2338 1
  rel_hdr->sh_addralign = bed->s->file_align;
d3751 1
a3751 1
	p->p_align = bed->s->file_align;
d4248 1
a4248 1
  off = align_file_position (off, bed->s->file_align);
d5305 1
a5305 1
  symtab_hdr->sh_addralign = bed->s->file_align;
d7128 1
a7128 1
      pad = -namesz & (bed->s->file_align - 1);
@


1.182.2.1
log
@	* cpu-arm.c (arm_check_note): Warning fix.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Warning fixes.  Arrange
	to keep relocs if edited.
	(iq2000_elf_print_private_bfd_data): Return TRUE.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Use ELFNN_R_SYM, not
	ELF64_R_SYM.
	(elfNN_ia64_relax_ldxmov): Warning fix.
	* xtensa-isa.c (xtensa_add_isa): Warning fix.
	* xtensa-modules.c (get_num_opcodes): Warning fix.
	* elf.c (elf_fake_sections): Use correct cast for sh_name.
@
text
@d2368 3
a2370 3
  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
@


1.182.2.2
log
@2003-05-13  Andrew Haley  <aph@@redhat.com>

        * elf.c (bfd_elf_hash): Mask lower 32 bits of hash.
@
text
@d274 1
a274 1
  return h & 0xffffffff;
@


1.182.2.3
log
@	* elf.c (bfd_elf_get_needed_list): Use is_elf_hash_table to check
	the type of the has table in the bfd_link_info structure.
	(bfd_elf_get_runpath_list): Likewise.
@
text
@d1619 1
a1619 1
  if (! is_elf_hash_table (info))
d1632 1
a1632 1
  if (! is_elf_hash_table (info))
@


1.181
log
@Fix memory leaks
@
text
@d2295 4
d4785 1
a4785 1
 
d5465 1
a5465 1
		      bfd_set_error (bfd_error_invalid_operation);      
d5469 1
a5469 1
  
d7078 1
a7078 1
     tid from the previous call to pass down to the next gregs 
@


1.181.6.1
log
@Merge from mainline.
@
text
@a2294 4
    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "eh_frame_hdr");

d4781 1
a4781 1

d5461 1
a5461 1
		      bfd_set_error (bfd_error_invalid_operation);
d5465 1
a5465 1

d7074 1
a7074 1
     tid from the previous call to pass down to the next gregs
@


1.181.6.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d274 1
a274 1
  return h & 0xffffffff;
d2338 1
a2338 1
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
d2368 3
a2370 3
  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
d3751 1
a3751 1
	p->p_align = 1 << bed->s->log_file_align;
d4248 1
a4248 1
  off = align_file_position (off, 1 << bed->s->log_file_align);
d5305 1
a5305 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d7128 1
a7128 1
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
@


1.180
log
@Add support for QNX style core files.
@
text
@d5071 4
a5074 1
		return FALSE;
d5309 4
a5312 1
    return FALSE;
d5322 5
a5326 1
	return FALSE;
d5370 4
a5373 1
	    return FALSE;
d5462 1
d5923 1
a5923 1
  if (contents == NULL)
@


1.179
log
@SEGMENT_OVERLAPS: Check that LMAs overlap as well.
@
text
@d100 6
d3551 1
a3551 1
#define TOEND(x) (((x)->flags & (SEC_LOAD|SEC_THREAD_LOCAL)) == 0)
d6976 98
d7313 5
@


1.178
log
@Generate an error message if a section cannot be found for a symbol.
@
text
@d4659 2
a4660 2
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)				\
  (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))
d4662 6
a4667 1
  /* Returns TRUE iff seg1 and seg2 overlap.  */
d4669 4
a4672 2
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2)					\
     || SEGMENT_AFTER_SEGMENT (seg2, seg1)))
d4770 3
a4772 2
      section_count = 0;
      for (section = ibfd->sections; section != NULL; section = section->next)
d4775 3
a4777 3

      /* Allocate a segment map big enough to contain all of the
	 sections we have selected.  */
d4849 1
a4849 1
	 4. The sections have been moved, but not be the same amount.
d5093 2
a5094 4
    {
      for (map = map_first; map != NULL; map = map->next)
	map->p_paddr_valid = 0;
    }
@


1.177
log
@	* elf-bfd.h (struct got_entry, struct plt_entry): Forward declare.
	(struct elf_link_hash_entry): Add "glist" and "plist" fields to
	"got" union, and declare as gotplt_union.  Use gotplt_uinion for
	"plt" field.
	(struct elf_link_hash_table): Make "init_refcount" a gotplt_union.
	Add "init_offset" field.
	(struct elf_obj_tdata <local_got>): Add "struct got_entry **" to union.
	(elf_local_got_ents): Declare.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust initialization of "got"
	and "plt".
	(_bfd_elf_link_hash_hide_symbol): Use "init_offset".
	(_bfd_elf_link_hash_table_init): Set "init_offset".
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set init_refcount
	from init_offset.
	(elf_adjust_dynamic_symbol): Set plt and got offsets using init_offset.

	* elf.c (bfd_elf_local_sym_name): Split out from..
	(group_signature): ..here.
	* elf-bfd.h (bfd_elf_local_sym_name): Declare.
@
text
@d5312 1
a5312 1
  /* now generate the data (for "contents") */
d5378 1
d5430 10
a5439 1
		  BFD_ASSERT (sec2 != 0);
d5460 1
a5460 1
      /* Processor-specific types */
@


1.176
log
@bfd
	* elf-bfd.h (enum elf_link_info_type): Remove.
	(struct bfd_elf_section_data): Move sec_info_type, use_rela_p fields
	to struct sec.  Remove linkonce_p field.
	(elf_linkonce_p): Delete.
	(elf_discarded_section): Update for sec_info_type change.
	* section.c (struct sec): Add sec_info_type, use_rela_p, has_tls_reloc,
	flag11, flag12, flag13, flag14, flag15, flag16, flag20, flag24.
	(ELF_INFO_TYPE_NONE): Define.
	(ELF_INFO_TYPE_STABS): Define.
	(ELF_INFO_TYPE_MERGE): Define.
	(ELF_INFO_TYPE_EH_FRAME): Define.
	(ELF_INFO_TYPE_JUST_SYMS): Define.
	(STD_SECTION): Update struct sec initializer.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf.c: Likewise.  Update occurrences of sec_info_type and use_rela_p.
	* elflink.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* bfd-in2.h: Regenerate.

	* elf32-sparc.c (sec_do_relax): Use elf_section_data macro rather than
	referring to used_by_bfd.
	* elf64-sparc.c (sec_do_relax): Likewise.
	* elf64-mmix.c (mmix_elf_section_data): Likewise.
	* elfxx-mips.c (mips_elf_section_data): Likewise.
	* ieee.c (ieee_slurp_section_data): Use ieee_per_section macro.
	(ieee_get_section_contents): Likewise.
	(ieee_new_section_hook): Formatting.
	(ieee_canonicalize_reloc): Remove commented out code.
	* mmo.c (mmo_section_data): Define.  Use throughout file.
	* oasys.c (oasys_get_section_contents): Use oasys_per_section macro.

gas
	* config/obj-elf.c (obj_elf_change_section): Set SEC_LINK_ONCE and
	SEC_LINK_DUPLICATES_DISCARD directly rather than using elf_linkonce_p.
@
text
@d479 17
a516 2
  unsigned int iname;
  unsigned int shindex;
d528 1
a528 10
  /* Look up the symbol name.  */
  iname = isym.st_name;
  shindex = hdr->sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym.st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym.st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
d1429 2
a1430 2
      ret->got.refcount = htab->init_refcount;
      ret->plt.refcount = htab->init_refcount;
d1505 1
a1505 1
  h->plt.offset = (bfd_vma) -1;
d1535 3
a1537 2
  table->init_refcount = get_elf_backend_data (abfd)->can_refcount;
  --table->init_refcount;
@


1.175
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d972 2
a973 5
  struct bfd_elf_section_data *sec_data;

  sec_data = elf_section_data (sec);
  BFD_ASSERT (sec_data->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec_data->sec_info_type = ELF_INFO_TYPE_NONE;
d1001 1
a1001 1
  elf_section_data (sec)->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
d2007 1
a2007 2
	  elf_section_data (target_sect)->use_rela_p
	    = (hdr->sh_type == SHT_RELA);
d2147 1
a2147 2
  sdata->use_rela_p
    = get_elf_backend_data (abfd)->default_use_rela_p;
d2505 1
a2505 1
				    elf_section_data (asect)->use_rela_p))
d5188 1
a5188 2
  elf_section_data (osec)->use_rela_p
    = elf_section_data (isec)->use_rela_p;
d7333 1
a7333 1
      && elf_section_data (sec)->sec_info_type == ELF_INFO_TYPE_MERGE)
d7358 1
a7358 1
  if (elf_section_data (sec)->sec_info_type != ELF_INFO_TYPE_MERGE)
d7376 1
a7376 1
  switch (sec_data->sec_info_type)
@


1.174
log
@	* elf.c (elf_sort_sections): Don't reorder .tbss.
	(assign_file_positions_for_segments): Only adjust off/voff
	for increased alignment in PT_LOAD or PT_NOTE segment,
	but adjust p_filesz for .tbss too.  in PT_LOAD consider
	.tbss to have zero memory size.
	(copy_private_bfd_data) [SECTION_SIZE]: Define.
	[IS_CONTAINED_BY_VMA, IS_CONTAINED_BY_LMA]: Use it.
	[INCLUDE_SECTION_IN_SEGMENT]: Only put SHF_TLS sections
	into PT_TLS segment.  Never put SHF_TLS sections in
	segments other than PT_TLS or PT_LOAD.

	* elf64-alpha.c (elf64_alpha_finish_dynamic_sections): Clear .plt
	sh_entsize.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
a2138 1
  bfd_size_type amt = sizeof (*sdata);
d2140 9
a2148 4
  sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, amt);
  if (!sdata)
    return FALSE;
  sec->used_by_bfd = (PTR) sdata;
@


1.173
log
@Comment typo fixes.
@
text
@d3521 1
d3539 1
a3539 1
#define TOEND(x) (((x)->flags & SEC_LOAD) == 0)
d3561 4
a3564 1
  if (sec1->_raw_size < sec2->_raw_size)
d3566 1
a3566 1
  if (sec1->_raw_size > sec2->_raw_size)
d3847 9
a3855 3
	      off += adjust;
	      voff += adjust;
	      if ((flags & SEC_LOAD) != 0)
d3912 3
a3914 1
	      if ((flags & SEC_ALLOC) != 0)
d3941 3
d4587 5
d4596 1
a4596 1
   && (section->vma + section->_raw_size				\
d4603 1
a4603 1
   && (section->lma + section->_raw_size				\
d4635 3
a4637 1
       4. The section has not already been allocated to a previous segment.  */
d4645 5
d5127 1
@


1.172
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d4054 1
a4054 1
	 PT_PHDR segment, although that may not be TRUE for all
@


1.171
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d18 1
a18 1
   along with this program; if not, write to the Free Software 
d44 56
a99 33
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, boolean));
static boolean map_sections_to_segments PARAMS ((bfd *));
static int elf_sort_sections PARAMS ((const PTR, const PTR));
static boolean assign_file_positions_for_segments PARAMS ((bfd *));
static boolean assign_file_positions_except_relocs PARAMS ((bfd *));
static boolean prep_headers PARAMS ((bfd *));
static boolean swap_out_syms PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static boolean copy_private_bfd_data PARAMS ((bfd *, bfd *));
static char *elf_read PARAMS ((bfd *, file_ptr, bfd_size_type));
static const char *group_signature PARAMS ((bfd *, Elf_Internal_Shdr *));
static boolean setup_group PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void merge_sections_remove_hook PARAMS ((bfd *, asection *));
static void elf_fake_sections PARAMS ((bfd *, asection *, PTR));
static boolean assign_section_numbers PARAMS ((bfd *));
static INLINE int sym_is_global PARAMS ((bfd *, asymbol *));
static boolean elf_map_symbols PARAMS ((bfd *));
static bfd_size_type get_program_header_size PARAMS ((bfd *));
static boolean elfcore_read_notes PARAMS ((bfd *, file_ptr, bfd_size_type));
static boolean elf_find_function PARAMS ((bfd *, asection *, asymbol **,
					  bfd_vma, const char **,
					  const char **));
static int elfcore_make_pid PARAMS ((bfd *));
static boolean elfcore_maybe_make_sect PARAMS ((bfd *, char *, asection *));
static boolean elfcore_make_note_pseudosection PARAMS ((bfd *, char *,
							Elf_Internal_Note *));
static boolean elfcore_grok_prfpreg PARAMS ((bfd *, Elf_Internal_Note *));
static boolean elfcore_grok_prxfpreg PARAMS ((bfd *, Elf_Internal_Note *));
static boolean elfcore_grok_note PARAMS ((bfd *, Elf_Internal_Note *));

static boolean elfcore_netbsd_get_lwpid PARAMS ((Elf_Internal_Note *, int *));
static boolean elfcore_grok_netbsd_procinfo PARAMS ((bfd *,
						     Elf_Internal_Note *));
static boolean elfcore_grok_netbsd_note PARAMS ((bfd *, Elf_Internal_Note *));
d296 1
a296 1
boolean
d305 1
a305 1
    return false;
d309 1
a309 1
  return true;
d312 1
a312 1
boolean
d527 1
a527 1
static boolean
d563 1
a563 1
	    return false;
d586 1
a586 1
		    return false;
d663 1
a663 1
		      return false;
d686 1
a686 1
  return true;
d689 1
a689 1
boolean
d705 1
a705 1
  return true;
d711 1
a711 1
boolean
d725 1
a725 1
      return true;
d730 1
a730 1
    return false;
d738 1
a738 1
    return false;
d766 1
a766 1
      return false;
d803 1
a803 1
      return false;
d806 1
a806 1
    return false;
d877 1
a877 1
  return true;
d981 1
a981 1
boolean
d987 1
a987 1
    return false;
d991 1
a991 1
  return true;
d1010 1
a1010 1
boolean
d1017 1
a1017 1
    return true;
d1025 2
a1026 2
  elf_flags_init (obfd) = true;
  return true;
d1031 1
a1031 1
boolean
d1120 1
a1120 1
	  boolean stringp;
d1127 1
a1127 1
	  stringp = false;
d1135 1
a1135 1
	    case DT_NEEDED: name = "NEEDED"; stringp = true; break;
d1148 2
a1149 2
	    case DT_SONAME: name = "SONAME"; stringp = true; break;
	    case DT_RPATH: name = "RPATH"; stringp = true; break;
d1163 1
a1163 1
	    case DT_RUNPATH: name = "RUNPATH"; stringp = true; break;
d1175 3
a1177 3
	    case DT_CONFIG: name = "CONFIG"; stringp = true; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = true; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = true; break;
d1189 1
a1189 1
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
d1191 1
a1191 1
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
d1218 1
a1218 1
	return false;
d1260 1
a1260 1
  return true;
d1265 1
a1265 1
  return false;
d1500 1
a1500 1
     boolean force_local;
d1518 1
a1518 1
boolean
d1522 3
a1524 3
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d1526 1
a1526 1
  boolean ret;
d1528 1
a1528 1
  table->dynamic_sections_created = false;
d1644 1
a1644 1
boolean
d1661 1
a1661 1
    return true;
d1665 1
a1665 1
    return true;
d1720 1
a1720 1
  return true;
d1725 1
a1725 1
  return false;
d1740 1
a1740 1
      loc = _bfd_stringtab_add (ret, "", true, false);
d1755 1
a1755 1
boolean
d1771 1
a1771 1
      return true;
d1784 1
a1784 1
	return false;
d1817 1
a1817 1
	return true;
d1835 1
a1835 1
	return false;
d1837 1
a1837 1
      return true;
d1841 1
a1841 1
	return true;
d1856 1
a1856 1
	return true;
d1861 1
a1861 1
	return false;
d1866 1
a1866 1
      return true;
d1870 1
a1870 1
	return true;
d1875 1
a1875 1
	  return true;
d1887 1
a1887 1
		  return false;
d1893 1
a1893 1
		    return true;
d1973 1
a1973 1
	  return false;
d1985 1
a1985 1
	  return false;
d1988 1
a1988 1
	  return false;
d2013 1
a2013 1
	return true;
d2036 1
a2036 1
      return true;
d2044 1
a2044 1
	return false;
d2046 1
a2046 1
	return false;
d2076 1
a2076 1
  return true;
d2133 1
a2133 1
boolean
d2143 1
a2143 1
    return false;
d2150 1
a2150 1
  return true;
d2175 1
a2175 1
boolean
d2195 1
a2195 1
    return false;
d2199 1
a2199 1
    return false;
d2227 1
a2227 1
	return false;
d2231 1
a2231 1
	return false;
d2245 1
a2245 1
  return true;
d2248 1
a2248 1
boolean
d2272 1
a2272 1
	return false;
d2274 2
a2275 2
	return false;
      return true;
d2295 1
a2295 1
   relocations against ASECT.  If USE_RELA_P is true, we use RELA
d2298 1
a2298 1
boolean
d2303 1
a2303 1
     boolean use_rela_p;
d2311 1
a2311 1
    return false;
d2315 1
a2315 1
					false);
d2317 1
a2317 1
    return false;
d2328 1
a2328 1
  return true;
d2340 1
a2340 1
  boolean *failedptr = (boolean *) failedptrarg;
d2353 1
a2353 1
							   asect->name, false);
d2356 1
a2356 1
      *failedptr = true;
d2483 1
a2483 1
                                          
d2496 1
a2496 1
    *failedptr = true;
d2507 1
a2507 1
    *failedptr = true;
d2518 1
a2518 1
  boolean *failedptr = (boolean *) failedptrarg;
d2523 1
a2523 1
  boolean gas;
d2545 1
a2545 1
  gas = true;
d2548 1
a2548 1
      gas = false;
d2555 1
a2555 1
	  *failedptr = true;
d2621 1
a2621 1
static boolean
d2683 1
a2683 1
						  ".symtab_shndx", false);
d2685 1
a2685 1
	    return false;
d2706 1
a2706 1
    return false;
d2713 1
a2713 1
      return false;
d2797 1
a2797 1
		return false;
d2846 1
a2846 1
  return true;
d2867 1
a2867 1
static boolean
d2899 1
a2899 1
    return false;
d2974 1
a2974 1
    return false;
d3009 1
a3009 1
  return true;
d3015 2
a3016 1
static INLINE file_ptr align_file_position PARAMS ((file_ptr, int));
d3032 1
a3032 1
     boolean align;
d3054 1
a3054 1
boolean
d3060 1
a3060 1
  boolean failed;
d3065 1
a3065 1
    return true;
d3072 1
a3072 1
    return false;
d3078 1
a3078 1
  failed = false;
d3081 1
a3081 1
    return false;
d3084 1
a3084 1
    return false;
d3093 1
a3093 1
	return false;
d3100 1
a3100 1
	return false;
d3116 1
a3116 1
    return false;
d3126 1
a3126 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3130 1
a3130 1
	off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3133 1
a3133 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3141 1
a3141 1
	return false;
d3145 1
a3145 1
  abfd->output_has_begun = true;
d3147 1
a3147 1
  return true;
d3158 1
a3158 1
     boolean phdr;
d3188 1
a3188 1
static boolean
d3203 2
a3204 2
  boolean phdr_in_segment = true;
  boolean writable;
d3211 1
a3211 1
    return true;
d3214 1
a3214 1
    return true;
d3281 1
a3281 1
  writable = false;
d3301 1
a3301 1
	phdr_in_segment = false;
d3307 1
a3307 1
      boolean new_segment;
d3318 1
a3318 1
	  new_segment = false;
d3325 1
a3325 1
	  new_segment = true;
d3332 1
a3332 1
	  new_segment = true;
d3339 1
a3339 1
	  new_segment = true;
d3346 1
a3346 1
	  new_segment = false;
d3361 1
a3361 1
	  new_segment = true;
d3366 1
a3366 1
	  new_segment = false;
d3372 1
a3372 1
	    writable = true;
d3388 1
a3388 1
	writable = true;
d3390 1
a3390 1
	writable = false;
d3394 1
a3394 1
      phdr_in_segment = false;
d3504 1
a3504 1
  return true;
d3509 1
a3509 1
  return false;
d3572 1
a3572 1
static boolean
d3590 1
a3590 1
	return false;
d3627 1
a3627 1
	return false;
d3639 1
a3639 1
    return true;
d3651 1
a3651 1
      return false;
d3660 1
a3660 1
    return false;
d3756 1
a3756 1
		  return false;
d3883 1
a3883 1
		      return false;
d4006 1
a4006 1
    return false;
d4008 1
a4008 1
  return true;
d4054 1
a4054 1
	 PT_PHDR segment, although that may not be true for all
d4117 1
a4117 1
static boolean
d4154 1
a4154 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d4171 1
a4171 1
	return false;
d4197 1
a4197 1
							       false);
d4206 1
a4206 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d4223 1
a4223 1
  return true;
d4226 1
a4226 1
static boolean
d4241 1
a4241 1
    return false;
d4319 1
a4319 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", false);
d4321 1
a4321 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", false);
d4323 1
a4323 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", false);
d4327 1
a4327 1
    return false;
d4329 1
a4329 1
  return true;
d4353 1
a4353 1
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, true);
d4359 1
a4359 1
boolean
d4366 1
a4366 1
  boolean failed;
d4372 1
a4372 1
    return false;
d4377 1
a4377 1
  failed = false;
d4380 1
a4380 1
    return false;
d4396 1
a4396 1
	    return false;
d4405 1
a4405 1
    return false;
d4414 1
a4414 1
boolean
d4532 1
a4532 1
static boolean
d4537 13
a4549 13
  Elf_Internal_Ehdr *       iehdr;
  struct elf_segment_map *  map;
  struct elf_segment_map *  map_first;
  struct elf_segment_map ** pointer_to_map;
  Elf_Internal_Phdr *       segment;
  asection *                section;
  unsigned int              i;
  unsigned int              num_segments;
  boolean                   phdr_included = false;
  bfd_vma                   maxpagesize;
  struct elf_segment_map *  phdr_adjust_seg = NULL;
  unsigned int              phdr_adjust_num = 0;
  struct elf_backend_data * bed;
d4553 1
a4553 1
    return true;
d4556 1
a4556 1
    return true;
d4572 1
a4572 1
  /* Returns true if the given section is contained within
d4579 1
a4579 1
  /* Returns true if the given section is contained within
d4625 1
a4625 1
  /* Returns true iff seg1 starts after the end of seg2.  */
d4629 1
a4629 1
  /* Returns true iff seg1 and seg2 overlap.  */
d4636 1
a4636 1
    section->segment_mark = false;
d4741 1
a4741 1
	return false;
d4768 1
a4768 1
	    phdr_included = true;
d4822 1
a4822 1
	return false;
d5003 1
a5003 1
		  section->segment_mark = true;
d5024 1
a5024 1
		return false;
d5107 1
a5107 1
  return true;
d5113 1
a5113 1
boolean
d5124 1
a5124 1
    return true;
d5140 1
a5140 1
	      return false;
d5164 1
a5164 1
  return true;
d5179 1
a5179 1
boolean
d5190 1
a5190 1
    return true;
d5215 1
a5215 1
  return true;
d5220 1
a5220 1
static boolean
d5239 1
a5239 1
    return false;
d5244 1
a5244 1
    return false;
d5261 1
a5261 1
    return false;
d5271 1
a5271 1
	return false;
d5313 1
a5313 1
							    true, false);
d5315 1
a5315 1
	    return false;
d5475 1
a5475 1
  return true;
d5543 1
a5543 1
  if (! bed->s->slurp_reloc_table (abfd, section, symbols, false))
d5561 1
a5561 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, false);
d5574 1
a5574 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, true);
d5625 2
a5626 1
  boolean (*slurp_relocs) PARAMS ((bfd *, asection *, asymbol **, boolean));
d5647 1
a5647 1
	  if (! (*slurp_relocs) (abfd, s, syms, true))
d5664 1
a5664 1
boolean
d5851 1
a5851 1
  return true;
d5856 1
a5856 1
  return false;
d5889 1
a5889 1
boolean
d5896 1
a5896 1
    return true;
d5901 1
a5901 1
    return true;
d5910 1
a5910 1
    return true;
d5912 1
a5912 1
  return false;
d5924 1
a5924 1
boolean
d5935 1
a5935 1
    return false;
d5943 1
a5943 1
static boolean
d5992 1
a5992 1
    return false;
d5999 1
a5999 1
  return true;
d6005 1
a6005 1
boolean
d6016 1
a6016 1
  boolean found;
d6027 1
a6027 1
      return true;
d6040 1
a6040 1
      return true;
d6047 1
a6047 1
    return false;
d6049 1
a6049 1
    return true;
d6052 1
a6052 1
    return false;
d6056 1
a6056 1
    return false;
d6059 1
a6059 1
  return true;
d6065 1
a6065 1
     boolean reloc;
d6075 1
a6075 1
boolean
d6089 1
a6089 1
    return false;
d6095 1
a6095 1
    return false;
d6097 1
a6097 1
  return true;
d6111 1
a6111 1
boolean
d6197 1
a6197 1
  return true;
d6204 1
a6204 1
  return false;
d6207 1
a6207 1
boolean
d6262 1
a6262 1
static boolean
d6271 1
a6271 1
    return true;
d6275 1
a6275 1
    return false;
d6281 1
a6281 1
  return true;
d6291 1
a6291 1
boolean
d6309 1
a6309 1
    return false;
d6314 1
a6314 1
    return false;
d6330 2
a6331 1
static boolean elfcore_grok_prstatus PARAMS ((bfd *, Elf_Internal_Note *));
d6333 1
a6333 1
static boolean
d6396 1
a6396 1
      return true;
d6406 1
a6406 1
static boolean
d6420 1
a6420 1
static boolean
d6432 1
a6432 1
static boolean
d6484 2
a6485 1
static boolean elfcore_grok_psinfo PARAMS ((bfd *, Elf_Internal_Note *));
d6487 1
a6487 1
static boolean
d6528 1
a6528 1
      return true;
d6543 1
a6543 1
  return true;
d6548 2
a6549 1
static boolean elfcore_grok_pstatus PARAMS ((bfd *, Elf_Internal_Note *));
d6551 1
a6551 1
static boolean
d6583 1
a6583 1
  return true;
d6588 2
a6589 1
static boolean elfcore_grok_lwpstatus PARAMS ((bfd *, Elf_Internal_Note *));
d6591 1
a6591 1
static boolean
d6607 1
a6607 1
    return true;
d6620 1
a6620 1
    return false;
d6625 1
a6625 1
    return false;
d6642 1
a6642 1
    return false;
d6650 1
a6650 1
    return false;
d6655 1
a6655 1
    return false;
d6676 1
a6676 1
static boolean
d6688 1
a6688 1
    return true;
d6707 1
a6707 1
	return false;
d6713 1
a6713 1
	return false;
d6724 1
a6724 1
	  return false;
d6734 1
a6734 1
	return false;
d6741 1
a6741 1
	return false;
d6750 1
a6750 1
      return true;
d6753 1
a6753 1
  return true;
d6757 1
a6757 1
static boolean
d6767 1
a6767 1
      return true;
d6772 1
a6772 1
	  return true;
d6776 1
a6776 1
      return true;
d6802 1
a6802 1
	return true;
d6808 1
a6808 1
	  return true;
d6812 1
a6812 1
      return true;
d6817 1
a6817 1
static boolean
d6828 1
a6828 1
      return true;
d6830 1
a6830 1
  return false;
d6833 1
a6833 1
static boolean
d6851 1
a6851 1
  return true;
d6854 1
a6854 1
static boolean
d6880 1
a6880 1
    return true;
d6899 1
a6899 1
          return true;
d6915 1
a6915 1
          return true;
d7113 1
a7113 1
static boolean
d7123 1
a7123 1
    return true;
d7126 1
a7126 1
    return false;
d7130 1
a7130 1
    return false;
d7136 1
a7136 1
      return false;
d7170 1
a7170 1
  return true;
@


1.170
log
@	* elf-eh-frame.c (ENSURE_NO_RELOCS): Disregard R_*_NONE relocs.
	(_bfd_elf_discard_section_eh_frame): Don't discard duplicate CIEs
	on a relocatable link.  Comment typos.
	* elf.c (_bfd_elf_link_hash_newfunc): Assign elements of structure
	in the order they are declared.  Clear elf_hash_value too.
	(_bfd_elf_link_hash_table_init): Likewise assign in order.  Clear
	eh_info and tls_segment.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Keep reloc offsets
	sorted when discarding relocs by turning them into R_*_NONE.

	* libbfd.c (warn_deprecated): Comment spelling.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@a6083 11
#if 0
void
_bfd_elf_no_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rel *dst;
{
  abort ();
}
#endif

@


1.169
log
@* elf.c (_bfd_elf_link_hash_table_init): Make sure
can_refcount is properly extended to the type of
init_refcount.
@
text
@a1393 1
      ret->size = 0;
d1396 1
a1397 2
      ret->got.refcount = htab->init_refcount;
      ret->plt.refcount = htab->init_refcount;
d1400 1
a1401 1
      ret->vtable_entries_size = 0;
d1403 3
a1515 2
  table->runpath = NULL;
  table->loaded = NULL;
d1519 1
d1521 5
a1525 1
  ret = _bfd_link_hash_table_init (& table->root, abfd, newfunc);
@


1.168
log
@	* elf-bfd.h (struct cie_header): Move from elf_eh-frame.c.
	(struct cie, struct eh_cie_fde, struct eh_frame_sec_info): Likewise.
	(struct eh_frame_array_ent, struct eh_frame_hdr_info): Likewise.
	(enum elf_link_info_type): Remove ELF_INFO_TYPE_EH_FRAME_HDR.
	(struct eh_frame_hdr_info): Add "hdr_sec", remove "split".
	(struct elf_link_hash_table): Add eh_info.
	(struct elf_obj_tdata): Change eh_frame_hdr to an asection *.
	(_bfd_elf_discard_section_eh_frame): Update prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Remove "ehdrsec"
	param.  Get "hdr_info" from link hash table.
	(_bfd_elf_discard_section_eh_frame_hdr): Remove "sec" param.  Get
	header section from link hash table.  Save header section to elf_tdata.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Remove local "sec".  Use
	header section from link hash table.  Don't alloc hdr_info.  Clear
	hdr_sec instead of setting "strip".
	(_bfd_elf_eh_frame_section_offset): Formatting.
	(_bfd_elf_write_section_eh_frame): Remove "ehdrsec", add "info" param.
	Get header section from link hash table.
	(_bfd_elf_write_section_eh_frame_hdr): Remove "sec", add "info" param.
	Get header section from link hash table.
	* elf.c (map_sections_to_segments): Use cached eh_frame_hdr.
	(get_program_header_size): Likewise.
	(_bfd_elf_section_offset): Formatting.
	* elflink.h (elf_link_create_dynamic_sections): Stash eh frame header
	section pointer in link hash table.
	(elf_bfd_final_link): Adjust _bfd_elf_write_section_eh_frame_hdr
	and _bfd_elf_write_section_eh_frame calls.  Update comment about
	eh_frame entries.
	(elf_bfd_discard_info): Adjust _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr calls.  Remove "ehdr".

	* po/SRC-POTFILES.in: Regenerate.
@
text
@d1506 4
a1509 1
  table->init_refcount = get_elf_backend_data (abfd)->can_refcount - 1;
@


1.167
log
@Ah bah, missed these from last commit.
@
text
@d3452 3
a3454 4
  eh_frame_hdr = NULL;
  if (elf_tdata (abfd)->eh_frame_hdr)
    eh_frame_hdr = bfd_get_section_by_name (abfd, ".eh_frame_hdr");
  if (eh_frame_hdr != NULL && (eh_frame_hdr->flags & SEC_LOAD))
d3463 1
a3463 1
      m->sections[0] = eh_frame_hdr;
d4034 1
a4034 2
  if (elf_tdata (abfd)->eh_frame_hdr
      && bfd_get_section_by_name (abfd, ".eh_frame_hdr") != NULL)
d7328 3
a7330 3
      return _bfd_stab_section_offset
	(abfd, &elf_hash_table (info)->merge_info, sec, &sec_data->sec_info,
	 offset);
@


1.166
log
@	* Makefile.am: Remove entries for elf32-qnx.[ch].
	* Makefile.in: Regenerate.
	* config.bfd: Change arm-nto to use bfd_elf32_{big|little}arm_vec,
	ppc-nto to use bfd_elf32_powerpc{le}_vec, sh-nto to use
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure.in: Remove support for bfd_elf32_sh{l}qnx_vec,
	bfd_elf32_powerpc{le}qnx_vec, bfd_elf32_{big|little}armqnx_vec,
	and bfd_elf32_i386qnx_vec, and removed elf32-qnx.lo from other targets.
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure: Regenerate.
	* elf32-qnx.c: Remove.
	* elf32-qnx.h: Remove.
	* elf.c: Remove calls to QNX specific set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
	* elf32-i386.c: Remove QNX extended bfd support.
	* elf32-ppc.c: Remove QNX extended bfd support.
	* elf32-sh.c: Remove QNX extended bfd support.
	* elfarm-nabi.c: Remove QNX extended bfd support.
	* targets.c: Remove qnx vectors.
	* elfxx-target.h (elf_backend_set_nonloadable_filepos): Remove
	(elf_backend_is_contained_by_filepos): Remove.
	(elf_backend_copy_private_bfd_data_p): Remove.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@a5091 1
  const struct elf_backend_data *bed = get_elf_backend_data (ibfd);
d5097 1
a5097 14
  /* Copy over private BFD data if it has not already been copied.
     This must be done here, rather than in the copy_private_bfd_data
     entry point, because the latter is called after the section
     contents have been set, which means that the program headers have
     already been worked out.  The backend function provides a way to
     override the test conditions and code path for the call to
     copy_private_bfd_data.  */
  if (bed->copy_private_bfd_data_p)
    {
      if ((*bed->copy_private_bfd_data_p) (ibfd, isec, obfd, osec))
        if (! copy_private_bfd_data (ibfd, obfd))
          return false;
    }
  else if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
@


1.165
log
@	* elflink.h (struct elf_final_link_info): Add shndxbuf_size.
	(elf_bfd_final_link): Don't bother zeroing symtab_hdr fields.
	Set up a larger symshndxbuf, and write it out.  Free it on
	exit rather than freeing symbuf twice.  Correct section index
	on output section symbol loop.
	(elf_link_output_sym): Accumulate symbol extension section
	indices, reallocating symshndxbuf rather than writing it out.
	(elf_link_flush_output_syms): Don't flush symshndxbuf.
	* elf.c (assign_section_numbers): Init i_shdrp to all zero.
	Use bfd_zalloc to clear i_shdrp[0] too.
@
text
@a3961 5
  /* If additional nonloadable filepos adjustments are required,
     do them now. */
  if (bed->set_nonloadable_filepos)
    (*bed->set_nonloadable_filepos) (abfd, phdrs);

a4556 7
  /* Returns true if the given section is contained within the
     given segment.  Filepos addresses are compared in an elf
     backend function. */
#define IS_CONTAINED_BY_FILEPOS(sec, seg, bed)				\
  (bed->is_contained_by_filepos						\
   && (*bed->is_contained_by_filepos) (sec, seg))

d4592 1
a4592 3
    || IS_COREFILE_NOTE (segment, section)				\
    || (IS_CONTAINED_BY_FILEPOS (section, segment, bed)			\
        && (section->flags & SEC_ALLOC) == 0))				\
a4836 1
		  || IS_CONTAINED_BY_FILEPOS (section, segment, bed)
a5072 1
#undef IS_CONTAINED_BY_FILEPOS
@


1.164
log
@* elf.c (elfcore_grok_note): Fix recognition on NT_PRXFPREG notes.
@
text
@d2674 1
a2674 1
  i_shdrp = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);
d2679 1
a2679 1
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);
a2684 1
  memset (i_shdrp[0], 0, sizeof (Elf_Internal_Shdr));
@


1.163
log
@	* elf.c (map_sections_to_segments): Correct test for start of
	writable section in the same page as end of read-only section.
@
text
@d6806 2
a6807 2
      if (note->namesz == 5
	  && ! strcmp (note->namedata, "LINUX"))
@


1.163.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d6806 2
a6807 2
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
@


1.163.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d18 1
a18 1
   along with this program; if not, write to the Free Software
d43 34
a76 5
static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct bfd_strtab_hash **, int) ;
static bfd_boolean elfcore_read_notes (bfd *, file_ptr, bfd_size_type) ;
d85 4
a88 3
_bfd_elf_swap_verdef_in (bfd *abfd,
			 const Elf_External_Verdef *src,
			 Elf_Internal_Verdef *dst)
d102 4
a105 3
_bfd_elf_swap_verdef_out (bfd *abfd,
			  const Elf_Internal_Verdef *src,
			  Elf_External_Verdef *dst)
d119 4
a122 3
_bfd_elf_swap_verdaux_in (bfd *abfd,
			  const Elf_External_Verdaux *src,
			  Elf_Internal_Verdaux *dst)
d131 4
a134 3
_bfd_elf_swap_verdaux_out (bfd *abfd,
			   const Elf_Internal_Verdaux *src,
			   Elf_External_Verdaux *dst)
d143 4
a146 3
_bfd_elf_swap_verneed_in (bfd *abfd,
			  const Elf_External_Verneed *src,
			  Elf_Internal_Verneed *dst)
d158 4
a161 3
_bfd_elf_swap_verneed_out (bfd *abfd,
			   const Elf_Internal_Verneed *src,
			   Elf_External_Verneed *dst)
d173 4
a176 3
_bfd_elf_swap_vernaux_in (bfd *abfd,
			  const Elf_External_Vernaux *src,
			  Elf_Internal_Vernaux *dst)
d188 4
a191 3
_bfd_elf_swap_vernaux_out (bfd *abfd,
			   const Elf_Internal_Vernaux *src,
			   Elf_External_Vernaux *dst)
d203 4
a206 3
_bfd_elf_swap_versym_in (bfd *abfd,
			 const Elf_External_Versym *src,
			 Elf_Internal_Versym *dst)
d214 4
a217 3
_bfd_elf_swap_versym_out (bfd *abfd,
			  const Elf_Internal_Versym *src,
			  Elf_External_Versym *dst)
d226 2
a227 1
bfd_elf_hash (const char *namearg)
d245 1
a245 1
  return h & 0xffffffff;
d253 4
a256 1
elf_read (bfd *abfd, file_ptr offset, bfd_size_type size)
d264 1
a264 1
  if (bfd_bread (buf, size, abfd) != size)
d273 3
a275 2
bfd_boolean
bfd_elf_mkobject (bfd *abfd)
d279 2
a280 1
  elf_tdata (abfd) = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
d282 1
a282 1
    return FALSE;
d286 1
a286 1
  return TRUE;
d289 3
a291 2
bfd_boolean
bfd_elf_mkcorefile (bfd *abfd)
d298 3
a300 1
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
d318 1
a318 1
      i_shdrp[shindex]->contents = shstrtab;
d324 4
a327 3
bfd_elf_string_from_elf_section (bfd *abfd,
				 unsigned int shindex,
				 unsigned int strindex)
d362 9
a370 7
bfd_elf_get_elf_syms (bfd *ibfd,
		      Elf_Internal_Shdr *symtab_hdr,
		      size_t symcount,
		      size_t symoffset,
		      Elf_Internal_Sym *intsym_buf,
		      void *extsym_buf,
		      Elf_External_Sym_Shndx *extshndx_buf)
d373 1
a373 1
  void *alloc_ext;
d379 1
a379 1
  const struct elf_backend_data *bed;
d420 1
a420 1
	  alloc_extshndx = bfd_malloc (amt);
d435 1
a435 1
      intsym_buf = bfd_malloc (amt);
d445 1
a445 1
    (*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym);
a455 15
/* Look up a symbol name.  */
const char *
bfd_elf_local_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
{
  unsigned int iname = isym->st_name;
  unsigned int shindex = elf_tdata (abfd)->symtab_hdr.sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym->st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

d469 3
a471 1
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
d477 2
d490 10
a499 1
  return bfd_elf_local_sym_name (abfd, &isym);
d504 5
a508 2
static bfd_boolean
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
d540 1
a540 1
	    return FALSE;
d563 1
a563 1
		    return FALSE;
d640 1
a640 1
		      return FALSE;
d663 1
a663 1
  return TRUE;
d666 4
a669 2
bfd_boolean
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED, asection *group)
d682 1
a682 1
  return TRUE;
d688 5
a692 4
bfd_boolean
_bfd_elf_make_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name)
d696 1
a696 1
  const struct elf_backend_data *bed;
d702 1
a702 1
      return TRUE;
d707 1
a707 5
    return FALSE;

  /* Always use the real type/flags.  */
  elf_section_type (newsect) = hdr->sh_type;
  elf_section_flags (newsect) = hdr->sh_flags;
d715 1
a715 1
    return FALSE;
d743 1
a743 1
      return FALSE;
d780 1
a780 1
      return FALSE;
d783 1
a783 1
    return FALSE;
d854 1
a854 1
  return TRUE;
d873 3
a875 1
bfd_elf_find_section (bfd *abfd, char *name)
d904 1
a904 1
/* ELF relocs are against symbols.  If we are producing relocatable
d912 1
a912 1
   relocatable output against an external symbol.  */
d915 14
a928 7
bfd_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol,
		       void *data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d930 1
a930 1
  if (output_bfd != NULL
d945 3
a947 2
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
d949 5
a953 2
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
d958 4
a961 2
bfd_boolean
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
d963 2
a964 2
  if (!is_elf_hash_table (info->hash))
    return FALSE;
d968 1
a968 1
  return TRUE;
d972 3
a974 1
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
d978 1
a978 1
  if (!is_elf_hash_table (info->hash))
d981 1
a981 1
  sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
d987 4
a990 2
bfd_boolean
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d994 1
a994 1
    return TRUE;
d1002 2
a1003 2
  elf_flags_init (obfd) = TRUE;
  return TRUE;
d1008 4
a1011 2
bfd_boolean
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
d1013 1
a1013 1
  FILE *f = farg;
a1040 1
	    case PT_GNU_STACK: pt = "STACK"; break;
d1071 1
a1071 1
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1075 1
a1075 1
      dynbuf = bfd_malloc (s->_raw_size);
d1078 2
a1079 1
      if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1097 1
a1097 1
	  bfd_boolean stringp;
d1099 1
a1099 1
	  (*swap_dyn_in) (abfd, extdyn, &dyn);
d1104 1
a1104 1
	  stringp = FALSE;
d1112 1
a1112 1
	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
d1125 2
a1126 2
	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
d1140 1
a1140 1
	    case DT_RUNPATH: name = "RUNPATH"; stringp = TRUE; break;
d1152 3
a1154 3
	    case DT_CONFIG: name = "CONFIG"; stringp = TRUE; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = TRUE; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = TRUE; break;
d1166 1
a1166 1
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
d1168 1
a1168 1
	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
d1195 1
a1195 1
	return FALSE;
d1237 1
a1237 1
  return TRUE;
d1242 1
a1242 1
  return FALSE;
d1248 5
a1252 4
bfd_elf_print_symbol (bfd *abfd,
		      void *filep,
		      asymbol *symbol,
		      bfd_print_symbol_type how)
d1254 1
a1254 1
  FILE *file = filep;
d1269 1
a1269 1
	const struct elf_backend_data *bed;
d1282 1
a1282 1
	    bfd_print_symbol_vandf (abfd, file, symbol);
d1371 4
a1374 3
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
d1394 1
a1396 1
      ret->elf_hash_value = 0;
d1398 3
d1402 1
a1403 1
      ret->vtable_entries_used = NULL;
a1404 3
      ret->got = htab->init_refcount;
      ret->plt = htab->init_refcount;
      ret->size = 0;
d1421 3
a1423 3
_bfd_elf_link_hash_copy_indirect (const struct elf_backend_data *bed,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
d1431 6
a1436 7
  dir->elf_link_hash_flags
    |= ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_NON_GOT_REF
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED);
d1473 4
a1476 3
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
d1478 1
a1478 1
  h->plt = elf_hash_table (info)->init_offset;
d1494 7
a1500 7
bfd_boolean
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d1502 1
a1502 1
  bfd_boolean ret;
d1504 1
a1504 1
  table->dynamic_sections_created = FALSE;
d1506 1
a1506 5
  /* Make sure can_refcount is extended to the width and signedness of
     init_refcount before we subtract one from it.  */
  table->init_refcount.refcount = get_elf_backend_data (abfd)->can_refcount;
  table->init_refcount.refcount -= 1;
  table->init_offset.offset = -(bfd_vma) 1;
d1512 2
a1516 1
  memset (&table->eh_info, 0, sizeof (table->eh_info));
d1518 1
a1518 6
  table->runpath = NULL;
  table->tls_sec = NULL;
  table->tls_size = 0;
  table->loaded = NULL;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d1527 2
a1528 1
_bfd_elf_link_hash_table_create (bfd *abfd)
d1533 2
a1534 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d1552 3
a1554 1
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
d1562 3
a1564 1
bfd_elf_set_dt_needed_soname (bfd *abfd, const char *name)
d1575 3
a1577 2
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
d1579 1
a1579 1
  if (! is_elf_hash_table (info->hash))
d1588 3
a1590 2
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
d1592 1
a1592 1
  if (! is_elf_hash_table (info->hash))
d1602 2
a1603 1
bfd_elf_get_dt_soname (bfd *abfd)
d1614 4
a1617 3
bfd_boolean
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
d1625 1
a1625 1
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1631 1
a1631 1
    return TRUE;
d1635 1
a1635 1
    return TRUE;
d1637 1
a1637 1
  dynbuf = bfd_malloc (s->_raw_size);
d1641 2
a1642 1
  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1660 1
a1660 1
      (*swap_dyn_in) (abfd, extdyn, &dyn);
d1677 1
a1677 1
	  l = bfd_alloc (abfd, amt);
d1690 1
a1690 1
  return TRUE;
d1695 1
a1695 1
  return FALSE;
d1701 1
a1701 1
_bfd_elf_stringtab_init (void)
d1710 1
a1710 1
      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
d1725 4
a1728 2
bfd_boolean
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
d1732 1
a1732 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1741 1
a1741 1
      return TRUE;
d1754 1
a1754 1
	return FALSE;
d1787 1
a1787 1
	return TRUE;
d1800 1
a1800 1
         set in a relocatable object file, which would confuse the
d1805 1
a1805 1
	return FALSE;
d1807 1
a1807 1
      return TRUE;
d1811 1
a1811 1
	return TRUE;
d1826 1
a1826 1
	return TRUE;
d1831 1
a1831 1
	return FALSE;
d1836 1
a1836 1
      return TRUE;
d1840 1
a1840 1
	return TRUE;
d1845 1
a1845 1
	  return TRUE;
d1857 1
a1857 1
		  return FALSE;
d1863 1
a1863 1
		    return TRUE;
d1943 1
a1943 1
	  return FALSE;
d1955 1
a1955 1
	  return FALSE;
d1958 1
a1958 1
	  return FALSE;
d1968 1
a1968 1
	    hdr2 = bfd_alloc (abfd, amt);
d1980 2
a1981 1
	  target_sect->use_rela_p = hdr->sh_type == SHT_RELA;
d1983 1
a1983 1
	return TRUE;
d2006 1
a2006 1
      return TRUE;
d2014 1
a2014 1
	return FALSE;
d2016 1
a2016 1
	return FALSE;
d2046 1
a2046 1
  return TRUE;
d2053 5
a2057 4
bfd_section_from_r_symndx (bfd *abfd,
			   struct sym_sec_cache *cache,
			   asection *sec,
			   unsigned long r_symndx)
d2080 1
a2080 2
  if ((isym.st_shndx != SHN_UNDEF && isym.st_shndx < SHN_LORESERVE)
      || isym.st_shndx > SHN_HIRESERVE)
d2094 3
a2096 1
bfd_section_from_elf_index (bfd *abfd, unsigned int index)
d2103 4
a2106 111
static struct bfd_elf_special_section const special_sections[] =
{
  { ".bss",            4, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".comment",        8,  0, SHT_PROGBITS, 0 },
  { ".data",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".data1",          6,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".debug",          6,  0, SHT_PROGBITS, 0 },
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".debug_line",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_info",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_abbrev",  13,  0, SHT_PROGBITS, 0 },
  { ".debug_aranges", 14,  0, SHT_PROGBITS, 0 },
  { ".dynamic",        8,  0, SHT_DYNAMIC,  SHF_ALLOC },
  { ".dynstr",         7,  0, SHT_STRTAB,   SHF_ALLOC },
  { ".dynsym",         7,  0, SHT_DYNSYM,   SHF_ALLOC },
  { ".got",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
  { ".gnu.version",   12,  0, SHT_GNU_versym, 0 },
  { ".gnu.version_d", 14,  0, SHT_GNU_verdef, 0 },
  { ".gnu.version_r", 14,  0, SHT_GNU_verneed, 0 },
  { ".note",           5, -1, SHT_NOTE,     0 },
  { ".rela",           5, -1, SHT_RELA,     0 },
  { ".rel",            4, -1, SHT_REL,      0 },
  { ".stabstr",        5,  3, SHT_STRTAB,   0 },
  { NULL,              0,  0, 0,            0 }
};

static const struct bfd_elf_special_section *
get_special_section (const char *name,
		     const struct bfd_elf_special_section *special_sections,
		     unsigned int rela)
{
  int i;
  int len = strlen (name);

  for (i = 0; special_sections[i].prefix != NULL; i++)
    {
      int suffix_len;
      int prefix_len = special_sections[i].prefix_length;

      if (len < prefix_len)
	continue;
      if (memcmp (name, special_sections[i].prefix, prefix_len) != 0)
	continue;

      suffix_len = special_sections[i].suffix_length;
      if (suffix_len <= 0)
	{
	  if (name[prefix_len] != 0)
	    {
	      if (suffix_len == 0)
		continue;
	      if (name[prefix_len] != '.'
		  && (suffix_len == -2
		      || (rela && special_sections[i].type == SHT_REL)))
		continue;
	    }
	}
      else
	{
	  if (len < prefix_len + suffix_len)
	    continue;
	  if (memcmp (name + len - suffix_len,
		      special_sections[i].prefix + prefix_len,
		      suffix_len) != 0)
	    continue;
	}
      return &special_sections[i];
    }

  return NULL;
}

const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  const struct bfd_elf_special_section *ssect = NULL;

  /* See if this is one of the special sections.  */
  if (name)
    {
      unsigned int rela = bed->default_use_rela_p;

      if (bed->special_sections)
	ssect = get_special_section (name, bed->special_sections, rela);

      if (! ssect)
	ssect = get_special_section (name, special_sections, rela);
    }

  return ssect;
}

bfd_boolean
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
d2109 1
a2109 10
  const struct bfd_elf_special_section *ssect;

  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == NULL)
    {
      sdata = bfd_zalloc (abfd, sizeof (*sdata));
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = sdata;
    }
d2111 4
a2114 7
  elf_section_type (sec) = SHT_NULL;
  ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
  if (ssect != NULL)
    {
      elf_section_type (sec) = ssect->type;
      elf_section_flags (sec) = ssect->attr;
    }
d2117 2
a2118 1
  sec->use_rela_p = get_elf_backend_data (abfd)->default_use_rela_p;
d2120 1
a2120 1
  return TRUE;
d2145 6
a2150 5
bfd_boolean
_bfd_elf_make_section_from_phdr (bfd *abfd,
				 Elf_Internal_Phdr *hdr,
				 int index,
				 const char *typename)
d2163 1
a2163 1
  name = bfd_alloc (abfd, len);
d2165 1
a2165 1
    return FALSE;
d2169 1
a2169 1
    return FALSE;
a2174 1
  newsect->alignment_power = bfd_log2 (hdr->p_align);
d2195 1
a2195 1
      name = bfd_alloc (abfd, len);
d2197 1
a2197 1
	return FALSE;
d2201 1
a2201 1
	return FALSE;
d2215 1
a2215 1
  return TRUE;
d2218 5
a2222 2
bfd_boolean
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index)
d2224 1
a2224 1
  const struct elf_backend_data *bed;
d2242 4
a2245 4
	return FALSE;
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
	return FALSE;
      return TRUE;
a2252 7
    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "eh_frame_hdr");

    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");

d2265 1
a2265 1
   relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA
d2268 6
a2273 5
bfd_boolean
_bfd_elf_init_reloc_shdr (bfd *abfd,
			  Elf_Internal_Shdr *rel_hdr,
			  asection *asect,
			  bfd_boolean use_rela_p)
d2276 1
a2276 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2281 1
a2281 1
    return FALSE;
d2285 1
a2285 1
					FALSE);
d2287 1
a2287 1
    return FALSE;
d2292 1
a2292 1
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
d2298 1
a2298 1
  return TRUE;
d2304 4
a2307 1
elf_fake_sections (bfd *abfd, asection *asect, void *failedptrarg)
d2309 2
a2310 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean *failedptr = failedptrarg;
d2322 3
a2324 3
  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
d2326 1
a2326 1
      *failedptr = TRUE;
d2348 7
a2354 10
  /* If the section type is unspecified, we set it based on
     asect->flags.  */
  if (this_hdr->sh_type == SHT_NULL)
    {
      if ((asect->flags & SEC_ALLOC) != 0
	  && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      || (asect->flags & SEC_NEVER_LOAD) != 0))
	this_hdr->sh_type = SHT_NOBITS;
      else
	this_hdr->sh_type = SHT_PROGBITS;
d2356 1
a2356 2

  switch (this_hdr->sh_type)
d2358 1
a2358 17
    default:
      break;

    case SHT_STRTAB:
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
    case SHT_NOTE:
    case SHT_NOBITS:
    case SHT_PROGBITS:
      break;

    case SHT_HASH:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;

    case SHT_DYNSYM:
d2360 4
a2363 3
      break;

    case SHT_DYNAMIC:
d2365 27
a2391 13
      break;

    case SHT_RELA:
      if (get_elf_backend_data (abfd)->may_use_rela_p)
	this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case SHT_REL:
      if (get_elf_backend_data (abfd)->may_use_rel_p)
	this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case SHT_GNU_versym:
d2393 4
a2396 3
      break;

     case SHT_GNU_verdef:
d2406 4
a2409 3
      break;

    case SHT_GNU_verneed:
d2419 4
a2422 3
      break;

    case SHT_GROUP:
a2423 1
      break;
d2425 6
d2453 1
a2453 1

d2466 1
a2466 1
    *failedptr = TRUE;
d2476 2
a2477 2
				    asect->use_rela_p))
    *failedptr = TRUE;
d2483 4
a2486 1
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
d2488 1
a2488 1
  bfd_boolean *failedptr = failedptrarg;
d2493 1
a2493 1
  bfd_boolean gas;
d2515 1
a2515 1
  gas = TRUE;
d2518 1
a2518 1
      gas = FALSE;
d2525 1
a2525 1
	  *failedptr = TRUE;
d2591 3
a2593 2
static bfd_boolean
assign_section_numbers (bfd *abfd)
d2653 1
a2653 1
						  ".symtab_shndx", FALSE);
d2655 1
a2655 1
	    return FALSE;
d2674 1
a2674 1
  i_shdrp = bfd_zalloc (abfd, amt);
d2676 1
a2676 1
    return FALSE;
d2679 1
a2679 1
  i_shdrp[0] = bfd_zalloc (abfd, amt);
d2683 1
a2683 1
      return FALSE;
d2685 1
d2766 1
a2766 1
	      alc = bfd_malloc (len - 2);
d2768 1
a2768 1
		return FALSE;
d2817 1
a2817 1
  return TRUE;
d2823 4
a2826 2
static int
sym_is_global (bfd *abfd, asymbol *sym)
d2829 3
a2831 3
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);
d2838 3
a2840 2
static bfd_boolean
elf_map_symbols (bfd *abfd)
d2868 1
a2868 1
  sect_syms = bfd_zalloc (abfd, amt);
d2870 1
a2870 1
    return FALSE;
d2942 1
a2942 1
  new_syms = bfd_alloc (abfd, amt);
d2945 1
a2945 1
    return FALSE;
d2980 1
a2980 1
  return TRUE;
d2986 5
a2990 2
static inline file_ptr
align_file_position (file_ptr off, int align)
d2998 5
a3002 4
file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
					   file_ptr offset,
					   bfd_boolean align)
d3024 4
a3027 3
bfd_boolean
_bfd_elf_compute_section_file_positions (bfd *abfd,
					 struct bfd_link_info *link_info)
d3029 2
a3030 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  bfd_boolean failed;
d3035 1
a3035 1
    return TRUE;
d3042 1
a3042 1
    return FALSE;
d3048 1
a3048 1
  failed = FALSE;
d3051 1
a3051 1
    return FALSE;
d3054 1
a3054 1
    return FALSE;
d3063 1
a3063 1
	return FALSE;
d3070 1
a3070 1
	return FALSE;
d3085 2
a3086 2
  if (!assign_file_positions_except_relocs (abfd, link_info))
    return FALSE;
d3096 1
a3096 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3100 1
a3100 1
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3103 1
a3103 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3111 1
a3111 1
	return FALSE;
d3115 1
a3115 1
  abfd->output_has_begun = TRUE;
d3117 1
a3117 1
  return TRUE;
d3122 7
a3128 6
static struct elf_segment_map *
make_mapping (bfd *abfd,
	      asection **sections,
	      unsigned int from,
	      unsigned int to,
	      bfd_boolean phdr)
d3137 1
a3137 1
  m = bfd_zalloc (abfd, amt);
d3158 3
a3160 2
static bfd_boolean
map_sections_to_segments (bfd *abfd)
d3173 2
a3174 2
  bfd_boolean phdr_in_segment = TRUE;
  bfd_boolean writable;
d3181 1
a3181 1
    return TRUE;
d3184 1
a3184 1
    return TRUE;
d3189 1
a3189 1
  sections = bfd_malloc (amt);
d3219 1
a3219 1
      m = bfd_zalloc (abfd, amt);
d3233 1
a3233 1
      m = bfd_zalloc (abfd, amt);
d3251 1
a3251 1
  writable = FALSE;
d3271 1
a3271 1
	phdr_in_segment = FALSE;
d3277 1
a3277 1
      bfd_boolean new_segment;
d3288 1
a3288 1
	  new_segment = FALSE;
d3295 1
a3295 1
	  new_segment = TRUE;
d3302 1
a3302 1
	  new_segment = TRUE;
d3309 1
a3309 1
	  new_segment = TRUE;
d3316 1
a3316 1
	  new_segment = FALSE;
d3331 1
a3331 1
	  new_segment = TRUE;
d3336 1
a3336 1
	  new_segment = FALSE;
d3342 1
a3342 1
	    writable = TRUE;
d3358 1
a3358 1
	writable = TRUE;
d3360 1
a3360 1
	writable = FALSE;
d3364 1
a3364 1
      phdr_in_segment = FALSE;
d3382 1
a3382 1
      m = bfd_zalloc (abfd, amt);
d3405 1
a3405 1
	  m = bfd_zalloc (abfd, amt);
d3431 1
a3431 1
      m = bfd_zalloc (abfd, amt);
d3453 4
a3456 3
  eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
  if (eh_frame_hdr != NULL
      && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
d3459 1
a3459 1
      m = bfd_zalloc (abfd, amt);
d3465 1
a3465 16
      m->sections[0] = eh_frame_hdr->output_section;

      *pm = m;
      pm = &m->next;
    }

  if (elf_tdata (abfd)->stack_flags)
    {
      amt = sizeof (struct elf_segment_map);
      m = bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_STACK;
      m->p_flags = elf_tdata (abfd)->stack_flags;
      m->p_flags_valid = 1;
d3475 1
a3475 1
  return TRUE;
d3480 1
a3480 1
  return FALSE;
d3486 3
a3488 1
elf_sort_sections (const void *arg1, const void *arg2)
a3491 1
  bfd_size_type size1, size2;
d3509 1
a3509 1
#define TOEND(x) (((x)->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)
d3531 1
a3531 4
  size1 = (sec1->flags & SEC_LOAD) ? sec1->_raw_size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->_raw_size : 0;

  if (size1 < size2)
d3533 1
a3533 1
  if (size1 > size2)
d3543 3
a3545 2
static bfd_boolean
assign_file_positions_for_segments (bfd *abfd, struct bfd_link_info *link_info)
d3561 1
a3561 1
	return FALSE;
d3597 2
a3598 2
      if (! (*bed->elf_backend_modify_segment_map) (abfd, link_info))
	return FALSE;
d3610 1
a3610 1
    return TRUE;
d3622 1
a3622 1
      return FALSE;
d3629 1
a3629 1
  phdrs = bfd_alloc (abfd, amt);
d3631 1
a3631 1
    return FALSE;
d3702 1
a3702 1
	p->p_align = 1 << bed->s->log_file_align;
d3727 1
a3727 1
		  return FALSE;
d3814 3
a3816 9
	      if (p->p_type == PT_LOAD
		  || (p->p_type == PT_NOTE
		      && bfd_get_format (abfd) == bfd_core))
		{
		  off += adjust;
		  voff += adjust;
		}
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_THREAD_LOCAL) != 0)
d3854 1
a3854 1
		      return FALSE;
d3873 1
a3873 3
	      if ((flags & SEC_ALLOC) != 0
		  && ((flags & SEC_LOAD) != 0
		      || (flags & SEC_THREAD_LOCAL) == 0))
a3899 3
	      if ((sec->flags & SEC_LOAD) != 0
		  || (sec->flags & SEC_THREAD_LOCAL) == 0
		  || p->p_type == PT_TLS)
d3963 5
d3982 1
a3982 1
    return FALSE;
d3984 1
a3984 1
  return TRUE;
d3999 2
a4000 1
get_program_header_size (bfd *abfd)
d4004 1
a4004 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4041 2
a4042 1
  if (elf_tdata (abfd)->eh_frame_hdr)
a4047 6
  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

d4094 3
a4096 3
static bfd_boolean
assign_file_positions_except_relocs (bfd *abfd,
				     struct bfd_link_info *link_info)
d4103 1
a4103 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4131 1
a4131 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d4147 2
a4148 2
      if (! assign_file_positions_for_segments (abfd, link_info))
	return FALSE;
d4174 1
a4174 1
							       FALSE);
d4183 1
a4183 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d4194 1
a4194 1
  off = align_file_position (off, 1 << bed->s->log_file_align);
d4200 1
a4200 1
  return TRUE;
d4203 3
a4205 2
static bfd_boolean
prep_headers (bfd *abfd)
d4211 1
a4211 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4218 1
a4218 1
    return FALSE;
d4256 5
a4260 2
      i_ehdrp->e_machine = bed->elf_machine_code;
    }
d4296 1
a4296 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", FALSE);
d4298 1
a4298 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", FALSE);
d4300 1
a4300 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", FALSE);
d4304 1
a4304 1
    return FALSE;
d4306 1
a4306 1
  return TRUE;
d4313 2
a4314 1
_bfd_elf_assign_file_positions_for_relocs (bfd *abfd)
d4330 1
a4330 1
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, TRUE);
d4336 3
a4338 2
bfd_boolean
_bfd_elf_write_object_contents (bfd *abfd)
d4340 1
a4340 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4343 1
a4343 1
  bfd_boolean failed;
d4347 3
a4349 2
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;
d4354 1
a4354 1
  failed = FALSE;
d4357 1
a4357 1
    return FALSE;
d4373 1
a4373 1
	    return FALSE;
d4382 1
a4382 1
    return FALSE;
d4391 3
a4393 2
bfd_boolean
_bfd_elf_write_corefile_contents (bfd *abfd)
d4402 3
a4404 1
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
d4406 1
a4406 1
  const struct elf_backend_data *bed;
d4453 3
a4455 1
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
d4509 18
a4526 16
static bfd_boolean
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
  const struct elf_backend_data *bed;
d4530 1
a4530 1
    return TRUE;
d4533 1
a4533 1
    return TRUE;
d4549 1
a4549 6
#define SECTION_SIZE(section, segment)					\
  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\
    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\
   ? section->_raw_size : 0)

  /* Returns TRUE if the given section is contained within
d4553 1
a4553 1
   && (section->vma + SECTION_SIZE (section, segment)			\
d4556 1
a4556 1
  /* Returns TRUE if the given section is contained within
d4560 1
a4560 1
   && (section->lma + SECTION_SIZE (section, segment)			\
d4563 7
d4599 1
a4599 4
       4. The section has not already been allocated to a previous segment.
       5. PT_GNU_STACK segments do not include any sections.
       6. PT_TLS segment includes only SHF_TLS sections.
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
d4605 3
a4607 1
    || IS_COREFILE_NOTE (segment, section))				\
a4608 6
   && segment->p_type != PT_GNU_STACK					\
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
d4611 5
a4615 10
  /* Returns TRUE iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)			\
  (seg1->field >= SEGMENT_END (seg2, seg2->field))

  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both
     their VMA address ranges and their LMA address ranges overlap.
     It is possible to have overlapping VMA ranges without overlapping LMA
     ranges.  RedBoot images for example can have both .data and .bss mapped
     to the same VMA range, but with the .data section mapped to a different
     LMA.  */
d4617 2
a4618 4
  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\
   && !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))
d4622 1
a4622 1
    section->segment_mark = FALSE;
d4640 1
a4640 1
		 assignment code will work.  */
d4716 2
a4717 3
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
d4721 2
a4722 2
      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
d4725 1
a4725 1
      map = bfd_alloc (obfd, amt);
d4727 1
a4727 1
	return FALSE;
d4754 1
a4754 1
	    phdr_included = TRUE;
d4794 1
a4794 1
	 4. The sections have been moved, but not by the same amount.
d4806 1
a4806 1
      sections = bfd_malloc (amt);
d4808 1
a4808 1
	return FALSE;
d4852 1
d4990 1
a4990 1
		  section->segment_mark = TRUE;
d5009 1
a5009 1
	      map = bfd_alloc (obfd, amt);
d5011 1
a5011 4
		{
		  free (sections);
		  return FALSE;
		}
d5039 4
a5042 2
    for (map = map_first; map != NULL; map = map->next)
      map->p_paddr_valid = 0;
a5086 1
#undef SECTION_SIZE
d5089 1
d5095 1
a5095 1
  return TRUE;
d5101 6
a5106 5
bfd_boolean
_bfd_elf_copy_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec)
d5109 1
d5113 1
a5113 1
    return TRUE;
d5115 14
a5128 1
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
d5142 1
a5142 1
	      return FALSE;
d5163 2
a5164 1
  osec->use_rela_p = isec->use_rela_p;
d5166 1
a5166 1
  return TRUE;
d5181 6
a5186 5
bfd_boolean
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
				   asymbol *isymarg,
				   bfd *obfd,
				   asymbol *osymarg)
d5192 1
a5192 1
    return TRUE;
d5217 1
a5217 1
  return TRUE;
d5222 5
a5226 4
static bfd_boolean
swap_out_syms (bfd *abfd,
	       struct bfd_strtab_hash **sttp,
	       int relocatable_p)
d5228 1
a5228 1
  const struct elf_backend_data *bed;
d5241 1
a5241 1
    return FALSE;
d5246 1
a5246 1
    return FALSE;
d5255 1
a5255 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
d5263 2
a5264 5
    {
      _bfd_stringtab_free (stt);
      return FALSE;
    }
  symtab_hdr->contents = outbound_syms;
d5273 1
a5273 5
	{
	  _bfd_stringtab_free (stt);
	  return FALSE;
	}

d5281 1
a5281 1
  /* Now generate the data (for "contents").  */
d5315 1
a5315 1
							    TRUE, FALSE);
d5317 1
a5317 4
	    {
	      _bfd_stringtab_free (stt);
	      return FALSE;
	    }
a5346 1

d5398 1
a5398 11
		  if (sec2 == NULL)
		    {
		      _bfd_error_handler (_("\
Unable to find equivalent output section for symbol '%s' from section '%s'"),
					  syms[idx]->name ? syms[idx]->name : "<Local sym>",
					  sec->name);
		      bfd_set_error (bfd_error_invalid_operation);
		      _bfd_stringtab_free (stt);
		      return FALSE;
		    }

d5419 1
a5419 1
      /* Processor-specific types.  */
d5477 1
a5477 1
  return TRUE;
d5487 2
a5488 1
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
d5503 2
a5504 1
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
d5525 3
a5527 2
_bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
				sec_ptr asect)
d5535 5
a5539 4
_bfd_elf_canonicalize_reloc (bfd *abfd,
			     sec_ptr section,
			     arelent **relptr,
			     asymbol **symbols)
d5543 1
a5543 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5545 1
a5545 1
  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
d5558 3
a5560 1
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
d5562 2
a5563 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
d5571 3
a5573 2
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
				      asymbol **allocation)
d5575 2
a5576 2
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);
d5589 2
a5590 1
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
d5622 4
a5625 3
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
				     arelent **storage,
				     asymbol **syms)
d5627 1
a5627 1
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
d5648 1
a5648 1
	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
d5665 3
a5667 2
bfd_boolean
_bfd_elf_slurp_version_tables (bfd *abfd)
d5684 1
a5684 1
      contents = bfd_malloc (hdr->sh_size);
d5688 1
a5688 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5708 1
a5708 1
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
d5730 1
a5730 1
	  iverdef->vd_auxptr = bfd_alloc (abfd, amt);
d5781 2
a5782 1
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
d5788 1
a5788 1
      contents = bfd_malloc (hdr->sh_size);
d5792 1
a5792 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5815 1
a5815 1
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);
d5852 1
a5852 1
  return TRUE;
d5855 1
a5855 1
  if (contents != NULL)
d5857 1
a5857 1
  return FALSE;
d5861 2
a5862 1
_bfd_elf_make_empty_symbol (bfd *abfd)
d5867 1
a5867 1
  newsym = bfd_zalloc (abfd, amt);
d5878 4
a5881 3
_bfd_elf_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			  asymbol *symbol,
			  symbol_info *ret)
d5890 4
a5893 3
bfd_boolean
_bfd_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *name)
d5897 1
a5897 1
    return TRUE;
d5902 1
a5902 1
    return TRUE;
d5911 1
a5911 1
    return TRUE;
d5913 1
a5913 1
  return FALSE;
d5917 3
a5919 2
_bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol ATTRIBUTE_UNUSED)
d5925 5
a5929 4
bfd_boolean
_bfd_elf_set_arch_mach (bfd *abfd,
			enum bfd_architecture arch,
			unsigned long machine)
d5936 1
a5936 1
    return FALSE;
d5944 9
a5952 7
static bfd_boolean
elf_find_function (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *section,
		   asymbol **symbols,
		   bfd_vma offset,
		   const char **filename_ptr,
		   const char **functionname_ptr)
d5993 1
a5993 1
    return FALSE;
d6000 1
a6000 1
  return TRUE;
d6006 10
a6015 8
bfd_boolean
_bfd_elf_find_nearest_line (bfd *abfd,
			    asection *section,
			    asymbol **symbols,
			    bfd_vma offset,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
d6017 1
a6017 1
  bfd_boolean found;
d6028 1
a6028 1
      return TRUE;
d6041 1
a6041 1
      return TRUE;
d6048 1
a6048 1
    return FALSE;
d6050 1
a6050 1
    return TRUE;
d6053 1
a6053 1
    return FALSE;
d6057 1
a6057 1
    return FALSE;
d6060 1
a6060 1
  return TRUE;
d6064 3
a6066 1
_bfd_elf_sizeof_headers (bfd *abfd, bfd_boolean reloc)
d6076 7
a6082 6
bfd_boolean
_bfd_elf_set_section_contents (bfd *abfd,
			       sec_ptr section,
			       const void *location,
			       file_ptr offset,
			       bfd_size_type count)
d6088 3
a6090 2
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
    return FALSE;
d6096 4
a6099 1
    return FALSE;
d6101 7
a6107 1
  return TRUE;
d6110 1
d6112 4
a6115 3
_bfd_elf_no_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *cache_ptr ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d6119 1
d6123 4
a6126 2
bfd_boolean
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
d6209 1
a6209 1
  return TRUE;
d6216 1
a6216 1
  return FALSE;
d6219 3
a6221 2
bfd_boolean
_bfd_elf_close_and_cleanup (bfd *abfd)
d6238 8
a6245 5
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd ATTRIBUTE_UNUSED, arelent *re ATTRIBUTE_UNUSED,
   struct bfd_symbol *symbol ATTRIBUTE_UNUSED,
   void *data ATTRIBUTE_UNUSED, asection *is ATTRIBUTE_UNUSED,
   bfd *obfd ATTRIBUTE_UNUSED, char **errmsg ATTRIBUTE_UNUSED)
d6262 2
a6263 1
elfcore_make_pid (bfd *abfd)
d6274 5
a6278 2
static bfd_boolean
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
d6283 1
a6283 1
    return TRUE;
d6287 1
a6287 1
    return FALSE;
d6293 1
a6293 1
  return TRUE;
d6303 6
a6308 5
bfd_boolean
_bfd_elfcore_make_pseudosection (bfd *abfd,
				 char *name,
				 size_t size,
				 ufile_ptr filepos)
d6319 1
a6319 1
  threaded_name = bfd_alloc (abfd, len);
d6321 1
a6321 1
    return FALSE;
d6324 1
a6324 1
  sect = bfd_make_section_anyway (abfd, threaded_name);
d6326 1
a6326 1
    return FALSE;
d6342 1
d6344 4
a6347 2
static bfd_boolean
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d6407 1
a6407 1
      return TRUE;
d6417 5
a6421 4
static bfd_boolean
elfcore_make_note_pseudosection (bfd *abfd,
				 char *name,
				 Elf_Internal_Note *note)
d6431 4
a6434 2
static bfd_boolean
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
d6443 4
a6446 2
static bfd_boolean
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
d6470 4
a6473 1
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
d6484 1
a6484 1
  dups = bfd_alloc (abfd, len + 1);
d6495 6
a6500 2
static bfd_boolean
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d6538 1
a6538 1
      return TRUE;
d6553 1
a6553 1
  return TRUE;
d6558 6
a6563 2
static bfd_boolean
elfcore_grok_pstatus (bfd *abfd, Elf_Internal_Note *note)
d6592 1
a6592 1
  return TRUE;
d6597 6
a6602 2
static bfd_boolean
elfcore_grok_lwpstatus (bfd *abfd, Elf_Internal_Note *note)
d6615 1
a6615 1
    return TRUE;
d6626 1
a6626 1
  name = bfd_alloc (abfd, len);
d6628 1
a6628 1
    return FALSE;
d6631 1
a6631 1
  sect = bfd_make_section_anyway (abfd, name);
d6633 1
a6633 1
    return FALSE;
d6650 1
a6650 1
    return FALSE;
d6656 1
a6656 1
  name = bfd_alloc (abfd, len);
d6658 1
a6658 1
    return FALSE;
d6661 1
a6661 1
  sect = bfd_make_section_anyway (abfd, name);
d6663 1
a6663 1
    return FALSE;
d6684 4
a6687 2
static bfd_boolean
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
d6696 1
a6696 1
    return TRUE;
d6713 1
a6713 1
      name = bfd_alloc (abfd, len);
d6715 1
a6715 1
	return FALSE;
d6719 1
a6719 1
      sect = bfd_make_section_anyway (abfd, name);
d6721 1
a6721 1
	return FALSE;
d6732 1
a6732 1
	  return FALSE;
d6740 1
a6740 1
      name = bfd_alloc (abfd, len);
d6742 1
a6742 1
	return FALSE;
d6746 1
a6746 1
      sect = bfd_make_section_anyway (abfd, name);
d6749 1
a6749 1
	return FALSE;
d6758 1
a6758 1
      return TRUE;
d6761 1
a6761 1
  return TRUE;
d6765 4
a6768 2
static bfd_boolean
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
d6770 1
a6770 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6775 1
a6775 1
      return TRUE;
d6780 1
a6780 1
	  return TRUE;
d6784 1
a6784 1
      return TRUE;
d6810 1
a6810 1
	return TRUE;
d6816 1
a6816 1
	  return TRUE;
d6820 1
a6820 1
      return TRUE;
a6821 14

    case NT_AUXV:
      {
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");

	if (sect == NULL)
	  return FALSE;
	sect->_raw_size = note->descsz;
	sect->filepos = note->descpos;
	sect->flags = SEC_HAS_CONTENTS;
	sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

	return TRUE;
      }
d6825 4
a6828 2
static bfd_boolean
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
d6836 1
a6836 1
      return TRUE;
d6838 1
a6838 1
  return FALSE;
d6841 4
a6844 2
static bfd_boolean
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
d6859 1
a6859 2
  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
					  note);
d6862 4
a6865 2
static bfd_boolean
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
d6888 1
a6888 1
    return TRUE;
d6907 1
a6907 1
          return TRUE;
d6923 1
a6923 1
          return TRUE;
a6928 106
static bfd_boolean
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, pid_t *tid)
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;
  short sig;
  unsigned flags;

  /* nto_procfs_status 'pid' field is at offset 0.  */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, (bfd_byte *) ddata);

  /* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
  *tid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'flags' field is at offset 8.  */
  flags = bfd_get_32 (abfd, (bfd_byte *) ddata + 8);

  /* nto_procfs_status 'what' field is at offset 14.  */
  if ((sig = bfd_get_16 (abfd, (bfd_byte *) ddata + 14)) > 0)
    {
      elf_tdata (abfd)->core_signal = sig;
      elf_tdata (abfd)->core_lwpid = *tid;
    }

  /* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores
     do not come from signals so we make sure we set the current
     thread just in case.  */
  if (flags & 0x00000080)
    elf_tdata (abfd)->core_lwpid = *tid;

  /* Make a ".qnx_core_status/%d" section.  */
  sprintf (buf, ".qnx_core_status/%d", *tid);

  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_gregs (bfd *abfd, Elf_Internal_Note *note, pid_t tid)
{
  char buf[100];
  char *name;
  asection *sect;

  /* Make a ".reg/%d" section.  */
  sprintf (buf, ".reg/%d", tid);

  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section_anyway (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  /* This is the current thread.  */
  if (elf_tdata (abfd)->core_lwpid == tid)
    return elfcore_maybe_make_sect (abfd, ".reg", sect);

  return TRUE;
}

#define BFD_QNT_CORE_INFO	7
#define BFD_QNT_CORE_STATUS	8
#define BFD_QNT_CORE_GREG	9
#define BFD_QNT_CORE_FPREG	10

static bfd_boolean
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
{
  /* Every GREG section has a STATUS section before it.  Store the
     tid from the previous call to pass down to the next gregs
     function.  */
  static pid_t tid = 1;

  switch (note->type)
    {
    case BFD_QNT_CORE_INFO:   return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS: return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:   return elfcore_grok_nto_gregs (abfd, note, tid);
    case BFD_QNT_CORE_FPREG:  return elfcore_grok_prfpreg (abfd, note);
    default:                  return TRUE;
    }
}

d6942 8
a6949 7
elfcore_write_note (bfd  *abfd,
		    char *buf,
		    int  *bufsiz,
		    const char *name,
		    int  type,
		    const void *input,
		    int  size)
d6961 1
a6961 1
      const struct elf_backend_data *bed;
d6965 1
a6965 1
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
d6968 1
a6968 1
  newspace = 12 + namesz + pad + size;
d6994 6
a6999 5
elfcore_write_prpsinfo (bfd  *abfd,
			char *buf,
			int  *bufsiz,
			const char *fname,
			const char *psargs)
d7022 7
a7028 6
elfcore_write_prstatus (bfd *abfd,
			char *buf,
			int *bufsiz,
			long pid,
			int cursig,
			const void *gregs)
d7044 7
a7050 6
elfcore_write_lwpstatus (bfd *abfd,
			 char *buf,
			 int *bufsiz,
			 long pid,
			 int cursig,
			 const void *gregs)
d7076 7
a7082 6
elfcore_write_pstatus (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       long pid,
		       int cursig,
		       const void *gregs)
d7096 6
a7101 5
elfcore_write_prfpreg (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *fpregs,
		       int size)
d7109 6
a7114 5
elfcore_write_prxfpreg (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *xfpregs,
			int size)
d7121 5
a7125 2
static bfd_boolean
elfcore_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
d7131 1
a7131 1
    return TRUE;
d7134 1
a7134 1
    return FALSE;
d7138 1
a7138 1
    return FALSE;
d7144 1
a7144 1
      return FALSE;
a7167 5
      else if (strncmp (in.namedata, "QNX", 3) == 0)
	{
	  if (! elfcore_grok_nto_note (abfd, &in))
	    goto error;
	}
d7178 1
a7178 1
  return TRUE;
d7188 2
a7189 1
bfd_get_elf_phdr_upper_bound (bfd *abfd)
d7209 3
a7211 1
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
d7229 4
a7232 1
_bfd_elf_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
d7260 4
a7263 1
_bfd_elf_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
d7292 2
a7293 1
_bfd_elf_reloc_type_class (const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
d7302 5
a7306 4
_bfd_elf_rela_local_sym (bfd *abfd,
			 Elf_Internal_Sym *sym,
			 asection **psec,
			 Elf_Internal_Rela *rel)
a7307 1
  asection *sec = *psec;
d7315 1
a7315 1
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d7317 3
d7321 1
a7321 1
	_bfd_merged_section_offset (abfd, psec,
d7324 3
a7326 4
				    0);
      sec = *psec;
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
d7332 5
a7336 4
_bfd_elf_rel_local_sym (bfd *abfd,
			Elf_Internal_Sym *sym,
			asection **psec,
			bfd_vma addend)
d7340 1
a7340 1
  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
d7345 1
a7345 1
				     sym->st_value + addend, 0);
d7349 5
a7353 4
_bfd_elf_section_offset (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 bfd_vma offset)
d7358 1
a7358 1
  switch (sec->sec_info_type)
d7361 3
a7363 3
      return _bfd_stab_section_offset (abfd,
				       &elf_hash_table (info)->merge_info,
				       sec, &sec_data->sec_info, offset);
a7368 24
}

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */

bfd *
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
{
  return (*get_elf_backend_data (templ)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, loadbasep, target_read_memory);
@


1.162
log
@        * bfd-in.h (bfd_get_dynamic_symcount): Define.
        * bfd.c (struct _bfd): Add dynsymcount.
        * bfd-in2.h: Regenerated.
        * elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
        abfd->dynsymcount.
        * elfcode.h (elf_slurp_reloc_table_from_section): Check
        for overflow.
@
text
@d3320 3
a3322 2
	       && (BFD_ALIGN (last_hdr->lma + last_hdr->_raw_size, maxpagesize)
		   == hdr->lma))
@


1.162.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d3320 2
a3321 3
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
@


1.162.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d6806 2
a6807 2
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
@


1.162.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2674 1
a2674 1
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
d2679 1
a2679 1
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d2685 1
d3453 4
a3456 3
  eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
  if (eh_frame_hdr != NULL
      && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)
d3465 1
a3465 1
      m->sections[0] = eh_frame_hdr->output_section;
d3963 5
d4041 2
a4042 1
  if (elf_tdata (abfd)->eh_frame_hdr)
d4563 7
d4605 3
a4607 1
    || IS_COREFILE_NOTE (segment, section))				\
d4852 1
d5089 1
d5109 1
d5115 14
a5128 1
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
d7361 3
a7363 3
      return _bfd_stab_section_offset (abfd,
				       &elf_hash_table (info)->merge_info,
				       sec, &sec_data->sec_info, offset);
@


1.162.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d18 1
a18 1
   along with this program; if not, write to the Free Software
d44 33
a76 56
  PARAMS ((bfd *, asection **, unsigned int, unsigned int, bfd_boolean));
static bfd_boolean map_sections_to_segments
  PARAMS ((bfd *));
static int elf_sort_sections
  PARAMS ((const PTR, const PTR));
static bfd_boolean assign_file_positions_for_segments
  PARAMS ((bfd *));
static bfd_boolean assign_file_positions_except_relocs
  PARAMS ((bfd *));
static bfd_boolean prep_headers
  PARAMS ((bfd *));
static bfd_boolean swap_out_syms
  PARAMS ((bfd *, struct bfd_strtab_hash **, int));
static bfd_boolean copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static char *elf_read
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static const char *group_signature
  PARAMS ((bfd *, Elf_Internal_Shdr *));
static bfd_boolean setup_group
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static void merge_sections_remove_hook
  PARAMS ((bfd *, asection *));
static void elf_fake_sections
  PARAMS ((bfd *, asection *, PTR));
static bfd_boolean assign_section_numbers
  PARAMS ((bfd *));
static INLINE int sym_is_global
  PARAMS ((bfd *, asymbol *));
static bfd_boolean elf_map_symbols
  PARAMS ((bfd *));
static bfd_size_type get_program_header_size
  PARAMS ((bfd *));
static bfd_boolean elfcore_read_notes
  PARAMS ((bfd *, file_ptr, bfd_size_type));
static bfd_boolean elf_find_function
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **));
static int elfcore_make_pid
  PARAMS ((bfd *));
static bfd_boolean elfcore_maybe_make_sect
  PARAMS ((bfd *, char *, asection *));
static bfd_boolean elfcore_make_note_pseudosection
  PARAMS ((bfd *, char *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_prxfpreg
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_note
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_netbsd_get_lwpid
  PARAMS ((Elf_Internal_Note *, int *));
static bfd_boolean elfcore_grok_netbsd_procinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elfcore_grok_netbsd_note
  PARAMS ((bfd *, Elf_Internal_Note *));
d273 1
a273 1
bfd_boolean
d282 1
a282 1
    return FALSE;
d286 1
a286 1
  return TRUE;
d289 1
a289 1
bfd_boolean
d504 1
a504 1
static bfd_boolean
d540 1
a540 1
	    return FALSE;
d563 1
a563 1
		    return FALSE;
d640 1
a640 1
		      return FALSE;
d663 1
a663 1
  return TRUE;
d666 1
a666 1
bfd_boolean
d682 1
a682 1
  return TRUE;
d688 1
a688 1
bfd_boolean
d702 1
a702 1
      return TRUE;
d707 1
a707 1
    return FALSE;
d715 1
a715 1
    return FALSE;
d743 1
a743 1
      return FALSE;
d780 1
a780 1
      return FALSE;
d783 1
a783 1
    return FALSE;
d854 1
a854 1
  return TRUE;
d958 1
a958 1
bfd_boolean
d964 1
a964 1
    return FALSE;
d968 1
a968 1
  return TRUE;
d987 1
a987 1
bfd_boolean
d994 1
a994 1
    return TRUE;
d1002 2
a1003 2
  elf_flags_init (obfd) = TRUE;
  return TRUE;
d1008 1
a1008 1
bfd_boolean
d1097 1
a1097 1
	  bfd_boolean stringp;
d1104 1
a1104 1
	  stringp = FALSE;
d1112 1
a1112 1
	    case DT_NEEDED: name = "NEEDED"; stringp = TRUE; break;
d1125 2
a1126 2
	    case DT_SONAME: name = "SONAME"; stringp = TRUE; break;
	    case DT_RPATH: name = "RPATH"; stringp = TRUE; break;
d1140 1
a1140 1
	    case DT_RUNPATH: name = "RUNPATH"; stringp = TRUE; break;
d1152 3
a1154 3
	    case DT_CONFIG: name = "CONFIG"; stringp = TRUE; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; stringp = TRUE; break;
	    case DT_AUDIT: name = "AUDIT"; stringp = TRUE; break;
d1166 1
a1166 1
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = TRUE; break;
d1168 1
a1168 1
	    case DT_FILTER: name = "FILTER"; stringp = TRUE; break;
d1195 1
a1195 1
	return FALSE;
d1237 1
a1237 1
  return TRUE;
d1242 1
a1242 1
  return FALSE;
d1394 1
a1396 1
      ret->elf_hash_value = 0;
d1398 2
d1402 1
a1403 1
      ret->vtable_entries_used = NULL;
a1404 3
      ret->got.refcount = htab->init_refcount;
      ret->plt.refcount = htab->init_refcount;
      ret->size = 0;
d1476 1
a1476 1
     bfd_boolean force_local;
d1494 1
a1494 1
bfd_boolean
d1498 3
a1500 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d1502 1
a1502 1
  bfd_boolean ret;
d1504 1
a1504 1
  table->dynamic_sections_created = FALSE;
d1506 1
a1506 4
  /* Make sure can_refcount is extended to the width and signedness of
     init_refcount before we subtract one from it.  */
  table->init_refcount = get_elf_backend_data (abfd)->can_refcount;
  --table->init_refcount;
d1512 2
a1516 1
  memset (&table->eh_info, 0, sizeof (table->eh_info));
d1518 1
a1518 5
  table->runpath = NULL;
  table->tls_segment = NULL;
  table->loaded = NULL;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d1614 1
a1614 1
bfd_boolean
d1631 1
a1631 1
    return TRUE;
d1635 1
a1635 1
    return TRUE;
d1690 1
a1690 1
  return TRUE;
d1695 1
a1695 1
  return FALSE;
d1710 1
a1710 1
      loc = _bfd_stringtab_add (ret, "", TRUE, FALSE);
d1725 1
a1725 1
bfd_boolean
d1741 1
a1741 1
      return TRUE;
d1754 1
a1754 1
	return FALSE;
d1787 1
a1787 1
	return TRUE;
d1805 1
a1805 1
	return FALSE;
d1807 1
a1807 1
      return TRUE;
d1811 1
a1811 1
	return TRUE;
d1826 1
a1826 1
	return TRUE;
d1831 1
a1831 1
	return FALSE;
d1836 1
a1836 1
      return TRUE;
d1840 1
a1840 1
	return TRUE;
d1845 1
a1845 1
	  return TRUE;
d1857 1
a1857 1
		  return FALSE;
d1863 1
a1863 1
		    return TRUE;
d1943 1
a1943 1
	  return FALSE;
d1955 1
a1955 1
	  return FALSE;
d1958 1
a1958 1
	  return FALSE;
d1983 1
a1983 1
	return TRUE;
d2006 1
a2006 1
      return TRUE;
d2014 1
a2014 1
	return FALSE;
d2016 1
a2016 1
	return FALSE;
d2046 1
a2046 1
  return TRUE;
d2103 1
a2103 1
bfd_boolean
d2113 1
a2113 1
    return FALSE;
d2120 1
a2120 1
  return TRUE;
d2145 1
a2145 1
bfd_boolean
d2165 1
a2165 1
    return FALSE;
d2169 1
a2169 1
    return FALSE;
d2197 1
a2197 1
	return FALSE;
d2201 1
a2201 1
	return FALSE;
d2215 1
a2215 1
  return TRUE;
d2218 1
a2218 1
bfd_boolean
d2242 1
a2242 1
	return FALSE;
d2244 2
a2245 2
	return FALSE;
      return TRUE;
d2265 1
a2265 1
   relocations against ASECT.  If USE_RELA_P is TRUE, we use RELA
d2268 1
a2268 1
bfd_boolean
d2273 1
a2273 1
     bfd_boolean use_rela_p;
d2281 1
a2281 1
    return FALSE;
d2285 1
a2285 1
					FALSE);
d2287 1
a2287 1
    return FALSE;
d2298 1
a2298 1
  return TRUE;
d2310 1
a2310 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2323 1
a2323 1
							   asect->name, FALSE);
d2326 1
a2326 1
      *failedptr = TRUE;
d2453 1
a2453 1

d2466 1
a2466 1
    *failedptr = TRUE;
d2477 1
a2477 1
    *failedptr = TRUE;
d2488 1
a2488 1
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
d2493 1
a2493 1
  bfd_boolean gas;
d2515 1
a2515 1
  gas = TRUE;
d2518 1
a2518 1
      gas = FALSE;
d2525 1
a2525 1
	  *failedptr = TRUE;
d2591 1
a2591 1
static bfd_boolean
d2653 1
a2653 1
						  ".symtab_shndx", FALSE);
d2655 1
a2655 1
	    return FALSE;
d2676 1
a2676 1
    return FALSE;
d2683 1
a2683 1
      return FALSE;
d2767 1
a2767 1
		return FALSE;
d2816 1
a2816 1
  return TRUE;
d2837 1
a2837 1
static bfd_boolean
d2869 1
a2869 1
    return FALSE;
d2944 1
a2944 1
    return FALSE;
d2979 1
a2979 1
  return TRUE;
d2985 1
a2985 2
static INLINE file_ptr align_file_position
  PARAMS ((file_ptr, int));
d3001 1
a3001 1
     bfd_boolean align;
d3023 1
a3023 1
bfd_boolean
d3029 1
a3029 1
  bfd_boolean failed;
d3034 1
a3034 1
    return TRUE;
d3041 1
a3041 1
    return FALSE;
d3047 1
a3047 1
  failed = FALSE;
d3050 1
a3050 1
    return FALSE;
d3053 1
a3053 1
    return FALSE;
d3062 1
a3062 1
	return FALSE;
d3069 1
a3069 1
	return FALSE;
d3085 1
a3085 1
    return FALSE;
d3095 1
a3095 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3099 1
a3099 1
	off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3102 1
a3102 1
      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d3110 1
a3110 1
	return FALSE;
d3114 1
a3114 1
  abfd->output_has_begun = TRUE;
d3116 1
a3116 1
  return TRUE;
d3127 1
a3127 1
     bfd_boolean phdr;
d3157 1
a3157 1
static bfd_boolean
d3172 2
a3173 2
  bfd_boolean phdr_in_segment = TRUE;
  bfd_boolean writable;
d3180 1
a3180 1
    return TRUE;
d3183 1
a3183 1
    return TRUE;
d3250 1
a3250 1
  writable = FALSE;
d3270 1
a3270 1
	phdr_in_segment = FALSE;
d3276 1
a3276 1
      bfd_boolean new_segment;
d3287 1
a3287 1
	  new_segment = FALSE;
d3294 1
a3294 1
	  new_segment = TRUE;
d3301 1
a3301 1
	  new_segment = TRUE;
d3308 1
a3308 1
	  new_segment = TRUE;
d3315 1
a3315 1
	  new_segment = FALSE;
d3330 1
a3330 1
	  new_segment = TRUE;
d3335 1
a3335 1
	  new_segment = FALSE;
d3341 1
a3341 1
	    writable = TRUE;
d3357 1
a3357 1
	writable = TRUE;
d3359 1
a3359 1
	writable = FALSE;
d3363 1
a3363 1
      phdr_in_segment = FALSE;
d3473 1
a3473 1
  return TRUE;
d3478 1
a3478 1
  return FALSE;
d3541 1
a3541 1
static bfd_boolean
d3559 1
a3559 1
	return FALSE;
d3596 1
a3596 1
	return FALSE;
d3608 1
a3608 1
    return TRUE;
d3620 1
a3620 1
      return FALSE;
d3629 1
a3629 1
    return FALSE;
d3725 1
a3725 1
		  return FALSE;
d3852 1
a3852 1
		      return FALSE;
d3975 1
a3975 1
    return FALSE;
d3977 1
a3977 1
  return TRUE;
d4086 1
a4086 1
static bfd_boolean
d4123 1
a4123 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d4140 1
a4140 1
	return FALSE;
d4166 1
a4166 1
							       FALSE);
d4175 1
a4175 1
	    off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);
d4192 1
a4192 1
  return TRUE;
d4195 1
a4195 1
static bfd_boolean
d4210 1
a4210 1
    return FALSE;
d4288 1
a4288 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", FALSE);
d4290 1
a4290 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", FALSE);
d4292 1
a4292 1
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", FALSE);
d4296 1
a4296 1
    return FALSE;
d4298 1
a4298 1
  return TRUE;
d4322 1
a4322 1
	off = _bfd_elf_assign_file_position_for_section (shdrp, off, TRUE);
d4328 1
a4328 1
bfd_boolean
d4335 1
a4335 1
  bfd_boolean failed;
d4341 1
a4341 1
    return FALSE;
d4346 1
a4346 1
  failed = FALSE;
d4349 1
a4349 1
    return FALSE;
d4365 1
a4365 1
	    return FALSE;
d4374 1
a4374 1
    return FALSE;
d4383 1
a4383 1
bfd_boolean
d4501 1
a4501 1
static bfd_boolean
d4506 13
a4518 13
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = FALSE;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
  struct elf_backend_data *bed;
d4522 1
a4522 1
    return TRUE;
d4525 1
a4525 1
    return TRUE;
d4541 1
a4541 1
  /* Returns TRUE if the given section is contained within
d4548 1
a4548 1
  /* Returns TRUE if the given section is contained within
d4594 1
a4594 1
  /* Returns TRUE iff seg1 starts after the end of seg2.  */
d4598 1
a4598 1
  /* Returns TRUE iff seg1 and seg2 overlap.  */
d4605 1
a4605 1
    section->segment_mark = FALSE;
d4710 1
a4710 1
	return FALSE;
d4737 1
a4737 1
	    phdr_included = TRUE;
d4791 1
a4791 1
	return FALSE;
d4972 1
a4972 1
		  section->segment_mark = TRUE;
d4993 1
a4993 1
		return FALSE;
d5076 1
a5076 1
  return TRUE;
d5082 1
a5082 1
bfd_boolean
d5093 1
a5093 1
    return TRUE;
d5109 1
a5109 1
	      return FALSE;
d5133 1
a5133 1
  return TRUE;
d5148 1
a5148 1
bfd_boolean
d5159 1
a5159 1
    return TRUE;
d5184 1
a5184 1
  return TRUE;
d5189 1
a5189 1
static bfd_boolean
d5208 1
a5208 1
    return FALSE;
d5213 1
a5213 1
    return FALSE;
d5230 1
a5230 1
    return FALSE;
d5240 1
a5240 1
	return FALSE;
d5282 1
a5282 1
							    TRUE, FALSE);
d5284 1
a5284 1
	    return FALSE;
d5444 1
a5444 1
  return TRUE;
d5512 1
a5512 1
  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
d5530 1
a5530 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, FALSE);
d5543 1
a5543 1
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, TRUE);
d5594 1
a5594 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d5615 1
a5615 1
	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
d5632 1
a5632 1
bfd_boolean
d5819 1
a5819 1
  return TRUE;
d5824 1
a5824 1
  return FALSE;
d5857 1
a5857 1
bfd_boolean
d5864 1
a5864 1
    return TRUE;
d5869 1
a5869 1
    return TRUE;
d5878 1
a5878 1
    return TRUE;
d5880 1
a5880 1
  return FALSE;
d5892 1
a5892 1
bfd_boolean
d5903 1
a5903 1
    return FALSE;
d5911 1
a5911 1
static bfd_boolean
d5960 1
a5960 1
    return FALSE;
d5967 1
a5967 1
  return TRUE;
d5973 1
a5973 1
bfd_boolean
d5984 1
a5984 1
  bfd_boolean found;
d5995 1
a5995 1
      return TRUE;
d6008 1
a6008 1
      return TRUE;
d6015 1
a6015 1
    return FALSE;
d6017 1
a6017 1
    return TRUE;
d6020 1
a6020 1
    return FALSE;
d6024 1
a6024 1
    return FALSE;
d6027 1
a6027 1
  return TRUE;
d6033 1
a6033 1
     bfd_boolean reloc;
d6043 1
a6043 1
bfd_boolean
d6057 1
a6057 1
    return FALSE;
d6063 1
a6063 1
    return FALSE;
d6065 1
a6065 1
  return TRUE;
d6077 11
d6090 1
a6090 1
bfd_boolean
d6176 1
a6176 1
  return TRUE;
d6183 1
a6183 1
  return FALSE;
d6186 1
a6186 1
bfd_boolean
d6241 1
a6241 1
static bfd_boolean
d6250 1
a6250 1
    return TRUE;
d6254 1
a6254 1
    return FALSE;
d6260 1
a6260 1
  return TRUE;
d6270 1
a6270 1
bfd_boolean
d6288 1
a6288 1
    return FALSE;
d6293 1
a6293 1
    return FALSE;
d6309 1
a6309 2
static bfd_boolean elfcore_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d6311 1
a6311 1
static bfd_boolean
d6374 1
a6374 1
      return TRUE;
d6384 1
a6384 1
static bfd_boolean
d6398 1
a6398 1
static bfd_boolean
d6410 1
a6410 1
static bfd_boolean
d6462 1
a6462 2
static bfd_boolean elfcore_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
d6464 1
a6464 1
static bfd_boolean
d6505 1
a6505 1
      return TRUE;
d6520 1
a6520 1
  return TRUE;
d6525 1
a6525 2
static bfd_boolean elfcore_grok_pstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d6527 1
a6527 1
static bfd_boolean
d6559 1
a6559 1
  return TRUE;
d6564 1
a6564 2
static bfd_boolean elfcore_grok_lwpstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d6566 1
a6566 1
static bfd_boolean
d6582 1
a6582 1
    return TRUE;
d6595 1
a6595 1
    return FALSE;
d6600 1
a6600 1
    return FALSE;
d6617 1
a6617 1
    return FALSE;
d6625 1
a6625 1
    return FALSE;
d6630 1
a6630 1
    return FALSE;
d6651 1
a6651 1
static bfd_boolean
d6663 1
a6663 1
    return TRUE;
d6682 1
a6682 1
	return FALSE;
d6688 1
a6688 1
	return FALSE;
d6699 1
a6699 1
	  return FALSE;
d6709 1
a6709 1
	return FALSE;
d6716 1
a6716 1
	return FALSE;
d6725 1
a6725 1
      return TRUE;
d6728 1
a6728 1
  return TRUE;
d6732 1
a6732 1
static bfd_boolean
d6742 1
a6742 1
      return TRUE;
d6747 1
a6747 1
	  return TRUE;
d6751 1
a6751 1
      return TRUE;
d6777 1
a6777 1
	return TRUE;
d6783 1
a6783 1
	  return TRUE;
d6787 1
a6787 1
      return TRUE;
d6792 1
a6792 1
static bfd_boolean
d6803 1
a6803 1
      return TRUE;
d6805 1
a6805 1
  return FALSE;
d6808 1
a6808 1
static bfd_boolean
d6826 1
a6826 1
  return TRUE;
d6829 1
a6829 1
static bfd_boolean
d6855 1
a6855 1
    return TRUE;
d6874 1
a6874 1
          return TRUE;
d6890 1
a6890 1
          return TRUE;
d7088 1
a7088 1
static bfd_boolean
d7098 1
a7098 1
    return TRUE;
d7101 1
a7101 1
    return FALSE;
d7105 1
a7105 1
    return FALSE;
d7111 1
a7111 1
      return FALSE;
d7145 1
a7145 1
  return TRUE;
@


1.162.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a478 17
/* Look up a symbol name.  */
const char *
bfd_elf_local_sym_name (abfd, isym)
     bfd *abfd;
     Elf_Internal_Sym *isym;
{
  unsigned int iname = isym->st_name;
  unsigned int shindex = elf_tdata (abfd)->symtab_hdr.sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym->st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym->st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

d500 2
d513 10
a522 1
  return bfd_elf_local_sym_name (abfd, &isym);
d972 5
a976 2
  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
  sec->sec_info_type = ELF_INFO_TYPE_NONE;
d1004 1
a1004 1
  sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
d1426 2
a1427 2
      ret->got = htab->init_refcount;
      ret->plt = htab->init_refcount;
d1502 1
a1502 1
  h->plt = elf_hash_table (info)->init_offset;
d1532 2
a1533 3
  table->init_refcount.refcount = get_elf_backend_data (abfd)->can_refcount;
  table->init_refcount.refcount -= 1;
  table->init_offset.offset = -(bfd_vma) 1;
d2010 2
a2011 1
	  target_sect->use_rela_p = hdr->sh_type == SHT_RELA;
d2139 1
d2141 4
a2144 9
  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == NULL)
    {
      bfd_size_type amt = sizeof (*sdata);
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, amt);
      if (sdata == NULL)
	return FALSE;
      sec->used_by_bfd = (PTR) sdata;
    }
d2147 2
a2148 1
  sec->use_rela_p = get_elf_backend_data (abfd)->default_use_rela_p;
d2506 1
a2506 1
				    asect->use_rela_p))
a3520 1
  bfd_size_type size1, size2;
d3538 1
a3538 1
#define TOEND(x) (((x)->flags & (SEC_LOAD|SEC_THREAD_LOCAL)) == 0)
d3560 1
a3560 4
  size1 = (sec1->flags & SEC_LOAD) ? sec1->_raw_size : 0;
  size2 = (sec2->flags & SEC_LOAD) ? sec2->_raw_size : 0;

  if (size1 < size2)
d3562 1
a3562 1
  if (size1 > size2)
d3843 3
a3845 9
	      if (p->p_type == PT_LOAD
		  || (p->p_type == PT_NOTE
		      && bfd_get_format (abfd) == bfd_core))
		{
		  off += adjust;
		  voff += adjust;
		}
	      if ((flags & SEC_LOAD) != 0
		  || (flags & SEC_THREAD_LOCAL) != 0)
d3902 1
a3902 3
	      if ((flags & SEC_ALLOC) != 0
		  && ((flags & SEC_LOAD) != 0
		      || (flags & SEC_THREAD_LOCAL) == 0))
a3928 3
	      if ((sec->flags & SEC_LOAD) != 0
		  || (sec->flags & SEC_THREAD_LOCAL) == 0
		  || p->p_type == PT_TLS)
a4571 5
#define SECTION_SIZE(section, segment)					\
  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))		\
    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)			\
   ? section->_raw_size : 0)

d4576 1
a4576 1
   && (section->vma + SECTION_SIZE (section, segment)			\
d4583 1
a4583 1
   && (section->lma + SECTION_SIZE (section, segment)			\
d4615 1
a4615 3
       4. The section has not already been allocated to a previous segment.
       5. PT_TLS segment includes only SHF_TLS sections.
       6. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
a4622 5
   && (segment->p_type != PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL))				\
   && (segment->p_type == PT_LOAD					\
       || segment->p_type == PT_TLS					\
       || (section->flags & SEC_THREAD_LOCAL) == 0)			\
a5099 1
#undef SECTION_SIZE
d5161 2
a5162 1
  osec->use_rela_p = isec->use_rela_p;
d5279 1
a5279 1
  /* Now generate the data (for "contents").  */
a5344 1

d5396 1
a5396 10
		  if (sec2 == NULL)
		    {
		      _bfd_error_handler (_("\
Unable to find equivalent output section for symbol '%s' from section '%s'"),
					  syms[idx]->name ? syms[idx]->name : "<Local sym>",
					  sec->name);
		      bfd_set_error (bfd_error_invalid_operation);      
		      return FALSE;
		    }
  
d5417 1
a5417 1
      /* Processor-specific types.  */
d7307 1
a7307 1
      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
d7332 1
a7332 1
  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
d7350 1
a7350 1
  switch (sec->sec_info_type)
@


1.162.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@a99 6
static bfd_boolean elfcore_grok_nto_gregs
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t));
static bfd_boolean elfcore_grok_nto_status
  PARAMS ((bfd *, Elf_Internal_Note *, pid_t *));
static bfd_boolean elfcore_grok_nto_note
  PARAMS ((bfd *, Elf_Internal_Note *));
d3545 1
a3545 1
#define TOEND(x) (((x)->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0)
d4659 2
a4660 2
#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)			\
  (seg1->field >= SEGMENT_END (seg2, seg2->field))
d4662 1
a4662 6
  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both
     their VMA address ranges and their LMA address ranges overlap.
     It is possible to have overlapping VMA ranges without overlapping LMA
     ranges.  RedBoot images for example can have both .data and .bss mapped
     to the same VMA range, but with the .data section mapped to a different
     LMA.  */
d4664 2
a4665 4
  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr)) 		\
   && !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_paddr)			\
        || SEGMENT_AFTER_SEGMENT (seg2, seg1, p_paddr)))
d4763 2
a4764 3
      for (section = ibfd->sections, section_count = 0;
	   section != NULL;
	   section = section->next)
d4767 3
a4769 3
 
      /* Allocate a segment map big enough to contain
	 all of the sections we have selected.  */
d4841 1
a4841 1
	 4. The sections have been moved, but not by the same amount.
d5085 4
a5088 2
    for (map = map_first; map != NULL; map = map->next)
      map->p_paddr_valid = 0;
a6963 98
static bfd_boolean
elfcore_grok_nto_status (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t *tid;
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;

  /* nto_procfs_status 'pid' field is at offset 0.  */
  elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, (bfd_byte *) ddata);

  /* nto_procfs_status 'tid' field is at offset 4.  */
  elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'what' field is at offset 14.  */
  elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, (bfd_byte *) ddata + 14);

  /* Pass tid back.  */
  *tid = elf_tdata (abfd)->core_lwpid;

  /* Make a ".qnx_core_status/%d" section.  */
  sprintf (buf, ".qnx_core_status/%d", *tid);

  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_gregs (abfd, note, tid)
     bfd *abfd;
     Elf_Internal_Note *note;
     pid_t tid;
{
  char buf[100];
  char *name;
  asection *sect;

  /* Make a ".reg/%d" section.  */
  sprintf (buf, ".reg/%d", tid);

  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return FALSE;

  sect->_raw_size       = note->descsz;
  sect->filepos         = note->descpos;
  sect->flags           = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, ".reg", sect);
}

#define BFD_QNT_CORE_INFO	7
#define BFD_QNT_CORE_STATUS	8
#define BFD_QNT_CORE_GREG	9
#define BFD_QNT_CORE_FPREG	10

static bfd_boolean
elfcore_grok_nto_note (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  /* Every GREG section has a STATUS section before it.  Store the
     tid from the previous call to pass down to the next gregs 
     function.  */
  static pid_t tid = 1;

  switch (note->type)
    {
    case BFD_QNT_CORE_INFO:   return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case BFD_QNT_CORE_STATUS: return elfcore_grok_nto_status (abfd, note, &tid);
    case BFD_QNT_CORE_GREG:   return elfcore_grok_nto_gregs (abfd, note, tid);
    case BFD_QNT_CORE_FPREG:  return elfcore_grok_prfpreg (abfd, note);
    default:                  return TRUE;
    }
}

a7202 5
      else if (strncmp (in.namedata, "QNX", 3) == 0)
	{
	  if (! elfcore_grok_nto_note (abfd, &in))
	    goto error;
	}
@


1.162.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d5071 1
a5071 4
		{
		  free (sections);
		  return FALSE;
		}
d5306 1
a5306 4
    {
      _bfd_stringtab_free (stt);
      return FALSE;
    }
d5316 1
a5316 5
	{
	  _bfd_stringtab_free (stt);
	  return FALSE;
	}

d5360 1
a5360 4
	    {
	      _bfd_stringtab_free (stt);
	      return FALSE;
	    }
a5448 1
		      _bfd_stringtab_free (stt);
d5909 1
a5909 1
  if (contents != NULL)
@


1.162.2.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a2294 4
    case PT_GNU_EH_FRAME:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index,
					      "eh_frame_hdr");

d4781 1
a4781 1

d5461 1
a5461 1
		      bfd_set_error (bfd_error_invalid_operation);
d5465 1
a5465 1

d7074 1
a7074 1
     tid from the previous call to pass down to the next gregs
@


1.162.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d274 1
a274 1
  return h & 0xffffffff;
d1619 1
a1619 1
  if (! is_elf_hash_table (info))
d1632 1
a1632 1
  if (! is_elf_hash_table (info))
d2338 1
a2338 1
  rel_hdr->sh_addralign = 1 << bed->s->log_file_align;
d2368 3
a2370 3
  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),
							  asect->name, FALSE);
  if (this_hdr->sh_name == (unsigned int) -1)
d3751 1
a3751 1
	p->p_align = 1 << bed->s->log_file_align;
d4248 1
a4248 1
  off = align_file_position (off, 1 << bed->s->log_file_align);
d5305 1
a5305 1
  symtab_hdr->sh_addralign = 1 << bed->s->log_file_align;
a6886 14

    case NT_AUXV:
      {
	asection *sect = bfd_make_section (abfd, ".auxv");

	if (sect == NULL)
	  return FALSE;
	sect->_raw_size = note->descsz;
	sect->filepos = note->descpos;
	sect->flags = SEC_HAS_CONTENTS;
	sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

	return TRUE;
      }
d7128 1
a7128 1
      pad = -namesz & ((1 << bed->s->log_file_align) - 1);
a7536 24
}

/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
   reconstruct an ELF file by reading the segments out of remote memory
   based on the ELF file header at EHDR_VMA and the ELF program headers it
   points to.  If not null, *LOADBASEP is filled in with the difference
   between the VMAs from which the segments were read, and the VMAs the
   file headers (and hence BFD's idea of each section's VMA) put them at.

   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
   remote memory at target address VMA into the local buffer at MYADDR; it
   should return zero on success or an `errno' code on failure.  TEMPL must
   be a BFD for an ELF target with the word size and byte order found in
   the remote memory.  */

bfd *
bfd_elf_bfd_from_remote_memory (templ, ehdr_vma, loadbasep, target_read_memory)
     bfd *templ;
     bfd_vma ehdr_vma;
     bfd_vma *loadbasep;
     int (*target_read_memory) PARAMS ((bfd_vma vma, char *myaddr, int len));
{
  return (*get_elf_backend_data (templ)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, loadbasep, target_read_memory);
@


1.162.2.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d939 1
a939 1
/* ELF relocs are against symbols.  If we are producing relocatable
d947 1
a947 1
   relocatable output against an external symbol.  */
a1072 1
	    case PT_GNU_STACK: pt = "STACK"; break;
d1840 1
a1840 1
         set in a relocatable object file, which would confuse the
a2298 3
    case PT_GNU_STACK:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, index, "stack");

a3515 15
  if (elf_tdata (abfd)->stack_flags)
    {
      amt = sizeof (struct elf_segment_map);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_GNU_STACK;
      m->p_flags = elf_tdata (abfd)->stack_flags;
      m->p_flags_valid = 1;

      *pm = m;
      pm = &m->next;
    }

a4101 6
  if (elf_tdata (abfd)->stack_flags)
    {
      /* We need a PT_GNU_STACK segment.  */
      ++segs;
    }

a7017 2
  short sig;
  unsigned flags;
d7022 2
a7023 5
  /* nto_procfs_status 'tid' field is at offset 4.  Pass it back.  */
  *tid = bfd_get_32 (abfd, (bfd_byte *) ddata + 4);

  /* nto_procfs_status 'flags' field is at offset 8.  */
  flags = bfd_get_32 (abfd, (bfd_byte *) ddata + 8);
d7026 1
a7026 5
  if ((sig = bfd_get_16 (abfd, (bfd_byte *) ddata + 14)) > 0)
    {
      elf_tdata (abfd)->core_signal = sig;
      elf_tdata (abfd)->core_lwpid = *tid;
    }
d7028 2
a7029 5
  /* _DEBUG_FLAG_CURTID (current thread) is 0x80.  Some cores
     do not come from signals so we make sure we set the current
     thread just in case.  */
  if (flags & 0x00000080)
    elf_tdata (abfd)->core_lwpid = *tid;
d7078 1
a7078 5
  /* This is the current thread.  */
  if (elf_tdata (abfd)->core_lwpid == tid)
    return elfcore_maybe_make_sect (abfd, ".reg", sect);

  return TRUE;
@


1.162.2.11
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d43 63
a105 5
static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct bfd_strtab_hash **, int) ;
static bfd_boolean elfcore_read_notes (bfd *, file_ptr, bfd_size_type) ;
d114 4
a117 3
_bfd_elf_swap_verdef_in (bfd *abfd,
			 const Elf_External_Verdef *src,
			 Elf_Internal_Verdef *dst)
d131 4
a134 3
_bfd_elf_swap_verdef_out (bfd *abfd,
			  const Elf_Internal_Verdef *src,
			  Elf_External_Verdef *dst)
d148 4
a151 3
_bfd_elf_swap_verdaux_in (bfd *abfd,
			  const Elf_External_Verdaux *src,
			  Elf_Internal_Verdaux *dst)
d160 4
a163 3
_bfd_elf_swap_verdaux_out (bfd *abfd,
			   const Elf_Internal_Verdaux *src,
			   Elf_External_Verdaux *dst)
d172 4
a175 3
_bfd_elf_swap_verneed_in (bfd *abfd,
			  const Elf_External_Verneed *src,
			  Elf_Internal_Verneed *dst)
d187 4
a190 3
_bfd_elf_swap_verneed_out (bfd *abfd,
			   const Elf_Internal_Verneed *src,
			   Elf_External_Verneed *dst)
d202 4
a205 3
_bfd_elf_swap_vernaux_in (bfd *abfd,
			  const Elf_External_Vernaux *src,
			  Elf_Internal_Vernaux *dst)
d217 4
a220 3
_bfd_elf_swap_vernaux_out (bfd *abfd,
			   const Elf_Internal_Vernaux *src,
			   Elf_External_Vernaux *dst)
d232 4
a235 3
_bfd_elf_swap_versym_in (bfd *abfd,
			 const Elf_External_Versym *src,
			 Elf_Internal_Versym *dst)
d243 4
a246 3
_bfd_elf_swap_versym_out (bfd *abfd,
			  const Elf_Internal_Versym *src,
			  Elf_External_Versym *dst)
d255 2
a256 1
bfd_elf_hash (const char *namearg)
d282 4
a285 1
elf_read (bfd *abfd, file_ptr offset, bfd_size_type size)
d293 1
a293 1
  if (bfd_bread (buf, size, abfd) != size)
d303 2
a304 1
bfd_elf_mkobject (bfd *abfd)
d308 2
a309 1
  elf_tdata (abfd) = bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
d319 2
a320 1
bfd_elf_mkcorefile (bfd *abfd)
d327 3
a329 1
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
d347 1
a347 1
      i_shdrp[shindex]->contents = shstrtab;
d353 4
a356 3
bfd_elf_string_from_elf_section (bfd *abfd,
				 unsigned int shindex,
				 unsigned int strindex)
d391 9
a399 7
bfd_elf_get_elf_syms (bfd *ibfd,
		      Elf_Internal_Shdr *symtab_hdr,
		      size_t symcount,
		      size_t symoffset,
		      Elf_Internal_Sym *intsym_buf,
		      void *extsym_buf,
		      Elf_External_Sym_Shndx *extshndx_buf)
d402 1
a402 1
  void *alloc_ext;
d449 1
a449 1
	  alloc_extshndx = bfd_malloc (amt);
d464 1
a464 1
      intsym_buf = bfd_malloc (amt);
d474 1
a474 1
    (*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym);
d487 3
a489 1
bfd_elf_local_sym_name (bfd *abfd, Elf_Internal_Sym *isym)
d515 3
a517 1
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
d540 4
a543 1
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
d702 3
a704 1
bfd_elf_discard_group (bfd *abfd ATTRIBUTE_UNUSED, asection *group)
d724 4
a727 3
_bfd_elf_make_section_from_shdr (bfd *abfd,
				 Elf_Internal_Shdr *hdr,
				 const char *name)
a743 4
  /* Always use the real type/flags.  */
  elf_section_type (newsect) = hdr->sh_type;
  elf_section_flags (newsect) = hdr->sh_flags;

d908 3
a910 1
bfd_elf_find_section (bfd *abfd, char *name)
d950 14
a963 7
bfd_elf_generic_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *reloc_entry,
		       asymbol *symbol,
		       void *data ATTRIBUTE_UNUSED,
		       asection *input_section,
		       bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d965 1
a965 1
  if (output_bfd != NULL
d980 3
a982 2
merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
			    asection *sec)
d991 3
a993 1
_bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
d1004 3
a1006 1
_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
d1020 3
a1022 1
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d1041 3
a1043 1
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
d1045 1
a1045 1
  FILE *f = farg;
d1104 1
a1104 1
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1108 1
a1108 1
      dynbuf = bfd_malloc (s->_raw_size);
d1111 2
a1112 1
      if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1132 1
a1132 1
	  (*swap_dyn_in) (abfd, extdyn, &dyn);
d1281 5
a1285 4
bfd_elf_print_symbol (bfd *abfd,
		      void *filep,
		      asymbol *symbol,
		      bfd_print_symbol_type how)
d1287 1
a1287 1
  FILE *file = filep;
d1315 1
a1315 1
	    bfd_print_symbol_vandf (abfd, file, symbol);
d1404 4
a1407 3
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
d1431 1
d1455 3
a1457 3
_bfd_elf_link_hash_copy_indirect (struct elf_backend_data *bed,
				  struct elf_link_hash_entry *dir,
				  struct elf_link_hash_entry *ind)
d1507 4
a1510 3
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				bfd_boolean force_local)
d1529 6
a1534 6
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      struct bfd_hash_table *,
				      const char *))
d1568 2
a1569 1
_bfd_elf_link_hash_table_create (bfd *abfd)
d1574 2
a1575 2
  ret = bfd_malloc (amt);
  if (ret == NULL)
d1593 3
a1595 1
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
d1603 3
a1605 1
bfd_elf_set_dt_needed_soname (bfd *abfd, const char *name)
d1616 3
a1618 2
bfd_elf_get_needed_list (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info)
d1629 3
a1631 2
bfd_elf_get_runpath_list (bfd *abfd ATTRIBUTE_UNUSED,
			  struct bfd_link_info *info)
d1643 2
a1644 1
bfd_elf_get_dt_soname (bfd *abfd)
d1656 3
a1658 2
bfd_elf_get_bfd_needed_list (bfd *abfd,
			     struct bfd_link_needed_list **pneeded)
d1666 1
a1666 1
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
d1678 1
a1678 1
  dynbuf = bfd_malloc (s->_raw_size);
d1682 2
a1683 1
  if (! bfd_get_section_contents (abfd, s, dynbuf, 0, s->_raw_size))
d1701 1
a1701 1
      (*swap_dyn_in) (abfd, extdyn, &dyn);
d1718 1
a1718 1
	  l = bfd_alloc (abfd, amt);
d1742 1
a1742 1
_bfd_elf_stringtab_init (void)
d1767 3
a1769 1
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
d2009 1
a2009 1
	    hdr2 = bfd_alloc (abfd, amt);
d2093 5
a2097 4
bfd_section_from_r_symndx (bfd *abfd,
			   struct sym_sec_cache *cache,
			   asection *sec,
			   unsigned long r_symndx)
d2120 1
a2120 2
  if ((isym.st_shndx != SHN_UNDEF && isym.st_shndx < SHN_LORESERVE)
      || isym.st_shndx > SHN_HIRESERVE)
d2134 3
a2136 1
bfd_section_from_elf_index (bfd *abfd, unsigned int index)
a2142 102
static struct bfd_elf_special_section const special_sections[] =
{
  { ".bss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".comment",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".data",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".data1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".debug",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".fini",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".line",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".rodata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".rodata1",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".tbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",	0,	NULL,	0,
    SHT_INIT_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".fini_array",	0,	NULL,	0,
    SHT_FINI_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".preinit_array",	0,	NULL,	0,
    SHT_PREINIT_ARRAY,	SHF_ALLOC + SHF_WRITE },
  { ".debug_line",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_info",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_abbrev",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".debug_aranges",	0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".dynamic",		0,	NULL,	0,
    SHT_DYNAMIC,	SHF_ALLOC },
  { ".dynstr",		0,	NULL,	0,
    SHT_STRTAB,		SHF_ALLOC },
  { ".dynsym",		0,	NULL,	0,
    SHT_DYNSYM,		SHF_ALLOC },
  { ".got",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".hash",		0,	NULL,	0,
    SHT_HASH,		SHF_ALLOC },
  { ".interp",		0,	NULL,	0,
    SHT_PROGBITS,	0 },
  { ".plt",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",	0,	NULL,	0,
    SHT_STRTAB,		0 },
  { ".strtab",		0,	NULL,	0,
    SHT_STRTAB,		0 },
  { ".symtab",		0,	NULL,	0,
    SHT_SYMTAB,		0 },
  { ".gnu.version",	0,	NULL,	0,
    SHT_GNU_versym,	0 },
  { ".gnu.version_d",	0,	NULL,	0,
    SHT_GNU_verdef,	0 },
  { ".gnu.version_r",	0,	NULL,	0,
    SHT_GNU_verneed,	0 },
  { ".note",		5,	NULL,	0,
    SHT_NOTE,		0 },
  { ".rela",		5,	NULL,	0,
    SHT_RELA,		0 },
  { ".rel",		4,	NULL,	0,
    SHT_REL,		0 },
  { ".stab",		5,	"str",	3,
    SHT_STRTAB,		0 },
  { NULL,		0,	NULL,	0,
    0,		 0 }
};

static const struct bfd_elf_special_section *
get_special_section (const char *name,
		     const struct bfd_elf_special_section *special_sections,
		     unsigned int rela)
{
  int i;

  for (i = 0; special_sections[i].prefix != NULL; i++)
    if (((special_sections[i].prefix_length
	  && strncmp (name, special_sections[i].prefix,
		      special_sections[i].prefix_length) == 0
	  && (! special_sections[i].suffix_length
	      || strcmp ((name + strlen (name)
			  - special_sections[i].suffix_length),
			 special_sections[i].suffix) == 0))
	 || strcmp (name, special_sections[i].prefix) == 0)
	&& (rela || special_sections[i].type != SHT_RELA))
      return &special_sections[i];

  return NULL;
}

d2144 3
a2146 30
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name, int *type, int *attr)
{
  bfd_boolean found = FALSE;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  /* See if this is one of the special sections.  */
  if (name)
    {
      const struct bfd_elf_special_section *ssect = NULL;
      unsigned int rela = get_elf_backend_data (abfd)->default_use_rela_p;

      if (bed->special_sections)
	ssect = get_special_section (name, bed->special_sections, rela);

      if (! ssect)
	ssect = get_special_section (name, special_sections, rela);

      if (ssect)
	{
	  *type = ssect->type;
	  *attr = ssect->attributes;
	  found = TRUE;
	}
    }

  return found;
}

bfd_boolean
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
a2148 1
  int type, attr;
d2153 2
a2154 1
      sdata = bfd_zalloc (abfd, sizeof (*sdata));
d2157 1
a2157 9
      sec->used_by_bfd = sdata;
    }

  elf_section_type (sec) = SHT_NULL;
  if (sec->name && _bfd_elf_get_sec_type_attr (abfd, sec->name,
					       &type, &attr))
    {
      elf_section_type (sec) = type;
      elf_section_flags (sec) = attr;
d2189 5
a2193 4
_bfd_elf_make_section_from_phdr (bfd *abfd,
				 Elf_Internal_Phdr *hdr,
				 int index,
				 const char *typename)
d2206 1
a2206 1
  name = bfd_alloc (abfd, len);
d2238 1
a2238 1
      name = bfd_alloc (abfd, len);
d2262 4
a2265 1
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index)
d2286 1
a2286 1
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
d2319 5
a2323 4
_bfd_elf_init_reloc_shdr (bfd *abfd,
			  Elf_Internal_Shdr *rel_hdr,
			  asection *asect,
			  bfd_boolean use_rela_p)
d2354 4
a2357 1
elf_fake_sections (bfd *abfd, asection *asect, void *failedptrarg)
d2360 1
a2360 1
  bfd_boolean *failedptr = failedptrarg;
d2398 7
a2404 10
  /* If the section type is unspecified, we set it based on
     asect->flags.  */
  if (this_hdr->sh_type == SHT_NULL)
    {
      if ((asect->flags & SEC_ALLOC) != 0
	  && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	      || (asect->flags & SEC_NEVER_LOAD) != 0))
	this_hdr->sh_type = SHT_NOBITS;
      else
	this_hdr->sh_type = SHT_PROGBITS;
d2406 1
a2406 2

  switch (this_hdr->sh_type)
d2408 1
a2408 17
    default:
      break;

    case SHT_STRTAB:
    case SHT_INIT_ARRAY:
    case SHT_FINI_ARRAY:
    case SHT_PREINIT_ARRAY:
    case SHT_NOTE:
    case SHT_NOBITS:
    case SHT_PROGBITS:
      break;

    case SHT_HASH:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;
  
    case SHT_DYNSYM:
d2410 4
a2413 3
      break;

    case SHT_DYNAMIC:
d2415 27
a2441 13
      break;

    case SHT_RELA:
      if (get_elf_backend_data (abfd)->may_use_rela_p)
	this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case SHT_REL:
      if (get_elf_backend_data (abfd)->may_use_rel_p)
	this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case SHT_GNU_versym:
d2443 4
a2446 3
      break;

     case SHT_GNU_verdef:
d2456 4
a2459 3
      break;

    case SHT_GNU_verneed:
d2469 4
a2472 3
      break;

    case SHT_GROUP:
a2473 1
      break;
d2475 6
d2533 4
a2536 1
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
d2538 1
a2538 1
  bfd_boolean *failedptr = failedptrarg;
d2642 2
a2643 1
assign_section_numbers (bfd *abfd)
d2724 1
a2724 1
  i_shdrp = bfd_zalloc (abfd, amt);
d2729 1
a2729 1
  i_shdrp[0] = bfd_zalloc (abfd, amt);
d2815 1
a2815 1
	      alc = bfd_malloc (len - 2);
d2872 4
a2875 2
static int
sym_is_global (bfd *abfd, asymbol *sym)
d2878 3
a2880 3
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);
d2888 2
a2889 1
elf_map_symbols (bfd *abfd)
d2917 1
a2917 1
  sect_syms = bfd_zalloc (abfd, amt);
d2991 1
a2991 1
  new_syms = bfd_alloc (abfd, amt);
d3035 6
a3040 2
static inline file_ptr
align_file_position (file_ptr off, int align)
d3048 5
a3052 4
file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
					   file_ptr offset,
					   bfd_boolean align)
d3075 3
a3077 2
_bfd_elf_compute_section_file_positions (bfd *abfd,
					 struct bfd_link_info *link_info)
d3172 7
a3178 6
static struct elf_segment_map *
make_mapping (bfd *abfd,
	      asection **sections,
	      unsigned int from,
	      unsigned int to,
	      bfd_boolean phdr)
d3187 1
a3187 1
  m = bfd_zalloc (abfd, amt);
d3209 2
a3210 1
map_sections_to_segments (bfd *abfd)
d3239 1
a3239 1
  sections = bfd_malloc (amt);
d3269 1
a3269 1
      m = bfd_zalloc (abfd, amt);
d3283 1
a3283 1
      m = bfd_zalloc (abfd, amt);
d3432 1
a3432 1
      m = bfd_zalloc (abfd, amt);
d3455 1
a3455 1
	  m = bfd_zalloc (abfd, amt);
d3481 1
a3481 1
      m = bfd_zalloc (abfd, amt);
d3508 1
a3508 1
      m = bfd_zalloc (abfd, amt);
d3523 1
a3523 1
      m = bfd_zalloc (abfd, amt);
d3550 3
a3552 1
elf_sort_sections (const void *arg1, const void *arg2)
d3612 2
a3613 1
assign_file_positions_for_segments (bfd *abfd)
d3697 1
a3697 1
  phdrs = bfd_alloc (abfd, amt);
d4073 2
a4074 1
get_program_header_size (bfd *abfd)
d4174 2
a4175 1
assign_file_positions_except_relocs (bfd *abfd)
d4283 2
a4284 1
prep_headers (bfd *abfd)
d4392 2
a4393 1
_bfd_elf_assign_file_positions_for_relocs (bfd *abfd)
d4416 2
a4417 1
_bfd_elf_write_object_contents (bfd *abfd)
d4426 2
a4427 1
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
d4471 2
a4472 1
_bfd_elf_write_corefile_contents (bfd *abfd)
d4481 3
a4483 1
_bfd_elf_section_from_bfd_section (bfd *abfd, struct sec *asect)
d4532 3
a4534 1
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
d4589 3
a4591 1
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
d4815 1
a4815 1
      map = bfd_alloc (obfd, amt);
d4896 1
a4896 1
      sections = bfd_malloc (amt);
d5098 1
a5098 1
	      map = bfd_alloc (obfd, amt);
d5192 5
a5196 4
_bfd_elf_copy_private_section_data (bfd *ibfd,
				    asection *isec,
				    bfd *obfd,
				    asection *osec)
d5257 5
a5261 4
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
				   asymbol *isymarg,
				   bfd *obfd,
				   asymbol *osymarg)
d5298 4
a5301 3
swap_out_syms (bfd *abfd,
	       struct bfd_strtab_hash **sttp,
	       int relocatable_p)
d5342 1
a5342 1
  symtab_hdr->contents = outbound_syms;
d5583 2
a5584 1
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
d5599 2
a5600 1
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
d5621 3
a5623 2
_bfd_elf_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
				sec_ptr asect)
d5631 5
a5635 4
_bfd_elf_canonicalize_reloc (bfd *abfd,
			     sec_ptr section,
			     arelent **relptr,
			     asymbol **symbols)
d5654 3
a5656 1
_bfd_elf_get_symtab (bfd *abfd, asymbol **allocation)
d5659 1
a5659 1
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, FALSE);
d5667 3
a5669 2
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
				      asymbol **allocation)
d5672 1
a5672 1
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, TRUE);
d5685 2
a5686 1
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
d5718 4
a5721 3
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
				     arelent **storage,
				     asymbol **syms)
d5723 2
a5724 1
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
d5763 2
a5764 1
_bfd_elf_slurp_version_tables (bfd *abfd)
d5781 1
a5781 1
      contents = bfd_malloc (hdr->sh_size);
d5785 1
a5785 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5805 1
a5805 1
      elf_tdata (abfd)->verdef = bfd_zalloc (abfd, amt);
d5827 1
a5827 1
	  iverdef->vd_auxptr = bfd_alloc (abfd, amt);
d5878 2
a5879 1
      elf_tdata (abfd)->verref = bfd_zalloc (abfd, amt);
d5885 1
a5885 1
      contents = bfd_malloc (hdr->sh_size);
d5889 1
a5889 1
	  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
d5912 1
a5912 1
	  iverneed->vn_auxptr = bfd_alloc (abfd, amt);
d5958 2
a5959 1
_bfd_elf_make_empty_symbol (bfd *abfd)
d5964 1
a5964 1
  newsym = bfd_zalloc (abfd, amt);
d5975 4
a5978 3
_bfd_elf_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			  asymbol *symbol,
			  symbol_info *ret)
d5988 3
a5990 2
_bfd_elf_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			      const char *name)
d6014 3
a6016 2
_bfd_elf_get_lineno (bfd *abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol ATTRIBUTE_UNUSED)
d6023 4
a6026 3
_bfd_elf_set_arch_mach (bfd *abfd,
			enum bfd_architecture arch,
			unsigned long machine)
d6042 8
a6049 6
elf_find_function (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *section,
		   asymbol **symbols,
		   bfd_vma offset,
		   const char **filename_ptr,
		   const char **functionname_ptr)
d6104 9
a6112 7
_bfd_elf_find_nearest_line (bfd *abfd,
			    asection *section,
			    asymbol **symbols,
			    bfd_vma offset,
			    const char **filename_ptr,
			    const char **functionname_ptr,
			    unsigned int *line_ptr)
d6161 3
a6163 1
_bfd_elf_sizeof_headers (bfd *abfd, bfd_boolean reloc)
d6174 6
a6179 5
_bfd_elf_set_section_contents (bfd *abfd,
			       sec_ptr section,
			       void *location,
			       file_ptr offset,
			       bfd_size_type count)
d6185 2
a6186 1
      && ! _bfd_elf_compute_section_file_positions (abfd, NULL))
d6199 4
a6202 3
_bfd_elf_no_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			   arelent *cache_ptr ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d6210 3
a6212 1
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
d6306 2
a6307 1
_bfd_elf_close_and_cleanup (bfd *abfd)
d6324 8
a6331 5
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd ATTRIBUTE_UNUSED, arelent *re ATTRIBUTE_UNUSED,
   struct symbol_cache_entry *symbol ATTRIBUTE_UNUSED,
   void *data ATTRIBUTE_UNUSED, asection *is ATTRIBUTE_UNUSED,
   bfd *obfd ATTRIBUTE_UNUSED, char **errmsg ATTRIBUTE_UNUSED)
d6348 2
a6349 1
elfcore_make_pid (bfd *abfd)
d6361 4
a6364 1
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
d6390 5
a6394 4
_bfd_elfcore_make_pseudosection (bfd *abfd,
				 char *name,
				 size_t size,
				 ufile_ptr filepos)
d6405 1
a6405 1
  threaded_name = bfd_alloc (abfd, len);
d6428 2
d6432 3
a6434 1
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d6505 4
a6508 3
elfcore_make_note_pseudosection (bfd *abfd,
				 char *name,
				 Elf_Internal_Note *note)
d6519 3
a6521 1
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
d6531 3
a6533 1
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
d6557 4
a6560 1
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
d6571 1
a6571 1
  dups = bfd_alloc (abfd, len + 1);
d6582 3
d6586 3
a6588 1
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d6646 3
d6650 3
a6652 1
elfcore_grok_pstatus (bfd *abfd, Elf_Internal_Note *note)
d6686 3
d6690 3
a6692 1
elfcore_grok_lwpstatus (bfd *abfd, Elf_Internal_Note *note)
d6716 1
a6716 1
  name = bfd_alloc (abfd, len);
d6746 1
a6746 1
  name = bfd_alloc (abfd, len);
d6775 3
a6777 1
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
d6803 1
a6803 1
      name = bfd_alloc (abfd, len);
d6830 1
a6830 1
      name = bfd_alloc (abfd, len);
d6856 3
a6858 1
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
d6930 3
a6932 1
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
d6946 3
a6948 1
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
d6967 3
a6969 1
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
d7034 4
a7037 1
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, pid_t *tid)
d7071 1
a7071 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d7089 4
a7092 1
elfcore_grok_nto_gregs (bfd *abfd, Elf_Internal_Note *note, pid_t tid)
d7101 1
a7101 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d7128 3
a7130 1
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
d7160 8
a7167 7
elfcore_write_note (bfd  *abfd,
		    char *buf,
		    int  *bufsiz,
		    const char *name,
		    int  type,
		    const void *input,
		    int  size)
d7212 6
a7217 5
elfcore_write_prpsinfo (bfd  *abfd,
			char *buf,
			int  *bufsiz,
			const char *fname,
			const char *psargs)
d7240 7
a7246 6
elfcore_write_prstatus (bfd *abfd,
			char *buf,
			int *bufsiz,
			long pid,
			int cursig,
			const void *gregs)
d7262 7
a7268 6
elfcore_write_lwpstatus (bfd *abfd,
			 char *buf,
			 int *bufsiz,
			 long pid,
			 int cursig,
			 const void *gregs)
d7294 7
a7300 6
elfcore_write_pstatus (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       long pid,
		       int cursig,
		       const void *gregs)
d7314 6
a7319 5
elfcore_write_prfpreg (bfd *abfd,
		       char *buf,
		       int *bufsiz,
		       const void *fpregs,
		       int size)
d7327 6
a7332 5
elfcore_write_prxfpreg (bfd *abfd,
			char *buf,
			int *bufsiz,
			const void *xfpregs,
			int size)
d7340 4
a7343 1
elfcore_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
d7411 2
a7412 1
bfd_get_elf_phdr_upper_bound (bfd *abfd)
d7432 3
a7434 1
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
d7452 4
a7455 1
_bfd_elf_sprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, char *buf, bfd_vma value)
d7483 4
a7486 1
_bfd_elf_fprintf_vma (bfd *abfd ATTRIBUTE_UNUSED, void *stream, bfd_vma value)
d7515 2
a7516 1
_bfd_elf_reloc_type_class (const Elf_Internal_Rela *rela ATTRIBUTE_UNUSED)
d7525 5
a7529 4
_bfd_elf_rela_local_sym (bfd *abfd,
			 Elf_Internal_Sym *sym,
			 asection *sec,
			 Elf_Internal_Rela *rel)
d7547 1
a7547 1
				    0)
d7555 5
a7559 4
_bfd_elf_rel_local_sym (bfd *abfd,
			Elf_Internal_Sym *sym,
			asection **psec,
			bfd_vma addend)
d7568 1
a7568 1
				     sym->st_value + addend, 0);
d7572 5
a7576 4
_bfd_elf_section_offset (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 bfd_vma offset)
d7608 5
a7612 5
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, char *, int))
@


1.162.2.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d328 1
a328 1
  const struct elf_backend_data *bed;
d641 1
a641 1
  const struct elf_backend_data *bed;
d1196 1
a1196 1
	const struct elf_backend_data *bed;
d1347 1
a1347 1
_bfd_elf_link_hash_copy_indirect (const struct elf_backend_data *bed,
d1652 1
a1652 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2126 1
a2126 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2132 1
a2132 1
      unsigned int rela = bed->default_use_rela_p;
d2277 1
a2277 1
  const struct elf_backend_data *bed;
d2335 1
a2335 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2365 1
a2365 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d2875 1
a2875 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d3069 1
a3069 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4062 1
a4062 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4165 1
a4165 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4272 1
a4272 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4317 5
a4321 2
      i_ehdrp->e_machine = bed->elf_machine_code;
    }
d4399 1
a4399 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4461 1
a4461 1
  const struct elf_backend_data *bed;
d4577 1
a4577 1
  const struct elf_backend_data *bed;
d5272 1
a5272 1
  const struct elf_backend_data *bed;
d5604 1
a5604 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5621 1
a5621 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d5633 1
a5633 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d6761 1
a6761 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
d7065 1
a7065 1
      const struct elf_backend_data *bed;
@


1.162.2.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1447 1
a1447 2
  table->tls_sec = NULL;
  table->tls_size = 0;
d2022 76
a2097 38
  { ".bss",            4, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".comment",        8,  0, SHT_PROGBITS, 0 },
  { ".data",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".data1",          6,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".debug",          6,  0, SHT_PROGBITS, 0 },
  { ".fini",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init",           5,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".line",           5,  0, SHT_PROGBITS, 0 },
  { ".rodata",         7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".rodata1",        8,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".tbss",           5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".tdata",          6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_TLS },
  { ".text",           5, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".init_array",    11,  0, SHT_INIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".fini_array",    11,  0, SHT_FINI_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".preinit_array", 14,  0, SHT_PREINIT_ARRAY, SHF_ALLOC + SHF_WRITE },
  { ".debug_line",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_info",    11,  0, SHT_PROGBITS, 0 },
  { ".debug_abbrev",  13,  0, SHT_PROGBITS, 0 },
  { ".debug_aranges", 14,  0, SHT_PROGBITS, 0 },
  { ".dynamic",        8,  0, SHT_DYNAMIC,  SHF_ALLOC },
  { ".dynstr",         7,  0, SHT_STRTAB,   SHF_ALLOC },
  { ".dynsym",         7,  0, SHT_DYNSYM,   SHF_ALLOC },
  { ".got",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".hash",           5,  0, SHT_HASH,     SHF_ALLOC },
  { ".interp",         7,  0, SHT_PROGBITS, 0 },
  { ".plt",            4,  0, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR },
  { ".shstrtab",       9,  0, SHT_STRTAB,   0 },
  { ".strtab",         7,  0, SHT_STRTAB,   0 },
  { ".symtab",         7,  0, SHT_SYMTAB,   0 },
  { ".gnu.version",   12,  0, SHT_GNU_versym, 0 },
  { ".gnu.version_d", 14,  0, SHT_GNU_verdef, 0 },
  { ".gnu.version_r", 14,  0, SHT_GNU_verneed, 0 },
  { ".note",           5, -1, SHT_NOTE,     0 },
  { ".rela",           5, -1, SHT_RELA,     0 },
  { ".rel",            4, -1, SHT_REL,      0 },
  { ".stabstr",        5,  3, SHT_STRTAB,   0 },
  { NULL,              0,  0, 0,            0 }
a2105 1
  int len = strlen (name);
d2108 9
a2116 31
    {
      int suffix_len;
      int prefix_len = special_sections[i].prefix_length;

      if (len < prefix_len)
	continue;
      if (memcmp (name, special_sections[i].prefix, prefix_len) != 0)
	continue;

      suffix_len = special_sections[i].suffix_length;
      if (suffix_len <= 0)
	{
	  if (name[prefix_len] != 0)
	    {
	      if (suffix_len == 0)
		continue;
	      if (name[prefix_len] != '.'
		  && (suffix_len == -2
		      || (rela && special_sections[i].type == SHT_REL)))
		continue;
	    }
	}
      else
	{
	  if (len < prefix_len + suffix_len)
	    continue;
	  if (memcmp (name + len - suffix_len,
		      special_sections[i].prefix + prefix_len,
		      suffix_len) != 0)
	    continue;
	}
a2117 1
    }
d2122 2
a2123 2
const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, const char *name)
d2125 1
a2126 1
  const struct bfd_elf_special_section *ssect = NULL;
d2131 1
d2139 7
d2148 1
a2148 1
  return ssect;
d2155 1
a2155 1
  const struct bfd_elf_special_section *ssect;
d2167 2
a2168 2
  ssect = _bfd_elf_get_sec_type_attr (abfd, sec->name);
  if (ssect != NULL)
d2170 2
a2171 2
      elf_section_type (sec) = ssect->type;
      elf_section_flags (sec) = ssect->attr;
a2230 1
  newsect->alignment_power = bfd_log2 (hdr->p_align);
d2433 1
a2433 1

d4456 1
a4456 1
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
d5616 1
a5616 1
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
d6119 1
a6119 1
			       const void *location,
d6263 1
a6263 1
   struct bfd_symbol *symbol ATTRIBUTE_UNUSED,
d6339 1
a6339 1
  sect = bfd_make_section_anyway (abfd, threaded_name);
d6623 1
a6623 1
  sect = bfd_make_section_anyway (abfd, name);
d6653 1
a6653 1
  sect = bfd_make_section_anyway (abfd, name);
d6709 1
a6709 1
      sect = bfd_make_section_anyway (abfd, name);
d6736 1
a6736 1
      sect = bfd_make_section_anyway (abfd, name);
d6813 1
a6813 1
	asection *sect = bfd_make_section_anyway (abfd, ".auxv");
d6965 1
a6965 1
  sect = bfd_make_section_anyway (abfd, name);
d6992 1
a6992 1
  sect = bfd_make_section_anyway (abfd, name);
d7069 1
a7069 1
  newspace = 12 + namesz + pad + size;
d7391 1
a7391 1
			 asection **psec,
a7393 1
  asection *sec = *psec;
d7403 3
d7407 1
a7407 1
	_bfd_merged_section_offset (abfd, psec,
d7410 3
a7412 4
				    0);
      sec = *psec;
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
@


1.162.2.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d44 1
a44 1
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
d897 1
a897 1
  if (!is_elf_hash_table (info->hash))
d910 1
a910 1
  if (!is_elf_hash_table (info->hash))
d1357 6
a1362 7
  dir->elf_link_hash_flags
    |= ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_NON_GOT_REF
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED);
d1506 1
a1506 1
  if (! is_elf_hash_table (info->hash))
d1518 1
a1518 1
  if (! is_elf_hash_table (info->hash))
d3105 1
a3105 1
  if (!assign_file_positions_except_relocs (abfd, link_info))
d3578 1
a3578 1
assign_file_positions_for_segments (bfd *abfd, struct bfd_link_info *link_info)
d3630 1
a3630 1
      if (! (*bed->elf_backend_modify_segment_map) (abfd, link_info))
d4138 1
a4138 2
assign_file_positions_except_relocs (bfd *abfd,
				     struct bfd_link_info *link_info)
d4189 1
a4189 1
      if (! assign_file_positions_for_segments (abfd, link_info))
d4626 2
a4627 3
       5. PT_GNU_STACK segments do not include any sections.
       6. PT_TLS segment includes only SHF_TLS sections.
       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.  */
a4634 1
   && segment->p_type != PT_GNU_STACK					\
d4678 1
a4678 1
		 assignment code will work.  */
d6837 1
a6837 2
  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
					  note);
@


1.161
log
@Check functionname_ptr and line_ptr before deciding we've found a symbol.
@
text
@d5575 5
a5579 1
  return bed->s->slurp_symbol_table (abfd, alocation, true);
@


1.160
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d6044 1
a6044 1
  if (found)
@


1.160.6.1
log
@* elf.c (elfcore_grok_note): Fix recognition on NT_PRXFPREG notes.
@
text
@d6801 2
a6802 2
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
@


1.159
log
@* elf.c (bfd_elf_get_elf_syms): Change type of `esym' to
`bfd_byte'.
@
text
@d1421 2
a1422 1
_bfd_elf_link_hash_copy_indirect (dir, ind)
d1426 1
d1444 1
a1444 1
  if (tmp <= 0)
d1450 1
a1450 1
    BFD_ASSERT (ind->got.refcount <= 0);
d1453 1
a1453 1
  if (tmp <= 0)
d1459 1
a1459 1
    BFD_ASSERT (ind->plt.refcount <= 0);
@


1.158
log
@	* elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

	* ldlang.c (lang_add_section): Don't turn .tbss into normal sections
	for relocatable link.
	(lang_size_sections_1): Don't make .tbss zero size for relocatable
	link.
@
text
@d374 1
a374 1
  const PTR esym;
@


1.157
log
@fix typo introduced in previous delta
@
text
@d2446 14
a2459 1
    this_hdr->sh_flags |= SHF_TLS;
@


1.156
log
@Add new bitfield 'want_p_paddr_set_to_zero'.
Set this field for HPUX IA64 port.
Test this field when setting p_paddr.
@
text
@d4819 1
@


1.155
log
@	* elf.c: (assign_section_numbers) Set sh_entsize for .stab only
	when not already set.
	* elf64-sparc.c: (sparc64_elf_fake_sections): New function.
	(elf_backend_fake_sections): Define.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software 
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d4816 2
a4817 1
		 correct value.  */
d4819 1
a4819 1
		  && segment->p_vaddr != 0
d4836 4
a4839 1
		  || IS_COREFILE_NOTE (segment, section))
@


1.155.2.1
log
@Add support for targets which need p_paddr set to zero.
Enable this feature for the HP-UX IA-64 target.
@
text
@d4816 1
a4816 2
		 correct value.  Note - some backends require that
		 p_paddr be left as zero.  */
a4818 1
		  && (! bed->want_p_paddr_set_to_zero)
d4835 1
a4835 4
		  || IS_COREFILE_NOTE (segment, section)
		  || (bed->want_p_paddr_set_to_zero &&
		      IS_CONTAINED_BY_VMA (output_section, segment))
                )
@


1.155.2.2
log
@        Merge from mainline:
        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * po/sv.po: Updated Swedish translation.

        2002-07-30  Jakub Jelinek  <jakub@@redhat.com>
        * elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

        2002-07-26  Chris Demetriou  <cgd@@broadcom.com>
        * elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Merge ASE
        flags into resulting BFD.

        2002-07-25  Alan Modra  <amodra@@bigpond.net.au>
        * elf-bfd.h (_bfd_elf32_link_record_local_dynamic_symbol): Define
        as elf_link_record_local_dynamic_symbol.
        (_bfd_elf64_link_record_local_dynamic_symbol): Likewise.
        (elf_link_record_local_dynamic_symbol): Declare.  Now returns int.
        * elflink.h (elf_link_record_local_dynamic_symbol): Move to..
        * elflink.c: .. here.  Use bfd_elf_get_elf_syms.  Check whether an
        attempt is made to record a symbol in a discarded section, and
        return `2' in that case.
@
text
@d2446 1
a2446 14
    {
      this_hdr->sh_flags |= SHF_TLS;
      if (asect->_raw_size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *o;
                                          
	  this_hdr->sh_size = 0;
	  for (o = asect->link_order_head; o != NULL; o = o->next)
	    if (this_hdr->sh_size < o->offset + o->size)
	      this_hdr->sh_size = o->offset + o->size;
	  if (this_hdr->sh_size)
	    this_hdr->sh_type = SHT_NOBITS;
	}
    }
@


1.155.2.3
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d1421 1
a1421 2
_bfd_elf_link_hash_copy_indirect (bed, dir, ind)
     struct elf_backend_data *bed;
a1424 1
  bfd_signed_vma lowest_valid = bed->can_refcount;
d1442 1
a1442 1
  if (tmp < lowest_valid)
d1448 1
a1448 1
    BFD_ASSERT (ind->got.refcount < lowest_valid);
d1451 1
a1451 1
  if (tmp < lowest_valid)
d1457 1
a1457 1
    BFD_ASSERT (ind->plt.refcount < lowest_valid);
@


1.155.2.4
log
@2002-09-21  David O'Brien  <obrien@@FreeBSD.org>
	Merge from mainline:
	2002-08-17  Andrew Cagney  <ac131313@@redhat.com>
	* elf.c (bfd_elf_get_elf_syms): Change type of `esym' to
 	`bfd_byte'.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20020922130702.K14457@@bubble.sa.bigpond.net.au>
@
text
@d374 1
a374 1
  const bfd_byte *esym;
@


1.155.2.5
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d5575 1
a5575 5
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, true);

  if (symcount >= 0)
    bfd_get_dynamic_symcount (abfd) = symcount;
  return symcount;
d6044 1
a6044 1
  if (found && (*functionname_ptr || *line_ptr))
@


1.155.2.6
log
@	* elf.c (map_sections_to_segments): Correct test for start of
	writable section in the same page as end of read-only section.
@
text
@d3320 2
a3321 3
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
@


1.155.2.7
log
@2002-11-07  Graeme Peterson  <gp@@qnx.com>

	* Makefile.am: Removed entries for elf32-i386qnx.c and
	elf32-i386qnx.lo.
	* Makefile.in: Regenerate.
	* config.bfd: Changed i[3456]86-*-nto-qnx* targ_defvec from
	bfd_elf32_i386qnx_vec to bfd_elf32_i386_vec.
	* configure.in: Removed support for bfd_elf32_i386qnx_vec.
	* configure: Regenerate.
	* elf32-i386qnx.c: Removed.
	* elf.c: Removed calls to QNX specific set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
	* elf32-i386.c: Removed QNX specific #ifdef ELF32_I386_C_INCLUDED.
	* targets.c: Removed bfd_elf32_i386qnx_vec.
	* elfxx-target.h: Removed QNX specific elf_backend_set_nonloadable_filepos,
	elf_backend_is_contained_by_filepos, and elf_backend_copy_private_bfd_data_p.
	* elf-bfd.h: Removed QNX specific set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
@
text
@d3963 5
d4563 7
d4605 3
a4607 1
    || IS_COREFILE_NOTE (segment, section))				\
d4852 1
d5089 1
d5115 14
a5128 1
  if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
@


1.155.2.8
log
@Remove now unused _bfd_elf_copy_private_section_data local var 'bed'
resulting the rev 1.155.2.6->1.155.2.7 change.

2002-11-27  David O'Brien  <obrien@@FreeBSD.org>
        * elf.c (_bfd_elf_copy_private_section_data): Don't define bed.
@
text
@d5093 1
@


1.154
log
@	* elf.c: Formatting.
	(IS_SOLARIS_PT_INTERP): Add p_paddr and p_memsz checks.
	(INCLUDE_SECTION_IN_SEGMENT): Remove IS_SOLARIS_PT_INTERP.
	(copy_private_bfd_data): Set p_vaddr on broken Solaris PT_INTERP
	segments.
@
text
@d2763 3
a2765 2
		  elf_section_data (s)->this_hdr.sh_entsize =
		    4 + 2 * bfd_get_arch_size (abfd) / 8;
@


1.153
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d4528 3
a4530 3
#define SEGMENT_END(segment, start) 			\
  (start + (segment->p_memsz > segment->p_filesz 	\
   ? segment->p_memsz : segment->p_filesz))
d4534 4
a4537 4
#define IS_CONTAINED_BY_VMA(section, segment)		\
  (section->vma >= segment->p_vaddr			\
   && (section->vma + section->_raw_size)		\
   <= (SEGMENT_END (segment, segment->p_vaddr)))
d4541 4
a4544 4
#define IS_CONTAINED_BY_LMA(section, segment, base)	\
    (section->lma >= base				\
     && (section->lma + section->_raw_size)		\
     <= SEGMENT_END (segment, base))
d4549 2
a4550 2
#define IS_CONTAINED_BY_FILEPOS(sec, seg, bed)		\
  (bed->is_contained_by_filepos		  		\
d4554 7
a4560 7
#define IS_COREFILE_NOTE(p, s)                          \
	    (p->p_type == PT_NOTE                       \
	     && bfd_get_format (ibfd) == bfd_core       \
	     && s->vma == 0 && s->lma == 0              \
	     && (bfd_vma) s->filepos >= p->p_offset     \
	     && (bfd_vma) s->filepos + s->_raw_size     \
	     <= p->p_offset + p->p_filesz)
d4565 10
a4574 8
#define IS_SOLARIS_PT_INTERP(p, s)			\
	    (   p->p_vaddr == 0				\
	     && p->p_filesz > 0				\
	     && (s->flags & SEC_HAS_CONTENTS) != 0	\
	     && s->_raw_size > 0			\
	     && (bfd_vma) s->filepos >= p->p_offset	\
	     && ((bfd_vma) s->filepos + s->_raw_size	\
		     <= p->p_offset + p->p_filesz))
d4584 3
a4586 4
  (((((segment->p_paddr							\
       ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
       : IS_CONTAINED_BY_VMA (section, segment))			\
      || IS_SOLARIS_PT_INTERP (segment, section))			\
d4595 2
a4596 2
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)		\
    (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))
d4599 3
a4601 2
#define SEGMENT_OVERLAPS(seg1, seg2)			\
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2) || SEGMENT_AFTER_SEGMENT (seg2, seg1)))
d4610 1
a4610 1
     parameters to objcopy.  */
d4617 10
@


1.152
log
@	* elflink.h (elf_link_add_object_symbols): Revert 1999-09-02 hpux
	fudge.
	* elf.c (bfd_section_from_shdr): Work around broken hpux shared
	libs here instead.
@
text
@d355 101
a472 3
  struct elf_backend_data *bed;
  file_ptr pos;
  bfd_size_type amt;
a473 1
  Elf_Internal_Shdr *shndx_hdr;
d486 2
a487 5
  bed = get_elf_backend_data (abfd);
  amt = bed->s->sizeof_sym;
  pos = hdr->sh_offset + ghdr->sh_info * amt;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread (esym, amt, abfd) != amt)
a489 16
  /* And possibly the symbol section index extension.  */
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (elf_elfsections (abfd) != NULL
      && elf_elfsections (abfd)[shndx_hdr->sh_link] == hdr)
    {
      amt = sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + ghdr->sh_info * amt;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) &eshndx, amt, abfd) != amt)
	return NULL;
    }

  /* Convert to internal format.  */
  (*bed->s->swap_symbol_in) (abfd, (const PTR *) &esym, (const PTR *) &eshndx,
			     &isym);

a2056 2
  unsigned char esym_shndx[4];
  unsigned int isym_shndx;
d2058 3
a2060 2
  file_ptr pos;
  bfd_size_type amt;
d2067 2
a2068 16
  pos = symtab_hdr->sh_offset;
  if (get_elf_backend_data (abfd)->s->sizeof_sym
      == sizeof (Elf64_External_Sym))
    {
      pos += r_symndx * sizeof (Elf64_External_Sym);
      pos += offsetof (Elf64_External_Sym, st_shndx);
      amt = sizeof (((Elf64_External_Sym *) 0)->st_shndx);
    }
  else
    {
      pos += r_symndx * sizeof (Elf32_External_Sym);
      pos += offsetof (Elf32_External_Sym, st_shndx);
      amt = sizeof (((Elf32_External_Sym *) 0)->st_shndx);
    }
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread ((PTR) esym_shndx, amt, abfd) != amt)
a2069 16
  isym_shndx = H_GET_16 (abfd, esym_shndx);

  if (isym_shndx == SHN_XINDEX)
    {
      Elf_Internal_Shdr *shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      if (shndx_hdr->sh_size != 0)
	{
	  pos = shndx_hdr->sh_offset;
	  pos += r_symndx * sizeof (Elf_External_Sym_Shndx);
	  amt = sizeof (Elf_External_Sym_Shndx);
	  if (bfd_seek (abfd, pos, SEEK_SET) != 0
	      || bfd_bread ((PTR) esym_shndx, amt, abfd) != amt)
	    return NULL;
	  isym_shndx = H_GET_32 (abfd, esym_shndx);
	}
    }
d2078 1
a2078 1
  if (isym_shndx < SHN_LORESERVE || isym_shndx > SHN_HIRESERVE)
d2081 1
a2081 1
      s = bfd_section_from_elf_index (abfd, isym_shndx);
@


1.151
log
@	* elf.c (_bfd_elf_reloc_type_class): Fix comment grammar.
@
text
@a1663 1
    case SHT_DYNAMIC:	/* Dynamic linking information.  */
d1671 33
@


1.150
log
@	* elf64-ppc.c (ppc_add_stub): Replace strcpy/strncpy with memcpy.
	* elf32-hppa.c (hppa_add_stub): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_add_default_symbol): Fix comment typo.
	(elf_add_default_symbol): Replace strcpy and strncpy with memcpy.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
	* hash.c (bfd_hash_lookup): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
	* section.c (bfd_get_unique_section_name): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* elf.c (_bfd_elf_make_section_from_phdr): Likewise.
	(assign_section_numbers): Likewise.
	(_bfd_elfcore_make_pseudosection): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(elfcore_grok_win32pstatus): Likewise.
	(elfcore_write_note): Constify input params.  Use PTR instead of
	void *.  Include terminating NUL in namesz.  Correct padding.
	Support NULL "name" param.  Use memcpy instead of strcpy.
	(elfcore_write_prpsinfo): Constify input params.
	(elfcore_write_prstatus): Likewise.  Use PTR instead of void *.
	(elfcore_write_lwpstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	* elf-bfd.h (elfcore_write_note): Update declaration.
	(elfcore_write_prpsinfo): Likewise.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_pstatus): Likewise.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_prxfpreg): Likewise.
	(elfcore_write_lwpstatus): Likewise.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 1
    
d729 1
a729 1
		 loaded data lies within the extent of the segment.  
d872 1
a872 1
    
d3487 1
a3487 1
		  if (i != new_count) 
d3553 1
a3553 1
         sections may not be correctly ordered.  NOTE: sorting should 
d3557 2
a3558 2
      if (m->count > 1 
	  && !(elf_elfheader (abfd)->e_type == ET_CORE 
d5006 2
a5007 2
     already been worked out.  The backend function provides a way to 
     override the test conditions and code path for the call to 
d5014 1
a5014 1
    } 
d6761 1
a6761 1
      
d6769 1
a6769 1
  
d6814 1
a6814 1
   Inputs: 
d6881 1
a6881 1
     const char *fname; 
d6898 1
a6898 1
  return elfcore_write_note (abfd, buf, bufsiz, 
d6920 1
a6920 1
  return elfcore_write_note (abfd, buf, bufsiz, 
d6952 1
a6952 1
  return elfcore_write_note (abfd, buf, bufsiz, note_name, 
d6972 1
a6972 1
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name, 
d6987 1
a6987 1
  return elfcore_write_note (abfd, buf, bufsiz, 
d7000 1
a7000 1
  return elfcore_write_note (abfd, buf, bufsiz, 
d7181 1
a7181 1
/* For RELA architectures, return what the relocation value for
d7220 1
a7220 1
{     
@


1.149
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d2074 1
d2081 2
a2082 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (namebuf) + 1);
d2085 1
a2085 1
  strcpy (name, namebuf);
d2113 2
a2114 1
      name = bfd_alloc (abfd, (bfd_size_type) strlen (namebuf) + 1);
d2117 1
a2117 1
      strcpy (name, namebuf);
d2672 1
a2672 1
	      alc = (char *) bfd_malloc ((bfd_size_type) len - 2);
d2675 1
a2675 1
	      strncpy (alc, sec->name, len - 3);
d6195 1
d6201 2
a6202 1
  threaded_name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6205 1
a6205 1
  strcpy (threaded_name, buf);
d6490 1
d6508 2
a6509 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6512 1
a6512 1
  strcpy (name, buf);
d6538 2
a6539 1
  name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6542 1
a6542 1
  strcpy (name, buf);
d6574 1
d6595 2
a6596 1
      name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6600 1
a6600 1
      strcpy (name, buf);
d6622 2
a6623 1
      name = bfd_alloc (abfd, (bfd_size_type) strlen (buf) + 1);
d6627 1
a6627 1
      strcpy (name, buf);
d6829 1
a6829 1
     char *name;
d6831 1
a6831 1
     void *input;
d6835 3
a6837 2
  int namesz = strlen (name);
  int newspace = BFD_ALIGN (sizeof (Elf_External_Note) + size + namesz - 1, 4);
d6840 13
d6860 12
a6871 2
  strcpy (xnp->name, name);
  memcpy (xnp->name + BFD_ALIGN (namesz, 4), input, size);
d6881 2
a6882 2
     char *fname; 
     char *psargs;
d6911 1
a6911 1
     void *gregs;
d6933 1
a6933 1
     void *gregs;
d6965 1
a6965 1
     void *gregs;
d6983 1
a6983 1
     void *fpregs;
d6996 1
a6996 1
     void *xfpregs;
@


1.148
log
@2002-06-23  Alan Modra  <amodra@@bigpond.net.au>

	* elflink.h: Comment typo fixes.

2002-06-23  H.J. Lu  <hjl@@gnu.org>

	* elf-bfd.h (elf_link_loaded_list): New structure.
	(elf_link_hash_table): Add "loaded".
	* elf.c (_bfd_elf_link_hash_table_init): Initialize "loaded".
	* elflink.h (elf_link_check_versioned_symbol): New function.
	(elf_link_output_extsym): Call elf_link_check_versioned_symbol.
@
text
@d4509 1
a4509 1
   && section->segment_mark == false)
d5968 2
a5969 2
      && ! _bfd_elf_compute_section_file_positions
      (abfd, (struct bfd_link_info *) NULL))
@


1.147
log
@2002-06-08  H.J. Lu <hjl@@gnu.org>

	* elf.c (copy_private_bfd_data): Don't cast to bfd_size_type to
	work around a long long bug in gcc 2.96 on mips.
@
text
@d1433 1
@


1.146
log
@	* elf-bfd.h (struct bfd_elf_section_data <group_name>): Replace with
	"group" union.
	(elf_group_name): Update.
	(elf_group_id): Define.
	(bfd_elf_set_group_contents): Declare.
	* elf.c (elf_fake_sections): Qualify use of elf_group_name.
	(set_group_contents): Rename to bfd_elf_set_group_contents.  Remove
	ATTRIBUTE_UNUSED from failedptrarg.  If elf_group_id is set, use
	that sym for the signature.
	(_bfd_elf_compute_section_file_positions): Don't call
	set_group_contents for "ld -r" case.
	(swap_out_syms): Use bfd_zalloc.
	* elflink.h (elf_link_add_archive_symbols): Likewise.
	(NAME(bfd_elf,size_dynamic_sections)): Likewise.
	(elf_bfd_final_link): Call bfd_elf_set_group_contents.
@
text
@d4691 3
a4693 1
      amt = (bfd_size_type) section_count * sizeof (asection *);
@


1.145
log
@Do not include empty sections in loadable segments.
@
text
@a56 1
static void set_group_contents PARAMS ((bfd *, asection *, PTR));
d2360 1
a2360 1
  if (elf_group_name (asect) != NULL)
d2384 2
a2385 2
static void
set_group_contents (abfd, sec, failedptrarg)
d2388 1
a2388 1
     PTR failedptrarg ATTRIBUTE_UNUSED;
d2401 13
a2413 7
  /* If called from the assembler, swap_out_syms will have set up
     elf_section_syms;  If called for "ld -r", the symbols won't yet
     be mapped, so emulate elf_bfd_final_link.  */
  if (elf_section_syms (abfd) != NULL)
    symindx = elf_section_syms (abfd)[sec->index]->udata.i;
  else
    symindx = elf_section_data (sec)->this_idx;
d2416 1
a2416 1
  /* Nor will the contents be allocated for "ld -r" or objcopy.  */
d2967 1
a2967 1
  if (link_info == NULL || link_info->relocateable)
d2969 1
a2969 1
      bfd_map_over_sections (abfd, set_group_contents, &failed);
d5152 1
a5152 1
      outbound_shndx = bfd_alloc (abfd, amt);
a5154 1
      memset (outbound_shndx, 0, (unsigned long) amt);
@


1.144
log
@	* elf.c (group_signature): Swap in the whole symbol, and handle
	extracting section symbol names.
	(setup_group): Add comment.
	(set_group_contents): When called from objcopy or ld, arrange for
	section contents to be written.  Write group member output section
	indices to allow objcopy to reorganize sections.
	(_bfd_elf_copy_private_section_data): Copy group info.
@
text
@d3458 31
d4644 2
a4645 1
	     something.  */
d4648 1
a4648 1
	      (_("%s: warning: Empty loadable segment detected\n"),
@


1.143
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d375 8
a382 2
  unsigned char ename[4];
  unsigned long iname;
d388 2
a389 2
  /* Fortunately, the name index is at the same place in the external
     symbol for both 32 and 64 bit ELF.  */
d391 2
a392 2
  pos = elf_tdata (abfd)->symtab_hdr.sh_offset;
  pos += ghdr->sh_info * bed->s->sizeof_sym;
d394 1
a394 1
      || bfd_bread (ename, (bfd_size_type) 4, abfd) != 4)
d396 27
a422 2
  iname = H_GET_32 (abfd, ename);
  return elf_string_from_elf_strtab (abfd, iname);
d570 2
d2393 1
a2393 1
  asection *elt;
d2396 1
d2411 2
a2412 1
  /* Nor will the contents be allocated for "ld -r".  */
d2415 1
d2417 3
d2429 4
a2432 3
  /* Get the pointer to the first section in the group that we
     squirreled away here.  */
  elt = elf_next_in_group (sec);
d2440 3
d2444 7
a2450 1
      H_PUT_32 (abfd, elf_section_data (elt)->this_idx, loc);
d2452 2
d2472 9
a2480 1
  loc -= 4;
a2481 2

  BFD_ASSERT (loc == sec->contents);
d5000 6
@


1.142
log
@	* elf.c (setup_group): Set SEC_LINK_ONCE on GRP_COMDAT groups.
	(bfd_section_from_shdr): Likewise.  Set section name of group
	sections from signature.
	(group_signature): Split out from setup_group.  Ensure symbol table
	is available.
	(bfd_elf_discard_group): New function.
	(_bfd_elf_make_section_from_shdr): Don't set SEC_LINK_ONCE on
	.gnu.linkonce* sections if they are members of a group.
	(set_group_contents): Set GRP_COMDAT flag.
	* section.c (bfd_discard_group): New function.
	* bfd-in.h (bfd_elf_discard_group): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct bfd_elf_section_data): Add linkonce_p field.
	(elf_linkonce_p): Define.
@
text
@d556 1
a556 1
void
d572 1
@


1.141
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d53 1
d365 29
d473 3
a527 4
		    struct elf_backend_data *bed;
		    file_ptr pos;
		    unsigned char ename[4];
		    unsigned long iname;
d530 2
a531 10
		    /* Humbug.  Get the name from the group signature
		       symbol.  Why isn't the signature just a string?
		       Fortunately, the name index is at the same
		       place in the external symbol for both 32 and 64
		       bit ELF.  */
		    bed = get_elf_backend_data (abfd);
		    pos = elf_tdata (abfd)->symtab_hdr.sh_offset;
		    pos += shdr->sh_info * bed->s->sizeof_sym;
		    if (bfd_seek (abfd, pos, SEEK_SET) != 0
			|| bfd_bread (ename, (bfd_size_type) 4, abfd) != 4)
a532 2
		    iname = H_GET_32 (abfd, ename);
		    gname = elf_string_from_elf_strtab (abfd, iname);
d538 1
d541 1
d556 18
d662 2
a663 1
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
d1863 6
a1868 1
      /* Make a section for objcopy and relocatable links.  */
d1877 4
d2421 1
a2421 1
  H_PUT_32 (abfd, 0, loc);
@


1.140
log
@	* Makefile.am (BFD32_BACKENDS): Add elf32-i386qnx.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386qnx.c.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* config.bfd: Add i[3456]86-*-nto-qnx* support.
	* configure.in: Add bfd_elf32_i386qnx_vec support.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
	* elf.c (assign_file_positions_for_segments): Call backend
	set_nonloadable_filepos.  Fix non-K&R call to _bfd_error_handler.
	(IS_CONTAINED_BY_FILEPOS): Define.
	(INCLUDE_SECTION_IN_SEGMENT): Also test IS_CONTAINED_BY_FILEPOS.
	(copy_private_bfd_data): Use IS_CONTAINED_BY_FILEPOS.  Typo fix.
	Fix non-K&R call to _bfd_error_handler.
	(_bfd_elf_copy_private_section_data): Use backend
	copy_private_bfd_data_p.
	* elf32-i386.c: Don't include elfxx-target.h when
	ELF32_I386_C_INCLUDED is defined.
	* elf32-i386qnx.c: New QNX elf backend file.
	* elfxx-target.h: Add elf_backend_set_nonloadable_filepos,
	elf_backend_is_contained_by_filepos, and
	elf_backend_do_copy_private_bfd_data.
	* targets.c: Add bfd_target bfd_elf32_i386qnx_vec.
@
text
@d1579 1
a1579 1
  char *name;
@


1.139
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d3480 3
a3482 2
		  _bfd_error_handler (_("%s: Not enough room for program headers, try linking with -N"),
				      bfd_get_filename (abfd));
d3720 5
d4283 1
d4292 1
d4320 7
d4355 1
a4355 1
#define INCLUDE_SECTION_IN_SEGMENT(section, segment)			\
d4361 3
a4363 1
    || IS_COREFILE_NOTE (segment, section))				\
d4463 1
a4463 1
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
d4508 3
a4510 3
	      _bfd_error_handler
		(_("%s: warning: Empty loadable segment detected\n"),
		 bfd_archive_filename (ibfd));
d4566 1
a4566 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment))
d4592 1
d4662 1
a4662 1
	 those that fit to the current segment and remvoing them from the
d4713 1
a4713 1
			  < BFD_ALIGN (output_section->lma, maxpagesize))
d4826 1
d4846 1
d4856 25
a4880 18
     already been worked out.  */
  if (elf_tdata (obfd)->segment_map == NULL
      && elf_tdata (ibfd)->phdr != NULL)
    {
      asection *s;

      /* Only set up the segments if there are no more SEC_ALLOC
         sections.  FIXME: This won't do the right thing if objcopy is
         used to remove the last SEC_ALLOC section, since objcopy
         won't call this routine in that case.  */
      for (s = isec->next; s != NULL; s = s->next)
	if ((s->flags & SEC_ALLOC) != 0)
	  break;
      if (s == NULL)
	{
	  if (! copy_private_bfd_data (ibfd, obfd))
	    return false;
	}
@


1.139.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a52 1
static const char *group_signature PARAMS ((bfd *, Elf_Internal_Shdr *));
d56 1
a363 60
/* Return the name of the group signature symbol.  Why isn't the
   signature just a string?  */

static const char *
group_signature (abfd, ghdr)
     bfd *abfd;
     Elf_Internal_Shdr *ghdr;
{
  struct elf_backend_data *bed;
  file_ptr pos;
  bfd_size_type amt;
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Shdr *shndx_hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
  unsigned int iname;
  unsigned int shindex;

  /* First we need to ensure the symbol table is available.  */
  if (! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return NULL;

  /* Go read the symbol.  */
  hdr = &elf_tdata (abfd)->symtab_hdr;
  bed = get_elf_backend_data (abfd);
  amt = bed->s->sizeof_sym;
  pos = hdr->sh_offset + ghdr->sh_info * amt;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread (esym, amt, abfd) != amt)
    return NULL;

  /* And possibly the symbol section index extension.  */
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (elf_elfsections (abfd) != NULL
      && elf_elfsections (abfd)[shndx_hdr->sh_link] == hdr)
    {
      amt = sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + ghdr->sh_info * amt;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) &eshndx, amt, abfd) != amt)
	return NULL;
    }

  /* Convert to internal format.  */
  (*bed->s->swap_symbol_in) (abfd, (const PTR *) &esym, (const PTR *) &eshndx,
			     &isym);

  /* Look up the symbol name.  */
  iname = isym.st_name;
  shindex = hdr->sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym.st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym.st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

a442 3
			  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))
			    shdr->bfd_section->flags
			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d495 4
d501 10
a510 2
		    gname = group_signature (abfd, shdr);
		    if (gname == NULL)
d512 2
a518 3

		/* If the group section has been created, point to the
		   new member.  */
a520 1

a534 19
boolean
bfd_elf_discard_group (abfd, group)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *group;
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      s->output_section = bfd_abs_section_ptr;
      s = elf_next_in_group (s);
      /* These lists are circular.  */
      if (s == first)
	break;
    }
  return true;
}

d623 1
a623 2
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0
      && elf_next_in_group (newsect) == NULL)
d1579 1
a1579 1
  const char *name;
d1823 1
a1823 6
      /* We need a BFD section for objcopy and relocatable linking,
	 and it's handy to have the signature available as the section
	 name.  */
      name = group_signature (abfd, hdr);
      if (name == NULL)
	return false;
a1831 4
	  if (idx->flags & GRP_COMDAT)
	    hdr->bfd_section->flags
	      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

d2278 1
a2278 1
  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)
d2302 2
a2303 2
void
bfd_elf_set_group_contents (abfd, sec, failedptrarg)
d2306 1
a2306 1
     PTR failedptrarg;
d2310 1
a2310 1
  asection *elt, *first;
a2312 1
  boolean gas;
d2318 7
a2324 13
  symindx = 0;
  if (elf_group_id (sec) != NULL)
    symindx = elf_group_id (sec)->udata.i;

  if (symindx == 0)
    {
      /* If called from the assembler, swap_out_syms will have set up
	 elf_section_syms;  If called for "ld -r", use target_index.  */
      if (elf_section_syms (abfd) != NULL)
	symindx = elf_section_syms (abfd)[sec->index]->udata.i;
      else
	symindx = sec->target_index;
    }
d2327 1
a2327 2
  /* The contents won't be allocated for "ld -r" or objcopy.  */
  gas = true;
a2329 1
      gas = false;
a2330 3

      /* Arrange for the section to be written out.  */
      elf_section_data (sec)->this_hdr.contents = sec->contents;
d2340 3
a2342 4
  /* Get the pointer to the first section in the group that gas
     squirreled away here.  objcopy arranges for this to be set to the
     start of the input section group.  */
  first = elt = elf_next_in_group (sec);
a2349 3
      asection *s;
      unsigned int idx;

d2351 1
a2351 7
      s = elt;
      if (!gas)
	s = s->output_section;
      idx = 0;
      if (s != NULL)
	idx = elf_section_data (s)->this_idx;
      H_PUT_32 (abfd, idx, loc);
a2352 2
      if (elt == first)
	break;
d2371 2
a2372 5
  /* With ld -r, merging SHT_GROUP sections results in wasted space
     due to allowing for the flag word on each input.  We may well
     duplicate entries too.  */
  while ((loc -= 4) > sec->contents)
    H_PUT_32 (abfd, 0, loc);
d2374 1
a2374 4
  if (loc != sec->contents)
    abort ();

  H_PUT_32 (abfd, sec->flags & SEC_LINK_ONCE ? GRP_COMDAT : 0, loc);
d2855 1
a2855 1
  if (link_info == NULL)
d2857 1
a2857 1
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
a3350 31
  else
    {
      /* The placement algorithm assumes that non allocated sections are
	 not in PT_LOAD segments.  We ensure this here by removing such
	 sections from the segment map.  */
      for (m = elf_tdata (abfd)->segment_map;
	   m != NULL;
	   m = m->next)
	{
	  unsigned int new_count;
	  unsigned int i;

	  if (m->p_type != PT_LOAD)
	    continue;

	  new_count = 0;
	  for (i = 0; i < m->count; i ++)
	    {
	      if ((m->sections[i]->flags & SEC_ALLOC) != 0)
		{
		  if (i != new_count) 
		    m->sections[new_count] = m->sections[i];

		  new_count ++;
		}
	    }

	  if (new_count != m->count)
	    m->count = new_count;
	}
    }
d3480 2
a3481 3
		  (*_bfd_error_handler)
		    (_("%s: Not enough room for program headers, try linking with -N"),
		     bfd_get_filename (abfd));
a3718 5
  /* If additional nonloadable filepos adjustments are required,
     do them now. */
  if (bed->set_nonloadable_filepos)
    (*bed->set_nonloadable_filepos) (abfd, phdrs);

a4276 1
  struct elf_backend_data * bed;
a4284 1
  bed = get_elf_backend_data (ibfd);
a4311 7
  /* Returns true if the given section is contained within the
     given segment.  Filepos addresses are compared in an elf
     backend function. */
#define IS_CONTAINED_BY_FILEPOS(sec, seg, bed)		\
  (bed->is_contained_by_filepos		  		\
   && (*bed->is_contained_by_filepos) (sec, seg))

d4340 1
a4340 1
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
d4346 1
a4346 3
    || IS_COREFILE_NOTE (segment, section)				\
    || (IS_CONTAINED_BY_FILEPOS (section, segment, bed)			\
        && (section->flags & SEC_ALLOC) == 0))				\
d4446 1
a4446 1
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
d4489 1
a4489 2
	     something.  They are allowed by the ELF spec however, so only
	     a warning is produced.  */
d4491 3
a4493 3
	    (*_bfd_error_handler)
	      (_("%s: warning: Empty loadable segment detected, is this intentional ?\n"),
	       bfd_archive_filename (ibfd));
d4530 1
a4530 3
      /* Gcc 2.96 miscompiles this code on mips. Don't do casting here
	 to work around this long long bug.  */
      amt = section_count * sizeof (asection *);
d4549 1
a4549 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
a4574 1
		  || IS_CONTAINED_BY_FILEPOS (section, segment, bed)
d4644 1
a4644 1
	 those that fit to the current segment and removing them from the
d4695 1
a4695 1
			   < BFD_ALIGN (output_section->lma, maxpagesize))
a4807 1
#undef IS_CONTAINED_BY_FILEPOS
a4826 1
  const struct elf_backend_data *bed = get_elf_backend_data (ibfd);
d4836 18
a4853 25
     already been worked out.  The backend function provides a way to 
     override the test conditions and code path for the call to 
     copy_private_bfd_data.  */
  if (bed->copy_private_bfd_data_p)
    {
      if ((*bed->copy_private_bfd_data_p) (ibfd, isec, obfd, osec))
        if (! copy_private_bfd_data (ibfd, obfd))
          return false;
    } 
  else if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
	asection *s;

	/* Only set up the segments if there are no more SEC_ALLOC
	   sections.  FIXME: This won't do the right thing if objcopy is
	   used to remove the last SEC_ALLOC section, since objcopy
	   won't call this routine in that case.  */
	for (s = isec->next; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) != 0)
	    break;
	if (s == NULL)
	  {
	    if (! copy_private_bfd_data (ibfd, obfd))
	      return false;
	  }
a4866 6
  /* Set things up for objcopy.  The output SHT_GROUP section will
     have its elf_next_in_group pointing back to the input group
     members.  */
  elf_next_in_group (osec) = elf_next_in_group (isec);
  elf_group_name (osec) = elf_group_name (isec);

d4975 1
a4975 1
      outbound_shndx = bfd_zalloc (abfd, amt);
d4978 1
@


1.139.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software 
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 1
a22 1

a354 101
/* Read and convert symbols to internal format.
   SYMCOUNT specifies the number of symbols to read, starting from
   symbol SYMOFFSET.  If any of INTSYM_BUF, EXTSYM_BUF or EXTSHNDX_BUF
   are non-NULL, they are used to store the internal symbols, external
   symbols, and symbol section index extensions, respectively.  */

Elf_Internal_Sym *
bfd_elf_get_elf_syms (ibfd, symtab_hdr, symcount, symoffset,
		      intsym_buf, extsym_buf, extshndx_buf)
     bfd *ibfd;
     Elf_Internal_Shdr *symtab_hdr;
     size_t symcount;
     size_t symoffset;
     Elf_Internal_Sym *intsym_buf;
     PTR extsym_buf;
     Elf_External_Sym_Shndx *extshndx_buf;
{
  Elf_Internal_Shdr *shndx_hdr;
  PTR alloc_ext;
  const PTR esym;
  Elf_External_Sym_Shndx *alloc_extshndx;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  struct elf_backend_data *bed;
  size_t extsym_size;
  bfd_size_type amt;
  file_ptr pos;

  if (symcount == 0)
    return intsym_buf;

  /* Normal syms might have section extension entries.  */
  shndx_hdr = NULL;
  if (symtab_hdr == &elf_tdata (ibfd)->symtab_hdr)
    shndx_hdr = &elf_tdata (ibfd)->symtab_shndx_hdr;

  /* Read the symbols.  */
  alloc_ext = NULL;
  alloc_extshndx = NULL;
  bed = get_elf_backend_data (ibfd);
  extsym_size = bed->s->sizeof_sym;
  amt = symcount * extsym_size;
  pos = symtab_hdr->sh_offset + symoffset * extsym_size;
  if (extsym_buf == NULL)
    {
      alloc_ext = bfd_malloc (amt);
      extsym_buf = alloc_ext;
    }
  if (extsym_buf == NULL
      || bfd_seek (ibfd, pos, SEEK_SET) != 0
      || bfd_bread (extsym_buf, amt, ibfd) != amt)
    {
      intsym_buf = NULL;
      goto out;
    }

  if (shndx_hdr == NULL || shndx_hdr->sh_size == 0)
    extshndx_buf = NULL;
  else
    {
      amt = symcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);
      if (extshndx_buf == NULL)
	{
	  alloc_extshndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  extshndx_buf = alloc_extshndx;
	}
      if (extshndx_buf == NULL
	  || bfd_seek (ibfd, pos, SEEK_SET) != 0
	  || bfd_bread (extshndx_buf, amt, ibfd) != amt)
	{
	  intsym_buf = NULL;
	  goto out;
	}
    }

  if (intsym_buf == NULL)
    {
      bfd_size_type amt = symcount * sizeof (Elf_Internal_Sym);
      intsym_buf = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (intsym_buf == NULL)
	goto out;
    }

  /* Convert the symbols to internal form.  */
  isymend = intsym_buf + symcount;
  for (esym = extsym_buf, isym = intsym_buf, shndx = extshndx_buf;
       isym < isymend;
       esym += extsym_size, isym++, shndx = shndx != NULL ? shndx + 1 : NULL)
    (*bed->s->swap_symbol_in) (ibfd, esym, (const PTR) shndx, isym);

 out:
  if (alloc_ext != NULL)
    free (alloc_ext);
  if (alloc_extshndx != NULL)
    free (alloc_extshndx);

  return intsym_buf;
}

d372 3
d376 1
d389 5
a393 2
  if (bfd_elf_get_elf_syms (abfd, hdr, 1, ghdr->sh_info,
			    &isym, esym, &eshndx) == NULL)
d396 16
d729 1
a729 1
		 loaded data lies within the extent of the segment.
d872 1
a872 1

a1432 1
  table->loaded = NULL;
d1663 1
a1671 33
    case SHT_DYNAMIC:	/* Dynamic linking information.  */
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
	return false;
      if (elf_elfsections (abfd)[hdr->sh_link]->sh_type != SHT_STRTAB)
	{
	  Elf_Internal_Shdr *dynsymhdr;

	  /* The shared libraries distributed with hpux11 have a bogus
	     sh_link field for the ".dynamic" section.  Find the
	     string table for the ".dynsym" section instead.  */
	  if (elf_dynsymtab (abfd) != 0)
	    {
	      dynsymhdr = elf_elfsections (abfd)[elf_dynsymtab (abfd)];
	      hdr->sh_link = dynsymhdr->sh_link;
	    }
	  else
	    {
	      unsigned int i, num_sec;

	      num_sec = elf_numsections (abfd);
	      for (i = 1; i < num_sec; i++)
		{
		  dynsymhdr = elf_elfsections (abfd)[i];
		  if (dynsymhdr->sh_type == SHT_DYNSYM)
		    {
		      hdr->sh_link = dynsymhdr->sh_link;
		      break;
		    }
		}
	    }
	}
      break;

d1946 2
d1949 2
a1950 3
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
d1957 16
a1972 2
  if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
			    &isym, esym, &eshndx) == NULL)
d1974 16
d1998 1
a1998 1
  if (isym.st_shndx < SHN_LORESERVE || isym.st_shndx > SHN_HIRESERVE)
d2001 1
a2001 1
      s = bfd_section_from_elf_index (abfd, isym.st_shndx);
a2072 1
  size_t len;
d2079 1
a2079 2
  len = strlen (namebuf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d2082 1
a2082 1
  memcpy (name, namebuf, len);
d2110 1
a2110 2
      len = strlen (namebuf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d2113 1
a2113 1
      memcpy (name, namebuf, len);
d2668 1
a2668 1
	      alc = (char *) bfd_malloc ((bfd_size_type) (len - 2));
d2671 1
a2671 1
	      memcpy (alc, sec->name, len - 3);
d2680 2
a2681 3
		  if (elf_section_data (s)->this_hdr.sh_entsize == 0)
		    elf_section_data (s)->this_hdr.sh_entsize
		      = 4 + 2 * bfd_get_arch_size (abfd) / 8;
d3483 1
a3483 1
		  if (i != new_count)
d3549 1
a3549 1
         sections may not be correctly ordered.  NOTE: sorting should
d3553 2
a3554 2
      if (m->count > 1
	  && !(elf_elfheader (abfd)->e_type == ET_CORE
d4445 3
a4447 3
#define SEGMENT_END(segment, start)					\
  (start + (segment->p_memsz > segment->p_filesz			\
	    ? segment->p_memsz : segment->p_filesz))
d4451 4
a4454 4
#define IS_CONTAINED_BY_VMA(section, segment)				\
  (section->vma >= segment->p_vaddr					\
   && (section->vma + section->_raw_size				\
       <= (SEGMENT_END (segment, segment->p_vaddr))))
d4458 4
a4461 4
#define IS_CONTAINED_BY_LMA(section, segment, base)			\
  (section->lma >= base							\
   && (section->lma + section->_raw_size				\
       <= SEGMENT_END (segment, base)))
d4466 2
a4467 2
#define IS_CONTAINED_BY_FILEPOS(sec, seg, bed)				\
  (bed->is_contained_by_filepos						\
d4471 7
a4477 7
#define IS_COREFILE_NOTE(p, s)						\
  (p->p_type == PT_NOTE							\
   && bfd_get_format (ibfd) == bfd_core					\
   && s->vma == 0 && s->lma == 0					\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))
d4482 8
a4489 10
#define IS_SOLARIS_PT_INTERP(p, s)					\
  (p->p_vaddr == 0							\
   && p->p_paddr == 0							\
   && p->p_memsz == 0							\
   && p->p_filesz > 0							\
   && (s->flags & SEC_HAS_CONTENTS) != 0				\
   && s->_raw_size > 0							\
   && (bfd_vma) s->filepos >= p->p_offset				\
   && ((bfd_vma) s->filepos + s->_raw_size				\
       <= p->p_offset + p->p_filesz))
d4499 4
a4502 3
  ((((segment->p_paddr							\
      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr)	\
      : IS_CONTAINED_BY_VMA (section, segment))				\
d4508 1
a4508 1
   && ! section->segment_mark)
d4511 2
a4512 2
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)				\
  (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))
d4515 2
a4516 3
#define SEGMENT_OVERLAPS(seg1, seg2)					\
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2)					\
     || SEGMENT_AFTER_SEGMENT (seg2, seg1)))
d4525 1
a4525 1
     parameters to objcopy.  Also, fix some solaris weirdness.  */
a4532 10
      if (segment->p_type == PT_INTERP)
	for (section = ibfd->sections; section; section = section->next)
	  if (IS_SOLARIS_PT_INTERP (segment, section))
	    {
	      /* Mininal change so that the normal section to segment
		 assigment code will work.  */
	      segment->p_vaddr = section->vma;
	      break;
	    }

d5002 2
a5003 2
     already been worked out.  The backend function provides a way to
     override the test conditions and code path for the call to
d5010 1
a5010 1
    }
d5967 2
a5968 2
      && ! (_bfd_elf_compute_section_file_positions
	    (abfd, (struct bfd_link_info *) NULL)))
a6190 1
  size_t len;
d6196 1
a6196 2
  len = strlen (buf) + 1;
  threaded_name = bfd_alloc (abfd, (bfd_size_type) len);
d6199 1
a6199 1
  memcpy (threaded_name, buf, len);
a6483 1
  size_t len;
d6501 1
a6501 2
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6504 1
a6504 1
  memcpy (name, buf, len);
d6530 1
a6530 2
  len = strlen (buf) + 1;
  name = bfd_alloc (abfd, (bfd_size_type) len);
d6533 1
a6533 1
  memcpy (name, buf, len);
a6564 1
  size_t len;
d6585 1
a6585 2
      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6589 1
a6589 1
      memcpy (name, buf, len);
d6611 1
a6611 2
      len = strlen (buf) + 1;
      name = bfd_alloc (abfd, (bfd_size_type) len);
d6615 1
a6615 1
      memcpy (name, buf, len);
d6749 1
a6749 1

d6757 1
a6757 1

d6802 1
a6802 1
   Inputs:
d6817 1
a6817 1
     const char *name;
d6819 1
a6819 1
     const PTR input;
d6823 2
a6824 3
  size_t namesz;
  size_t pad;
  size_t newspace;
a6826 13
  namesz = 0;
  pad = 0;
  if (name != NULL)
    {
      struct elf_backend_data *bed;

      namesz = strlen (name) + 1;
      bed = get_elf_backend_data (abfd);
      pad = -namesz & (bed->s->file_align - 1);
    }

  newspace = sizeof (Elf_External_Note) - 1 + namesz + pad + size;

d6834 2
a6835 12
  dest = xnp->name;
  if (name != NULL)
    {
      memcpy (dest, name, namesz);
      dest += namesz;
      while (pad != 0)
	{
	  *dest++ = '\0';
	  --pad;
	}
    }
  memcpy (dest, input, size);
d6845 2
a6846 2
     const char *fname;
     const char *psargs;
d6862 1
a6862 1
  return elfcore_write_note (abfd, buf, bufsiz,
d6875 1
a6875 1
     const PTR gregs;
d6884 1
a6884 1
  return elfcore_write_note (abfd, buf, bufsiz,
d6897 1
a6897 1
     const PTR gregs;
d6916 1
a6916 1
  return elfcore_write_note (abfd, buf, bufsiz, note_name,
d6929 1
a6929 1
     const PTR gregs;
d6936 1
a6936 1
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name,
d6947 1
a6947 1
     const PTR fpregs;
d6951 1
a6951 1
  return elfcore_write_note (abfd, buf, bufsiz,
d6960 1
a6960 1
     const PTR xfpregs;
d6964 1
a6964 1
  return elfcore_write_note (abfd, buf, bufsiz,
d7145 1
a7145 1
/* For RELA architectures, return the relocation value for a
d7184 1
a7184 1
{
@


1.139.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software 
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d2446 1
a2446 14
    {
      this_hdr->sh_flags |= SHF_TLS;
      if (asect->_raw_size == 0 && (asect->flags & SEC_HAS_CONTENTS) == 0)
	{
	  struct bfd_link_order *o;
                                          
	  this_hdr->sh_size = 0;
	  for (o = asect->link_order_head; o != NULL; o = o->next)
	    if (this_hdr->sh_size < o->offset + o->size)
	      this_hdr->sh_size = o->offset + o->size;
	  if (this_hdr->sh_size)
	    this_hdr->sh_type = SHT_NOBITS;
	}
    }
d4816 1
a4816 2
		 correct value.  Note - some backends require that
		 p_paddr be left as zero.  */
a4818 1
		  && (! bed->want_p_paddr_set_to_zero)
d4835 1
a4835 4
		  || IS_COREFILE_NOTE (segment, section)
		  || (bed->want_p_paddr_set_to_zero &&
		      IS_CONTAINED_BY_VMA (output_section, segment))
                )
@


1.139.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d374 1
a374 1
  const bfd_byte *esym;
d1421 1
a1421 2
_bfd_elf_link_hash_copy_indirect (bed, dir, ind)
     struct elf_backend_data *bed;
a1424 1
  bfd_signed_vma lowest_valid = bed->can_refcount;
d1442 1
a1442 1
  if (tmp < lowest_valid)
d1448 1
a1448 1
    BFD_ASSERT (ind->got.refcount < lowest_valid);
d1451 1
a1451 1
  if (tmp < lowest_valid)
d1457 1
a1457 1
    BFD_ASSERT (ind->plt.refcount < lowest_valid);
@


1.139.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d3320 2
a3321 3
	       && (((last_hdr->lma + last_hdr->_raw_size - 1)
		    & ~(maxpagesize - 1))
		   != (hdr->lma & ~(maxpagesize - 1))))
d5575 1
a5575 5
  long symcount = bed->s->slurp_symbol_table (abfd, alocation, true);

  if (symcount >= 0)
    bfd_get_dynamic_symcount (abfd) = symcount;
  return symcount;
d6044 1
a6044 1
  if (found && (*functionname_ptr || *line_ptr))
@


1.139.2.6
log
@merge from mainline
@
text
@d6806 2
a6807 2
      if (note->namesz == 6
	  && strcmp (note->namedata, "LINUX") == 0)
@


1.139.2.7
log
@merge from mainline
@
text
@d2674 1
a2674 1
  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);
d2679 1
a2679 1
  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd, amt);
d2685 1
@


1.138
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d594 2
d888 1
d2280 2
d2964 2
d3204 33
d3661 14
d3809 10
d5112 3
a5114 1
      if ((flags & BSF_FUNCTION) != 0)
d5120 3
@


1.137
log
@	* elf.c (prep_headers): Don't zero EI_OSABI, EI_ABIVERSION or
	header pad.
@
text
@d817 13
@


1.137.4.1
log
@merge from trunk
@
text
@a52 1
static const char *group_signature PARAMS ((bfd *, Elf_Internal_Shdr *));
d56 1
a363 60
/* Return the name of the group signature symbol.  Why isn't the
   signature just a string?  */

static const char *
group_signature (abfd, ghdr)
     bfd *abfd;
     Elf_Internal_Shdr *ghdr;
{
  struct elf_backend_data *bed;
  file_ptr pos;
  bfd_size_type amt;
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Shdr *shndx_hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;
  unsigned int iname;
  unsigned int shindex;

  /* First we need to ensure the symbol table is available.  */
  if (! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return NULL;

  /* Go read the symbol.  */
  hdr = &elf_tdata (abfd)->symtab_hdr;
  bed = get_elf_backend_data (abfd);
  amt = bed->s->sizeof_sym;
  pos = hdr->sh_offset + ghdr->sh_info * amt;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bread (esym, amt, abfd) != amt)
    return NULL;

  /* And possibly the symbol section index extension.  */
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
  if (elf_elfsections (abfd) != NULL
      && elf_elfsections (abfd)[shndx_hdr->sh_link] == hdr)
    {
      amt = sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + ghdr->sh_info * amt;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bread ((PTR) &eshndx, amt, abfd) != amt)
	return NULL;
    }

  /* Convert to internal format.  */
  (*bed->s->swap_symbol_in) (abfd, (const PTR *) &esym, (const PTR *) &eshndx,
			     &isym);

  /* Look up the symbol name.  */
  iname = isym.st_name;
  shindex = hdr->sh_link;
  if (iname == 0 && ELF_ST_TYPE (isym.st_info) == STT_SECTION)
    {
      iname = elf_elfsections (abfd)[isym.st_shndx]->sh_name;
      shindex = elf_elfheader (abfd)->e_shstrndx;
    }

  return bfd_elf_string_from_elf_section (abfd, shindex, iname);
}

a442 3
			  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))
			    shdr->bfd_section->flags
			      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
d495 4
d501 10
a510 2
		    gname = group_signature (abfd, shdr);
		    if (gname == NULL)
d512 2
a518 3

		/* If the group section has been created, point to the
		   new member.  */
a520 1

a534 19
boolean
bfd_elf_discard_group (abfd, group)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *group;
{
  asection *first = elf_next_in_group (group);
  asection *s = first;

  while (s != NULL)
    {
      s->output_section = bfd_abs_section_ptr;
      s = elf_next_in_group (s);
      /* These lists are circular.  */
      if (s == first)
	break;
    }
  return true;
}

a593 2
  if ((hdr->sh_flags & SHF_TLS) != 0)
    flags |= SEC_THREAD_LOCAL;
d621 1
a621 2
  if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0
      && elf_next_in_group (newsect) == NULL)
a816 13

void
_bfd_elf_link_just_syms (sec, info)
     asection *sec;
     struct bfd_link_info *info;
{
  sec->output_section = bfd_abs_section_ptr;
  sec->output_offset = sec->vma;
  if (!is_elf_hash_table (info))
    return;

  elf_section_data (sec)->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
}
a872 1
	    case PT_TLS: pt = "TLS"; break;
d1563 1
a1563 1
  const char *name;
d1807 1
a1807 6
      /* We need a BFD section for objcopy and relocatable linking,
	 and it's handy to have the signature available as the section
	 name.  */
      name = group_signature (abfd, hdr);
      if (name == NULL)
	return false;
a1815 4
	  if (idx->flags & GRP_COMDAT)
	    hdr->bfd_section->flags
	      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

d2262 1
a2262 1
  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)
a2263 2
  if ((asect->flags & SEC_THREAD_LOCAL) != 0)
    this_hdr->sh_flags |= SHF_TLS;
d2284 2
a2285 2
void
bfd_elf_set_group_contents (abfd, sec, failedptrarg)
d2288 1
a2288 1
     PTR failedptrarg;
d2292 1
a2292 1
  asection *elt, *first;
a2294 1
  boolean gas;
d2300 7
a2306 13
  symindx = 0;
  if (elf_group_id (sec) != NULL)
    symindx = elf_group_id (sec)->udata.i;

  if (symindx == 0)
    {
      /* If called from the assembler, swap_out_syms will have set up
	 elf_section_syms;  If called for "ld -r", use target_index.  */
      if (elf_section_syms (abfd) != NULL)
	symindx = elf_section_syms (abfd)[sec->index]->udata.i;
      else
	symindx = sec->target_index;
    }
d2309 1
a2309 2
  /* The contents won't be allocated for "ld -r" or objcopy.  */
  gas = true;
a2311 1
      gas = false;
a2312 3

      /* Arrange for the section to be written out.  */
      elf_section_data (sec)->this_hdr.contents = sec->contents;
d2322 3
a2324 4
  /* Get the pointer to the first section in the group that gas
     squirreled away here.  objcopy arranges for this to be set to the
     start of the input section group.  */
  first = elt = elf_next_in_group (sec);
a2331 3
      asection *s;
      unsigned int idx;

d2333 1
a2333 7
      s = elt;
      if (!gas)
	s = s->output_section;
      idx = 0;
      if (s != NULL)
	idx = elf_section_data (s)->this_idx;
      H_PUT_32 (abfd, idx, loc);
a2334 2
      if (elt == first)
	break;
d2353 2
a2354 8
  /* With ld -r, merging SHT_GROUP sections results in wasted space
     due to allowing for the flag word on each input.  We may well
     duplicate entries too.  */
  while ((loc -= 4) > sec->contents)
    H_PUT_32 (abfd, 0, loc);

  if (loc != sec->contents)
    abort ();
d2356 1
a2356 1
  H_PUT_32 (abfd, sec->flags & SEC_LINK_ONCE ? GRP_COMDAT : 0, loc);
d2837 1
a2837 1
  if (link_info == NULL)
d2839 1
a2839 1
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
a2945 2
  int tls_count = 0;
  asection *first_tls = NULL;
a3183 33
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  if (! tls_count)
	    first_tls = s;
	  tls_count++;
	}
    }

  /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
  if (tls_count > 0)
    {
      int i;

      amt = sizeof (struct elf_segment_map);
      amt += (tls_count - 1) * sizeof (asection *);
      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
      if (m == NULL)
	goto error_return;
      m->next = NULL;
      m->p_type = PT_TLS;
      m->count = tls_count;
      /* Mandated PF_R.  */
      m->p_flags = PF_R;
      m->p_flags_valid = 1;
      for (i = 0; i < tls_count; ++i)
	{
	  BFD_ASSERT (first_tls->flags & SEC_THREAD_LOCAL);
	  m->sections[i] = first_tls;
	  first_tls = first_tls->next;
	}

      *pm = m;
      pm = &m->next;
a3297 31
  else
    {
      /* The placement algorithm assumes that non allocated sections are
	 not in PT_LOAD segments.  We ensure this here by removing such
	 sections from the segment map.  */
      for (m = elf_tdata (abfd)->segment_map;
	   m != NULL;
	   m = m->next)
	{
	  unsigned int new_count;
	  unsigned int i;

	  if (m->p_type != PT_LOAD)
	    continue;

	  new_count = 0;
	  for (i = 0; i < m->count; i ++)
	    {
	      if ((m->sections[i]->flags & SEC_ALLOC) != 0)
		{
		  if (i != new_count) 
		    m->sections[new_count] = m->sections[i];

		  new_count ++;
		}
	    }

	  if (new_count != m->count)
	    m->count = new_count;
	}
    }
d3427 2
a3428 3
		  (*_bfd_error_handler)
		    (_("%s: Not enough room for program headers, try linking with -N"),
		     bfd_get_filename (abfd));
a3607 14
	      if (p->p_type == PT_TLS
		  && sec->_raw_size == 0
		  && (sec->flags & SEC_HAS_CONTENTS) == 0)
		{
		  struct bfd_link_order *o;
		  bfd_vma tbss_size = 0;

		  for (o = sec->link_order_head; o != NULL; o = o->next)
		    if (tbss_size < o->offset + o->size)
		      tbss_size = o->offset + o->size;

		  p->p_memsz += tbss_size;
		}

a3651 5
  /* If additional nonloadable filepos adjustments are required,
     do them now. */
  if (bed->set_nonloadable_filepos)
    (*bed->set_nonloadable_filepos) (abfd, phdrs);

a3741 10
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (s->flags & SEC_THREAD_LOCAL)
	{
	  /* We need a PT_TLS segment.  */
	  ++segs;
	  break;
	}
    }

a4199 1
  struct elf_backend_data * bed;
a4207 1
  bed = get_elf_backend_data (ibfd);
a4234 7
  /* Returns true if the given section is contained within the
     given segment.  Filepos addresses are compared in an elf
     backend function. */
#define IS_CONTAINED_BY_FILEPOS(sec, seg, bed)		\
  (bed->is_contained_by_filepos		  		\
   && (*bed->is_contained_by_filepos) (sec, seg))

d4263 1
a4263 1
#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed)		\
d4269 1
a4269 3
    || IS_COREFILE_NOTE (segment, section)				\
    || (IS_CONTAINED_BY_FILEPOS (section, segment, bed)			\
        && (section->flags & SEC_ALLOC) == 0))				\
d4369 1
a4369 1
	if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
d4412 1
a4412 2
	     something.  They are allowed by the ELF spec however, so only
	     a warning is produced.  */
d4414 3
a4416 3
	    (*_bfd_error_handler)
	      (_("%s: warning: Empty loadable segment detected, is this intentional ?\n"),
	       bfd_archive_filename (ibfd));
d4453 1
a4453 3
      /* Gcc 2.96 miscompiles this code on mips. Don't do casting here
	 to work around this long long bug.  */
      amt = section_count * sizeof (asection *);
d4472 1
a4472 1
	  if (INCLUDE_SECTION_IN_SEGMENT (section, segment, bed))
a4497 1
		  || IS_CONTAINED_BY_FILEPOS (section, segment, bed)
d4567 1
a4567 1
	 those that fit to the current segment and removing them from the
d4618 1
a4618 1
			   < BFD_ALIGN (output_section->lma, maxpagesize))
a4730 1
#undef IS_CONTAINED_BY_FILEPOS
a4749 1
  const struct elf_backend_data *bed = get_elf_backend_data (ibfd);
d4759 18
a4776 25
     already been worked out.  The backend function provides a way to 
     override the test conditions and code path for the call to 
     copy_private_bfd_data.  */
  if (bed->copy_private_bfd_data_p)
    {
      if ((*bed->copy_private_bfd_data_p) (ibfd, isec, obfd, osec))
        if (! copy_private_bfd_data (ibfd, obfd))
          return false;
    } 
  else if (elf_tdata (obfd)->segment_map == NULL && elf_tdata (ibfd)->phdr != NULL)
    {
	asection *s;

	/* Only set up the segments if there are no more SEC_ALLOC
	   sections.  FIXME: This won't do the right thing if objcopy is
	   used to remove the last SEC_ALLOC section, since objcopy
	   won't call this routine in that case.  */
	for (s = isec->next; s != NULL; s = s->next)
	  if ((s->flags & SEC_ALLOC) != 0)
	    break;
	if (s == NULL)
	  {
	    if (! copy_private_bfd_data (ibfd, obfd))
	      return false;
	  }
a4789 6
  /* Set things up for objcopy.  The output SHT_GROUP section will
     have its elf_next_in_group pointing back to the input group
     members.  */
  elf_next_in_group (osec) = elf_next_in_group (isec);
  elf_group_name (osec) = elf_group_name (isec);

d4898 1
a4898 1
      outbound_shndx = bfd_zalloc (abfd, amt);
d4901 1
d5035 1
a5035 3
      if ((flags & BSF_THREAD_LOCAL) != 0)
	type = STT_TLS;
      else if ((flags & BSF_FUNCTION) != 0)
a5040 3

      if (syms[idx]->section->flags & SEC_THREAD_LOCAL)
	type = STT_TLS;
@


1.136
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@a3883 1
  int count;
a3904 6

  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NONE;
  i_ehdrp->e_ident[EI_ABIVERSION] = 0;

  for (count = EI_PAD; count < EI_NIDENT; count++)
    i_ehdrp->e_ident[count] = 0;
@


1.135
log
@	* elf.c (_bfd_elf_make_section_from_shdr): When setting section
	LMAs, loop over segments until p_vaddr and p_memsz specify an
	extent enclosing the section.
@
text
@d1363 1
a1363 1
  ret = (struct elf_link_hash_table *) bfd_alloc (abfd, amt);
d1369 1
a1369 1
      bfd_release (abfd, ret);
@


1.134
log
@2002-04-01  Nathan Williams  <nathanw@@wasabisystems.com>

* elf.c (elfcore_netbsd_get_lwpid): Fix off-by-one erro
which caused the returned LWP ID to always be 0.
@
text
@d668 2
a669 2
		      || (phdr->p_offset + phdr->p_filesz
			  >= hdr->sh_offset + hdr->sh_size)))
d672 2
a673 1
		    newsect->lma += phdr->p_paddr - phdr->p_vaddr;
d684 9
a692 1
		  break;
@


1.133
log
@	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.
@
text
@d6444 1
a6444 1
      *lwpidp = atoi(cp);
@


1.132
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.
@
text
@d5116 3
a5118 1
  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
d5138 3
a5140 1
  symtab_size = (symcount - 1 + 1) * (sizeof (asymbol *));
@


1.131
log
@2002-03-04  H.J. Lu <hjl@@gnu.org>

	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.

	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.
@
text
@d658 1
a658 1
		 though as a perfectly valid, initialised segment can
d660 1
a660 1
	         place special significance one the address 0 and
d671 12
a682 9
		  /* We used to do a relative adjustment here, but
		     that doesn't work if the segment is packed with
		     code from multiple VMAs.  Instead we calculate
		     the LMA absoultely, based on the LMA of the
		     segment (it is assumed that the segment will
		     contain sections with contiguous LMAs, even if
		     the VMAs are not).  */
		  newsect->lma = phdr->p_paddr
		    + hdr->sh_offset - phdr->p_offset;
@


1.130
log
@	* elf.c (elf_fake_sections): Use SHT_NOBITS when SEC_NEVER_LOAD.
@
text
@d1566 3
d2183 6
@


1.129
log
@2002-02-11  Michael Snyder  <msnyder@@redhat.com>

	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d2222 2
a2223 1
	   && ((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0))
@


1.128
log
@Accept a physicall address of 0 as valid in a program header
@
text
@d6156 2
d6195 2
d6610 32
d6655 5
a6659 5
  memset (&pstat, 0, sizeof (prstat));
  pstat.pr_pid = pid;
  memcpy (pstat.pr_reg, gregs, sizeof (pstat.pr_reg));
  return elfcore_write_note (abfd, buf, bufsiz, 
			     note_name, NT_PSTATUS, &pstat, sizeof (pstat));
@


1.127
log
@Don't translate debugging  message.
@
text
@d655 8
a662 2
		 If the p_paddr field is not set, we don't alter the 
		 LMA.  */
a663 1
		  && phdr->p_paddr
@


1.127.2.1
log
@	* elf.c (elf_fake_sections): Use SHT_NOBITS when SEC_NEVER_LOAD.
@
text
@d2217 1
a2217 2
	   && (((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
	       || (asect->flags & SEC_NEVER_LOAD) != 0))
@


1.127.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

	Merge from mainline
	2002-03-27  Gregory Steuck <greg@@nest.cx>
	* elf.c (_bfd_elf_get_symtab_upper_bound): Leave space for
	terminating NULL if empty symbol table.
	(_bfd_elf_get_dynamic_symtab_upper_bound): Likewise.

	2002-03-26  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_gc_mark): Don't recurse into non-ELF sections.

	2002-03-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set lma based on
	section file offset for !SEC_LOAD sections.

	2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>
	* dwarf2.c (struct funcinfo): Move up.
	(lookup_address_in_function_table): New argument function_ptr.
	Set it.
	(lookup_address_in_line_table): New argument function.  If function
	is non-NULL, use it to handle ``addr'' before the first line note of
	the function.
	(comp_unit_find_nearest_line): Update and swap calls to
	lookup_address_in_function_table and lookup_address_in_line_table.
	* syms.c (_bfd_stab_section_find_nearest_line): Use the first
	N_SLINE encountered if we see an N_FUN before any N_SLINE.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* libbfd.c (bfd_write_bigendian_4byte_int): Return true iff success.
	* libbfd.h: Regenerate.
	* archive.c (coff_write_armap): Pass on failures from
	bfd_write_bigendian_4byte_int.

	2002-03-14  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Set the BFD
	error to bfd_error_nonrepresentable_section for reinit_array
	section in DSO.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* coffcode.h (coff_slurp_symbol_table): When adding BSF_WEAK flag,
	OR it in rather than replacing previously selected flags.
	* elfxx-target.h (TARGET_BIG_SYM): Set ar_max_namelen to 15.
	(TARGET_LITTLE_SYM): Set ar_max_namelen to 15.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_bfd_final_link): Revert last change.  Instead,
	ensure reloc size matches before calling elf_link_input_bfd.
	Add an assert to check reloc size when counting output relocs.

	2002-03-14  Nick Clifton  <nickc@@cambridge.redhat.com>
	* mmo.c (mmo_get_loc): Return NULL rather than false.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes.
	(elf_link_output_extsym): Merge undefined and undef weak cases.
	* elflink.h (elf_bfd_final_link): Only call elf_link_input_bfd
	when word size of input matches output word size.

	2002-03-07  H.J. Lu  (hjl@@gnu.org)
	* coff-sh.c (shcoff_reloc_map): Use bfd_reloc_code_real_type
	as the type for bfd_reloc_val.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* elf-hppa.h (elf_hppa_is_dynamic_loader_symbol): New function.
	(elf_hppa_relocate_section): Ignore undefined dynamic loader symbols.
	(elf_hppa_final_link_relocate): Correct relocations for indirect
	references to local data through the DLT.  Fix .opd creation for
	local symbols using R_PARISC_LTOFF_FPTR32 and R_PARISC_FPTR64
	relocations.  Use e_lsel selector for R_PARISC_DLTIND21L,
	R_PARISC_LTOFF_FPTR21L and R_PARISC_LTOFF_TP21L as per
	"Processor-Specific ELF for PA_RISC, Version 1.43" document.
	Similarly, use e_rsel for DLT and LTOFF 'R' relocations.
	* elf32-hppa.c (final_link_relocate): Revise relocation selectors
	as per "Processor-Specific ELF for PA_RISC, Version 1.43" document.

	2002-03-05  Jakub Jelinek  <jakub@@redhat.com>
	* merge.c (_bfd_merge_sections): Don't segfault if there
	is nothing to merge due to GC.

	2002-03-05  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (clobber_millicode_symbols): Remove hack to keep
	symbols that have been forced local.
	* elflink.h (elf_bfd_final_link): Call elf_link_output_extsym
	to output forced local syms for non-shared link.
	(elf_link_output_extsym): Tweak condition for calling backend
	adjust_dynamic_symbol so that previous behaviour is kept.
	Whitespace changes throughout file.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* elf.c (bfd_section_from_shdr): Handle special sections,
	.init_array, .fini_array and .preinit_array.
	(elf_fake_sections): Likewise.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Create the
	DT entry only if the section is in output for .init_array,
	.fini_array and .preinit_array. Complain about .preinit_array
	section in DSO.
	(elf_bfd_final_link): Warn zero size for .init_array,
	.fini_array and .preinit_array sections.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Remove
	SHT_INIT_ARRAY, SHT_FINI_ARRAY and SHT_PREINIT_ARRAY.
	(elfNN_ia64_fake_sections): Remove .init_array, .fini_array and
	.preinit_array.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* elflink.h (size_dynamic_sections): If section named
	".preinit_array" exists, create DT_PREINIT_ARRAY and
	DT_PREINIT_ARRAYSZ entries in dynamic table.  Analogously for
	".init_array" and ".fini_array".
	(elf_bfd_final_link): Handle DT_PREINIT_ARRAYSZ, DT_INIT_ARRAYSZ,
	DT_FINI_ARRAYSZ, DT_PREINIT_ARRAY, DT_INIT_ARRAY, and
	DT_FINI_ARRAY.

	2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>
	* syms.c (stt[]): Sorted.  Added .init/.fini -> "t" mapping.

	2002-02-13  Nick Clifton  <nickc@@cambridge.redhat.com>
	* elf.c (_bfd_elf_make_section_from_shdr): Do not insist on
	non-zero physical addresses when adjusting the LMAs of new
	sections.

	2002-02-11  Michael Snyder  <msnyder@@redhat.com>
	* elf-bfd.h (elfcore_write_lwpstatus): Add prototype.
	* elf.c (elfcore_grok_pstatus): Add prototype.
	(elfcore_grok_lwpstatus): Add prototype.
	(elfcore_write_lwpstatus): New function.
	(elfcore_write_pstatus): Fix typo, eliminate unnecessary memcpy.
@
text
@d655 2
a656 8

		 Note - we used to check the p_paddr field as well, and
		 refuse to set the LMA if it was 0.  This is wrong
		 though, as a perfectly valid initialised segment can
		 have a p_paddr of zero.  Some architectures, eg ARM,
	         place special significance on the address 0 and
	         executables need to be able to have a segment which
	         covers this address.  */
d658 1
d666 9
a674 12
		  if ((flags & SEC_LOAD) == 0)
		    newsect->lma += phdr->p_paddr - phdr->p_vaddr;
		  else
		    /* We used to use the same adjustment for SEC_LOAD
		       sections, but that doesn't work if the segment
		       is packed with code from multiple VMAs.
		       Instead we calculate the section LMA based on
		       the segment LMA.  It is assumed that the
		       segment will contain sections with contiguous
		       LMAs, even if the VMAs are not.  */
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_offset - phdr->p_offset);
a1560 3
    case SHT_INIT_ARRAY:	/* .init_array section.  */
    case SHT_FINI_ARRAY:	/* .fini_array section.  */
    case SHT_PREINIT_ARRAY:	/* .preinit_array section.  */
a2174 6
  else if (strcmp (asect->name, ".init_array") == 0)
    this_hdr->sh_type = SHT_INIT_ARRAY;
  else if (strcmp (asect->name, ".fini_array") == 0)
    this_hdr->sh_type = SHT_FINI_ARRAY;
  else if (strcmp (asect->name, ".preinit_array") == 0)
    this_hdr->sh_type = SHT_PREINIT_ARRAY;
d5099 1
a5099 3
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);
d5119 1
a5119 3
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);
a6151 2
static boolean elfcore_grok_pstatus PARAMS ((bfd *, Elf_Internal_Note *));

a6188 2
static boolean elfcore_grok_lwpstatus PARAMS ((bfd *, Elf_Internal_Note *));

a6601 32
#if defined (HAVE_LWPSTATUS_T)
char *
elfcore_write_lwpstatus (abfd, buf, bufsiz, pid, cursig, gregs)
     bfd *abfd;
     char *buf;
     int *bufsiz;
     long pid;
     int cursig;
     void *gregs;
{
  lwpstatus_t lwpstat;
  char *note_name = "CORE";

  memset (&lwpstat, 0, sizeof (lwpstat));
  lwpstat.pr_lwpid  = pid >> 16;
  lwpstat.pr_cursig = cursig;
#if defined (HAVE_LWPSTATUS_T_PR_REG)
  memcpy (lwpstat.pr_reg, gregs, sizeof (lwpstat.pr_reg));
#elif defined (HAVE_LWPSTATUS_T_PR_CONTEXT)
#if !defined(gregs)
  memcpy (lwpstat.pr_context.uc_mcontext.gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.gregs));
#else
  memcpy (lwpstat.pr_context.uc_mcontext.__gregs,
	  gregs, sizeof (lwpstat.pr_context.uc_mcontext.__gregs));
#endif
#endif
  return elfcore_write_note (abfd, buf, bufsiz, note_name, 
			     NT_LWPSTATUS, &lwpstat, sizeof (lwpstat));
}
#endif /* HAVE_LWPSTATUS_T */

d6615 5
a6619 5
  memset (&pstat, 0, sizeof (pstat));
  pstat.pr_pid = pid & 0xffff;
  buf = elfcore_write_note (abfd, buf, bufsiz, note_name, 
			    NT_PSTATUS, &pstat, sizeof (pstat));
  return buf;
@


1.127.2.3
log
@2002-04-01  Nathan Williams  <nathanw@@wasabisystems.com>

* elf.c (elfcore_netbsd_get_lwpid): Fix off-by-one error
which caused the returned LWP ID to always be 0.
@
text
@d6444 1
a6444 1
      *lwpidp = atoi(cp + 1);
@


1.127.2.4
log
@Merge from mainline.
@
text
@d668 2
a669 2
		      || (hdr->sh_offset + hdr->sh_size
			  <= phdr->p_offset + phdr->p_filesz)))
d672 1
a672 2
		    newsect->lma = (phdr->p_paddr
				    + hdr->sh_addr - phdr->p_vaddr);
d683 1
a683 9

		  /* With contiguous segments, we can't tell from file
		     offsets whether a section with zero size should
		     be placed at the end of one segment or the
		     beginning of the next.  Decide based on vaddr.  */
		  if (hdr->sh_addr >= phdr->p_vaddr
		      && (hdr->sh_addr + hdr->sh_size
			  <= phdr->p_vaddr + phdr->p_memsz))
		    break;
@


1.127.2.5
log
@	Merge from mainline
	2002-04-12  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (prep_headers): Don't zero EI_OSABI, EI_ABIVERSION or
	header pad.

	2002-02-21  Andreas Jaeger  <aj@@suse.de>
	* elf64-x86-64.c: Major rework that introduces all recent changes
	to the x86-64 backend.  Get a closer match to elf32-i386.
	(struct elf64_x86_64_dyn_relocs): Rename from
	elf64_x86_64_pcrel_relocs_copied, add additional fields.  Change
	all users.
	(struct elf64_x86_64_link_hash_table): Add short cuts to some
	sections.
	(link_hash_newfunc): Rename from elf64_x86_64_link_hash_newfunc,
	remove casts, initialize new hash members.
	(create_got_section): New.
	(elf64_x86_64_create_dynamic_sections): New.
	(elf64_x86_64_copy_indirect_symbol): New.
	(elf64_x86_64_check_relocs): Don't allocate space for dynamic
	relocs, .got or .relgot here but do it in allocate_dynrelocs.
	Reference count possible .plt and .got entries.  Don't test input
	section SEC_READONLY here to try to avoid copy relocs, and keep
	dyn_relocs regardless of ELF_LINK_NON_GOT_REF.  Don't set
	DF_TEXTREL here.  Delay setting of variables until needed.  Cache
	pointer to "sreloc" section in elf_section_data. Tweak condition
	under which .got created.  Report files with bad relocation
	section names.
	(elf64_x86_64_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
	Reference count possible .plt entries.  Don't deallocate .got and
	.relgot space here.
	(elf64_x86_64_adjust_dynamic_symbol): Handle nocopyreloc.  Don't
	do copy reloc processing for weakdefs.  Remove redundant casts and
	aborts.  Delay setting of vars until needed.  Move creation of
	dynamic symbols and allocation of .plt and .rela.plt to
	allocate_dynrelocs.  Replace BFD_ASSERT with abort.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(allocate_dynrelocs): New.
	(readonly_dynrelocs): New.
	(elf64_x86_64_size_dynamic_sections): Call readonly_dynrelocs.
	Allocate space for dyn relocs.  Replace BFD_ASSERT with abort.
	Zero out the dynamic allocated content space.
	(elf64_x86_64_discard_copies): Removed.
	(elf64_x86_64_relocate_section): Make use of dynamic section
	short-cuts.  Localise vars, and delay setting.  Better error
	reporting, replace BFD_ASSERT with abort.  Check
	ELF_LINK_HASH_DEF_DYNAMIC to see if a symbol is not defined in the
	regular object file and tread the weak definition as the normal
	one.  Don't discard relocs for undefweak or undefined symbols and
	check !DEF_REGULAR as well as DEF_DYNAMIC in test for avoided copy
	relocs.
	(elf64_x86_64_finish_dynamic_symbol): Don't copy relocs for
	symbols that have been forced local.  Use same test to decide if
	we can use a relative reloc for got as relocate_section.  Expand
	SHN_UNDEF comment.  Move expressions out of function calls.
	Replace BFD_ASSERT with abort.
	(bfd_elf64_bfd_final_link): Removed.
	(elf_backend_copy_indirect_symbol): Define.
@
text
@d3884 1
d3906 6
@


1.126
log
@Copy only as much information as possible to avoid stack corruption.
@
text
@d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d21 2
a22 3
/*

SECTION
d31 1
a31 2
	haven't bothered yet.
 */
d4151 1
a4151 1
	     _("elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n"),
@


1.125
log
@* elf.c (elfcore_write_prstatus): Make sure we pass the address of
prstat.pr_reg even if it is a struct.
@
text
@d6285 1
a6285 1
  memcpy (&pstatus, note->descdata, note->descsz);
@


1.124
log
@	* elf-bfd.h (elf_backend_data <elf_backend_hide_symbol>): Add
	boolean param.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Adjust call to
	elf_backend_hide_symbol.
	(elf_fix_symbol_flags): Likewise.
	(elf_link_assign_sym_version): Likewise. Use bfd_malloc rather
	than bfd_alloc.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Add "force_local" param.
	Set ELF_LINK_FORCED_LOCAL and call _bfd_elf_strtab_delref.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	(clobber_millicode_symbols): Adjust to suit new hide_symbol.
	* elf32-cris.c (elf_cris_hide_symbol): Add "force_local" param
	and adjust to suit.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise, and call
	_bfd_elf_link_hash_hide_symbol rather than duplicating code.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.
@
text
@d6597 1
a6597 1
  memcpy (prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
@


1.123
log
@	* elf-bfd.h (elf_backend_data <elf_backend_section_from_bfd_section>):
	Remove "Elf_Internal_Shdr *" param.
	(_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-mips.c (_bfd_mips_elf_section_from_bfd_section): Ditto.
	* elf32-m32r.c (_bfd_m32r_elf_section_from_bfd_section): Ditto.
	* elf32-v850.c (v850_elf_section_from_bfd_section): Ditto.
	* elf64-mmix.c (mmix_elf_section_from_bfd_section): Ditto.
	* elfxx-ia64.c (elfNN_hpux_backend_section_from_bfd_section): Ditto.
	* elf.c (_bfd_elf_section_from_bfd_section): Allow backend
	function to override special sections.  Remove hdr arg from
	backend call, and don't loop.
@
text
@d1289 2
a1290 2
_bfd_elf_link_hash_hide_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1292 1
d1294 1
d1296 10
a1305 3
  h->plt.offset = (bfd_vma) -1;
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
@


1.122
log
@	* elflink.h (elf_link_input_bfd): Back out 2002-01-07 change.
	* elf.c (merge_sections_remove_hook): New function.
	(_bfd_elf_merge_sections): Pass it as 3rd argument to
	_bfd_merge_sections.
	* libbfd-in.h (_bfd_merge_sections): Add 3rd argument.
	* libbfd.h: Rebuilt.
	* merge.c (_bfd_merge_sections): Add remove_hook argument.
	Call remove_hook if a SEC_EXCLUDE section is encountered.
@
text
@d4053 1
a4053 2
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
  Elf_Internal_Shdr **i_shdrp = elf_elfsections (abfd);
a4054 2
  Elf_Internal_Shdr *hdr;
  int maxindex = elf_numsections (abfd);
d4061 13
a4073 5
    return SHN_ABS;
  if (bfd_is_com_section (asect))
    return SHN_COMMON;
  if (bfd_is_und_section (asect))
    return SHN_UNDEF;
d4075 4
a4078 5
  for (index = 1; index < maxindex; index++)
    {
      hdr = i_shdrp[index];
      if (hdr != NULL && hdr->bfd_section == asect)
	return index;
d4081 1
d4084 1
a4084 3
      for (index = 0; index < maxindex; index++)
	{
	  int retval;
d4086 2
a4087 9
	  hdr = i_shdrp[index];
	  if (hdr == NULL)
	    continue;

	  retval = index;
	  if ((*bed->elf_backend_section_from_bfd_section)
	      (abfd, hdr, asect, &retval))
	    return retval;
	}
d4090 2
a4091 1
  bfd_set_error (bfd_error_nonrepresentable_section);
d4093 1
a4093 1
  return SHN_BAD;
@


1.121
log
@2002-01-10  Michael Snyder  <msnyder@@redhat.com>

	* elf.c (elfcore_write_prstatus): Use long instead of pid_t;
	(elfcore_write_pstatus): Use long instead of pid_t;
	* elf-bfd.h: Change prototypes to use long instead of pid_t;
@
text
@d56 1
d774 14
d798 2
a799 1
    _bfd_merge_sections (abfd, elf_hash_table (info)->merge_info);
@


1.120
log
@include/elf:
* common.h: Update copyright years.
(NT_NETBSDCORE_PROCINFO): Define.
(NT_NETBSDCORE_FIRSTMACH): Define.

bfd:
* elf.c: Update copyright years.
(elfcore_grok_netbsd_note): Use NT_NETBSDCORE_PROCINFO
and NT_NETBSDCORE_FIRSTMACH.  Improve a comment.

bintuils:
* readelf.c (get_netbsd_elfcore_note_type): Use
NT_NETBSDCORE_PROCINFO and NT_NETBSDCORE_FIRSTMACH.
@
text
@d6565 1
a6565 1
     pid_t pid;
d6587 1
a6587 1
     pid_t pid;
@


1.119
log
@2002-01-08  Michael Snyder  <msnyder@@redhat.com>

	Add capability to write corefile note sections, for gdb.
	* elf.c (elfcore_write_note): New function.
	(elfcore_write_prpsinfo): New function.
	(elfcore_write_prstatus): New function.
	(elfcore_write_pstatus): New function.
	(elfcore_write_prfpreg): New function.
	(elfcore_write_prxfpreg): New function.
	* elf-bfd.h: Add prototypes for above functions.
@
text
@d6435 1
a6435 1
  if (note->type == 1)
d6445 4
a6448 3
  /* There are not currently any other machine-independent notes defined
     for NetBSD ELF core files.  If the note type is less than the start
     of the machine-dependent note types, we don't understand it.  */
d6450 1
a6450 1
  if (note->type < 32)
d6463 1
a6463 1
        case 32+0:
d6466 1
a6466 1
        case 32+2:
d6479 1
a6479 1
        case 32+1:
d6482 1
a6482 1
        case 32+3:
@


1.118
log
@* elf.c (elf_fake_sections): Propagate errors from
elf_backend_fake_section.
@
text
@d6491 136
@


1.117
log
@2001-12-18  Michael Snyder  <msnyder@@redhat.com>

        * elf.c (assign_file_positions_for_segments): Don't sort PT_NOTE
        sections of corefiles.  Also it makes no sense to sort if count == 1.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d2216 3
a2218 2
  if (bed->elf_backend_fake_sections)
    (*bed->elf_backend_fake_sections) (abfd, this_hdr, asect);
@


1.116
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf.c (_bfd_elf_copy_private_bfd_data): Also copy GP.
@
text
@d3302 7
a3308 2
         sections may not be correctly ordered.  */
      if (m->count > 0)
@


1.115
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf.c (_bfd_elf_copy_private_bfd_data): Update comments.
@
text
@d787 2
a788 1
/* Copy the program header from one object module to another */
d803 1
@


1.114
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d787 1
a787 1
/* Print out the program headers.  */
d806 2
@


1.113
log
@	* elf.c (elfcore_netbsd_get_lwpid): New function.
	(elfcore_grok_netbsd_procinfo): New function.
	(elfcore_grok_netbsd_note): New function.
	(elfcore_read_notes): Call elfcore_grok_netbsd_note to process
	NetBSD ELF core file notes.
@
text
@d790 18
@


1.112
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d74 5
d6361 103
d6505 10
a6514 2
      if (! elfcore_grok_note (abfd, &in))
	goto error;
@


1.111
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d378 1
a378 1
      shnum = elf_elfheader (abfd)->e_shnum;
d711 2
a712 2
      shstrtab = bfd_elf_get_str_section
	(abfd, elf_elfheader (abfd)->e_shstrndx);
d715 1
a715 1
	  max = elf_elfheader (abfd)->e_shnum;
d1552 14
d1576 1
a1576 1
	unsigned int i;
d1578 2
a1579 1
	for (i = 1; i < ehdr->e_shnum; i++)
d1625 1
d1628 2
a1629 1
	if (hdr->sh_link >= ehdr->e_shnum)
d1647 1
a1647 1
	    int scan;
d1651 1
a1651 1
	    for (scan = 1; scan < ehdr->e_shnum; scan++)
d1778 1
a1778 1
  unsigned char esym_shndx[2];
d1795 1
d1801 1
a1802 1
  amt = sizeof (esym_shndx);
d1808 15
d1830 1
a1830 1
  if (isym_shndx > 0 && isym_shndx < SHN_LORESERVE)
d1848 1
a1848 2
  BFD_ASSERT (index > 0 && index < SHN_LORESERVE);
  if (index >= elf_elfheader (abfd)->e_shnum)
d2303 2
d2311 2
d2319 2
d2328 2
d2336 2
d2340 13
d2359 2
d2362 2
d2387 5
d2505 5
a2509 3
    i_shdrp[secn]->sh_name = _bfd_elf_strtab_offset (elf_shstrtab (abfd),
						     i_shdrp[secn]->sh_name);

d2791 4
d3110 3
a3112 1
  eh_frame_hdr = bfd_get_section_by_name (abfd, ".eh_frame_hdr");
d3692 1
d3708 1
a3708 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < i_ehdrp->e_shnum; i++, hdrpp++)
d3713 5
a3717 1
	  if (hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
a3719 1
	      continue;
d3721 4
a3724 2
	  if (i == tdata->symtab_section
	      || i == tdata->strtab_section)
d3726 2
a3727 2
	      hdr->sh_offset = -1;
	      continue;
a3728 2

	  off = _bfd_elf_assign_file_position_for_section (hdr, off, true);
d3744 1
a3744 1
      for (i = 1, hdrpp = i_shdrpp + 1; i < i_ehdrp->e_shnum; i++, hdrpp++)
d3770 1
d3775 6
d3915 1
a3915 1
  unsigned int i;
d3920 2
a3921 3
  for (i = 1, shdrpp = elf_elfsections (abfd) + 1;
       i < elf_elfheader (abfd)->e_shnum;
       i++, shdrpp++)
d3942 1
a3942 1
  unsigned int count;
d3960 2
a3961 1
  for (count = 1; count < i_ehdrp->e_shnum; count++)
d3973 2
d4008 12
a4019 1
  int maxindex = elf_elfheader (abfd)->e_shnum;
d4021 1
a4021 1
  for (index = 0; index < maxindex; index++)
d4024 1
a4024 1
      if (hdr->bfd_section == asect)
d4035 3
a4044 7
  if (bfd_is_abs_section (asect))
    return SHN_ABS;
  if (bfd_is_com_section (asect))
    return SHN_COMMON;
  if (bfd_is_und_section (asect))
    return SHN_UNDEF;

d4047 1
a4047 1
  return -1;
d4214 1
a4214 1
     in the loadable segments.  These can be created by wierd
d4616 1
a4616 1
     going to be needed, then check our estimate know and adjust
d4729 5
a4733 4
#define MAP_ONESYMTAB (SHN_LORESERVE - 1)
#define MAP_DYNSYMTAB (SHN_LORESERVE - 2)
#define MAP_STRTAB (SHN_LORESERVE - 3)
#define MAP_SHSTRTAB (SHN_LORESERVE - 4)
d4766 2
d4787 1
d4790 1
d4820 16
d4846 1
a4846 1
    bed->s->swap_symbol_out (abfd, &sym, (PTR) outbound_syms);
d4848 2
d4930 3
d5010 1
a5010 1
      bed->s->swap_symbol_out (abfd, &sym, (PTR) outbound_syms);
d5012 2
@


1.110
log
@Combine sentance fragments into a single sentance in order to permit better
translation into foreign languages.
@
text
@d815 1
d2798 1
a2798 1
  asection *dynsec;
d3038 18
d3570 7
d6421 1
a6421 1
      && elf_section_data (sec)->merge_info)
d6428 1
a6428 1
				    elf_section_data (sec)->merge_info,
d6446 1
a6446 1
  if (elf_section_data (sec)->merge_info == NULL)
d6450 1
a6450 1
				     elf_section_data (sec)->merge_info,
d6464 11
a6474 5
  if (sec_data->stab_info != NULL)
    return _bfd_stab_section_offset
	   (abfd, &elf_hash_table (info)->stab_info,
	    sec, &sec_data->stab_info, offset);
  return offset;
@


1.109
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d3378 5
a3382 7
		      (* _bfd_error_handler)
			(_("Error: First section in segment (%s) starts at 0x%x"),
			 bfd_section_name (abfd, sec), sec->lma);
		      (* _bfd_error_handler)
			(_("       whereas segment starts at 0x%x"),
			 p->p_paddr);

@


1.108
log
@Do not overwite the core signal if it has already been set by another thread.
@
text
@d6396 2
a6397 1
      && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
d6411 34
@


1.107
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d5756 4
a5759 1
      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
d5782 4
a5785 1
      elf_tdata (abfd)->core_signal = prstat.pr_cursig;
@


1.106
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d6373 32
@


1.105
log
@	* Makefile.am (BFD32_BACKENDS): Add elf-strtab.lo.
	(BFD32_BACKENDS_CFILES): Add elf-strtab.c.
	(elf-strtab.lo): Add rule.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-strtab.lo.
	* configure: Rebuilt.
	* elf-bfd.h (elf_strtab_hash): Forward declare.
	(struct elf_link_hash_table): Change dynstr type to
	struct elf_strtab_hash *.
	(struct elf_obj_tdata): Change strtab_ptr type to
	struct elf_strtab_hash *.
	(_bfd_elf_strtab_init, _bfd_elf_strtab_free, _bfd_elf_strtab_add,
	_bfd_elf_strtab_addref, _bfd_elf_strtab_delref,
	_bfd_elf_strtab_clear_all_refs, _bfd_elf_strtab_size,
	_bfd_elf_strtab_offset, _bfd_elf_strtab_emit,
	_bfd_elf_strtab_finalize): New prototypes.
	* elf-strtab.c: New file.
	* elflink.h (elf_link_add_object_symbols): Use _bfd_elf_strtab_add
	and _bfd_elf_strtab_size instead of _bfd_stringtab calls.
	Call _bfd_elf_strtab_delref if DT_NEEDED entry is not needed or
	when forcing dynamic symbol to local.
	(elf_link_create_dynamic_sections): Call
	_bfd_elf_strtab_init instead of elf_stringtab_init.
	(elf_link_record_local_dynamic_symbol): Likewise, change
	dynstr type.  Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.
	(size_dynamic_sections): Use _bfd_elf_strtab functions instead of
	_bfd_stringtab calls.  For DT_RUNPATH and Verdaux vda_name fields,
	call _bfd_elf_strtab_addref.  Call elf_finalize_dynstr.
	(elf_adjust_dynstr_offsets, elf_finalize_dynstr): New functions.
	(elf_fix_symbol_flags): Call _bfd_elf_strtab_delref when forcing
	dynamic symbol to local.
	(elf_link_assign_sym_version): Likewise.
	(elf_bfd_final_link): Call _bfd_elf_strtab_emit instead of
	_bfd_stringtab_emit.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Change dynstr
	type.  Call _bfd_elf_strtab functions instead of
	_bfd_stringtab functions.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.
	* elf.c (_bfd_elf_init_reloc_shdr): Likewise.
	(elf_fake_sections): Likewise.
	(assign_section_numbers): Call _bfd_elf_strtab_clear_all_refs
	on shstrtab hash table, call _bfd_elf_strtab_addref on each section
	name in the output.  Call _bfd_elf_strtab_finalize and
	use _bfd_elf_strtab_offset to finalize sh_name section header fields.
	(_bfd_elf_compute_section_file_positions): Use _bfd_elf_strtab_size
	instead of _bfd_stringtab_size.
	(prep_headers): Change shstrtab type.
	Use _bfd_elf_strtab calls instead of _bfd_stringtab calls.
@
text
@d1750 56
@


1.104
log
@If the LMA for a segment is known, use it for matching sections to segments.
Use the LMA when adjusting for inter-section alignment padding.
@
text
@d1942 2
a1943 2
    (unsigned int) _bfd_stringtab_add (elf_shstrtab (abfd), name,
				       true, false);
d1980 2
a1981 3
  this_hdr->sh_name = (unsigned long) _bfd_stringtab_add (elf_shstrtab (abfd),
							  asect->name,
							  true, false);
d2202 1
a2202 1
  unsigned int section_number;
d2208 2
d2215 1
d2219 4
a2222 1
	d->rel_idx = section_number++;
d2225 4
a2228 1
	d->rel_idx2 = section_number++;
d2234 1
a2235 1
  t->shstrtab_hdr.sh_size = _bfd_stringtab_size (elf_shstrtab (abfd));
d2240 1
d2242 1
d2245 2
d2383 4
d2648 1
a2648 1
  shstrtab_hdr->sh_size = _bfd_stringtab_size (elf_shstrtab (abfd));
d3639 1
a3639 1
  struct bfd_strtab_hash *shstrtab;
d3645 1
a3645 1
  shstrtab = _bfd_elf_stringtab_init ();
d3731 1
a3731 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".symtab", true, false);
d3733 1
a3733 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".strtab", true, false);
d3735 1
a3735 1
    (unsigned int) _bfd_stringtab_add (shstrtab, ".shstrtab", true, false);
d3814 1
a3814 1
      || ! _bfd_stringtab_emit (abfd, elf_shstrtab (abfd)))
d5568 1
a5568 1
	_bfd_stringtab_free (elf_shstrtab (abfd));
@


1.103
log
@Set the LMA based on the p_paddr of the segment that contains it.
@
text
@d3265 2
a3266 2
	     cumulative phdr vma and the section's vma.  */
	  if (p->p_vaddr + p->p_memsz < sec->vma)
d3268 1
a3268 1
	      bfd_vma adjust = sec->vma - (p->p_vaddr + p->p_memsz);
d3997 2
a3998 1
       1. It is within the address space of the segment,
d4002 8
a4009 6
#define INCLUDE_SECTION_IN_SEGMENT(section, segment)	\
  ((((IS_CONTAINED_BY_VMA (section, segment) 		\
      || IS_SOLARIS_PT_INTERP (segment, section))	\
     && (section->flags & SEC_ALLOC) != 0)		\
    || IS_COREFILE_NOTE (segment, section))		\
   && section->output_section != NULL			\
@


1.102
log
@	* elf-m10200.c (mn10200_elf_relax_section): Cast assignment to
	Elf_Internal_Shdr.contents now that it's no longer a PTR.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elf.c (setup_group): Warning fixes.
	* elflink.h (elf_link_sort_relocs): Likewise.
	* pdp11.c (slurp_reloc_table): Likewise.
@
text
@d43 1
d470 1
a470 1
		asection *s;
d603 1
a603 1
    for (i = sizeof (debug_sec_names) / sizeof (debug_sec_names[0]); i--;)
d647 6
d654 4
a657 4
		  && phdr->p_vaddr != phdr->p_paddr
		  && phdr->p_vaddr <= hdr->sh_addr
		  && (phdr->p_vaddr + phdr->p_memsz
		      >= hdr->sh_addr + hdr->sh_size)
d659 2
a660 3
		      || (phdr->p_offset <= (bfd_vma) hdr->sh_offset
			  && (phdr->p_offset + phdr->p_filesz
			      >= hdr->sh_offset + hdr->sh_size))))
d662 9
a670 1
		  newsect->lma += phdr->p_paddr - phdr->p_vaddr;
@


1.101
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Test ind->root.type
	rather than ind->weakdef.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
@
text
@d387 1
a387 1
	num_group = -1;
d405 1
a405 1
		  char *src;
d505 1
a505 1
			|| bfd_bread (ename, 4, abfd) != 4)
@


1.100
log
@	* elf.c (elf_map_symbols): Don't create new section symbols; Use
	existing section syms.  Update comments.
	(copy_private_bfd_data): Formatting fixes.
	(elfcore_grok_win32pstatus): Likewise.
	(swap_out_syms): Likewise.  Remove unnecessary level of braces.
@
text
@d1196 1
a1196 1
  if (dir == ind->weakdef)
@


1.99
log
@	* elf-bfd.h (struct bfd_elf_section_data): Rename "group" to
	"group_name".
	(elf_group_name): Define.
	(elf_next_in_group): Define.
	* elf.c: Make use of elf_group_name and elf_next_in_group throughout.
	(setup_group): Don't use sec->lineno for SHT_GROUP section to store
	first member section; Instead use elf_next_in_group.
	(bfd_section_from_shdr): Likewise.
	(set_group_contents): Likewise.  Use elf_section_syms, not sec->symbol.
@
text
@a2389 1
  unsigned int num_sections = 0;
a2399 2
  /* Add a section symbol for each BFD section.  FIXME: Is this really
     necessary?  */
d2414 2
d2436 10
a2445 9
		  /* Empty sections in the input files may have had a section
		     symbol created for them.  (See the comment near the end of
		     _bfd_generic_link_output_symbols in linker.c).  If the linker
		     script discards such sections then we will reach this point.
		     Since we know that we cannot avoid this case, we detect it
		     and skip the abort and the assignment to the sect_syms array.
		     To reproduce this particular case try running the linker
		     testsuite test ld-scripts/weak.exp for an ELF port that uses
		     the generic linker.  */
a2455 25
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      asymbol *sym;

      if (sect_syms[asect->index] != NULL)
	continue;

      sym = bfd_make_empty_symbol (abfd);
      if (sym == NULL)
	return false;
      sym->the_bfd = abfd;
      sym->name = asect->name;
      sym->value = 0;
      /* Set the flags to 0 to indicate that this one was newly added.  */
      sym->flags = 0;
      sym->section = asect;
      sect_syms[asect->index] = sym;
      num_sections++;
#ifdef DEBUG
      fprintf (stderr,
 _("creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n"),
	       asect->name, (long) asect->vma, asect->index, (long) asect);
#endif
    }

d2464 5
d2471 1
a2471 2
      if (sect_syms[asect->index] != NULL
	  && sect_syms[asect->index]->flags == 0)
d2473 1
a2473 2
	  sect_syms[asect->index]->flags = BSF_SECTION_SYM;
	  if (!sym_is_global (abfd, sect_syms[asect->index]))
a2476 1
	  sect_syms[asect->index]->flags = 0;
d2501 1
a2501 2
      if (sect_syms[asect->index] != NULL
	  && sect_syms[asect->index]->flags == 0)
d2503 1
a2503 1
	  asymbol *sym = sect_syms[asect->index];
d2506 1
a2506 1
	  sym->flags = BSF_SECTION_SYM;
d4212 2
a4213 1
						 ? iehdr->e_phnum * iehdr->e_phentsize
d4338 2
a4339 1
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
d4341 2
a4342 1
			  || ((prev_sec->lma + prev_sec->_raw_size) > output_section->lma))
d4574 9
a4582 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d4588 15
a4602 9
  {
    int symcount = bfd_get_symcount (abfd);
    asymbol **syms = bfd_get_outsymbols (abfd);
    struct bfd_strtab_hash *stt;
    Elf_Internal_Shdr *symtab_hdr;
    Elf_Internal_Shdr *symstrtab_hdr;
    char *outbound_syms;
    int idx;
    bfd_size_type amt;
d4604 5
a4608 3
    stt = _bfd_elf_stringtab_init ();
    if (stt == NULL)
      return false;
d4610 13
a4622 15
    symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
    symtab_hdr->sh_type = SHT_SYMTAB;
    symtab_hdr->sh_entsize = bed->s->sizeof_sym;
    symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
    symtab_hdr->sh_info = elf_num_locals (abfd) + 1;
    symtab_hdr->sh_addralign = bed->s->file_align;

    symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;
    symstrtab_hdr->sh_type = SHT_STRTAB;

    amt = (bfd_size_type) (1 + symcount) * bed->s->sizeof_sym;
    outbound_syms = bfd_alloc (abfd, amt);
    if (outbound_syms == NULL)
      return false;
    symtab_hdr->contents = (PTR) outbound_syms;
d4624 2
a4625 1
    /* now generate the data (for "contents") */
a4626 1
      /* Fill in zeroth symbol and swap it out.  */
d4628 151
a4778 6
      sym.st_name = 0;
      sym.st_value = 0;
      sym.st_size = 0;
      sym.st_info = 0;
      sym.st_other = 0;
      sym.st_shndx = SHN_UNDEF;
a4781 156
    for (idx = 0; idx < symcount; idx++)
      {
	Elf_Internal_Sym sym;
	bfd_vma value = syms[idx]->value;
	elf_symbol_type *type_ptr;
	flagword flags = syms[idx]->flags;
	int type;

	if ((flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
	  {
	    /* Local section symbols have no name.  */
	    sym.st_name = 0;
	  }
	else
	  {
	    sym.st_name = (unsigned long) _bfd_stringtab_add (stt,
							      syms[idx]->name,
							      true, false);
	    if (sym.st_name == (unsigned long) -1)
	      return false;
	  }

	type_ptr = elf_symbol_from (abfd, syms[idx]);

	if ((flags & BSF_SECTION_SYM) == 0
	    && bfd_is_com_section (syms[idx]->section))
	  {
	    /* ELF common symbols put the alignment into the `value' field,
	       and the size into the `size' field.  This is backwards from
	       how BFD handles it, so reverse it here.  */
	    sym.st_size = value;
	    if (type_ptr == NULL
		|| type_ptr->internal_elf_sym.st_value == 0)
	      sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
	    else
	      sym.st_value = type_ptr->internal_elf_sym.st_value;
	    sym.st_shndx = _bfd_elf_section_from_bfd_section
	      (abfd, syms[idx]->section);
	  }
	else
	  {
	    asection *sec = syms[idx]->section;
	    int shndx;

	    if (sec->output_section)
	      {
		value += sec->output_offset;
		sec = sec->output_section;
	      }
	    /* Don't add in the section vma for relocatable output.  */
	    if (! relocatable_p)
	      value += sec->vma;
	    sym.st_value = value;
	    sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

	    if (bfd_is_abs_section (sec)
		&& type_ptr != NULL
		&& type_ptr->internal_elf_sym.st_shndx != 0)
	      {
		/* This symbol is in a real ELF section which we did
                   not create as a BFD section.  Undo the mapping done
                   by copy_private_symbol_data.  */
		shndx = type_ptr->internal_elf_sym.st_shndx;
		switch (shndx)
		  {
		  case MAP_ONESYMTAB:
		    shndx = elf_onesymtab (abfd);
		    break;
		  case MAP_DYNSYMTAB:
		    shndx = elf_dynsymtab (abfd);
		    break;
		  case MAP_STRTAB:
		    shndx = elf_tdata (abfd)->strtab_section;
		    break;
		  case MAP_SHSTRTAB:
		    shndx = elf_tdata (abfd)->shstrtab_section;
		    break;
		  default:
		    break;
		  }
	      }
	    else
	      {
		shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

		if (shndx == -1)
		  {
		    asection *sec2;

		    /* Writing this would be a hell of a lot easier if
		       we had some decent documentation on bfd, and
		       knew what to expect of the library, and what to
		       demand of applications.  For example, it
		       appears that `objcopy' might not set the
		       section of a symbol to be a section that is
		       actually in the output file.  */
		    sec2 = bfd_get_section_by_name (abfd, sec->name);
		    BFD_ASSERT (sec2 != 0);
		    shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
		    BFD_ASSERT (shndx != -1);
		  }
	      }

	    sym.st_shndx = shndx;
	  }

	if ((flags & BSF_FUNCTION) != 0)
	  type = STT_FUNC;
	else if ((flags & BSF_OBJECT) != 0)
	  type = STT_OBJECT;
	else
	  type = STT_NOTYPE;

        /* Processor-specific types */
        if (type_ptr != NULL
	    && bed->elf_backend_get_symbol_type)
          type = (*bed->elf_backend_get_symbol_type) (&type_ptr->internal_elf_sym, type);

	if (flags & BSF_SECTION_SYM)
	  {
	    if (flags & BSF_GLOBAL)
	      sym.st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
	    else
	      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
	  }
	else if (bfd_is_com_section (syms[idx]->section))
	  sym.st_info = ELF_ST_INFO (STB_GLOBAL, type);
	else if (bfd_is_und_section (syms[idx]->section))
	  sym.st_info = ELF_ST_INFO (((flags & BSF_WEAK)
				      ? STB_WEAK
				      : STB_GLOBAL),
				     type);
	else if (flags & BSF_FILE)
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);
	else
	  {
	    int bind = STB_LOCAL;

	    if (flags & BSF_LOCAL)
	      bind = STB_LOCAL;
	    else if (flags & BSF_WEAK)
	      bind = STB_WEAK;
	    else if (flags & BSF_GLOBAL)
	      bind = STB_GLOBAL;

	    sym.st_info = ELF_ST_INFO (bind, type);
	  }

	if (type_ptr != NULL)
	  sym.st_other = type_ptr->internal_elf_sym.st_other;
	else
	  sym.st_other = 0;

	bed->s->swap_symbol_out (abfd, &sym, (PTR) outbound_syms);
	outbound_syms += bed->s->sizeof_sym;
      }
d4783 10
a4792 11
    *sttp = stt;
    symstrtab_hdr->sh_size = _bfd_stringtab_size (stt);
    symstrtab_hdr->sh_type = SHT_STRTAB;

    symstrtab_hdr->sh_flags = 0;
    symstrtab_hdr->sh_addr = 0;
    symstrtab_hdr->sh_entsize = 0;
    symstrtab_hdr->sh_link = 0;
    symstrtab_hdr->sh_info = 0;
    symstrtab_hdr->sh_addralign = 1;
  }
d6016 3
a6018 2
      sect->filepos = note->descpos + offsetof (struct win32_pstatus,
						data.thread_info.thread_context);
@


1.98
log
@	* elf-bfd.h (struct bfd_elf_section_data): Add "group" and
	"next_in_group".  Fix gp and gp_size comments.
	* elf.c (union elf_internal_group): New.
	(setup_group): New function.
	(_bfd_elf_make_section_from_shdr): Set BFD flags for SHT_GROUP.
	Call setup_group for SHF_GROUP sections.
	(bfd_section_from_shdr): Build a BFD section for SHT_GROUP.
	(elf_fake_sections): Set header type for SEC_GROUP, and header
	flags for sections in a group.
	(set_group_contents): New function.
	(_bfd_elf_compute_section_file_positions): Call it.
	(assign_section_numbers): Set sh_link for SHT_GROUP.
	* elflink.h (gc_mark_hook): Handle section groups.
	* elfxx-target.h: Add SEC_GROUP to applicable_flags.
	* section.c (SEC_GROUP): Define.
	(struct sec): Comment fixes.
	* bfd-in2.h: Regenerate.

	* elf.c (bfd_elf_print_symbol): Formatting fix; migrate expression
	out of function args.
	(_bfd_elf_canonicalize_reloc): Similarly.
	(_bfd_elf_get_symtab): Here too.
	(_bfd_elf_canonicalize_dynamic_symtab): And here.
	* elfcode.h (elf_slurp_symbol_table): Don't recalculate size for
	bfd_bread, and remove unnecessary cast.
@
text
@d478 1
a478 1
		      && elf_section_data (s)->next_in_group != NULL)
a481 3
		    const char *gname;
		    asection *next;

d484 3
a486 5
		    gname = elf_section_data (s)->group;
		    elf_section_data (newsect)->group = gname;
		    next = elf_section_data (s)->next_in_group;
		    elf_section_data (newsect)->next_in_group = next;
		    elf_section_data (s)->next_in_group = newsect;
d509 1
a509 1
		    elf_section_data (newsect)->group = gname;
d512 1
a512 1
		    elf_section_data (newsect)->next_in_group = newsect;
d515 1
a515 1
		  shdr->bfd_section->lineno = (alent *) newsect;
d522 1
a522 1
  if (elf_section_data (newsect)->group == NULL)
d1716 1
a1716 1
		&& elf_section_data (s)->next_in_group != NULL)
d1718 1
a1718 1
		hdr->bfd_section->lineno = (alent *) s;
d2083 1
a2083 1
  if (elf_section_data (asect)->group != NULL)
d2121 5
a2125 4
     udata.i;  If called for "ld -r", the symbols won't yet be mapped,
     so emulate elf_bfd_final_link.  */
  symindx = sec->symbol->udata.i;
  if (symindx == 0)
d2144 1
a2144 1
  elt = (asection *) sec->lineno;
d2154 1
a2154 1
      elt = elf_section_data (elt)->next_in_group;
d2162 1
a2162 1
	&& (elt = (asection *) l->u.indirect.section->lineno) != NULL)
d2168 1
a2168 1
	  elt = elf_section_data (elt)->next_in_group;
d2171 1
a2171 1
      while (elt != (asection *) l->u.indirect.section->lineno);
@


1.97
log
@	* elflink.h (elf_fix_symbol_flags): Copy flags to weakdef using
	elf_backend_copy_indirect_symbol so that backend has a chance to
	copy other necessary fields.
	* elf-bfd.h (struct elf_backend_data): Update description of
	elf_backend_copy_indirect_symbol.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Bail out after
	copying flags if this is a weakdef.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_link_hash_lookup rather
	than bfd_link_hash_lookup.
	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Don't do copy
	reloc processing for weakdefs.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
@
text
@d54 1
d56 1
d350 185
d570 2
d591 3
d1036 1
d1055 5
a1059 4
	bfd_fprintf_vma (abfd, file,
			 (bfd_is_com_section (symbol->section)
			  ? ((elf_symbol_type *) symbol)->internal_elf_sym.st_value
			  : ((elf_symbol_type *) symbol)->internal_elf_sym.st_size));
d1709 20
d2064 5
d2088 2
d2107 76
d2355 3
d2634 7
d4879 1
d4881 1
a4881 4
  if (! get_elf_backend_data (abfd)->s->slurp_reloc_table (abfd,
							   section,
							   symbols,
							   false))
d4898 2
a4899 2
  long symcount = get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, false);
d4911 2
a4912 2
  return get_elf_backend_data (abfd)->s->slurp_symbol_table
    (abfd, alocation, true);
@


1.96
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Set ind refcounts to
	the old dir refcount, so we indirectly set them to init_refcount.
	Short-circuit asserts when we've just verified they are true.
@
text
@d989 1
a989 1
   old indirect symbol.  */
d1006 3
@


1.95
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d995 2
d1009 2
a1010 1
  if (dir->got.refcount <= 0)
d1013 1
a1013 1
      ind->got.refcount = 0;
d1015 2
a1016 1
  BFD_ASSERT (ind->got.refcount <= 0);
d1018 2
a1019 1
  if (dir->plt.refcount <= 0)
d1022 1
a1022 1
      ind->plt.refcount = 0;
d1024 2
a1025 1
  BFD_ASSERT (ind->plt.refcount <= 0);
d1034 2
a1035 1
  BFD_ASSERT (ind->dynindx == -1);
@


1.94
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@a946 2
  struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;

d949 6
a954 5
  if (ret == (struct elf_link_hash_entry *) NULL)
    ret = ((struct elf_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry)));
  if (ret == (struct elf_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d957 2
a958 4
  ret = ((struct elf_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret != (struct elf_link_hash_entry *) NULL)
d960 3
d969 3
a971 3
      ret->got.offset = (bfd_vma) -1;
      ret->plt.offset = (bfd_vma) -1;
      ret->linker_section_pointer = (elf_linker_section_pointers_t *)0;
d985 1
a985 1
  return (struct bfd_hash_entry *) ret;
d1005 1
a1005 1
  /* Copy over the global and procedure linkage table offset entries.
d1007 1
a1007 1
  if (dir->got.offset == (bfd_vma) -1)
d1009 2
a1010 2
      dir->got.offset = ind->got.offset;
      ind->got.offset = (bfd_vma) -1;
d1012 1
a1012 1
  BFD_ASSERT (ind->got.offset == (bfd_vma) -1);
d1014 1
a1014 1
  if (dir->plt.offset == (bfd_vma) -1)
d1016 2
a1017 2
      dir->plt.offset = ind->plt.offset;
      ind->plt.offset = (bfd_vma) -1;
d1019 1
a1019 1
  BFD_ASSERT (ind->plt.offset == (bfd_vma) -1);
d1056 1
@


1.93
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d5985 2
a5986 2
_bfd_elf_reloc_type_class (type)
     int type ATTRIBUTE_UNUSED;
@


1.92
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d337 1
a337 1
	 bfd_get_filename (abfd), strindex, (unsigned long) hdr->sh_size,
d1401 1
a1401 1
	      bfd_get_filename (abfd), hdr->sh_link, name, shindex));
d3598 1
a3598 1
	 bfd_get_filename (abfd), bfd_asymbol_name (asym_ptr));
d3848 1
a3848 1
		 bfd_get_filename (ibfd));
d5230 1
a5230 1
     bfd_get_filename (abfd), areloc->howto->name);
@


1.91
log
@* elf.c (prep_headers): Get the machine code from the elf
backend data.
* elf-m10200.c (ELF_MACHINE_CODE): Redefine to EM_MN10200.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10200.
* elf-m10300.c (ELF_MACHINE_CODE): Redefine to EM_MN10300.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10300.
* elf-arc.c (arc_elf_final_write_processing): Don't override
e_machine, it's now properly set in prep_headers.
* elf32-avr.c (elf32_avr_object_p): Accept both EM_AVR and
EM_AVR_OLD.
(ELF_MACHINE_ALT1): Define to EM_AVR_OLD.
* elf-d10v.c (ELF_MACHINE_CODE): Redefine to EM_D10V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D10V.
* elf-d30v.c (ELF_MACHINE_CODE): Redefine to EM_D30V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D30V.
* elf-fr30.c (ELF_MACHINE_CODE): Redefine to EM_FR30.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_FR30.
* elf-m32r.c (ELF_MACHINE_CODE): Redefine to EM_M32R.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_M32R.
* elf32-pj.c (ELF_MACHINE_ALT1): DEfine to EM_PJ_OLD.
* elf-v850.c (ELF_MACHINE_CODE): Redefine to EM_V850.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_V850.
@
text
@d53 1
a53 1
static char *elf_read PARAMS ((bfd *, long, unsigned int));
d59 1
a59 1
static boolean elfcore_read_notes PARAMS ((bfd *, bfd_vma, bfd_vma));
d83 7
a89 7
  dst->vd_version = bfd_h_get_16 (abfd, src->vd_version);
  dst->vd_flags   = bfd_h_get_16 (abfd, src->vd_flags);
  dst->vd_ndx     = bfd_h_get_16 (abfd, src->vd_ndx);
  dst->vd_cnt     = bfd_h_get_16 (abfd, src->vd_cnt);
  dst->vd_hash    = bfd_h_get_32 (abfd, src->vd_hash);
  dst->vd_aux     = bfd_h_get_32 (abfd, src->vd_aux);
  dst->vd_next    = bfd_h_get_32 (abfd, src->vd_next);
d100 7
a106 7
  bfd_h_put_16 (abfd, src->vd_version, dst->vd_version);
  bfd_h_put_16 (abfd, src->vd_flags, dst->vd_flags);
  bfd_h_put_16 (abfd, src->vd_ndx, dst->vd_ndx);
  bfd_h_put_16 (abfd, src->vd_cnt, dst->vd_cnt);
  bfd_h_put_32 (abfd, src->vd_hash, dst->vd_hash);
  bfd_h_put_32 (abfd, src->vd_aux, dst->vd_aux);
  bfd_h_put_32 (abfd, src->vd_next, dst->vd_next);
d117 2
a118 2
  dst->vda_name = bfd_h_get_32 (abfd, src->vda_name);
  dst->vda_next = bfd_h_get_32 (abfd, src->vda_next);
d129 2
a130 2
  bfd_h_put_32 (abfd, src->vda_name, dst->vda_name);
  bfd_h_put_32 (abfd, src->vda_next, dst->vda_next);
d141 5
a145 5
  dst->vn_version = bfd_h_get_16 (abfd, src->vn_version);
  dst->vn_cnt     = bfd_h_get_16 (abfd, src->vn_cnt);
  dst->vn_file    = bfd_h_get_32 (abfd, src->vn_file);
  dst->vn_aux     = bfd_h_get_32 (abfd, src->vn_aux);
  dst->vn_next    = bfd_h_get_32 (abfd, src->vn_next);
d156 5
a160 5
  bfd_h_put_16 (abfd, src->vn_version, dst->vn_version);
  bfd_h_put_16 (abfd, src->vn_cnt, dst->vn_cnt);
  bfd_h_put_32 (abfd, src->vn_file, dst->vn_file);
  bfd_h_put_32 (abfd, src->vn_aux, dst->vn_aux);
  bfd_h_put_32 (abfd, src->vn_next, dst->vn_next);
d171 5
a175 5
  dst->vna_hash  = bfd_h_get_32 (abfd, src->vna_hash);
  dst->vna_flags = bfd_h_get_16 (abfd, src->vna_flags);
  dst->vna_other = bfd_h_get_16 (abfd, src->vna_other);
  dst->vna_name  = bfd_h_get_32 (abfd, src->vna_name);
  dst->vna_next  = bfd_h_get_32 (abfd, src->vna_next);
d186 5
a190 5
  bfd_h_put_32 (abfd, src->vna_hash, dst->vna_hash);
  bfd_h_put_16 (abfd, src->vna_flags, dst->vna_flags);
  bfd_h_put_16 (abfd, src->vna_other, dst->vna_other);
  bfd_h_put_32 (abfd, src->vna_name, dst->vna_name);
  bfd_h_put_32 (abfd, src->vna_next, dst->vna_next);
d201 1
a201 1
  dst->vs_vers = bfd_h_get_16 (abfd, src->vs_vers);
d212 1
a212 1
  bfd_h_put_16 (abfd, src->vs_vers, dst->vs_vers);
d248 2
a249 2
     long offset;
     unsigned int size;
d255 1
a255 1
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
d257 1
a257 1
  if (bfd_read ((PTR) buf, size, 1, abfd) != size)
d272 2
a273 2
  elf_tdata (abfd) = (struct elf_obj_tdata *)
    bfd_zalloc (abfd, sizeof (struct elf_obj_tdata));
d297 2
a298 2
  unsigned int offset;
  unsigned int shstrtabsize;
d377 1
a377 1
				      bfd_log2 (hdr->sh_addralign)))
d602 1
a602 1
	  const char *s;
d607 8
a614 8
	    case PT_NULL: s = "NULL"; break;
	    case PT_LOAD: s = "LOAD"; break;
	    case PT_DYNAMIC: s = "DYNAMIC"; break;
	    case PT_INTERP: s = "INTERP"; break;
	    case PT_NOTE: s = "NOTE"; break;
	    case PT_SHLIB: s = "SHLIB"; break;
	    case PT_PHDR: s = "PHDR"; break;
	    default: sprintf (buf, "0x%lx", p->p_type); s = buf; break;
d616 1
a616 1
	  fprintf (f, "%8s off    0x", s);
d631 2
a632 2
	  if ((p->p_flags &~ (PF_R | PF_W | PF_X)) != 0)
	    fprintf (f, " %lx", p->p_flags &~ (PF_R | PF_W | PF_X));
d641 1
a641 1
      unsigned long link;
d658 1
a658 1
      link = elf_elfsections (abfd)[elfsec]->sh_link;
d750 1
d752 1
a752 2
	      string = bfd_elf_string_from_elf_section (abfd, link,
							dyn.d_un.d_val);
d1079 1
d1081 1
a1081 2
  ret = ((struct elf_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_link_hash_table)));
d1170 1
a1170 1
  unsigned long link;
d1197 1
a1197 1
  link = elf_elfsections (abfd)[elfsec]->sh_link;
d1217 2
d1220 1
a1220 2
	  string = bfd_elf_string_from_elf_section (abfd, link,
						    dyn.d_un.d_val);
d1224 2
a1225 1
	  l = (struct bfd_link_needed_list *) bfd_alloc (abfd, sizeof *l);
d1461 1
d1463 2
a1464 1
	    hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, sizeof (*hdr2));
d1536 1
d1538 1
a1538 1
  sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd, sizeof (*sdata));
d1588 1
a1588 1
  name = bfd_alloc (abfd, strlen (namebuf) + 1);
d1619 1
a1619 1
      name = bfd_alloc (abfd, strlen (namebuf) + 1);
d1667 1
a1667 1
      if (! elfcore_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
d1700 2
a1701 1
  struct elf_backend_data *bed;
d1703 1
a1703 2
  bed = get_elf_backend_data (abfd);
  name = bfd_alloc (abfd, sizeof ".rela" + strlen (asect->name));
d1887 1
d1921 2
a1922 2
  i_shdrp = ((Elf_Internal_Shdr **)
	     bfd_alloc (abfd, section_number * sizeof (Elf_Internal_Shdr *)));
d1926 2
a1927 2
  i_shdrp[0] = ((Elf_Internal_Shdr *)
		bfd_alloc (abfd, sizeof (Elf_Internal_Shdr)));
d2009 1
a2009 1
	      alc = (char *) bfd_malloc (len - 2);
d2075 1
a2075 1
  int symcount = bfd_get_symcount (abfd);
d2078 4
a2081 4
  int num_locals = 0;
  int num_globals = 0;
  int num_locals2 = 0;
  int num_globals2 = 0;
d2083 2
a2084 2
  int num_sections = 0;
  int idx;
d2087 1
a2087 1
  asymbol *sym;
d2103 2
a2104 1
  sect_syms = (asymbol **) bfd_zalloc (abfd, max_index * sizeof (asymbol *));
d2112 1
a2112 1
      sym = syms[idx];
d2151 2
d2197 3
a2199 3
  new_syms = ((asymbol **)
	      bfd_alloc (abfd,
			 (num_locals + num_globals) * sizeof (asymbol *)));
d2206 1
a2206 1
      int i;
d2221 1
a2221 1
	  int i;
d2379 1
d2381 3
a2383 4
  m = ((struct elf_segment_map *)
       bfd_zalloc (abfd,
		   (sizeof (struct elf_segment_map)
		    + (to - from - 1) * sizeof (asection *))));
d2422 1
d2432 2
a2433 2
  sections = (asection **) bfd_malloc (bfd_count_sections (abfd)
				       * sizeof (asection *));
d2462 2
a2463 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d2476 2
a2477 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d2624 2
a2625 2
      m = ((struct elf_segment_map *)
	   bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d2647 2
a2648 2
	  m = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, sizeof (struct elf_segment_map)));
d2746 1
d2787 2
a2788 2
  phdrs = ((Elf_Internal_Phdr *)
	   bfd_alloc (abfd, alloc * sizeof (Elf_Internal_Phdr)));
d3116 1
a3116 1
  if (bfd_seek (abfd, bed->s->sizeof_ehdr, SEEK_SET) != 0
d3484 2
d3487 1
a3487 3
	      || (bfd_write (i_shdrp[count]->contents, i_shdrp[count]->sh_size,
			     1, abfd)
		  != i_shdrp[count]->sh_size))
d3793 1
d3806 3
a3808 4
      map = ((struct elf_segment_map *)
	   bfd_alloc (obfd,
		      (sizeof (struct elf_segment_map)
		       + ((size_t) section_count - 1) * sizeof (asection *))));
d3885 2
a3886 2
      sections = (asection **) bfd_malloc
	(sizeof (asection *) * section_count);
d4078 3
a4080 5
	      map = ((struct elf_segment_map *)
		     bfd_alloc (obfd,
				(sizeof (struct elf_segment_map)
				 + ((size_t) section_count - 1)
				 * sizeof (asection *))));
d4295 1
d4311 2
a4312 2
    outbound_syms = bfd_alloc (abfd,
			       (1 + symcount) * bed->s->sizeof_sym);
d4686 1
d4704 1
a4704 1
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
d4723 2
a4724 3
      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, maxidx * sizeof (Elf_Internal_Verdef)));
d4745 2
a4746 4
	  iverdef->vd_auxptr = ((Elf_Internal_Verdaux *)
				bfd_alloc (abfd,
					   (iverdef->vd_cnt
					    * sizeof (Elf_Internal_Verdaux))));
d4796 1
d4798 1
a4798 2
	((Elf_Internal_Verneed *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verneed)));
d4808 1
a4808 1
	  || bfd_read ((PTR) contents, 1, hdr->sh_size, abfd) != hdr->sh_size)
d4829 3
a4831 4
	  iverneed->vn_auxptr =
	    ((Elf_Internal_Vernaux *)
	     bfd_alloc (abfd,
			iverneed->vn_cnt * sizeof (Elf_Internal_Vernaux)));
d4881 1
d4883 1
a4883 1
  newsym = (elf_symbol_type *) bfd_zalloc (abfd, sizeof (elf_symbol_type));
d5101 1
d5109 3
a5111 4

  if (bfd_seek (abfd, hdr->sh_offset + offset, SEEK_SET) == -1)
    return false;
  if (bfd_write (location, 1, count, abfd) != count)
d5323 2
a5324 2
     int size;
     int filepos;
d5333 1
a5333 1
  threaded_name = bfd_alloc (abfd, strlen (buf) + 1);
d5363 1
a5363 1
  int raw_size;
d5481 1
a5481 1
     int max;
d5483 1
a5483 1
  char *dup;
d5485 1
a5485 1
  int len;
d5492 2
a5493 2
  dup = bfd_alloc (abfd, len + 1);
  if (dup == NULL)
d5496 2
a5497 2
  memcpy (dup, start, len);
  dup[len] = '\0';
d5499 1
a5499 1
  return dup;
d5628 1
a5628 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d5657 1
a5657 1
  name = bfd_alloc (abfd, strlen (buf) + 1);
d5712 1
a5712 1
      name = bfd_alloc (abfd, strlen (buf) + 1);
d5737 1
a5737 1
      name = bfd_alloc (abfd, strlen (buf) + 1);
d5825 2
a5826 2
     bfd_vma offset;
     bfd_vma size;
d5834 1
a5834 1
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
d5837 1
a5837 1
  buf = bfd_malloc ((size_t) size);
d5841 1
a5841 1
  if (bfd_read (buf, size, 1, abfd) != size)
d5855 1
a5855 1
      in.type = bfd_h_get_32 (abfd, (bfd_byte *) xnp->type);
d5857 1
a5857 1
      in.namesz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->namesz);
d5860 1
a5860 1
      in.descsz = bfd_h_get_32 (abfd, (bfd_byte *) xnp->descsz);
@


1.90
log
@        * cpu-h8300.c (h8300_scan, compatible): Prototype.
        (h8300_scan): Handle architecture:machine encodings typically
        found in linker scripts.
        * elf.c (prep_headers): Do not try to do H8 machine recognition
        here.
        * elf32-h8300.c:  Add some missing prototypes.
        (elf32_h8_mach, elf32_h8_final_write_processing): New functions.
        (elf32_h8_object_p): Similarly.
@
text
@d3350 12
a3361 12
    case bfd_arch_sparc:
      if (bfd_get_arch_size (abfd) == 64)
	i_ehdrp->e_machine = EM_SPARCV9;
      else
	i_ehdrp->e_machine = EM_SPARC;
      break;
    case bfd_arch_i370:
      i_ehdrp->e_machine = EM_S370;
      break;
    case bfd_arch_i386:
      if (bfd_get_arch_size (abfd) == 64)
	i_ehdrp->e_machine = EM_X86_64;
d3363 3
a3365 100
	i_ehdrp->e_machine = EM_386;
      break;
    case bfd_arch_ia64:
      i_ehdrp->e_machine = EM_IA_64;
      break;
    case bfd_arch_m68hc11:
      i_ehdrp->e_machine = EM_68HC11;
      break;
    case bfd_arch_m68hc12:
      i_ehdrp->e_machine = EM_68HC12;
      break;
    case bfd_arch_s390:
      i_ehdrp->e_machine = EM_S390;
      break;
    case bfd_arch_m68k:
      i_ehdrp->e_machine = EM_68K;
      break;
    case bfd_arch_m88k:
      i_ehdrp->e_machine = EM_88K;
      break;
    case bfd_arch_i860:
      i_ehdrp->e_machine = EM_860;
      break;
    case bfd_arch_i960:
      i_ehdrp->e_machine = EM_960;
      break;
    case bfd_arch_mips:	/* MIPS Rxxxx */
      i_ehdrp->e_machine = EM_MIPS;	/* only MIPS R3000 */
      break;
    case bfd_arch_hppa:
      i_ehdrp->e_machine = EM_PARISC;
      break;
    case bfd_arch_powerpc:
      if (bed->s->arch_size == 64)
	i_ehdrp->e_machine = EM_PPC64;
      else
	i_ehdrp->e_machine = EM_PPC;
      break;
    case bfd_arch_alpha:
      i_ehdrp->e_machine = EM_ALPHA;
      break;
    case bfd_arch_sh:
      i_ehdrp->e_machine = EM_SH;
      break;
    case bfd_arch_d10v:
      i_ehdrp->e_machine = EM_CYGNUS_D10V;
      break;
    case bfd_arch_d30v:
      i_ehdrp->e_machine = EM_CYGNUS_D30V;
      break;
    case bfd_arch_fr30:
      i_ehdrp->e_machine = EM_CYGNUS_FR30;
      break;
    case bfd_arch_mcore:
      i_ehdrp->e_machine = EM_MCORE;
      break;
    case bfd_arch_avr:
      i_ehdrp->e_machine = EM_AVR;
      break;
    case bfd_arch_v850:
      switch (bfd_get_mach (abfd))
	{
	default:
	case 0:               i_ehdrp->e_machine = EM_CYGNUS_V850; break;
	}
      break;
    case bfd_arch_arc:
      i_ehdrp->e_machine = EM_CYGNUS_ARC;
      break;
    case bfd_arch_arm:
      i_ehdrp->e_machine = EM_ARM;
      break;
    case bfd_arch_m32r:
      i_ehdrp->e_machine = EM_CYGNUS_M32R;
      break;
    case bfd_arch_mn10200:
      i_ehdrp->e_machine = EM_CYGNUS_MN10200;
      break;
    case bfd_arch_mn10300:
      i_ehdrp->e_machine = EM_CYGNUS_MN10300;
      break;
    case bfd_arch_pj:
      i_ehdrp->e_machine = EM_PJ;
      break;
    case bfd_arch_cris:
      i_ehdrp->e_machine = EM_CRIS;
      break;
    case bfd_arch_openrisc:
      i_ehdrp->e_machine = EM_OPENRISC;
      break;
      /* Also note that EM_M32, AT&T WE32100 is unknown to bfd.  */
    case bfd_arch_h8300:
      i_ehdrp->e_machine = EM_H8_300;
      break;
    case bfd_arch_h8500:
      i_ehdrp->e_machine = EM_H8_500;
      break;
    default:
      i_ehdrp->e_machine = EM_NONE;
    }
@


1.89
log
@	* Makefile.am (elf32-h8300.lo): New target.
	* config.bfd (h8300*-*-elf): New case.
	* configure.in (bfd_elf32_h8300_vec): New case.
	* elf.c (prep_headers): Add case for bfd_arch_h8300.
	* reloc.c (BFD_RELOC_H8_DIR16A8): New relocation.
	(BFD_RELOC_H8_DIR16R8, BFD_RELOC_H8_DIR24A8): Likewise.
	(BFD_RELOC_H8_DIR24R8, BFD_RELOC_H8_DIR32A16): Likewise.
	* targets.c (bfd_target bfd_elf32_h8300_vec): New extern declaration.
	* elf32-h8300.c: New file.
	* Makefile.in, bfd-in2.h, libbfd.h, configure: Regenerated.
@
text
@d3455 1
a3455 13
      switch (bfd_get_mach (abfd))
	{
	default:
	case bfd_mach_h8300:
	  i_ehdrp->e_machine = EM_H8_300;
	  break;
	case bfd_mach_h8300h:
	  i_ehdrp->e_machine = EM_H8_300H;
	  break;
	case bfd_mach_h8300s:
	  i_ehdrp->e_machine = EM_H8S;
	  break;
	}
@


1.88
log
@	* config.bfd: Add powerpc64 target.  Add powerpc64 vectors to
	targ64_selvecs for 32 bit powerpc targets.
	* Makefile.am (BFD64_BACKENDS): Add elf64-ppc.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-ppc.c.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in: Add elf64_powerpc vecs.
	* configure: Regenerate.
	* cpu-powerpc.c: Default to bfd_mach_ppc_620 entry for 64 bit.
	* elf.c (prep_headers): EM_PPC64 for 64 bit ppc elf target.
	* targets.c: Add bfd_elf64_powerpc_vec and bfd_elf64_powerpcle_vec.
	* elf64-ppc.c: New file.
	* reloc.c: Add powerpc64 relocs.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d3454 18
@


1.87
log
@
	* oasys.c: Add missing prototypes.

	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Add unused
	attribute for parameter.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.

	* versados.c (get_4): Make static.
	(get_10): Make static.
	Add missing prototypes.
	(process_esd): Fix call to versados_new_symbol.
@
text
@d3396 4
a3399 1
      i_ehdrp->e_machine = EM_PPC;
@


1.86
log
@2001-08-24  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_merge_sections): Fail if not using an ELF
	hash structure.
@
text
@d6066 1
a6066 1
     int type;
@


1.85
log
@Apply H.J.'s patch to revert change to elfxx-target.h
Apply my patch to allow SREC as output format.
@
text
@d574 1
a574 5
  struct elf_link_hash_table * hash_table;

  hash_table = elf_hash_table (info);

  if (hash_table == NULL)
d576 2
a577 3

  if (hash_table->merge_info)
    _bfd_merge_sections (abfd, hash_table->merge_info);
@


1.84
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d574 9
a582 2
  if (elf_hash_table (info)->merge_info)
    _bfd_merge_sections (abfd, elf_hash_table (info)->merge_info);
d1057 2
d1071 4
a1074 1
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc);
@


1.83
log
@	* elf-bfd.h (enum elf_reloc_type_class): New.
	(struct elf_backend_data): Add elf_backend_reloc_type_class.
	(_bfd_elf_reloc_type_class): New.
	* elfxx-target.h (elf_backend_reloc_type_class): Define.
	(elfNN_bed): Add elf_backend_reloc_type_class.
	* elf.c (_bfd_elf_reloc_type_class): New.
	* elf32-i386.c (elf_i386_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(elf_i386_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_i386_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_sparc_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_sparc_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf64-sparc.c (sparc64_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(sparc64_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(sparc64_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add reltext field.
	(elfNN_ia64_hash_table_create): Clear ia64_info.
	(get_reloc_section): Set DF_TEXTREL if the reloc is against read-only
	section.
	(elfNN_ia64_size_dynamic_sections): Use ia64_info->reltext flag
	instead of looking up section names for DT_TEXTREL.
	(elfNN_ia64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elflink.h (size_dynamic_sections): Add spare DT_NULL tags.
	(struct elf_link_sort_rela): New.
	(elf_link_sort_cmp1, elf_link_sort_cmp2, elf_link_sort_relocs): New.
	(elf_bfd_final_link): Call elf_link_sort_relocs.
	Convert one spare DT_NULL into DT_RELCOUNT resp. DT_RELACOUNT if
	necessary.

	* bfdlink.h (struct bfd_link_info): Add combreloc and
	spare_dynamic_tags fields.

	* emultempl/elf32.em (place_orphan): Place orphan .rel* sections
	into .rel.dyn resp. .rela.dyn if combreloc.
	(get_script): If .x linker script is equal to .xn, only put it
	once into the binary.
	Add .xc and .xsc scripts.
	(parse_args): Handle -z combreloc and -z nocombreloc.
	* scripttempl/elf.sc (.rela.sbss): Fix a typo.
	For .xc and .xsc scripts put all .rel* or .rela* input sections
	but .rel*.plt and PLT-like sections into .rel.dyn resp. .rela.dyn.
	* genscripts.sh (GENERATE_COMBRELOC_SCRIPT): Set if SCRIPT_NAME
	is elf.
	Strip trailing whitespace from script.
	Generate .xc and .xsc scripts if requested.
	* ldmain.c (main): Initialize link_info.combreloc and
	link_info.spare_dynamic_tags.
	* lexsup.c (OPTION_SPARE_DYNAMIC_TAGS): Define.
	(ld_options): Add --spare-dynamic-tags option.
	(parse_args): Likewise.
	* ld.texinfo: Document -z combreloc and -z nocombreloc.
	* ldint.texinfo: Document .xc and .xsc linker scripts.
	* NEWS: Add notes about -z combreloc and SHF_MERGE.
@
text
@d615 1
a615 1
	  fprintf_vma (f, p->p_offset);
d617 1
a617 1
	  fprintf_vma (f, p->p_vaddr);
d619 1
a619 1
	  fprintf_vma (f, p->p_paddr);
d622 1
a622 1
	  fprintf_vma (f, p->p_filesz);
d624 1
a624 1
	  fprintf_vma (f, p->p_memsz);
d833 1
a833 1
      fprintf_vma (file, symbol->value);
d852 1
a852 1
	    bfd_print_symbol_vandf ((PTR) file, symbol);
d860 4
a863 4
	fprintf_vma (file,
		     (bfd_is_com_section (symbol->section)
		      ? ((elf_symbol_type *) symbol)->internal_elf_sym.st_value
		      : ((elf_symbol_type *) symbol)->internal_elf_sym.st_size));
@


1.82
log
@2001-08-20  H.J. Lu  <hjl@@gnu.org>

	* elf-bfd.h (elf_obj_tdata): Add num_section_syms.
	(elf_num_section_syms): New for num_section_syms.

	* elf.c (elf_map_symbols): Set num_section_syms.
	(_bfd_elf_symbol_from_bfd_symbol): Check num_section_syms for
	the section symbol index.
@
text
@d6056 7
@


1.81
log
@	* archive.c (offsetof): Remove define.
	* elf.c: Likewise.
	* oasys.c: Likewise
	* sysdep.h (offsetof): Define.
@
text
@d2094 1
d3655 2
a3656 1
      if (elf_section_syms (abfd)[indx])
@


1.80
log
@replace direct invocation og elf vma print functions with indirect invocation
@
text
@a5345 6
/* Define offsetof for those systems which lack it.  */

#ifndef offsetof
# define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

@


1.79
log
@	* elf.c (bfd_elf_sprintf_vma): Add ATTRIBUTE_UNUSED to quiet
	warning if not BFD64.  Add braces so emacs auto format works.
	(bfd_elf_fprintf_vma): Likewise.
@
text
@d5999 1
a5999 1
bfd_elf_sprintf_vma (abfd, buf, value)
d6030 1
a6030 1
bfd_elf_fprintf_vma (abfd, stream, value)
@


1.78
log
@2001-08-09  H.J. Lu  <hjl@@gnu.org>

	* elf.c (bfd_elf_sprintf_vma): Check ELFCLASS64 only in BFD64.
	(bfd_elf_fprintf_vma): Likewise.
@
text
@d6000 1
a6000 1
     bfd *abfd;
d6013 1
d6015 1
a6015 1
	sprintf (buf, "%016lx", value);
d6017 2
a6018 2
	sprintf (buf, "%08lx%08lx", _bfd_int64_high (value),
		 _bfd_int64_low (value));
d6020 1
d6031 1
a6031 1
     bfd *abfd;
d6044 1
d6046 1
a6046 1
	fprintf ((FILE *) stream, "%016lx", value);
d6048 2
a6049 2
	fprintf ((FILE *) stream, "%08lx%08lx",
		 _bfd_int64_high (value), _bfd_int64_low (value));
d6051 1
@


1.77
log
@2001-08-09  H.J. Lu  <hjl@@gnu.org>

	* bfd-in.h (bfd_sprintf_vma): New prototype.
	(bfd_fprintf_vma): Likewise.
	(bfd_elf_sprintf_vma): Likewise.
	(bfd_elf_fprintf_vma): Likewise.
	(bfd_printf_vma): New. Defined with bfd_fprintf_vma.
	* bfd-in2.h: Regenerated.

	* bfd.c (bfd_sprintf_vma): New. Defined.
	(bfd_fprintf_vma): Likewise.

	* elf.c (bfd_elf_sprintf_vma): New. Defined.
	(bfd_elf_fprintf_vma): Likewise.
@
text
@d6004 1
d6022 3
d6033 1
d6052 3
@


1.76
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d5997 51
@


1.75
log
@Return zero only as the last step of qsort function.
@
text
@d60 10
a69 4
static boolean elf_find_function PARAMS ((bfd *, asection *,
                                         asymbol **,
                                         bfd_vma, const char **,
                                         const char **));
d5433 2
d5580 1
@


1.74
log
@	* elfcore.h (elf_core_file_p): Call bfd_section_from_phdr directly
	instead of _bfd_elfcore_section_from_phdr.
	* elf-bfd.h (_bfd_elfcore_section_from_phdr): Remove.
	* elf.c (_bfd_elfcore_section_from_phdr): Remove.
	(_bfd_elfcore_make_pseudosection): Expedite tail-call.
	(elfcore_grok_prstatus): Likewise.
	(elfcore_grok_lwpstatus): Likewise.
	(bfd_get_elf_phdr_upper_bound): Likewise.
	(elfcore_make_note_pseudosection): Formatting.
	(_bfd_elfcore_strndup): Formatting.
	* elf32-mips.c (mips_elf_sym_is_global): Formatting.
	(_bfd_elf32_mips_grok_prstatus): Expedite tail-call.
@
text
@d2680 6
a2685 1
	return sec1->target_index - sec2->target_index;
d2689 1
a2689 2

  if (TOEND (sec2))
d2694 2
a2695 2
  /* Sort by size, to put zero sized sections before others at the
     same address.  */
@


1.73
log
@	* elf-bfd.h: Add prototypes for _bfd_elfcore_make_pseudosection
	and _bfd_elfcore_strndup.
	(struct elf_backend_data): Add elf_backend_grok_prstatus
	and elf_backend_grok_psinfo.
	* elf.c (_bfd_elfcore_make_pseudosection): New function.
	(elfcore_grok_prstatus): Use it.
	(elfcore_make_note_pseudosection): Likewise.
	(elfcore_strndup):  Rename to...
	(_bfd_elfcore_strndup): Here, and make global.
	(elfcore_grok_psinfo): Use _bfd_elfcore_strndup.
	(elfcore_grok_note): Call elf_backend_grok_prstatus
	and elf_backend_grok_psinfo if available.
	* elf32-mips.c (_bfd_elf32_mips_grok_prstatus): New function.
	(_bfd_elf32_mips_grok_psinfo): New function.
	(elf_backend_grok_prstatus): Define.
	(elf_backend_grok_psinfo): Define.
	* elfxx-target.h (elf_backend_grok_prstatus): Default to NULL.
	(elf_backend_grok_psinfo): Likewise.
	(elfNN_bed): Include elf_backend_grok_prstatus and
	elf_backend_grok_psinfo.
@
text
@d5413 1
a5413 4
  if (! elfcore_maybe_make_sect (abfd, name, sect))
    return false;

  return true;
d5484 2
a5485 5
  if (! _bfd_elfcore_make_pseudosection (abfd, ".reg",
					 raw_size, note->descpos + offset));
    return false;

  return true;
d5496 2
a5497 1
  return _bfd_elfcore_make_pseudosection (abfd, name, note->descsz, note->descpos);
d5542 1
a5542 1
char*
d5581 2
a5582 1
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5585 2
a5586 1
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5597 2
a5598 1
	= _bfd_elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5601 2
a5602 1
	= _bfd_elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5744 1
a5744 4
  if (!elfcore_maybe_make_sect (abfd, ".reg2", sect))
    return false;

  return true;
a5936 15

/* FIXME: This function is now unnecessary.  Callers can just call
   bfd_section_from_phdr directly.  */

boolean
_bfd_elfcore_section_from_phdr (abfd, phdr, sec_num)
     bfd *abfd;
     Elf_Internal_Phdr* phdr;
     int sec_num;
{
  if (! bfd_section_from_phdr (abfd, phdr, sec_num))
    return false;

  return true;
}
d5954 1
a5954 2
  return (elf_elfheader (abfd)->e_phnum
	  * sizeof (Elf_Internal_Phdr));
@


1.72
log
@	* elflink.h: Whitespace changes.
	(elf_link_read_relocs_from_section): Use "unsigned int" iterator
	rather than "unsigned char".
	(elf_link_output_relocs): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_reloc_link_order): LIkewise.
	* elf.c: s/CONST/const/.  Whitespace changes.
	* elf32-mips.c: Formatting fix.

	* Makefile.am (SOURCE_HFILES): Include xcoff-target.h, remove xcoff.h.
	* Makefile.in: Regenerate.
	* po/Make-in: Remove trailing tab.
@
text
@d5379 40
a5430 3
  char buf[100];
  char *name;
  asection *sect;
d5486 3
a5488 19
  /* Make a ".reg/999" section.  */

  sprintf (buf, ".reg/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return false;
  strcpy (name, buf);

  sect = bfd_make_section (abfd, name);
  if (sect == NULL)
    return false;

  sect->_raw_size = raw_size;
  sect->filepos = note->descpos + offset;

  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
d5495 1
a5495 8
/* Create a pseudosection containing the exact contents of NOTE.  This
   actually creates up to two pseudosections:
   - For the single-threaded case, a section named NAME, unless
     such a section already exists.
   - For the multi-threaded case, a section named "NAME/PID", where
     PID is elfcore_make_pid (abfd).
   Both pseudosections have identical contents: the contents of NOTE.  */

d5502 1
a5502 24
  char buf[100];
  char *threaded_name;
  asection *sect;

  /* Build the section name.  */

  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  threaded_name = bfd_alloc (abfd, strlen (buf) + 1);
  if (threaded_name == NULL)
    return false;
  strcpy (threaded_name, buf);

  sect = bfd_make_section (abfd, threaded_name);
  if (sect == NULL)
    return false;
  sect->_raw_size = note->descsz;
  sect->filepos = note->descpos;
  sect->flags = SEC_HAS_CONTENTS;
  sect->alignment_power = 2;

  if (! elfcore_maybe_make_sect (abfd, name, sect))
    return false;

  return true;
a5542 2
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)

d5547 2
a5548 2
static char*
elfcore_strndup (abfd, start, max)
d5572 2
d5586 1
a5586 1
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5589 1
a5589 1
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5600 1
a5600 1
	= elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5603 1
a5603 1
	= elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5835 2
d5842 4
a5846 1
    case NT_PRSTATUS:
d5848 2
a5876 1
#if defined (HAVE_PRPSINFO_T) || defined (HAVE_PSINFO_T)
d5879 4
d5884 2
@


1.71
log
@2001-06-08  H.J. Lu  <hjl@@gnu.org>

	* elf.c (swap_out_syms): Keep names for global section symbols.
@
text
@d832 2
a833 2
	CONST char *section_name;
	CONST char *name = NULL;
d5023 1
a5023 1
                  filename_ptr, functionname_ptr)
d5028 2
a5029 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d5085 1
a5085 1
                           filename_ptr, functionname_ptr, line_ptr)
d5090 2
a5091 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d5097 2
a5098 2
                                    filename_ptr, functionname_ptr,
                                    line_ptr))
d5101 4
a5104 4
       elf_find_function (abfd, section, symbols, offset,
                          *filename_ptr ? NULL : filename_ptr,
                          functionname_ptr);
       
d5109 3
a5111 3
                                    filename_ptr, functionname_ptr,
                                    line_ptr, 0,
                                    &elf_tdata (abfd)->dwarf2_find_line_info))
d5114 4
a5117 4
       elf_find_function (abfd, section, symbols, offset,
                          *filename_ptr ? NULL : filename_ptr,
                          functionname_ptr);
       
d5122 3
a5124 3
                                            &found, filename_ptr,
                                            functionname_ptr, line_ptr,
                                            &elf_tdata (abfd)->line_info))
d5133 1
a5133 1
                          filename_ptr, functionname_ptr))
@


1.70
log
@Replace sh_size/sh_entsize with NUM_SHDR_ENTRIES
@
text
@d4397 1
a4397 1
	if ((flags & BSF_SECTION_SYM) != 0)
d4399 1
a4399 1
	    /* Section symbols have no name.  */
d4508 6
a4513 1
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
@


1.69
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d1452 1
a1452 1
	target_sect->reloc_count += hdr->sh_size / hdr->sh_entsize;
@


1.68
log
@	* ecoff.c (bfd_debug_section): Fix initialization.
	* elf.c (_bfd_elf_slurp_version_tables): Change maxidx to unsigned, it
	is always a positive integer. Cast away sign mismatch.
	* elf32-mips.c: Fix misleading comment and typo.
	(_bfd_mips_elf_section_from_bfd_section): Remove unused attribute, use
	correct data type.
	* elflink.c: Fix typo.
	(_bfd_elf_create_dynamic_sections): Remove superfluous initialization.
	* ecoffswap.h (ecoff_swap_fdr_in): Cast away sign mismatch.
@
text
@d561 12
@


1.67
log
@2000-04-27  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_link_hash_hide_symbol): Set dynindx to -1
	only for ELF_LINK_FORCED_LOCAL.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf32-mips.c (_bfd_mips_elf_hide_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_hide_symbol): Likewise.

	* elflink.h (elf_fix_symbol_flags): Set ELF_LINK_FORCED_LOCAL
	if the symbol has hidden or internal visibility.
@
text
@d4737 1
a4737 1
      int maxidx;
d4757 2
a4758 2
	  if ((iverdefmem.vd_ndx & VERSYM_VERSION) > maxidx)
	    maxidx = iverdefmem.vd_ndx & VERSYM_VERSION;
@


1.66
log
@Add OpenRISC support
@
text
@a1016 1
  h->dynindx = -1;
d1018 2
@


1.65
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d3416 4
a3419 1
      /* also note that EM_M32, AT&T WE32100 is unknown to bfd */
@


1.64
log
@Update copyright notices
@
text
@d389 7
d1041 1
d1820 7
@


1.63
log
@fixes for elf_find_nearest_line
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.62
log
@Add s390 support
@
text
@d59 4
d4717 1
a4717 1
      unsigned int maxidx;
d4981 2
a4982 2
/* Find the nearest line to a particular section and offset, for error
   reporting.  */
d4984 4
a4987 9
boolean
_bfd_elf_find_nearest_line (abfd,
			    section,
			    symbols,
			    offset,
			    filename_ptr,
			    functionname_ptr,
			    line_ptr)
     bfd *abfd;
a4992 1
     unsigned int *line_ptr;
a4993 1
  boolean found;
a4998 22
  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    return true;

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    return true;

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return false;
  if (found)
    return true;

  if (symbols == NULL)
    return false;

d5035 64
a5098 2
  *filename_ptr = filename;
  *functionname_ptr = bfd_asymbol_name (func);
@


1.61
log
@Fix formatting.
@
text
@d3323 3
@


1.61.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.61.2.2
log
@Merge from mainline.
@
text
@a59 4
static boolean elf_find_function PARAMS ((bfd *, asection *,
                                         asymbol **,
                                         bfd_vma, const char **,
                                         const char **));
d809 2
a810 2
	const char *section_name;
	const char *name = NULL;
d1006 1
a1007 2
  if ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
    h->dynindx = -1;
d1427 1
a1427 1
	target_sect->reloc_count += NUM_SHDR_ENTRIES (hdr);
d3394 1
a3394 1
      /* Also note that EM_M32, AT&T WE32100 is unknown to bfd.  */
d4731 2
a4732 2
	  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)
	    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);
d4975 2
a4976 2
/* Find the function to a particular section and offset,
   for error reporting.  */
d4978 9
a4986 4
static boolean
elf_find_function (abfd, section, symbols, offset,
		   filename_ptr, functionname_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
d4990 3
a4992 2
     const char **filename_ptr;
     const char **functionname_ptr;
d4994 1
d5000 22
d5058 2
a5059 64
  if (filename_ptr)
    *filename_ptr = filename;
  if (functionname_ptr)
    *functionname_ptr = bfd_asymbol_name (func);

  return true;
}

/* Find the nearest line to a particular section and offset,
   for error reporting.  */

boolean
_bfd_elf_find_nearest_line (abfd, section, symbols, offset,
			    filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
{
  boolean found;

  if (_bfd_dwarf1_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return true;
    }

  if (_bfd_dwarf2_find_nearest_line (abfd, section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, 0,
				     &elf_tdata (abfd)->dwarf2_find_line_info))
    {
      if (!*functionname_ptr)
	elf_find_function (abfd, section, symbols, offset,
			   *filename_ptr ? NULL : filename_ptr,
			   functionname_ptr);

      return true;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
					     &found, filename_ptr,
					     functionname_ptr, line_ptr,
					     &elf_tdata (abfd)->line_info))
    return false;
  if (found)
    return true;

  if (symbols == NULL)
    return false;

  if (! elf_find_function (abfd, section, symbols, offset,
			   filename_ptr, functionname_ptr))
    return false;

@


1.60
log
@Generalize DWARF2 and COFF support.
@
text
@d3310 1
a3310 1
      i_ehdrp->e_machine = EM_X86_64;
d3312 1
a3312 1
      i_ehdrp->e_machine = EM_386;
@


1.59
log
@Add support for x86_64-*-linux-gnu* target
@
text
@d5006 2
a5007 1
				     line_ptr, 0))
@


1.58
log
@Revert 2000-10-07 link-once section symbol changes.
@
text
@d3309 3
@


1.57
log
@Make elf section symbols global for link-once sections.
@
text
@d4355 5
a4359 4
	/* Section symbols usually have no name.  The exception is
	   link-once section symbols, which we make global.  */
	if ((flags & (BSF_SECTION_SYM | BSF_GLOBAL)) == BSF_SECTION_SYM)
	  sym.st_name = 0;
d4466 1
a4466 2
	  sym.st_info = ELF_ST_INFO ((flags & BSF_GLOBAL
				      ? STB_GLOBAL : STB_LOCAL), STT_SECTION);
@


1.56
log
@Preserve machine dependent section header flags when reading ELF object file.
	* elf-bfd.h (struct elf_backend_data): Add elf_backend_section_flags
	field.
	* elf.c (_bfd_elf_make_section_from_shdr): Call the
	elf_backend_section_flags function.
	* elf64-ia64.c (elf64_ia64_section_from_shdr): Delete flag conversion
	code.
	(elf64_ia64_section_flags): New function containing flag conversion
	code.
	(elf_backend_section_flags): Define to elf64_ia64_section_flags.
	* elfxx-target.h (elf_backend_section_flags): Define.
	(elfNN_bed): Initialize elf_backend_section_flags field.
@
text
@d4355 3
a4357 2
	if (flags & BSF_SECTION_SYM)
	  /* Section symbols have no names.  */
d4465 2
a4466 1
	  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
@


1.55
log
@Support for Unixware 7.1.x pxstatus_t and lwpxstatus_t.
@
text
@d348 1
d413 5
@


1.54
log
@That'll teach me not to type little patches in by hand.  Get
the parentheses right.
@
text
@d5556 5
a5560 1
  if (note->descsz == sizeof (pstatus_t))
d5598 5
a5602 1
  if (note->descsz != sizeof (lwpstat))
@


1.53
log
@(elf_fake_sections): Do not mark the section SHT_NOBITS if
is has the SEC_HAS_CONTENTS flag set.
@
text
@d1790 1
a1790 1
	   && ((asect->flags & (SEC_LOAD | SEC_HAS_CONTENTS) == 0)))
@


1.52
log
@Make debug_sec_names static.
@
text
@d1790 1
a1790 4
	   && (asect->flags & SEC_LOAD) != 0)
    this_hdr->sh_type = SHT_PROGBITS;
  else if ((asect->flags & SEC_ALLOC) != 0
	   && ((asect->flags & SEC_LOAD) == 0))
d1793 1
a1793 4
    {
      /* Who knows?  */
      this_hdr->sh_type = SHT_PROGBITS;
    }
@


1.51
log
@2000-09-07  Kazu Hirata  <kazu@@hxi.com>

	* elf.c: Fix formatting.
@
text
@d387 1
a387 1
    const char *debug_sec_names [] =
@


1.50
log
@Add .gnu.linkobce.wi. to the list of debug section names.
Update generated files
@
text
@d232 1
a232 1
   buffer. */
d236 1
a236 1
     bfd * abfd;
d257 1
a257 1
     bfd * abfd;
d259 2
a260 2
  /* this just does initialization */
  /* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
d265 2
a266 2
  /* since everything is done at close time, do we need any
     initialization? */
d273 1
a273 1
     bfd * abfd;
d275 1
a275 1
  /* I think this can be done just like an object file. */
d281 1
a281 1
     bfd * abfd;
d296 1
a296 1
      /* No cached one, attempt to read, and cache what we read. */
d307 1
a307 1
     bfd * abfd;
d387 1
a387 1
    const char * debug_sec_names [] =
d475 1
a475 1
     bfd * abfd;
a514 1
/*ARGSUSED*/
d806 1
a806 1
	
d811 1
a811 1
	    name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);
d882 1
a882 1
	
d1224 1
a1224 1
/* Create a new bfd section from an ELF section header. */
d1397 1
a1397 1
	   try.  We just present it as a normal section.  We also 
d1399 1
a1399 1
	   section. */
d1494 1
a1494 1
  sdata->use_rela_p 
d1557 1
a1557 1
	     may be data. */
d1629 1
a1629 1
         If no handler for them, default to making "segment" sections. */
a1676 1
/*ARGSUSED*/
d1815 1
a1815 1
     create the other.  */ 
d1817 1
a1817 1
      && !_bfd_elf_init_reloc_shdr (abfd, 
d1819 1
a1819 1
				    asect, 
d2059 1
a2059 1
      
d2073 1
a2073 1
		  
d3369 1
a3369 1
   case bfd_arch_arc:
d3372 1
a3372 1
   case bfd_arch_arm:
d3397 1
a3397 1
  /* no program header, for now. */
d3402 1
a3402 1
  /* each bfd section is section header entry */
d3406 1
a3406 1
  /* if we're building an executable, we'll need a program header table */
d3409 1
a3409 1
      /* it all happens later */
d3414 1
a3414 1
	 Elf_Internal_Phdrs */
d3494 1
a3494 1
  /* After writing the headers, we need to write the sections too... */
d3525 1
a3525 1
  /* Hopefully this can be done just like an object file. */
d3528 3
a3530 1
/* given a section, search the header to find them... */
d3652 1
a3652 1
  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d3662 1
a3662 1
  pointer_to_map = & map_first;
d3678 1
a3678 1
    
d3686 1
a3686 1
  /* Special case: corefile "NOTE" section containing regs, prpsinfo etc. */
d3739 1
a3739 1
       i ++, segment ++)
d3742 1
a3742 1
      Elf_Internal_Phdr * segment2;
d3746 1
a3746 1
      
d3748 1
a3748 1
      for (j = 0, segment2 = elf_tdata (ibfd)->phdr; j < i; j ++, segment2 ++)
d3751 1
a3751 1
	  
d3755 1
a3755 1
	  
d3759 2
a3760 1
	      /* Extend SEGMENT2 to include SEGMENT and then delete SEGMENT.  */
d3764 1
a3764 1
	      
d3770 1
a3770 1
	      
d3772 1
a3772 1
	      
d3780 2
a3781 1
	      /* Extend SEGMENT to include SEGMENT2 and then delete SEGMENT2.  */
d3785 1
a3785 1
	      
d3791 1
a3791 1
	      
d3796 1
a3796 1
  
d3812 1
a3812 1
      
d3817 1
a3817 1
	  ++ section_count;
d3851 1
a3851 1
	  
d3867 2
a3868 2
	  * pointer_to_map = map;
	  pointer_to_map = & map->next;
d3971 2
a3972 2
	  * pointer_to_map = map;
	  pointer_to_map = & map->next;
d4037 1
a4037 1
	      
d4086 2
a4087 2
	  * pointer_to_map = map;
	  pointer_to_map = & map->next;
d4141 1
a4141 1
      
d4143 1
a4143 1
	count ++;
d4149 1
a4149 1
  
d4151 2
a4152 1
  /* Final Step: Sort the segments into ascending order of physical address.  */
d4155 1
a4155 1
      struct elf_segment_map * prev;
d4304 1
a4304 1
  /* Dump out the symtabs. */
d4995 1
a4995 1
				     filename_ptr, functionname_ptr, 
d5122 1
a5122 1
  /* Check whether we really have an ELF howto. */
d5130 1
a5130 1
	 equivalent ELF reloc. */
a5242 1

d5247 1
a5247 1
   out details about the corefile. */
d5253 1
a5253 2

/* Define offsetof for those systems which lack it. */
d5259 1
a5259 2

/* FIXME: this is kinda wrong, but it's what gdb wants. */
d5263 1
a5263 1
     bfd* abfd;
a5268 1

d5272 1
a5272 1
   overwrite it. */
d5276 3
a5278 3
     bfd* abfd;
     char* name;
     asection* sect;
d5280 1
a5280 1
  asection* sect2;
a5295 1

d5305 2
a5306 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5309 2
a5310 2
  char* name;
  asection* sect;
d5366 1
a5366 1
  /* Make a ".reg/999" section. */
a5390 1

d5401 1
a5401 1
     bfd* abfd;
d5403 1
a5403 1
     Elf_Internal_Note* note;
d5407 1
a5407 1
  asection* sect;
a5430 1

d5433 2
a5434 1
   data structure apart. */
d5437 2
a5438 2
     bfd* abfd;
     Elf_Internal_Note* note;
a5442 1

d5446 1
d5449 2
a5450 2
     bfd* abfd;
     Elf_Internal_Note* note;
a5454 1

a5468 1

d5473 1
a5473 1
   the copy will always have a terminating '\0'. */
d5477 2
a5478 2
     bfd* abfd;
     char* start;
d5481 2
a5482 2
  char* dup;
  char* end = memchr (start, '\0', max);
d5502 2
a5503 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5542 1
a5542 1
     implementations, so strip it off if it exists. */
d5545 1
a5545 1
    char* command = elf_tdata (abfd)->core_command;
a5555 1

d5559 2
a5560 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5583 1
a5583 1
     NT_LWPSTATUS note, presumably. */
a5588 1

d5592 2
a5593 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5597 2
a5598 2
  char* name;
  asection* sect;
d5608 1
a5608 1
  /* Make a ".reg/999" section. */
d5673 2
a5674 2
     bfd * abfd;
     Elf_Internal_Note * note;
d5677 2
a5678 2
  char * name;
  asection * sect;
d5684 3
a5686 3
  memcpy (& pstatus, note->descdata, note->descsz);
  
  switch (pstatus.data_type) 
d5692 1
a5692 1
      break ;
d5697 1
a5697 1
      
d5700 2
a5701 2
        return false;
      
d5706 2
a5707 2
        return false;
      
d5721 2
a5722 2
      sprintf (buf, ".module/%08x" , pstatus.data.module_info.base_address);
      
d5726 1
a5726 1
      
d5730 1
a5730 1
      
d5733 1
a5733 1
      
d5750 2
a5751 2
     bfd* abfd;
     Elf_Internal_Note* note;
d5777 1
a5777 1
    case NT_WIN32PSTATUS:	
d5781 1
a5781 1
  case NT_PRXFPREG:		/* Linux SSE extension */
a5795 1

d5798 1
a5798 1
     bfd* abfd;
d5802 2
a5803 2
  char* buf;
  char* p;
d5825 2
a5826 2
      /* FIXME: bad alignment assumption. */
      Elf_External_Note* xnp = (Elf_External_Note*) p;
a5847 1

d5853 1
a5853 1
     bfd* abfd;
a5861 2


d5868 1
a5882 1

d5890 1
d5905 1
a5905 1
  memcpy (phdrs, elf_tdata (abfd)->phdr, 
@


1.49
log
@2000-08-29  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * elf.c: Eliminate references to __sparcv9 macro; replace with
        autoconf variables HAVE_PSINFO32_T etc.
        * configure.in: Auto-configure HAVE_PSINFO_32_T, HAVE_PRPSINFO32_T,
        HAVE_PSTATUS32_T, HAVE_PRSTATUS32_T, HAVE_PRSTATUS32_T_PR_WHO.
        * config.in: Ditto.
        * acinclude.m4 (BFD_HAVE_SYS_PROCFS_TYPE) define _SYSCALL32 so it can
        detect the above typedefs.  (BFD_HAVE_SYS_PROCFS_TYPE_MEMBER): Ditto.
        * aclocal.m4: Ditto.
        * configure: Regenerate.
@
text
@d386 17
a402 4
  if (strncmp (name, ".debug", sizeof ".debug" - 1) == 0
      || strncmp (name, ".line", sizeof ".line" - 1) == 0
      || strncmp (name, ".stab", sizeof ".stab" - 1) == 0)
    flags |= SEC_DEBUGGING;
@


1.48
log
@2000-08-22  H.J. Lu  <hjl@@gnu.org>

	* elf-bfd.h (elf_link_hash_table): Add runpath.

	* bfd-in.h (bfd_elf_get_runpath_list): New prototype.
	* bfd-in2.h: Rebuilt.

	* elf.c (_bfd_elf_link_hash_table_init): Initialize the
	"runpath" field to NULL.
	(bfd_elf_get_runpath_list): New function.

	* elflink.h (elf_link_add_object_symbols): Record DT_RPATH and
	DT_RUNPATH entries.
@
text
@d34 2
a35 4
#ifdef __sparcv9
#define _SYSCALL32	/* For Sparc64-cross-32 */
#endif

d803 1
a803 1
	    name = symbol->name;  
d982 1
a982 1
_bfd_elf_link_hash_hide_symbol(info, h)
d5301 1
d5308 1
d5324 1
a5324 1
#if defined (__sparcv9)
d5331 1
d5343 1
a5343 1
#if defined (HAVE_PRSTATUS_T_PR_WHO)
d5347 1
a5347 1
#endif /* __sparcv9 */
d5367 2
a5368 12
  if (note->descsz == sizeof (prstatus_t))
    {
      sect->_raw_size = raw_size;
      sect->filepos = note->descpos + offsetof (prstatus_t, pr_reg);
    }
#if defined (__sparcv9)
  else if (note->descsz == sizeof (prstatus32_t))
    {
      sect->_raw_size = raw_size;
      sect->filepos = note->descpos + offsetof (prstatus32_t, pr_reg);
    }
#endif
d5448 1
a5448 1
#if defined (__sparcv9)	/* Sparc64 cross Sparc32 */
d5455 1
a5455 1
#if defined (__sparcv9)	/* Sparc64 cross Sparc32 */
d5501 1
a5501 1
      memcpy (&psinfo, note->descdata, note->descsz);
d5509 1
a5509 1
#if defined (__sparcv9)
d5515 1
a5515 1
      memcpy (&psinfo, note->descdata, note->descsz);
d5563 1
a5563 1
#if defined (__sparcv9)
@


1.47
log
@Restore reverted code.  Fix bug in reverted code which was eliminating too
many segments.
@
text
@d1010 1
d1075 13
@


1.46
log
@2000-08-03  H.J. Lu  <hjl@@gnu.org>

	* section.c: Back out the change made by Nick Clifton
	<nickc@@cygnus.com> on 2000-07-31. It breaks stripping dynamic
	binaries.
	* bfd-in2.h: Likewise.
	* elf.c: Likewise.
@
text
@d3614 12
a3625 8
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *mfirst;
  struct elf_segment_map **pm;
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;
  unsigned int i;
  unsigned int num_segments;
  boolean phdr_included = false;
d3627 1
a3627 1
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
d3636 2
a3637 2
  mfirst = NULL;
  pm = &mfirst;
d3640 1
d3642 18
a3659 4
#define IS_CONTAINED_BY(addr, len, bottom, phdr)		 	\
	  ((addr) >= (bottom)				 	  	\
	   && (   ((addr) + (len)) <= ((bottom) + (phdr)->p_memsz)	\
	       || ((addr) + (len)) <= ((bottom) + (phdr)->p_filesz)))
d3662 6
a3667 7

#define IS_COREFILE_NOTE(p, s)                                          \
	    (p->p_type == PT_NOTE                                       \
	     && bfd_get_format (ibfd) == bfd_core                       \
	     && s->vma == 0 && s->lma == 0                              \
	     && (bfd_vma) s->filepos >= p->p_offset                     \
	     && (bfd_vma) s->filepos + s->_raw_size                     \
d3673 8
d3682 25
a3706 8
#define IS_SOLARIS_PT_INTERP(p, s)					\
	    (p->p_vaddr == 0						\
	     && p->p_filesz > 0						\
	     && (s->flags & SEC_HAS_CONTENTS) != 0			\
	     && s->_raw_size > 0					\
	     && (bfd_vma) s->filepos >= p->p_offset			\
	     && ((bfd_vma) s->filepos + s->_raw_size			\
		     <= p->p_offset + p->p_filesz))
d3709 6
a3714 2
     of the input BFD.  */
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < num_segments; i++, p++)
a3715 7
      unsigned int csecs;
      asection *s;
      asection **sections;
      asection *os;
      unsigned int isec;
      bfd_vma matching_lma;
      bfd_vma suggested_lma;
d3717 1
d3719 72
a3790 16
      /* For each section in the input BFD, decide if it should be
	 included in the current segment.  A section will be included
	 if it is within the address space of the segment, and it is
	 an allocated segment, and there is an output section
	 associated with it.  */
      csecs = 0;
      for (s = ibfd->sections; s != NULL; s = s->next)
	if (s->output_section != NULL)
	  {
	    if ((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	      ++csecs;
	    else if (IS_COREFILE_NOTE (p, s))
	      ++csecs;
	  }
d3794 1
a3794 1
      m = ((struct elf_segment_map *)
d3797 2
a3798 2
		       + ((size_t) csecs - 1) * sizeof (asection *))));
      if (m == NULL)
d3803 6
a3808 6
      m->next          = NULL;
      m->p_type        = p->p_type;
      m->p_flags       = p->p_flags;
      m->p_flags_valid = 1;
      m->p_paddr       = p->p_paddr;
      m->p_paddr_valid = 1;
d3812 2
a3813 2
      m->includes_filehdr = (p->p_offset == 0
			     && p->p_filesz >= iehdr->e_ehsize);
d3815 1
a3815 1
      m->includes_phdrs = 0;
d3817 1
a3817 1
      if (! phdr_included || p->p_type != PT_LOAD)
d3819 3
a3821 3
	  m->includes_phdrs =
	    (p->p_offset <= (bfd_vma) iehdr->e_phoff
	     && (p->p_offset + p->p_filesz
d3824 2
a3825 1
	  if (p->p_type == PT_LOAD && m->includes_phdrs)
d3829 1
a3829 1
      if (csecs == 0)
d3834 1
a3834 2

	  if (p->p_type == PT_LOAD)
d3839 3
a3841 3
	  m->count = 0;
	  *pm = m;
	  pm = &m->next;
d3874 2
a3875 1
      sections = (asection **) bfd_malloc (sizeof (asection *) * csecs);
a3884 1

d3889 3
a3891 1
      for (j = 0, s = ibfd->sections; s != NULL; s = s->next)
d3893 3
a3895 1
	  os = s->output_section;
d3897 1
a3897 7
	  if ((((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	       || IS_COREFILE_NOTE (p, s))
	      && os != NULL)
	    {
	      sections[j++] = s;
d3902 2
a3903 2
	      if (p->p_paddr == 0
		  && p->p_vaddr != 0
d3905 9
a3913 9
		  && os->lma != 0
		  && (os->vma == (p->p_vaddr
				  + (m->includes_filehdr
				     ? iehdr->e_ehsize
				     : 0)
				  + (m->includes_phdrs
				     ? iehdr->e_phnum * iehdr->e_phentsize
				     : 0))))
		m->p_paddr = p->p_vaddr;
d3917 2
a3918 2
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
d3921 1
a3921 1
		    matching_lma = os->lma;
d3924 1
a3924 1
		     that it does not overlap any other section within that
d3926 1
a3926 1
		  m->sections[isec++] = os;
d3929 1
a3929 1
		suggested_lma = os->lma;
d3933 1
a3933 1
      BFD_ASSERT (j == csecs);
d3937 1
a3937 1
      if (isec == csecs)
d3943 3
a3945 3
	  m->count = csecs;
	  *pm = m;
	  pm = &m->next;
d3957 1
a3957 2

	      m->p_paddr = matching_lma;
d3964 2
d3967 4
a3970 2
	      m->p_paddr = suggested_lma;
	    }
d3972 3
a3974 4
	  /* Offset the segment physical address from the lma to allow
	     for space taken up by elf headers.  */
	  if (m->includes_filehdr)
	    m->p_paddr -= iehdr->e_ehsize;
d3976 8
a3983 2
	  if (m->includes_phdrs)
	    m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
d3996 1
a3996 1
	  m->count = 0;
d4000 1
a4000 1
	  for (j = 0; j < csecs; j++)
d4002 1
a4002 1
	      s = sections[j];
d4004 1
a4004 1
	      if (s == NULL)
d4007 1
a4007 1
	      os = s->output_section;
d4009 4
a4012 2
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
		  || IS_COREFILE_NOTE (p, s))
d4014 1
a4014 1
		  if (m->count == 0)
d4017 8
a4024 7
			 the beginning of the segment, then something is wrong.  */
		      if (os->lma != (m->p_paddr
				      + (m->includes_filehdr
					 ? iehdr->e_ehsize : 0)
				      + (m->includes_phdrs
					 ? iehdr->e_phnum * iehdr->e_phentsize
					 : 0)))
a4029 1
		      bfd_vma maxpagesize;
d4031 1
a4031 2
		      prev_sec = m->sections[m->count - 1];
		      maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
d4034 5
a4038 4
			 and the start of this section is more than maxpagesize
			 then we need to start a new segment.  */
		      if (BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
			  < BFD_ALIGN (os->lma, maxpagesize))
d4041 1
a4041 1
			    suggested_lma = os->lma;
d4047 1
a4047 1
		  m->sections[m->count++] = os;
d4050 1
d4053 1
a4053 1
		suggested_lma = os->lma;
d4056 1
a4056 1
	  BFD_ASSERT (m->count > 0);
d4059 2
a4060 2
	  *pm = m;
	  pm = &m->next;
d4062 1
a4062 1
	  if (isec < csecs)
d4067 6
a4072 6

	      m = ((struct elf_segment_map *)
		   bfd_alloc (obfd,
			      (sizeof (struct elf_segment_map)
			       + ((size_t) csecs - 1) * sizeof (asection *))));
	      if (m == NULL)
d4078 8
a4085 9

	      m->next             = NULL;
	      m->p_type           = p->p_type;
	      m->p_flags          = p->p_flags;
	      m->p_flags_valid    = 1;
	      m->p_paddr          = suggested_lma;
	      m->p_paddr_valid    = 1;
	      m->includes_filehdr = 0;
	      m->includes_phdrs   = 0;
d4088 1
a4088 1
      while (isec < csecs);
d4097 2
a4098 2
  for (m = mfirst; m != NULL; m = m->next)
    if (m->p_paddr != 0)
d4100 1
a4100 1
  if (m == NULL)
d4102 2
a4103 2
      for (m = mfirst; m != NULL; m = m->next)
	m->p_paddr_valid = 0;
d4106 1
a4106 1
  elf_tdata (obfd)->segment_map = mfirst;
d4108 15
d4124 2
a4125 2
  /* Final Step: Sort the segments into ascending order of physical address. */
  if (mfirst != NULL)
d4127 1
a4127 1
      struct elf_segment_map* prev;
d4129 2
a4130 2
      prev = mfirst;
      for (m = mfirst->next; m != NULL; prev = m, m = m->next)
d4132 2
a4133 2
	  /* Yes I know - its a bubble sort....*/
	  if (m->next != NULL && (m->next->p_paddr < m->p_paddr))
d4135 4
a4138 4
	      /* swap m and m->next */
	      prev->next = m->next;
	      m->next = m->next->next;
	      prev->next->next = m;
d4140 2
a4141 2
	      /* restart loop. */
	      m = mfirst;
d4147 4
a4150 1
#undef IS_CONTAINED_BY
d4152 3
a4154 1
#undef IS_COREFILE_NOTE
@


1.45
log
@Improve section to segment mapping code.
@
text
@d984 1
a984 1
_bfd_elf_link_hash_hide_symbol (info, h)
a3621 4
  asection *s;
  bfd_vma maxpagesize;
  struct elf_segment_map * phdr_adjust_seg = NULL;
  unsigned int phdr_adjust_num = 0;
a3635 1
  maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
d3637 4
a3640 18
  /* Returns the end address of the segment + 1.  */
#define SEGMENT_END(segment, start) 			\
  (start + (segment->p_memsz > segment->p_filesz 	\
   ? segment->p_memsz : segment->p_filesz))

  /* Returns true if the given section is contained within
     the given segment.  VMA addresses are compared.  */
#define IS_CONTAINED_BY_VMA(section, segment)		\
  (section->vma >= segment->p_vaddr			\
   && (section->vma + section->_raw_size)		\
   <= (SEGMENT_END (segment, segment->p_vaddr)))
    
  /* Returns true if the given section is contained within
     the given segment.  LMA addresses are compared.  */
#define IS_CONTAINED_BY_LMA(section, segment, base)	\
    (section->lma >= base				\
     && (section->lma + section->_raw_size)		\
     <= SEGMENT_END (segment, base))
d3643 7
a3649 6
#define IS_COREFILE_NOTE(p, s)                          \
	    (p->p_type == PT_NOTE                       \
	     && bfd_get_format (ibfd) == bfd_core       \
	     && s->vma == 0 && s->lma == 0              \
	     && (bfd_vma) s->filepos >= p->p_offset     \
	     && (bfd_vma) s->filepos + s->_raw_size     \
d3655 8
a3662 7
#define IS_SOLARIS_PT_INTERP(p, s)			\
	    (p->p_vaddr == 0				\
	     && p->p_filesz > 0				\
	     && (s->flags & SEC_HAS_CONTENTS) != 0	\
	     && s->_raw_size > 0			\
	     && (bfd_vma) s->filepos >= p->p_offset	\
	     && ((bfd_vma) s->filepos + s->_raw_size	\
a3664 27
  /* Decide if the given section should be included in the given segment.
     A section will be included if:
       1. It is within the address space of the segment,
       2. It is an allocated segment,
       3. There is an output section associated with it,
       4. The section has not already been allocated to a previous segment.  */
#define INCLUDE_SECTION_IN_SEGMENT(section, segment)	\
  ((((IS_CONTAINED_BY_VMA (section, segment) 		\
      || IS_SOLARIS_PT_INTERP (segment, section))	\
     && (section->flags & SEC_ALLOC) != 0)		\
    || IS_COREFILE_NOTE (segment, section))		\
   && section->output_section != NULL			\
   && section->segment_mark == false)

  /* Returns true iff seg1 starts after the end of seg2.  */
#define SEGMENT_AFTER_SEGMENT(seg1, seg2)		\
    (seg1->p_vaddr >= SEGMENT_END (seg2, seg2->p_vaddr))

  /* Returns true iff seg1 and seg2 overlap.  */
#define SEGMENT_OVERLAPS(seg1, seg2)			\
  (!(SEGMENT_AFTER_SEGMENT (seg1, seg2) && SEGMENT_AFTER_SEGMENT (seg2, seg1)))

  
  /* Initialise the segment mark field.  */
  for (s = ibfd->sections; s != NULL; s = s->next)
    s->segment_mark = false;

d3666 1
a3666 58
     of the input BFD.  For this first scan we look for overlaps.
     These can be created by wierd parameters to objcopy.  */
  for (i = 0, p = elf_tdata (ibfd)->phdr; i < num_segments; i ++, p ++)
    {
      unsigned int j;
      Elf_Internal_Phdr * pp;

      if (p->p_type == PT_NULL)
	continue;
      
      /* Determine if this segment overlaps any previous segments.
	 This can happen when objcopy is used to adjust section LMAs.  */
      for (j = 0, pp = elf_tdata (ibfd)->phdr; j < i; j ++, pp ++)
	{
	  bfd_signed_vma extra_length;
	  
	  
	  if (pp->p_type == PT_NULL || ! SEGMENT_OVERLAPS (p, pp))
	    continue;
	  
	  /* Merge the two segments together.  */
	  if (pp->p_vaddr < p->p_vaddr)
	    {
	      /* Extend PP to include P and then delete P.  */
	      extra_length =
		SEGMENT_END (p, p->p_vaddr) - SEGMENT_END (pp, pp->p_vaddr);
	      
	      if (extra_length > 0)
		{
		  pp->p_memsz  += extra_length;
		  pp->p_filesz += extra_length;
		}
	      
	      p->p_type = PT_NULL;
	      
	      /* Since we have deleted P we must restart the outer loop.  */
	      i = 0;
	      p = elf_tdata (ibfd)->phdr;
	      break;
	    }
	  else
	    {
	      /* Extend P to include PP and then delete PP.  */
	      extra_length =
		SEGMENT_END (pp, pp->p_vaddr) - SEGMENT_END (p, p->p_vaddr);
	      
	      if (extra_length > 0)
		{
		  p->p_memsz  += extra_length;
		  p->p_filesz += extra_length;
		}
	      
	      pp->p_type = PT_NULL;
	    }
	}
    }
  
  /* The second scan attempts to assign sections to segments.  */
d3670 1
d3678 5
a3682 4
      if (p->p_type == PT_NULL)
	continue;
      
      /* Compute how many sections might be placed into this segment.  */
d3685 9
a3693 2
	if (INCLUDE_SECTION_IN_SEGMENT (s, p))
	  ++csecs;
d3736 1
d3787 1
d3794 7
a3800 1
	  if (INCLUDE_SECTION_IN_SEGMENT (s, p))
a3801 2
	      os = s->output_section;

d3822 1
a3822 1
	      if (IS_CONTAINED_BY_LMA (os, p, m->p_paddr)
d3829 1
a3829 1
		     then it does not overlap any other section within that
d3862 1
d3870 1
d3874 2
a3875 2
	  /* Offset the segment physical address from the lma
	     to allow for space taken up by elf headers.  */
d3880 1
a3880 11
	    {
	      m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;

	      /* iehdr->e_phnum is just an estimate of the number
		 of program headers that we will need.  Make a note
		 here of the number we used and the segment we chose
		 to hold these headers, so that we can adjust the
		 offset when we know the correct value.  */
	      phdr_adjust_num = iehdr->e_phnum;
	      phdr_adjust_seg = m;
	    }
d3906 1
a3906 3
	      BFD_ASSERT (os != NULL);
	      
	      if (IS_CONTAINED_BY_LMA (os, p, m->p_paddr)
d3924 1
d3927 1
d3932 1
a3932 1
		      if ((BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
a3933 1
			  || ((prev_sec->lma + prev_sec->_raw_size) > os->lma))
a3944 1
		  s->segment_mark = true;
d3961 1
d3972 1
a4002 14
  /* If we had to estimate the number of program headers that were
     going to be needed, then check our estimate know and adjust
     the offset if necessary.  */
  if (phdr_adjust_seg != NULL)
    {
      unsigned int count;
      
      for (count = 0, m = mfirst; m != NULL; m = m->next)
	count ++;

      if (count > phdr_adjust_num)
	phdr_adjust_seg->p_paddr -= (count - phdr_adjust_num) * iehdr->e_phentsize;
    }
  
d4004 1
a4004 1
  /* Final Step: Sort the segments into ascending order of physical address.  */
d4012 1
a4012 1
	  /* Yes I know - its a bubble sort....  */
d4015 1
a4015 1
	      /* swap m and m->next.  */
d4020 1
a4020 1
	      /* restart loop.  */
@


1.44
log
@	* Makefile.am (ALL_MACHINES): Add cpu-cris.lo.
	(ALL_MACHINES_CFILES): Add cpu-cris.c.
	(BFD32_BACKENDS): Add aout-cris.lo and elf32-cris.lo.
	(BFD32_BACKENDS_CFILES): Add aout-cris.c and elf32-cris.c.
	(cpu-cris.lo, aout-cris.lo, elf32-cris.lo): New rules.
	* Makefile.in: Rebuild.
	* aclocal.m4: Rebuild.
	* aoutx.h (NAME(aout,machine_type)): Add case for bfd_arch_cris.
	* archures.c (enum bfd_architecture): Add bfd_arch_cris.
	(bfd_cris_arch): Declare.
	(bfd_archures_list): Add bfd_cris_arch.
	* bfd-in2.h: Rebuild.
	* config.bfd: (cris-*-*): New target.
	* configure.in (bfd_elf32_cris_vec, cris_aout_vec): New vectors.
	* configure: Rebuild.
	* elf.c (prep_headers): Add bfd_arch_cris.
	* libbfd.h: Rebuild.
	* libaout.h (enum machine_type): Add M_CRIS.
	* reloc.c: Add CRIS relocations.
	* targets.c (bfd_target bfd_elf32_cris_vec, cris_aout_vec):
	Declare.
	(bfd_target_vect): Add bfd_elf32_cris_vec and cris_aout_vec.
	* cpu-cris.c, aout-cris.c, elf32-cris.c: New files.
	* po/POTFILES.in, po/bfd.pot: Regenerate.
@
text
@d984 1
a984 1
_bfd_elf_link_hash_hide_symbol(info, h)
d3622 4
d3640 1
d3642 18
a3659 4
#define IS_CONTAINED_BY(addr, len, bottom, phdr)		 	\
	  ((addr) >= (bottom)				 	  	\
	   && (   ((addr) + (len)) <= ((bottom) + (phdr)->p_memsz)	\
	       || ((addr) + (len)) <= ((bottom) + (phdr)->p_filesz)))
d3662 6
a3667 7

#define IS_COREFILE_NOTE(p, s)                                          \
	    (p->p_type == PT_NOTE                                       \
	     && bfd_get_format (ibfd) == bfd_core                       \
	     && s->vma == 0 && s->lma == 0                              \
	     && (bfd_vma) s->filepos >= p->p_offset                     \
	     && (bfd_vma) s->filepos + s->_raw_size                     \
d3673 8
d3682 26
a3707 8
#define IS_SOLARIS_PT_INTERP(p, s)					\
	    (p->p_vaddr == 0						\
	     && p->p_filesz > 0						\
	     && (s->flags & SEC_HAS_CONTENTS) != 0			\
	     && s->_raw_size > 0					\
	     && (bfd_vma) s->filepos >= p->p_offset			\
	     && ((bfd_vma) s->filepos + s->_raw_size			\
		     <= p->p_offset + p->p_filesz))
d3710 58
a3767 1
     of the input BFD.  */
a3770 1
      asection *s;
d3778 4
a3781 5
      /* For each section in the input BFD, decide if it should be
	 included in the current segment.  A section will be included
	 if it is within the address space of the segment, and it is
	 an allocated segment, and there is an output section
	 associated with it.  */
d3784 2
a3785 9
	if (s->output_section != NULL)
	  {
	    if ((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	      ++csecs;
	    else if (IS_COREFILE_NOTE (p, s))
	      ++csecs;
	  }
a3827 1

a3877 1

d3884 3
a3886 1
	  os = s->output_section;
a3887 6
	  if ((((IS_CONTAINED_BY (s->vma, s->_raw_size, p->p_vaddr, p)
		 || IS_SOLARIS_PT_INTERP (p, s))
		&& (s->flags & SEC_ALLOC) != 0)
	       || IS_COREFILE_NOTE (p, s))
	      && os != NULL)
	    {
d3908 1
a3908 1
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
d3915 1
a3915 1
		     that it does not overlap any other section within that
a3947 1

a3954 1

d3958 2
a3959 2
	  /* Offset the segment physical address from the lma to allow
	     for space taken up by elf headers.  */
d3964 11
a3974 1
	    m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
d4000 3
a4002 1
	      if (IS_CONTAINED_BY (os->lma, os->_raw_size, m->p_paddr, p)
a4019 1
		      bfd_vma maxpagesize;
a4021 1
		      maxpagesize = get_elf_backend_data (obfd)->maxpagesize;
d4026 1
a4026 1
		      if (BFD_ALIGN (prev_sec->lma + prev_sec->_raw_size, maxpagesize)
d4028 1
d4040 1
a4056 1

a4066 1

d4097 14
d4112 1
a4112 1
  /* Final Step: Sort the segments into ascending order of physical address. */
d4120 1
a4120 1
	  /* Yes I know - its a bubble sort....*/
d4123 1
a4123 1
	      /* swap m and m->next */
d4128 1
a4128 1
	      /* restart loop. */
@


1.43
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* bfd-in.h (bfd_elf_set_dt_needed_soname): New.
	* bfd-in2.h: Rebuild.

	* elf-bfd.h (elf_obj_tdata): Add dt_soname.
	(elf_dt_soname): New.

	* elf.c (bfd_elf_set_dt_needed_soname): New.

	* elflink.h (elf_link_add_object_symbols): Add the DT_NEEDED
	entry if the shared object loaded by DT_NEEDED is used to
	resolve the reference in a regular object.
@
text
@d3364 3
@


1.42
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_CONFIG,
	DT_DEPAUDIT and DT_AUDIT as strings.
@
text
@d1053 10
@


1.41
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_print_private_bfd_data): Fix DT_CHECKSUM.
@
text
@d677 3
a679 3
	    case DT_CONFIG: name = "CONFIG"; break;
	    case DT_DEPAUDIT: name = "DEPAUDIT"; break;
	    case DT_AUDIT: name = "AUDIT"; break;
@


1.40
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_BIND_NOW,
	DT_INIT_ARRAY, DT_FINI_ARRAY, DT_INIT_ARRAYSZ, DT_FINI_ARRAYSZ,
	DT_RUNPATH, DT_FLAGS, DT_PREINIT_ARRAY, DT_PREINIT_ARRAYSZ,
	DT_PLTPADSZ, DT_MOVEENT, DT_MOVESZ, DT_FEATURE, DT_POSFLAG_1,
	DT_SYMINSZ, DT_SYMINENT, DT_CONFIG, DT_DEPAUDIT, DT_AUDIT,
	DT_PLTPAD, DT_MOVETAB, DT_SYMINFO, DT_RELACOUNT, DT_RELCOUNT,
	DT_FLAGS_1, DT_USED and DT_CHECKSUM.
@
text
@d669 1
a693 3
#if DT_CHECKSUM != 0
	    case DT_CHECKSUM: name = "CHECKSUM"; break;
#endif
@


1.39
log
@Rename bfd_elf_get_arch_size  to bfd_get_arch_size
Rename bfd_elf_get_sign_extend_vma  to  bfd_get_sign_extend_vma
@
text
@d660 25
a684 2
	    case DT_AUXILIARY: name = "AUXILIARY"; stringp = true; break;
	    case DT_FILTER: name = "FILTER"; stringp = true; break;
d690 6
@


1.38
log
@Add function bfd_elf_get_sign_extend_vma.
@
text
@a1763 30
/* Get elf arch size (32 / 64).
   Returns -1 if not elf.  */

int
bfd_elf_get_arch_size (abfd)
     bfd *abfd;
{
  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return (get_elf_backend_data (abfd))->s->arch_size;
}

/* True if addresses "naturally" sign extend.  Return 0/1 if known.
   -1 if unknown. */
int
bfd_elf_get_sign_extend_vma (abfd)
     bfd *abfd;
{
  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }
  return (get_elf_backend_data (abfd)->sign_extend_vma);
}

d1910 1
a1910 1
		    4 + 2 * bfd_elf_get_arch_size (abfd) / 8;
d3240 1
a3240 1
      if (bfd_elf_get_arch_size (abfd) == 64)
@


1.37
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d1780 14
@


1.36
log
@2000-06-18  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* elf_bfd.h (struct elf_backend_data): Add info argument to
	elf_backend_hide_symbol.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_hide_symbol): Likewise.
	* elf64-ia64.c (elf64_ia64_hash_hide_symbol): Likewise.
	* elflink.h (elf_link_add_object_symbols): Likewise.
	(elf_link_assign_sym_version): Likewise.
@
text
@d1336 4
a1339 2
	   try.  We just present it as a normal section.  */
	if (hdr->sh_link != elf_onesymtab (abfd))
d3269 6
@


1.35
log
@2000-06-06  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * elf.c (elf_grok_pr_status): Eliminate reference to prgregset_t.
@
text
@d957 2
a958 1
_bfd_elf_link_hash_hide_symbol(h)
@


1.34
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * elf.c (elfcore_grok_prstatus, elfcore_grok_pstatus,
        elfcore_grok_psinfo): Add code to allow debugging a 32-bit
        corefile on a 64-bit (Sparc Solaris) host.  Also clean up
        a few old comments.
@
text
@d5130 1
d5136 1
d5158 1
d5196 1
a5196 1
      sect->_raw_size = sizeof (prgregset_t);
d5202 1
a5202 1
      sect->_raw_size = sizeof (prgregset32_t);
@


1.33
log
@(_bfd_elf_slurp_version_tables): Correct reading of version
definitions.  We must not assume they are sorted in the file
according to their index numbers.
@
text
@d34 4
d2925 4
a2928 2
	      if (i == 0)	/* the actual "note" segment */
		{		/* this one actually contains everything. */
d2934 1
a2934 1
	      else	/* fake sections -- don't need to be written */
d2936 1
d2939 1
a2939 1
		  flags = sec->flags = 0;	/* no contents */
d5116 1
a5116 1
     solaris 2.[567]
a5126 1
  prstatus_t prstat;
d5131 3
a5133 2
  if (note->descsz != sizeof (prstat))
    return true;
d5135 1
a5135 1
  memcpy (&prstat, note->descdata, sizeof (prstat));
d5137 2
a5138 2
  elf_tdata (abfd)->core_signal = prstat.pr_cursig;
  elf_tdata (abfd)->core_pid = prstat.pr_pid;
d5140 6
a5145 6
  /* pr_who exists on:
       solaris 2.[567]
       unixware 4.2
     pr_who doesn't exist on:
       linux 2.[01]
  */
d5147 1
a5147 1
  elf_tdata (abfd)->core_lwpid = prstat.pr_who;
d5149 29
d5190 14
a5203 2
  sect->_raw_size = sizeof (prstat.pr_reg);
  sect->filepos = note->descpos + offsetof (prstatus_t, pr_reg);
d5281 4
a5284 1
# define elfcore_psinfo_t prpsinfo_t
d5288 4
a5291 1
# define elfcore_psinfo_t psinfo_t
d5331 8
a5338 1
  elfcore_psinfo_t psinfo;
d5340 10
a5349 2
  if (note->descsz != sizeof (elfcore_psinfo_t))
    return true;
d5351 2
a5352 1
  memcpy (&psinfo, note->descdata, note->descsz);
d5354 4
a5357 2
  elf_tdata (abfd)->core_program
    = elfcore_strndup (abfd, psinfo.pr_fname, sizeof (psinfo.pr_fname));
d5359 6
a5364 2
  elf_tdata (abfd)->core_command
    = elfcore_strndup (abfd, psinfo.pr_psargs, sizeof (psinfo.pr_psargs));
d5389 3
a5391 1
  pstatus_t pstat;
d5393 1
a5393 2
  if (note->descsz != sizeof (pstat))
    return true;
d5395 7
a5401 1
  memcpy (&pstat, note->descdata, sizeof (pstat));
d5403 1
a5403 1
  elf_tdata (abfd)->core_pid = pstat.pr_pid;
d5405 3
@


1.32
log
@(_bfd_elf_link_hash_table_init): Initialize dynlocal.
@
text
@d4509 2
d4512 1
a4515 8
      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, hdr->sh_info * sizeof (Elf_Internal_Verdef)));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = hdr->sh_info;

d4523 24
d4548 2
a4549 2
      iverdef = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++, iverdef++)
d4555 4
a4558 1
	  _bfd_elf_swap_verdef_in (abfd, everdef, iverdef);
@


1.31
log
@Fix some nits shown up by objcopy.
@
text
@d980 1
@


1.30
log
@2000-05-04  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * elf.c (bfd_elf_get_arch_size): New function, return 32 | 64 | -1.
        * bfd-in.h: Prototype bfd_elf_get_arch_size.
        * bfd-in2.h: Prototype bfd_elf_get_arch_size.
@
text
@d1357 3
a1359 2
	elf_section_data (target_sect)->use_rela_p 
	  = (hdr->sh_type == SHT_RELA);
d3748 1
a3748 1
      matching_lma = false;
d3814 1
a3814 1
      else if (matching_lma != 0)
d3816 13
a3828 3
	  /* At least one section fits inside the current segment.
	     Keep it, but modify its physical address to match the
	     LMA of the first section that fitted.  */
d3830 7
a3836 7
	  m->p_paddr = matching_lma;
	}
      else
	{
	  /* None of the sections fitted inside the current segment.
	     Change the current segment's physical address to match
	     the LMA of the first section.  */
d3838 2
a3839 1
	  m->p_paddr = suggested_lma;
d3872 6
a3877 1
		      if (os->lma != m->p_paddr)
@


1.29
log
@2000-05-02  H.J. Lu  <hjl@@gnu.org>

	* elf.c (prep_headers): USe ELFOSABI_NONE instead of
	ELFOSABI_SYSV.
@
text
@d1755 16
a1782 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
d1917 1
a1917 1
		    4 + 2 * (bed->s->arch_size / 8);
d3244 1
a3244 1
      if (bed->s->arch_size == 64)
@


1.28
log
@IA-64 ELF support.
@
text
@d3208 1
a3208 1
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_SYSV;
@


1.27
log
@ATMEL AVR microcontroller support.
@
text
@d3240 3
@


1.27.2.1
log
@Fix some nits shown up by objcopy.
@
text
@d1357 2
a1358 3
	if (hdr->sh_size != 0)
	  elf_section_data (target_sect)->use_rela_p
	    = (hdr->sh_type == SHT_RELA);
d3729 1
a3729 1
      matching_lma = 0;
d3795 8
d3805 3
a3807 21
	  if (matching_lma != 0)
	    {
	      /* At least one section fits inside the current segment.
		 Keep it, but modify its physical address to match the
		 LMA of the first section that fitted.  */

	      m->p_paddr = matching_lma;
	    }
	  else
	    {
	      /* None of the sections fitted inside the current segment.
		 Change the current segment's physical address to match
		 the LMA of the first section.  */

	      m->p_paddr = suggested_lma;
	    }

	  /* Offset the segment physical address from the lma to allow
	     for space taken up by elf headers.  */
	  if (m->includes_filehdr)
	    m->p_paddr -= iehdr->e_ehsize;
d3809 1
a3809 2
	  if (m->includes_phdrs)
	    m->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;
d3842 1
a3842 6
		      if (os->lma != (m->p_paddr
				      + (m->includes_filehdr
					 ? iehdr->e_ehsize : 0)
				      + (m->includes_phdrs
					 ? iehdr->e_phnum * iehdr->e_phentsize
					 : 0)))
@


1.27.2.2
log
@H.J.'s ELFOSABI changes.
@
text
@d3209 1
a3209 1
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_NONE;
@


1.27.2.3
log
@(_bfd_elf_link_hash_table_init): Initialize dynlocal.
@
text
@a979 1
  table->dynlocal = NULL;
@


1.27.2.4
log
@2000-09-06  Philip Blundell  <philb@@gnu.org>

	Merge from mainline:

	2000-05-31  Ulrich Drepper  <drepper@@redhat.com>

	* elf.c (_bfd_elf_slurp_version_tables): Correct reading of version
	definitions.  We must not assume they are sorted in the file
	according to their index numbers.
@
text
@a4490 2
      Elf_Internal_Verdef *iverdefarr;
      Elf_Internal_Verdef iverdefmem;
a4491 1
      unsigned int maxidx;
d4495 8
a4509 24
      /* We know the number of entries in the section but not the maximum
	 index.  Therefore we have to run through all entries and find
	 the maximum.  */
      everdef = (Elf_External_Verdef *) contents;
      maxidx = 0;
      for (i = 0; i < hdr->sh_info; ++i)
	{
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  if ((iverdefmem.vd_ndx & VERSYM_VERSION) > maxidx)
	    maxidx = iverdefmem.vd_ndx & VERSYM_VERSION;

	  everdef = ((Elf_External_Verdef *)
		     ((bfd_byte *) everdef + iverdefmem.vd_next));
	}

      elf_tdata (abfd)->verdef =
	((Elf_Internal_Verdef *)
	 bfd_zalloc (abfd, maxidx * sizeof (Elf_Internal_Verdef)));
      if (elf_tdata (abfd)->verdef == NULL)
	goto error_return;

      elf_tdata (abfd)->cverdefs = maxidx;

d4511 2
a4512 2
      iverdefarr = elf_tdata (abfd)->verdef;
      for (i = 0; i < hdr->sh_info; i++)
d4518 1
a4518 4
	  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

	  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];
	  memcpy (iverdef, &iverdefmem, sizeof (Elf_Internal_Verdef));
@


1.26
log
@        * elf.c (swap_out_syms):  Check for null type_ptr.
@
text
@d3279 3
@


1.25
log
@Add IBM 370 support.
@
text
@d4227 2
a4228 1
        if (bed->elf_backend_get_symbol_type)
@


1.24
log
@        * elf-bfd.h (struct elf_link_hash_table): Remove copy_indirect
        and hide_symbol members.
        (elf_link_hash_copy_indirect): Remove.
        (elf_link_hash_hide_symbol): Remove.
        (struct elf_backend_data): Add elf_backend_copy_indirect_symbol
        and elf_backend_hide_symbol.
        (_bfd_elf_link_hash_copy_indirect): Declare.
        (_bfd_elf_link_hash_hide_symbol): Declare.
        * elf.c (_bfd_elf_link_hash_copy_indirect): Remove table argument.
        (_bfd_elf_link_hash_hide_symbol): Likewise.
        (_bfd_elf_link_hash_table_init): Don't init killed members.
        * elflink.h (elf_link_add_object_symbols): Use the bed function
        pointers not elf_link_hash_{copy_indirect,hide_symbol}.
        (elf_link_assign_sym_version): Likewise.
        * elfxx-target.h (elf_backend_copy_indirect_symbol): Default.
        (elf_backend_hide_symbol): Likewise.
        (elfNN_bed): Update for new members.
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d3233 3
@


1.23
log
@        * elf-bfd.h (struct elf_link_hash_table): Add copy_indirect and
        hide_symbol members.
        (elf_link_hash_copy_indirect): New.
        (elf_link_hash_hide_symbol): New.
        * elflink.h (elf_link_add_object_symbols): Break out copy from
        indirect new new symbol to elf.c.
        (elf_link_assign_sym_version): Break out privatization of
        non-exported symbol to elf.c.
        * elf.c (_bfd_elf_link_hash_copy_indirect): New.
        (_bfd_elf_link_hash_hide_symbol): New.
        (_bfd_elf_link_hash_table_init): Init copy_indirect and hide_symbol.
@
text
@d912 2
a913 3
static void
_bfd_elf_link_hash_copy_indirect (table, dir, ind)
     struct elf_link_hash_table *table;
d952 2
a953 3
static void
_bfd_elf_link_hash_hide_symbol(table, h)
     struct elf_link_hash_table *table;
a979 2
  table->copy_indirect = _bfd_elf_link_hash_copy_indirect;
  table->hide_symbol = _bfd_elf_link_hash_hide_symbol;
@


1.22
log
@Apply patch from Egor Duda to process win32_pstatus notes in core dumps.
@
text
@d909 54
d982 2
@


1.21
log
@ELF visibility patch from Martin Loewis.
@
text
@d5295 73
d5369 3
d5401 6
a5406 1
    case NT_PRXFPREG:		/* Linux SSE extension */
@


1.20
log
@Add support for SSE registers in ELF core files.
* elf.c (elfcore_make_note_pseudosection): New function.
(elfcore_grok_prfpreg): Use it.
(elfcore_grok_prxfpreg): New function.
(elfcore_grok_note): Recognize Linux NT_PRXFPREG notes.
@
text
@d764 1
d840 13
a852 4
	if (((elf_symbol_type *) symbol)->internal_elf_sym.st_other != 0)
	  fprintf (file, " 0x%02x",
		   ((unsigned int)
		    ((elf_symbol_type *) symbol)->internal_elf_sym.st_other));
@


1.19
log
@* elf.c (bfd_get_elf_phdrs, bfd_get_elf_phdr_upper_bound): New
functions.
* bfd-in2.h (bfd_get_elf_phdrs, bfd_get_elf_phdr_upper_bound): New
declarations.
@
text
@d5040 7
a5046 3
/* There isn't a consistent prfpregset_t across platforms,
   but it doesn't matter, because we don't have to pick this
   data structure apart. */
d5049 1
a5049 1
elfcore_grok_prfpreg (abfd, note)
d5051 1
d5055 1
a5055 1
  char* name;
d5058 1
a5058 1
  /* Make a ".reg2/999" section. */
d5060 3
a5062 3
  sprintf (buf, ".reg2/%d", elfcore_make_pid (abfd));
  name = bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
d5064 1
a5064 1
  strcpy (name, buf);
d5066 1
a5066 1
  sect = bfd_make_section (abfd, name);
d5074 1
a5074 1
  if (! elfcore_maybe_make_sect (abfd, ".reg2", sect))
d5080 25
d5314 7
@


1.18
log
@Add support for target specific processing of ELF segments
@
text
@d5362 48
@


1.17
log
@Fred Fish  <fnf@@cygnus.com>

        * elf.c (bfd_section_from_phdr): Add typename variable.  Use p_type
        to initialize it to something meaningful.  Then use it to generate
        more useful segment names.
@
text
@d56 1
d1391 1
a1391 1
bfd_section_from_phdr (abfd, hdr, index)
d1395 1
a1398 1
  char *typename;
a1404 11
  switch (hdr->p_type)
    {
    case PT_NULL: typename = "null"; break;
    case PT_LOAD: typename = "load"; break;
    case PT_DYNAMIC: typename = "dynamic"; break;
    case PT_INTERP: typename = "interp"; break;
    case PT_NOTE: typename = "note"; break;
    case PT_SHLIB: typename = "shlib"; break;
    case PT_PHDR: typename = "phdr"; break;
    default: typename = "segment"; break;
    }
d1460 46
d5347 2
a5356 4
    return false;

  if (phdr->p_type == PT_NOTE
      && ! elfcore_read_notes (abfd, phdr->p_offset, phdr->p_filesz))
@


1.16
log
@1999-09-04  Steve Chamberlain  <sac@@pobox.com>

	* cpu-pj.c: New file.
	* elf32-pj.c: New file.
	* config.bfd (pj*): New cpu.
	(pj-*-*, pjl-*-*): New targets.
	* configure.in (bfd_elf32_pj_vec): New target vector.
	(bfd_elf32_pjl_vec): New target vector.
 	* archures.c (bfd_arch_pj): Define.
	* elf.c (prep_headers): Handle bfd_arch_pj.
	* reloc.c: Define BFD_RELOC_PJ_* relocations.
	* targets.c (bfd_elf32_pj_vec, bfd_elf32_pjl_vec): Declare and add
	to target vector list.
	* Makefile.am: Rebuild dependencies.
	(ALL_MACHINES): Add cpu-pj.lo.
	(ALL_MACHINES_CFILES): Add cpu-pj.c.
	(BFD32_BACKENDS): Add elf32-pj.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-pj.c.
	* configure, Makefile.in, bfd-in2.h, libbfd.h: Rebuild.
@
text
@d1397 1
d1404 12
a1415 1
  sprintf (namebuf, split ? "segment%da" : "segment%d", index);
d1446 1
a1446 1
      sprintf (namebuf, "segment%db", index);
@


1.15
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * elf-bfd.h (struct elf_backend_data): Add
        print_symbol_all and output_arch_syms backend methods.
        * elfxx-target.h: Likewise.
        * elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create,
        sparc64_elf_add_symbol_hook, sparc64_elf_output_arch_syms,
        sparc64_elf_get_symbol_type, sparc64_elf_symbol_processing): New
        functions.
        (sparc64_elf_size_dynamic_sections): Leave space for STT_REGISTER
        symbols in .dynsym, add their names into .dynstr. Put those symbols
        into dynlocal.
        (sparc64_elf_finish_dynamic_sections): Fix up DT_SPARC_REGISTER
        pointers to STT_REGISTER symbols in dynsym section.
        (sparc64_elf_print_symbol_all): New function.
        * elf.c (bfd_elf_print_symbol): Allow special backend symbol
        printing using the print_symbol_all hook.
@
text
@d3188 3
@


1.14
log
@        * elf.c (assign_file_positions_for_segments): Thinko last change.
        Always overwrite p_flags.
@
text
@d761 3
d765 11
a775 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
d843 1
a843 1
	fprintf (file, " %s", symbol->name);
@


1.13
log
@* elf.c (assign_file_positions_for_segments): Don't overwrite p_flags.
@
text
@d2561 1
a2561 3

      if (m->p_flags_valid)
	p->p_flags |= m->p_flags;
@


1.12
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d2563 1
a2563 3
	p->p_flags = m->p_flags;
      else
	p->p_flags = 0;
@


1.11
log
@	* elf.c (bfd_elf_hash): Change parameter from unsigned char * to
	char *.
	* elf-bfd.h (bfd_elf_hash): Update declaration.
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Remove casts
	when calling bfd_elf_hash.
@
text
@d508 1
a508 1
     bfd *abfd;
d511 1
a511 1
     PTR data;
d514 1
a514 1
     char **error_message;
d949 1
a949 1
     bfd *abfd;
d4196 1
a4196 1
     bfd *abfd;
d4527 1
a4527 1
     bfd *ignore_abfd;
d4540 1
a4540 1
     bfd *abfd;
d4566 2
a4567 2
     bfd *ignore_abfd;
     asymbol *symbol;
d4717 3
a4719 3
     bfd *abfd;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d4853 7
a4859 7
     bfd *abfd;
     arelent *re;
     struct symbol_cache_entry *symbol;
     PTR data;
     asection *is;
     bfd *obfd;
     char **errmsg;
@


1.10
log
@	* elflink.h (elf_link_create_dynamic_sections): Handle non-standard
	hash-entry sizes.
	(size_dynamic_sections): Likewise.
	(elf_link_output_extsym): Likewise.
	* elf.c: (elf_fake_sections): Likewise.
	* libbfd.c (bfd_get): New macro.
	(bfd_put): Likewise.
	* bfd-in2.h: Regenerated.
	* elf-bfd.h (elf_size_info): Add hash_entry_size,
	int_rels_per_ext_rel, swap_dyn_out, swap_reloc_in, swap_reloc_out,
	wap_reloca_in, and swap_reloca_out.
	* elflink.h (elf_link_read_relocs_from_section): Adjust to handle
	multiple internal relocations per external relocation.
	(link_read_relocs): Likewise.
	(elf_bfd_final_link): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	* elfcode.h (elf_swap_dyn_out): Adjust type to match
	elf_swap_dyn_in.
	(size_info): Add entries for new fields.
	* elf64-mips.c (mips_elf64_swap_reloc_out): Enable.
	(mips_elf64_be_swap_reloc_in): New function.
	(mips_elf64_be_swap_reloc_out): Likewise.
	(mips_elf64_be_swap_reloca_in): Likewise.
	(mips_elf64_be_swap_reloca_out): Likewise.
	(mips_elf64_size_info): Add entries for new fields.
@
text
@d203 1
d205 2
a206 2
bfd_elf_hash (name)
     CONST unsigned char *name;
d208 1
@


1.9
log
@	* dwarf2.c (parse_comp_unit): Add ABBREV_LENGTH parameter.
	(_bfd_dwarf2_find_nearest_line): Add ADDR_SIZE parameter.
	* elf.c (_bfd_elf_find_nearest_line): Pass it.
	* elf32-arm.h (elf32_arm_find_nearest_line): Likewise.
	* elf32-mips.c (ABI_64_P): New macro.
	(IRIX_COMPAT): We are IRIX6-compatible if ABI_64_P.
	(_bfd_mips_elf_find_nearest_line): Adjust call to
	_bfd_dwarf2_find_nearest_line.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Update prototype.
	* libbfd.h: Regenerated.
@
text
@d1535 1
a1535 1
      this_hdr->sh_entsize = bed->s->arch_size / 8;
@


1.8
log
@	* elf-bfd.h (bfd_elf_section_data): Add rel_count and rel_count2
	fields.
	(_bfd_elf_init_reloc_shdr): New function.
	* elf.c (_bfd_elf_new_section_hook): Use bfd_zalloc, rather than
	bfd_alloc followed by memset.
	(_bfd_elf_init_reloc_shdr): New function, split out from ...
	(elf_fake_sections): Here.
	(assign_section_numbers): Assign section numbers for the second
	relocation section, if required.
	* elflink.h (elf_link_output_relocs): New function.
	(elf_link_size_reloc_section): Likewise.
	(elf_bfd_final_link): Use elf_link_size_reloc_section.
	(elf_link_input_bfd): Use elf_link_output_relocs.
	* elf32-mips.c (_bfd_mips_elf_fake_sections): Use
	_bfd_elf_init_reloc_shdr to initialize rel_hdr2.
@
text
@d4619 1
a4619 1
				     line_ptr))
@


1.7
log
@	* elf.c (bfd_section_from_shdr): Avoid crashing on a bogus sh_link
	field.
@
text
@d1340 1
a1340 1
  sdata = (struct bfd_elf_section_data *) bfd_alloc (abfd, sizeof (*sdata));
a1343 1
  memset (sdata, 0, sizeof (*sdata));
d1443 37
d1619 9
a1627 33
     SHT_REL[A] section.  */
  if ((asect->flags & SEC_RELOC) != 0)
    {
      Elf_Internal_Shdr *rela_hdr;
      int use_rela_p = elf_section_data (asect)->use_rela_p;
      char *name;

      rela_hdr = &elf_section_data (asect)->rel_hdr;
      name = bfd_alloc (abfd, sizeof ".rela" + strlen (asect->name));
      if (name == NULL)
	{
	  *failedptr = true;
	  return;
	}
      sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", asect->name);
      rela_hdr->sh_name =
	(unsigned int) _bfd_stringtab_add (elf_shstrtab (abfd), name,
					   true, false);
      if (rela_hdr->sh_name == (unsigned int) -1)
	{
	  *failedptr = true;
	  return;
	}
      rela_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
      rela_hdr->sh_entsize = (use_rela_p
			      ? bed->s->sizeof_rela
			      : bed->s->sizeof_rel);
      rela_hdr->sh_addralign = bed->s->file_align;
      rela_hdr->sh_flags = 0;
      rela_hdr->sh_addr = 0;
      rela_hdr->sh_size = 0;
      rela_hdr->sh_offset = 0;
    }
d1655 5
d1708 2
d1720 5
@


1.6
log
@	* elf.c (elf_fake_sections): Undo change of 1999-05-10.
@
text
@d1204 9
@


1.5
log
@	* elf-bfd.h (elf_backend_data): Remove use_rela_p.  Add
	may_use_rel_p, may_use_rela_p, default_use_rela_p.
	(bfd_elf_section_data): Add use_rela_p.
	* elf.c (bfd_section_from_shdr): Set use_rela_p appropriately.
	(_bfd_elf_new_section_hook): Likewise.
	(elf_fake_sections): Use may_use_rela_p, etc., instead of
	use_rela_p.
	(_bfd_elf_copy_private_section_data): Copy use_rela_p.
	* elfcode.h (write_relocs): Determine whether or not use rela
	relocs based on the relocation section header.
	* elflink.c (_bfd_elf_create_dynamic_sections): Use default_use_rela_p
	instead of use_rela_p.
	* elfxx-target.h (elf_backend_may_use_relp): New macro.
	(elf_backend_may_use_rela_p): Likewise.
	(elf_backend_default_use_rela_p): Likewise.
	(elfNN_bed): Use them.
@
text
@d1502 1
a1502 1
  else if (strncmp (asect->name, ".rela.", 6) == 0
d1508 1
a1508 1
  else if (strncmp (asect->name, ".rel.", 5) == 0
@


1.4
log
@Initialise EI_OSABI and EI_ABIVERSION fields of e_ident array.
Add ability for backends to process program and section headers after they
have been created.
@
text
@d1268 4
d1336 5
d1503 1
a1503 1
	   && get_elf_backend_data (abfd)->use_rela_p)
d1509 1
a1509 1
	   && ! get_elf_backend_data (abfd)->use_rela_p)
d1570 2
a1571 6
  {
    struct elf_backend_data *bed = get_elf_backend_data (abfd);

    if (bed->elf_backend_fake_sections)
      (*bed->elf_backend_fake_sections) (abfd, this_hdr, asect);
  }
d1578 1
a1578 1
      int use_rela_p = get_elf_backend_data (abfd)->use_rela_p;
d3844 3
@


1.3
log
@1999-05-28  Martin Dorey  <mdorey@@madge.com>
	* elf32-i960.c: New file.
	* elf.c (prep_headers): Handle bfd_arch_i960.
	* targets.c (bfd_target_vector): Add &bfd_elf32_i960_vec.
	* config.bfd (i960-*-elf*): New target.
	* configure.in (bfd_elf32_i960_vec): New target vector.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i960.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i960.c.
	* Makefile.in, aclocal.m4, configure: Rebuild.
@
text
@d2014 4
d3048 3
@


1.2
log
@Check for period after .rel{a} when detecting reloc sections.
@
text
@d3080 3
@


1.1
log
@Initial revision
@
text
@d1493 1
a1493 1
  else if (strncmp (asect->name, ".rela", 5) == 0
d1499 1
a1499 1
  else if (strncmp (asect->name, ".rel", 4) == 0
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

