head	1.111;
access;
symbols
	sid-snapshot-20180601:1.111
	sid-snapshot-20180501:1.111
	sid-snapshot-20180401:1.111
	sid-snapshot-20180301:1.111
	sid-snapshot-20180201:1.111
	sid-snapshot-20180101:1.111
	sid-snapshot-20171201:1.111
	sid-snapshot-20171101:1.111
	sid-snapshot-20171001:1.111
	sid-snapshot-20170901:1.111
	sid-snapshot-20170801:1.111
	sid-snapshot-20170701:1.111
	sid-snapshot-20170601:1.111
	sid-snapshot-20170501:1.111
	sid-snapshot-20170401:1.111
	sid-snapshot-20170301:1.111
	sid-snapshot-20170201:1.111
	sid-snapshot-20170101:1.111
	sid-snapshot-20161201:1.111
	sid-snapshot-20161101:1.111
	sid-snapshot-20160901:1.111
	sid-snapshot-20160801:1.111
	sid-snapshot-20160701:1.111
	sid-snapshot-20160601:1.111
	sid-snapshot-20160501:1.111
	sid-snapshot-20160401:1.111
	sid-snapshot-20160301:1.111
	sid-snapshot-20160201:1.111
	sid-snapshot-20160101:1.111
	sid-snapshot-20151201:1.111
	sid-snapshot-20151101:1.111
	sid-snapshot-20151001:1.111
	sid-snapshot-20150901:1.111
	sid-snapshot-20150801:1.111
	sid-snapshot-20150701:1.111
	sid-snapshot-20150601:1.111
	sid-snapshot-20150501:1.111
	sid-snapshot-20150401:1.111
	sid-snapshot-20150301:1.111
	sid-snapshot-20150201:1.111
	sid-snapshot-20150101:1.111
	sid-snapshot-20141201:1.111
	sid-snapshot-20141101:1.111
	sid-snapshot-20141001:1.111
	sid-snapshot-20140901:1.111
	sid-snapshot-20140801:1.111
	sid-snapshot-20140701:1.111
	sid-snapshot-20140601:1.111
	sid-snapshot-20140501:1.111
	sid-snapshot-20140401:1.111
	sid-snapshot-20140301:1.111
	sid-snapshot-20140201:1.111
	sid-snapshot-20140101:1.111
	sid-snapshot-20131201:1.111
	sid-snapshot-20131101:1.111
	sid-snapshot-20131001:1.111
	binutils-2_24-branch:1.111.0.2
	binutils-2_24-branchpoint:1.111
	binutils-2_21_1:1.98
	sid-snapshot-20130901:1.111
	gdb_7_6_1-2013-08-30-release:1.108
	sid-snapshot-20130801:1.111
	sid-snapshot-20130701:1.111
	sid-snapshot-20130601:1.111
	sid-snapshot-20130501:1.108
	gdb_7_6-2013-04-26-release:1.108
	sid-snapshot-20130401:1.108
	binutils-2_23_2:1.104.4.1
	gdb_7_6-branch:1.108.0.2
	gdb_7_6-2013-03-12-branchpoint:1.108
	sid-snapshot-20130301:1.108
	sid-snapshot-20130201:1.106
	sid-snapshot-20130101:1.106
	sid-snapshot-20121201:1.105
	gdb_7_5_1-2012-11-29-release:1.104
	binutils-2_23_1:1.104.4.1
	sid-snapshot-20121101:1.105
	binutils-2_23:1.104.4.1
	sid-snapshot-20121001:1.105
	sid-snapshot-20120901:1.105
	gdb_7_5-2012-08-17-release:1.104
	sid-snapshot-20120801:1.104
	binutils-2_23-branch:1.104.0.4
	binutils-2_23-branchpoint:1.104
	gdb_7_5-branch:1.104.0.2
	gdb_7_5-2012-07-18-branchpoint:1.104
	sid-snapshot-20120701:1.104
	sid-snapshot-20120601:1.104
	sid-snapshot-20120501:1.102
	binutils-2_22_branch:1.100.0.4
	gdb_7_4_1-2012-04-26-release:1.101
	sid-snapshot-20120401:1.102
	sid-snapshot-20120301:1.102
	sid-snapshot-20120201:1.102
	gdb_7_4-2012-01-24-release:1.101
	sid-snapshot-20120101:1.102
	gdb_7_4-branch:1.101.0.2
	gdb_7_4-2011-12-13-branchpoint:1.101
	sid-snapshot-20111201:1.101
	binutils-2_22:1.100
	sid-snapshot-20111101:1.100
	sid-snapshot-20111001:1.100
	binutils-2_22-branch:1.100.0.2
	binutils-2_22-branchpoint:1.100
	gdb_7_3_1-2011-09-04-release:1.99
	sid-snapshot-20110901:1.100
	sid-snapshot-20110801:1.100
	gdb_7_3-2011-07-26-release:1.99
	sid-snapshot-20110701:1.99
	sid-snapshot-20110601:1.99
	sid-snapshot-20110501:1.99
	gdb_7_3-branch:1.99.0.2
	gdb_7_3-2011-04-01-branchpoint:1.99
	sid-snapshot-20110401:1.99
	sid-snapshot-20110301:1.99
	sid-snapshot-20110201:1.99
	sid-snapshot-20110101:1.99
	binutils-2_21:1.98
	sid-snapshot-20101201:1.98
	binutils-2_21-branch:1.98.0.2
	binutils-2_21-branchpoint:1.98
	sid-snapshot-20101101:1.98
	sid-snapshot-20101001:1.97
	binutils-2_20_1:1.91
	gdb_7_2-2010-09-02-release:1.93
	sid-snapshot-20100901:1.96
	sid-snapshot-20100801:1.94
	gdb_7_2-branch:1.93.0.2
	gdb_7_2-2010-07-07-branchpoint:1.93
	sid-snapshot-20100701:1.93
	sid-snapshot-20100601:1.93
	sid-snapshot-20100501:1.93
	sid-snapshot-20100401:1.93
	gdb_7_1-2010-03-18-release:1.92
	sid-snapshot-20100301:1.92
	gdb_7_1-branch:1.92.0.2
	gdb_7_1-2010-02-18-branchpoint:1.92
	sid-snapshot-20100201:1.92
	sid-snapshot-20100101:1.91
	gdb_7_0_1-2009-12-22-release:1.91
	sid-snapshot-20091201:1.91
	sid-snapshot-20091101:1.91
	binutils-2_20:1.91
	gdb_7_0-2009-10-06-release:1.91
	sid-snapshot-20091001:1.91
	gdb_7_0-branch:1.91.0.4
	gdb_7_0-2009-09-16-branchpoint:1.91
	arc-sim-20090309:1.84
	binutils-arc-20081103-branch:1.89.0.16
	binutils-arc-20081103-branchpoint:1.89
	binutils-2_20-branch:1.91.0.2
	binutils-2_20-branchpoint:1.91
	sid-snapshot-20090901:1.89
	sid-snapshot-20090801:1.89
	msnyder-checkpoint-072509-branch:1.89.0.14
	msnyder-checkpoint-072509-branchpoint:1.89
	sid-snapshot-20090701:1.89
	dje-cgen-play1-branch:1.89.0.12
	dje-cgen-play1-branchpoint:1.89
	sid-snapshot-20090601:1.89
	sid-snapshot-20090501:1.89
	sid-snapshot-20090401:1.89
	arc-20081103-branch:1.89.0.10
	arc-20081103-branchpoint:1.89
	arc-insight_6_8-branch:1.84.0.8
	arc-insight_6_8-branchpoint:1.84
	insight_6_8-branch:1.84.0.6
	insight_6_8-branchpoint:1.84
	sid-snapshot-20090301:1.89
	binutils-2_19_1:1.89
	sid-snapshot-20090201:1.89
	sid-snapshot-20090101:1.89
	reverse-20081226-branch:1.89.0.8
	reverse-20081226-branchpoint:1.89
	sid-snapshot-20081201:1.89
	multiprocess-20081120-branch:1.89.0.6
	multiprocess-20081120-branchpoint:1.89
	sid-snapshot-20081101:1.89
	binutils-2_19:1.89
	sid-snapshot-20081001:1.89
	reverse-20080930-branch:1.89.0.4
	reverse-20080930-branchpoint:1.89
	binutils-2_19-branch:1.89.0.2
	binutils-2_19-branchpoint:1.89
	sid-snapshot-20080901:1.89
	sid-snapshot-20080801:1.85
	reverse-20080717-branch:1.85.0.4
	reverse-20080717-branchpoint:1.85
	sid-snapshot-20080701:1.85
	msnyder-reverse-20080609-branch:1.85.0.2
	msnyder-reverse-20080609-branchpoint:1.85
	drow-reverse-20070409-branch:1.79.0.2
	drow-reverse-20070409-branchpoint:1.79
	sid-snapshot-20080601:1.85
	sid-snapshot-20080501:1.85
	sid-snapshot-20080403:1.85
	sid-snapshot-20080401:1.85
	gdb_6_8-2008-03-27-release:1.84
	sid-snapshot-20080301:1.85
	gdb_6_8-branch:1.84.0.4
	gdb_6_8-2008-02-26-branchpoint:1.84
	sid-snapshot-20080201:1.84
	sid-snapshot-20080101:1.84
	sid-snapshot-20071201:1.84
	sid-snapshot-20071101:1.84
	gdb_6_7_1-2007-10-29-release:1.84
	gdb_6_7-2007-10-10-release:1.84
	sid-snapshot-20071001:1.84
	gdb_6_7-branch:1.84.0.2
	gdb_6_7-2007-09-07-branchpoint:1.84
	binutils-2_18:1.83
	binutils-2_18-branch:1.83.0.2
	binutils-2_18-branchpoint:1.83
	insight_6_6-20070208-release:1.78
	binutils-csl-coldfire-4_1-32:1.73
	binutils-csl-sourcerygxx-4_1-32:1.73
	gdb_6_6-2006-12-18-release:1.78
	binutils-csl-innovasic-fido-3_4_4-33:1.73
	binutils-csl-sourcerygxx-3_4_4-32:1.69
	binutils-csl-coldfire-4_1-30:1.73
	binutils-csl-sourcerygxx-4_1-30:1.73
	binutils-csl-coldfire-4_1-28:1.73
	binutils-csl-sourcerygxx-4_1-29:1.73
	binutils-csl-sourcerygxx-4_1-28:1.73
	gdb_6_6-branch:1.78.0.2
	gdb_6_6-2006-11-15-branchpoint:1.78
	binutils-csl-arm-2006q3-27:1.73
	binutils-csl-sourcerygxx-4_1-27:1.73
	binutils-csl-arm-2006q3-26:1.73
	binutils-csl-sourcerygxx-4_1-26:1.73
	binutils-csl-sourcerygxx-4_1-25:1.73
	binutils-csl-sourcerygxx-4_1-24:1.73
	binutils-csl-sourcerygxx-4_1-23:1.73
	insight_6_5-20061003-release:1.73
	gdb-csl-symbian-6_4_50_20060226-12:1.73
	binutils-csl-sourcerygxx-4_1-21:1.73
	binutils-csl-arm-2006q3-21:1.73
	binutils-csl-sourcerygxx-4_1-22:1.73
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.73
	binutils-csl-sourcerygxx-4_1-20:1.73
	binutils-csl-arm-2006q3-19:1.73
	binutils-csl-sourcerygxx-4_1-19:1.73
	binutils-csl-sourcerygxx-4_1-18:1.73
	binutils-csl-renesas-4_1-9:1.73
	gdb-csl-sourcerygxx-3_4_4-25:1.72
	binutils-csl-sourcerygxx-3_4_4-25:1.69
	nickrob-async-20060828-mergepoint:1.76
	gdb-csl-symbian-6_4_50_20060226-11:1.73
	binutils-csl-renesas-4_1-8:1.73
	binutils-csl-renesas-4_1-7:1.73
	binutils-csl-renesas-4_1-6:1.73
	gdb-csl-sourcerygxx-4_1-17:1.73
	binutils-csl-sourcerygxx-4_1-17:1.73
	gdb-csl-20060226-branch-local-2:1.73
	gdb-csl-sourcerygxx-4_1-14:1.73
	binutils-csl-sourcerygxx-4_1-14:1.73
	binutils-csl-sourcerygxx-4_1-15:1.73
	gdb-csl-sourcerygxx-4_1-13:1.73
	binutils-csl-sourcerygxx-4_1-13:1.73
	binutils-2_17:1.73
	gdb-csl-sourcerygxx-4_1-12:1.73
	binutils-csl-sourcerygxx-4_1-12:1.73
	gdb-csl-sourcerygxx-3_4_4-21:1.73
	binutils-csl-sourcerygxx-3_4_4-21:1.73
	gdb_6_5-20060621-release:1.73
	binutils-csl-wrs-linux-3_4_4-24:1.69
	binutils-csl-wrs-linux-3_4_4-23:1.69
	gdb-csl-sourcerygxx-4_1-9:1.73
	binutils-csl-sourcerygxx-4_1-9:1.73
	gdb-csl-sourcerygxx-4_1-8:1.73
	binutils-csl-sourcerygxx-4_1-8:1.73
	gdb-csl-sourcerygxx-4_1-7:1.73
	binutils-csl-sourcerygxx-4_1-7:1.73
	gdb-csl-arm-2006q1-6:1.73
	binutils-csl-arm-2006q1-6:1.73
	gdb-csl-sourcerygxx-4_1-6:1.73
	binutils-csl-sourcerygxx-4_1-6:1.73
	binutils-csl-wrs-linux-3_4_4-22:1.69
	gdb-csl-symbian-6_4_50_20060226-10:1.73
	gdb-csl-symbian-6_4_50_20060226-9:1.73
	gdb-csl-symbian-6_4_50_20060226-8:1.73
	gdb-csl-coldfire-4_1-11:1.73
	binutils-csl-coldfire-4_1-11:1.73
	gdb-csl-sourcerygxx-3_4_4-19:1.73
	binutils-csl-sourcerygxx-3_4_4-19:1.73
	gdb-csl-coldfire-4_1-10:1.73
	gdb_6_5-branch:1.73.0.20
	gdb_6_5-2006-05-14-branchpoint:1.73
	binutils-csl-coldfire-4_1-10:1.73
	gdb-csl-sourcerygxx-4_1-5:1.73
	binutils-csl-sourcerygxx-4_1-5:1.73
	nickrob-async-20060513-branch:1.73.0.18
	nickrob-async-20060513-branchpoint:1.73
	gdb-csl-sourcerygxx-4_1-4:1.73
	binutils-csl-sourcerygxx-4_1-4:1.73
	msnyder-reverse-20060502-branch:1.73.0.16
	msnyder-reverse-20060502-branchpoint:1.73
	binutils-csl-wrs-linux-3_4_4-21:1.69
	gdb-csl-morpho-4_1-4:1.73
	binutils-csl-morpho-4_1-4:1.73
	gdb-csl-sourcerygxx-3_4_4-17:1.73
	binutils-csl-sourcerygxx-3_4_4-17:1.73
	binutils-csl-wrs-linux-3_4_4-20:1.69
	readline_5_1-import-branch:1.73.0.14
	readline_5_1-import-branchpoint:1.73
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.73
	binutils-2_17-branch:1.73.0.12
	binutils-2_17-branchpoint:1.73
	gdb-csl-symbian-20060226-branch:1.73.0.10
	gdb-csl-symbian-20060226-branchpoint:1.73
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.73
	msnyder-reverse-20060331-branch:1.73.0.8
	msnyder-reverse-20060331-branchpoint:1.73
	binutils-csl-2_17-branch:1.73.0.6
	binutils-csl-2_17-branchpoint:1.73
	gdb-csl-available-20060303-branch:1.73.0.4
	gdb-csl-available-20060303-branchpoint:1.73
	gdb-csl-20060226-branch:1.73.0.2
	gdb-csl-20060226-branchpoint:1.73
	gdb_6_4-20051202-release:1.72
	msnyder-fork-checkpoint-branch:1.72.0.10
	msnyder-fork-checkpoint-branchpoint:1.72
	gdb-csl-gxxpro-6_3-branch:1.72.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.72
	gdb_6_4-branch:1.72.0.6
	gdb_6_4-2005-11-01-branchpoint:1.72
	gdb-csl-arm-20051020-branch:1.72.0.4
	gdb-csl-arm-20051020-branchpoint:1.72
	binutils-csl-gxxpro-3_4-branch:1.69.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.69
	binutils-2_16_1:1.69
	msnyder-tracepoint-checkpoint-branch:1.72.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.72
	gdb-csl-arm-20050325-2005-q1b:1.69
	binutils-csl-arm-2005q1b:1.69
	binutils-2_16:1.69
	gdb-csl-arm-20050325-2005-q1a:1.69
	binutils-csl-arm-2005q1a:1.69
	csl-arm-20050325-branch:1.69.0.6
	csl-arm-20050325-branchpoint:1.69
	binutils-csl-arm-2005q1-branch:1.69.0.4
	binutils-csl-arm-2005q1-branchpoint:1.69
	binutils-2_16-branch:1.69.0.2
	binutils-2_16-branchpoint:1.69
	csl-arm-2004-q3d:1.62
	gdb_6_3-20041109-release:1.62
	gdb_6_3-branch:1.62.0.2
	gdb_6_3-20041019-branchpoint:1.62
	csl-arm-2004-q3:1.61
	drow_intercu-merge-20040921:1.61
	drow_intercu-merge-20040915:1.61
	jimb-gdb_6_2-e500-branch:1.61.0.6
	jimb-gdb_6_2-e500-branchpoint:1.61
	gdb_6_2-20040730-release:1.61
	gdb_6_2-branch:1.61.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.61
	gdb_6_1_1-20040616-release:1.59
	binutils-2_15:1.59
	binutils-2_15-branchpoint:1.59
	csl-arm-2004-q1a:1.59
	csl-arm-2004-q1:1.59
	gdb_6_1-2004-04-05-release:1.59
	drow_intercu-merge-20040402:1.59
	drow_intercu-merge-20040327:1.59
	ezannoni_pie-20040323-branch:1.59.0.14
	ezannoni_pie-20040323-branchpoint:1.59
	cagney_tramp-20040321-mergepoint:1.59
	cagney_tramp-20040309-branch:1.59.0.12
	cagney_tramp-20040309-branchpoint:1.59
	gdb_6_1-branch:1.59.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.59
	drow_intercu-20040221-branch:1.59.0.8
	drow_intercu-20040221-branchpoint:1.59
	binutils-2_15-branch:1.59.0.6
	cagney_bfdfile-20040213-branch:1.59.0.4
	cagney_bfdfile-20040213-branchpoint:1.59
	drow-cplus-merge-20040208:1.59
	carlton_dictionary-20040126-merge:1.59
	cagney_bigcore-20040122-branch:1.59.0.2
	cagney_bigcore-20040122-branchpoint:1.59
	drow-cplus-merge-20040113:1.58
	csl-arm-2003-q4:1.57
	drow-cplus-merge-20031224:1.57
	drow-cplus-merge-20031220:1.57
	carlton_dictionary-20031215-merge:1.56
	drow-cplus-merge-20031214:1.56
	carlton-dictionary-20031111-merge:1.54
	gdb_6_0-2003-10-04-release:1.50
	kettenis_sparc-20030918-branch:1.53.0.6
	kettenis_sparc-20030918-branchpoint:1.53
	carlton_dictionary-20030917-merge:1.53
	ezannoni_pie-20030916-branchpoint:1.53
	ezannoni_pie-20030916-branch:1.53.0.4
	cagney_x86i386-20030821-branch:1.53.0.2
	cagney_x86i386-20030821-branchpoint:1.53
	carlton_dictionary-20030805-merge:1.51
	carlton_dictionary-20030627-merge:1.51
	gdb_6_0-branch:1.50.0.4
	gdb_6_0-2003-06-23-branchpoint:1.50
	jimb-ppc64-linux-20030613-branch:1.50.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.50
	binutils-2_14:1.47
	cagney_convert-20030606-branch:1.49.0.4
	cagney_convert-20030606-branchpoint:1.49
	cagney_writestrings-20030508-branch:1.48.0.6
	cagney_writestrings-20030508-branchpoint:1.48
	jimb-ppc64-linux-20030528-branch:1.49.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.49
	carlton_dictionary-20030523-merge:1.49
	cagney_fileio-20030521-branch:1.48.0.4
	cagney_fileio-20030521-branchpoint:1.48
	kettenis_i386newframe-20030517-mergepoint:1.48
	jimb-ppc64-linux-20030509-branch:1.48.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.48
	kettenis_i386newframe-20030504-mergepoint:1.47
	carlton_dictionary-20030430-merge:1.47
	binutils-2_14-branch:1.47.0.10
	binutils-2_14-branchpoint:1.47
	kettenis_i386newframe-20030419-branch:1.47.0.8
	kettenis_i386newframe-20030419-branchpoint:1.47
	carlton_dictionary-20030416-merge:1.47
	cagney_frameaddr-20030409-mergepoint:1.47
	kettenis_i386newframe-20030406-branch:1.47.0.6
	kettenis_i386newframe-20030406-branchpoint:1.47
	cagney_frameaddr-20030403-branchpoint:1.47
	cagney_frameaddr-20030403-branch:1.47.0.4
	cagney_framebase-20030330-mergepoint:1.47
	cagney_framebase-20030326-branch:1.47.0.2
	cagney_framebase-20030326-branchpoint:1.47
	cagney_lazyid-20030317-branch:1.46.0.4
	cagney_lazyid-20030317-branchpoint:1.46
	kettenis-i386newframe-20030316-mergepoint:1.46
	offbyone-20030313-branch:1.46.0.2
	offbyone-20030313-branchpoint:1.46
	kettenis-i386newframe-20030308-branch:1.44.0.4
	kettenis-i386newframe-20030308-branchpoint:1.44
	carlton_dictionary-20030305-merge:1.44
	cagney_offbyone-20030303-branch:1.44.0.2
	cagney_offbyone-20030303-branchpoint:1.44
	carlton_dictionary-20030207-merge:1.43
	interps-20030202-branch:1.43.0.2
	interps-20030202-branchpoint:1.43
	cagney-unwind-20030108-branch:1.42.0.2
	cagney-unwind-20030108-branchpoint:1.42
	binutils-2_13_2_1:1.33
	binutils-2_13_2:1.33
	carlton_dictionary-20021223-merge:1.42
	gdb_5_3-2002-12-12-release:1.35
	carlton_dictionary-20021115-merge:1.39
	binutils-2_13_1:1.33
	kseitz_interps-20021105-merge:1.38
	kseitz_interps-20021103-merge:1.38
	drow-cplus-merge-20021020:1.38
	drow-cplus-merge-20021025:1.38
	carlton_dictionary-20021025-merge:1.38
	carlton_dictionary-20021011-merge:1.38
	drow-cplus-branch:1.38.0.4
	drow-cplus-branchpoint:1.38
	kseitz_interps-20020930-merge:1.38
	carlton_dictionary-20020927-merge:1.38
	carlton_dictionary-branch:1.38.0.2
	carlton_dictionary-20020920-branchpoint:1.38
	sid-20020905-branchpoint:1.35
	sid-20020905-branch:1.35.0.8
	gdb_5_3-branch:1.35.0.6
	gdb_5_3-2002-09-04-branchpoint:1.35
	kseitz_interps-20020829-merge:1.35
	cagney_sysregs-20020825-branch:1.35.0.4
	cagney_sysregs-20020825-branchpoint:1.35
	readline_4_3-import-branch:1.35.0.2
	readline_4_3-import-branchpoint:1.35
	binutils-2_13:1.33
	gdb_5_2_1-2002-07-23-release:1.28
	binutils-2_13-branchpoint:1.33
	binutils-2_13-branch:1.33.0.2
	kseitz_interps-20020528-branch:1.30.0.6
	kseitz_interps-20020528-branchpoint:1.30
	cagney_regbuf-20020515-branch:1.30.0.4
	cagney_regbuf-20020515-branchpoint:1.30
	binutils-2_12_1:1.26.2.2
	jimb-macro-020506-branch:1.30.0.2
	jimb-macro-020506-branchpoint:1.30
	gdb_5_2-2002-04-29-release:1.28
	binutils-2_12:1.26.2.1
	gdb_5_2-branch:1.28.0.2
	gdb_5_2-2002-03-03-branchpoint:1.28
	binutils-2_12-branch:1.26.0.2
	binutils-2_12-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.15
	gdb_5_1_0_1-2002-01-03-release:1.15
	cygnus_cvs_20020108_pre:1.26
	gdb_5_1_0_1-2002-01-03-branch:1.15.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.15
	gdb_5_1-2001-11-21-release:1.15
	gdb_s390-2001-09-26-branch:1.15.0.4
	gdb_s390-2001-09-26-branchpoint:1.15
	gdb_5_1-2001-07-29-branch:1.15.0.2
	gdb_5_1-2001-07-29-branchpoint:1.15
	binutils-2_11_2:1.11.2.2
	binutils-2_11_1:1.11.2.2
	binutils-2_11:1.11
	x86_64versiong3:1.12
	binutils-2_11-branch:1.11.0.2
	insight-precleanup-2001-01-01:1.11
	binutils-2_10_1:1.9
	binutils-2_10:1.9
	gdb-premipsmulti-2000-06-06-branch:1.9.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.9
	gdb_5_0-2000-05-19-release:1.9
	gdb_4_18_2-2000-05-18-release:1.9
	gdb_4_95_1-2000-05-11-snapshot:1.9
	gdb_4_95_0-2000-04-27-snapshot:1.9
	gdb_5_0-2000-04-10-branch:1.9.0.4
	gdb_5_0-2000-04-10-branchpoint:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.111
	repo-unification-2000-02-06:1.9
	binu_ss_19990721:1.7
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.111
date	2013.05.30.20.27.21;	author clm;	state Exp;
branches;
next	1.110;

1.110
date	2013.05.06.15.25.45;	author clm;	state Exp;
branches;
next	1.109;

1.109
date	2013.05.04.09.33.08;	author rsandifo;	state Exp;
branches;
next	1.108;

1.108
date	2013.02.21.03.02.30;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2013.02.18.23.20.44;	author macro;	state Exp;
branches;
next	1.106;

1.106
date	2012.12.03.16.17.46;	author macro;	state Exp;
branches;
next	1.105;

1.105
date	2012.08.03.22.17.19;	author macro;	state Exp;
branches;
next	1.104;

1.104
date	2012.05.19.19.30.45;	author macro;	state Exp;
branches
	1.104.4.1;
next	1.103;

1.103
date	2012.05.19.19.13.56;	author macro;	state Exp;
branches;
next	1.102;

1.102
date	2011.12.19.07.58.00;	author cltang;	state Exp;
branches;
next	1.101;

1.101
date	2011.11.16.12.12.22;	author macro;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.24.14.20.05;	author rsandifo;	state Exp;
branches
	1.100.2.1;
next	1.99;

1.99
date	2010.12.31.11.00.53;	author rsandifo;	state Exp;
branches;
next	1.98;

1.98
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.97;

1.97
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.96;

1.96
date	2010.08.25.14.53.44;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.27.21.08.21;	author macro;	state Exp;
branches;
next	1.93;

1.93
date	2010.03.24.15.41.59;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.91;

1.91
date	2009.09.03.15.21.09;	author macro;	state Exp;
branches;
next	1.90;

1.90
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.08.19.24.48;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.07.20.03.25;	author rsandifo;	state Exp;
branches;
next	1.87;

1.87
date	2008.08.07.19.57.27;	author rsandifo;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.06.19.44.47;	author rsandifo;	state Exp;
branches;
next	1.85;

1.85
date	2008.02.27.17.06.06;	author clm;	state Exp;
branches;
next	1.84;

1.84
date	2007.08.24.13.46.32;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2007.07.10.04.08.11;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.02.10.49.41;	author jsm28;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2006.10.28.10.13.49;	author rsandifo;	state Exp;
branches;
next	1.77;

1.77
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.15.18.28.48;	author ths;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.20.16.46.29;	author ths;	state Exp;
branches;
next	1.74;

1.74
date	2006.06.12.11.35.43;	author ths;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.23.14.04.17;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.23.17.44.53;	author fnf;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.04.15.53.24;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2005.03.02.21.23.20;	author drow;	state Exp;
branches;
next	1.68;

1.68
date	2005.02.15.19.57.48;	author macro;	state Exp;
branches;
next	1.67;

1.67
date	2005.02.11.22.29.10;	author macro;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.10.03.07.46;	author macro;	state Exp;
branches;
next	1.65;

1.65
date	2005.02.07.15.50.16;	author macro;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.07.02.44.59;	author macro;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.31.23.13.24;	author bje;	state Exp;
branches;
next	1.62;

1.62
date	2004.10.07.19.15.28;	author rsandifo;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.29.13.46.33;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.14.03.06.00;	author ian;	state Exp;
branches
	1.59.8.1;
next	1.58;

1.58
date	2004.01.05.22.09.38;	author macro;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.18.10.23.07;	author rsandifo;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.07.21.24.28;	author rsandifo;	state Exp;
branches;
next	1.55;

1.55
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2003.08.20.13.53.42;	author rsandifo;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.11.16.22.25;	author ths;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.22.09.27.51;	author ths;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.09.02.27.10;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.26.01.04.21;	author aoliva;	state Exp;
branches
	1.47.8.1;
next	1.46;

1.46
date	2003.03.12.23.05.51;	author aoliva;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.12.22.52.12;	author aoliva;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.02.21.30.14;	author ths;	state Exp;
branches
	1.44.4.1;
next	1.43;

1.43
date	2003.01.23.11.51.32;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.12.05.05.04.00;	author kevinb;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.28.11.55.41;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.11.06.21.56.05;	author aoliva;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.18.17.28.37;	author scox;	state Exp;
branches
	1.38.2.1
	1.38.4.1;
next	1.37;

1.37
date	2002.09.18.01.38.20;	author scox;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.17.07.48.30;	author ths;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.25.15.35.14;	author ths;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.19.21.34.02;	author ths;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.08.07.27.52;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.05.10.31.46;	author macro;	state Exp;
branches;
next	1.30;

1.30
date	2002.04.04.07.01.22;	author ths;	state Exp;
branches
	1.30.4.1
	1.30.6.1;
next	1.29;

1.29
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.19.12.40.32;	author jakub;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.15.02.10.35;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.17.20.14.48;	author ths;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.15.09.56.19;	author ths;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.05.22.46.21;	author ths;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.02.13.14.48;	author ths;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.03.14.12.12;	author ths;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.06.21.30.15;	author ths;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.17.09.21.34;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.03.04.46.27;	author aj;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.08.05.11.48;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.11.23.21.01;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.09.01.54.51;	author kazu;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.07.11.06.37.34;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	99.12.10.18.51.34;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	99.12.10.01.41.21;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.07.14.08.49.40;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	99.07.07.19.23.21;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	99.07.07.17.50.56;	author mmitchel;	state Exp;
branches;
next	1.4;

1.4
date	99.06.02.18.17.59;	author mmitchel;	state Exp;
branches;
next	1.3;

1.3
date	99.06.02.16.11.43;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.10.20.15;	author mmitchel;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.104.4.1
date	2012.09.04.14.37.52;	author gingold;	state Exp;
branches;
next	;

1.100.2.1
date	2011.12.19.10.49.25;	author cltang;	state Exp;
branches;
next	;

1.59.8.1
date	2004.09.16.17.00.29;	author drow;	state Exp;
branches;
next	;

1.47.8.1
date	2003.05.18.09.43.45;	author kettenis;	state Exp;
branches;
next	;

1.44.4.1
date	2003.03.16.14.01.43;	author kettenis;	state Exp;
branches;
next	;

1.38.2.1
date	2002.11.15.19.18.27;	author carlton;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2002.12.23.19.37.47;	author carlton;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2003.02.07.19.17.39;	author carlton;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2003.04.16.19.56.44;	author carlton;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2003.05.23.18.40.26;	author carlton;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2003.06.27.21.49.20;	author carlton;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2003.09.17.21.27.54;	author carlton;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2003.11.11.23.50.22;	author carlton;	state Exp;
branches;
next	1.38.2.10;

1.38.2.10
date	2003.12.15.23.59.35;	author carlton;	state Exp;
branches;
next	1.38.2.11;

1.38.2.11
date	2004.01.26.19.11.05;	author carlton;	state Exp;
branches;
next	;

1.38.4.1
date	2003.12.14.20.26.43;	author drow;	state Exp;
branches;
next	1.38.4.2;

1.38.4.2
date	2003.12.20.18.16.46;	author drow;	state Exp;
branches;
next	1.38.4.3;

1.38.4.3
date	2004.01.13.16.11.37;	author drow;	state Exp;
branches;
next	1.38.4.4;

1.38.4.4
date	2004.02.09.19.43.24;	author drow;	state Exp;
branches;
next	;

1.30.4.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.30.6.1
date	2002.06.20.01.30.31;	author kseitz;	state Exp;
branches;
next	1.30.6.2;

1.30.6.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	1.30.6.3;

1.30.6.3
date	2002.08.09.18.34.15;	author kseitz;	state Exp;
branches;
next	1.30.6.4;

1.30.6.4
date	2002.10.01.00.45.47;	author kseitz;	state Exp;
branches;
next	;

1.26.2.1
date	2002.02.19.13.10.32;	author jakub;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	;

1.11.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.06.11.10.04.14;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.57;	author rth;	state Exp;
branches;
next	;


desc
@@


1.111
log
@2013-05-30  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips_eh_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup ): Support BFD_RELOC_MIPS_EH.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf32_rtype_to_howto): Support R_MIPS_EH.
	* elf64-mips.c (elf_mips_eh_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Support BFD_RELOC_MIPS_EH.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Support R_MIPS_EH.
	* libbfd.h: Regenerate.
	* reloc.c (BFD_RELOC_MIPS_EH): New.

	gas/
	* config/tc-mips.c (md_apply_fix): Support BFD_RELOC_MIPS_EH.

	include/elf
	* mips.h (R_MIPS_EH): New.
@
text
@/* MIPS-specific support for 64-bit ELF
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
   Ian Lance Taylor, Cygnus Support
   Linker support added by Mark Mitchell, CodeSourcery, LLC.
   <mark@@codesourcery.com>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file supports the 64-bit MIPS ELF ABI.

   The MIPS 64-bit ELF ABI uses an unusual reloc format.  This file
   overrides the usual ELF reloc handling, and handles reading and
   writing the relocations here.  */

/* TODO: Many things are unsupported, even if there is some code for it
 .       (which was mostly stolen from elf32-mips.c and slightly adapted).
 .
 .   - Relocation handling for REL relocs is wrong in many cases and
 .     generally untested.
 .   - Relocation handling for RELA relocs related to GOT support are
 .     also likely to be wrong.
 .   - Support for MIPS16 is untested.
 .   - Combined relocs with RSS_* entries are unsupported.
 .   - The whole GOT handling for NewABI is missing, some parts of
 .     the OldABI version is still lying around and should be removed.
 */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "aout/ar.h"
#include "bfdlink.h"
#include "genlink.h"
#include "elf-bfd.h"
#include "elfxx-mips.h"
#include "elf/mips.h"

/* Get the ECOFF swapping routines.  The 64-bit ABI is not supposed to
   use ECOFF.  However, we support it anyhow for an easier changeover.  */
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/internal.h"
#include "coff/ecoff.h"
/* The 64 bit versions of the mdebug data structures are in alpha.h.  */
#include "coff/alpha.h"
#define ECOFF_SIGNED_64
#include "ecoffswap.h"

static void mips_elf64_swap_reloc_in
  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
static void mips_elf64_swap_reloca_in
  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
static void mips_elf64_swap_reloc_out
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
static void mips_elf64_swap_reloca_out
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
static void mips_elf64_be_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
static void mips_elf64_be_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
static void mips_elf64_be_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
static void mips_elf64_be_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
static reloc_howto_type *bfd_elf64_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static reloc_howto_type *mips_elf64_rtype_to_howto
  (unsigned int, bfd_boolean);
static void mips_elf64_info_to_howto_rel
  (bfd *, arelent *, Elf_Internal_Rela *);
static void mips_elf64_info_to_howto_rela
  (bfd *, arelent *, Elf_Internal_Rela *);
static long mips_elf64_get_reloc_upper_bound
  (bfd *, asection *);
static long mips_elf64_canonicalize_reloc
  (bfd *, asection *, arelent **, asymbol **);
static long mips_elf64_get_dynamic_reloc_upper_bound
  (bfd *);
static long mips_elf64_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
static bfd_boolean mips_elf64_slurp_one_reloc_table
  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
   asymbol **, bfd_boolean);
static bfd_boolean mips_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);
static void mips_elf64_write_relocs
  (bfd *, asection *, void *);
static void mips_elf64_write_rel
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
static void mips_elf64_write_rela
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
static bfd_reloc_status_type mips_elf64_gprel16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_literal_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_gprel32_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips_elf64_shift6_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type mips16_gprel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean mips_elf64_assign_gp
  (bfd *, bfd_vma *);
static bfd_reloc_status_type mips_elf64_final_gp
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf64_object_p
  (bfd *);
static irix_compat_t elf64_mips_irix_compat
  (bfd *);
static bfd_boolean elf64_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf64_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);

extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_littlemips_vec;

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* The number of local .got entries we reserve.  */
#define MIPS_RESERVED_GOTNO (2)

/* The relocation table used for SHT_REL sections.  */

static reloc_howto_type mips_elf64_howto_table_rel[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
				/* This needs complex overflow
				   detection, because the upper 36
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x03ffffff,		/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for NewABI REL.
     However, the native IRIX6 tools use them, so we try our best. */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS_HI16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS_LO16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_literal_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC16",		/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c0,		/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_elf64_shift6_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000007c4,		/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_A",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction, and change all relocations
     to refer to the old instruction at the address.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_B,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_B",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Delete a 32 bit instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_DELETE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_DELETE",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The MIPS ELF64 ABI Draft wants us to support these for REL relocations.
     We don't, because
       a) It means building the addend from a R_MIPS_HIGHEST/R_MIPS_HIGHER/
	  R_MIPS_HI16/R_MIPS_LO16 sequence with varying ordering, using
	  fallable heuristics.
       b) No other NewABI toolchain actually emits such relocations.  */
  EMPTY_HOWTO (R_MIPS_HIGHER),
  EMPTY_HOWTO (R_MIPS_HIGHEST),

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement, used by an associated event location section.  */
  HOWTO (R_MIPS_SCN_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),

  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS relocations.  */
  EMPTY_HOWTO (R_MIPS_TLS_DTPMOD32),
  EMPTY_HOWTO (R_MIPS_TLS_DTPREL32),

  HOWTO (R_MIPS_TLS_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPMOD64",	/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_TLS_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL64",	/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS general dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_GD,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS IE dynamic relocations.  */
  EMPTY_HOWTO (R_MIPS_TLS_TPREL32),

  HOWTO (R_MIPS_TLS_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL64",	/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation with no addend.  */
  HOWTO (R_MIPS_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* The relocation table used for SHT_RELA sections.  */

static reloc_howto_type mips_elf64_howto_table_rela[] =
{
  /* No relocation.  */
  HOWTO (R_MIPS_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit relocation.  */
  HOWTO (R_MIPS_16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation.  */
  HOWTO (R_MIPS_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit symbol relative relocation.  */
  HOWTO (R_MIPS_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 26 bit jump address.  */
  HOWTO (R_MIPS_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
				/* This needs complex overflow
				   detection, because the upper 36
				   bits must match the PC + 4.  */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_26",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x03ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MIPS_HI16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_HI16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MIPS_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_LO16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_gprel16_reloc, /* special_function */
	 "R_MIPS_GPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips_elf64_literal_reloc, /* special_function */
	 "R_MIPS_LITERAL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MIPS_GOT16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
  HOWTO (R_MIPS_PC16,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MIPS_CALL16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit GP relative reference.  */
  HOWTO (R_MIPS_GPREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_gprel32_reloc, /* special_function */
	 "R_MIPS_GPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),

  /* A 5 bit shift field.  */
  HOWTO (R_MIPS_SHIFT5,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 5,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SHIFT5",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c0,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 6 bit shift field.  */
  HOWTO (R_MIPS_SHIFT6,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 6,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 mips_elf64_shift6_reloc, /* special_function */
	 "R_MIPS_SHIFT6",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000007c4,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit relocation.  */
  HOWTO (R_MIPS_64,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_64",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement in the global offset table.  */
  HOWTO (R_MIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_DISP",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_PAGE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_OFST",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GOT_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  */
  HOWTO (R_MIPS_SUB,		/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SUB",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Insert the addend as an instruction, and change all relocations
     to refer to the old instruction at the address.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_INSERT_B,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_INSERT_B",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Delete a 32 bit instruction.  */
  /* FIXME: Not handled correctly.  */
  HOWTO (R_MIPS_DELETE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_DELETE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_CALL_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement, used by an associated event location section.  */
  HOWTO (R_MIPS_SCN_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_SCN_DISP",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_REL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* These two are obsolete.  */
  EMPTY_HOWTO (R_MIPS_ADD_IMMEDIATE),
  EMPTY_HOWTO (R_MIPS_PJUMP),

  /* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.
     It must be used for multigot GOT's (and only there).  */
  HOWTO (R_MIPS_RELGOT,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_RELGOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MIPS_JALR,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_JALR",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS relocations.  */
  EMPTY_HOWTO (R_MIPS_TLS_DTPMOD32),
  EMPTY_HOWTO (R_MIPS_TLS_DTPREL32),

  HOWTO (R_MIPS_TLS_DTPMOD64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPMOD64", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_MIPS_TLS_DTPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS general dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_GD,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GD",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic variable reference.  */
  HOWTO (R_MIPS_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_LDM",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS local dynamic offset.  */
  HOWTO (R_MIPS_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_DTPREL_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_GOTTPREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS IE dynamic relocations.  */
  EMPTY_HOWTO (R_MIPS_TLS_TPREL32),

  HOWTO (R_MIPS_TLS_TPREL64,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL64",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_HI16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* TLS thread pointer offset.  */
  HOWTO (R_MIPS_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_TLS_TPREL_LO16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32 bit relocation with no addend.  */
  HOWTO (R_MIPS_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static reloc_howto_type mips16_elf64_howto_table_rel[] =
{
  /* The reloc used for the mips16 jump instruction.  */
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_26",		/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The reloc used for the mips16 gprel instruction.  */
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 reference to the global offset table.  */
  HOWTO (R_MIPS16_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS16_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 call through the global offset table.  */
  HOWTO (R_MIPS16_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 high 16 bits of symbol value.  */
  HOWTO (R_MIPS16_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS16_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 low 16 bits of symbol value.  */
  HOWTO (R_MIPS16_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS16_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static reloc_howto_type mips16_elf64_howto_table_rela[] =
{
  /* The reloc used for the mips16 jump instruction.  */
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_26",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The reloc used for the mips16 gprel instruction.  */
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 reference to the global offset table.  */
  HOWTO (R_MIPS16_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MIPS16_GOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A MIPS16 call through the global offset table.  */
  HOWTO (R_MIPS16_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_CALL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,	        /* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 high 16 bits of symbol value.  */
  HOWTO (R_MIPS16_HI16,		/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MIPS16_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 low 16 bits of symbol value.  */
  HOWTO (R_MIPS16_LO16,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MIPS16_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static reloc_howto_type micromips_elf64_howto_table_rel[] =
{
  EMPTY_HOWTO (130),
  EMPTY_HOWTO (131),
  EMPTY_HOWTO (132),

  /* 26 bit jump address.  */
  HOWTO (R_MICROMIPS_26_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_26_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_HI16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MICROMIPS_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MICROMIPS_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MICROMIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_GPREL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MICROMIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_LITERAL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MICROMIPS_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MICROMIPS_GOT16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This is for microMIPS branches.  */
  HOWTO (R_MICROMIPS_PC7_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC7_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000007f,		/* src_mask */
	 0x0000007f,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC10_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC10_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x000003ff,		/* src_mask */
	 0x000003ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC16_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC16_S1",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MICROMIPS_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (143),
  EMPTY_HOWTO (144),

  /* Displacement in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_DISP",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_PAGE",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_OFST",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_HI16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_LO16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MICROMIPS_SUB,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SUB",	/* name */
	 TRUE,			/* partial_inplace */
	 MINUS_ONE,		/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* We don't support these for REL relocations, because it means building
     the addend from a R_MICROMIPS_HIGHEST/R_MICROMIPS_HIGHER/
     R_MICROMIPS_HI16/R_MICROMIPS_LO16 sequence with varying ordering,
     using fallable heuristics.  */
  EMPTY_HOWTO (R_MICROMIPS_HIGHER),
  EMPTY_HOWTO (R_MICROMIPS_HIGHEST),

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_HI16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_LO16",/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MICROMIPS_SCN_DISP,  /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SCN_DISP", /* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MICROMIPS_JALR,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_JALR",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static reloc_howto_type micromips_elf64_howto_table_rela[] =
{
  EMPTY_HOWTO (130),
  EMPTY_HOWTO (131),
  EMPTY_HOWTO (132),

  /* 26 bit jump address.  */
  HOWTO (R_MICROMIPS_26_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_26_S1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_HI16,	/* type */
	 16,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_hi16_reloc, /* special_function */
	 "R_MICROMIPS_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of symbol value.  */
  HOWTO (R_MICROMIPS_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_lo16_reloc, /* special_function */
	 "R_MICROMIPS_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GP relative reference.  */
  HOWTO (R_MICROMIPS_GPREL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_GPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to literal section.  */
  HOWTO (R_MICROMIPS_LITERAL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf32_gprel16_reloc, /* special_function */
	 "R_MICROMIPS_LITERAL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Reference to global offset table.  */
  HOWTO (R_MICROMIPS_GOT16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_got16_reloc, /* special_function */
	 "R_MICROMIPS_GOT16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This is for microMIPS branches.  */
  HOWTO (R_MICROMIPS_PC7_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC7_S1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000007f,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC10_S1,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 10,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC10_S1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000003ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_MICROMIPS_PC16_S1,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_PC16_S1",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 16 bit call through global offset table.  */
  HOWTO (R_MICROMIPS_CALL16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  EMPTY_HOWTO (143),
  EMPTY_HOWTO (144),

  /* Displacement in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_DISP,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_DISP",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Displacement to page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_PAGE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_PAGE",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Offset from page pointer in the global offset table.  */
  HOWTO (R_MICROMIPS_GOT_OFST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_OFST",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_HI16",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_GOT_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_GOT_LO16",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 64 bit subtraction.  Used in the N32 ABI.  */
  HOWTO (R_MICROMIPS_SUB,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SUB",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 MINUS_ONE,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MICROMIPS_HIGHER,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_HIGHER",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MICROMIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_HIGHEST",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* High 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_HI16",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Low 16 bits of displacement in global offset table.  */
  HOWTO (R_MICROMIPS_CALL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_CALL_LO16",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Section displacement.  */
  HOWTO (R_MICROMIPS_SCN_DISP,  /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_SCN_DISP", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Protected jump conversion.  This is an optimization hint.  No
     relocation is required for correctness.  */
  HOWTO (R_MICROMIPS_JALR,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MICROMIPS_JALR",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rela16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 32 bit pc-relative.  Used for compact EH tables.  */
static reloc_howto_type elf_mips_gnu_pcrel32 =
  HOWTO (R_MIPS_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_PC32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */


/* Originally a VxWorks extension, but now used for other systems too.  */
static reloc_howto_type elf_mips_copy_howto =
  HOWTO (R_MIPS_COPY,		/* type */
	 0,			/* rightshift */
	 0,			/* this one is variable size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Originally a VxWorks extension, but now used for other systems too.  */
static reloc_howto_type elf_mips_jump_slot_howto =
  HOWTO (R_MIPS_JUMP_SLOT,	/* type */
	 0,			/* rightshift */
	 4,			/* size (0 = byte, 1 = short, 2 = long) */
	 64,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_JUMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0,         		/* src_mask */
	 0x0,		        /* dst_mask */
	 FALSE);		/* pcrel_offset */

/* Used in EH tables.  */
static reloc_howto_type elf_mips_eh_howto =
  HOWTO (R_MIPS_EH,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS_EH",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,	        /* dst_mask */
	 FALSE);		/* pcrel_offset */


/* Swap in a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
			  Elf64_Mips_Internal_Rela *dst)
{
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = 0;
}

/* Swap in a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
			   Elf64_Mips_Internal_Rela *dst)
{
  dst->r_offset = H_GET_64 (abfd, src->r_offset);
  dst->r_sym = H_GET_32 (abfd, src->r_sym);
  dst->r_ssym = H_GET_8 (abfd, src->r_ssym);
  dst->r_type3 = H_GET_8 (abfd, src->r_type3);
  dst->r_type2 = H_GET_8 (abfd, src->r_type2);
  dst->r_type = H_GET_8 (abfd, src->r_type);
  dst->r_addend = H_GET_S64 (abfd, src->r_addend);
}

/* Swap out a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			   Elf64_Mips_External_Rel *dst)
{
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
}

/* Swap out a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			    Elf64_Mips_External_Rela *dst)
{
  H_PUT_64 (abfd, src->r_offset, dst->r_offset);
  H_PUT_32 (abfd, src->r_sym, dst->r_sym);
  H_PUT_8 (abfd, src->r_ssym, dst->r_ssym);
  H_PUT_8 (abfd, src->r_type3, dst->r_type3);
  H_PUT_8 (abfd, src->r_type2, dst->r_type2);
  H_PUT_8 (abfd, src->r_type, dst->r_type);
  H_PUT_S64 (abfd, src->r_addend, dst->r_addend);
}

/* Swap in a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
			     Elf_Internal_Rela *dst)
{
  Elf64_Mips_Internal_Rela mirel;

  mips_elf64_swap_reloc_in (abfd,
			    (const Elf64_Mips_External_Rel *) src,
			    &mirel);

  dst[0].r_offset = mirel.r_offset;
  dst[0].r_info = ELF64_R_INFO (mirel.r_sym, mirel.r_type);
  dst[0].r_addend = 0;
  dst[1].r_offset = mirel.r_offset;
  dst[1].r_info = ELF64_R_INFO (mirel.r_ssym, mirel.r_type2);
  dst[1].r_addend = 0;
  dst[2].r_offset = mirel.r_offset;
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirel.r_type3);
  dst[2].r_addend = 0;
}

/* Swap in a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
			      Elf_Internal_Rela *dst)
{
  Elf64_Mips_Internal_Rela mirela;

  mips_elf64_swap_reloca_in (abfd,
			     (const Elf64_Mips_External_Rela *) src,
			     &mirela);

  dst[0].r_offset = mirela.r_offset;
  dst[0].r_info = ELF64_R_INFO (mirela.r_sym, mirela.r_type);
  dst[0].r_addend = mirela.r_addend;
  dst[1].r_offset = mirela.r_offset;
  dst[1].r_info = ELF64_R_INFO (mirela.r_ssym, mirela.r_type2);
  dst[1].r_addend = 0;
  dst[2].r_offset = mirela.r_offset;
  dst[2].r_info = ELF64_R_INFO (STN_UNDEF, mirela.r_type3);
  dst[2].r_addend = 0;
}

/* Swap out a MIPS 64-bit Rel reloc.  */

static void
mips_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
			      bfd_byte *dst)
{
  Elf64_Mips_Internal_Rela mirel;

  mirel.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);

  mirel.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirel.r_sym = ELF64_R_SYM (src[0].r_info);
  mirel.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirel.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirel.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);

  mips_elf64_swap_reloc_out (abfd, &mirel,
			     (Elf64_Mips_External_Rel *) dst);
}

/* Swap out a MIPS 64-bit Rela reloc.  */

static void
mips_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
			       bfd_byte *dst)
{
  Elf64_Mips_Internal_Rela mirela;

  mirela.r_offset = src[0].r_offset;
  BFD_ASSERT(src[0].r_offset == src[1].r_offset);
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);

  mirela.r_type = ELF64_MIPS_R_TYPE (src[0].r_info);
  mirela.r_sym = ELF64_R_SYM (src[0].r_info);
  mirela.r_addend = src[0].r_addend;
  BFD_ASSERT(src[1].r_addend == 0);
  BFD_ASSERT(src[2].r_addend == 0);

  mirela.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
  mirela.r_ssym = ELF64_MIPS_R_SSYM (src[1].r_info);
  mirela.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);

  mips_elf64_swap_reloca_out (abfd, &mirela,
			      (Elf64_Mips_External_Rela *) dst);
}

/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
   dangerous relocation.  */

static bfd_boolean
mips_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
{
  unsigned int count;
  asymbol **sym;
  unsigned int i;

  /* If we've already figured out what GP will be, just return it.  */
  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp)
    return TRUE;

  count = bfd_get_symcount (output_bfd);
  sym = bfd_get_outsymbols (output_bfd);

  /* The linker script will have created a symbol named `_gp' with the
     appropriate value.  */
  if (sym == NULL)
    i = count;
  else
    {
      for (i = 0; i < count; i++, sym++)
	{
	  register const char *name;

	  name = bfd_asymbol_name (*sym);
	  if (*name == '_' && strcmp (name, "_gp") == 0)
	    {
	      *pgp = bfd_asymbol_value (*sym);
	      _bfd_set_gp_value (output_bfd, *pgp);
	      break;
	    }
	}
    }

  if (i >= count)
    {
      /* Only get the error once.  */
      *pgp = 4;
      _bfd_set_gp_value (output_bfd, *pgp);
      return FALSE;
    }

  return TRUE;
}

/* We have to figure out the gp value, so that we can adjust the
   symbol value correctly.  We look up the symbol _gp in the output
   BFD.  If we can't find it, we're stuck.  We cache it in the ELF
   target data.  We don't need to adjust the symbol value for an
   external symbol if we are producing relocatable output.  */

static bfd_reloc_status_type
mips_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		     char **error_message, bfd_vma *pgp)
{
  if (bfd_is_und_section (symbol->section)
      && ! relocatable)
    {
      *pgp = 0;
      return bfd_reloc_undefined;
    }

  *pgp = _bfd_get_gp_value (output_bfd);
  if (*pgp == 0
      && (! relocatable
	  || (symbol->flags & BSF_SECTION_SYM) != 0))
    {
      if (relocatable)
	{
	  /* Make up a value.  */
	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
	  _bfd_set_gp_value (output_bfd, *pgp);
	}
      else if (!mips_elf64_assign_gp (output_bfd, pgp))
	{
	  *error_message =
	    (char *) _("GP relative relocation when _gp not defined");
	  return bfd_reloc_dangerous;
	}
    }

  return bfd_reloc_ok;
}

/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
}

/* Do a R_MIPS_LITERAL relocation.  */

static bfd_reloc_status_type
mips_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;

  /* R_MIPS_LITERAL relocations are defined for local symbols only.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("literal relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocatable,
					data, gp);
}

/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */

static bfd_reloc_status_type
mips_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  bfd_vma relocation;
  bfd_vma val;

  /* R_MIPS_GPREL32 relocations are defined for local symbols only.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      *error_message = (char *)
	_("32bits gp relative relocation occurs for an external symbol");
      return bfd_reloc_outofrange;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			     error_message, &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Do a R_MIPS_SHIFT6 relocation. The MSB of the shift is stored at bit 2,
   the rest is at bits 6-10. The bitpos already got right by the howto.  */

static bfd_reloc_status_type
mips_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section, bfd *output_bfd,
			 char **error_message)
{
  if (reloc_entry->howto->partial_inplace)
    {
      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
			     | (reloc_entry->addend & 0x00000800) >> 9);
    }

  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
{
  bfd_boolean relocatable;
  bfd_reloc_status_type ret;
  bfd_byte *location;
  bfd_vma gp;

  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocatable = TRUE;
  else
    {
      relocatable = FALSE;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  location = (bfd_byte *) data + reloc_entry->address;
  _bfd_mips_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				 location);
  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocatable,
				       data, gp);
  _bfd_mips_elf_reloc_shuffle (abfd, reloc_entry->howto->type, !relocatable,
			       location);

  return ret;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  /* There is no BFD reloc for R_MIPS_REL32.  */
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_CTOR, R_MIPS_64 },
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_MIPS_SHIFT5, R_MIPS_SHIFT5 },
  { BFD_RELOC_MIPS_SHIFT6, R_MIPS_SHIFT6 },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_INSERT_A, R_MIPS_INSERT_A },
  { BFD_RELOC_MIPS_INSERT_B, R_MIPS_INSERT_B },
  { BFD_RELOC_MIPS_DELETE, R_MIPS_DELETE },
  { BFD_RELOC_MIPS_HIGHEST, R_MIPS_HIGHEST },
  { BFD_RELOC_MIPS_HIGHER, R_MIPS_HIGHER },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SCN_DISP, R_MIPS_SCN_DISP },
  { BFD_RELOC_MIPS_REL16, R_MIPS_REL16 },
  /* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
  { BFD_RELOC_MIPS_RELGOT, R_MIPS_RELGOT },
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR },
  { BFD_RELOC_MIPS_TLS_DTPMOD32, R_MIPS_TLS_DTPMOD32 },
  { BFD_RELOC_MIPS_TLS_DTPREL32, R_MIPS_TLS_DTPREL32 },
  { BFD_RELOC_MIPS_TLS_DTPMOD64, R_MIPS_TLS_DTPMOD64 },
  { BFD_RELOC_MIPS_TLS_DTPREL64, R_MIPS_TLS_DTPREL64 },
  { BFD_RELOC_MIPS_TLS_GD, R_MIPS_TLS_GD },
  { BFD_RELOC_MIPS_TLS_LDM, R_MIPS_TLS_LDM },
  { BFD_RELOC_MIPS_TLS_DTPREL_HI16, R_MIPS_TLS_DTPREL_HI16 },
  { BFD_RELOC_MIPS_TLS_DTPREL_LO16, R_MIPS_TLS_DTPREL_LO16 },
  { BFD_RELOC_MIPS_TLS_GOTTPREL, R_MIPS_TLS_GOTTPREL },
  { BFD_RELOC_MIPS_TLS_TPREL32, R_MIPS_TLS_TPREL32 },
  { BFD_RELOC_MIPS_TLS_TPREL64, R_MIPS_TLS_TPREL64 },
  { BFD_RELOC_MIPS_TLS_TPREL_HI16, R_MIPS_TLS_TPREL_HI16 },
  { BFD_RELOC_MIPS_TLS_TPREL_LO16, R_MIPS_TLS_TPREL_LO16 }
};

static const struct elf_reloc_map mips16_reloc_map[] =
{
  { BFD_RELOC_MIPS16_JMP, R_MIPS16_26 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_GPREL, R_MIPS16_GPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_GOT16, R_MIPS16_GOT16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_CALL16, R_MIPS16_CALL16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_HI16_S, R_MIPS16_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_LO16, R_MIPS16_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
};

static const struct elf_reloc_map micromips_reloc_map[] =
{
  { BFD_RELOC_MICROMIPS_JMP, R_MICROMIPS_26_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HI16_S, R_MICROMIPS_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_LO16, R_MICROMIPS_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GPREL16, R_MICROMIPS_GPREL16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_LITERAL, R_MICROMIPS_LITERAL - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT16, R_MICROMIPS_GOT16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_7_PCREL_S1, R_MICROMIPS_PC7_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_10_PCREL_S1, R_MICROMIPS_PC10_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_16_PCREL_S1, R_MICROMIPS_PC16_S1 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL16, R_MICROMIPS_CALL16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_DISP, R_MICROMIPS_GOT_DISP - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_PAGE - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_OFST, R_MICROMIPS_GOT_OFST - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_GOT_LO16, R_MICROMIPS_GOT_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_SUB, R_MICROMIPS_SUB - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HIGHER, R_MICROMIPS_HIGHER - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_HIGHEST, R_MICROMIPS_HIGHEST - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL_HI16, R_MICROMIPS_CALL_HI16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_CALL_LO16, R_MICROMIPS_CALL_LO16 - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_SCN_DISP, R_MICROMIPS_SCN_DISP - R_MICROMIPS_min },
  { BFD_RELOC_MICROMIPS_JALR, R_MICROMIPS_JALR - R_MICROMIPS_min },
};
/* Given a BFD reloc type, return a howto structure.  */

static reloc_howto_type *
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;
  /* FIXME: We default to RELA here instead of choosing the right
     relocation variant.  */
  reloc_howto_type *howto_table = mips_elf64_howto_table_rela;
  reloc_howto_type *howto16_table = mips16_elf64_howto_table_rela;
  reloc_howto_type *howto_micromips_table = micromips_elf64_howto_table_rela;

  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }

  for (i = 0; i < sizeof (mips16_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips16_reloc_map[i].bfd_val == code)
	return &howto16_table[(int) mips16_reloc_map[i].elf_val];
    }

  for (i = 0; i < sizeof (micromips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (micromips_reloc_map[i].bfd_val == code)
	return &howto_micromips_table[(int) micromips_reloc_map[i].elf_val];
    }

  switch (code)
    {
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
    case BFD_RELOC_MIPS_EH:
      return &elf_mips_eh_howto;
    case BFD_RELOC_MIPS_COPY:
      return &elf_mips_copy_howto;
    case BFD_RELOC_MIPS_JUMP_SLOT:
      return &elf_mips_jump_slot_howto;
    default:
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }
}

static reloc_howto_type *
bfd_elf64_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < (sizeof (mips_elf64_howto_table_rela)
	    / sizeof (mips_elf64_howto_table_rela[0])); i++)
    if (mips_elf64_howto_table_rela[i].name != NULL
	&& strcasecmp (mips_elf64_howto_table_rela[i].name, r_name) == 0)
      return &mips_elf64_howto_table_rela[i];

  for (i = 0;
       i < (sizeof (mips16_elf64_howto_table_rela)
	    / sizeof (mips16_elf64_howto_table_rela[0]));
       i++)
    if (mips16_elf64_howto_table_rela[i].name != NULL
	&& strcasecmp (mips16_elf64_howto_table_rela[i].name, r_name) == 0)
      return &mips16_elf64_howto_table_rela[i];

  for (i = 0;
       i < (sizeof (micromips_elf64_howto_table_rela)
	    / sizeof (micromips_elf64_howto_table_rela[0]));
       i++)
    if (micromips_elf64_howto_table_rela[i].name != NULL
	&& strcasecmp (micromips_elf64_howto_table_rela[i].name, r_name) == 0)
      return &micromips_elf64_howto_table_rela[i];

  if (strcasecmp (elf_mips_gnu_vtinherit_howto.name, r_name) == 0)
    return &elf_mips_gnu_vtinherit_howto;
  if (strcasecmp (elf_mips_gnu_vtentry_howto.name, r_name) == 0)
    return &elf_mips_gnu_vtentry_howto;
  if (strcasecmp (elf_mips_gnu_rel16_s2.name, r_name) == 0)
    return &elf_mips_gnu_rel16_s2;
  if (strcasecmp (elf_mips_gnu_rela16_s2.name, r_name) == 0)
    return &elf_mips_gnu_rela16_s2;
  if (strcasecmp (elf_mips_gnu_pcrel32.name, r_name) == 0)
    return &elf_mips_gnu_pcrel32;
  if (strcasecmp (elf_mips_eh_howto.name, r_name) == 0)
    return &elf_mips_eh_howto;
  if (strcasecmp (elf_mips_copy_howto.name, r_name) == 0)
    return &elf_mips_copy_howto;
  if (strcasecmp (elf_mips_jump_slot_howto.name, r_name) == 0)
    return &elf_mips_jump_slot_howto;

  return NULL;
}

/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */

static reloc_howto_type *
mips_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
{
  switch (r_type)
    {
    case R_MIPS_GNU_VTINHERIT:
      return &elf_mips_gnu_vtinherit_howto;
    case R_MIPS_GNU_VTENTRY:
      return &elf_mips_gnu_vtentry_howto;
    case R_MIPS_GNU_REL16_S2:
      if (rela_p)
	return &elf_mips_gnu_rela16_s2;
      else
	return &elf_mips_gnu_rel16_s2;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
    case R_MIPS_EH:
      return &elf_mips_eh_howto;
    case R_MIPS_COPY:
      return &elf_mips_copy_howto;
    case R_MIPS_JUMP_SLOT:
      return &elf_mips_jump_slot_howto;
    default:
      if (r_type >= R_MICROMIPS_min && r_type < R_MICROMIPS_max)
	{
	  if (rela_p)
	    return &micromips_elf64_howto_table_rela[r_type - R_MICROMIPS_min];
	  else
	    return &micromips_elf64_howto_table_rel[r_type - R_MICROMIPS_min];
	}
      if (r_type >= R_MIPS16_min && r_type < R_MIPS16_max)
	{
	  if (rela_p)
	    return &mips16_elf64_howto_table_rela[r_type - R_MIPS16_min];
	  else
	    return &mips16_elf64_howto_table_rel[r_type - R_MIPS16_min];
	}
      BFD_ASSERT (r_type < (unsigned int) R_MIPS_max);
      if (rela_p)
	return &mips_elf64_howto_table_rela[r_type];
      else
	return &mips_elf64_howto_table_rel[r_type];
      break;
    }
}

/* Prevent relocation handling by bfd for MIPS ELF64.  */

static void
mips_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			      arelent *cache_ptr ATTRIBUTE_UNUSED,
			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  BFD_ASSERT (0);
}

static void
mips_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr ATTRIBUTE_UNUSED,
			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
{
  BFD_ASSERT (0);
}

/* Since each entry in an SHT_REL or SHT_RELA section can represent up
   to three relocs, we must tell the user to allocate more space.  */

static long
mips_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  return (sec->reloc_count * 3 + 1) * sizeof (arelent *);
}

static long
mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */

static long
mips_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
			       arelent **relptr, asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
				       asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */

static bfd_boolean
mips_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
				  Elf_Internal_Shdr *rel_hdr,
				  bfd_size_type reloc_count,
				  arelent *relents, asymbol **symbols,
				  bfd_boolean dynamic)
{
  void *allocated;
  bfd_byte *native_relocs;
  arelent *relent;
  bfd_vma i;
  int entsize;
  bfd_boolean rela_p;

  allocated = bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    return FALSE;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
    goto error_return;

  native_relocs = allocated;

  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf64_Mips_External_Rel)
	      || entsize == sizeof (Elf64_Mips_External_Rela));

  if (entsize == sizeof (Elf64_Mips_External_Rel))
    rela_p = FALSE;
  else
    rela_p = TRUE;

  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
    {
      Elf64_Mips_Internal_Rela rela;
      bfd_boolean used_sym, used_ssym;
      int ir;

      if (entsize == sizeof (Elf64_Mips_External_Rela))
	mips_elf64_swap_reloca_in (abfd,
				   (Elf64_Mips_External_Rela *) native_relocs,
				   &rela);
      else
	mips_elf64_swap_reloc_in (abfd,
				  (Elf64_Mips_External_Rel *) native_relocs,
				  &rela);

      /* Each entry represents exactly three actual relocations.  */

      used_sym = FALSE;
      used_ssym = FALSE;
      for (ir = 0; ir < 3; ir++)
	{
	  enum elf_mips_reloc_type type;

	  switch (ir)
	    {
	    default:
	      abort ();
	    case 0:
	      type = (enum elf_mips_reloc_type) rela.r_type;
	      break;
	    case 1:
	      type = (enum elf_mips_reloc_type) rela.r_type2;
	      break;
	    case 2:
	      type = (enum elf_mips_reloc_type) rela.r_type3;
	      break;
	    }

	  /* Some types require symbols, whereas some do not.  */
	  switch (type)
	    {
	    case R_MIPS_NONE:
	    case R_MIPS_LITERAL:
	    case R_MIPS_INSERT_A:
	    case R_MIPS_INSERT_B:
	    case R_MIPS_DELETE:
	      relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	      break;

	    default:
	      if (! used_sym)
		{
		  if (rela.r_sym == STN_UNDEF)
		    relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
		  else
		    {
		      asymbol **ps, *s;

		      ps = symbols + rela.r_sym - 1;
		      s = *ps;
		      if ((s->flags & BSF_SECTION_SYM) == 0)
			relent->sym_ptr_ptr = ps;
		      else
			relent->sym_ptr_ptr = s->section->symbol_ptr_ptr;
		    }

		  used_sym = TRUE;
		}
	      else if (! used_ssym)
		{
		  switch (rela.r_ssym)
		    {
		    case RSS_UNDEF:
		      relent->sym_ptr_ptr =
			bfd_abs_section_ptr->symbol_ptr_ptr;
		      break;

		    case RSS_GP:
		    case RSS_GP0:
		    case RSS_LOC:
		      /* FIXME: I think these need to be handled using
			 special howto structures.  */
		      BFD_ASSERT (0);
		      break;

		    default:
		      BFD_ASSERT (0);
		      break;
		    }

		  used_ssym = TRUE;
		}
	      else
		relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;

	      break;
	    }

	  /* The address of an ELF reloc is section relative for an
	     object file, and absolute for an executable file or
	     shared library.  The address of a BFD reloc is always
	     section relative.  */
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
	    relent->address = rela.r_offset;
	  else
	    relent->address = rela.r_offset - asect->vma;

	  relent->addend = rela.r_addend;

	  relent->howto = mips_elf64_rtype_to_howto (type, rela_p);

	  ++relent;
	}
    }

  asect->reloc_count += (relent - relents) / 3;

  if (allocated != NULL)
    free (allocated);

  return TRUE;

 error_return:
  if (allocated != NULL)
    free (allocated);
  return FALSE;
}

/* Read the relocations.  On Irix 6, there can be two reloc sections
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */

static bfd_boolean
mips_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
			      asymbol **symbols, bfd_boolean dynamic)
{
  struct bfd_elf_section_data * const d = elf_section_data (asect);
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
    {
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = d->rel.hdr;
      reloc_count = rel_hdr ? NUM_SHDR_ENTRIES (rel_hdr) : 0;
      rel_hdr2 = d->rela.hdr;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT ((rel_hdr && asect->rel_filepos == rel_hdr->sh_offset)
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));

    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }

  /* Allocate space for 3 arelent structures for each Rel structure.  */
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;

  /* The slurp_one_reloc_table routine increments reloc_count.  */
  asect->reloc_count = 0;

  if (rel_hdr != NULL
      && ! mips_elf64_slurp_one_reloc_table (abfd, asect,
					     rel_hdr, reloc_count,
					     relents,
					     symbols, dynamic))
    return FALSE;
  if (rel_hdr2 != NULL
      && ! mips_elf64_slurp_one_reloc_table (abfd, asect,
					     rel_hdr2, reloc_count2,
					     relents + reloc_count * 3,
					     symbols, dynamic))
    return FALSE;

  asect->relocation = relents;
  return TRUE;
}

/* Write out the relocations.  */

static void
mips_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
{
  bfd_boolean *failedp = data;
  int count;
  Elf_Internal_Shdr *rel_hdr;
  unsigned int idx;

  /* If we have already failed, don't do anything.  */
  if (*failedp)
    return;

  if ((sec->flags & SEC_RELOC) == 0)
    return;

  /* The linker backend writes the relocs out itself, and sets the
     reloc_count field to zero to inhibit writing them here.  Also,
     sometimes the SEC_RELOC flag gets set even when there aren't any
     relocs.  */
  if (sec->reloc_count == 0)
    return;

  /* We can combine up to three relocs that refer to the same address
     if the latter relocs have no associated symbol.  */
  count = 0;
  for (idx = 0; idx < sec->reloc_count; idx++)
    {
      bfd_vma addr;
      unsigned int i;

      ++count;

      addr = sec->orelocation[idx]->address;
      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != addr
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  ++idx;
	}
    }

  rel_hdr = _bfd_elf_single_rel_hdr (sec);

  /* Do the actual relocation.  */

  if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rel))
    mips_elf64_write_rel (abfd, sec, rel_hdr, &count, data);
  else if (rel_hdr->sh_entsize == sizeof(Elf64_Mips_External_Rela))
    mips_elf64_write_rela (abfd, sec, rel_hdr, &count, data);
  else
    BFD_ASSERT (0);
}

static void
mips_elf64_write_rel (bfd *abfd, asection *sec,
		      Elf_Internal_Shdr *rel_hdr,
		      int *count, void *data)
{
  bfd_boolean *failedp = data;
  Elf64_Mips_External_Rel *ext_rel;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  ext_rel = (Elf64_Mips_External_Rel *) rel_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rel++)
    {
      arelent *ptr;
      Elf64_Mips_Internal_Rela int_rel;
      asymbol *sym;
      int n;
      unsigned int i;

      ptr = sec->orelocation[idx];

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	int_rel.r_offset = ptr->address;
      else
	int_rel.r_offset = ptr->address + sec->vma;

      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      int_rel.r_sym = n;
      int_rel.r_ssym = RSS_UNDEF;

      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      int_rel.r_type = ptr->howto->type;
      int_rel.r_type2 = (int) R_MIPS_NONE;
      int_rel.r_type3 = (int) R_MIPS_NONE;

      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != ptr->address
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  if (i == 0)
	    int_rel.r_type2 = r->howto->type;
	  else
	    int_rel.r_type3 = r->howto->type;

	  ++idx;
	}

      mips_elf64_swap_reloc_out (abfd, &int_rel, ext_rel);
    }

  BFD_ASSERT (ext_rel - (Elf64_Mips_External_Rel *) rel_hdr->contents
	      == *count);
}

static void
mips_elf64_write_rela (bfd *abfd, asection *sec,
		       Elf_Internal_Shdr *rela_hdr,
		       int *count, void *data)
{
  bfd_boolean *failedp = data;
  Elf64_Mips_External_Rela *ext_rela;
  unsigned int idx;
  asymbol *last_sym = 0;
  int last_sym_idx = 0;

  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
    {
      *failedp = TRUE;
      return;
    }

  ext_rela = (Elf64_Mips_External_Rela *) rela_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rela++)
    {
      arelent *ptr;
      Elf64_Mips_Internal_Rela int_rela;
      asymbol *sym;
      int n;
      unsigned int i;

      ptr = sec->orelocation[idx];

      /* The address of an ELF reloc is section relative for an object
	 file, and absolute for an executable file or shared library.
	 The address of a BFD reloc is always section relative.  */
      if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
	int_rela.r_offset = ptr->address;
      else
	int_rela.r_offset = ptr->address + sec->vma;

      sym = *ptr->sym_ptr_ptr;
      if (sym == last_sym)
	n = last_sym_idx;
      else if (bfd_is_abs_section (sym->section) && sym->value == 0)
	n = STN_UNDEF;
      else
	{
	  last_sym = sym;
	  n = _bfd_elf_symbol_from_bfd_symbol (abfd, &sym);
	  if (n < 0)
	    {
	      *failedp = TRUE;
	      return;
	    }
	  last_sym_idx = n;
	}

      int_rela.r_sym = n;
      int_rela.r_addend = ptr->addend;
      int_rela.r_ssym = RSS_UNDEF;

      if ((*ptr->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec
	  && ! _bfd_elf_validate_reloc (abfd, ptr))
	{
	  *failedp = TRUE;
	  return;
	}

      int_rela.r_type = ptr->howto->type;
      int_rela.r_type2 = (int) R_MIPS_NONE;
      int_rela.r_type3 = (int) R_MIPS_NONE;

      for (i = 0; i < 2; i++)
	{
	  arelent *r;

	  if (idx + 1 >= sec->reloc_count)
	    break;
	  r = sec->orelocation[idx + 1];
	  if (r->address != ptr->address
	      || ! bfd_is_abs_section ((*r->sym_ptr_ptr)->section)
	      || (*r->sym_ptr_ptr)->value != 0)
	    break;

	  /* We can merge the reloc at IDX + 1 with the reloc at IDX.  */

	  if (i == 0)
	    int_rela.r_type2 = r->howto->type;
	  else
	    int_rela.r_type3 = r->howto->type;

	  ++idx;
	}

      mips_elf64_swap_reloca_out (abfd, &int_rela, ext_rela);
    }

  BFD_ASSERT (ext_rela - (Elf64_Mips_External_Rela *) rela_hdr->contents
	      == *count);
}

/* Set the right machine number for a MIPS ELF file.  */

static bfd_boolean
mips_elf64_object_p (bfd *abfd)
{
  unsigned long mach;

  /* Irix 6 is broken.  Object file symbol tables are not always
     sorted correctly such that local symbols precede global symbols,
     and the sh_info field in the symbol table is not always right.  */
  if (elf64_mips_irix_compat (abfd) != ict_none)
    elf_bad_symtab (abfd) = TRUE;

  mach = _bfd_elf_mips_mach (elf_elfheader (abfd)->e_flags);
  bfd_default_set_arch_mach (abfd, bfd_arch_mips, mach);
  return TRUE;
}

/* Depending on the target vector we generate some version of Irix
   executables or "normal" MIPS ELF ABI executables.  */
static irix_compat_t
elf64_mips_irix_compat (bfd *abfd)
{
  if ((abfd->xvec == &bfd_elf64_bigmips_vec)
      || (abfd->xvec == &bfd_elf64_littlemips_vec))
    return ict_irix6;
  else
    return ict_none;
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf64_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 480:		/* Linux/MIPS - N64 kernel */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	size = 360;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf64_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 136:		/* Linux/MIPS - N64 kernel elf_prpsinfo */
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf64_ecoff_debug_swap =
{
  /* Symbol table magic number.  */
  magicSym2,
  /* Alignment of debugging information.  E.g., 4.  */
  8,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  _bfd_mips_elf_read_ecoff_info
};

/* Relocations in the 64 bit MIPS ELF ABI are more complex than in
   standard ELF.  This structure is used to redirect the relocation
   handling routines.  */

const struct elf_size_info mips_elf64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_Mips_External_Rel),
  sizeof (Elf64_Mips_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  4,		/* hash-table entry size */
  3,		/* internal relocations per external relocations */
  64,		/* arch_size */
  3,		/* log_file_align */
  ELFCLASS64,
  EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_checksum_contents,
  mips_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  mips_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  mips_elf64_be_swap_reloc_in,
  mips_elf64_be_swap_reloc_out,
  mips_elf64_be_swap_reloca_in,
  mips_elf64_be_swap_reloca_out
};

#define ELF_ARCH			bfd_arch_mips
#define ELF_TARGET_ID			MIPS_ELF_DATA
#define ELF_MACHINE_CODE		EM_MIPS

#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
#define elf_info_to_howto		mips_elf64_info_to_howto_rela
#define elf_info_to_howto_rel		mips_elf64_info_to_howto_rel
#define elf_backend_object_p		mips_elf64_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
#define elf_backend_section_from_bfd_section \
				_bfd_mips_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook \
				_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_create_dynamic_sections \
				_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
#define elf_backend_merge_symbol_attribute \
				_bfd_mips_elf_merge_symbol_attribute
#define elf_backend_get_target_dtag	_bfd_mips_elf_get_target_dtag
#define elf_backend_adjust_dynamic_symbol \
				_bfd_mips_elf_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
				_bfd_mips_elf_always_size_sections
#define elf_backend_size_dynamic_sections \
				_bfd_mips_elf_size_dynamic_sections
#define elf_backend_init_index_section	_bfd_elf_init_1_index_section
#define elf_backend_relocate_section    _bfd_mips_elf_relocate_section
#define elf_backend_finish_dynamic_symbol \
				_bfd_mips_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
				_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_final_write_processing \
				_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
				_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_mips_irix_compat	elf64_mips_irix_compat
#define elf_backend_mips_rtype_to_howto	mips_elf64_rtype_to_howto
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
#define elf_backend_size_info		mips_elf64_size_info

#define elf_backend_grok_prstatus	elf64_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf64_mips_grok_psinfo

#define elf_backend_got_header_size	(8 * MIPS_RESERVED_GOTNO)

/* MIPS ELF64 can use a mixture of REL and RELA, but some Relocations
   work better/work only in RELA, so we default to this.  */
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1
#define elf_backend_rela_plts_and_copies_p 0
#define elf_backend_plt_readonly	1
#define elf_backend_plt_sym_val		_bfd_mips_elf_plt_sym_val

#define elf_backend_sign_extend_vma	TRUE

#define elf_backend_write_section	_bfd_mips_elf_write_section

/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit
   MIPS-specific function only applies to IRIX5, which had no 64-bit
   ABI.  */
#define bfd_elf64_bfd_is_target_special_symbol \
					_bfd_mips_elf_is_target_special_symbol
#define bfd_elf64_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf64_find_inliner_info	_bfd_mips_elf_find_inliner_info
#define bfd_elf64_new_section_hook	_bfd_mips_elf_new_section_hook
#define bfd_elf64_set_section_contents	_bfd_mips_elf_set_section_contents
#define bfd_elf64_bfd_get_relocated_section_contents \
				_bfd_elf_mips_get_relocated_section_contents
#define bfd_elf64_bfd_link_hash_table_create \
				_bfd_mips_elf_link_hash_table_create
#define bfd_elf64_bfd_final_link	_bfd_mips_elf_final_link
#define bfd_elf64_bfd_merge_private_bfd_data \
				_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf64_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
#define bfd_elf64_bfd_print_private_bfd_data \
				_bfd_mips_elf_print_private_bfd_data

#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
#define bfd_elf64_bfd_relax_section     _bfd_mips_relax_section
#define bfd_elf64_mkobject		_bfd_mips_elf_mkobject

/* MIPS ELF64 archive functions.  */
#define bfd_elf64_archive_functions
extern bfd_boolean bfd_elf64_archive_slurp_armap
  (bfd *);
extern bfd_boolean bfd_elf64_archive_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int);
#define bfd_elf64_archive_slurp_extended_name_table \
			_bfd_archive_coff_slurp_extended_name_table
#define bfd_elf64_archive_construct_extended_name_table \
			_bfd_archive_coff_construct_extended_name_table
#define bfd_elf64_archive_truncate_arname \
			_bfd_archive_coff_truncate_arname
#define bfd_elf64_archive_read_ar_hdr	_bfd_archive_coff_read_ar_hdr
#define bfd_elf64_archive_write_ar_hdr	_bfd_archive_coff_write_ar_hdr
#define bfd_elf64_archive_openr_next_archived_file \
			_bfd_archive_coff_openr_next_archived_file
#define bfd_elf64_archive_get_elt_at_index \
			_bfd_archive_coff_get_elt_at_index
#define bfd_elf64_archive_generic_stat_arch_elt \
			_bfd_archive_coff_generic_stat_arch_elt
#define bfd_elf64_archive_update_armap_timestamp \
			_bfd_archive_coff_update_armap_timestamp

/* The SGI style (n)64 NewABI.  */
#define TARGET_LITTLE_SYM		bfd_elf64_littlemips_vec
#define TARGET_LITTLE_NAME		"elf64-littlemips"
#define TARGET_BIG_SYM			bfd_elf64_bigmips_vec
#define TARGET_BIG_NAME			"elf64-bigmips"

#define ELF_MAXPAGESIZE			0x10000
#define ELF_COMMONPAGESIZE		0x1000

#include "elf64-target.h"

/* The SYSV-style 'traditional' (n)64 NewABI.  */
#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#undef ELF_MAXPAGESIZE
#undef ELF_COMMONPAGESIZE

#define TARGET_LITTLE_SYM		bfd_elf64_tradlittlemips_vec
#define TARGET_LITTLE_NAME		"elf64-tradlittlemips"
#define TARGET_BIG_SYM			bfd_elf64_tradbigmips_vec
#define TARGET_BIG_NAME			"elf64-tradbigmips"

#define ELF_MAXPAGESIZE			0x10000
#define ELF_COMMONPAGESIZE		0x1000
#define elf64_bed			elf64_tradbed

/* Include the target file again for this target.  */
#include "elf64-target.h"


/* FreeBSD support.  */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define	TARGET_LITTLE_SYM		bfd_elf64_tradlittlemips_freebsd_vec
#define	TARGET_LITTLE_NAME		"elf64-tradlittlemips-freebsd"
#define	TARGET_BIG_SYM			bfd_elf64_tradbigmips_freebsd_vec
#define	TARGET_BIG_NAME			"elf64-tradbigmips-freebsd"

#undef	ELF_OSABI
#define	ELF_OSABI			ELFOSABI_FREEBSD

/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void
elf_fbsd_post_process_headers (bfd *abfd, struct bfd_link_info *info)
{
  _bfd_elf_set_osabi (abfd, info);
}

#undef	elf_backend_post_process_headers
#define	elf_backend_post_process_headers	elf_fbsd_post_process_headers
#undef	elf64_bed
#define elf64_bed				elf64_fbsd_tradbed

#include "elf64-target.h"
@


1.110
log
@2013-05-06  Paul Brook  <paul@@codesourcery.com>

        include/elf/
        * mips.h (R_MIPS_PC32): Update comment.

        * elf64-mips.c (elf_mips_gnu_pcrel32): New.
        (bfd_elf64_bfd_reloc_type_lookup, bfd_elf64_bfd_reloc_name_lookup,
        mips_elf64_rtype_to_howto): Handle R_MIPS_PC32.
        * elfn32-mips.c (elf_mips_gnu_pcrel32): New.
        (bfd_elfn32_bfd_reloc_type_lookup, bfd_elfn32_bfd_reloc_name_lookup,
        mips_elfn32_rtype_to_howto): Handle R_MIPS_PC32.

2013-05-06  Paul Brook  <paul@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

        gas/
        * config/tc-mips.c (md_pcrel_from): Handle BFD_RELOC_32_PCREL.
        (limited_pcrel_reloc_p): Likewise.
	(md_apply_fix): Likewise.
	(tc_gen_reloc): Likewise.
@
text
@d2674 17
d3296 2
d3347 2
d3375 2
@


1.109
log
@bfd/
	* elf32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto):
	Use _bfd_mips_elf_generic_reloc instead of bfd_elf_generic_reloc.
	* elfn32-mips.c: Likewise.
	* elf64-mips.c: Likewise.
@
text
@d2625 17
d3277 2
d3326 2
d3352 2
@


1.108
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d2635 1
a2635 1
	 bfd_elf_generic_reloc,	/* special_function */
d2651 1
a2651 1
	 bfd_elf_generic_reloc,	/* special_function */
@


1.107
log
@	* elf64-mips.c (micromips_elf64_howto_table_rel): Add
	R_MICROMIPS_SCN_DISP and R_MICROMIPS_JALR.
	(micromips_elf64_howto_table_rela): Likewise.
	(micromips_reloc_map): Add BFD_RELOC_MICROMIPS_JALR.
	* elfn32-mips.c (elf_micromips_howto_table_rel): Add
	R_MICROMIPS_SCN_DISP and R_MICROMIPS_JALR.
	(elf_micromips_howto_table_rela): Likewise.
	(micromips_reloc_map): Add BFD_RELOC_MICROMIPS_JALR.
@
text
@d4011 1
a4011 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d4014 1
a4014 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 32);
d4037 1
a4037 1
	elf_tdata (abfd)->core_program
d4039 1
a4039 1
	elf_tdata (abfd)->core_command
d4048 1
a4048 1
    char *command = elf_tdata (abfd)->core_command;
@


1.106
log
@	bfd/
	* elf32-mips.c (bfd_elf32_mkobject): New macro.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): New prototype.
	* elfxx-mips.c (mips_elf_obj_tdata): New struct.
	(mips_elf_tdata): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(mips_elf_merge_obj_attributes): Report the originating input BFD
	on attribute conflicts.

	ld/testsuite/
	* ld-mips-elf/attr-gnu-4-12.d: Update the warning message.
	* ld-mips-elf/attr-gnu-4-13.d: Likewise.
	* ld-mips-elf/attr-gnu-4-14.d: Likewise.
	* ld-mips-elf/attr-gnu-4-15.d: Likewise.
	* ld-mips-elf/attr-gnu-4-21.d: Likewise.
	* ld-mips-elf/attr-gnu-4-23.d: Likewise.
	* ld-mips-elf/attr-gnu-4-24.d: Likewise.
	* ld-mips-elf/attr-gnu-4-25.d: Likewise.
	* ld-mips-elf/attr-gnu-4-31.d: Likewise.
	* ld-mips-elf/attr-gnu-4-32.d: Likewise.
	* ld-mips-elf/attr-gnu-4-34.d: Likewise.
	* ld-mips-elf/attr-gnu-4-35.d: Likewise.
	* ld-mips-elf/attr-gnu-4-41.d: Likewise.
	* ld-mips-elf/attr-gnu-4-42.d: Likewise.
	* ld-mips-elf/attr-gnu-4-43.d: Likewise.
	* ld-mips-elf/attr-gnu-4-45.d: Likewise.
	* ld-mips-elf/attr-gnu-4-51.d: Likewise.
@
text
@d2187 31
d2529 31
d3217 2
@


1.105
log
@	* elf64-mips.c (mips16_elf64_howto_table_rela): Correct src_mask
	field initializers throughout.
	* elfn32-mips.c (elf_mips16_howto_table_rela): Likewise.
@
text
@d4169 1
@


1.104
log
@	* elf64-mips.c (elf_backend_got_header_size): Correct definition.
	* elfxx-mips.c (_bfd_mips_elf_adjust_dynamic_symbol): Use the ELF
	backend's GOT header size instead of hardcoding it.
@
text
@d1806 1
a1806 1
	 0x0000ffff,		/* src_mask */
d1821 1
a1821 1
	 0x0000ffff,		/* src_mask */
d1836 1
a1836 1
	 0x0000ffff,		/* src_mask */
d1851 1
a1851 1
	 0x0000ffff,		/* src_mask */
d1866 1
a1866 1
	 0x0000ffff,		/* src_mask */
d1881 1
a1881 1
	 0x0000ffff,		/* src_mask */
d1896 1
a1896 1
	 0x0000ffff,		/* src_mask */
@


1.104.4.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d1806 1
a1806 1
	 0,			/* src_mask */
d1821 1
a1821 1
	 0,			/* src_mask */
d1836 1
a1836 1
	 0,			/* src_mask */
d1851 1
a1851 1
	 0,			/* src_mask */
d1866 1
a1866 1
	 0,			/* src_mask */
d1881 1
a1881 1
	 0,			/* src_mask */
d1896 1
a1896 1
	 0,			/* src_mask */
@


1.103
log
@	* elf64-mips.c (mips_elf64_be_swap_reloc_out): Also make sure
	the third reloc offset is the same as the first.
@
text
@d4129 1
a4129 1
#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
@


1.102
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@d2711 1
@


1.101
log
@	* elf64-mips.c (mips_elf64_howto_table_rela): Set src_mask to
	zero throughout.
	(mips16_elf64_howto_table_rela): Likewise.
	(micromips_elf64_howto_table_rela): Likewise.
	* elfn32-mips.c (elf_mips_howto_table_rela): Likewise.
	(elf_mips16_howto_table_rela): Likewise.
	(elf_micromips_howto_table_rela): Likewise.
@
text
@d1593 105
d1794 105
d3121 9
@


1.100
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d1343 1
a1343 1
	 MINUS_ONE,		/* src_mask */
d1357 1
a1357 1
	 MINUS_ONE,		/* src_mask */
d1372 1
a1372 1
	 0x0000ffff,		/* src_mask */
d1387 1
a1387 1
	 0x0000ffff,		/* src_mask */
d1402 1
a1402 1
	 0x0000ffff,		/* src_mask */
d1417 1
a1417 1
	 0x0000ffff,		/* src_mask */
d1432 1
a1432 1
	 0x0000ffff,		/* src_mask */
d1449 1
a1449 1
	 MINUS_ONE,		/* src_mask */
d1464 1
a1464 1
	 0x0000ffff,		/* src_mask */
d1479 1
a1479 1
	 0x0000ffff,		/* src_mask */
d1611 1
a1611 1
	 0x3ffffff,		/* src_mask */
d1626 1
a1626 1
	 0x0000ffff,		/* src_mask */
d1641 1
a1641 1
	 0x0000ffff,		/* src_mask */
d1656 1
a1656 1
	 0x0000ffff,		/* src_mask */
d1671 1
a1671 1
	 0x0000ffff,		/* src_mask */
d1686 1
a1686 1
	 0x0000ffff,		/* src_mask */
d1999 1
a1999 1
	 0x3ffffff,		/* src_mask */
d2014 1
a2014 1
	 0x0000ffff,		/* src_mask */
d2029 1
a2029 1
	 0x0000ffff,		/* src_mask */
d2044 1
a2044 1
	 0x0000ffff,		/* src_mask */
d2059 1
a2059 1
	 0x0000ffff,		/* src_mask */
d2074 1
a2074 1
	 0x0000ffff,		/* src_mask */
d2089 1
a2089 1
	 0x0000007f,		/* src_mask */
d2103 1
a2103 1
	 0x000003ff,		/* src_mask */
d2117 1
a2117 1
	 0x0000ffff,		/* src_mask */
d2132 1
a2132 1
	 0x0000ffff,		/* src_mask */
d2150 1
a2150 1
	 0x0000ffff,		/* src_mask */
d2165 1
a2165 1
	 0x0000ffff,		/* src_mask */
d2180 1
a2180 1
	 0x0000ffff,		/* src_mask */
d2195 1
a2195 1
	 0x0000ffff,		/* src_mask */
d2210 1
a2210 1
	 0x0000ffff,		/* src_mask */
d2225 1
a2225 1
	 MINUS_ONE,		/* src_mask */
d2240 1
a2240 1
	 0x0000ffff,		/* src_mask */
d2255 1
a2255 1
	 0x0000ffff,		/* src_mask */
d2270 1
a2270 1
	 0x0000ffff,		/* src_mask */
d2285 1
a2285 1
	 0x0000ffff,		/* src_mask */
@


1.100.2.1
log
@
2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	Backport from mainline:

	2011-12-19  Chung-Lin Tang  <cltang@@codesourcery.com>

	gas/
	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
	entries.
	(mips16_percent_op): Add MIPS16 TLS relocation ops.
	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
	directive string and reloc type as function parameters. Update
	comments.
	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
	(s_tprelword,s_tpreldword): New functions.

	include/
	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.

	bfd/
	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
	entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel,
	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel,
	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
	mappings.
	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
@
text
@a1592 105

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
a1688 105

  /* MIPS16 TLS general dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_GD,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GD",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic variable reference.  */
  HOWTO (R_MIPS16_TLS_LDM,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_LDM",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS local dynamic offset.  */
  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_GOTTPREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_HI16", /* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* MIPS16 TLS thread pointer offset.  */
  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 _bfd_mips_elf_generic_reloc, /* special_function */
	 "R_MIPS16_TLS_TPREL_LO16", /* name */
	 FALSE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
a2910 9
  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
@


1.99
log
@bfd/
2010-12-23  Robert Millan  <rmh@@gnu.org>

	* config.bfd: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.host: Likewise.
	* configure.in: Support for `bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.
	* configure: Regenerate.
	* elf32-mips.c: New target for FreeBSD support
	(same as traditional MIPS but overrides ELF_OSABI
	with ELFOSABI_FREEBSD).
	* elf64-mips.c: Likewise.
	* elfn32-mips.c: Likewise.
	* targets.c (_bfd_target_vector): Add
	`bfd_elf32_ntradbigmips_freebsd_vec',
	`bfd_elf32_ntradlittlemips_freebsd_vec',
	`bfd_elf32_tradbigmips_freebsd_vec',
	`bfd_elf32_tradlittlemips_freebsd_vec',
	`bfd_elf64_tradbigmips_freebsd_vec' and
	`bfd_elf64_tradlittlemips_freebsd_vec'.

ld/
2010-12-14  Robert Millan  <rmh@@gnu.org>

	* configure.tgt: Recognize mips-freebsd and mips-kfreebsd-gnu.

	* emulparams/elf32btsmip_fbsd.sh: New file.
	* emulparams/elf32btsmipn32_fbsd.sh: Likewise.
	* emulparams/elf32ltsmip_fbsd.sh: Likewise.
	* emulparams/elf32ltsmipn32_fbsd.sh: Likewise.
	* emulparams/elf64btsmip_fbsd.sh: Likewise.
	* emulparams/elf64ltsmip_fbsd.sh: Likewise.

	* Makefile.am: Add build rules for `eelf32btsmip_fbsd.c',
	`eelf32btsmipn32_fbsd.c', `eelf32ltsmip_fbsd.c',
	`eelf32ltsmipn32_fbsd.c', `eelf64btsmip_fbsd.c' and
	`eelf64ltsmip_fbsd.c'.
	* Makefile.in: Regenerate.

gas/
2010-12-19  Robert Millan  <rmh@@gnu.org>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.c (ELF_TARGET): New macro.  Generates target
	names accordingly to whether TE_FreeBSD and whether TE_TMIPS
	are defined.
	(mips_target_format): Refactor code using ELF_TARGET().
	(support_64bit_objects): Likewise.

	* configure.in: Recognize mips-freebsd and mips-kfreebsd-gnu.
	* configure.tgt: Likewise.
	* configure: Regenerate.

binutils/testsuite/
	* binutils-all/readelf.exp: Handle MIPS FreeBSD targets.

gas/testsuite/
	* gas/mips/e32el-rel2.d: Accept any file format.
	* gas/mips/elf-rel.d: Likewise.
	* gas/mips/elf-rel2.d: Likewise.
	* gas/mips/elf-rel3.d: Likewise.
	* gas/mips/elfel-rel.d: Likewise.
	* gas/mips/elfel-rel2.d: Likewise.
	* gas/mips/elfel-rel3.d: Likewise.
	* gas/mips/ldstla-32-mips3-shared.d: Likewise.
	* gas/mips/ldstla-32-mips3.d: Likewise.
	* gas/mips/ldstla-32-shared.d: Likewise.
	* gas/mips/ldstla-32.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/noat-1.d: Likewise.
	* gas/mips/set-arch.d: Likewise.
	* gas/mips/tls-o32.d: Likewise.

ld/testsuite/
	* ld-mips-elf/mips-elf-flags.exp: Handle FreeBSD targets.
	* ld-mips-elf/mips-elf.exp: Likewise.
	* ld-mips-elf/mips16-call-global.d: Accept any file format.
	* ld-mips-elf/mips16-intermix.d: Likewise.
@
text
@d1691 599
d2833 2
a2834 2
  _bfd_mips16_elf_reloc_unshuffle (abfd, reloc_entry->howto->type, FALSE,
				   location);
d2838 2
a2839 2
  _bfd_mips16_elf_reloc_shuffle (abfd, reloc_entry->howto->type, !relocatable,
				 location);
d2913 23
d2947 1
d2963 7
d3007 8
d3052 7
d3927 2
@


1.98
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d3357 33
@


1.97
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d2725 3
a2727 3
      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
d2731 1
a2731 1
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
d2759 11
a2769 4
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
a2770 8
  if (d->rel_hdr2 != NULL)
    {
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
	return FALSE;
    }
d2829 1
a2829 1
  rel_hdr = &elf_section_data (sec)->rel_hdr;
@


1.96
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2622 1
a2622 1
		  if (rela.r_sym == 0)
@


1.95
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d3210 1
a3288 1
#define bfd_elf64_mkobject		_bfd_mips_elf_mkobject
@


1.94
log
@	* elf64-mips.c (mips_elf64_howto_table_rela)
	[R_MIPS_TLS_DTPMOD64]: Clear partial_inplace.
	[R_MIPS_TLS_DTPREL64, R_MIPS_TLS_GD, R_MIPS_TLS_LDM]: Likewise.
	[R_MIPS_TLS_DTPREL_HI16, R_MIPS_TLS_DTPREL_LO16]: Likewise.
	[R_MIPS_TLS_GOTTPREL, R_MIPS_TLS_TPREL64]: Likewise.
	[R_MIPS_TLS_TPREL_HI16, R_MIPS_TLS_TPREL_LO16]: Likewise.
	* elfn32-mips.c (elf_mips_howto_table_rela)
	[R_MIPS_TLS_DTPMOD32]: Likewise.
	[R_MIPS_TLS_DTPREL32, R_MIPS_TLS_GD, R_MIPS_TLS_LDM]: Likewise.
	[R_MIPS_TLS_DTPREL_HI16, R_MIPS_TLS_DTPREL_LO16]: Likewise.
	[R_MIPS_TLS_GOTTPREL, R_MIPS_TLS_TPREL32]: Likewise.
	[R_MIPS_TLS_TPREL_HI16, R_MIPS_TLS_TPREL_LO16]: Likewise.
@
text
@d3086 1
a3086 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);
@


1.93
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@d1342 1
a1342 1
	 TRUE,			/* partial_inplace */
d1356 1
a1356 1
	 TRUE,			/* partial_inplace */
d1371 1
a1371 1
	 TRUE,			/* partial_inplace */
d1386 1
a1386 1
	 TRUE,			/* partial_inplace */
d1401 1
a1401 1
	 TRUE,			/* partial_inplace */
d1416 1
a1416 1
	 TRUE,			/* partial_inplace */
d1431 1
a1431 1
	 TRUE,			/* partial_inplace */
d1448 1
a1448 1
	 TRUE,			/* partial_inplace */
d1463 1
a1463 1
	 TRUE,			/* partial_inplace */
d1478 1
a1478 1
	 TRUE,			/* partial_inplace */
@


1.92
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d3 2
a4 1
   2006, 2007, 2008 Free Software Foundation, Inc.
@


1.91
log
@	* elf64-mips.c (mips_elf64_howto_table_rela): Add support for
	R_MIPS_TLS_DTPMOD64 and R_MIPS_TLS_TPREL64, replacing the
	respective stubs.
@
text
@d3316 1
@


1.90
log
@update copyright dates
@
text
@d1331 14
a1344 1
  EMPTY_HOWTO (R_MIPS_TLS_DTPMOD64),
d1435 1
d1437 14
a1450 1
  EMPTY_HOWTO (R_MIPS_TLS_TPREL64),
@


1.89
log
@2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* elf32-mips.c (mips_vxworks_copy_howto_rela): Replace with...
	(elf_mips_copy_howto): ...this howto.  Clear the size fields.
	(mips_vxworks_jump_slot_howto_rela): Replace with...
	(elf_mips_jump_slot_howto): ...this howto.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_plt_readonly): Define.
	(elf_backend_plt_sym_val): Define for non-VxWorks targets.
	(mips_vxworks_bfd_reloc_type_lookup): Delete.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(mips_vxworks_rtype_to_howto): Likewise.
	(elf_backend_want_dynbss): Don't define for VxWorks.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	* elfn32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_n32_rtype_to_howto): Handle R_MIPS_COPY and
	R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elf64-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf64_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf64_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Delete.
	(_bfd_mips_elf_use_plts_and_copy_relocs, _bfd_mips_elf_init_stubs)
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): Declare.
	* elfxx-mips.c (mips_elf_la25_stub): New structure.
	(LA25_LUI, LA25_J, LA25_ADDIU): New macros.
	(mips_elf_link_hash_entry): Add "la25_stubs", "has_static_relocs"
	and "has_nonpic_branches" fields.  Remove "is_relocation_target" and
	"is_branch_target".
	(mips_elf_link_hash_table): Add blank lines.  Add
	"use_plts_and_copy_relocs", "reserved_gotno", "strampoline",
	"la25_stubs" and "add_stub_section" fields.
	(mips_htab_traverse_info): New structure.
	(PIC_OBJECT_P, MIPS_ELF_LOAD_WORD): New macros.
	(MIPS_RESERVED_GOTNO): Delete.
	(mips_o32_exec_plt0_entry, mips_n32_exec_plt0_entry)
	(mips_n64_exec_plt0_entry, mips_exec_plt_entry): New tables.
	(mips_elf_link_hash_newfunc): Update after the changes to
	mips_elf_link_hash_entry.
	(mips_elf_check_mips16_stubs): Replace the DATA parameter with
	an INFO parameter.  Don't look through warnings symbols here;
	do it in mips_elf_check_symbols instead.
	(mips_elf_create_stub_symbol): New function.
	(mips_elf_la25_stub_hash, mips_elf_la25_stub_eq): New functions.
	(_bfd_mips_elf_init_stubs, mips_elf_local_pic_function_p): Likewise.
	(mips_elf_add_la25_intro, mips_elf_add_la25_trampoline): Likewise.
	(mips_elf_add_la25_stub, mips_elf_check_symbols): New functions.
	(mips_elf_gotplt_index): Check for VxWorks.
	(mips_elf_output_dynamic_relocation): Take the relocation index
	as an extra parameter.  Do not increment reloc_count here.
	(mips_elf_initialize_tls_slots): Update the calls to
	mips_elf_output_dynamic_relocation accordingly.
	(mips_elf_multi_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Don't allocate reserved GOT
	entries here.  Unconditionally create .got.plt, but don't
	set its alignment here.
	(mips_elf_relocation_needs_la25_stub): New function.
	(mips_elf_calculate_relocation): Redirect branches and jumps to
	a non-PIC stub if one exists.  Check !h->has_static_relocs instead
	of !htab->is_vxworks when deciding whether to create dynamic
	relocations for R_MIPS_32, R_MIPS_REL32 and R_MIPS_64.
	(_bfd_mips_elf_create_dynamic_sections): Unconditionally call
	_bfd_elf_create_dynamic_sections.  Unconditionally set up
	htab->splt and htab->sdynbss.  Set htab->srelplt to ".rel.plt"
	if !htab->is_vxworks.  Add non-VxWorks values of
	htab->plt_header_size and htab->plt_entry_size.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	non-branch static relocations.  Set has_nonpic_branches when an la25
	stub might be required.  Set can_make_dynamic_p to TRUE if R_MIPS_32,
	R_MIPS_REL32 and R_MIPS_64 relocations can be made dynamic,
	rather than duplicating the condition.  Do not make them dynamic
	for read-only sections in non-PIC executable objects.
	Do not protect this code with dynobj == NULL || htab->sgot == NULL;
	handle each group of cases separately.  Add a default case that
	sets has_static_relocs for non-GOT relocations that cannot be
	made dynamic.  Don't set is_relocation_target and is_branch_target.
	Reject non-PIC static relocations in shared objects.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): Fold into...
	(_bfd_mips_elf_adjust_dynamic_symbol): ...here, using
	htab->use_plts_and_copy_relocs instead of htab->is_vxworks
	to select PLT and copy-reloc handling.  Set the alignment of
	.plt and .got.plt when allocating the first entry.  Generalize
	code to handle REL as well as RELA sections and 64-bit as well as
	32-bit GOT entries.  Complain if we find a static-only reloc
	against an externally-defined symbol and if we cannot create
	dynamic relocations for it.  Allocate copy relocs using
	mips_elf_allocate_dynamic_relocations on non-VxWorks targets.
	Set possibly_dynamic_relocs to 0 when using PLTs or copy relocs.
	Skip reserved .got.plt entries.
	(_bfd_mips_elf_always_size_sections): Use mips_elf_check_symbols
	instead of mips_elf_check_mips16_stubs to process each symbol.
	Do the traversal for relocatable objects too.
	(mips_elf_lay_out_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(_bfd_mips_elf_size_dynamic_sections): Exclude sdynbss if it
	is empty.  Extend the DT_PLTREL, DT_JMPREL and DT_PLTRELSZ handling
	to non-VxWorks targets.  Only add DT_REL{,A}, DT_REL{,A}SZ and
	DT_REL{,A}ENT if .rel.dyn is nonempty.  Create a symbol for the
	PLT.  Allocate a nop at the end of the PLT.  Allocate DT_MIPS_PLTGOT.
	(mips_elf_create_la25_stub_info): New function.
	(_bfd_mips_elf_finish_dynamic_symbol): Write out PLT entries
	and copy relocs where necessary.  Check pointer_equality_needed.
	(mips_finish_exec_plt): New function.
	(_bfd_mips_elf_finish_dynamic_sections): Always set DT_PLTGOT
	to the beginning of htab->sgot.  Use htab->reserved_gotno instead
	of MIPS_RESERVED_GOTNO.  Assert htab->use_plts_and_copy_relocs
	instead of htab->is_vxworks for DT_PLTREL, DT_PLTRELSZ and DT_JMPREL.
	Set DT_PLTREL to DT_REL instead of DT_RELA on non-VxWorks targets.
	Use mips_finish_exec_plt to create non-VxWorks PLT headers.  Set
	DT_MIPS_PLTGOT.
	(_bfd_mips_elf_copy_indirect_symbol): Copy has_static_relocs
	from the indirect symbol to the direct symbol.  Also copy
	has_nonpic_branches for indirect symbols.
	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
	DT_MIPS_RWPLT.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): Set
	use_plts_and_copy_relocs to TRUE.  Use TRUE rather than 1
	when setting is_vxworks.
	(_bfd_mips_elf_use_plts_and_copy_relocs): New function.
	(_bfd_mips_elf_final_link): Call mips_elf_create_la25_stub for
	each la25_stub.
	(_bfd_mips_elf_merge_private_bfd_data): Treat dynamic objects
	as PIC.  Generalize message about linking PIC and non-PIC.
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): New
	functions.
	* reloc.c: Update comment near BFD_RELOC_MIPS_JUMP_SLOT.
	* bfd-in2.h: Regenerated.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* readelf.c (get_mips_symbol_other): Handle STO_MIPS_PLT and
	STO_MIPS_PIC.
	(slurp_rela_relocs, slurp_rel_relocs): Handle MIPS ELF64 here.
	(dump_relocations, debug_apply_relocations): Don't handle it here.
	(get_mips_dynamic_type): Handle DT_MIPS_PLTGOT and DT_MIPS_RWPLT.
	(print_mips_pltgot_entry): New function.
	(process_mips_specific): Dump the PLT GOT.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/tc-mips.c (OPTION_CALL_NONPIC): New macro.
	(OPTION_NON_SHARED, OPTION_XGOT, OPTION_MABI, OPTION_32)
	(OPTION_N32, OPTION_64, OPTION_MDEBUG, OPTION_NO_MDEBUG)
	(OPTION_PDR, OPTION_NO_PDR, OPTION_MVXWORKS_PIC): Bump by 1.
	(md_longopts): Add -call_nonpic.
	(md_parse_option): Handle OPTION_CALL_NONPIC.
	(md_show_usage): Add -call_nonpic.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/call-nonpic-1.s, gas/mips/call-nonpic-1.d: New test.
	* gas/mips/mips.exp: Run it.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* mips.h (STO_MIPS_PLT, ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT)
	(STO_MIPS_PIC, DT_MIPS_PLTGOT, DT_MIPS_RWPLT): New macros.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* emulparams/elf32bmip.sh (GOT): Define, moving .got.plt to...
	(OTHER_RELRO_SECTIONS, OTHER_READWRITE_SECTIONS): ...one of these
	two variables.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emultempl/mipself.em: Include ldctor.h, elf/mips.h and elfxx-mips.h.
	(is_mips_elf): New macro.
	(stub_file, stub_bfd): New variables.
	(hook_stub_info): New structure.
	(hook_in_stub): New function.
	(mips_add_stub_section): Likewise.
	(mips_create_output_section_statements): Likewise.
	(mips_before_allocation): Likewise.
	(real_func): New variable.
	(mips_for_each_input_file_wrapper): New function.
	(mips_lang_for_each_input_file): Likewise.
	(lang_for_each_input_file): Define.
	(LDEMUL_BEFORE_ALLOCATION): Likewise.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Likewise.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ld-mips-elf/mips16-pic-3a.s,
	ld-mips-elf/mips16-pic-3b.s,
	ld-mips-elf/mips16-pic-3.dd,
	ld-mips-elf/mips16-pic-3.gd,
	ld-mips-elf/mips16-pic-3.rd,
	ld-mips-elf/mips16-pic-3.inc,
	ld-mips-elf/pic-and-nonpic-1a.s,
	ld-mips-elf/pic-and-nonpic-1b.s,
	ld-mips-elf/pic-and-nonpic-1.ld,
	ld-mips-elf/pic-and-nonpic-1.dd,
	ld-mips-elf/pic-and-nonpic-1.nd,
	ld-mips-elf/pic-and-nonpic-1-rel.dd,
	ld-mips-elf/pic-and-nonpic-1-rel.nd,
	ld-mips-elf/pic-and-nonpic-2a.s,
	ld-mips-elf/pic-and-nonpic-2b.s,
	ld-mips-elf/pic-and-nonpic-2.d,
	ld-mips-elf/pic-and-nonpic-3a.s,
	ld-mips-elf/pic-and-nonpic-3a.ld,
	ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3a.gd,
	ld-mips-elf/pic-and-nonpic-3a.sd,
	ld-mips-elf/pic-and-nonpic-3b.s,
	ld-mips-elf/pic-and-nonpic-3b.ld,
	ld-mips-elf/pic-and-nonpic-3b.ad,
	ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.gd,
	ld-mips-elf/pic-and-nonpic-3b.nd,
	ld-mips-elf/pic-and-nonpic-3b.pd,
	ld-mips-elf/pic-and-nonpic-3b.rd,
	ld-mips-elf/pic-and-nonpic-3b.sd,
	ld-mips-elf/pic-and-nonpic-3-error.d,
	ld-mips-elf/pic-and-nonpic-4a.s,
	ld-mips-elf/pic-and-nonpic-4b.s,
	ld-mips-elf/pic-and-nonpic-4b.ld,
	ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.dd,
	ld-mips-elf/pic-and-nonpic-4b.gd,
	ld-mips-elf/pic-and-nonpic-4b.nd,
	ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-4b.sd,
	ld-mips-elf/pic-and-nonpic-4-error.d,
	ld-mips-elf/pic-and-nonpic-5a.s,
	ld-mips-elf/pic-and-nonpic-5b.s,
	ld-mips-elf/pic-and-nonpic-5b.ld,
	ld-mips-elf/pic-and-nonpic-5b.ad,
	ld-mips-elf/pic-and-nonpic-5b.dd,
	ld-mips-elf/pic-and-nonpic-5b.gd,
	ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-5b.rd,
	ld-mips-elf/pic-and-nonpic-5b.sd,
	ld-mips-elf/pic-and-nonpic-5b.pd,
	ld-mips-elf/pic-and-nonpic-6.ld,
	ld-mips-elf/pic-and-nonpic-6-o32a.s,
	ld-mips-elf/pic-and-nonpic-6-o32b.s,
	ld-mips-elf/pic-and-nonpic-6-o32c.s,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.pd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.sd,
	ld-mips-elf/pic-and-nonpic-6-n32a.s,
	ld-mips-elf/pic-and-nonpic-6-n32b.s,
	ld-mips-elf/pic-and-nonpic-6-n32c.s,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.pd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n32.sd,
	ld-mips-elf/pic-and-nonpic-6-n64a.s,
	ld-mips-elf/pic-and-nonpic-6-n64b.s,
	ld-mips-elf/pic-and-nonpic-6-n64c.s,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.pd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.sd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d3 1
a3 1
   2007 Free Software Foundation, Inc.
@


1.88
log
@bfd/
	* elf-bfd.h (MIPS_ELF_TDATA): New elf_object_id.
	* elf32-mips.c (bfd_elf32_mkobject): Define.
	* elf64-mips.c (bfd_elf64_mkobject): Likewise.
	* elfn32-mips.c (bfd_elf32_mkobject): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Declare.
	* elfxx-mips.c (is_mips_elf): New macro.
	(_bfd_mips_elf_mkobject): New function.
	(_bfd_mips_elf_final_link): Use is_mips_elf.
	(_bfd_mips_elf_merge_private_bfd_data): Likewise.
@
text
@d1727 32
d2318 4
d2357 4
d2381 4
d3243 3
@


1.87
log
@bfd/
	* elf32-mips.c (elf_backend_hide_symbol): Delete.
	* elfn32-mips.c (elf_backend_hide_symbol): Likewise.
	* elf64-mips.c (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.h (elf_backend_hide_symbol): Likewise.
	* elfxx-mips.c (mips_elf_link_hash_entry): Remove "forced_local"
	and add "needs_lazy_stub".
	(mips_elf_link_hash_newfunc): Update accordingly.
	(mips_elf_link_hash_table): Remove "computed_got_sizes" and
	add "lazy_stub_count".
	(_bfd_mips_elf_link_hash_table_create): Update accordingly.
	(mips_elf_output_extsym): Use hd->needs_lazy_stub to detect
	cases where a lazy stub is being used.
	(mips_elf_sort_hash_table_f): Use h->root.forced_local instead
	of h->forced_local.
	(mips_elf_record_global_got_symbol): Use _bfd_elf_link_hash_hide_symbol
	instead of _bfd_mips_elf_hide_symbol.  Do not increment local_gotno
	here.
	(mips_elf_allocate_dynamic_relocations): Move before new first use.
	(mips_elf_check_recreate_got, mips_elf_recreate_got): New functions.
	(mips_elf_resolve_final_got_entries): Move earlier in file.  Make at
	most two passes over the hash table.  Use mips_elf_check_recreate_got
	to see if there are any indirect or warning entries and
	mips_elf_recreate_got to create a new GOT without them.
	Return a boolean success value.
	(mips_elf_count_forced_local_got_entries): New function.
	(mips_elf_make_got_per_bfd): Check h->root.forced_local instead of
	h->forced_local.
	(mips_elf_set_global_got_offset): Likewise.
	(mips_elf_set_no_stub): Replace with...
	(mips_elf_forbid_lazy_stubs): ...this new function.
	(mips_elf_resolve_final_got_entry): Delete.
	(mips_elf_multi_got): Fix formatting.  Use mips_elf_forbid_lazy_stubs
	instead of mips_elf_set_no_stub.  Move the code that sets
	global offsets and allocates dynamic relocations from the main
	_bfd_mips_elf_size_dynamic_sections loop to here.
	(_bfd_mips_elf_adjust_dynamic_symbol): Do not allocate room in
	.MIPS.stubs here; just set hmips->needs_lazy_stub and increment
	htab->lazy_stub_count.
	(_bfd_mips_elf_always_size_sections): Move the stub-estimation
	code to mips_elf_estimate_stub_size and the GOT-sizing code to
	mips_elf_lay_out_got.  Do not call these functions here.
	(mips_elf_estimate_stub_size): New function, split
	out from _bfd_mips_elf_always_size_sections.  Call
	mips_elf_resolve_final_got_entries earlier.  Count the number
	of forced-local entries.  Do not add stub sizes to loadable_size;
	after this patch, the stub sizes are already included in the main
	estimate.  Allocate dynamic relocations here rather than in the
	main _bfd_mips_elf_size_dynamic_sections loop.
	(mips_elf_estimate_stub_size): New function, split out from
	_bfd_mips_elf_always_size_sections.
	(mips_elf_allocate_lazy_stub): New function.
	(mips_elf_lay_out_lazy_stubs): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Call mips_elf_estimate_stub_size,
	mips_elf_lay_out_got and mips_elf_lay_out_lazy_stubs.  Do not handle
	the allocation of sreldyn specially.
	(_bfd_mips_elf_hide_symbol): Delete.

ld/testsuite/
	* ld-mips-elf/tlsdyn-o32-2.got, ld-mips-elf/tlsdyn-o32-3.got,
	ld-mips-elf/tlsdyn-o32-2.d, ld-mips-elf/tlsdyn-o32-3.d: Change the
	GOT layout as follows:

	         BEFORE                  AFTER
	   +0x08 %call16(__tls_get_addr) %call16(__tls_get_addr)
	   +0x0c %tlsldm(tlsbin_ld)      %gottprel(tlsvar_ie)
	   +0x10   "  "                  %tlsgd(tlsvar_gd)
	   +0x14 %tlsgd(tlsvar_gd)          "  "
	   +0x18   "  "                  %tlsgd(tlsbin_gd)
	   +0x1c %gottprel(tlsvar_ie)       "  "
	   +0x20 %tlsgd(tlsbin_gd)       %tlsldm(tlsbin_ld)
	   +0x24   "  "                     "  "
	   +0x28 %gottprel(tlsbin_ie)    %gottprel(tlsbin_ie)
@
text
@d3213 1
@


1.86
log
@bfd/
	* reloc.c (BFD_RELOC_MIPS16_GOT16, BFD_RELOC_MIPS16_CALL16): Declare.
	* libbfd.h, bfd-in2.h: Regenerate.
	* elf32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_reloc_map): Add mappings.
	* elf64-mips.c (mips16_elf64_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(mips16_elf64_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfn32-mips.c (elf_mips16_howto_table_rel): Fill in reserved
	R_MIPS16_GOT16 and R_MIPS16_CALL16 entries.
	(elf_mips16_howto_table_rela): Likewise.
	(mips16_reloc_map): Add mappings.
	* elfxx-mips.c (mips_elf_create_shadow_symbol): New function.
	(section_allows_mips16_refs_p): Likewise.
	(mips16_stub_symndx): Likewise.
	(mips_elf_check_mips16_stubs): Treat the data argument as a
	bfd_link_info.  Mark every dynamic symbol as needing MIPS16 stubs
	and create a "shadow" symbol for the original MIPS16 definition.
	(mips16_reloc_p, got16_reloc_p, call16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p, mips16_call_reloc_p): New functions.
	(_bfd_mips16_elf_reloc_unshuffle): Use mips16_reloc_p to generalize
	relocation checks.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Handle R_MIPS16_GOT16.
	(mips_elf_got16_entry): Add comment.
	(mips_elf_calculate_relocation): Use hi16_reloc_p,
	lo16_reloc_p, mips16_call_reloc_p, call16_reloc_p and got16_reloc_p
	to generalize relocation checks.  Use section_allows_mips16_refs_p
	instead of mips16_stub_section_p.   Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16, allowing the former to refer directly to a
	MIPS16 function if its stub is not needed.
	(mips16_stub_section_p): Delete.
	(_bfd_mips_elf_symbol_processing): Convert odd-valued function
	symbols into even MIPS16 symbols.
	(mips_elf_add_lo16_rel_addend): Use mips16_reloc_p to generalize
	a relocation check.
	(_bfd_mips_elf_check_relocs): Calculate "bed" and "rel_end"
	earlier in the function.  Use mips16_stub_symndx to identify
	the target function.  Avoid out-of-bounds accesses when the
	stub has no relocations; report an error instead.  Use
	section_allows_mips16_refs_p instead of mips16_stub_section_p.
	Use mips16_call_reloc_p and got16_reloc_p to generalize relocation
	checks.  Handle R_MIPS16_CALL16 and R_MIPS16_GOT16.  Don't create
	dynamic relocations for absolute references to __gnu_local_gp.
	(_bfd_mips_elf_always_size_sections): Pass a bfd_link_info as
	the argument to mips_elf_check_mips16_stubs.  Generalize comment.
	(_bfd_mips_elf_relocate_section): Use hi16_reloc_p and got16_reloc_p
	to generalize relocation checks.
	(_bfd_mips_elf_finish_dynamic_symbol): If a dynamic MIPS16 function
	symbol has a non-MIPS16 stub, redirect the symbol to the stub.
	Fix an overly long line.  Don't give dynamic symbols type STO_MIPS16.
	(_bfd_mips_elf_gc_sweep_hook): Handle R_MIPS16_CALL16 and
	R_MIPS16_GOT16.

gas/
	* config/tc-mips.c (mips16_reloc_p, got16_reloc_p, hi16_reloc_p)
	(lo16_reloc_p): New functions.
	(reloc_needs_lo_p): Use hi16_reloc_p and got16_reloc_p to
	generalize relocation checks.
	(matching_lo_reloc): New function.
	(fixup_has_matching_lo_p): Use it.
	(mips16_mark_labels): Don't clobber a symbol's visibility.
	(append_insn): Use hi16_reloc_p and lo16_reloc_p.
	(mips16_ip): Handle BFD_RELOC_MIPS16_GOT16 and BFD_RELOC_MIPS16_CALL16.
	(md_apply_fix): Likewise.
	(mips16_percent_op): Add %got and %call16.
	(mips_frob_file): Use got16_reloc_p to generalize relocation checks.
	Use matching_lo_reloc.
	(mips_force_relocation): Use hi16_reloc_p and lo16_reloc_p to
	generalize relocation checks.
	(mips_fix_adjustable): Use lo16_reloc_p to generalize relocation
	checks.

gas/testsuite/
	* gas/mips/elf-rel8-mips16.d, gas/mips/elf-rel8-mips16.s,
	* gas/mips/elf-rel9-mips16.d, gas/mips/elf-rel9-mips16.s,
	* gas/mips/elf-rel13-mips16.d, gas/mips/elf-rel13-mips16.s: New tests.
	* gas/mips/mips.exp: Run them.

ld/testsuite/
	* ld-mips-elf/mips16-local-stubs-1.d: Remove stub_for_h3,
	which was only referenced by the .pdr section, and was not
	actually needed by code.
	* ld-mips-elf/mips16-intermix.d: Remove unused static function stubs.
	* ld-mips-elf/mips16-pic-1a.s,
	ld-mips-elf/mips16-pic-1b.s,
	ld-mips-elf/mips16-pic-1-dummy.s,
	ld-mips-elf/mips16-pic-1.dd,
	ld-mips-elf/mips16-pic-1.gd,
	ld-mips-elf/mips16-pic-1.inc,
	ld-mips-elf/mips16-pic-1.ld,
	ld-mips-elf/mips16-pic-2a.s,
	ld-mips-elf/mips16-pic-2b.s,
	ld-mips-elf/mips16-pic-2.ad,
	ld-mips-elf/mips16-pic-2.dd,
	ld-mips-elf/mips16-pic-2.gd,
	ld-mips-elf/mips16-pic-2.nd,
	ld-mips-elf/mips16-pic-2.rd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@a3181 1
#define elf_backend_hide_symbol		_bfd_mips_elf_hide_symbol
@


1.85
log
@        * elf.c ( _bfd_elf_print_private_bfd_data): Call
        elf_backend_get_target_dtag if defined.
        * elf32-mips.c (elf_backend_get_target_dtag): Define.
        * elf64-mips.c: Likewise.
        * elfn32-mips.c: Likewise.
        * elfxx-mips.c (_bfd_mips_elf_get_target_dtag): New.
        * elfxx-mips.h (_bfd_mips_elf_get_target_dtag): Declare.
        * elf-bfd.h (elf_backend_get_target_dtag): Add prototype.
        * elfxx-target.h (elf_backend_get_target_dtag): Add default.
        (elf_backend_data): Add elf_backend_get_target_dtag.
@
text
@d1506 14
a1519 2
  /* A placeholder for MIPS16 reference to global offset table.  */
  EMPTY_HOWTO (R_MIPS16_GOT16),
d1521 14
a1534 2
  /* A placeholder for MIPS16 16 bit call through global offset table.  */
  EMPTY_HOWTO (R_MIPS16_CALL16),
d1602 14
a1615 2
  /* A placeholder for MIPS16 reference to global offset table.  */
  EMPTY_HOWTO (R_MIPS16_GOT16),
d1617 14
a1630 2
  /* A placeholder for MIPS16 16 bit call through global offset table.  */
  EMPTY_HOWTO (R_MIPS16_CALL16),
d2248 2
@


1.84
log
@	* elf64-mips.c (elf_backend_sign_extend_vma): Define.
@
text
@d3110 1
@


1.83
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@d3150 2
@


1.82
log
@Switch sources over to use the GPL version 3
@
text
@d3073 1
@


1.81
log
@bfd:
	* elfxx-mips.c (mips_elf_calculate_relocation): Handle
	R_MIPS_TLS_DTPREL32 and R_MIPS_TLS_DTPREL64.
	* elf64-mips.c (mips_elf64_howto_table_rela): Support
	R_MIPS_TLS_DTPREL64.

gas:
	* config/tc-mips.c (s_dtprelword, s_dtpreldword,
	s_dtprel_internal): New.
	(mips_pseudo_table): Add .dtprelword and .dtpreldword.
	(md_apply_fix): Handle BFD_RELOC_MIPS_TLS_DTPREL32 and
	BFD_RELOC_MIPS_TLS_DTPREL64.
@
text
@d8 16
a23 1
This file is part of BFD, the Binary File Descriptor library.
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.80
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1330 14
a1343 1
  EMPTY_HOWTO (R_MIPS_TLS_DTPREL64),
@


1.79
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d43 1
a44 1
#include "sysdep.h"
@


1.78
log
@include/elf/
	* mips.h (R_MIPS_GLOB_DAT): Define
	(R_MIPS_max): Bump by 1.

bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Add R_MIPS_GLOB_DAT.
	* elfn32-mips.c (elf_mips_howto_table_rel): Likewise.
	(elf_mips_howto_table_rela): Likewise.
	* elf64-mips.c (mips_elf64_howto_table_rel): Likewise.
	(mips_elf64_howto_table_rela): Likewise.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d2227 33
@


1.77
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d792 15
d1439 15
@


1.76
log
@	* elf32-mips.c, elf64-mips.c, elfn32-mips.c
	(elf_backend_merge_symbol_attribute): Define.
	* elflink.c (elf_link_add_object_symbols): Merge only the ELF
	visibility flags.
	* elfxx-mips.c (_bfd_mips_elf_merge_symbol_attribute): New function.
@
text
@d3037 1
@


1.75
log
@	[ bfd/ChangeLog ]
	* elf32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel): Use _bfd_mips_elf_generic_reloc
	instead of mips16_jump_reloc.
	* elf64_mips.c, wlfn32-mips.c (mips16_jump_reloc): Remove function.
	(elf_mips16_howto_table_rel, elf_mips16_howto_table_rela): Use
	_bfd_mips_elf_generic_reloc instead of mips16_jump_reloc.

	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_fix_adjustable): Handle BFD_RELOC_MIPS16_JMP.
	(tc_gen_reloc): Handle mips16 jumps to section symbol offsets.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/mips16-call-global-1.s,
	ld-mips-elf/mips16-call-global-2.s,
	ld-mips-elf/mips16-call-global-3.s, ld-mips-elf/mips16-call-global.d:
	Test linking of external mips16 jumps.
	* ld-mips-elf/mips-elf.exp: Run new test.
@
text
@d3029 2
@


1.74
log
@	[ bfd/ChangeLog ]
	* elf32-mips.c: Expand comment about ABI-mandated pagesize values.
	(ELF_MAXPAGESIZE, ELF_COMMONPAGESIZE): define in a more obvious way.
	* elf64-mips.c, elfn32-mips.c (ELF_MAXPAGESIZE): Fix value for IRIX6.
	Delete old comments.
	(ELF_COMMONPAGESIZE): Define in a more obvious way.

	[ ld/ChangeLog ]
	* emulparams/elf64bmip.sh, emulparams/elf64btsmip.sh (COMMONPAGESIZE):
	Define.

	[ ld/testsuite/ChangeLog ]
	* ld-mips-elf/multi-got-no-shared.d: Adjust for recent change of
	ELF_MAXPAGESIZE.
@
text
@a114 2
static bfd_reloc_status_type mips16_jump_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d1439 1
a1439 1
	 mips16_jump_reloc,	/* special_function */
d1511 1
a1511 1
	 mips16_jump_reloc,	/* special_function */
a2044 31
/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static bfd_boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = TRUE;
  }

  return bfd_reloc_undefined;
}

@


1.73
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf64_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfn32-mips.c (elf_mips_howto_table_rel): Use rightshift 2 for
	R_MIPS_PC16.
	(elf_mips_howto_table_rela): Likewise.
	(mips_reloc_map): Map BFD_RELOC_16_PCREL_S2 to R_MIPS_PC16.
	(bfd_elf32_bfd_reloc_type_lookup): Don't handle
	BFD_RELOC_16_PCREL_S2.
	* elfxx-mips.c: Formatting fixes.
	(mips_elf_calculate_relocation): Handle R_MIPS_GNU_REL16_S2
	and R_MIPS_PC16 identically.
gas/
	* config/tc-mips.c (append_insn): Handle BFD_RELOC_16_PCREL_S2.
	(macro_build): Complain for invalid branch displacements.
	(mips_validate_fix): Delete.
	(md_apply_fix): Re-add pcrel support for branches.  Use consistent
	text for misaligned branch targets.
	(tc_gen_reloc: Re-add pcrel support for branches.  Handle strange
	BFD pcrel processing.  Remove error for unresolved branches.
	* config/tc-mips.h (TC_VALIDATE_FIX, mips_validate_fix): Delete.
gas/testsuite/
	* gas/mips/bge.d, gas/mips/bge.s, gas/mips/bgeu.d, gas/mips/bgeu.s,
	gas/mips/blt.d, gas/mips/blt.s, gas/mips/bltu.d,
	gas/mips/bltu.s: Reactivate external branch tests.
	* gas/mips/branch-misc-2.d, gas/mips/branch-misc-2pic.d,
	gas/mips/branch-misc-2-64.d, gas/mips/branch-misc-2pic-64.d: New
	tests.
	* gas/mips/branch-misc-2.l, gas/mips/branch-misc-2pic.l,
	gas/testsuite/gas/mips/branch-misc-2pic.s: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 tests.  Add 64-bit
	variants.
@
text
@d3155 2
a3156 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000
d3167 1
a3173 2
/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
d3175 1
@


1.72
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d302 3
a304 1
  /* 16 bit PC relative reference.  */
d306 1
a306 1
	 0,			/* rightshift */
d953 3
a955 1
  /* 16 bit PC relative reference.  */
d957 1
a957 1
	 0,			/* rightshift */
d2140 1
a2140 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
a2223 2
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rela16_s2;
@


1.71
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3105 1
@


1.70
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.69
log
@	* elfxx-mips.c (struct mips_got_entry): Add tls_type.
	(struct mips_got_info): Add tls_gotno, tls_assigned_gotno,
	and tls_ldm_offset.
	(struct mips_elf_got_per_bfd_arg): Add global_count.
	(struct mips_elf_count_tls_arg): New.
	(struct mips_elf_hash_sort_data): Update comment for min_got_dynindx.
	(struct mips_elf_link_hash_entry): Add tls_type and tls_got_offset.
	(GOT_NORMAL, GOT_TLS_GD, GOT_TLS_LDM, GOT_TLS_IE)
	(GOT_TLS_OFFSET_DONE, GOT_TLS_DONE): Define.
	(TLS_RELOC_P): Define.
	(TP_OFFSET, DTP_OFFSET): Define.
	(dtprel_base, tprel_base): New functions.
	(mips_elf_link_hash_newfunc): Initialize tls_type.
	(mips_elf_got_entry_hash, mips_elf_got_entry_eq)
	(mips_elf_multi_got_entry_hash, mips_elf_multi_got_entry_eq): Handle
	TLS entries.
	(mips_tls_got_relocs, mips_elf_count_local_tls_relocs)
	(mips_elf_count_global_tls_entries, mips_elf_count_global_tls_relocs)
	(mips_elf_output_dynamic_relocation, mips_elf_initialize_tls_slots)
	(mips_tls_got_index): New functions.
	(mips_elf_local_got_index): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Pass them to mips_elf_create_local_got_entry.  Use
	mips_tls_got_index.
	(mips_elf_global_got_index): Add new R_TYPE and INFO arguments.
	Handle TLS entries.
	(mips_elf_got_page, mips_elf_got16_entry): Update calls to
	mips_elf_create_local_got_entry.
	(mips_elf_create_local_got_entry): Add new R_SYMNDX, H, and R_TYPE
	arguments.  Handle TLS entries.
	(mips_elf_sort_hash_table_f): Add non-TLS assertions.
	(mips_elf_record_local_got_symbol): Add new TLS_FLAG argument.  Handle
	TLS entries.
	(mips_elf_record_global_got_symbol): Likewise.
	(mips_elf_make_got_per_bfd): Initialize new mips_got_info members.
	Count TLS entries.
	(mips_elf_merge_gots): Handle TLS entries when merging.
	(mips_elf_initialize_tls_index): New function.
	(mips_elf_set_global_got_offset): Handle TLS entries.
	(mips_elf_adjust_gp): Handle TLS.
	(mips_elf_multi_got): Remove redundant call to
	mips_elf_resolve_final_got_entries.  Initialize global_count.
	Correct a comment.  Initialize new TLS members of mips_got_info.
	Assign TLS GOT indexes for new GOTs.
	(mips_elf_create_got_section): Initialize new TLS members of
	mips_got_info.
	(mips_elf_calculate_relocation): Handle TLS relocs.
	(_bfd_mips_elf_check_relocs): Likewise.  Update calls to changed
	functions.
	(_bfd_mips_elf_always_size_sections): Handle TLS.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.  Update calls to
	changed functions.
	(_bfd_mips_elf_copy_indirect_symbol): Copy tls_type.
	(_bfd_mips_elf_hide_symbol): Handle TLS.
	* elfn32-mips.c (elf_mips_howto_table_rel, elf_mips_howto_table_rela)
	(mips_reloc_map): Add TLS relocs.
	* elf32-mips.c (elf_mips_howto_table_rel, mips_reloc_map): Likewise.
	* elf64-mips.c (mips_elf64_howto_table_rel)
	(mips_elf64_howto_table_rela, mips_reloc_map): Likewise.
	* reloc.c: Define new MIPS TLS relocations.
	* libbfd.h, bfd-in2.h: Regenerated.
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.68
log
@bfd/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rel.
	* elf64-mips.c (mips16_elf64_howto_table_rel): New array for
	MIPS16 REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16
	relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into mips16_elf64_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_elf64_howto_table_rela): New array for MIPS16 RELA
	reloc howtos.  Add R_MIPS16_26, R_MIPS16_GPREL, R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs and R_MIPS16_GOT16 and R_MIPS16_CALL16
	placeholders.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf64_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf64_rtype_to_howto): Fetch MIPS16 howtos from
	mips16_elf64_howto_table_rela or mips16_elf64_howto_table_rel.
	* elfn32-mips.c (elf_mips16_howto_table_rel): New array for MIPS16
	REL reloc howtos.  Add R_MIPS16_HI16 and R_MIPS16_LO16 relocs and
	R_MIPS16_GOT16 and R_MIPS16_CALL16 placeholders.
	(elf_mips16_jump_howto): Move into elf_mips16_howto_table_rel.
	(elf_mips16_gprel_howto): Likewise.  Redefine src_mask and
	dst_mask.
	(mips16_gprel_reloc): Remove bit shuffling; call
	_bfd_mips16_elf_reloc_unshuffle(), _bfd_mips_elf_gprel16_with_gp()
	and _bfd_mips16_elf_reloc_shuffle() instead.
	(mips16_reloc_map): New reloc map for MIPS16 relocs.
	(bfd_elf32_bfd_reloc_type_lookup): Use mips16_reloc_map for MIPS16
	relocs.
	(mips_elf_n32_rtype_to_howto): Fetch MIPS16 howtos from
	elf_mips16_howto_table_rela or elf_mips16_howto_table_rel.
	* elfxx-mips.c (_bfd_mips16_elf_reloc_unshuffle): New function to
	handle bit shuffling for MIPS16 relocs.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	(_bfd_mips_elf_lo16_reloc): Use _bfd_mips16_elf_reloc_unshuffle()
	and _bfd_mips16_elf_reloc_shuffle().
	(_bfd_mips_elf_generic_reloc): Likewise.
	(mips_elf_calculate_relocation): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	(mips_elf_obtain_contents): Remove bit shuffling.
	(mips_elf_perform_relocation): Likewise; call
	_bfd_mips16_elf_reloc_unshuffle() and _bfd_mips16_elf_reloc_shuffle()
	instead.
	(_bfd_mips_elf_relocate_section): Likewise.  Handle R_MIPS16_HI16
	and R_MIPS16_LO16.
	* elfxx-mips.h (_bfd_mips16_elf_reloc_unshuffle): Declare.
	(_bfd_mips16_elf_reloc_shuffle): Likewise.
	* reloc.c (BFD_RELOC_MIPS16_HI16): New reloc.
	(BFD_RELOC_MIPS16_HI16_S): Likewise.
	(BFD_RELOC_MIPS16_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

gas/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* config/tc-mips.c (reloc_needs_lo_p): Handle
	BFD_RELOC_MIPS16_HI16_S.
	(fixup_has_matching_lo_p): Handle BFD_RELOC_MIPS16_LO16.
	(append_insn): Add BFD_RELOC_MIPS16_GPREL, BFD_RELOC_MIPS16_HI16_S
	and BFD_RELOC_MIPS16_LO16 to relocs to suppress overflow
	complaints on.
	(mips16_ip): Resolve BFD_RELOC_MIPS16_HI16_S,
	BFD_RELOC_MIPS16_HI16 and BFD_RELOC_MIPS16_LO16 for constants.
	Call my_getSmallExpression() to parse percent operators.
	(percent_op_match, mips_percent_op): Separate definitions.
	(mips16_percent_op): Define percent operators for the MIPS16 mode.
	(parse_relocation): Handle the MIPS16 mode using
	mips16_percent_op.
	(md_apply_fix3): Handle BFD_RELOC_MIPS16_HI16,
	BFD_RELOC_MIPS16_HI16_S and BFD_RELOC_MIPS16_LO16.

gas/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* gas/mips/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* gas/mips/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* gas/mips/mips16-hilo.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

include/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* elf/mips.h (R_MIPS16_GOT16): New reloc code.
	(R_MIPS16_CALL16): Likewise.
	(R_MIPS16_HI16): Likewise.
	(R_MIPS16_LO16): Likewise.
	(R_MIPS16_min): New fake reloc code.
	(R_MIPS16_max): Likewise.

ld/testsuite/:
2005-02-15  Nigel Stephens  <nigel@@mips.com>
            Maciej W. Rozycki  <macro@@mips.com>

	* ld-mips-elf/mips16-hilo.d: New test for the R_MIPS16_HI16 and
	R_MIPS16_LO16 relocs.
	* ld-mips-elf/mips16-hilo-n32.d: Likewise, for the n32 ABI.
	* ld-mips-elf/mips16-hilo.s: Auxiliary source for the new tests.
	* ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d638 154
d1308 114
d2164 14
a2177 1
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR }
@


1.67
log
@* elf32-mips.c (_bfd_mips_elf32_gprel16_reloc): Reject
R_MIPS_LITERAL relocations for external symbols.
* elf64-mips.c (mips_elf64_literal_reloc): Likewise.
* elfn32-mips.c (mips_elf_literal_reloc): Likewise.
@
text
@d1156 3
a1158 2
/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
d1174 1
a1174 1
	 FALSE);		/* pcrel_offset */
d1176 1
a1176 2
/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
d1187 112
a1298 3
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,		/* dst_mask */
	 FALSE);		/* pcrel_offset */
d1815 1
a1816 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1841 8
a1848 2
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;
d1850 1
a1850 46
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1899 8
d1917 1
d1926 7
a1934 4
    case BFD_RELOC_MIPS16_JMP:
      return &elf_mips16_jump_howto;
    case BFD_RELOC_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
a1953 4
    case R_MIPS16_26:
      return &elf_mips16_jump_howto;
    case R_MIPS16_GPREL:
      return &elf_mips16_gprel_howto;
d1964 7
@


1.66
log
@* elf64-mips.c (mips16_gprel_reloc): Update a comment.
* elfn32-mips.c (mips16_gprel_reloc): Keep R_MIPS16_GPREL
relocations against external symbols unchanged.
@
text
@d1546 1
a1546 2
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
d1551 3
a1553 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
@


1.65
log
@* elf64-mips.c: Fix formatting throughout.
@
text
@d1712 2
a1713 2
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  */
@


1.64
log
@* elf32-mips.c (mips_elf_gprel32_reloc): Reject
R_MIPS_GPREL32 relocations against external symbols.
* elf64-mips.c (mips_elf64_gprel32_reloc): Replace an incorrect
comment.
@
text
@d625 1
a625 1
  HOWTO (R_MIPS_JALR,	        /* type */
d633 1
a633 1
	 "R_MIPS_JALR",	        /* name */
d1141 1
a1141 1
  HOWTO (R_MIPS_JALR,	        /* type */
d1149 1
a1149 1
	 "R_MIPS_JALR",	        /* name */
d1188 1
a1188 1
	 0x07ff001f,	        /* dst_mask */
d1607 4
a1610 4
    ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
    if (ret != bfd_reloc_ok)
      return ret;
d2119 1
a2119 1
                         special howto structures.  */
d2655 2
a2656 2
  4,            /* hash-table entry size */
  3,            /* internal relocations per external relocations */
d2804 4
a2807 4
#define TARGET_LITTLE_SYM               bfd_elf64_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf64-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf64_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf64-tradbigmips"
@


1.63
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d1589 1
a1589 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
@


1.62
log
@	* elf64-mips.c (mips_elf64_write_rel): Use STN_UNDEF for relocs
	against the absolute section.
	(mips_elf64_write_rela): Likewise.
@
text
@a1369 3
#if 0
  BFD_ASSERT(src[0].r_offset == src[2].r_offset);
#endif
@


1.61
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2355 2
d2453 2
@


1.60
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a1590 1
  bfd_size_type sz;
d1624 1
a1624 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
a1714 1
  bfd_size_type sz;
d1739 1
a1739 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.59
log
@	* elf64-mips.c (mips_elf64_slurp_one_reloc_table): Call
	mips_elf64_rtype_to_howto instead of using howto_table.

	* gas/mips/mips16-64.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1591 1
d1625 2
a1626 1
  if (reloc_entry->address > input_section->_cooked_size)
d1717 1
d1742 2
a1743 1
  if (reloc_entry->address > input_section->_cooked_size)
d1991 1
a1991 1
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
d2217 1
a2217 1
      if (asect->_raw_size == 0)
d2546 1
a2546 1
  unsigned int raw_size;
d2562 1
a2562 1
	raw_size = 360;
d2569 1
a2569 1
					  raw_size, note->descpos + offset);
@


1.59.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d1624 1
a1624 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1739 1
a1739 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d1987 1
a1987 1
	  count = s->size / elf_section_data (s)->this_hdr.sh_entsize * 3;
d2213 1
a2213 1
      if (asect->size == 0)
d2542 1
a2542 1
  unsigned int size;
d2558 1
a2558 1
	size = 360;
d2565 1
a2565 1
					  size, note->descpos + offset);
@


1.58
log
@* elf32-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf32_bed): Redefine to get a separate backend data structure for
traditional targets.
* elf64-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf64_bed): Redefine to get a separate backend data structure for
traditional targets.
* elfn32-mips.c (ELF_MAXPAGESIZE): Redefine for traditional
targets to support pages of up to 64kB.
(elf32_bed): Redefine to get a separate backend data structure for
traditional targets.
@
text
@d2018 1
a2018 1
  reloc_howto_type *howto_table;
d2036 1
a2036 1
    howto_table = mips_elf64_howto_table_rel;
d2038 1
a2038 1
    howto_table = mips_elf64_howto_table_rela;
d2151 1
a2151 1
	  relent->howto = &howto_table[(int) type];
@


1.57
log
@bfd/
	* elf32-mips.c (elf_mips_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16,
	_bfd_mips_elf_lo16_reloc for R_MIPS_LO16 and R_MIPS_GNU_REL_LO16,
	and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.  Change rightshift
	to 16 for R_MIPS_HI16 and R_MIPS_GNU_REL_HI16.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(_bfd_mips_elf32_gprel16_reloc): Remove special case.
	(mips_elf_gprel32_reloc, mips32_64bit_reloc): Likewise.

	* elf64-mips.c (mips_elf64_howto_table_rel): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.  Use
	_bfd_mips_elf_hi16_reloc for R_MIPS_HI16, _bfd_mips_elf_lo16_reloc
	for R_MIPS_LO16 and _bfd_mips_elf_got16_reloc for R_MIPS_GOT16.
	Change R_MIPS_HI16's rightshift to 16.
	(mips_elf64_howto_table_rela): Replace all uses of
	mips_elf_generic_reloc with _bfd_mips_elf_generic_reloc.
	Use _bfd_mips_elf_generic_reloc for R_MIPS_GOT16 as well.
	(mips_elf64_hi16_reloc, mips_elf64_got16_reloc): Delete.
	(mips_elf64_shift6_reloc): Remove special case.  Use
	_bfd_mips_elf_generic_reloc instead of returning bfd_reloc_continue.

	* elfn32-mips.c (prev_reloc_section): Delete.
	(prev_reloc_address, prev_reloc_addend): Delete.
	(elf_mips_howto_table_rel, elf_mips_howto_table_rela): As for
	elf64-mips.c
	(GET_RELOC_ADDEND, SET_RELOC_ADDEND): Delete.
	(mips_elf_generic_reloc, struct mips_hi16, mips_elf_hi16_reloc)
	(mips_elf_lo16_reloc, mips_elf_got16_reloc): Delete.
	(mips_elf_gprel16_reloc): Delete use of GET_RELOC_ADDEND.
	(mips_elf_literal_reloc, mips_elf_gprel32_reloc): Likewise.
	(mips16_jump_reloc, mips16_gprel_reloc): Likewise.
	(mips_elf_shift6_reloc): Likewise.  Delete use of SET_RELOC_ADDEND.

	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Use
	_bfd_relocate_contents to install an in-place addend.
	(mips_hi16): New structure.
	(mips_hi16_list): Moved from elf32-mips.c.
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_got16_reloc): New functions.
	(_bfd_mips_elf_lo16_reloc, _bfd_mips_elf_generic_reloc): New functions.
	(mips_elf_calculate_relocation): Assume addend is unshifted.
	(_bfd_mips_elf_relocate_section): Don't apply the howto rightshift
	on top of the usual high-part shift.  Don't shift the addend right
	before calling mips_elf_calculate_relocation.

	* elfxx-mips.h (_bfd_mips_elf_hi16_reloc): Declare.
	(_bfd_mips_elf_got16_reloc, _bfd_mips_elf_lo16_reloc): Declare.
	(_bfd_mips_elf_generic_reloc): Declare.

gas/
	* config/tc-mips.c (mips_need_elf_addend_fixup): Delete.
	(md_apply_fix3): Remove bfd_install_relocation workarounds.
	(tc_gen_reloc): Likewise. Factor handling of pc-relative relocations
	and treat fx_addnumber as relative to the relocation address.

gas/testsuite/
	* gas/mips/mips16-jalx.d: Use -mabi=o64.
	* gas/mips/mips16.d: Likewise.
	* gas/mips/elf-rel17.[sd]: New test.
	* gas/mips/mips.exp: Run it.
@
text
@a2678 5
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000

d2789 5
a2795 2
#define INCLUDED_TARGET_FILE            /* More a type of flag.  */

d2802 2
d2808 5
@


1.56
log
@	* elf32-mips.c, elfn32-mips.c, elf64-mips.c: Convert prototypes.
	Remove casts that were only needed for K&R compatibility.
@
text
@a106 2
static bfd_reloc_status_type mips_elf64_hi16_reloc
  (bfd *, arelent *, asymbol *,	void *, asection *, bfd *, char **);
a114 2
static bfd_reloc_status_type mips_elf64_got16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d154 1
a154 1
	 bfd_elf_generic_reloc,	/* special_function */
d169 1
a169 1
	 bfd_elf_generic_reloc,	/* special_function */
d184 1
a184 1
	 bfd_elf_generic_reloc,	/* special_function */
d199 1
a199 1
	 bfd_elf_generic_reloc,	/* special_function */
d217 1
a217 1
	 bfd_elf_generic_reloc,	/* special_function */
d229 1
a229 1
	 0,			/* rightshift */
d235 1
a235 1
	 mips_elf64_hi16_reloc,	/* special_function */
d250 1
a250 1
	 bfd_elf_generic_reloc,	/* special_function */
d295 1
a295 1
	 mips_elf64_got16_reloc, /* special_function */
d310 1
a310 1
	 bfd_elf_generic_reloc,	/* special_function */
d325 1
a325 1
	 bfd_elf_generic_reloc,	/* special_function */
d359 1
a359 1
	 bfd_elf_generic_reloc,	/* special_function */
d389 1
a389 1
	 bfd_elf_generic_reloc,	/* special_function */
d404 1
a404 1
	 bfd_elf_generic_reloc,	/* special_function */
d419 1
a419 1
	 bfd_elf_generic_reloc,	/* special_function */
d434 1
a434 1
	 bfd_elf_generic_reloc,	/* special_function */
d449 1
a449 1
	 bfd_elf_generic_reloc,	/* special_function */
d464 1
a464 1
	 bfd_elf_generic_reloc,	/* special_function */
d479 1
a479 1
	 bfd_elf_generic_reloc,	/* special_function */
d495 1
a495 1
	 bfd_elf_generic_reloc,	/* special_function */
d512 1
a512 1
	 bfd_elf_generic_reloc,	/* special_function */
d528 1
a528 1
	 bfd_elf_generic_reloc,	/* special_function */
d552 1
a552 1
	 bfd_elf_generic_reloc,	/* special_function */
d567 1
a567 1
	 bfd_elf_generic_reloc,	/* special_function */
d582 1
a582 1
	 bfd_elf_generic_reloc,	/* special_function */
d596 1
a596 1
	 bfd_elf_generic_reloc,	/* special_function */
d616 1
a616 1
	 bfd_elf_generic_reloc,	/* special_function */
d632 1
a632 1
	 bfd_elf_generic_reloc,	/* special_function */
d652 1
a652 1
	 bfd_elf_generic_reloc,	/* special_function */
d667 1
a667 1
	 bfd_elf_generic_reloc,	/* special_function */
d682 1
a682 1
	 bfd_elf_generic_reloc,	/* special_function */
d697 1
a697 1
	 bfd_elf_generic_reloc,	/* special_function */
d715 1
a715 1
	 bfd_elf_generic_reloc,	/* special_function */
d730 1
a730 1
	 bfd_elf_generic_reloc,	/* special_function */
d745 1
a745 1
	 bfd_elf_generic_reloc,	/* special_function */
d790 1
a790 1
	 mips_elf64_got16_reloc, /* special_function */
d805 1
a805 1
	 bfd_elf_generic_reloc,	/* special_function */
d820 1
a820 1
	 bfd_elf_generic_reloc,	/* special_function */
d854 1
a854 1
	 bfd_elf_generic_reloc,	/* special_function */
d884 1
a884 1
	 bfd_elf_generic_reloc,	/* special_function */
d899 1
a899 1
	 bfd_elf_generic_reloc,	/* special_function */
d914 1
a914 1
	 bfd_elf_generic_reloc,	/* special_function */
d929 1
a929 1
	 bfd_elf_generic_reloc,	/* special_function */
d944 1
a944 1
	 bfd_elf_generic_reloc,	/* special_function */
d959 1
a959 1
	 bfd_elf_generic_reloc,	/* special_function */
d974 1
a974 1
	 bfd_elf_generic_reloc,	/* special_function */
d990 1
a990 1
	 bfd_elf_generic_reloc,	/* special_function */
d1007 1
a1007 1
	 bfd_elf_generic_reloc,	/* special_function */
d1023 1
a1023 1
	 bfd_elf_generic_reloc,	/* special_function */
d1038 1
a1038 1
	 bfd_elf_generic_reloc, /* special_function */
d1053 1
a1053 1
	 bfd_elf_generic_reloc, /* special_function */
d1068 1
a1068 1
	 bfd_elf_generic_reloc,	/* special_function */
d1083 1
a1083 1
	 bfd_elf_generic_reloc,	/* special_function */
d1098 1
a1098 1
	 bfd_elf_generic_reloc,	/* special_function */
d1112 1
a1112 1
	 bfd_elf_generic_reloc,	/* special_function */
d1132 1
a1132 1
	 bfd_elf_generic_reloc,	/* special_function */
d1148 1
a1148 1
	 bfd_elf_generic_reloc,	/* special_function */
d1232 1
a1232 1
	 bfd_elf_generic_reloc,	/* special_function */
d1248 1
a1248 1
	 bfd_elf_generic_reloc,	/* special_function */
a1409 60
/* Do a R_MIPS_HI16 relocation.  */

static bfd_reloc_status_type
mips_elf64_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		       asection *input_section, bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (reloc_entry->howto->partial_inplace)
    {
      if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
	reloc_entry->addend += 0x8000;
    }

  return bfd_reloc_continue;
}

/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset
   table used for PIC code.  If the symbol is an external symbol, the
   instruction is modified to contain the offset of the appropriate
   entry in the global offset table.  If the symbol is a section
   symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit
   addends are combined to form the real addend against the section
   symbol; the GOT16 is modified to contain the offset of an entry in
   the global offset table, and the LO16 is modified to offset it
   appropriately.  Thus an offset larger than 16 bits requires a
   modified value in the global offset table.

   This implementation suffices for the assembler, but the linker does
   not yet know how to create global offset tables.  */

static bfd_reloc_status_type
mips_elf64_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
{
  /* If we're relocating, and this is a local symbol, we can handle it
     just like an R_MIPS_HI16.  */
  if (output_bfd != NULL
      && ((symbol->flags & BSF_SECTION_SYM) != 0
	  || (symbol->flags & BSF_LOCAL) == 0))
    return mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);


  /* Otherwise we try to handle it as R_MIPS_GOT_DISP.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
}

d1655 3
a1657 4
mips_elf64_shift6_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			 asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			 asection *input_section, bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
a1658 10
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (symbol->flags & BSF_LOCAL) != 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

d1665 3
a1667 1
  return bfd_reloc_continue;
@


1.55
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d65 1
a65 2
  PARAMS ((bfd *, const Elf64_Mips_External_Rel *,
	   Elf64_Mips_Internal_Rela *));
d67 1
a67 2
  PARAMS ((bfd *, const Elf64_Mips_External_Rela *,
	   Elf64_Mips_Internal_Rela *));
d69 1
a69 2
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
	   Elf64_Mips_External_Rel *));
d71 1
a71 2
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
	   Elf64_Mips_External_Rela *));
d73 1
a73 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d75 1
a75 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d77 1
a77 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d79 1
a79 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d81 1
a81 1
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d83 1
a83 1
  PARAMS ((unsigned int, bfd_boolean));
d85 1
a85 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d87 1
a87 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d89 1
a89 1
  PARAMS ((bfd *, asection *));
d91 3
a93 2
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long mips_elf64_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
d95 1
a95 1
  PARAMS ((bfd *, arelent **, asymbol **));
d97 2
a98 2
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));
d100 1
a100 1
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d102 1
a102 1
  PARAMS ((bfd *, asection *, PTR));
d104 1
a104 1
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
d106 1
a106 1
  PARAMS((bfd *, asection *, Elf_Internal_Shdr *, int *, PTR));
d108 1
a108 1
  PARAMS ((bfd *, arelent *, asymbol *,	PTR, asection *, bfd *, char **));
d110 1
a110 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d112 1
a112 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d114 1
a114 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d116 1
a116 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d118 1
a118 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d120 1
a120 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d122 1
a122 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d124 1
a124 1
  PARAMS ((bfd *, bfd_vma *));
d126 1
a126 1
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
d128 1
a128 1
  PARAMS ((bfd *));
d130 1
a130 1
  PARAMS ((bfd *));
d132 1
a132 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d134 1
a134 1
  PARAMS ((bfd *, Elf_Internal_Note *));
d1262 2
a1263 4
mips_elf64_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_External_Rel *src;
     Elf64_Mips_Internal_Rela *dst;
d1277 2
a1278 4
mips_elf64_swap_reloca_in (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_External_Rela *src;
     Elf64_Mips_Internal_Rela *dst;
d1292 2
a1293 4
mips_elf64_swap_reloc_out (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_Internal_Rela *src;
     Elf64_Mips_External_Rel *dst;
d1306 2
a1307 4
mips_elf64_swap_reloca_out (abfd, src, dst)
     bfd *abfd;
     const Elf64_Mips_Internal_Rela *src;
     Elf64_Mips_External_Rela *dst;
d1321 2
a1322 4
mips_elf64_be_swap_reloc_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rela *dst;
d1344 2
a1345 4
mips_elf64_be_swap_reloca_in (abfd, src, dst)
     bfd *abfd;
     const bfd_byte *src;
     Elf_Internal_Rela *dst;
d1367 2
a1368 4
mips_elf64_be_swap_reloc_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *dst;
d1391 2
a1392 4
mips_elf64_be_swap_reloca_out (abfd, src, dst)
     bfd *abfd;
     const Elf_Internal_Rela *src;
     bfd_byte *dst;
d1417 4
a1420 9
mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1424 1
a1424 1
  if (output_bfd != (bfd *) NULL
d1456 3
a1458 9
mips_elf64_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1462 1
a1462 1
  if (output_bfd != (bfd *) NULL
d1478 1
a1478 3
mips_elf64_assign_gp (output_bfd, pgp)
     bfd *output_bfd;
     bfd_vma *pgp;
d1494 1
a1494 1
  if (sym == (asymbol **) NULL)
d1530 2
a1531 6
mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message, pgp)
     bfd *output_bfd;
     asymbol *symbol;
     bfd_boolean relocatable;
     char **error_message;
     bfd_vma *pgp;
d1566 3
a1568 9
mips_elf64_gprel16_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1576 1
a1576 1
  if (output_bfd != (bfd *) NULL
d1584 1
a1584 1
  if (output_bfd != (bfd *) NULL)
d1605 3
a1607 9
mips_elf64_literal_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1615 1
a1615 1
  if (output_bfd != (bfd *) NULL
d1624 1
a1624 1
  if (output_bfd != (bfd *) NULL)
d1646 3
a1648 9
mips_elf64_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1658 1
a1658 1
  if (output_bfd != (bfd *) NULL
d1667 1
a1667 1
  if (output_bfd != (bfd *) NULL)
d1719 4
a1722 9
mips_elf64_shift6_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1726 1
a1726 1
  if (output_bfd != (bfd *) NULL
d1746 4
a1749 9
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1751 1
a1751 1
  if (output_bfd != (bfd *) NULL
d1777 3
a1779 9
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1846 1
a1846 3
		  (bfd_vma) ((extend & 0xf800)
			     | ((val >> 11) & 0x1f)
			     | (val & 0x7e0)),
d1849 1
a1849 2
		  (bfd_vma) ((insn & 0xffe0)
			     | (val & 0x1f)),
d1912 2
a1913 3
bfd_elf64_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1948 1
a1948 3
mips_elf64_rtype_to_howto (r_type, rela_p)
     unsigned int r_type;
     bfd_boolean rela_p;
d1978 3
a1980 4
mips_elf64_info_to_howto_rel (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d1986 3
a1988 4
mips_elf64_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d1997 1
a1997 3
mips_elf64_get_reloc_upper_bound (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d2003 1
a2003 2
mips_elf64_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d2014 2
a2015 5
mips_elf64_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d2034 2
a2035 4
mips_elf64_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
d2037 1
a2037 2
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
d2080 5
a2084 9
mips_elf64_slurp_one_reloc_table (abfd, asect, rel_hdr, reloc_count,
				  relents, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
     asymbol **symbols;
     bfd_boolean dynamic;
d2086 1
a2086 1
  PTR allocated = NULL;
d2093 1
a2093 1
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
d2102 1
a2102 1
  native_relocs = (bfd_byte *) allocated;
d2250 2
a2251 5
mips_elf64_slurp_reloc_table (abfd, asect, symbols, dynamic)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     bfd_boolean dynamic;
d2297 1
a2297 1
  relents = (arelent *) bfd_alloc (abfd, amt);
d2325 1
a2325 4
mips_elf64_write_relocs (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d2327 1
a2327 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2388 3
a2390 6
mips_elf64_write_rel (abfd, sec, rel_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rel_hdr;
     int *count;
     PTR data;
d2392 1
a2392 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2398 2
a2399 2
  rel_hdr->sh_size = (bfd_vma)(rel_hdr->sh_entsize * *count);
  rel_hdr->contents = (PTR) bfd_alloc (abfd, rel_hdr->sh_size);
d2484 3
a2486 6
mips_elf64_write_rela (abfd, sec, rela_hdr, count, data)
     bfd *abfd;
     asection *sec;
     Elf_Internal_Shdr *rela_hdr;
     int *count;
     PTR data;
d2488 1
a2488 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2494 2
a2495 2
  rela_hdr->sh_size = (bfd_vma)(rela_hdr->sh_entsize * *count);
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
d2583 1
a2583 2
mips_elf64_object_p (abfd)
     bfd *abfd;
d2601 1
a2601 2
elf64_mips_irix_compat (abfd)
     bfd *abfd;
d2612 1
a2612 3
elf64_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d2642 1
a2642 3
elf64_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d2842 1
a2842 1
  PARAMS ((bfd *));
d2844 1
a2844 1
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
@


1.54
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d478 1
a478 1
  /* 64 bit substraction.  */
d973 1
a973 1
  /* 64 bit substraction.  */
@


1.53
log
@	* elf64-mips.c (elf_backend_copy_indirect_symbol): Define.
@
text
@a2915 1
#define elf_backend_plt_header_size	0
@


1.52
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2902 2
@


1.51
log
@Correct spelling of "relocatable".
@
text
@d2103 1
a2103 1
  struct elf_backend_data *bed = get_elf_backend_data (abfd);
@


1.50
log
@	* elf32-mips.c (mips_elf_generic_reloc): New Function.
	(elf_mips_howto_table_rel): Use it.
	(gprel32_with_gp): Move prototype.
	(mips_elf_hi16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Use mips_elf_generic_reloc.
	(mips_elf_got16_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Code cleanup.
	(_bfd_mips_elf32_gprel16_reloc): Check for ! BSF_LOCAL instead of
	zero addend.
	(mips_elf_gprel32_reloc): Likewise. Use the same GP assignment logic
	as in the other *_gprel*_reloc functions.
	(gprel32_with_gp): Handle partial_inplace properly.
	(mips32_64bit_reloc): Use mips_elf_generic_reloc.
	(mips16_gprel_reloc): Check for ! BSF_LOCAL instead of zero addend.
	Do addend handling directly instead of calling
	_bfd_mips_elf_gprel16_with_gp. Handle partial_inplace properly.
	* elf64-mips.c (mips_elf64_hi16_reloc): Check for ! BSF_LOCAL instead
	of zero addend. Handle partial_inplace properly.
	(mips_elf64_got16_reloc): Check for ! BSF_LOCAL instead of zero
	addend.
	(mips_elf64_gprel16_reloc): Likewise.
	(mips_elf64_literal_reloc): Likewise.
	(mips_elf64_gprel32_reloc): Likewise. Use the same GP assignment
	logic as in the other *_gprel*_reloc functions. Handle
	partial_inplace properly.
	(mips_elf64_shift6_reloc): Check for ! BSF_LOCAL instead of zero
	addend. Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfn32-mips.c (mips_elf_got16_reloc): Check for BSF_LOCAL.
	(mips_elf_gprel32_reloc): Check for ! BSF_LOCAL instead
	of zero addend.
	(mips_elf_shift6_reloc): Handle partial_inplace properly.
	(mips16_gprel_reloc): Likewise. Do addend handling directly instead
	of calling _bfd_mips_elf_gprel16_with_gp.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp): Handle
	partial_inplace properly. Fix wrong addend handling. Fix overflow
	check.
	(_bfd_mips_elf_sign_extend): Renamed from mips_elf_sign_extend and
	exported.
	(mips_elf_calculate_relocation): Use _bfd_mips_elf_sign_extend.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_dynamic_relocation): Update sec_info_type access.
	* elfxx-mips.h (_bfd_mips_relax_section): Fix prototype declaration.
	(_bfd_mips_elf_sign_extend): New prototype.
	* config/tc-mips.c (md_pcrel_from): Return actual pcrel address.
	(md_apply_fix3): Ignore non-special relocations. Remove superfluous
	exceptions from size assert. Remove most of the addend fixup
	specialcasing. Remove value, use valP directly. simplify fx_addnumber
	handling. Remove zero addend specialcases.
	(tc_gen_reloc): Use appropriate value for reloc2 addend. Remove
	the addend fixup specialcase.
	* config/tc-mips.h (MD_APPLY_SYM_VALUE): Define as 0.
@
text
@d1559 1
a1559 1
   external symbol if we are producing relocateable output.  */
d1562 1
a1562 1
mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message, pgp)
d1565 1
a1565 1
     bfd_boolean relocateable;
d1570 1
a1570 1
      && ! relocateable)
d1578 1
a1578 1
      && (! relocateable
d1581 1
a1581 1
      if (relocateable)
d1612 1
a1612 1
  bfd_boolean relocateable;
d1627 1
a1627 1
    relocateable = TRUE;
d1630 1
a1630 1
      relocateable = FALSE;
d1634 1
a1634 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1640 1
a1640 1
					input_section, relocateable,
d1657 1
a1657 1
  bfd_boolean relocateable;
d1673 1
a1673 1
    relocateable = TRUE;
d1676 1
a1676 1
      relocateable = FALSE;
d1680 1
a1680 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1686 1
a1686 1
					input_section, relocateable,
d1704 1
a1704 1
  bfd_boolean relocateable;
d1722 1
a1722 1
    relocateable = TRUE;
d1725 1
a1725 1
      relocateable = FALSE;
d1729 1
a1729 1
    ret = mips_elf64_final_gp (output_bfd, symbol, relocateable,
d1752 1
a1752 1
     are producing relocateable output, we don't want to do this for
d1754 1
a1754 1
  if (! relocateable
d1763 1
a1763 1
  if (relocateable)
d1851 1
a1851 1
  bfd_boolean relocateable;
d1870 1
a1870 1
    relocateable = TRUE;
d1873 1
a1873 1
      relocateable = FALSE;
d1877 1
a1877 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
d1907 1
a1907 1
     are producing relocateable output, we don't want to do this for
d1909 1
a1909 1
  if (! relocateable
d1928 1
a1928 1
  if (relocateable)
@


1.49
log
@	* elf64-mips.c (elf_mips_gnu_rel16_s2): Add internally used
	R_MIPS_GNU_REL16_S2 support.
	(bfd_elf64_bfd_reloc_type_lookup): Use it.
	(mips_elf64_rtype_to_howto): Use it.
	* elfn32-mips.c (elf_mips_gnu_rel16_s2): Add internally used
	R_MIPS_GNU_REL16_S2 support.
	(bfd_elf32_bfd_reloc_type_lookup): Use it.
	(mips_elf_n32_rtype_to_howto): Use it.
@
text
@d1450 1
a1450 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1456 5
a1460 2
  if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
    reloc_entry->addend += 0x8000;
d1493 2
a1494 1
      && (symbol->flags & BSF_SECTION_SYM) != 0)
d1616 2
a1617 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1620 1
a1620 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1665 1
a1665 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1708 1
a1708 1
  unsigned long val;
d1710 2
a1711 4
  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1714 1
a1714 1
      && reloc_entry->addend == 0)
d1722 1
a1722 4
    {
      relocateable = TRUE;
      gp = _bfd_get_gp_value (output_bfd);
    }
d1727 1
d1729 4
a1732 5
      ret = mips_elf64_final_gp (output_bfd, symbol, relocateable,
				 error_message, &gp);
      if (ret != bfd_reloc_ok)
	return ret;
    }
d1745 2
a1746 7
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case arises with the 64-bit MIPS ELF ABI.  */
      val = 0;
    }
  else
    val = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1748 2
a1749 2
  /* Set val to the offset into the section or symbol.  */
  val += reloc_entry->addend;
d1758 4
a1761 1
  bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
d1787 1
a1787 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1793 5
a1797 2
  reloc_entry->addend = (reloc_entry->addend & 0x00007c0)
			| (reloc_entry->addend & 0x00000800) >> 9;
d1854 4
a1857 2
  unsigned short extend, insn;
  unsigned long final;
d1860 1
a1860 3
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1863 1
a1863 1
      && reloc_entry->addend == 0)
d1885 18
a1902 25
  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);
d1904 30
a1933 1
  return ret;
@


1.48
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1230 32
d1995 2
d2020 5
@


1.47
log
@* elfxx-mips.c (_bfd_mips_relax_section): New function.
* elfxx-mips.h (_bfd_mips_relax_section): Declare.
* elfn32-mips.c, elf64-mips.c: Use it.
@
text
@d2785 1
a2785 1
  8,		/* file_align */
@


1.47.8.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d2785 1
a2785 1
  3,		/* log_file_align */
@


1.46
log
@* Reverted 2003-03-02's patch.
@
text
@d2890 1
@


1.45
log
@* elfxx-target.h (bfd_elfNN_canonicalize_reloc): Make it
overridable.
* elf64-mips.c (mips_elf64_canonicalize_reloc,
mips_elf64_get_dynamic_reloc_upper_bound,
mips_elf64_canonicalize_dynamic_reloc): New, adapted from elf.c.
(bfd_elf64_get_canonicalize_reloc,
bfd_elf64_get_dynamic_reloc_upper_bound,
bfd_elf64_canonicalize_dynamic_reloc): Define.
(mips_elf64_slurp_reloc_table): Support dynamic.
(mips_elf64_slurp_one_reloc_table): Adjust.
@
text
@d309 1
a309 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d311 1
a311 1
	 2,			/* rightshift */
d804 1
a804 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d806 1
a806 1
	 2,			/* rightshift */
d1903 1
a1903 1
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
@


1.44
log
@	* elf32-mips.c (elf_mips_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(elf_reloc_map mips_reloc_map): Map to rightshifted BFD reloc.
	(bfd_elf32_bfd_reloc_type_lookup): Support
	BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* elf64-mips.c (mips_elf64_howto_table_rel): Change definition of
	R_MIPS_PC16 to rightshift 2.
	(mips_elf64_howto_table_rela): Likewise.
	(mips_reloc_map): Map to rightshifted BFD reloc.
	* elfn32-mips.c: The same as in elf64-mips.c.
	* elfxx-mips.c (mips_elf_got_for_ibfd): Typo in comment.
	(mips_elf_calculate_relocation): Handle rightshifted addends for
	R_MIPS_PC16.
	* reloc.c (BFD_RELOC_MIPSEMB_16_PCREL_S2): New BFD relocation for
	MIPS Embedded PIC. Remove superfluous empty COMMENT.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* config/tc-mips.c (append_insn): Add handling of
	BFD_RELOC_MIPSEMB_16_PCREL_S2. Avoid emitting unneeded
	BFD_RELOC_16_PCREL_S2 relocs and add earlier warnings about
	misaligned address and reange overflow.
	(macro_build): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2. Add
	earlier warnings about misaligned address and reange overflow.
	(mips_ip): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	(md_apply_fix): Likewise. Fix warning output.
	(tc_gen_reloc): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	Allow BFD_RELOC_16_PCREL_S2 for all ABIs.
	(md_convert_frag): Add handling of BFD_RELOC_MIPSEMB_16_PCREL_S2.
	* gas/mips/bge.d: Reactivate external branch tests.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.d: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.d: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.d: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.d: New File.
	* gas/mips/branch-misc-2.l: Remove.
	* gas/mips/mips.exp: Adjust branch-misc-2 test.
@
text
@d94 5
d100 2
a101 1
  PARAMS ((bfd *, asection *, asymbol **, const Elf_Internal_Shdr *));
d2031 83
a2113 1
/* Read the relocations from one reloc section.  */
d2116 2
a2117 1
mips_elf64_slurp_one_reloc_table (abfd, asect, symbols, rel_hdr)
d2120 3
d2124 1
a2124 1
     const Elf_Internal_Shdr *rel_hdr;
a2127 1
  arelent *relents;
a2128 1
  bfd_vma count;
d2138 2
a2139 1
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd) != rel_hdr->sh_size))
a2143 2
  relents = asect->relocation + asect->reloc_count;

a2147 2
  count = rel_hdr->sh_size / entsize;

d2153 3
a2155 2
  relent = relents;
  for (i = 0; i < count; i++, native_relocs += entsize)
d2257 1
a2257 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
d2284 4
a2287 1
   associated with a single data section.  */
d2296 6
a2302 1
  struct bfd_elf_section_data * const d = elf_section_data (asect);
d2304 4
a2307 1
  if (dynamic)
d2309 27
a2335 2
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
a2337 5
  if (asect->relocation != NULL
      || (asect->flags & SEC_RELOC) == 0
      || asect->reloc_count == 0)
    return TRUE;

d2339 3
a2341 4
  amt = asect->reloc_count;
  amt *= 3 * sizeof (arelent);
  asect->relocation = (arelent *) bfd_alloc (abfd, amt);
  if (asect->relocation == NULL)
d2347 4
a2350 1
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect, symbols, &d->rel_hdr))
d2354 4
a2357 2
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect, symbols,
					      d->rel_hdr2))
d2361 1
d2891 3
@


1.44.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a93 5
static long mips_elf64_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long mips_elf64_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
static long mips_elf64_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
d95 1
a95 2
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));
d303 3
a305 1
  /* 16 bit PC relative reference.  */
d307 1
a307 1
	 0,			/* rightshift */
d800 3
a802 1
  /* 16 bit PC relative reference.  */
d804 1
a804 1
	 0,			/* rightshift */
d1901 1
a1901 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d2025 1
a2025 83
static long
mips_elf64_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */

static long
mips_elf64_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  unsigned int i;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
{
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */
d2028 1
a2028 2
mips_elf64_slurp_one_reloc_table (abfd, asect, rel_hdr, reloc_count,
				  relents, symbols, dynamic)
a2030 3
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
d2032 1
a2032 1
     bfd_boolean dynamic;
d2036 1
d2038 1
d2048 1
a2048 2
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d2053 2
d2059 2
d2066 2
a2067 3
  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
d2169 1
a2169 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
d2196 1
a2196 4
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */
d2205 1
a2206 6
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;
d2208 1
a2208 4
  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
d2210 3
a2212 12
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
d2214 4
a2217 15
    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }
d2220 4
a2223 3
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = (arelent *) bfd_alloc (abfd, amt);
  if (relents == NULL)
d2229 1
a2229 4
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
d2233 2
a2234 4
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
a2237 1
  asect->relocation = relents;
a2766 3
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
@


1.43
log
@include/elf/ChangeLog
	* sh.h: Split out various bits to bfd/elf32-sh64.h.

include/opcode/ChangeLog
	* m68hc11.h (cpu6812s): Define.

bfd/ChangeLog
	* elf-bfd.h (struct bfd_elf_section_data): Remove tdata.  Change
	dynindx to an int.  Rearrange for better packing.
	* elf.c (_bfd_elf_new_section_hook): Don't alloc if already done.
	* elf32-mips.c (bfd_elf32_new_section_hook): Define.
	* elf32-sh64.h: New.  Split out from include/elf/sh.h.
	(struct _sh64_elf_section_data): New struct.
	(sh64_elf_section_data): Don't dereference sh64_info (was tdata).
	* elf32-sh64-com.c: Include elf32-sh64.h.
	* elf32-sh64.c: Likewise.
	(sh64_elf_new_section_hook): New function.
	(bfd_elf32_new_section_hook): Define.
	(sh64_elf_fake_sections): Adjust for sh64_elf_section_data change.
	(sh64_bfd_elf_copy_private_section_data): Likewise.
	(sh64_elf_final_write_processing): Likewise.
	* elf32-sparc.c (struct elf32_sparc_section_data): New.
	(elf32_sparc_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(elf32_sparc_relax_section): Adjust to use sec_do_relax.
	(elf32_sparc_relocate_section): Likewise.
	* elf64-mips.c (bfd_elf64_new_section_hook): Define.
	* elf64-mmix.c (struct _mmix_elf_section_data): New.
	(mmix_elf_section_data): Define.  Use throughout file.
	(mmix_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-ppc.c (struct _ppc64_elf_section_data): New.
	(ppc64_elf_section_data): Define.  Use throughout.
	(ppc64_elf_new_section_hook): New function.
	(bfd_elf64_new_section_hook): Define.
	* elf64-sparc.c (struct sparc64_elf_section_data): New.
	(sparc64_elf_new_section_hook): New function.
	(SET_SEC_DO_RELAX, SEC_DO_RELAX): Delete.
	(sec_do_relax): Define.
	(sparc64_elf_relax_section): Adjust to use sec_do_relax.
	(sparc64_elf_relocate_section): Likewise.
	(bfd_elf64_new_section_hook): Define.
	* elfn32-mips.c (bfd_elf32_new_section_hook): Define.
	* elfxx-mips.c (struct _mips_elf_section_data): New.
	(mips_elf_section_data): Define.  Use throughout.
	(_bfd_mips_elf_new_section_hook): New function.
	(mips_elf_create_got_section): Don't alloc used_by_bfd.
	* elfxx-mips.h (_bfd_mips_elf_new_section_hook): Declare.
	* elfxx-target.h (bfd_elfNN_new_section_hook): Add #ifndef.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

opcodes/ChangeLog
	* sh64-dis.c: Include elf32-sh64.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

gas/ChangeLog
	* config/tc-sh64.c (shmedia_frob_section_type): Adjust for changed
	sh64_elf_section_data.
	* config/tc-sh64.h: Include elf32-sh64.h.
	* config/tc-m68hc11.c: Don't include stdio.h.
	(md_show_usage): Fix missing continuation.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.

ld/ChangeLog
	* emultempl/sh64elf.em: Include elf32-sh64.h.
	(sh64_elf_${EMULATION_NAME}_before_allocation): Adjust for changed
	sh64_elf_section_data.
	(sh64_elf_${EMULATION_NAME}_after_allocation): Likewise.
@
text
@d303 3
a305 1
  /* 16 bit PC relative reference.  */
d307 1
a307 1
	 0,			/* rightshift */
d800 3
a802 1
  /* 16 bit PC relative reference.  */
d804 1
a804 1
	 0,			/* rightshift */
d1901 1
a1901 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
@


1.42
log
@Add n64 core file support for Linux/MIPS.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d2749 1
@


1.41
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d128 4
d2536 65
d2730 3
@


1.40
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d87 1
a87 1
  PARAMS ((unsigned int, boolean));
d92 3
a94 2
static long mips_elf64_get_reloc_upper_bound PARAMS ((bfd *, asection *));
static boolean mips_elf64_slurp_one_reloc_table
d96 4
a99 3
static boolean mips_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, boolean));
static void mips_elf64_write_relocs PARAMS ((bfd *, asection *, PTR));
d120 2
a121 1
static boolean mips_elf64_assign_gp PARAMS ((bfd *, bfd_vma *));
d123 5
a127 3
  PARAMS ((bfd *, asymbol *, boolean, char **, bfd_vma *));
static boolean mips_elf64_object_p PARAMS ((bfd *));
static irix_compat_t elf64_mips_irix_compat PARAMS ((bfd *));
d148 1
a148 1
	 false,			/* pc_relative */
d153 1
a153 1
	 false,			/* partial_inplace */
d156 1
a156 1
	 false),		/* pcrel_offset */
d163 1
a163 1
	 false,			/* pc_relative */
d168 1
a168 1
	 true,			/* partial_inplace */
d171 1
a171 1
	 false),		/* pcrel_offset */
d178 1
a178 1
	 false,			/* pc_relative */
d183 1
a183 1
	 true,			/* partial_inplace */
d186 1
a186 1
	 false),		/* pcrel_offset */
d193 1
a193 1
	 false,			/* pc_relative */
d198 1
a198 1
	 true,			/* partial_inplace */
d201 1
a201 1
	 false),		/* pcrel_offset */
d208 1
a208 1
	 false,			/* pc_relative */
d216 1
a216 1
	 true,			/* partial_inplace */
d219 1
a219 1
	 false),		/* pcrel_offset */
d229 1
a229 1
	 false,			/* pc_relative */
d234 1
a234 1
	 true,			/* partial_inplace */
d237 1
a237 1
	 false),		/* pcrel_offset */
d244 1
a244 1
	 false,			/* pc_relative */
d249 1
a249 1
	 true,			/* partial_inplace */
d252 1
a252 1
	 false),		/* pcrel_offset */
d259 1
a259 1
	 false,			/* pc_relative */
d264 1
a264 1
	 true,			/* partial_inplace */
d267 1
a267 1
	 false),		/* pcrel_offset */
d274 1
a274 1
	 false,			/* pc_relative */
d279 1
a279 1
	 true,			/* partial_inplace */
d282 1
a282 1
	 false),		/* pcrel_offset */
d289 1
a289 1
	 false,			/* pc_relative */
d294 1
a294 1
	 true,			/* partial_inplace */
d297 1
a297 1
	 false),		/* pcrel_offset */
d304 1
a304 1
	 true,			/* pc_relative */
d309 1
a309 1
	 true,			/* partial_inplace */
d312 1
a312 1
	 true),			/* pcrel_offset */
d319 1
a319 1
	 false,			/* pc_relative */
d324 1
a324 1
	 true,			/* partial_inplace */
d327 1
a327 1
	 false),		/* pcrel_offset */
d334 1
a334 1
	 false,			/* pc_relative */
d339 1
a339 1
	 true,			/* partial_inplace */
d342 1
a342 1
	 false),		/* pcrel_offset */
d353 1
a353 1
	 false,			/* pc_relative */
d358 1
a358 1
	 true,			/* partial_inplace */
d361 1
a361 1
	 false),		/* pcrel_offset */
d368 1
a368 1
	 false,			/* pc_relative */
d373 1
a373 1
	 true,			/* partial_inplace */
d376 1
a376 1
	 false),		/* pcrel_offset */
d383 1
a383 1
	 false,			/* pc_relative */
d388 1
a388 1
	 true,			/* partial_inplace */
d391 1
a391 1
	 false),		/* pcrel_offset */
d398 1
a398 1
	 false,			/* pc_relative */
d403 1
a403 1
	 true,			/* partial_inplace */
d406 1
a406 1
	 false),		/* pcrel_offset */
d413 1
a413 1
	 false,			/* pc_relative */
d418 1
a418 1
	 true,			/* partial_inplace */
d421 1
a421 1
	 false),		/* pcrel_offset */
d428 1
a428 1
	 false,			/* pc_relative */
d433 1
a433 1
	 true,			/* partial_inplace */
d436 1
a436 1
	 false),		/* pcrel_offset */
d443 1
a443 1
	 false,			/* pc_relative */
d448 1
a448 1
	 true,			/* partial_inplace */
d451 1
a451 1
	 false),		/* pcrel_offset */
d458 1
a458 1
	 false,			/* pc_relative */
d463 1
a463 1
	 true,			/* partial_inplace */
d466 1
a466 1
	 false),		/* pcrel_offset */
d473 1
a473 1
	 false,			/* pc_relative */
d478 1
a478 1
	 true,			/* partial_inplace */
d481 1
a481 1
	 false),		/* pcrel_offset */
d489 1
a489 1
	 false,			/* pc_relative */
d494 1
a494 1
	 true,			/* partial_inplace */
d497 1
a497 1
	 false),		/* pcrel_offset */
d506 1
a506 1
	 false,			/* pc_relative */
d511 1
a511 1
	 true,			/* partial_inplace */
d514 1
a514 1
	 false),		/* pcrel_offset */
d522 1
a522 1
	 false,			/* pc_relative */
d527 1
a527 1
	 true,			/* partial_inplace */
d530 1
a530 1
	 false),		/* pcrel_offset */
d546 1
a546 1
	 false,			/* pc_relative */
d551 1
a551 1
	 true,			/* partial_inplace */
d554 1
a554 1
	 false),		/* pcrel_offset */
d561 1
a561 1
	 false,			/* pc_relative */
d566 1
a566 1
	 true,			/* partial_inplace */
d569 1
a569 1
	 false),		/* pcrel_offset */
d576 1
a576 1
	 false,			/* pc_relative */
d581 1
a581 1
	 true,			/* partial_inplace */
d584 1
a584 1
	 false),		/* pcrel_offset */
d590 1
a590 1
	 false,			/* pc_relative */
d595 1
a595 1
	 true,			/* partial_inplace */
d598 1
a598 1
	 false),		/* pcrel_offset */
d610 1
a610 1
	 false,			/* pc_relative */
d615 1
a615 1
	 true,			/* partial_inplace */
d618 1
a618 1
	 false),		/* pcrel_offset */
d626 1
a626 1
	 false,			/* pc_relative */
d631 1
a631 1
	 false,			/* partial_inplace */
d634 1
a634 1
	 false),		/* pcrel_offset */
d646 1
a646 1
	 false,			/* pc_relative */
d651 1
a651 1
	 false,			/* partial_inplace */
d654 1
a654 1
	 false),		/* pcrel_offset */
d661 1
a661 1
	 false,			/* pc_relative */
d666 1
a666 1
	 false,			/* partial_inplace */
d669 1
a669 1
	 false),		/* pcrel_offset */
d676 1
a676 1
	 false,			/* pc_relative */
d681 1
a681 1
	 false,			/* partial_inplace */
d684 1
a684 1
	 false),		/* pcrel_offset */
d691 1
a691 1
	 false,			/* pc_relative */
d696 1
a696 1
	 false,			/* partial_inplace */
d699 1
a699 1
	 false),		/* pcrel_offset */
d706 1
a706 1
	 false,			/* pc_relative */
d714 1
a714 1
	 false,			/* partial_inplace */
d717 1
a717 1
	 false),		/* pcrel_offset */
d724 1
a724 1
	 false,			/* pc_relative */
d729 1
a729 1
	 false,			/* partial_inplace */
d732 1
a732 1
	 false),		/* pcrel_offset */
d739 1
a739 1
	 false,			/* pc_relative */
d744 1
a744 1
	 false,			/* partial_inplace */
d747 1
a747 1
	 false),		/* pcrel_offset */
d754 1
a754 1
	 false,			/* pc_relative */
d759 1
a759 1
	 false,			/* partial_inplace */
d762 1
a762 1
	 false),		/* pcrel_offset */
d769 1
a769 1
	 false,			/* pc_relative */
d774 1
a774 1
	 false,			/* partial_inplace */
d777 1
a777 1
	 false),		/* pcrel_offset */
d784 1
a784 1
	 false,			/* pc_relative */
d789 1
a789 1
	 false,			/* partial_inplace */
d792 1
a792 1
	 false),		/* pcrel_offset */
d799 1
a799 1
	 true,			/* pc_relative */
d804 1
a804 1
	 false,			/* partial_inplace */
d807 1
a807 1
	 true),			/* pcrel_offset */
d814 1
a814 1
	 false,			/* pc_relative */
d819 1
a819 1
	 false,			/* partial_inplace */
d822 1
a822 1
	 false),		/* pcrel_offset */
d829 1
a829 1
	 false,			/* pc_relative */
d834 1
a834 1
	 false,			/* partial_inplace */
d837 1
a837 1
	 false),		/* pcrel_offset */
d848 1
a848 1
	 false,			/* pc_relative */
d853 1
a853 1
	 false,			/* partial_inplace */
d856 1
a856 1
	 false),		/* pcrel_offset */
d863 1
a863 1
	 false,			/* pc_relative */
d868 1
a868 1
	 false,			/* partial_inplace */
d871 1
a871 1
	 false),		/* pcrel_offset */
d878 1
a878 1
	 false,			/* pc_relative */
d883 1
a883 1
	 false,			/* partial_inplace */
d886 1
a886 1
	 false),		/* pcrel_offset */
d893 1
a893 1
	 false,			/* pc_relative */
d898 1
a898 1
	 false,			/* partial_inplace */
d901 1
a901 1
	 false),		/* pcrel_offset */
d908 1
a908 1
	 false,			/* pc_relative */
d913 1
a913 1
	 false,			/* partial_inplace */
d916 1
a916 1
	 false),		/* pcrel_offset */
d923 1
a923 1
	 false,			/* pc_relative */
d928 1
a928 1
	 false,			/* partial_inplace */
d931 1
a931 1
	 false),		/* pcrel_offset */
d938 1
a938 1
	 false,			/* pc_relative */
d943 1
a943 1
	 false,			/* partial_inplace */
d946 1
a946 1
	 false),		/* pcrel_offset */
d953 1
a953 1
	 false,			/* pc_relative */
d958 1
a958 1
	 false,			/* partial_inplace */
d961 1
a961 1
	 false),		/* pcrel_offset */
d968 1
a968 1
	 false,			/* pc_relative */
d973 1
a973 1
	 false,			/* partial_inplace */
d976 1
a976 1
	 false),		/* pcrel_offset */
d984 1
a984 1
	 false,			/* pc_relative */
d989 1
a989 1
	 false,			/* partial_inplace */
d992 1
a992 1
	 false),		/* pcrel_offset */
d1001 1
a1001 1
	 false,			/* pc_relative */
d1006 1
a1006 1
	 false,			/* partial_inplace */
d1009 1
a1009 1
	 false),		/* pcrel_offset */
d1017 1
a1017 1
	 false,			/* pc_relative */
d1022 1
a1022 1
	 false,			/* partial_inplace */
d1025 1
a1025 1
	 false),		/* pcrel_offset */
d1032 1
a1032 1
	 false,			/* pc_relative */
d1037 1
a1037 1
	 false,			/* partial_inplace */
d1040 1
a1040 1
	 false),		/* pcrel_offset */
d1047 1
a1047 1
	 false,			/* pc_relative */
d1052 1
a1052 1
	 false,			/* partial_inplace */
d1055 1
a1055 1
	 false),		/* pcrel_offset */
d1062 1
a1062 1
	 false,			/* pc_relative */
d1067 1
a1067 1
	 false,			/* partial_inplace */
d1070 1
a1070 1
	 false),		/* pcrel_offset */
d1077 1
a1077 1
	 false,			/* pc_relative */
d1082 1
a1082 1
	 false,			/* partial_inplace */
d1085 1
a1085 1
	 false),		/* pcrel_offset */
d1092 1
a1092 1
	 false,			/* pc_relative */
d1097 1
a1097 1
	 false,			/* partial_inplace */
d1100 1
a1100 1
	 false),		/* pcrel_offset */
d1106 1
a1106 1
	 false,			/* pc_relative */
d1111 1
a1111 1
	 false,			/* partial_inplace */
d1114 1
a1114 1
	 false),		/* pcrel_offset */
d1126 1
a1126 1
	 false,			/* pc_relative */
d1131 1
a1131 1
	 false,			/* partial_inplace */
d1134 1
a1134 1
	 false),		/* pcrel_offset */
d1142 1
a1142 1
	 false,			/* pc_relative */
d1147 1
a1147 1
	 false,			/* partial_inplace */
d1150 1
a1150 1
	 false),		/* pcrel_offset */
d1159 1
a1159 1
	 false,			/* pc_relative */
d1167 1
a1167 1
	 true,			/* partial_inplace */
d1170 1
a1170 1
	 false);		/* pcrel_offset */
d1178 1
a1178 1
	 false,			/* pc_relative */
d1183 1
a1183 1
	 true,			/* partial_inplace */
d1186 1
a1186 1
	 false);		/* pcrel_offset */
d1194 1
a1194 1
	 false,			/* pc_relative */
d1199 1
a1199 1
	 false,			/* partial_inplace */
d1202 1
a1202 1
	 false);		/* pcrel_offset */
d1210 1
a1210 1
	 false,			/* pc_relative */
d1215 1
a1215 1
	 false,			/* partial_inplace */
d1218 1
a1218 1
	 false);		/* pcrel_offset */
d1349 1
a1349 1
#if 0  
d1459 1
a1459 1
/* Set the GP value for OUTPUT_BFD.  Returns false if this is a
d1462 1
a1462 1
static boolean
d1474 1
a1474 1
    return true;
d1504 1
a1504 1
      return false;
d1507 1
a1507 1
  return true;
d1520 1
a1520 1
     boolean relocateable;
d1567 1
a1567 1
  boolean relocateable;
d1585 1
a1585 1
    relocateable = true;
d1588 1
a1588 1
      relocateable = false;
d1615 1
a1615 1
  boolean relocateable;
d1632 1
a1632 1
    relocateable = true;
d1635 1
a1635 1
      relocateable = false;
d1663 1
a1663 1
  boolean relocateable;
d1684 1
a1684 1
      relocateable = true;
d1689 1
a1689 1
      relocateable = false;
d1790 1
a1790 1
    static boolean warned;
d1796 1
a1796 1
    warned = true;
d1815 1
a1815 1
  boolean relocateable;
d1834 1
a1834 1
    relocateable = true;
d1837 1
a1837 1
      relocateable = false;
d1964 1
a1964 1
     boolean rela_p;
d2019 1
a2019 1
static boolean
d2037 1
a2037 1
    return false;
d2062 1
a2062 1
      boolean used_sym, used_ssym;
d2076 2
a2077 2
      used_sym = false;
      used_ssym = false;
d2125 1
a2125 1
		  used_sym = true;
d2149 1
a2149 1
		  used_ssym = true;
d2179 1
a2179 1
  return true;
d2184 1
a2184 1
  return false;
d2190 1
a2190 1
static boolean
d2195 1
a2195 1
     boolean dynamic;
d2203 1
a2203 1
      return false;
d2209 1
a2209 1
    return true;
d2216 1
a2216 1
    return false;
d2222 1
a2222 1
    return false;
d2227 1
a2227 1
	return false;
d2230 1
a2230 1
  return true;
d2241 1
a2241 1
  boolean *failedp = (boolean *) data;
d2309 1
a2309 1
  boolean *failedp = (boolean *) data;
d2319 1
a2319 1
      *failedp = true;
d2351 1
a2351 1
	      *failedp = true;
d2363 1
a2363 1
	  *failedp = true;
d2408 1
a2408 1
  boolean *failedp = (boolean *) data;
d2418 1
a2418 1
      *failedp = true;
d2450 1
a2450 1
	      *failedp = true;
d2463 1
a2463 1
	  *failedp = true;
d2502 1
a2502 1
static boolean
d2512 1
a2512 1
    elf_bad_symtab (abfd) = true;
d2516 1
a2516 1
  return true;
d2618 3
a2620 3
#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
d2693 4
a2696 4
extern boolean bfd_elf64_archive_slurp_armap
  PARAMS((bfd *));
extern boolean bfd_elf64_archive_write_armap
  PARAMS((bfd *, unsigned int, struct orl *, unsigned int, int));
@


1.39
log
@* elf64-mips.c (mips_elf64_slurp_one_reloc_table): Generate
exactly three internal relocs per external reloc.  Set reloc_count
to the external reloc count.
@
text
@d66 1
a66 1
	   Elf64_Mips_Internal_Rel *));
d71 1
a71 1
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rel *,
d77 1
a77 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rel *));
d79 1
a79 1
  PARAMS ((bfd *, const Elf_Internal_Rel *, bfd_byte *));
d89 1
a89 1
  PARAMS ((bfd *, arelent *, Elf64_Internal_Rel *));
d91 1
a91 1
  PARAMS ((bfd *, arelent *, Elf64_Internal_Rela *));
d1221 1
a1221 1
     Elf64_Mips_Internal_Rel *dst;
d1229 1
d1254 1
a1254 1
     const Elf64_Mips_Internal_Rel *src;
d1288 1
a1288 1
     Elf_Internal_Rel *dst;
d1290 1
a1290 1
  Elf64_Mips_Internal_Rel mirel;
d1298 1
d1301 1
d1304 1
d1337 1
a1337 1
     const Elf_Internal_Rel *src;
d1340 1
a1340 1
  Elf64_Mips_Internal_Rel mirel;
d1954 1
a1954 1
/* Given a MIPS Elf64_Internal_Rel, fill in an arelent structure.  */
d1987 1
a1987 1
     Elf64_Internal_Rel *dst ATTRIBUTE_UNUSED;
d1996 1
a1996 1
     Elf64_Internal_Rela *dst ATTRIBUTE_UNUSED;
d2065 3
a2067 14
	{
	  Elf64_Mips_Internal_Rel rel;

	  mips_elf64_swap_reloc_in (abfd,
				    (Elf64_Mips_External_Rel *) native_relocs,
				    &rel);
	  rela.r_offset = rel.r_offset;
	  rela.r_sym = rel.r_sym;
	  rela.r_ssym = rel.r_ssym;
	  rela.r_type3 = rel.r_type3;
	  rela.r_type2 = rel.r_type2;
	  rela.r_type = rel.r_type;
	  rela.r_addend = 0;
	}
d2322 1
a2322 1
      Elf64_Mips_Internal_Rel int_rel;
@


1.38
log
@* elf64-mips.c (mips_elf64_be_swap_reloca_out): Handle type2 and type3.
@
text
@d2076 1
a2076 1
      /* Each entry represents up to three actual relocations.  */
a2098 21
	  if (type == R_MIPS_NONE)
	    {
	      /* There are no more relocations in this entry.  If this
                 is the first entry, we need to generate a dummy
                 relocation so that the generic linker knows that
                 there has been a break in the sequence of relocations
                 applying to a particular address.  */
	      if (ir == 0)
		{
		  relent->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
		  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)
		    relent->address = rela.r_offset;
		  else
		    relent->address = rela.r_offset - asect->vma;
		  relent->addend = 0;
		  relent->howto = &howto_table[(int) R_MIPS_NONE];
		  ++relent;
		}
	      break;
	    }

d2176 1
a2176 1
  asect->reloc_count += relent - relents;
@


1.38.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d65 2
a66 1
  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
d68 2
a69 1
  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
d71 2
a72 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
d74 2
a75 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
d77 1
a77 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d79 1
a79 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d81 1
a81 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d83 1
a83 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d85 1
a85 1
  (bfd *, bfd_reloc_code_real_type);
d87 1
a87 1
  (unsigned int, bfd_boolean);
d89 1
a89 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d91 7
a97 16
  (bfd *, arelent *, Elf_Internal_Rela *);
static long mips_elf64_get_reloc_upper_bound
  (bfd *, asection *);
static long mips_elf64_canonicalize_reloc
  (bfd *, asection *, arelent **, asymbol **);
static long mips_elf64_get_dynamic_reloc_upper_bound
  (bfd *);
static long mips_elf64_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
static bfd_boolean mips_elf64_slurp_one_reloc_table
  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
   asymbol **, bfd_boolean);
static bfd_boolean mips_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);
static void mips_elf64_write_relocs
  (bfd *, asection *, void *);
d99 1
a99 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d101 1
a101 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d103 1
a103 1
  (bfd *, arelent *, asymbol *,	void *, asection *, bfd *, char **);
d105 1
a105 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d107 1
a107 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d109 1
a109 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d111 1
a111 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d113 1
a113 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d115 1
a115 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d117 2
a118 3
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean mips_elf64_assign_gp
  (bfd *, bfd_vma *);
d120 3
a122 9
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
static bfd_boolean mips_elf64_object_p
  (bfd *);
static irix_compat_t elf64_mips_irix_compat
  (bfd *);
static bfd_boolean elf64_mips_grok_prstatus
  (bfd *, Elf_Internal_Note *);
static bfd_boolean elf64_mips_grok_psinfo
  (bfd *, Elf_Internal_Note *);
d143 1
a143 1
	 FALSE,			/* pc_relative */
d148 1
a148 1
	 FALSE,			/* partial_inplace */
d151 1
a151 1
	 FALSE),		/* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d163 1
a163 1
	 TRUE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),		/* pcrel_offset */
d173 1
a173 1
	 FALSE,			/* pc_relative */
d178 1
a178 1
	 TRUE,			/* partial_inplace */
d181 1
a181 1
	 FALSE),		/* pcrel_offset */
d188 1
a188 1
	 FALSE,			/* pc_relative */
d193 1
a193 1
	 TRUE,			/* partial_inplace */
d196 1
a196 1
	 FALSE),		/* pcrel_offset */
d203 1
a203 1
	 FALSE,			/* pc_relative */
d211 1
a211 1
	 TRUE,			/* partial_inplace */
d214 1
a214 1
	 FALSE),		/* pcrel_offset */
d224 1
a224 1
	 FALSE,			/* pc_relative */
d229 1
a229 1
	 TRUE,			/* partial_inplace */
d232 1
a232 1
	 FALSE),		/* pcrel_offset */
d239 1
a239 1
	 FALSE,			/* pc_relative */
d244 1
a244 1
	 TRUE,			/* partial_inplace */
d247 1
a247 1
	 FALSE),		/* pcrel_offset */
d254 1
a254 1
	 FALSE,			/* pc_relative */
d259 1
a259 1
	 TRUE,			/* partial_inplace */
d262 1
a262 1
	 FALSE),		/* pcrel_offset */
d269 1
a269 1
	 FALSE,			/* pc_relative */
d274 1
a274 1
	 TRUE,			/* partial_inplace */
d277 1
a277 1
	 FALSE),		/* pcrel_offset */
d284 1
a284 1
	 FALSE,			/* pc_relative */
d289 1
a289 1
	 TRUE,			/* partial_inplace */
d292 1
a292 1
	 FALSE),		/* pcrel_offset */
d299 1
a299 1
	 TRUE,			/* pc_relative */
d304 1
a304 1
	 TRUE,			/* partial_inplace */
d307 1
a307 1
	 TRUE),			/* pcrel_offset */
d314 1
a314 1
	 FALSE,			/* pc_relative */
d319 1
a319 1
	 TRUE,			/* partial_inplace */
d322 1
a322 1
	 FALSE),		/* pcrel_offset */
d329 1
a329 1
	 FALSE,			/* pc_relative */
d334 1
a334 1
	 TRUE,			/* partial_inplace */
d337 1
a337 1
	 FALSE),		/* pcrel_offset */
d348 1
a348 1
	 FALSE,			/* pc_relative */
d353 1
a353 1
	 TRUE,			/* partial_inplace */
d356 1
a356 1
	 FALSE),		/* pcrel_offset */
d363 1
a363 1
	 FALSE,			/* pc_relative */
d368 1
a368 1
	 TRUE,			/* partial_inplace */
d371 1
a371 1
	 FALSE),		/* pcrel_offset */
d378 1
a378 1
	 FALSE,			/* pc_relative */
d383 1
a383 1
	 TRUE,			/* partial_inplace */
d386 1
a386 1
	 FALSE),		/* pcrel_offset */
d393 1
a393 1
	 FALSE,			/* pc_relative */
d398 1
a398 1
	 TRUE,			/* partial_inplace */
d401 1
a401 1
	 FALSE),		/* pcrel_offset */
d408 1
a408 1
	 FALSE,			/* pc_relative */
d413 1
a413 1
	 TRUE,			/* partial_inplace */
d416 1
a416 1
	 FALSE),		/* pcrel_offset */
d423 1
a423 1
	 FALSE,			/* pc_relative */
d428 1
a428 1
	 TRUE,			/* partial_inplace */
d431 1
a431 1
	 FALSE),		/* pcrel_offset */
d438 1
a438 1
	 FALSE,			/* pc_relative */
d443 1
a443 1
	 TRUE,			/* partial_inplace */
d446 1
a446 1
	 FALSE),		/* pcrel_offset */
d453 1
a453 1
	 FALSE,			/* pc_relative */
d458 1
a458 1
	 TRUE,			/* partial_inplace */
d461 1
a461 1
	 FALSE),		/* pcrel_offset */
d463 1
a463 1
  /* 64 bit subtraction.  */
d468 1
a468 1
	 FALSE,			/* pc_relative */
d473 1
a473 1
	 TRUE,			/* partial_inplace */
d476 1
a476 1
	 FALSE),		/* pcrel_offset */
d484 1
a484 1
	 FALSE,			/* pc_relative */
d489 1
a489 1
	 TRUE,			/* partial_inplace */
d492 1
a492 1
	 FALSE),		/* pcrel_offset */
d501 1
a501 1
	 FALSE,			/* pc_relative */
d506 1
a506 1
	 TRUE,			/* partial_inplace */
d509 1
a509 1
	 FALSE),		/* pcrel_offset */
d517 1
a517 1
	 FALSE,			/* pc_relative */
d522 1
a522 1
	 TRUE,			/* partial_inplace */
d525 1
a525 1
	 FALSE),		/* pcrel_offset */
d541 1
a541 1
	 FALSE,			/* pc_relative */
d546 1
a546 1
	 TRUE,			/* partial_inplace */
d549 1
a549 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 TRUE,			/* partial_inplace */
d564 1
a564 1
	 FALSE),		/* pcrel_offset */
d571 1
a571 1
	 FALSE,			/* pc_relative */
d576 1
a576 1
	 TRUE,			/* partial_inplace */
d579 1
a579 1
	 FALSE),		/* pcrel_offset */
d585 1
a585 1
	 FALSE,			/* pc_relative */
d590 1
a590 1
	 TRUE,			/* partial_inplace */
d593 1
a593 1
	 FALSE),		/* pcrel_offset */
d605 1
a605 1
	 FALSE,			/* pc_relative */
d610 1
a610 1
	 TRUE,			/* partial_inplace */
d613 1
a613 1
	 FALSE),		/* pcrel_offset */
d621 1
a621 1
	 FALSE,			/* pc_relative */
d626 1
a626 1
	 FALSE,			/* partial_inplace */
d629 1
a629 1
	 FALSE),		/* pcrel_offset */
d641 1
a641 1
	 FALSE,			/* pc_relative */
d646 1
a646 1
	 FALSE,			/* partial_inplace */
d649 1
a649 1
	 FALSE),		/* pcrel_offset */
d656 1
a656 1
	 FALSE,			/* pc_relative */
d661 1
a661 1
	 FALSE,			/* partial_inplace */
d664 1
a664 1
	 FALSE),		/* pcrel_offset */
d671 1
a671 1
	 FALSE,			/* pc_relative */
d676 1
a676 1
	 FALSE,			/* partial_inplace */
d679 1
a679 1
	 FALSE),		/* pcrel_offset */
d686 1
a686 1
	 FALSE,			/* pc_relative */
d691 1
a691 1
	 FALSE,			/* partial_inplace */
d694 1
a694 1
	 FALSE),		/* pcrel_offset */
d701 1
a701 1
	 FALSE,			/* pc_relative */
d709 1
a709 1
	 FALSE,			/* partial_inplace */
d712 1
a712 1
	 FALSE),		/* pcrel_offset */
d719 1
a719 1
	 FALSE,			/* pc_relative */
d724 1
a724 1
	 FALSE,			/* partial_inplace */
d727 1
a727 1
	 FALSE),		/* pcrel_offset */
d734 1
a734 1
	 FALSE,			/* pc_relative */
d739 1
a739 1
	 FALSE,			/* partial_inplace */
d742 1
a742 1
	 FALSE),		/* pcrel_offset */
d749 1
a749 1
	 FALSE,			/* pc_relative */
d754 1
a754 1
	 FALSE,			/* partial_inplace */
d757 1
a757 1
	 FALSE),		/* pcrel_offset */
d764 1
a764 1
	 FALSE,			/* pc_relative */
d769 1
a769 1
	 FALSE,			/* partial_inplace */
d772 1
a772 1
	 FALSE),		/* pcrel_offset */
d779 1
a779 1
	 FALSE,			/* pc_relative */
d784 1
a784 1
	 FALSE,			/* partial_inplace */
d787 1
a787 1
	 FALSE),		/* pcrel_offset */
d794 1
a794 1
	 TRUE,			/* pc_relative */
d799 1
a799 1
	 FALSE,			/* partial_inplace */
d802 1
a802 1
	 TRUE),			/* pcrel_offset */
d809 1
a809 1
	 FALSE,			/* pc_relative */
d814 1
a814 1
	 FALSE,			/* partial_inplace */
d817 1
a817 1
	 FALSE),		/* pcrel_offset */
d824 1
a824 1
	 FALSE,			/* pc_relative */
d829 1
a829 1
	 FALSE,			/* partial_inplace */
d832 1
a832 1
	 FALSE),		/* pcrel_offset */
d843 1
a843 1
	 FALSE,			/* pc_relative */
d848 1
a848 1
	 FALSE,			/* partial_inplace */
d851 1
a851 1
	 FALSE),		/* pcrel_offset */
d858 1
a858 1
	 FALSE,			/* pc_relative */
d863 1
a863 1
	 FALSE,			/* partial_inplace */
d866 1
a866 1
	 FALSE),		/* pcrel_offset */
d873 1
a873 1
	 FALSE,			/* pc_relative */
d878 1
a878 1
	 FALSE,			/* partial_inplace */
d881 1
a881 1
	 FALSE),		/* pcrel_offset */
d888 1
a888 1
	 FALSE,			/* pc_relative */
d893 1
a893 1
	 FALSE,			/* partial_inplace */
d896 1
a896 1
	 FALSE),		/* pcrel_offset */
d903 1
a903 1
	 FALSE,			/* pc_relative */
d908 1
a908 1
	 FALSE,			/* partial_inplace */
d911 1
a911 1
	 FALSE),		/* pcrel_offset */
d918 1
a918 1
	 FALSE,			/* pc_relative */
d923 1
a923 1
	 FALSE,			/* partial_inplace */
d926 1
a926 1
	 FALSE),		/* pcrel_offset */
d933 1
a933 1
	 FALSE,			/* pc_relative */
d938 1
a938 1
	 FALSE,			/* partial_inplace */
d941 1
a941 1
	 FALSE),		/* pcrel_offset */
d948 1
a948 1
	 FALSE,			/* pc_relative */
d953 1
a953 1
	 FALSE,			/* partial_inplace */
d956 1
a956 1
	 FALSE),		/* pcrel_offset */
d958 1
a958 1
  /* 64 bit subtraction.  */
d963 1
a963 1
	 FALSE,			/* pc_relative */
d968 1
a968 1
	 FALSE,			/* partial_inplace */
d971 1
a971 1
	 FALSE),		/* pcrel_offset */
d979 1
a979 1
	 FALSE,			/* pc_relative */
d984 1
a984 1
	 FALSE,			/* partial_inplace */
d987 1
a987 1
	 FALSE),		/* pcrel_offset */
d996 1
a996 1
	 FALSE,			/* pc_relative */
d1001 1
a1001 1
	 FALSE,			/* partial_inplace */
d1004 1
a1004 1
	 FALSE),		/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),		/* pcrel_offset */
d1027 1
a1027 1
	 FALSE,			/* pc_relative */
d1032 1
a1032 1
	 FALSE,			/* partial_inplace */
d1035 1
a1035 1
	 FALSE),		/* pcrel_offset */
d1042 1
a1042 1
	 FALSE,			/* pc_relative */
d1047 1
a1047 1
	 FALSE,			/* partial_inplace */
d1050 1
a1050 1
	 FALSE),		/* pcrel_offset */
d1057 1
a1057 1
	 FALSE,			/* pc_relative */
d1062 1
a1062 1
	 FALSE,			/* partial_inplace */
d1065 1
a1065 1
	 FALSE),		/* pcrel_offset */
d1072 1
a1072 1
	 FALSE,			/* pc_relative */
d1077 1
a1077 1
	 FALSE,			/* partial_inplace */
d1080 1
a1080 1
	 FALSE),		/* pcrel_offset */
d1087 1
a1087 1
	 FALSE,			/* pc_relative */
d1092 1
a1092 1
	 FALSE,			/* partial_inplace */
d1095 1
a1095 1
	 FALSE),		/* pcrel_offset */
d1101 1
a1101 1
	 FALSE,			/* pc_relative */
d1106 1
a1106 1
	 FALSE,			/* partial_inplace */
d1109 1
a1109 1
	 FALSE),		/* pcrel_offset */
d1121 1
a1121 1
	 FALSE,			/* pc_relative */
d1126 1
a1126 1
	 FALSE,			/* partial_inplace */
d1129 1
a1129 1
	 FALSE),		/* pcrel_offset */
d1137 1
a1137 1
	 FALSE,			/* pc_relative */
d1142 1
a1142 1
	 FALSE,			/* partial_inplace */
d1145 1
a1145 1
	 FALSE),		/* pcrel_offset */
d1154 1
a1154 1
	 FALSE,			/* pc_relative */
d1162 1
a1162 1
	 TRUE,			/* partial_inplace */
d1165 1
a1165 1
	 FALSE);		/* pcrel_offset */
d1173 1
a1173 1
	 FALSE,			/* pc_relative */
d1178 1
a1178 1
	 TRUE,			/* partial_inplace */
d1181 1
a1181 1
	 FALSE);		/* pcrel_offset */
d1189 1
a1189 1
	 FALSE,			/* pc_relative */
d1194 1
a1194 1
	 FALSE,			/* partial_inplace */
d1197 1
a1197 1
	 FALSE);		/* pcrel_offset */
d1205 1
a1205 1
	 FALSE,			/* pc_relative */
d1210 1
a1210 1
	 FALSE,			/* partial_inplace */
d1213 1
a1213 33
	 FALSE);		/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rela16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */
d1218 4
a1221 2
mips_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
			  Elf64_Mips_Internal_Rela *dst)
a1228 1
  dst->r_addend = 0;
d1234 4
a1237 2
mips_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
			   Elf64_Mips_Internal_Rela *dst)
d1251 4
a1254 2
mips_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			   Elf64_Mips_External_Rel *dst)
d1267 4
a1270 2
mips_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			    Elf64_Mips_External_Rela *dst)
d1284 4
a1287 2
mips_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
			     Elf_Internal_Rela *dst)
d1289 1
a1289 1
  Elf64_Mips_Internal_Rela mirel;
a1296 1
  dst[0].r_addend = 0;
a1298 1
  dst[1].r_addend = 0;
a1300 1
  dst[2].r_addend = 0;
d1306 4
a1309 2
mips_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
			      Elf_Internal_Rela *dst)
d1331 4
a1334 2
mips_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
			      bfd_byte *dst)
d1336 1
a1336 1
  Elf64_Mips_Internal_Rela mirel;
d1340 1
a1340 1
#if 0
d1357 4
a1360 2
mips_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
			       bfd_byte *dst)
d1385 9
a1393 4
mips_elf64_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		       asection *input_section, bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d1397 1
a1397 1
  if (output_bfd != NULL
d1399 2
a1400 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1406 2
a1407 5
  if (reloc_entry->howto->partial_inplace)
    {
      if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
	reloc_entry->addend += 0x8000;
    }
d1427 9
a1435 3
mips_elf64_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d1439 2
a1440 3
  if (output_bfd != NULL
      && ((symbol->flags & BSF_SECTION_SYM) != 0
	  || (symbol->flags & BSF_LOCAL) == 0))
d1450 1
a1450 1
/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
d1453 4
a1456 2
static bfd_boolean
mips_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d1465 1
a1465 1
    return TRUE;
d1472 1
a1472 1
  if (sym == NULL)
d1495 1
a1495 1
      return FALSE;
d1498 1
a1498 1
  return TRUE;
d1505 1
a1505 1
   external symbol if we are producing relocatable output.  */
d1508 6
a1513 2
mips_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		     char **error_message, bfd_vma *pgp)
d1516 1
a1516 1
      && ! relocatable)
d1524 1
a1524 1
      && (! relocatable
d1527 1
a1527 1
      if (relocatable)
d1548 9
a1556 3
mips_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1558 1
a1558 1
  bfd_boolean relocatable;
d1562 5
a1566 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1568 2
a1569 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1575 2
a1576 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1579 1
a1579 1
      relocatable = FALSE;
d1583 1
a1583 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1589 1
a1589 1
					input_section, relocatable,
d1596 9
a1604 3
mips_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1606 1
a1606 1
  bfd_boolean relocatable;
d1612 1
a1612 1
  if (output_bfd != NULL
d1614 2
a1615 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1622 2
a1623 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1626 1
a1626 1
      relocatable = FALSE;
d1630 1
a1630 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1636 1
a1636 1
					input_section, relocatable,
d1644 9
a1652 3
mips_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1654 1
a1654 1
  bfd_boolean relocatable;
d1658 1
a1658 1
  bfd_vma val;
d1660 5
a1664 3
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
  if (output_bfd != NULL
d1666 1
a1666 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1673 5
a1677 2
  if (output_bfd != NULL)
    relocatable = TRUE;
d1680 1
a1680 1
      relocatable = FALSE;
d1682 5
a1688 5
    ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
    if (ret != bfd_reloc_ok)
      return ret;

d1700 8
d1709 1
a1709 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1712 1
a1712 1
     are producing relocatable output, we don't want to do this for
d1714 1
a1714 1
  if (! relocatable
d1718 1
a1718 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1720 1
a1720 1
  if (relocatable)
d1730 9
a1738 4
mips_elf64_shift6_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			 asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			 asection *input_section, bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
d1742 1
a1742 1
  if (output_bfd != NULL
d1744 2
a1745 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1751 2
a1752 5
  if (reloc_entry->howto->partial_inplace)
    {
      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
			     | (reloc_entry->addend & 0x00000800) >> 9);
    }
d1760 9
a1768 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1770 1
a1770 1
  if (output_bfd != NULL
d1781 1
a1781 1
    static bfd_boolean warned;
d1787 1
a1787 1
    warned = TRUE;
d1796 9
a1804 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1806 1
a1806 1
  bfd_boolean relocatable;
d1809 2
a1810 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1813 3
a1815 1
     addend, we don't want to change anything.  */
d1818 1
a1818 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1825 1
a1825 1
    relocatable = TRUE;
d1828 1
a1828 1
      relocatable = FALSE;
d1832 1
a1832 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1840 25
a1864 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1866 1
a1866 41
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);

  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (insn & 0xffe0) | (val & 0x1f),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
d1918 3
a1920 2
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
a1943 2
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rela16_s2;
d1950 1
a1950 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1953 3
a1955 1
mips_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
a1966 5
    case R_MIPS_GNU_REL16_S2:
      if (rela_p)
	return &elf_mips_gnu_rela16_s2;
      else
	return &elf_mips_gnu_rel16_s2;
d1980 4
a1983 3
mips_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			      arelent *cache_ptr ATTRIBUTE_UNUSED,
			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d1989 4
a1992 3
mips_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr ATTRIBUTE_UNUSED,
			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d2001 3
a2003 1
mips_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d2008 1
a2008 10
static long
mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */
d2010 6
a2015 3
static long
mips_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
			       arelent **relptr, asymbol **symbols)
d2017 1
a2017 70
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
				       asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */

static bfd_boolean
mips_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
				  Elf_Internal_Shdr *rel_hdr,
				  bfd_size_type reloc_count,
				  arelent *relents, asymbol **symbols,
				  bfd_boolean dynamic)
{
  void *allocated;
d2019 1
d2021 1
d2026 1
a2026 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d2028 1
a2028 1
    return FALSE;
d2031 1
a2031 2
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d2034 3
a2036 1
  native_relocs = allocated;
d2042 2
d2049 2
a2050 3
  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
d2053 1
a2053 1
      bfd_boolean used_sym, used_ssym;
d2061 2
a2062 3
	mips_elf64_swap_reloc_in (abfd,
				  (Elf64_Mips_External_Rel *) native_relocs,
				  &rela);
d2064 13
a2076 1
      /* Each entry represents exactly three actual relocations.  */
d2078 2
a2079 2
      used_sym = FALSE;
      used_ssym = FALSE;
d2099 21
d2148 1
a2148 1
		  used_sym = TRUE;
d2172 1
a2172 1
		  used_ssym = TRUE;
d2184 1
a2184 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
d2197 1
a2197 1
  asect->reloc_count += (relent - relents) / 3;
d2202 1
a2202 1
  return TRUE;
d2207 1
a2207 1
  return FALSE;
d2211 8
a2218 8
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */

static bfd_boolean
mips_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
			      asymbol **symbols, bfd_boolean dynamic)
d2220 1
a2221 9
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;

  if (asect->relocation != NULL)
    return TRUE;
d2223 1
a2223 1
  if (! dynamic)
d2225 3
a2227 12
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
d2229 4
a2232 15
    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }
d2235 5
a2239 4
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = bfd_alloc (abfd, amt);
  if (relents == NULL)
    return FALSE;
d2244 2
a2245 5
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
    return FALSE;
d2248 3
a2250 5
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
	return FALSE;
d2253 1
a2253 2
  asect->relocation = relents;
  return TRUE;
d2259 4
a2262 1
mips_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
d2264 1
a2264 1
  bfd_boolean *failedp = data;
d2325 6
a2330 3
mips_elf64_write_rel (bfd *abfd, asection *sec,
		      Elf_Internal_Shdr *rel_hdr,
		      int *count, void *data)
d2332 1
a2332 1
  bfd_boolean *failedp = data;
d2338 2
a2339 2
  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
d2342 1
a2342 1
      *failedp = TRUE;
d2350 1
a2350 1
      Elf64_Mips_Internal_Rela int_rel;
d2374 1
a2374 1
	      *failedp = TRUE;
d2386 1
a2386 1
	  *failedp = TRUE;
d2424 6
a2429 3
mips_elf64_write_rela (bfd *abfd, asection *sec,
		       Elf_Internal_Shdr *rela_hdr,
		       int *count, void *data)
d2431 1
a2431 1
  bfd_boolean *failedp = data;
d2437 2
a2438 2
  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d2441 1
a2441 1
      *failedp = TRUE;
d2473 1
a2473 1
	      *failedp = TRUE;
d2486 1
a2486 1
	  *failedp = TRUE;
d2525 3
a2527 2
static bfd_boolean
mips_elf64_object_p (bfd *abfd)
d2535 1
a2535 1
    elf_bad_symtab (abfd) = TRUE;
d2539 1
a2539 1
  return TRUE;
d2545 2
a2546 1
elf64_mips_irix_compat (bfd *abfd)
a2554 61
/* Support for core dump NOTE sections.  */
static bfd_boolean
elf64_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 480:		/* Linux/MIPS - N64 kernel */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	raw_size = 360;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
elf64_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 136:		/* Linux/MIPS - N64 kernel elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

d2615 1
a2615 1
  3,		/* log_file_align */
d2641 3
a2643 3
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
a2676 2
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
a2684 3
#define elf_backend_grok_prstatus	elf64_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf64_mips_grok_psinfo

d2686 1
a2699 1
#define bfd_elf64_new_section_hook	_bfd_mips_elf_new_section_hook
a2712 4
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
#define bfd_elf64_bfd_relax_section     _bfd_mips_relax_section
d2716 4
a2719 4
extern bfd_boolean bfd_elf64_archive_slurp_armap
  (bfd *);
extern bfd_boolean bfd_elf64_archive_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int);
@


1.38.4.2
log
@Merge from mainline.
@
text
@d107 2
d117 2
d158 1
a158 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d173 1
a173 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d188 1
a188 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d203 1
a203 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d221 1
a221 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d233 1
a233 1
	 16,			/* rightshift */
d239 1
a239 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d254 1
a254 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d299 1
a299 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d314 1
a314 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d329 1
a329 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d363 1
a363 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d393 1
a393 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d408 1
a408 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d423 1
a423 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d438 1
a438 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d453 1
a453 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d468 1
a468 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d483 1
a483 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d499 1
a499 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d516 1
a516 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d532 1
a532 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d556 1
a556 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d571 1
a571 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d586 1
a586 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d600 1
a600 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d620 1
a620 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d636 1
a636 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d656 1
a656 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d671 1
a671 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d686 1
a686 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d701 1
a701 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d719 1
a719 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d734 1
a734 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d749 1
a749 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d794 1
a794 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d809 1
a809 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d824 1
a824 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d858 1
a858 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d888 1
a888 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d903 1
a903 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d918 1
a918 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d933 1
a933 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d948 1
a948 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d963 1
a963 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d978 1
a978 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d994 1
a994 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1011 1
a1011 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1027 1
a1027 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1042 1
a1042 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1057 1
a1057 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1072 1
a1072 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1087 1
a1087 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1102 1
a1102 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1116 1
a1116 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1136 1
a1136 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1152 1
a1152 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1236 1
a1236 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1252 1
a1252 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1414 60
d1719 4
a1722 3
mips_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section, bfd *output_bfd,
			 char **error_message)
d1724 10
d1740 1
a1740 3
  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
@


1.38.4.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2679 5
d2794 1
a2794 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000
d2796 1
a2796 1
#include "elf64-target.h"
a2803 2
#undef ELF_MAXPAGESIZE

a2807 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf64_bed			elf64_tradbed
@


1.38.4.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2018 1
a2018 1
  bfd_boolean rela_p;
d2036 1
a2036 1
    rela_p = FALSE;
d2038 1
a2038 1
    rela_p = TRUE;
d2151 1
a2151 1
	  relent->howto = mips_elf64_rtype_to_howto (type, rela_p);
@


1.38.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d2076 1
a2076 1
      /* Each entry represents exactly three actual relocations.  */
d2099 21
d2197 1
a2197 1
  asect->reloc_count += (relent - relents) / 3;
@


1.38.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d66 1
a66 1
	   Elf64_Mips_Internal_Rela *));
d71 1
a71 1
  PARAMS ((bfd *, const Elf64_Mips_Internal_Rela *,
d77 1
a77 1
  PARAMS ((bfd *, const bfd_byte *, Elf_Internal_Rela *));
d79 1
a79 1
  PARAMS ((bfd *, const Elf_Internal_Rela *, bfd_byte *));
d87 1
a87 1
  PARAMS ((unsigned int, bfd_boolean));
d89 1
a89 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d91 3
a93 4
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static long mips_elf64_get_reloc_upper_bound
  PARAMS ((bfd *, asection *));
static bfd_boolean mips_elf64_slurp_one_reloc_table
d95 3
a97 4
static bfd_boolean mips_elf64_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static void mips_elf64_write_relocs
  PARAMS ((bfd *, asection *, PTR));
d118 1
a118 2
static bfd_boolean mips_elf64_assign_gp
  PARAMS ((bfd *, bfd_vma *));
d120 3
a122 9
  PARAMS ((bfd *, asymbol *, bfd_boolean, char **, bfd_vma *));
static bfd_boolean mips_elf64_object_p
  PARAMS ((bfd *));
static irix_compat_t elf64_mips_irix_compat
  PARAMS ((bfd *));
static bfd_boolean elf64_mips_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf64_mips_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
d143 1
a143 1
	 FALSE,			/* pc_relative */
d148 1
a148 1
	 FALSE,			/* partial_inplace */
d151 1
a151 1
	 FALSE),		/* pcrel_offset */
d158 1
a158 1
	 FALSE,			/* pc_relative */
d163 1
a163 1
	 TRUE,			/* partial_inplace */
d166 1
a166 1
	 FALSE),		/* pcrel_offset */
d173 1
a173 1
	 FALSE,			/* pc_relative */
d178 1
a178 1
	 TRUE,			/* partial_inplace */
d181 1
a181 1
	 FALSE),		/* pcrel_offset */
d188 1
a188 1
	 FALSE,			/* pc_relative */
d193 1
a193 1
	 TRUE,			/* partial_inplace */
d196 1
a196 1
	 FALSE),		/* pcrel_offset */
d203 1
a203 1
	 FALSE,			/* pc_relative */
d211 1
a211 1
	 TRUE,			/* partial_inplace */
d214 1
a214 1
	 FALSE),		/* pcrel_offset */
d224 1
a224 1
	 FALSE,			/* pc_relative */
d229 1
a229 1
	 TRUE,			/* partial_inplace */
d232 1
a232 1
	 FALSE),		/* pcrel_offset */
d239 1
a239 1
	 FALSE,			/* pc_relative */
d244 1
a244 1
	 TRUE,			/* partial_inplace */
d247 1
a247 1
	 FALSE),		/* pcrel_offset */
d254 1
a254 1
	 FALSE,			/* pc_relative */
d259 1
a259 1
	 TRUE,			/* partial_inplace */
d262 1
a262 1
	 FALSE),		/* pcrel_offset */
d269 1
a269 1
	 FALSE,			/* pc_relative */
d274 1
a274 1
	 TRUE,			/* partial_inplace */
d277 1
a277 1
	 FALSE),		/* pcrel_offset */
d284 1
a284 1
	 FALSE,			/* pc_relative */
d289 1
a289 1
	 TRUE,			/* partial_inplace */
d292 1
a292 1
	 FALSE),		/* pcrel_offset */
d299 1
a299 1
	 TRUE,			/* pc_relative */
d304 1
a304 1
	 TRUE,			/* partial_inplace */
d307 1
a307 1
	 TRUE),			/* pcrel_offset */
d314 1
a314 1
	 FALSE,			/* pc_relative */
d319 1
a319 1
	 TRUE,			/* partial_inplace */
d322 1
a322 1
	 FALSE),		/* pcrel_offset */
d329 1
a329 1
	 FALSE,			/* pc_relative */
d334 1
a334 1
	 TRUE,			/* partial_inplace */
d337 1
a337 1
	 FALSE),		/* pcrel_offset */
d348 1
a348 1
	 FALSE,			/* pc_relative */
d353 1
a353 1
	 TRUE,			/* partial_inplace */
d356 1
a356 1
	 FALSE),		/* pcrel_offset */
d363 1
a363 1
	 FALSE,			/* pc_relative */
d368 1
a368 1
	 TRUE,			/* partial_inplace */
d371 1
a371 1
	 FALSE),		/* pcrel_offset */
d378 1
a378 1
	 FALSE,			/* pc_relative */
d383 1
a383 1
	 TRUE,			/* partial_inplace */
d386 1
a386 1
	 FALSE),		/* pcrel_offset */
d393 1
a393 1
	 FALSE,			/* pc_relative */
d398 1
a398 1
	 TRUE,			/* partial_inplace */
d401 1
a401 1
	 FALSE),		/* pcrel_offset */
d408 1
a408 1
	 FALSE,			/* pc_relative */
d413 1
a413 1
	 TRUE,			/* partial_inplace */
d416 1
a416 1
	 FALSE),		/* pcrel_offset */
d423 1
a423 1
	 FALSE,			/* pc_relative */
d428 1
a428 1
	 TRUE,			/* partial_inplace */
d431 1
a431 1
	 FALSE),		/* pcrel_offset */
d438 1
a438 1
	 FALSE,			/* pc_relative */
d443 1
a443 1
	 TRUE,			/* partial_inplace */
d446 1
a446 1
	 FALSE),		/* pcrel_offset */
d453 1
a453 1
	 FALSE,			/* pc_relative */
d458 1
a458 1
	 TRUE,			/* partial_inplace */
d461 1
a461 1
	 FALSE),		/* pcrel_offset */
d468 1
a468 1
	 FALSE,			/* pc_relative */
d473 1
a473 1
	 TRUE,			/* partial_inplace */
d476 1
a476 1
	 FALSE),		/* pcrel_offset */
d484 1
a484 1
	 FALSE,			/* pc_relative */
d489 1
a489 1
	 TRUE,			/* partial_inplace */
d492 1
a492 1
	 FALSE),		/* pcrel_offset */
d501 1
a501 1
	 FALSE,			/* pc_relative */
d506 1
a506 1
	 TRUE,			/* partial_inplace */
d509 1
a509 1
	 FALSE),		/* pcrel_offset */
d517 1
a517 1
	 FALSE,			/* pc_relative */
d522 1
a522 1
	 TRUE,			/* partial_inplace */
d525 1
a525 1
	 FALSE),		/* pcrel_offset */
d541 1
a541 1
	 FALSE,			/* pc_relative */
d546 1
a546 1
	 TRUE,			/* partial_inplace */
d549 1
a549 1
	 FALSE),		/* pcrel_offset */
d556 1
a556 1
	 FALSE,			/* pc_relative */
d561 1
a561 1
	 TRUE,			/* partial_inplace */
d564 1
a564 1
	 FALSE),		/* pcrel_offset */
d571 1
a571 1
	 FALSE,			/* pc_relative */
d576 1
a576 1
	 TRUE,			/* partial_inplace */
d579 1
a579 1
	 FALSE),		/* pcrel_offset */
d585 1
a585 1
	 FALSE,			/* pc_relative */
d590 1
a590 1
	 TRUE,			/* partial_inplace */
d593 1
a593 1
	 FALSE),		/* pcrel_offset */
d605 1
a605 1
	 FALSE,			/* pc_relative */
d610 1
a610 1
	 TRUE,			/* partial_inplace */
d613 1
a613 1
	 FALSE),		/* pcrel_offset */
d621 1
a621 1
	 FALSE,			/* pc_relative */
d626 1
a626 1
	 FALSE,			/* partial_inplace */
d629 1
a629 1
	 FALSE),		/* pcrel_offset */
d641 1
a641 1
	 FALSE,			/* pc_relative */
d646 1
a646 1
	 FALSE,			/* partial_inplace */
d649 1
a649 1
	 FALSE),		/* pcrel_offset */
d656 1
a656 1
	 FALSE,			/* pc_relative */
d661 1
a661 1
	 FALSE,			/* partial_inplace */
d664 1
a664 1
	 FALSE),		/* pcrel_offset */
d671 1
a671 1
	 FALSE,			/* pc_relative */
d676 1
a676 1
	 FALSE,			/* partial_inplace */
d679 1
a679 1
	 FALSE),		/* pcrel_offset */
d686 1
a686 1
	 FALSE,			/* pc_relative */
d691 1
a691 1
	 FALSE,			/* partial_inplace */
d694 1
a694 1
	 FALSE),		/* pcrel_offset */
d701 1
a701 1
	 FALSE,			/* pc_relative */
d709 1
a709 1
	 FALSE,			/* partial_inplace */
d712 1
a712 1
	 FALSE),		/* pcrel_offset */
d719 1
a719 1
	 FALSE,			/* pc_relative */
d724 1
a724 1
	 FALSE,			/* partial_inplace */
d727 1
a727 1
	 FALSE),		/* pcrel_offset */
d734 1
a734 1
	 FALSE,			/* pc_relative */
d739 1
a739 1
	 FALSE,			/* partial_inplace */
d742 1
a742 1
	 FALSE),		/* pcrel_offset */
d749 1
a749 1
	 FALSE,			/* pc_relative */
d754 1
a754 1
	 FALSE,			/* partial_inplace */
d757 1
a757 1
	 FALSE),		/* pcrel_offset */
d764 1
a764 1
	 FALSE,			/* pc_relative */
d769 1
a769 1
	 FALSE,			/* partial_inplace */
d772 1
a772 1
	 FALSE),		/* pcrel_offset */
d779 1
a779 1
	 FALSE,			/* pc_relative */
d784 1
a784 1
	 FALSE,			/* partial_inplace */
d787 1
a787 1
	 FALSE),		/* pcrel_offset */
d794 1
a794 1
	 TRUE,			/* pc_relative */
d799 1
a799 1
	 FALSE,			/* partial_inplace */
d802 1
a802 1
	 TRUE),			/* pcrel_offset */
d809 1
a809 1
	 FALSE,			/* pc_relative */
d814 1
a814 1
	 FALSE,			/* partial_inplace */
d817 1
a817 1
	 FALSE),		/* pcrel_offset */
d824 1
a824 1
	 FALSE,			/* pc_relative */
d829 1
a829 1
	 FALSE,			/* partial_inplace */
d832 1
a832 1
	 FALSE),		/* pcrel_offset */
d843 1
a843 1
	 FALSE,			/* pc_relative */
d848 1
a848 1
	 FALSE,			/* partial_inplace */
d851 1
a851 1
	 FALSE),		/* pcrel_offset */
d858 1
a858 1
	 FALSE,			/* pc_relative */
d863 1
a863 1
	 FALSE,			/* partial_inplace */
d866 1
a866 1
	 FALSE),		/* pcrel_offset */
d873 1
a873 1
	 FALSE,			/* pc_relative */
d878 1
a878 1
	 FALSE,			/* partial_inplace */
d881 1
a881 1
	 FALSE),		/* pcrel_offset */
d888 1
a888 1
	 FALSE,			/* pc_relative */
d893 1
a893 1
	 FALSE,			/* partial_inplace */
d896 1
a896 1
	 FALSE),		/* pcrel_offset */
d903 1
a903 1
	 FALSE,			/* pc_relative */
d908 1
a908 1
	 FALSE,			/* partial_inplace */
d911 1
a911 1
	 FALSE),		/* pcrel_offset */
d918 1
a918 1
	 FALSE,			/* pc_relative */
d923 1
a923 1
	 FALSE,			/* partial_inplace */
d926 1
a926 1
	 FALSE),		/* pcrel_offset */
d933 1
a933 1
	 FALSE,			/* pc_relative */
d938 1
a938 1
	 FALSE,			/* partial_inplace */
d941 1
a941 1
	 FALSE),		/* pcrel_offset */
d948 1
a948 1
	 FALSE,			/* pc_relative */
d953 1
a953 1
	 FALSE,			/* partial_inplace */
d956 1
a956 1
	 FALSE),		/* pcrel_offset */
d963 1
a963 1
	 FALSE,			/* pc_relative */
d968 1
a968 1
	 FALSE,			/* partial_inplace */
d971 1
a971 1
	 FALSE),		/* pcrel_offset */
d979 1
a979 1
	 FALSE,			/* pc_relative */
d984 1
a984 1
	 FALSE,			/* partial_inplace */
d987 1
a987 1
	 FALSE),		/* pcrel_offset */
d996 1
a996 1
	 FALSE,			/* pc_relative */
d1001 1
a1001 1
	 FALSE,			/* partial_inplace */
d1004 1
a1004 1
	 FALSE),		/* pcrel_offset */
d1012 1
a1012 1
	 FALSE,			/* pc_relative */
d1017 1
a1017 1
	 FALSE,			/* partial_inplace */
d1020 1
a1020 1
	 FALSE),		/* pcrel_offset */
d1027 1
a1027 1
	 FALSE,			/* pc_relative */
d1032 1
a1032 1
	 FALSE,			/* partial_inplace */
d1035 1
a1035 1
	 FALSE),		/* pcrel_offset */
d1042 1
a1042 1
	 FALSE,			/* pc_relative */
d1047 1
a1047 1
	 FALSE,			/* partial_inplace */
d1050 1
a1050 1
	 FALSE),		/* pcrel_offset */
d1057 1
a1057 1
	 FALSE,			/* pc_relative */
d1062 1
a1062 1
	 FALSE,			/* partial_inplace */
d1065 1
a1065 1
	 FALSE),		/* pcrel_offset */
d1072 1
a1072 1
	 FALSE,			/* pc_relative */
d1077 1
a1077 1
	 FALSE,			/* partial_inplace */
d1080 1
a1080 1
	 FALSE),		/* pcrel_offset */
d1087 1
a1087 1
	 FALSE,			/* pc_relative */
d1092 1
a1092 1
	 FALSE,			/* partial_inplace */
d1095 1
a1095 1
	 FALSE),		/* pcrel_offset */
d1101 1
a1101 1
	 FALSE,			/* pc_relative */
d1106 1
a1106 1
	 FALSE,			/* partial_inplace */
d1109 1
a1109 1
	 FALSE),		/* pcrel_offset */
d1121 1
a1121 1
	 FALSE,			/* pc_relative */
d1126 1
a1126 1
	 FALSE,			/* partial_inplace */
d1129 1
a1129 1
	 FALSE),		/* pcrel_offset */
d1137 1
a1137 1
	 FALSE,			/* pc_relative */
d1142 1
a1142 1
	 FALSE,			/* partial_inplace */
d1145 1
a1145 1
	 FALSE),		/* pcrel_offset */
d1154 1
a1154 1
	 FALSE,			/* pc_relative */
d1162 1
a1162 1
	 TRUE,			/* partial_inplace */
d1165 1
a1165 1
	 FALSE);		/* pcrel_offset */
d1173 1
a1173 1
	 FALSE,			/* pc_relative */
d1178 1
a1178 1
	 TRUE,			/* partial_inplace */
d1181 1
a1181 1
	 FALSE);		/* pcrel_offset */
d1189 1
a1189 1
	 FALSE,			/* pc_relative */
d1194 1
a1194 1
	 FALSE,			/* partial_inplace */
d1197 1
a1197 1
	 FALSE);		/* pcrel_offset */
d1205 1
a1205 1
	 FALSE,			/* pc_relative */
d1210 1
a1210 1
	 FALSE,			/* partial_inplace */
d1213 1
a1213 1
	 FALSE);		/* pcrel_offset */
d1221 1
a1221 1
     Elf64_Mips_Internal_Rela *dst;
a1228 1
  dst->r_addend = 0;
d1253 1
a1253 1
     const Elf64_Mips_Internal_Rela *src;
d1287 1
a1287 1
     Elf_Internal_Rela *dst;
d1289 1
a1289 1
  Elf64_Mips_Internal_Rela mirel;
a1296 1
  dst[0].r_addend = 0;
a1298 1
  dst[1].r_addend = 0;
a1300 1
  dst[2].r_addend = 0;
d1333 1
a1333 1
     const Elf_Internal_Rela *src;
d1336 1
a1336 1
  Elf64_Mips_Internal_Rela mirel;
d1340 1
a1340 1
#if 0
d1450 1
a1450 1
/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a
d1453 1
a1453 1
static bfd_boolean
d1465 1
a1465 1
    return TRUE;
d1495 1
a1495 1
      return FALSE;
d1498 1
a1498 1
  return TRUE;
d1511 1
a1511 1
     bfd_boolean relocateable;
d1558 1
a1558 1
  bfd_boolean relocateable;
d1576 1
a1576 1
    relocateable = TRUE;
d1579 1
a1579 1
      relocateable = FALSE;
d1606 1
a1606 1
  bfd_boolean relocateable;
d1623 1
a1623 1
    relocateable = TRUE;
d1626 1
a1626 1
      relocateable = FALSE;
d1654 1
a1654 1
  bfd_boolean relocateable;
d1675 1
a1675 1
      relocateable = TRUE;
d1680 1
a1680 1
      relocateable = FALSE;
d1781 1
a1781 1
    static bfd_boolean warned;
d1787 1
a1787 1
    warned = TRUE;
d1806 1
a1806 1
  bfd_boolean relocateable;
d1825 1
a1825 1
    relocateable = TRUE;
d1828 1
a1828 1
      relocateable = FALSE;
d1950 1
a1950 1
/* Given a MIPS Elf_Internal_Rel, fill in an arelent structure.  */
d1955 1
a1955 1
     bfd_boolean rela_p;
d1983 1
a1983 1
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d1992 1
a1992 1
     Elf_Internal_Rela *dst ATTRIBUTE_UNUSED;
d2010 1
a2010 1
static bfd_boolean
d2028 1
a2028 1
    return FALSE;
d2053 1
a2053 1
      bfd_boolean used_sym, used_ssym;
d2061 14
a2074 3
	mips_elf64_swap_reloc_in (abfd,
				  (Elf64_Mips_External_Rel *) native_relocs,
				  &rela);
d2078 2
a2079 2
      used_sym = FALSE;
      used_ssym = FALSE;
d2127 1
a2127 1
		  used_sym = TRUE;
d2151 1
a2151 1
		  used_ssym = TRUE;
d2181 1
a2181 1
  return TRUE;
d2186 1
a2186 1
  return FALSE;
d2192 1
a2192 1
static bfd_boolean
d2197 1
a2197 1
     bfd_boolean dynamic;
d2205 1
a2205 1
      return FALSE;
d2211 1
a2211 1
    return TRUE;
d2218 1
a2218 1
    return FALSE;
d2224 1
a2224 1
    return FALSE;
d2229 1
a2229 1
	return FALSE;
d2232 1
a2232 1
  return TRUE;
d2243 1
a2243 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2311 1
a2311 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2321 1
a2321 1
      *failedp = TRUE;
d2329 1
a2329 1
      Elf64_Mips_Internal_Rela int_rel;
d2353 1
a2353 1
	      *failedp = TRUE;
d2365 1
a2365 1
	  *failedp = TRUE;
d2410 1
a2410 1
  bfd_boolean *failedp = (bfd_boolean *) data;
d2420 1
a2420 1
      *failedp = TRUE;
d2452 1
a2452 1
	      *failedp = TRUE;
d2465 1
a2465 1
	  *failedp = TRUE;
d2504 1
a2504 1
static bfd_boolean
d2514 1
a2514 1
    elf_bad_symtab (abfd) = TRUE;
d2518 1
a2518 1
  return TRUE;
a2533 65
/* Support for core dump NOTE sections.  */
static bfd_boolean
elf64_mips_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  unsigned int raw_size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 480:		/* Linux/MIPS - N64 kernel */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	raw_size = 360;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static bfd_boolean
elf64_mips_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 136:		/* Linux/MIPS - N64 kernel elf_prpsinfo */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

d2620 3
a2622 3
#define elf_backend_collect		TRUE
#define elf_backend_type_change_ok	TRUE
#define elf_backend_can_gc_sections	TRUE
a2663 3
#define elf_backend_grok_prstatus	elf64_mips_grok_prstatus
#define elf_backend_grok_psinfo		elf64_mips_grok_psinfo

d2695 4
a2698 4
extern bfd_boolean bfd_elf64_archive_slurp_armap
  PARAMS ((bfd *));
extern bfd_boolean bfd_elf64_archive_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
@


1.38.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a2748 1
#define bfd_elf64_new_section_hook	_bfd_mips_elf_new_section_hook
@


1.38.2.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d303 1
a303 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d305 1
a305 1
	 2,			/* rightshift */
d798 1
a798 3
  /* 16 bit PC relative reference.  Note that the ABI document has a typo
     and claims R_MIPS_PC16 to be not rightshifted, rendering it useless.
     We do the right thing here.  */
d800 1
a800 1
	 2,			/* rightshift */
d1897 1
a1897 1
  { BFD_RELOC_16_PCREL_S2, R_MIPS_PC16 },
@


1.38.2.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a93 5
static long mips_elf64_canonicalize_reloc
  PARAMS ((bfd *, asection *, arelent **, asymbol **));
static long mips_elf64_get_dynamic_reloc_upper_bound PARAMS ((bfd *));
static long mips_elf64_canonicalize_dynamic_reloc
  PARAMS ((bfd *, arelent **, asymbol **));
d95 1
a95 2
  PARAMS ((bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type,
	   arelent *, asymbol **, bfd_boolean));
d303 3
a305 1
  /* 16 bit PC relative reference.  */
d307 1
a307 1
	 0,			/* rightshift */
d800 3
a802 1
  /* 16 bit PC relative reference.  */
d804 1
a804 1
	 0,			/* rightshift */
d1901 1
a1901 1
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
d2025 1
a2025 83
static long
mips_elf64_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
{
  return _bfd_elf_get_dynamic_reloc_upper_bound (abfd) * 3;
}

/* We must also copy more relocations than the corresponding functions
   in elf.c would, so the two following functions are slightly
   modified from elf.c, that multiply the external relocation count by
   3 to obtain the internal relocation count.  */

static long
mips_elf64_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
{
  arelent *tblptr;
  unsigned int i;
  struct elf_backend_data *bed = get_elf_backend_data (abfd);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count * 3; i++)
    *relptr++ = tblptr++;

  *relptr = NULL;

  return section->reloc_count * 3;
}

static long
mips_elf64_canonicalize_dynamic_reloc (abfd, storage, syms)
     bfd *abfd;
     arelent **storage;
     asymbol **syms;
{
  bfd_boolean (*slurp_relocs)
    PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
  asection *s;
  long ret;

  if (elf_dynsymtab (abfd) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != NULL; s = s->next)
    {
      if (elf_section_data (s)->this_hdr.sh_link == elf_dynsymtab (abfd)
	  && (elf_section_data (s)->this_hdr.sh_type == SHT_REL
	      || elf_section_data (s)->this_hdr.sh_type == SHT_RELA))
	{
	  arelent *p;
	  long count, i;

	  if (! (*slurp_relocs) (abfd, s, syms, TRUE))
	    return -1;
	  count = s->_raw_size / elf_section_data (s)->this_hdr.sh_entsize * 3;
	  p = s->relocation;
	  for (i = 0; i < count; i++)
	    *storage++ = p++;
	  ret += count;
	}
    }

  *storage = NULL;

  return ret;
}

/* Read the relocations from one reloc section.  This is mostly copied
   from elfcode.h, except for the changes to expand one external
   relocation to 3 internal ones.  We must unfortunately set
   reloc_count to the number of external relocations, because a lot of
   generic code seems to depend on this.  */
d2028 1
a2028 2
mips_elf64_slurp_one_reloc_table (abfd, asect, rel_hdr, reloc_count,
				  relents, symbols, dynamic)
a2030 3
     Elf_Internal_Shdr *rel_hdr;
     bfd_size_type reloc_count;
     arelent *relents;
d2032 1
a2032 1
     bfd_boolean dynamic;
d2036 1
d2038 1
d2048 1
a2048 2
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd)
	  != rel_hdr->sh_size))
d2053 2
d2059 2
d2066 2
a2067 3
  for (i = 0, relent = relents;
       i < reloc_count;
       i++, native_relocs += entsize)
d2169 1
a2169 1
	  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0 || dynamic)
d2196 1
a2196 4
   associated with a single data section.  This is copied from
   elfcode.h as well, with changes as small as accounting for 3
   internal relocs per external reloc and resetting reloc_count to
   zero before processing the relocs of a section.  */
d2205 1
a2206 6
  Elf_Internal_Shdr *rel_hdr;
  Elf_Internal_Shdr *rel_hdr2;
  bfd_size_type reloc_count;
  bfd_size_type reloc_count2;
  arelent *relents;
  bfd_size_type amt;
d2208 1
a2208 4
  if (asect->relocation != NULL)
    return TRUE;

  if (! dynamic)
d2210 3
a2212 12
      if ((asect->flags & SEC_RELOC) == 0
	  || asect->reloc_count == 0)
	return TRUE;

      rel_hdr = &d->rel_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = d->rel_hdr2;
      reloc_count2 = (rel_hdr2 ? NUM_SHDR_ENTRIES (rel_hdr2) : 0);

      BFD_ASSERT (asect->reloc_count == reloc_count + reloc_count2);
      BFD_ASSERT (asect->rel_filepos == rel_hdr->sh_offset
		  || (rel_hdr2 && asect->rel_filepos == rel_hdr2->sh_offset));
d2214 4
a2217 15
    }
  else
    {
      /* Note that ASECT->RELOC_COUNT tends not to be accurate in this
	 case because relocations against this section may use the
	 dynamic symbol table, and in that case bfd_section_from_shdr
	 in elf.c does not update the RELOC_COUNT.  */
      if (asect->_raw_size == 0)
	return TRUE;

      rel_hdr = &d->this_hdr;
      reloc_count = NUM_SHDR_ENTRIES (rel_hdr);
      rel_hdr2 = NULL;
      reloc_count2 = 0;
    }
d2220 4
a2223 3
  amt = (reloc_count + reloc_count2) * 3 * sizeof (arelent);
  relents = (arelent *) bfd_alloc (abfd, amt);
  if (relents == NULL)
d2229 1
a2229 4
  if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					  rel_hdr, reloc_count,
					  relents,
					  symbols, dynamic))
d2233 2
a2234 4
      if (! mips_elf64_slurp_one_reloc_table (abfd, asect,
					      rel_hdr2, reloc_count2,
					      relents + reloc_count * 3,
					      symbols, dynamic))
a2237 1
  asect->relocation = relents;
a2766 4
#define bfd_elf64_canonicalize_reloc mips_elf64_canonicalize_reloc
#define bfd_elf64_get_dynamic_reloc_upper_bound mips_elf64_get_dynamic_reloc_upper_bound
#define bfd_elf64_canonicalize_dynamic_reloc mips_elf64_canonicalize_dynamic_reloc
#define bfd_elf64_bfd_relax_section     _bfd_mips_relax_section
@


1.38.2.6
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a1229 32
/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rel16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 TRUE,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

/* 16 bit offset for pc-relative branches.  */
static reloc_howto_type elf_mips_gnu_rela16_s2 =
  HOWTO (R_MIPS_GNU_REL16_S2,	/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_GNU_REL16_S2",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

a1962 2
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rela16_s2;
a1985 5
    case R_MIPS_GNU_REL16_S2:
      if (rela_p)
	return &elf_mips_gnu_rela16_s2;
      else
	return &elf_mips_gnu_rel16_s2;
d2785 1
a2785 1
  3,		/* log_file_align */
@


1.38.2.7
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1450 2
a1451 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1457 2
a1458 5
  if (reloc_entry->howto->partial_inplace)
    {
      if (((reloc_entry->addend & 0xffff) + 0x8000) & ~0xffff)
	reloc_entry->addend += 0x8000;
    }
d1491 1
a1491 2
      && ((symbol->flags & BSF_SECTION_SYM) != 0
	  || (symbol->flags & BSF_LOCAL) == 0))
d1556 1
a1556 1
   external symbol if we are producing relocatable output.  */
d1559 1
a1559 1
mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message, pgp)
d1562 1
a1562 1
     bfd_boolean relocatable;
d1567 1
a1567 1
      && ! relocatable)
d1575 1
a1575 1
      && (! relocatable
d1578 1
a1578 1
      if (relocatable)
d1609 1
a1609 1
  bfd_boolean relocatable;
d1613 4
a1616 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1619 2
a1620 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1627 1
a1627 1
    relocatable = TRUE;
d1630 1
a1630 1
      relocatable = FALSE;
d1634 1
a1634 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1640 1
a1640 1
					input_section, relocatable,
d1657 1
a1657 1
  bfd_boolean relocatable;
d1665 2
a1666 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1674 1
a1674 1
    relocatable = TRUE;
d1677 1
a1677 1
      relocatable = FALSE;
d1681 1
a1681 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1687 1
a1687 1
					input_section, relocatable,
d1705 1
a1705 1
  bfd_boolean relocatable;
d1709 1
a1709 1
  bfd_vma val;
d1711 4
a1714 2
  /* If we're relocating, and this is an external symbol, we don't want
     to change anything.  */
d1717 1
a1717 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1725 4
a1728 1
    relocatable = TRUE;
d1731 1
a1731 1
      relocatable = FALSE;
d1733 5
a1739 5
    ret = mips_elf64_final_gp (output_bfd, symbol, relocatable,
			       error_message, &gp);
    if (ret != bfd_reloc_ok)
      return ret;

d1751 8
d1760 1
a1760 4
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    val += bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
d1763 1
a1763 1
     are producing relocatable output, we don't want to do this for
d1765 1
a1765 1
  if (! relocatable
d1769 1
a1769 4
  if (reloc_entry->howto->partial_inplace)
    bfd_put_32 (abfd, val, (bfd_byte *) data + reloc_entry->address);
  else
    reloc_entry->addend = val;
d1771 1
a1771 1
  if (relocatable)
d1795 2
a1796 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1802 2
a1803 5
  if (reloc_entry->howto->partial_inplace)
    {
      reloc_entry->addend = ((reloc_entry->addend & 0x00007c0)
			     | (reloc_entry->addend & 0x00000800) >> 9);
    }
d1857 1
a1857 1
  bfd_boolean relocatable;
d1860 2
a1861 4
  unsigned short extend = 0;
  unsigned short insn = 0;
  bfd_signed_vma val;
  bfd_vma relocation;
d1864 3
a1866 1
     addend, we don't want to change anything.  */
d1869 1
a1869 1
      && (symbol->flags & BSF_LOCAL) != 0)
d1876 1
a1876 1
    relocatable = TRUE;
d1879 1
a1879 1
      relocatable = FALSE;
d1883 1
a1883 1
  ret = mips_elf64_final_gp (output_bfd, symbol, relocatable, error_message,
d1891 25
a1915 20
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  /* Set val to the offset into the section or symbol.  */
  val = reloc_entry->addend;

  if (reloc_entry->howto->partial_inplace)
    {
      /* Pick up the mips16 extend instruction and the real instruction.  */
      extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
      insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);
      val += ((extend & 0x1f) << 11) | (extend & 0x7e0) | (insn & 0x1f);
    }

  _bfd_mips_elf_sign_extend(val, 16);
d1917 1
a1917 28
  /* Adjust val for the final section location and GP value.  If we
     are producing relocatable output, we don't want to do this for
     an external symbol.  */
  if (! relocatable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  if (reloc_entry->howto->partial_inplace)
    {
      bfd_put_16 (abfd,
		  (bfd_vma) ((extend & 0xf800)
			     | ((val >> 11) & 0x1f)
			     | (val & 0x7e0)),
		  (bfd_byte *) data + reloc_entry->address);
      bfd_put_16 (abfd,
		  (bfd_vma) ((insn & 0xffe0)
			     | (val & 0x1f)),
		  (bfd_byte *) data + reloc_entry->address + 2);
    }
  else
    reloc_entry->addend = val;

  if (relocatable)
    reloc_entry->address += input_section->output_offset;
  else if (((val & ~0xffff) != ~0xffff) && ((val & ~0xffff) != 0))
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
@


1.38.2.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2103 1
a2103 1
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
a2901 2
#define elf_backend_copy_indirect_symbol \
					_bfd_mips_elf_copy_indirect_symbol
@


1.38.2.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2916 1
@


1.38.2.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d65 2
a66 1
  (bfd *, const Elf64_Mips_External_Rel *, Elf64_Mips_Internal_Rela *);
d68 2
a69 1
  (bfd *, const Elf64_Mips_External_Rela *, Elf64_Mips_Internal_Rela *);
d71 2
a72 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rel *);
d74 2
a75 1
  (bfd *, const Elf64_Mips_Internal_Rela *, Elf64_Mips_External_Rela *);
d77 1
a77 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d79 1
a79 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d81 1
a81 1
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
d83 1
a83 1
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
d85 1
a85 1
  (bfd *, bfd_reloc_code_real_type);
d87 1
a87 1
  (unsigned int, bfd_boolean);
d89 1
a89 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d91 1
a91 1
  (bfd *, arelent *, Elf_Internal_Rela *);
d93 1
a93 1
  (bfd *, asection *);
d95 2
a96 3
  (bfd *, asection *, arelent **, asymbol **);
static long mips_elf64_get_dynamic_reloc_upper_bound
  (bfd *);
d98 1
a98 1
  (bfd *, arelent **, asymbol **);
d100 2
a101 2
  (bfd *, asection *, Elf_Internal_Shdr *, bfd_size_type, arelent *,
   asymbol **, bfd_boolean);
d103 1
a103 1
  (bfd *, asection *, asymbol **, bfd_boolean);
d105 1
a105 1
  (bfd *, asection *, void *);
d107 1
a107 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d109 1
a109 1
  (bfd *, asection *, Elf_Internal_Shdr *, int *, void *);
d111 1
a111 1
  (bfd *, arelent *, asymbol *,	void *, asection *, bfd *, char **);
d113 1
a113 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d115 1
a115 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d117 1
a117 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d119 1
a119 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d121 1
a121 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d123 1
a123 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d125 1
a125 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d127 1
a127 1
  (bfd *, bfd_vma *);
d129 1
a129 1
  (bfd *, asymbol *, bfd_boolean, char **, bfd_vma *);
d131 1
a131 1
  (bfd *);
d133 1
a133 1
  (bfd *);
d135 1
a135 1
  (bfd *, Elf_Internal_Note *);
d137 1
a137 1
  (bfd *, Elf_Internal_Note *);
d478 1
a478 1
  /* 64 bit subtraction.  */
d973 1
a973 1
  /* 64 bit subtraction.  */
d1265 4
a1268 2
mips_elf64_swap_reloc_in (bfd *abfd, const Elf64_Mips_External_Rel *src,
			  Elf64_Mips_Internal_Rela *dst)
d1282 4
a1285 2
mips_elf64_swap_reloca_in (bfd *abfd, const Elf64_Mips_External_Rela *src,
			   Elf64_Mips_Internal_Rela *dst)
d1299 4
a1302 2
mips_elf64_swap_reloc_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			   Elf64_Mips_External_Rel *dst)
d1315 4
a1318 2
mips_elf64_swap_reloca_out (bfd *abfd, const Elf64_Mips_Internal_Rela *src,
			    Elf64_Mips_External_Rela *dst)
d1332 4
a1335 2
mips_elf64_be_swap_reloc_in (bfd *abfd, const bfd_byte *src,
			     Elf_Internal_Rela *dst)
d1357 4
a1360 2
mips_elf64_be_swap_reloca_in (bfd *abfd, const bfd_byte *src,
			      Elf_Internal_Rela *dst)
d1382 4
a1385 2
mips_elf64_be_swap_reloc_out (bfd *abfd, const Elf_Internal_Rela *src,
			      bfd_byte *dst)
d1408 4
a1411 2
mips_elf64_be_swap_reloca_out (bfd *abfd, const Elf_Internal_Rela *src,
			       bfd_byte *dst)
d1436 9
a1444 4
mips_elf64_hi16_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		       asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		       asection *input_section, bfd *output_bfd,
		       char **error_message ATTRIBUTE_UNUSED)
d1448 1
a1448 1
  if (output_bfd != NULL
d1480 9
a1488 3
mips_elf64_got16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			void *data, asection *input_section, bfd *output_bfd,
			char **error_message)
d1492 1
a1492 1
  if (output_bfd != NULL
d1508 3
a1510 1
mips_elf64_assign_gp (bfd *output_bfd, bfd_vma *pgp)
d1526 1
a1526 1
  if (sym == NULL)
d1562 6
a1567 2
mips_elf64_final_gp (bfd *output_bfd, asymbol *symbol, bfd_boolean relocatable,
		     char **error_message, bfd_vma *pgp)
d1602 9
a1610 3
mips_elf64_gprel16_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1618 1
a1618 1
  if (output_bfd != NULL
d1626 1
a1626 1
  if (output_bfd != NULL)
d1647 9
a1655 3
mips_elf64_literal_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1663 1
a1663 1
  if (output_bfd != NULL
d1672 1
a1672 1
  if (output_bfd != NULL)
d1694 9
a1702 3
mips_elf64_gprel32_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			  void *data, asection *input_section, bfd *output_bfd,
			  char **error_message)
d1712 1
a1712 1
  if (output_bfd != NULL
d1721 1
a1721 1
  if (output_bfd != NULL)
d1773 9
a1781 4
mips_elf64_shift6_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
			 asymbol *symbol, void *data ATTRIBUTE_UNUSED,
			 asection *input_section, bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
d1785 1
a1785 1
  if (output_bfd != NULL
d1805 9
a1813 4
mips16_jump_reloc (bfd *abfd ATTRIBUTE_UNUSED, arelent *reloc_entry,
		   asymbol *symbol, void *data ATTRIBUTE_UNUSED,
		   asection *input_section, bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
d1815 1
a1815 1
  if (output_bfd != NULL
d1841 9
a1849 3
mips16_gprel_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
		    void *data, asection *input_section, bfd *output_bfd,
		    char **error_message)
d1916 3
a1918 1
		  (extend & 0xf800) | ((val >> 11) & 0x1f) | (val & 0x7e0),
d1921 2
a1922 1
		  (insn & 0xffe0) | (val & 0x1f),
d1985 3
a1987 2
bfd_elf64_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
d2022 3
a2024 1
mips_elf64_rtype_to_howto (unsigned int r_type, bfd_boolean rela_p)
d2054 4
a2057 3
mips_elf64_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
			      arelent *cache_ptr ATTRIBUTE_UNUSED,
			      Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d2063 4
a2066 3
mips_elf64_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			       arelent *cache_ptr ATTRIBUTE_UNUSED,
			       Elf_Internal_Rela *dst ATTRIBUTE_UNUSED)
d2075 3
a2077 1
mips_elf64_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d2083 2
a2084 1
mips_elf64_get_dynamic_reloc_upper_bound (bfd *abfd)
d2095 5
a2099 2
mips_elf64_canonicalize_reloc (bfd *abfd, sec_ptr section,
			       arelent **relptr, asymbol **symbols)
d2118 4
a2121 2
mips_elf64_canonicalize_dynamic_reloc (bfd *abfd, arelent **storage,
				       asymbol **syms)
d2123 2
a2124 1
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
d2167 9
a2175 5
mips_elf64_slurp_one_reloc_table (bfd *abfd, asection *asect,
				  Elf_Internal_Shdr *rel_hdr,
				  bfd_size_type reloc_count,
				  arelent *relents, asymbol **symbols,
				  bfd_boolean dynamic)
d2177 1
a2177 1
  void *allocated;
d2184 1
a2184 1
  allocated = bfd_malloc (rel_hdr->sh_size);
d2193 1
a2193 1
  native_relocs = allocated;
d2341 5
a2345 2
mips_elf64_slurp_reloc_table (bfd *abfd, asection *asect,
			      asymbol **symbols, bfd_boolean dynamic)
d2391 1
a2391 1
  relents = bfd_alloc (abfd, amt);
d2419 4
a2422 1
mips_elf64_write_relocs (bfd *abfd, asection *sec, void *data)
d2424 1
a2424 1
  bfd_boolean *failedp = data;
d2485 6
a2490 3
mips_elf64_write_rel (bfd *abfd, asection *sec,
		      Elf_Internal_Shdr *rel_hdr,
		      int *count, void *data)
d2492 1
a2492 1
  bfd_boolean *failedp = data;
d2498 2
a2499 2
  rel_hdr->sh_size = rel_hdr->sh_entsize * *count;
  rel_hdr->contents = bfd_alloc (abfd, rel_hdr->sh_size);
d2584 6
a2589 3
mips_elf64_write_rela (bfd *abfd, asection *sec,
		       Elf_Internal_Shdr *rela_hdr,
		       int *count, void *data)
d2591 1
a2591 1
  bfd_boolean *failedp = data;
d2597 2
a2598 2
  rela_hdr->sh_size = rela_hdr->sh_entsize * *count;
  rela_hdr->contents = bfd_alloc (abfd, rela_hdr->sh_size);
d2686 2
a2687 1
mips_elf64_object_p (bfd *abfd)
d2705 2
a2706 1
elf64_mips_irix_compat (bfd *abfd)
d2717 3
a2719 1
elf64_mips_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d2749 3
a2751 1
elf64_mips_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d2951 1
a2951 1
  (bfd *);
d2953 1
a2953 1
  (bfd *, unsigned int, struct orl *, unsigned int, int);
@


1.38.2.11
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d107 2
d117 2
d158 1
a158 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d173 1
a173 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d188 1
a188 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d203 1
a203 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d221 1
a221 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d233 1
a233 1
	 16,			/* rightshift */
d239 1
a239 1
	 _bfd_mips_elf_hi16_reloc, /* special_function */
d254 1
a254 1
	 _bfd_mips_elf_lo16_reloc, /* special_function */
d299 1
a299 1
	 _bfd_mips_elf_got16_reloc, /* special_function */
d314 1
a314 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d329 1
a329 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d363 1
a363 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d393 1
a393 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d408 1
a408 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d423 1
a423 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d438 1
a438 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d453 1
a453 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d468 1
a468 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d483 1
a483 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d499 1
a499 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d516 1
a516 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d532 1
a532 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d556 1
a556 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d571 1
a571 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d586 1
a586 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d600 1
a600 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d620 1
a620 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d636 1
a636 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d656 1
a656 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d671 1
a671 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d686 1
a686 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d701 1
a701 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d719 1
a719 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d734 1
a734 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d749 1
a749 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d794 1
a794 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d809 1
a809 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d824 1
a824 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d858 1
a858 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d888 1
a888 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d903 1
a903 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d918 1
a918 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d933 1
a933 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d948 1
a948 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d963 1
a963 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d978 1
a978 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d994 1
a994 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1011 1
a1011 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1027 1
a1027 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1042 1
a1042 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1057 1
a1057 1
	 _bfd_mips_elf_generic_reloc, /* special_function */
d1072 1
a1072 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1087 1
a1087 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1102 1
a1102 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1116 1
a1116 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1136 1
a1136 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1152 1
a1152 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1236 1
a1236 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1252 1
a1252 1
	 _bfd_mips_elf_generic_reloc,	/* special_function */
d1414 60
d1719 4
a1722 3
mips_elf64_shift6_reloc (bfd *abfd, arelent *reloc_entry, asymbol *symbol,
			 void *data, asection *input_section, bfd *output_bfd,
			 char **error_message)
d1724 10
d1740 1
a1740 3
  return _bfd_mips_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				      input_section, output_bfd,
				      error_message);
d2091 1
a2091 1
  bfd_boolean rela_p;
d2109 1
a2109 1
    rela_p = FALSE;
d2111 1
a2111 1
    rela_p = TRUE;
d2224 1
a2224 1
	  relent->howto = mips_elf64_rtype_to_howto (type, rela_p);
d2752 5
d2867 1
a2867 4
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
#define ELF_MAXPAGESIZE			0x1000
d2869 1
a2869 1
#include "elf64-target.h"
a2876 2
#undef ELF_MAXPAGESIZE

a2880 5

/* The SVR4 MIPS ABI says that this should be 0x10000, and Linux uses
   page sizes of up to that limit, so we need to respect it.  */
#define ELF_MAXPAGESIZE			0x10000
#define elf64_bed			elf64_tradbed
@


1.37
log
@	* elf64-mips.c (mips_elf64_be_swap_reloca_out): Handle type2 and type3.
	(mips_elf64_final_gp): Don't make up gp value.
	* elfn32-mips.c (mips_elf_final_gp): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_final_link): Always create
	.MIPS.options/.options section.
@
text
@d1374 1
a1374 1
  mirela.r_type2 = ELF64_MIPS_R_TYPE2 (src[1].r_info);
d1376 1
a1376 1
  mirela.r_type3 = ELF64_MIPS_R_TYPE3 (src[2].r_info);
@


1.36
log
@	* elf64-mips.c (define elf_backend_ignore_discarded_relocs): Remove
	duplicate define.
@
text
@d1340 1
d1342 1
d1346 1
a1346 1
  mirel.r_type2 = ELF64_MIPS_R_TYPE2 (src[1].r_info);
d1348 1
a1348 1
  mirel.r_type3 = ELF64_MIPS_R_TYPE3 (src[2].r_info);
d1530 1
a1530 1
	  *pgp = symbol->section->output_section->vma + 0x4000;
@


1.35
log
@	* elf64-mips.c: Update TODO comment.
	(mips_elf64_higher_reloc,mips_elf64_highest_reloc,
	mips_elf64_gprel16_reloca): Remove prototypes.
	(mips16_jump_reloc,mips16_gprel_reloc): Add functions.
	(UNUSED_RELOC): Replace by EMPTY_RELOC.
	(mips_elf64_howto_table_rel): Use special R_MIPS_HI16 handling. Remove
	wrong comments. Remove disfunctional support of R_MIPS_HIGHER and
	R_MIPS_HIGHEST.
	(mips_elf64_howto_table_rela): Fix handling of R_MIPS_GPREL16 and
	R_MIPS_GOT16. Remove wrong comments.
	(elf_mips16_jump_howto,elf_mips16_gprel_howto,
	elf_mips_gnu_vtinherit_howto,elf_mips_gnu_vtentry_howto): New, code
	from elf32-mips.c.
	(mips_elf64_hi16_reloc): Fix formatting.
	(mips_elf64_higher_reloc,mips_elf64_highest_reloc): Remove.
	(mips_elf64_got16_reloc): Fix formatting. Remove superfluous code.
	Better comment. Fall back to R_MIPS_GOT_DISP instead of abort().
	(mips_elf64_gprel16_reloc): Make static. Add check for
	partial_inplace.
	(mips_elf64_gprel16_reloca): Remove.
	(mips_elf64_literal_reloc): New function.
	(mips_elf64_gprel32_reloc): Fix formatting.
	(mips_elf64_shift6_reloc): Fix comment. Make static.
	(mips16_jump_reloc,mips16_gprel_reloc): New functions, code from
	elf32-mips.c.
	(elf_reloc_map,mips_reloc_map): New mapping table, similiar as in
	elf32-mips.c
	(bfd_elf64_bfd_reloc_type_lookup): Use the mapping table. Enable GNU
	specific relocations.
	(mips_elf64_rtype_to_howto): Enable GNU specific relocations.
	(mips_elf64_object_p): Invert logic to check for SGI-ish ABI.
	(ELF_MAXPAGESIZE): Add comment.
@
text
@a2691 2
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
@


1.34
log
@	* elfxx-mips.c (_bfd_mips_elf_discard_info): New function, code from
	elf32-mips.c.
	(_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_discard_info): New prototype.
	(_bfd_mips_elf_write_section): Likewise.
	* elf32-mips.c (elf32_mips_discard_info): Move to elfxx-mips.c.
	(elf32_mips_write_section): Likewise.
	* elf64-mips.c (_bfd_mips_elf_ignore_discarded_relocs): Use it.
	(_bfd_mips_elf_write_section): Likewise.
@
text
@d37 1
a37 2
 .   - Support for MIPS16 is only partially implemented.
 .   - Embedded PIC  is only partially implemented (is it needed?).
a103 4
static bfd_reloc_status_type mips_elf64_higher_reloc
  PARAMS ((bfd *, arelent *, asymbol *,	PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips_elf64_highest_reloc
  PARAMS ((bfd *, arelent *, asymbol *,	PTR, asection *, bfd *, char **));
a105 2
static bfd_reloc_status_type mips_elf64_gprel16_reloca
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d114 4
d124 2
a125 10
extern const bfd_target bfd_elf64_tradbigmips_vec;
extern const bfd_target bfd_elf64_tradlittlemips_vec;

static bfd_vma prev_reloc_addend = 0;
static bfd_size_type prev_reloc_address = 0;

/* Whether we are trying to be compatible with IRIX6 (or little endianers
   which are otherwise IRIX-ABI compliant).  */
#define SGI_COMPAT(abfd) \
  (elf64_mips_irix_compat (abfd) != ict_none)
a135 2
#define UNUSED_RELOC(num) { num, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

d216 3
d227 1
a227 1
	 bfd_elf_generic_reloc,	/* special_function */
a309 1
  /* FIXME: This is not handled correctly.  */
d339 3
a341 3
  UNUSED_RELOC (13),
  UNUSED_RELOC (14),
  UNUSED_RELOC (15),
a388 1
  /* FIXME: Not handled correctly.  */
a403 1
  /* FIXME: Not handled correctly.  */
a418 1
  /* FIXME: Not handled correctly.  */
a433 1
  /* FIXME: Not handled correctly.  */
a448 1
  /* FIXME: Not handled correctly.  */
a463 1
  /* FIXME: Not handled correctly.  */
d527 8
a534 29
  /* Get the higher value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHER,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_higher_reloc, /* special_function */
	 "R_MIPS_HIGHER",	/* name */
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */

  /* Get the highest value of a 64 bit addend.  */
  HOWTO (R_MIPS_HIGHEST,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 mips_elf64_highest_reloc, /* special_function */
	 "R_MIPS_HIGHEST",	/* name */
	 true,			/* partial_inplace */
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 false),		/* pcrel_offset */
a536 1
  /* FIXME: Not handled correctly.  */
a551 1
  /* FIXME: Not handled correctly.  */
a566 1
  /* FIXME: Not handled correctly.  */
a713 1
  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for 64 bit REL.  */
d752 1
a752 1
	 mips_elf64_gprel16_reloca, /* special_function */
a774 1
  /* FIXME: This is not handled correctly.  */
d782 1
a782 1
	 bfd_elf_generic_reloc, /* special_function */
a804 1
  /* FIXME: This is not handled correctly.  */
d834 3
a836 3
  UNUSED_RELOC (13),
  UNUSED_RELOC (14),
  UNUSED_RELOC (15),
a883 1
  /* FIXME: Not handled correctly.  */
a898 1
  /* FIXME: Not handled correctly.  */
a913 1
  /* FIXME: Not handled correctly.  */
a928 1
  /* FIXME: Not handled correctly.  */
a943 1
  /* FIXME: Not handled correctly.  */
a958 1
  /* FIXME: Not handled correctly.  */
a1052 1
  /* FIXME: Not handled correctly.  */
a1067 1
  /* FIXME: Not handled correctly.  */
a1082 1
  /* FIXME: Not handled correctly.  */
d1147 67
d1382 3
a1384 8
bfd_reloc_status_type
mips_elf64_hi16_reloc (abfd,
		     reloc_entry,
		     symbol,
		     data,
		     input_section,
		     output_bfd,
		     error_message)
a1409 72
/* Do a R_MIPS_HIGHER relocation.  */

bfd_reloc_status_type
mips_elf64_higher_reloc (abfd,
			 reloc_entry,
			 symbol,
			 data,
			 input_section,
			 output_bfd,
			 error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (((reloc_entry->addend & 0xffffffff) + 0x80008000)
      & ~0xffffffff)
    reloc_entry->addend += 0x80008000;

  return bfd_reloc_continue;
}

/* Do a R_MIPS_HIGHEST relocation.  */

bfd_reloc_status_type
mips_elf64_highest_reloc (abfd,
			  reloc_entry,
			  symbol,
			  data,
			  input_section,
			  output_bfd,
			  error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (((reloc_entry->addend & 0xffffffffffff) + 0x800080008000)
      & ~0xffffffffffff)
    reloc_entry->addend += 0x800080008000;

  return bfd_reloc_continue;
}

d1424 3
a1426 8
bfd_reloc_status_type
mips_elf64_got16_reloc (abfd,
		      reloc_entry,
		      symbol,
		      data,
		      input_section,
		      output_bfd,
		      error_message)
a1434 10
  /* If we're relocating, and this an external symbol, we don't want
     to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

d1436 1
a1436 1
     just like HI16.  */
d1442 4
a1445 1
  abort ();
d1545 1
a1545 1
bfd_reloc_status_type
d1566 2
a1567 1
      && reloc_entry->addend == 0)
d1591 1
a1591 1
/* Do a R_MIPS_GPREL16 RELA relocation.  */
d1593 3
a1595 3
bfd_reloc_status_type
mips_elf64_gprel16_reloca (abfd, reloc_entry, symbol, data, input_section,
			   output_bfd, error_message)
d1599 1
a1599 1
     PTR data ATTRIBUTE_UNUSED;
d1605 1
d1608 2
a1609 7
  /* This works only for NewABI.  */
  BFD_ASSERT (reloc_entry->howto->src_mask == 0);

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
d1612 2
a1613 1
      && reloc_entry->addend == 0)
d1619 1
d1628 4
a1631 11
  if (prev_reloc_address != reloc_entry->address)
    prev_reloc_address = reloc_entry->address;
  else
    {
      mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			   &gp);
      prev_reloc_addend = reloc_entry->addend + reloc_entry->address - gp;
      if (symbol->flags & BSF_LOCAL)
	prev_reloc_addend += _bfd_get_gp_value (abfd);
/*fprintf(stderr, "Addend: %lx, Next Addend: %lx\n", reloc_entry->addend, prev_reloc_addend);*/
    }
d1633 3
a1635 1
  return bfd_reloc_ok;
d1638 2
a1639 1
/* Do a R_MIPS_LITERAL relocation.  */
d1641 2
a1642 2
bfd_reloc_status_type
mips_elf64_literal_reloc (abfd, reloc_entry, symbol, data, input_section,
a1651 36
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.
     Currently we simply call mips_elf64_gprel16_reloc.  */
  return mips_elf64_gprel16_reloc (abfd, reloc_entry, symbol, data,
				   input_section, output_bfd, error_message);
}

/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset
   from the gp register? XXX */

bfd_reloc_status_type
mips_elf64_gprel32_reloc (abfd,
			reloc_entry,
			symbol,
			data,
			input_section,
			output_bfd,
			error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
d1725 1
a1725 1
   the rest is at bits 6-10. The bitpos alredy got right by the howto.   */
d1727 1
a1727 1
bfd_reloc_status_type
d1755 158
d1920 1
d1925 7
a1933 67
    case BFD_RELOC_NONE:
      return &howto_table[R_MIPS_NONE];
    case BFD_RELOC_16:
      return &howto_table[R_MIPS_16];
    case BFD_RELOC_32:
      return &howto_table[R_MIPS_32];
    case BFD_RELOC_64:
    case BFD_RELOC_CTOR:
      return &howto_table[R_MIPS_64];
    case BFD_RELOC_16_PCREL:
      return &howto_table[R_MIPS_PC16];
    case BFD_RELOC_HI16_S:
      return &howto_table[R_MIPS_HI16];
    case BFD_RELOC_LO16:
      return &howto_table[R_MIPS_LO16];
    case BFD_RELOC_GPREL16:
      return &howto_table[R_MIPS_GPREL16];
    case BFD_RELOC_GPREL32:
      return &howto_table[R_MIPS_GPREL32];
    case BFD_RELOC_MIPS_JMP:
      return &howto_table[R_MIPS_26];
    case BFD_RELOC_MIPS_LITERAL:
      return &howto_table[R_MIPS_LITERAL];
    case BFD_RELOC_MIPS_GOT16:
      return &howto_table[R_MIPS_GOT16];
    case BFD_RELOC_MIPS_CALL16:
      return &howto_table[R_MIPS_CALL16];
    case BFD_RELOC_MIPS_SHIFT5:
      return &howto_table[R_MIPS_SHIFT5];
    case BFD_RELOC_MIPS_SHIFT6:
      return &howto_table[R_MIPS_SHIFT6];
    case BFD_RELOC_MIPS_GOT_DISP:
      return &howto_table[R_MIPS_GOT_DISP];
    case BFD_RELOC_MIPS_GOT_PAGE:
      return &howto_table[R_MIPS_GOT_PAGE];
    case BFD_RELOC_MIPS_GOT_OFST:
      return &howto_table[R_MIPS_GOT_OFST];
    case BFD_RELOC_MIPS_GOT_HI16:
      return &howto_table[R_MIPS_GOT_HI16];
    case BFD_RELOC_MIPS_GOT_LO16:
      return &howto_table[R_MIPS_GOT_LO16];
    case BFD_RELOC_MIPS_SUB:
      return &howto_table[R_MIPS_SUB];
    case BFD_RELOC_MIPS_INSERT_A:
      return &howto_table[R_MIPS_INSERT_A];
    case BFD_RELOC_MIPS_INSERT_B:
      return &howto_table[R_MIPS_INSERT_B];
    case BFD_RELOC_MIPS_DELETE:
      return &howto_table[R_MIPS_DELETE];
    case BFD_RELOC_MIPS_HIGHEST:
      return &howto_table[R_MIPS_HIGHEST];
    case BFD_RELOC_MIPS_HIGHER:
      return &howto_table[R_MIPS_HIGHER];
    case BFD_RELOC_MIPS_CALL_HI16:
      return &howto_table[R_MIPS_CALL_HI16];
    case BFD_RELOC_MIPS_CALL_LO16:
      return &howto_table[R_MIPS_CALL_LO16];
    case BFD_RELOC_MIPS_SCN_DISP:
      return &howto_table[R_MIPS_SCN_DISP];
    case BFD_RELOC_MIPS_REL16:
      return &howto_table[R_MIPS_REL16];
    /* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
    case BFD_RELOC_MIPS_RELGOT:
      return &howto_table[R_MIPS_RELGOT];
    case BFD_RELOC_MIPS_JALR:
      return &howto_table[R_MIPS_JALR];
/*
a1941 11
    case BFD_RELOC_PCREL_HI16_S:
      return &elf_mips_gnu_rel_hi16;
    case BFD_RELOC_PCREL_LO16:
      return &elf_mips_gnu_rel_lo16;
    case BFD_RELOC_16_PCREL_S2:
      return &elf_mips_gnu_rel16_s2;
    case BFD_RELOC_64_PCREL:
      return &elf_mips_gnu_pcrel64;
    case BFD_RELOC_32_PCREL:
      return &elf_mips_gnu_pcrel32;
*/
a1956 1
/*
a1958 1
      break;
a1960 1
      break;
a1962 1
      break;
a1964 18
      break;
    case R_MIPS_GNU_REL_HI16:
      return &elf_mips_gnu_rel_hi16;
      break;
    case R_MIPS_GNU_REL_LO16:
      return &elf_mips_gnu_rel_lo16;
      break;
    case R_MIPS_GNU_REL16_S2:
      return &elf_mips_gnu_rel16_s2;
      break;
    case R_MIPS_PC64:
      return &elf_mips_gnu_pcrel64;
      break;
    case R_MIPS_PC32:
      return &elf_mips_gnu_pcrel32;
      break;
*/

d2532 1
a2532 1
  if (SGI_COMPAT(abfd))
d2546 4
a2549 2
  if ((abfd->xvec == &bfd_elf64_tradbigmips_vec)
      || (abfd->xvec == &bfd_elf64_tradlittlemips_vec))
a2550 2
  else
    return ict_irix6;
d2634 3
@


1.33
log
@	* armnetbsd.c: Replace CONST with const.
	* corefile.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf64-mips.c: Likewise.
	* mmo.c: Likewise.
	* ns32knetbsd.c: Likewise.
@
text
@d2739 4
@


1.32
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d1551 1
a1551 1
	  register CONST char *name;
@


1.31
log
@* elf32-mips.c (elf32_mips_ignore_discarded_relocs): Move to...
elfxx-mips.c (_bfd_mips_elf_ignore_discarded_relocs): ... here.
elf64-mips.c (elf_backend_ignore_discarded_relocs): Use
_bfd_mips_elf_ignore_discarded_relocs.
elfxx-mips.h (_bfd_mips_elf_ignore_discarded_relocs): Declare.
@
text
@d2669 1
@


1.30
log
@	* Makefile.am: Add elfxx-mips.c to the known backends.
	(elf32-mips.lo): remove dependency to coff/external.h.
	* Makefile.in: Regenerate.
	* configure.in: Add elfxx-mips.lo to all vectors using elf32-mips.lo
	Remove elf32-mips.lo from 64 bit vectors. Update dependencies
	accordingly.
	* configure: Regenerate.
	* elf-bfd.h: Move all MIPS ELF specific prototypes to elfxx-mips.h.
	(irix_compat_t): IRIX compatibility level, moved from elf32-mips.c.
	(elf_backend_mips_irix_compat, elf_backend_mips_rtype_to_howto): New
	MIPS specific backend functions.
	* elf32-mips.c: Moved most code to elfxx-mips.c.
	(mips_elf_hi16_reloc): Rename from _bfd_mips_elf_hi16_reloc and make
	static.
	(mips_elf_lo16_reloc): Likewise, was _bfd_mips_elf_lo16_reloc.
	(mips_elf_got16_reloc): Likewise, was _bfd_mips_elf_got16_reloc.
	(mips_elf_gprel32_reloc): Likewise, was _bfd_mips_elf_gprel32_reloc.
	(mips_elf32_rtype_to_howto): Rename from mips_rtype_to_howto. Changed
	interface to allow selection of the right REL or RELA howto table.
	(mips_elf32_object_p): Rename from _bfd_mips_elf_object_p and made
	static. Let it refuse n32 objects.
	(elf32_mips_grok_prstatus): Rename from _bfd_elf32_mips_grok_prstatus.
	(elf32_mips_grok_psinfo): Rename from _bfd_elf32_mips_grok_psinfo.
	(elf32_mips_discard_info): Rename from _bfd_elf32_mips_discard_info.
	(elf32_mips_ignore_discarded_relocs): Rename from
	_bfd_elf32_mips_ignore_discarded_relocs.
	(elf32_mips_write_section): Rename from _bfd_elf32_mips_write_section.
	(elf32_mips_irix_compat): New function, replaces IRIX_COMPAT.
	(elf_mips_howto_table_rela): Remove.
	* elf64-mips.c: Moved most code to elfxx-mips.c.
	(bfd_elf64_bfd_reloc_type_lookup): Make static.
	(mips_elf64_rtype_to_howto): New function.
	(mips_elf64_object_p): Likewise.
	(elf64_mips_irix_compat): Likewise.
	* elfxx-mips.c: New file containing common code merged together from
	elf32-mips.c and elf64-mips.c.
	* elfxx-mips.h: New file containing MIPS specific prototypes from
	elf-bfd.h.
	* elfxx-target.h: Add handling for elf_backend_mips_irix_compat and
	elf_backend_mips_rtype_to_howto.
@
text
@d2722 2
@


1.30.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1551 1
a1551 1
	  register const char *name;
a2668 1
  bfd_elf64_swap_symbol_in,
a2721 2
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
@


1.30.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a2738 4
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
#define elf_backend_write_section	_bfd_mips_elf_write_section

@


1.30.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d37 2
a38 1
 .   - Support for MIPS16 is untested.
d105 4
d111 2
a120 4
static bfd_reloc_status_type mips16_jump_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_reloc_status_type mips16_gprel_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d127 10
a136 2
extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_littlemips_vec;
d147 2
a228 3
  /* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for NewABI REL.
     However, the native IRIX6 tools use them, so we try our best. */

d237 1
a237 1
	 mips_elf64_hi16_reloc,	/* special_function */
d320 1
d350 3
a352 3
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
d400 1
d416 1
d432 1
d448 1
d464 1
d480 1
d544 29
a572 8
  /* The MIPS ELF64 ABI Draft wants us to support these for REL relocations.
     We don't, because
       a) It means building the addend from a R_MIPS_HIGHEST/R_MIPS_HIGHER/
	  R_MIPS_HI16/R_MIPS_LO16 sequence with varying ordering, using
	  fallable heuristics.
       b) No other NewABI toolchain actually emits such relocations.  */
  EMPTY_HOWTO (R_MIPS_HIGHER),
  EMPTY_HOWTO (R_MIPS_HIGHEST),
d575 1
d591 1
d607 1
d755 1
d794 1
a794 1
	 mips_elf64_gprel16_reloc, /* special_function */
d817 1
d825 1
a825 1
	 mips_elf64_got16_reloc, /* special_function */
d848 1
d878 3
a880 3
  EMPTY_HOWTO (13),
  EMPTY_HOWTO (14),
  EMPTY_HOWTO (15),
d928 1
d944 1
d960 1
d976 1
d992 1
d1008 1
d1103 1
d1119 1
d1135 1
a1199 67

/* The reloc used for the mips16 jump instruction.  */
static reloc_howto_type elf_mips16_jump_howto =
  HOWTO (R_MIPS16_26,		/* type */
	 2,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 			/* This needs complex overflow
				   detection, because the upper four
				   bits must match the PC.  */
	 mips16_jump_reloc,	/* special_function */
	 "R_MIPS16_26",		/* name */
	 true,			/* partial_inplace */
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
	 false);		/* pcrel_offset */

/* The reloc used for the mips16 gprel instruction.  */
static reloc_howto_type elf_mips16_gprel_howto =
  HOWTO (R_MIPS16_GPREL,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 mips16_gprel_reloc,	/* special_function */
	 "R_MIPS16_GPREL",	/* name */
	 true,			/* partial_inplace */
	 0x07ff001f,		/* src_mask */
	 0x07ff001f,	        /* dst_mask */
	 false);		/* pcrel_offset */

/* GNU extension to record C++ vtable hierarchy */
static reloc_howto_type elf_mips_gnu_vtinherit_howto =
  HOWTO (R_MIPS_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_MIPS_GNU_VTINHERIT", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false);		/* pcrel_offset */

/* GNU extension to record C++ vtable member usage */
static reloc_howto_type elf_mips_gnu_vtentry_howto =
  HOWTO (R_MIPS_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_MIPS_GNU_VTENTRY",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false);		/* pcrel_offset */
d1368 8
a1375 3
static bfd_reloc_status_type
mips_elf64_hi16_reloc (abfd, reloc_entry, symbol, data, input_section,
		       output_bfd, error_message)
d1401 72
d1487 8
a1494 3
static bfd_reloc_status_type
mips_elf64_got16_reloc (abfd, reloc_entry, symbol, data, input_section,
			output_bfd, error_message)
d1503 10
d1514 1
a1514 1
     just like an R_MIPS_HI16.  */
d1520 1
a1520 4

  /* Otherwise we try to handle it as R_MIPS_GOT_DISP.  */
  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				input_section, output_bfd, error_message);
d1620 1
a1620 1
static bfd_reloc_status_type
d1641 1
a1641 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
d1665 1
a1665 1
/* Do a R_MIPS_LITERAL relocation.  */
d1667 3
a1669 3
static bfd_reloc_status_type
mips_elf64_literal_reloc (abfd, reloc_entry, symbol, data, input_section,
			  output_bfd, error_message)
d1673 1
a1673 1
     PTR data;
a1678 1
  bfd_reloc_status_type ret;
d1681 7
a1687 2
  /* If we're relocating, and this is an external symbol, we don't
     want to change anything.  */
d1690 1
a1690 2
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
a1695 1
  /* FIXME: The entries in the .lit8 and .lit4 sections should be merged.  */
d1704 11
a1714 4
  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;
d1716 1
a1716 3
  return _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
					input_section, relocateable,
					data, gp);
d1719 1
a1719 2
/* Do a R_MIPS_GPREL32 relocation.  This is a 32 bit value which must
   become the offset from the gp register.  */
d1721 2
a1722 2
static bfd_reloc_status_type
mips_elf64_gprel32_reloc (abfd, reloc_entry, symbol, data, input_section,
d1732 36
d1841 1
a1841 1
   the rest is at bits 6-10. The bitpos already got right by the howto.  */
d1843 1
a1843 1
static bfd_reloc_status_type
a1870 158
/* Handle a mips16 jump.  */

static bfd_reloc_status_type
mips16_jump_reloc (abfd, reloc_entry, symbol, data, input_section,
		   output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! reloc_entry->howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  /* FIXME.  */
  {
    static boolean warned;

    if (! warned)
      (*_bfd_error_handler)
	(_("Linking mips16 objects into %s format is not supported"),
	 bfd_get_target (input_section->output_section->owner));
    warned = true;
  }

  return bfd_reloc_undefined;
}

/* Handle a mips16 GP relative reloc.  */

static bfd_reloc_status_type
mips16_gprel_reloc (abfd, reloc_entry, symbol, data, input_section,
		    output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  boolean relocateable;
  bfd_reloc_status_type ret;
  bfd_vma gp;
  unsigned short extend, insn;
  unsigned long final;

  /* If we're relocating, and this is an external symbol with no
     addend, we don't want to change anything.  We will only have an
     addend if this is a newly created reloc, not read from an ELF
     file.  */
  if (output_bfd != NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && reloc_entry->addend == 0)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    relocateable = true;
  else
    {
      relocateable = false;
      output_bfd = symbol->section->output_section->owner;
    }

  ret = mips_elf64_final_gp (output_bfd, symbol, relocateable, error_message,
			     &gp);
  if (ret != bfd_reloc_ok)
    return ret;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  /* Pick up the mips16 extend instruction and the real instruction.  */
  extend = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn = bfd_get_16 (abfd, (bfd_byte *) data + reloc_entry->address + 2);

  /* Stuff the current addend back as a 32 bit value, do the usual
     relocation, and then clean up.  */
  bfd_put_32 (abfd,
	      (bfd_vma) (((extend & 0x1f) << 11)
			 | (extend & 0x7e0)
			 | (insn & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address);

  ret = _bfd_mips_elf_gprel16_with_gp (abfd, symbol, reloc_entry,
				       input_section, relocateable, data, gp);

  final = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((extend & 0xf800)
			 | ((final >> 11) & 0x1f)
			 | (final & 0x7e0)),
	      (bfd_byte *) data + reloc_entry->address);
  bfd_put_16 (abfd,
	      (bfd_vma) ((insn & 0xffe0)
			 | (final & 0x1f)),
	      (bfd_byte *) data + reloc_entry->address + 2);

  return ret;
}

/* A mapping from BFD reloc types to MIPS ELF reloc types.  */

struct elf_reloc_map {
  bfd_reloc_code_real_type bfd_val;
  enum elf_mips_reloc_type elf_val;
};

static const struct elf_reloc_map mips_reloc_map[] =
{
  { BFD_RELOC_NONE, R_MIPS_NONE },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  /* There is no BFD reloc for R_MIPS_REL32.  */
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_CTOR, R_MIPS_64 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_MIPS_SHIFT5, R_MIPS_SHIFT5 },
  { BFD_RELOC_MIPS_SHIFT6, R_MIPS_SHIFT6 },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_INSERT_A, R_MIPS_INSERT_A },
  { BFD_RELOC_MIPS_INSERT_B, R_MIPS_INSERT_B },
  { BFD_RELOC_MIPS_DELETE, R_MIPS_DELETE },
  { BFD_RELOC_MIPS_HIGHEST, R_MIPS_HIGHEST },
  { BFD_RELOC_MIPS_HIGHER, R_MIPS_HIGHER },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SCN_DISP, R_MIPS_SCN_DISP },
  { BFD_RELOC_MIPS_REL16, R_MIPS_REL16 },
  /* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
  { BFD_RELOC_MIPS_RELGOT, R_MIPS_RELGOT },
  { BFD_RELOC_MIPS_JALR, R_MIPS_JALR }
};

a1877 1
  unsigned int i;
a1881 7
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (mips_reloc_map[i].bfd_val == code)
	return &howto_table[(int) mips_reloc_map[i].elf_val];
    }

d1884 67
d1959 11
d1985 1
d1988 1
d1991 1
d1994 1
d1997 18
d2582 1
a2582 1
  if (elf64_mips_irix_compat (abfd) != ict_none)
d2596 4
a2599 2
  if ((abfd->xvec == &bfd_elf64_bigmips_vec)
      || (abfd->xvec == &bfd_elf64_littlemips_vec))
a2600 2
  else
    return ict_none;
a2683 3
/* The SVR4 MIPS ABI says that this should be 0x10000, but Irix 5 uses
   a value of 0x1000, and we are compatible.
   FIXME: How does this affect NewABI?  */
@


1.30.6.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a1339 1
#if 0  
a1340 1
#endif
d1344 1
a1344 1
  mirel.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
d1346 1
a1346 1
  mirel.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);
d1372 1
a1372 1
  mirela.r_type2 = ELF64_MIPS_R_TYPE (src[1].r_info);
d1374 1
a1374 1
  mirela.r_type3 = ELF64_MIPS_R_TYPE (src[2].r_info);
d1528 1
a1528 1
	  *pgp = symbol->section->output_section->vma /*+ 0x4000*/;
d2692 2
@


1.30.4.1
log
@merge from trunk
@
text
@d1551 1
a1551 1
	  register const char *name;
a2668 1
  bfd_elf64_swap_symbol_in,
a2721 2
#define elf_backend_ignore_discarded_relocs \
					_bfd_mips_elf_ignore_discarded_relocs
@


1.29
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d41 1
a41 1
 .     the OldABI version is still lying around and shold be removed.
d51 1
a64 2
struct mips_elf64_link_hash_entry;

d85 1
a85 4
static bfd_vma mips_elf64_high PARAMS ((bfd_vma));
static bfd_vma mips_elf64_higher PARAMS ((bfd_vma));
static bfd_vma mips_elf64_highest PARAMS ((bfd_vma));
static reloc_howto_type *mips_elf64_reloc_type_lookup
d87 2
a102 2
static struct bfd_hash_entry *mips_elf64_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d124 2
a125 92
static bfd_reloc_status_type gprel16_with_gp
  PARAMS ((bfd *, asymbol *, arelent *, asection *, boolean, PTR, bfd_vma));
static int mips_elf64_additional_program_headers PARAMS ((bfd *));
static struct bfd_link_hash_table *mips_elf64_link_hash_table_create
  PARAMS((bfd *));
static bfd_vma mips_elf64_got_offset_from_index
  PARAMS ((bfd *, bfd *, bfd_vma));
static struct mips_elf64_got_info *_mips_elf64_got_info
  PARAMS ((bfd *, asection **));
static bfd_vma mips_elf64_sign_extend PARAMS ((bfd_vma, int));
static boolean mips_elf64_overflow_p PARAMS ((bfd_vma, int));
static bfd_vma mips_elf64_global_got_index
  PARAMS ((bfd *, struct elf_link_hash_entry *));
static boolean mips_elf64_sort_hash_table_f
  PARAMS ((struct mips_elf64_link_hash_entry *, PTR));
static boolean mips_elf64_sort_hash_table
  PARAMS ((struct bfd_link_info *, unsigned long));
static void mips_elf64_swap_msym_out
  PARAMS ((bfd *, const Elf32_Internal_Msym *, Elf32_External_Msym *));
static bfd_vma mips_elf64_create_local_got_entry
  PARAMS ((bfd *abfd, struct mips_elf64_got_info *, asection *,
	   bfd_vma value));
static bfd_vma mips_elf64_local_got_index
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma));
static bfd_vma mips_elf64_got_page
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, bfd_vma *));
static bfd_vma mips_elf64_got16_entry
  PARAMS ((bfd *, struct bfd_link_info *, bfd_vma, boolean));
static boolean mips_elf64_local_relocation_p
  PARAMS ((bfd *, const Elf_Internal_Rela *, asection **, boolean));
static const Elf_Internal_Rela *mips_elf64_next_relocation
  PARAMS ((unsigned int, const Elf_Internal_Rela *,
	   const Elf_Internal_Rela *));
static boolean mips_elf64_create_dynamic_relocation
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Rela *,
	   struct mips_elf64_link_hash_entry *, asection *, bfd_vma,
	   bfd_vma *, asection *));
static bfd_reloc_status_type mips_elf64_calculate_relocation
  PARAMS ((bfd *, bfd *, asection *, struct bfd_link_info *,
	   const Elf_Internal_Rela *, bfd_vma, reloc_howto_type *,
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **,
	   boolean *));
static bfd_vma mips_elf64_obtain_contents
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd *, bfd_byte *));
static boolean mips_elf64_perform_relocation
  PARAMS ((struct bfd_link_info *, reloc_howto_type *,
	   const Elf_Internal_Rela *, bfd_vma,
	   bfd *, asection *, bfd_byte *, boolean));
static boolean mips_elf64_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
boolean mips_elf64_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
boolean mips_elf64_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *h));
boolean mips_elf64_always_size_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf64_check_mips16_stubs
  PARAMS ((struct mips_elf64_link_hash_entry *, PTR));
boolean mips_elf64_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
boolean mips_elf64_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
boolean mips_elf64_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *info));
asection *mips_elf64_gc_mark_hook
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
boolean mips_elf64_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean mips_elf64_create_got_section
  PARAMS ((bfd *, struct bfd_link_info *));
static boolean mips_elf64_record_global_got_symbol
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *,
	   struct mips_elf64_got_info *));
static asection *mips_elf64_create_msym_section PARAMS((bfd *));
static void mips_elf64_allocate_dynamic_relocations
  PARAMS ((bfd *, unsigned int));
static boolean mips_elf64_stub_section_p PARAMS ((bfd *, asection *));
boolean mips_elf64_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static boolean mips_elf64_output_extsym
	PARAMS ((struct mips_elf64_link_hash_entry *, PTR));
static void mips_elf64_swap_gptab_in
  PARAMS ((bfd *, const Elf32_External_gptab *, Elf32_gptab *));
static void mips_elf64_swap_gptab_out
  PARAMS ((bfd *, const Elf32_gptab *, Elf32_External_gptab *));
static int gptab_compare PARAMS ((const PTR, const PTR));
boolean mips_elf64_final_link PARAMS ((bfd *, struct bfd_link_info *));
d127 2
a128 2
extern const bfd_target bfd_elf64_bigmips_vec;
extern const bfd_target bfd_elf64_littlemips_vec;
d136 1
a136 2
  ((abfd->xvec == &bfd_elf64_bigmips_vec) \
   || (abfd->xvec == &bfd_elf64_littlemips_vec) ? true : false)
d144 1
a144 9

/* Instructions which appear in a stub.  */
#define ELF_MIPS_GP_OFFSET(abfd) 0x7ff0
#define STUB_LW    0xdf998010   /* ld t9,0x8010(gp) */
#define STUB_MOVE  0x03e07825   /* move t7,ra */
#define STUB_JALR  0x0320f809   /* jal t9 */
#define STUB_LI16  0x34180000   /* ori t8,zero,0 */
#define MIPS_FUNCTION_STUB_SIZE (16)

d1200 1
a1200 1

d1365 1
a1365 28

/* Calculate the %high function.  */

static bfd_vma
mips_elf64_high (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x8000) >> 16) & 0xffff;
}

/* Calculate the %higher function.  */

static bfd_vma
mips_elf64_higher (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x80008000) >> 32) & 0xffff;
}

/* Calculate the %highest function.  */

static bfd_vma 
mips_elf64_highest (value)
     bfd_vma value;
{
  return ((value + (bfd_vma) 0x800080008000) >> 48) & 0xffff;
}

d1660 3
a1662 62
  return gprel16_with_gp (abfd, symbol, reloc_entry, input_section,
			  relocateable, data, gp);
}

static bfd_reloc_status_type
gprel16_with_gp (abfd, symbol, reloc_entry, input_section, relocateable, data,
		 gp)
     bfd *abfd;
     asymbol *symbol;
     arelent *reloc_entry;
     asection *input_section;
     boolean relocateable;
     PTR data;
     bfd_vma gp;
{
  bfd_vma relocation;
  unsigned long insn;
  unsigned long val;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;

  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);

  /* Set val to the offset into the section or symbol.  */
  if (reloc_entry->howto->src_mask == 0)
    {
      /* This case occurs with the 64-bit MIPS ELF ABI.  */
      val = reloc_entry->addend;
    }
  else
    {
      val = ((insn & 0xffff) + reloc_entry->addend) & 0xffff;
      if (val & 0x8000)
	val -= 0x10000;
    }

  /* Adjust val for the final section location and GP value.  If we
     are producing relocateable output, we don't want to do this for
     an external symbol.  */
  if (! relocateable
      || (symbol->flags & BSF_SECTION_SYM) != 0)
    val += relocation - gp;

  insn = (insn & ~0xffff) | (val & 0xffff);
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if (relocateable)
    reloc_entry->address += input_section->output_offset;

  else if ((long) val >= 0x8000 || (long) val < -0x8000)
    return bfd_reloc_overflow;

  return bfd_reloc_ok;
a1870 13
static int
mips_elf64_additional_program_headers (abfd)
     bfd *abfd;
{
  int ret = 0;

  /* See if we need a PT_MIPS_OPTIONS segment.  */
  if (bfd_get_section_by_name (abfd, ".MIPS.options"))
    ++ret;

  return ret;
}

d1874 1
a1874 1
mips_elf64_reloc_type_lookup (abfd, code)
d1892 1
a1892 8
      /* We need to handle these specially.  Select the right
	 relocation (R_MIPS_32 or R_MIPS_64) based on the
	 size of addresses on this architecture.  */
      if (bfd_arch_bits_per_address (abfd) == 32)
	return &howto_table[R_MIPS_32];
      else
	return &howto_table[R_MIPS_64];

d1976 49
d2571 1
a2571 2
/* This structure is used to hold .got information when linking.  It
   is stored in the tdata field of the bfd_elf_section_data structure.  */
d2573 3
a2575 1
struct mips_elf64_got_info
d2577 7
a2583 10
  /* The global symbol in the GOT with the lowest index in the dynamic
     symbol table.  */
  struct elf_link_hash_entry *global_gotsym;
  /* The number of global .got entries.  */
  unsigned int global_gotno;
  /* The number of local .got entries.  */
  unsigned int local_gotno;
  /* The number of local .got entries we have used.  */
  unsigned int assigned_gotno;
};
d2585 4
a2588 2
/* The MIPS ELF64 linker needs additional information for each symbol in
   the global hash table.  */
d2590 16
a2605 1
struct mips_elf64_link_hash_entry
d2607 37
a2643 38
  struct elf_link_hash_entry root;

  /* External symbol information.  */
  EXTR esym;

  /* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against
     this symbol.  */ 
  unsigned int possibly_dynamic_relocs;

  /* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against
     a readonly section.  */
  boolean readonly_reloc;

  /* The index of the first dynamic relocation (in the .rel.dyn
     section) against this symbol.  */
  unsigned int min_dyn_reloc_index;

  /* We must not create a stub for a symbol that has relocations
     related to taking the function's address, i.e. any but
     R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",
     p. 4-20.  */
  boolean no_fn_stub;

  /* If there is a stub that 32 bit functions should use to call this
     16 bit function, this points to the section containing the stub.  */
  asection *fn_stub;

  /* Whether we need the fn_stub; this is set if this symbol appears
     in any relocs other than a 16 bit call.  */
  boolean need_fn_stub;

  /* If there is a stub that 16 bit functions should use to call this
     32 bit function, this points to the section containing the stub.  */
  asection *call_stub;

  /* This is like the call_stub field, but it is used if the function
     being called returns a floating point value.  */
  asection *call_fp_stub;
d2646 3
a2648 2
  /* The mips16 compiler uses a couple of special sections to handle
     floating point arguments.
d2650 1
a2650 38
     Section names that look like .mips16.fn.FNNAME contain stubs that
     copy floating point arguments from the fp regs to the gp regs and
     then jump to FNNAME.  If any 32 bit function calls FNNAME, the
     call should be redirected to the stub instead.  If no 32 bit
     function calls FNNAME, the stub should be discarded.  We need to
     consider any reference to the function, not just a call, because
     if the address of the function is taken we will need the stub,
     since the address might be passed to a 32 bit function.

     Section names that look like .mips16.call.FNNAME contain stubs
     that copy floating point arguments from the gp regs to the fp
     regs and then jump to FNNAME.  If FNNAME is a 32 bit function,
     then any 16 bit function that calls FNNAME should be redirected
     to the stub instead.  If FNNAME is not a 32 bit function, the
     stub should be discarded.

     .mips16.call.fp.FNNAME sections are similar, but contain stubs
     which call FNNAME and then copy the return value from the fp regs
     to the gp regs.  These stubs store the return value in $18 while
     calling FNNAME; any function which might call one of these stubs
     must arrange to save $18 around the call.  (This case is not
     needed for 32 bit functions that call 16 bit functions, because
     16 bit functions always return floating point values in both
     $f0/$f1 and $2/$3.)

     Note that in all cases FNNAME might be defined statically.
     Therefore, FNNAME is not used literally.  Instead, the relocation
     information will indicate which symbol the section is for.

     We record any stubs that we find in the symbol table.  */

#define FN_STUB ".mips16.fn."
#define CALL_STUB ".mips16.call."
#define CALL_FP_STUB ".mips16.call.fp."

/* MIPS ELF64 linker hash table.  */

struct mips_elf64_link_hash_table
d2652 26
a2677 3
  struct elf_link_hash_table root;
  /* This is set if we see any mips16 stub sections.  */
  boolean mips16_stubs_seen;
d2680 2
a2681 1
/* Look up an entry in a MIPS ELF64 linker hash table.  */
d2683 1
a2683 4
#define mips_elf64_link_hash_lookup(table, string, create, copy, follow) \
  ((struct mips_elf64_link_hash_entry *)				\
   elf_link_hash_lookup (&(table)->root, (string), (create),		\
			 (copy), (follow)))
d2685 41
a2725 1
/* Traverse a MIPS ELF linker hash table.  */
d2727 2
a2728 5
#define mips_elf64_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))
d2730 5
a2734 1
/* Get the MIPS ELF64 linker hash table from a link_info structure.  */
d2736 15
a2750 2
#define mips_elf64_hash_table(p) \
  ((struct mips_elf64_link_hash_table *) ((p)->hash))
d2752 1
a2752 40
/* Create an entry in a MIPS ELF64 linker hash table.  */

static struct bfd_hash_entry *
mips_elf64_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  struct mips_elf64_link_hash_entry *ret =
    (struct mips_elf64_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct mips_elf64_link_hash_entry *) NULL)
    ret = ((struct mips_elf64_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct mips_elf64_link_hash_entry)));
  if (ret == (struct mips_elf64_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct mips_elf64_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct mips_elf64_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      memset (&ret->esym, 0, sizeof (EXTR));
      /* We use -2 as a marker to indicate that the information has
	 not been set.  -1 means there is no associated ifd.  */
      ret->esym.ifd = -2;
      ret->possibly_dynamic_relocs = 0;
      ret->readonly_reloc = false;
      ret->min_dyn_reloc_index = 0;
      ret->no_fn_stub = false;
      ret->fn_stub = NULL;
      ret->need_fn_stub = false;
      ret->call_stub = NULL;
      ret->call_fp_stub = NULL;
    }
d2754 1
a2754 4149
  return (struct bfd_hash_entry *) ret;
}

/* Create a MIPS ELF64 linker hash table.  */

struct bfd_link_hash_table *
mips_elf64_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct mips_elf64_link_hash_table *ret;

  ret = ((struct mips_elf64_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct mips_elf64_link_hash_table)));
  if (ret == (struct mips_elf64_link_hash_table *) NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       mips_elf64_link_hash_newfunc))
    {
      bfd_release (abfd, ret);
      return NULL;
    }

  ret->mips16_stubs_seen = false;

  return &ret->root.root;
}

/* Returns the offset for the entry at the INDEXth position
   in the GOT.  */

static bfd_vma
mips_elf64_got_offset_from_index (dynobj, output_bfd, index)
     bfd *dynobj;
     bfd *output_bfd;
     bfd_vma index;
{
  asection *sgot;
  bfd_vma gp;

  sgot = bfd_get_section_by_name (dynobj, ".got");
  gp = _bfd_get_gp_value (output_bfd);
  return (sgot->output_section->vma + sgot->output_offset + index - 
	  gp);
}

/* Returns the GOT information associated with the link indicated by
   INFO.  If SGOTP is non-NULL, it is filled in with the GOT 
   section.  */

static struct mips_elf64_got_info *
_mips_elf64_got_info (abfd, sgotp)
     bfd *abfd;
     asection **sgotp;
{
  asection *sgot;
  struct mips_elf64_got_info *g;

  sgot = bfd_get_section_by_name (abfd, ".got");
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_elf64_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  if (sgotp)
    *sgotp = sgot;
  return g;
}

/* Sign-extend VALUE, which has the indicated number of BITS.  */

static bfd_vma
mips_elf64_sign_extend (value, bits)
     bfd_vma value;
     int bits;
{
  if (value & ((bfd_vma)1 << (bits - 1)))
    /* VALUE is negative.  */
    value |= ((bfd_vma) - 1) << bits;      
  
  return value;
}

/* Return non-zero if the indicated VALUE has overflowed the maximum
   range expressable by a signed number with the indicated number of
   BITS.  */

static boolean
mips_elf64_overflow_p (value, bits)
     bfd_vma value;
     int bits;
{
  bfd_signed_vma svalue = (bfd_signed_vma) value;

  if (svalue > (1 << (bits - 1)) - 1)
    /* The value is too big.  */
    return true;
  else if (svalue < -(1 << (bits - 1)))
    /* The value is too small.  */
    return true;
    
  /* All is well.  */
  return false;
}

/* Returns the GOT index for the global symbol indicated by H.  */

static bfd_vma 
mips_elf64_global_got_index (abfd, h)
     bfd *abfd;
     struct elf_link_hash_entry *h;
{
  bfd_vma index;
  asection *sgot;
  struct mips_elf64_got_info *g;

  g = _mips_elf64_got_info (abfd, &sgot);

  /* Once we determine the global GOT entry with the lowest dynamic
     symbol table index, we must put all dynamic symbols with greater
     indices into the GOT.  That makes it easy to calculate the GOT
     offset.  */
  BFD_ASSERT (h->dynindx >= g->global_gotsym->dynindx);
  index = ((h->dynindx - g->global_gotsym->dynindx + g->local_gotno) 
	   * (get_elf_backend_data (abfd)->s->arch_size / 8));
  BFD_ASSERT (index < sgot->_raw_size);

  return index;
}

struct mips_elf64_hash_sort_data
{
  /* The symbol in the global GOT with the lowest dynamic symbol table
     index.  */
  struct elf_link_hash_entry *low;
  /* The least dynamic symbol table index corresponding to a symbol
     with a GOT entry.  */
  long min_got_dynindx;
  /* The greatest dynamic symbol table index not corresponding to a
     symbol without a GOT entry.  */
  long max_non_got_dynindx;
};

/* If H needs a GOT entry, assign it the highest available dynamic
   index.  Otherwise, assign it the lowest available dynamic 
   index.  */

static boolean
mips_elf64_sort_hash_table_f (h, data)
     struct mips_elf64_link_hash_entry *h;
     PTR data;
{
  struct mips_elf64_hash_sort_data *hsd 
    = (struct mips_elf64_hash_sort_data *) data;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

  /* Symbols without dynamic symbol table entries aren't interesting
     at all.  */
  if (h->root.dynindx == -1)
    return true;

  if (h->root.got.offset != 1)
    h->root.dynindx = hsd->max_non_got_dynindx++;
  else
    {
      h->root.dynindx = --hsd->min_got_dynindx;
      hsd->low = (struct elf_link_hash_entry *) h;
    }

  return true;
}

/* Sort the dynamic symbol table so that symbols that need GOT entries
   appear towards the end.  This reduces the amount of GOT space
   required.  MAX_LOCAL is used to set the number of local symbols
   known to be in the dynamic symbol table.  During
   mips_elf64_size_dynamic_sections, this value is 1.  Afterward, the
   section symbols are added and the count is higher.  */

static boolean
mips_elf64_sort_hash_table (info, max_local)
     struct bfd_link_info *info;
     unsigned long max_local;
{
  struct mips_elf64_hash_sort_data hsd;
  struct mips_elf64_got_info *g;
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  hsd.low = NULL;
  hsd.min_got_dynindx = elf_hash_table (info)->dynsymcount;
  hsd.max_non_got_dynindx = max_local;
  mips_elf64_link_hash_traverse (((struct mips_elf64_link_hash_table *) 
				  elf_hash_table (info)), 
				 mips_elf64_sort_hash_table_f, 
				 &hsd);

  /* There shoud have been enough room in the symbol table to
     accomodate both the GOT and non-GOT symbols.  */
  BFD_ASSERT (hsd.max_non_got_dynindx <= hsd.min_got_dynindx);

  /* Now we know which dynamic symbol has the lowest dynamic symbol
     table index in the GOT.  */
  g = _mips_elf64_got_info (dynobj, NULL);
  g->global_gotsym = hsd.low;

  return true;
}

#if 0
/* Swap in an MSYM entry.  */

static void
mips_elf64_swap_msym_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_Msym *ex;
     Elf32_Internal_Msym *in;
{
  in->ms_hash_value = H_GET_32 (abfd, ex->ms_hash_value);
  in->ms_info = H_GET_32 (abfd, ex->ms_info);
}
#endif
/* Swap out an MSYM entry.  */

static void
mips_elf64_swap_msym_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_Internal_Msym *in;
     Elf32_External_Msym *ex;
{
  H_PUT_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  H_PUT_32 (abfd, in->ms_info, ex->ms_info);
}

/* Create a local GOT entry for VALUE.  Return the index of the entry,
   or -1 if it could not be created.  */

static bfd_vma
mips_elf64_create_local_got_entry (abfd, g, sgot, value)
     bfd *abfd;
     struct mips_elf64_got_info *g;
     asection *sgot;
     bfd_vma value;
{
  CONST bfd_vma got_size = get_elf_backend_data (abfd)->s->arch_size / 8;
  
  if (g->assigned_gotno >= g->local_gotno)
    {
      /* We didn't allocate enough space in the GOT.  */
      (*_bfd_error_handler)
	(_("not enough GOT space for local GOT entries"));
      bfd_set_error (bfd_error_bad_value);
      return (bfd_vma) -1;
    }

  bfd_put_64 (abfd, value, (sgot->contents + got_size * g->assigned_gotno));
  return got_size * g->assigned_gotno++;
}

/* Returns the GOT offset at which the indicated address can be found.
   If there is not yet a GOT entry for this value, create one.  Returns
   -1 if no satisfactory GOT offset can be found.  */

static bfd_vma
mips_elf64_local_got_index (abfd, info, value)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
{
  CONST bfd_vma got_size = get_elf_backend_data (abfd)->s->arch_size / 8;
  asection *sgot;
  struct mips_elf64_got_info *g;
  bfd_byte *entry;

  g = _mips_elf64_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  for (entry = (sgot->contents + got_size * MIPS_RESERVED_GOTNO); 
       entry != sgot->contents + got_size * g->assigned_gotno;
       entry += got_size)
    {
      bfd_vma address = bfd_get_64 (abfd, entry);
      if (address == value)
	return entry - sgot->contents;
    }

  return mips_elf64_create_local_got_entry (abfd, g, sgot, value);
}

/* Find a GOT entry that is within 32KB of the VALUE.  These entries
   are supposed to be placed at small offsets in the GOT, i.e.,
   within 32KB of GP.  Return the index into the GOT for this page,
   and store the offset from this entry to the desired address in
   OFFSETP, if it is non-NULL.  */

static bfd_vma
mips_elf64_got_page (abfd, info, value, offsetp)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     bfd_vma *offsetp;
{
  CONST bfd_vma got_size = get_elf_backend_data (abfd)->s->arch_size / 8;
  asection *sgot;
  struct mips_elf64_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  g = _mips_elf64_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we aleady have an appropriate entry.  */
  last_entry = sgot->contents + got_size * g->assigned_gotno;
  for (entry = (sgot->contents + got_size * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += got_size)
    {
      address = bfd_get_64 (abfd, entry);

      if (!mips_elf64_overflow_p (value - address, 16))
	{
	  /* This entry will serve as the page pointer.  We can add a
	     16-bit number to it to get the actual address.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf64_create_local_got_entry (abfd, g, sgot, value);

  if (offsetp)
    {
      address = bfd_get_64 (abfd, entry);
      *offsetp = value - address;
    }

  return index;
}

/* Find a GOT entry whose higher-order 16 bits are the same as those
   for value.  Return the index into the GOT for this entry.  */

static bfd_vma
mips_elf64_got16_entry (abfd, info, value, external)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_vma value;
     boolean external;
{
  CONST bfd_vma got_size = get_elf_backend_data (abfd)->s->arch_size / 8;
  asection *sgot;
  struct mips_elf64_got_info *g;
  bfd_byte *entry;
  bfd_byte *last_entry;
  bfd_vma index = 0;
  bfd_vma address;

  if (! external)
    {
      /* Although the ABI says that it is "the high-order 16 bits" that we
	 want, it is really the %high value.  The complete value is
	 calculated with a `addiu' of a LO16 relocation, just as with a
	 HI16/LO16 pair.  */
      value = mips_elf64_high (value) << 16;
    }

  g = _mips_elf64_got_info (elf_hash_table (info)->dynobj, &sgot);

  /* Look to see if we already have an appropriate entry.  */
  last_entry = sgot->contents + got_size * g->assigned_gotno;
  for (entry = (sgot->contents + got_size * MIPS_RESERVED_GOTNO);
       entry != last_entry;
       entry += got_size)
    {
      address = bfd_get_64 (abfd, entry);
      if (address == value)
	{
	  /* This entry has the right high-order 16 bits, and the low-order
	     16 bits are set to zero.  */
	  index = entry - sgot->contents;
	  break;
	}
    }

  /* If we didn't have an appropriate entry, we create one now.  */
  if (entry == last_entry)
    index = mips_elf64_create_local_got_entry (abfd, g, sgot, value);

  return index;
}

/* Return whether a relocation is against a local symbol.  */

static boolean
mips_elf64_local_relocation_p (input_bfd, relocation, local_sections,
			     check_forced)
     bfd *input_bfd;
     const Elf_Internal_Rela *relocation;
     asection **local_sections;
     boolean check_forced;
{
  unsigned long r_symndx;
  Elf_Internal_Shdr *symtab_hdr;
  struct mips_elf64_link_hash_entry* h;
  size_t extsymoff;

  r_symndx = ELF64_R_SYM (relocation->r_info);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  extsymoff = (elf_bad_symtab (input_bfd)) ? 0 : symtab_hdr->sh_info;

  if (r_symndx < extsymoff)
    return true;
  if (elf_bad_symtab (input_bfd) && local_sections[r_symndx] != NULL)
    return true;

  if (check_forced)
    {
       /* Look up the hash table to check whether the symbol
 	 was forced local.  */
       h = (struct mips_elf64_link_hash_entry *)
 	  elf_sym_hashes (input_bfd) [r_symndx - extsymoff];
       /* Find the real hash-table entry for this symbol.  */
       while (h->root.root.type == bfd_link_hash_indirect
 	     || h->root.root.type == bfd_link_hash_warning)
         h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;
       if ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0)
         return true;
    }

  return false;
}

/* Returns the first relocation of type r_type found, beginning with
   RELOCATION.  RELEND is one-past-the-end of the relocation table.  */

static const Elf_Internal_Rela *
mips_elf64_next_relocation (r_type, relocation, relend)
     unsigned int r_type;
     const Elf_Internal_Rela *relocation;
     const Elf_Internal_Rela *relend;
{
  /* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be
     immediately following.  However, for the IRIX6 ABI, the next
     relocation may be a composed relocation consisting of several
     relocations for the same address.  In that case, the R_MIPS_LO16
     relocation may occur as one of these.  We permit a similar
     extension in general, as that is useful for GCC.  */
  while (relocation < relend)
    {
      if (ELF64_MIPS_R_TYPE (relocation->r_info) == r_type)
	return relocation;

      ++relocation;
    }

  /* We didn't find it.  */
  bfd_set_error (bfd_error_bad_value);
  return NULL;
}

/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL
   is the original relocation, which is now being transformed into a
   dynamic relocation.  The ADDENDP is adjusted if necessary; the
   caller should store the result in place of the original addend.  */

static boolean
mips_elf64_create_dynamic_relocation (output_bfd, info, rel, h, sec,
				    symbol, addendp, input_section)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *rel;
     struct mips_elf64_link_hash_entry *h;
     asection *sec;
     bfd_vma symbol;
     bfd_vma *addendp;
     asection *input_section;
{
  Elf_Internal_Rel outrel[3];
  boolean skip;
  asection *sreloc;
  bfd *dynobj;
  int r_type;

  r_type = ELF64_MIPS_R_TYPE (rel->r_info);
  dynobj = elf_hash_table (info)->dynobj;
  sreloc = bfd_get_section_by_name (dynobj, ".rel.dyn");
  BFD_ASSERT (sreloc != NULL);
  BFD_ASSERT (sreloc->contents != NULL);
  BFD_ASSERT ((sreloc->reloc_count
	       * get_elf_backend_data (output_bfd)->s->sizeof_rel)
	      < sreloc->_raw_size);

  skip = false;
  outrel[0].r_offset = _bfd_elf_section_offset (output_bfd, info,
						input_section,
						rel[0].r_offset);
  /* FIXME: For -2 runtime relocation needs to be skipped, but
     properly resolved statically and installed.  */
  BFD_ASSERT (outrel[0].r_offset != (bfd_vma) -2);

  /* We begin by assuming that the offset for the dynamic relocation
     is the same as for the original relocation.  We'll adjust this
     later to reflect the correct output offsets.  */
  if (elf_section_data (input_section)->sec_info_type != ELF_INFO_TYPE_STABS)
    {
      outrel[1].r_offset = rel[1].r_offset;
      outrel[2].r_offset = rel[2].r_offset;
    }
  else
    {
      /* Except that in a stab section things are more complex.
	 Because we compress stab information, the offset given in the
	 relocation may not be the one we want; we must let the stabs
	 machinery tell us the offset.  */
      outrel[1].r_offset = outrel[0].r_offset;
      outrel[2].r_offset = outrel[0].r_offset;
      /* If we didn't need the relocation at all, this value will be
	 -1.  */
      if (outrel[0].r_offset == (bfd_vma) -1)
	skip = true;
    }

  /* If we've decided to skip this relocation, just output an empty
     record.  Note that R_MIPS_NONE == 0, so that this call to memset
     is a way of setting R_TYPE to R_MIPS_NONE.  */
  if (skip)
    memset (outrel, 0, sizeof (Elf_Internal_Rel) * 3);
  else
    {
      long indx;
      bfd_vma section_offset;

      /* We must now calculate the dynamic symbol table index to use
	 in the relocation.  */
      if (h != NULL
	  && (! info->symbolic || (h->root.elf_link_hash_flags
				   & ELF_LINK_HASH_DEF_REGULAR) == 0))
	{
	  indx = h->root.dynindx;
	  /* h->root.dynindx may be -1 if this symbol was marked to
	     become local.  */
	  if (indx == -1)
		indx = 0;
	}
      else
	{
	  if (sec != NULL && bfd_is_abs_section (sec))
	    indx = 0;
	  else if (sec == NULL || sec->owner == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  else
	    {
	      indx = elf_section_data (sec->output_section)->dynindx;
	      if (indx == 0)
		abort ();
	    }

	  /* Figure out how far the target of the relocation is from
	     the beginning of its section.  */
	  section_offset = symbol - sec->output_section->vma;
	  /* The relocation we're building is section-relative.
	     Therefore, the original addend must be adjusted by the
	     section offset.  */
	  *addendp += section_offset;
	  /* Now, the relocation is just against the section.  */
	  symbol = sec->output_section->vma;
	}
      
      /* If the relocation was previously an absolute relocation and
	 this symbol will not be referred to by the relocation, we must
	 adjust it by the value we give it in the dynamic symbol table.
	 Otherwise leave the job up to the dynamic linker.  */
      if (!indx && r_type != R_MIPS_REL32)
	*addendp += symbol;

      /* The relocation is always an REL32 relocation because we don't
	 know where the shared library will wind up at load-time.  */
      outrel[0].r_info = ELF64_R_INFO (indx, R_MIPS_REL32);

      /* Adjust the output offset of the relocation to reference the
	 correct location in the output file.  */
      outrel[0].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
      outrel[1].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
      outrel[2].r_offset += (input_section->output_section->vma
			     + input_section->output_offset);
    }

  /* Put the relocation back out.  */
  mips_elf64_be_swap_reloc_out (output_bfd, outrel,
				(sreloc->contents 
				 + sreloc->reloc_count
				   * sizeof (Elf64_Mips_External_Rel)));

  /* Record the index of the first relocation referencing H.  This
     information is later emitted in the .msym section.  */
  if (h != NULL
      && (h->min_dyn_reloc_index == 0 
	  || sreloc->reloc_count < h->min_dyn_reloc_index))
    h->min_dyn_reloc_index = sreloc->reloc_count;

  /* We've now added another relocation.  */
  ++sreloc->reloc_count;

  /* Make sure the output section is writable.  The dynamic linker
     will be writing to it.  */
  elf_section_data (input_section->output_section)->this_hdr.sh_flags
    |= SHF_WRITE;

  return true;
}

/* Calculate the value produced by the RELOCATION (which comes from
   the INPUT_BFD).  The ADDEND is the addend to use for this
   RELOCATION; RELOCATION->R_ADDEND is ignored.

   The result of the relocation calculation is stored in VALUEP.
   REQUIRE_JALXP indicates whether or not the opcode used with this
   relocation must be JALX.

   This function returns bfd_reloc_continue if the caller need take no
   further action regarding this relocation, bfd_reloc_notsupported if
   something goes dramatically wrong, bfd_reloc_overflow if an
   overflow occurs, and bfd_reloc_ok to indicate success.  */

static bfd_reloc_status_type
mips_elf64_calculate_relocation (abfd, input_bfd, input_section, info,
				 relocation, addend, howto, local_syms,
				 local_sections, valuep, namep, require_jalxp)
     bfd *abfd;
     bfd *input_bfd;
     asection *input_section;
     struct bfd_link_info *info;
     const Elf_Internal_Rela *relocation;
     bfd_vma addend;
     reloc_howto_type *howto;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
     bfd_vma *valuep;
     const char **namep;
     boolean *require_jalxp;
{
  /* The eventual value we will return.  */
  bfd_vma value;
  /* The address of the symbol against which the relocation is
     occurring.  */
  bfd_vma symbol = 0;
  /* The final GP value to be used for the relocatable, executable, or
     shared object file being produced.  */
  bfd_vma gp = (bfd_vma) - 1;
  /* The place (section offset or address) of the storage unit being
     relocated.  */
  bfd_vma p;
  /* The value of GP used to create the relocatable object.  */
  bfd_vma gp0 = (bfd_vma) - 1;
  /* The offset into the global offset table at which the address of
     the relocation entry symbol, adjusted by the addend, resides
     during execution.  */
  bfd_vma g = (bfd_vma) - 1;
  /* The section in which the symbol referenced by the relocation is
     located.  */
  asection *sec = NULL;
  struct mips_elf64_link_hash_entry* h = NULL;
  /* True if the symbol referred to by this relocation is a local
     symbol.  */
  boolean local_p;
  Elf_Internal_Shdr *symtab_hdr;
  size_t extsymoff;
  unsigned long r_symndx;
  int r_type;
  /* True if overflow occurred during the calculation of the
     relocation value.  */
  boolean overflowed_p;
  /* True if this relocation refers to a MIPS16 function.  */
  boolean target_is_16_bit_code_p = false;

  /* Parse the relocation.  */
  r_symndx = ELF64_R_SYM (relocation->r_info);
  r_type = ELF64_MIPS_R_TYPE (relocation->r_info);
  p = (input_section->output_section->vma 
       + input_section->output_offset
       + relocation->r_offset);

  /* Assume that there will be no overflow.  */
  overflowed_p = false;

  /* Figure out whether or not the symbol is local, and get the offset
     used in the array of hash table entries.  */
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_p = mips_elf64_local_relocation_p (input_bfd, relocation,
					 local_sections, false);
  if (! elf_bad_symtab (input_bfd))
    extsymoff = symtab_hdr->sh_info;
  else
    {
      /* The symbol table does not follow the rule that local symbols
	 must come before globals.  */
      extsymoff = 0;
    }

  /* Figure out the value of the symbol.  */
  if (local_p)
    {
      Elf_Internal_Sym *sym;

      sym = local_syms + r_symndx;
      sec = local_sections[r_symndx];

      symbol = sec->output_section->vma + sec->output_offset;
      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
	symbol += sym->st_value;

      /* MIPS16 text labels should be treated as odd.  */
      if (sym->st_other == STO_MIPS16)
	++symbol;

      /* Record the name of this symbol, for our caller.  */
      *namep = bfd_elf_string_from_elf_section (input_bfd,
						symtab_hdr->sh_link,
						sym->st_name);
      if (*namep == '\0')
	*namep = bfd_section_name (input_bfd, sec);

      target_is_16_bit_code_p = (sym->st_other == STO_MIPS16);
    }
  else
    {
      /* For global symbols we look up the symbol in the hash-table.  */
      h = ((struct mips_elf64_link_hash_entry *) 
	   elf_sym_hashes (input_bfd) [r_symndx - extsymoff]);
      /* Find the real hash-table entry for this symbol.  */
      while (h->root.root.type == bfd_link_hash_indirect
	     || h->root.root.type == bfd_link_hash_warning)
	h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;
      
      /* Record the name of this symbol, for our caller.  */
      *namep = h->root.root.root.string;

      /* If this symbol is defined, calculate its address.  */
      if ((h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
	  && h->root.root.u.def.section)
	{
	  sec = h->root.root.u.def.section;
	  if (sec->output_section)
	    symbol = (h->root.root.u.def.value 
		      + sec->output_section->vma
		      + sec->output_offset);
	  else
	    symbol = h->root.root.u.def.value;
	}
      else if (h->root.root.type == bfd_link_hash_undefweak)
	/* We allow relocations against undefined weak symbols, giving
	   it the value zero, so that you can undefined weak functions
	   and check to see if they exist by looking at their
	   addresses.  */
	symbol = 0;
      else if (info->shared
	       && (!info->symbolic || info->allow_shlib_undefined)
	       && !info->no_undefined
	       && ELF_ST_VISIBILITY (h->root.other) == STV_DEFAULT)
	symbol = 0;
      else if (strcmp (h->root.root.root.string, "_DYNAMIC_LINK") == 0 ||
              strcmp (h->root.root.root.string, "_DYNAMIC_LINKING") == 0)
	{
	  /* If this is a dynamic link, we should have created a
	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol 
	     in in mips_elf64_create_dynamic_sections.
	     Otherwise, we should define the symbol with a value of 0.
	     FIXME: It should probably get into the symbol table
	     somehow as well.  */
	  BFD_ASSERT (! info->shared);
	  BFD_ASSERT (bfd_get_section_by_name (abfd, ".dynamic") == NULL);
	  symbol = 0;
	}
      else
	{
	  if (! ((*info->callbacks->undefined_symbol)
		 (info, h->root.root.root.string, input_bfd,
		  input_section, relocation->r_offset,
		  (!info->shared || info->no_undefined
		   || ELF_ST_VISIBILITY (h->root.other)))))
	    return bfd_reloc_undefined;
	  symbol = 0;
	}

      target_is_16_bit_code_p = (h->root.other == STO_MIPS16);
    }

  /* If this is a 64-bit call to a 16-bit function with a stub, we
     need to redirect the call to the stub, unless we're already *in*
     a stub.  */
  if (r_type != R_MIPS16_26 && !info->relocateable
      && ((h != NULL && h->fn_stub != NULL)
	  || (local_p && elf_tdata (input_bfd)->local_stubs != NULL
	      && elf_tdata (input_bfd)->local_stubs[r_symndx] != NULL))
      && !mips_elf64_stub_section_p (input_bfd, input_section))
    {
      /* This is a 64-bit call to a 16-bit function.  We should
	 have already noticed that we were going to need the
	 stub.  */
      if (local_p)
	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
      else
	{
	  BFD_ASSERT (h->need_fn_stub);
	  sec = h->fn_stub;
	}

      symbol = sec->output_section->vma + sec->output_offset;
    }
  /* If this is a 16-bit call to a 64-bit function with a stub, we
     need to redirect the call to the stub.  */
  else if (r_type == R_MIPS16_26 && !info->relocateable
	   && h != NULL
	   && (h->call_stub != NULL || h->call_fp_stub != NULL)
	   && !target_is_16_bit_code_p)
    {
      /* If both call_stub and call_fp_stub are defined, we can figure
	 out which one to use by seeing which one appears in the input
	 file.  */
      if (h->call_stub != NULL && h->call_fp_stub != NULL)
	{
	  asection *o;

	  sec = NULL;
	  for (o = input_bfd->sections; o != NULL; o = o->next)
	    {
	      if (strncmp (bfd_get_section_name (input_bfd, o),
			   CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
		{
		  sec = h->call_fp_stub;
		  break;
		}
	    }
	  if (sec == NULL)
	    sec = h->call_stub;
	}
      else if (h->call_stub != NULL)
	sec = h->call_stub;
      else
	sec = h->call_fp_stub;

      BFD_ASSERT (sec->_raw_size > 0);
      symbol = sec->output_section->vma + sec->output_offset;
    }

  /* Calls from 16-bit code to 32-bit code and vice versa require the
     special jalx instruction.  */
  *require_jalxp = (!info->relocateable
		    && ((r_type == R_MIPS16_26) != target_is_16_bit_code_p));

  local_p = mips_elf64_local_relocation_p (input_bfd, relocation,
					   local_sections, true);

  /* If we haven't already determined the GOT offset, or the GP value,
     and we're going to need it, get it now.  */
  switch (r_type)
    {
    case R_MIPS_CALL16:
    case R_MIPS_GOT16:
    case R_MIPS_GOT_DISP:
    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      /* Find the index into the GOT where this value is located.  */
      if (!local_p)
	{
	  BFD_ASSERT (addend == 0);
	  g = mips_elf64_global_got_index (elf_hash_table (info)->dynobj,
					 (struct elf_link_hash_entry*) h);
	  if (! elf_hash_table(info)->dynamic_sections_created
	      || (info->shared
		  && (info->symbolic || h->root.dynindx == -1)
		  && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	    {
	      /* This is a static link or a -Bsymbolic link.  The
		 symbol is defined locally, or was forced to be local.
		 We must initialize this entry in the GOT.  */
	      bfd *tmpbfd = elf_hash_table (info)->dynobj;

	      asection *sgot = bfd_get_section_by_name (tmpbfd, ".got");
	      bfd_put_64 (tmpbfd, symbol + addend, sgot->contents + g);
	    }
	}
      else if (r_type == R_MIPS_GOT16 || r_type == R_MIPS_CALL16)
	/* There's no need to create a local GOT entry here; the
	   calculation for a local GOT16 entry does not involve G.  */
	break;
      else
	{
	  g = mips_elf64_local_got_index (abfd, info, symbol + addend);
	  if (g == (bfd_vma) -1)
	    return false;
	}

      /* Convert GOT indices to actual offsets.  */
      g = mips_elf64_got_offset_from_index (elf_hash_table (info)->dynobj,
					    abfd, g);
      break;
      
    case R_MIPS_HI16:
    case R_MIPS_LO16:
    case R_MIPS_GPREL16:
    case R_MIPS_GPREL32:
    case R_MIPS_LITERAL:
      gp0 = _bfd_get_gp_value (input_bfd);
      gp = _bfd_get_gp_value (abfd);
      break;

    default:
      break;
    }

  /* Figure out what kind of relocation is being performed.  */
  switch (r_type)
    {
    case R_MIPS_NONE:
      return bfd_reloc_continue;

    case R_MIPS_16:
      value = symbol + mips_elf64_sign_extend (addend, 16);
      overflowed_p = mips_elf64_overflow_p (value, 16);
      break;

    case R_MIPS_32:
    case R_MIPS_REL32:
    case R_MIPS_64:
      if ((info->shared
	   || (elf_hash_table (info)->dynamic_sections_created
	       && h != NULL
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_DYNAMIC) != 0)
	       && ((h->root.elf_link_hash_flags
		    & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	  && r_symndx != 0
	  && (input_section->flags & SEC_ALLOC) != 0)
	{
	  /* If we're creating a shared library, or this relocation is
	     against a symbol in a shared library, then we can't know
	     where the symbol will end up.  So, we create a relocation
	     record in the output, and leave the job up to the dynamic
	     linker.  */
	  value = addend;
	  if (!mips_elf64_create_dynamic_relocation (abfd, info, relocation,
						     h, sec, symbol, &value,
						     input_section))
	    return false;
	}
      else
	{
	  if (r_type != R_MIPS_REL32)
	    value = symbol + addend;
	  else
	    value = addend;
	}
      value &= howto->dst_mask;
      break;

    case R_MIPS_PC32:
    case R_MIPS_PC64:
    case R_MIPS_GNU_REL_LO16:
      value = symbol + addend - p;
      value &= howto->dst_mask;
      break;

    case R_MIPS_GNU_REL16_S2:
      value = symbol + mips_elf64_sign_extend (addend << 2, 18) - p;
      overflowed_p = mips_elf64_overflow_p (value, 18);
      value = (value >> 2) & howto->dst_mask;
      break;

    case R_MIPS_GNU_REL_HI16:
      value = mips_elf64_high (addend + symbol - p);
      value &= howto->dst_mask;
      break;

    case R_MIPS16_26:
      /* The calculation for R_MIPS16_26 is just the same as for an
	 R_MIPS_26.  It's only the storage of the relocated field into
	 the output file that's different.  That's handled in
	 mips_elf_perform_relocation.  So, we just fall through to the
	 R_MIPS_26 case here.  */
    case R_MIPS_26:
      if (local_p)
	value = (((addend << 2) | ((p + 4) & 0xf0000000)) + symbol) >> 2;
      else
	value = (mips_elf64_sign_extend (addend << 2, 28) + symbol) >> 2;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HI16:
      value = mips_elf64_high (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_LO16:
	value = (addend + symbol) & 0xffff;
	value &= howto->dst_mask;
      break;

    case R_MIPS_LITERAL:
      /* Because we don't merge literal sections, we can handle this
	 just like R_MIPS_GPREL16.  In the long run, we should merge
	 shared literals, and then we will need to additional work
	 here.  */

      /* Fall through.  */

    case R_MIPS_GPREL16:
      if (local_p)
	value = mips_elf64_sign_extend (addend, 16) + symbol + gp0 - gp;
      else
	value = mips_elf64_sign_extend (addend, 16) + symbol - gp;
      overflowed_p = mips_elf64_overflow_p (value, 16);
      break;
      
    case R_MIPS_PC16:
      value = mips_elf64_sign_extend (addend, 16) + symbol - p;
      overflowed_p = mips_elf64_overflow_p (value, 16);
      value = (bfd_vma) ((bfd_signed_vma) value / 4);
      break;

    case R_MIPS_GOT16:
    case R_MIPS_CALL16:
      if (local_p)
	{
	  boolean forced;
	  
	  /* The special case is when the symbol is forced to be local.  We
	     need the full address in the GOT since no R_MIPS_LO16 relocation
	     follows.  */
	  forced = ! mips_elf64_local_relocation_p (input_bfd, relocation,
						  local_sections, false);
	  value = mips_elf64_got16_entry (abfd, info, symbol + addend, forced);
	  if (value == (bfd_vma) -1)
	    return false;
	  value 
	    = mips_elf64_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
	  overflowed_p = mips_elf64_overflow_p (value, 16);
	  break;
	}

      /* Fall through.  */

    case R_MIPS_GOT_DISP:
      value = g;
      overflowed_p = mips_elf64_overflow_p (value, 16);
      break;

    case R_MIPS_GPREL32:
      value = (addend + symbol + gp0 - gp) & howto->dst_mask;
      break;

    case R_MIPS_GOT_HI16:
    case R_MIPS_CALL_HI16:
      /* We're allowed to handle these two relocations identically.
	 The dynamic linker is allowed to handle the CALL relocations
	 differently by creating a lazy evaluation stub.  */
      value = g;
      value = mips_elf64_high (value);
      value &= howto->dst_mask;
      break;

    case R_MIPS_GOT_LO16:
    case R_MIPS_CALL_LO16:
      value = g & howto->dst_mask;
      break;

    case R_MIPS_GOT_PAGE:
      value = mips_elf64_got_page (abfd, info, symbol + addend, NULL);
      if (value == (bfd_vma) -1)
	return false;
      value = mips_elf64_got_offset_from_index (elf_hash_table (info)->dynobj,
					      abfd,
					      value);
      overflowed_p = mips_elf64_overflow_p (value, 16);
      break;
      
    case R_MIPS_GOT_OFST:
      mips_elf64_got_page (abfd, info, symbol + addend, &value);
      overflowed_p = mips_elf64_overflow_p (value, 16);
      break;

    case R_MIPS_SUB:
      value = symbol - addend;
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHER:
      value = mips_elf64_higher (addend + symbol);
      value &= howto->dst_mask;
      break;

    case R_MIPS_HIGHEST:
      value = mips_elf64_highest (addend + symbol);
      value &= howto->dst_mask;
      break;
      
    case R_MIPS_SCN_DISP:
      value = symbol + addend - sec->output_offset;
      value &= howto->dst_mask;
      break;

    case R_MIPS_PJUMP:
    case R_MIPS_JALR:
      /* Both of these may be ignored.  R_MIPS_JALR is an optimization
	 hint; we could improve performance by honoring that hint.  */
      return bfd_reloc_continue;

    case R_MIPS_GNU_VTINHERIT:
    case R_MIPS_GNU_VTENTRY:
      /* We don't do anything with these at present.  */
      return bfd_reloc_continue;

    default:
      /* An unrecognized relocation type.  */
      return bfd_reloc_notsupported;
    }

  /* Store the VALUE for our caller.  */
  *valuep = value;
  return overflowed_p ? bfd_reloc_overflow : bfd_reloc_ok;
}

/* Obtain the field relocated by RELOCATION.  */

static bfd_vma
mips_elf64_obtain_contents (howto, relocation, input_bfd, contents)
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd *input_bfd;
     bfd_byte *contents;
{
  bfd_byte *location = contents + relocation->r_offset;

  /* Obtain the bytes.  */
  return bfd_get (8 * bfd_get_reloc_size (howto), input_bfd, location);
}

/* It has been determined that the result of the RELOCATION is the
   VALUE.  Use HOWTO to place VALUE into the output file at the
   appropriate position.  The SECTION is the section to which the
   relocation applies.  If REQUIRE_JALX is true, then the opcode used
   for the relocation must be either JAL or JALX, and it is
   unconditionally converted to JALX.

   Returns false if anything goes wrong.  */

static boolean
mips_elf64_perform_relocation (info, howto, relocation, value,
			     input_bfd, input_section,
			     contents, require_jalx)
     struct bfd_link_info *info;
     reloc_howto_type *howto;
     const Elf_Internal_Rela *relocation;
     bfd_vma value;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     boolean require_jalx;
{
  bfd_vma x;
  bfd_byte *location;
  int r_type = ELF32_R_TYPE (relocation->r_info);

  /* Figure out where the relocation is occurring.  */
  location = contents + relocation->r_offset;

  /* Obtain the current value.  */
  x = mips_elf64_obtain_contents (howto, relocation, input_bfd, contents);

  /* Clear the field we are setting.  */
  x &= ~howto->dst_mask;

  /* If this is the R_MIPS16_26 relocation, we must store the
     value in a funny way.  */
  if (r_type == R_MIPS16_26)
    {
      /* R_MIPS16_26 is used for the mips16 jal and jalx instructions.
	 Most mips16 instructions are 16 bits, but these instructions
	 are 32 bits.

	 The format of these instructions is:

	 +--------------+--------------------------------+
	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  !
	 +--------------+--------------------------------+
	 !	  	  Immediate  15:0		    !
	 +-----------------------------------------------+

	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.
	 Note that the immediate value in the first word is swapped.

	 When producing a relocateable object file, R_MIPS16_26 is
	 handled mostly like R_MIPS_26.  In particular, the addend is
	 stored as a straight 26-bit value in a 32-bit instruction.
	 (gas makes life simpler for itself by never adjusting a
	 R_MIPS16_26 reloc to be against a section, so the addend is
	 always zero).  However, the 32 bit instruction is stored as 2
	 16-bit values, rather than a single 32-bit value.  In a
	 big-endian file, the result is the same; in a little-endian
	 file, the two 16-bit halves of the 32 bit value are swapped.
	 This is so that a disassembler can recognize the jal
	 instruction.

	 When doing a final link, R_MIPS16_26 is treated as a 32 bit
	 instruction stored as two 16-bit values.  The addend A is the
	 contents of the targ26 field.  The calculation is the same as
	 R_MIPS_26.  When storing the calculated value, reorder the
	 immediate value as shown above, and don't forget to store the
	 value as two 16-bit values.

	 To put it in MIPS ABI terms, the relocation field is T-targ26-16,
	 defined as

	 big-endian:
	 +--------+----------------------+
	 |        |                      |
	 |        |    targ26-16         |
	 |31    26|25                   0|
	 +--------+----------------------+

	 little-endian:
	 +----------+------+-------------+
	 |          |      |             |
	 |  sub1    |      |     sub2    |
	 |0        9|10  15|16         31|
	 +----------+--------------------+
	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is
	 ((sub1 << 16) | sub2)).

	 When producing a relocateable object file, the calculation is
	 (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 When producing a fully linked file, the calculation is
	 let R = (((A < 2) | ((P + 4) & 0xf0000000) + S) >> 2)
	 ((R & 0x1f0000) << 5) | ((R & 0x3e00000) >> 5) | (R & 0xffff)  */

      if (!info->relocateable)
	/* Shuffle the bits according to the formula above.  */
	value = (((value & 0x1f0000) << 5)
		 | ((value & 0x3e00000) >> 5)
		 | (value & 0xffff));
    }
  else if (r_type == R_MIPS16_GPREL)
    {
      /* R_MIPS16_GPREL is used for GP-relative addressing in mips16
	 mode.  A typical instruction will have a format like this:

	 +--------------+--------------------------------+
	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  !
	 +--------------+--------------------------------+
	 !    Major     !   rx   !   ry   !   Imm  4:0   !
	 +--------------+--------------------------------+

	 EXTEND is the five bit value 11110.  Major is the instruction
	 opcode.

	 This is handled exactly like R_MIPS_GPREL16, except that the
	 addend is retrieved and stored as shown in this diagram; that
	 is, the Imm fields above replace the V-rel16 field.

         All we need to do here is shuffle the bits appropriately.  As
	 above, the two 16-bit halves must be swapped on a
	 little-endian system.  */
      value = (((value & 0x7e0) << 16)
	       | ((value & 0xf800) << 5)
	       | (value & 0x1f));
    }

  /* Set the field.  */
  x |= (value & howto->dst_mask);

  /* If required, turn JAL into JALX.  */
  if (require_jalx)
    {
      boolean ok;
      bfd_vma opcode = x >> 26;
      bfd_vma jalx_opcode;

      /* Check to see if the opcode is already JAL or JALX.  */
      if (r_type == R_MIPS16_26)
	{
	  ok = ((opcode == 0x6) || (opcode == 0x7));
	  jalx_opcode = 0x7;
	}
      else
	{
	  ok = ((opcode == 0x3) || (opcode == 0x1d));
	  jalx_opcode = 0x1d;
	}

      /* If the opcode is not JAL or JALX, there's a problem.  */
      if (!ok)
	{
	  (*_bfd_error_handler)
	    (_("%s: %s+0x%lx: jump to stub routine which is not jal"),
	     bfd_archive_filename (input_bfd),
	     input_section->name,
	     (unsigned long) relocation->r_offset);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}

      /* Make this the JALX opcode.  */
      x = (x & ~(0x3f << 26)) | (jalx_opcode << 26);
    }

  /* Swap the high- and low-order 16 bits on little-endian systems
     when doing a MIPS16 relocation.  */
  if ((r_type == R_MIPS16_GPREL || r_type == R_MIPS16_26)
      && bfd_little_endian (input_bfd))
    x = (((x & 0xffff) << 16) | ((x & 0xffff0000) >> 16));

  /* Put the value into the output.  */
  bfd_put (8 * bfd_get_reloc_size (howto), input_bfd, x, location);
  return true;
}

/* Returns true if SECTION is a MIPS16 stub section.  */

static boolean
mips_elf64_stub_section_p (abfd, section)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
{
  const char *name = bfd_get_section_name (abfd, section);

  return (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0
	  || strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	  || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0);
}

/* Relocate a MIPS ELF64 section.  */

static boolean
mips_elf64_relocate_section (output_bfd, info, input_bfd, input_section,
			     contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
{
  Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *relend;
  bfd_vma addend = 0;
  boolean use_saved_addend_p = false;
  struct elf_backend_data *bed;

  bed = get_elf_backend_data (output_bfd);
  relend = relocs + input_section->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < relend; ++rel)
    {
      const char *name;
      bfd_vma value;
      reloc_howto_type *howto;
      boolean require_jalx;
      /* True if the relocation is a RELA relocation, rather than a
         REL relocation.  */
      boolean rela_relocation_p = true;
      int r_type = ELF64_MIPS_R_TYPE (rel->r_info);
      const char *msg = (const char *) NULL;

      /* Find the relocation howto for this relocation.  */
      howto = &mips_elf64_howto_table_rela[r_type];

      if (!use_saved_addend_p)
	{
	  Elf_Internal_Shdr *rel_hdr;

	  /* If these relocations were originally of the REL variety,
	     we must pull the addend out of the field that will be
	     relocated.  Otherwise, we simply use the contents of the
	     RELA relocation.  To determine which flavor or relocation
	     this is, we depend on the fact that the INPUT_SECTION's
	     REL_HDR is read before its REL_HDR2.  */
	  rel_hdr = &elf_section_data (input_section)->rel_hdr;
	  if ((size_t) (rel - relocs)
	      >= (NUM_SHDR_ENTRIES (rel_hdr) * bed->s->int_rels_per_ext_rel))
	    rel_hdr = elf_section_data (input_section)->rel_hdr2;
	  if (rel_hdr->sh_entsize
	      == (get_elf_backend_data (input_bfd)->s->sizeof_rel))
	    {
	      /* Note that this is a REL relocation.  */
	      rela_relocation_p = false;

	      /* Find the relocation howto for this relocation.  */
	      howto = &mips_elf64_howto_table_rel[r_type];

	      /* Get the addend, which is stored in the input file.  */
	      addend = mips_elf64_obtain_contents (howto, 
						   rel,
						   input_bfd,
						   contents);
	      addend &= howto->src_mask;

	      /* For some kinds of relocations, the ADDEND is a
		 combination of the addend stored in two different
		 relocations.   */
	      if (r_type == R_MIPS_HI16
		  || r_type == R_MIPS_GNU_REL_HI16
		  || (r_type == R_MIPS_GOT16
		      && mips_elf64_local_relocation_p (input_bfd, rel,
						      local_sections, false)))
		{
		  bfd_vma l;
		  const Elf_Internal_Rela *lo16_relocation;
		  reloc_howto_type *lo16_howto;
		  int lo;

		  /* The combined value is the sum of the HI16 addend,
		     left-shifted by sixteen bits, and the LO16
		     addend, sign extended.  (Usually, the code does
		     a `lui' of the HI16 value, and then an `addiu' of
		     the LO16 value.)  

		     Scan ahead to find a matching LO16 relocation.  */
		  if (r_type == R_MIPS_GNU_REL_HI16)
		    lo = R_MIPS_GNU_REL_LO16;
		  else
		    lo = R_MIPS_LO16;
		  lo16_relocation 
		    = mips_elf64_next_relocation (lo, rel, relend); 
		  if (lo16_relocation == NULL)
		    return false;

		  /* Obtain the addend kept there.  */
		  if (rela_relocation_p == false)
		    lo16_howto = &mips_elf64_howto_table_rel[lo];
		  else
		    lo16_howto = &mips_elf64_howto_table_rela[lo];
		  l = mips_elf64_obtain_contents (lo16_howto,
						lo16_relocation,
						input_bfd, contents);
		  l &= lo16_howto->src_mask;
		  l = mips_elf64_sign_extend (l, 16);

		  addend <<= 16;

		  /* Compute the combined addend.  */
		  addend += l;
		}
	    }
	  else
	    addend = rel->r_addend;
	}

      if (info->relocateable)
	{
	  Elf_Internal_Sym *sym;
	  unsigned long r_symndx;

	  /* Since we're just relocating, all we need to do is copy
	     the relocations back out to the object file, unless
	     they're against a section symbol, in which case we need
	     to adjust by the section offset, or unless they're GP
	     relative in which case we need to adjust by the amount
	     that we're adjusting GP in this relocateable object.  */

	  if (!mips_elf64_local_relocation_p (input_bfd, rel, local_sections,
					    false))
	    /* There's nothing to do for non-local relocations.  */
	    continue;

	  if (r_type == R_MIPS_GPREL16
	      || r_type == R_MIPS_GPREL32
	      || r_type == R_MIPS_LITERAL)
	    addend -= (_bfd_get_gp_value (output_bfd)
		       - _bfd_get_gp_value (input_bfd));
	  else if (r_type == R_MIPS_26 || r_type == R_MIPS_GNU_REL16_S2)
	    /* The addend is stored without its two least
	       significant bits (which are always zero.)  In a
	       non-relocateable link, calculate_relocation will do
	       this shift; here, we must do it ourselves.  */
	    addend <<= 2;

	  r_symndx = ELF64_R_SYM (rel->r_info);
	  sym = local_syms + r_symndx;
	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    /* Adjust the addend appropriately.  */
	    addend += local_sections[r_symndx]->output_offset;

#if 0
	  /* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16,
	     then we only want to write out the high-order 16 bits.
	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
	  if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16
	      || r_type == R_MIPS_GNU_REL_HI16)
	    addend = mips_elf64_high (addend);
	  else if (r_type == R_MIPS_HIGHER)
	    addend = mips_elf64_higher (addend);
	  else if (r_type == R_MIPS_HIGHEST)
	    addend = mips_elf64_highest (addend);
#endif
	  /* If the relocation is for an R_MIPS_26 relocation, then
	     the two low-order bits are not stored in the object file;
	     they are implicitly zero.  */
	  if (r_type == R_MIPS_26 || r_type == R_MIPS_GNU_REL16_S2)
	    addend >>= 2;

	  if (rela_relocation_p)
	    /* If this is a RELA relocation, just update the addend.
	       We have to cast away constness for REL.  */
	    rel->r_addend = addend;
	  else
	    {
	      /* Otherwise, we have to write the value back out.  Note
		 that we use the source mask, rather than the
		 destination mask because the place to which we are
		 writing will be source of the addend in the final
		 link.  */
	      addend &= howto->src_mask;

	      if (!mips_elf64_perform_relocation (info, howto, rel, addend,
						  input_bfd, input_section,
						  contents, false))
		return false;
	    }

	  /* Go on to the next relocation.  */
	  continue;
	}

      /* In the N32 and 64-bit ABIs there may be multiple consecutive
	 relocations for the same offset.  In that case we are
	 supposed to treat the output of each relocation as the addend
	 for the next.  */
      if (rel + 1 < relend 
	  && rel->r_offset == rel[1].r_offset
	  && ELF64_MIPS_R_TYPE (rel[1].r_info) != R_MIPS_NONE)
	use_saved_addend_p = true;
      else
	use_saved_addend_p = false;

      /* Figure out what value we are supposed to relocate.  */
      switch (mips_elf64_calculate_relocation (output_bfd, input_bfd,
					       input_section, info, rel,
					       addend, howto, local_syms,
					       local_sections, &value, &name,
					       &require_jalx))
	{
	case bfd_reloc_continue:
	  /* There's nothing to do.  */
	  continue;

	case bfd_reloc_undefined:
	  /* mips_elf64_calculate_relocation already called the
	     undefined_symbol callback.  There's no real point in
	     trying to perform the relocation at this point, so we
	     just skip ahead to the next relocation.  */
	  continue;

	case bfd_reloc_notsupported:
	  msg = _("internal error: unsupported relocation error");
	  info->callbacks->warning
	    (info, msg, name, input_bfd, input_section, rel->r_offset);
	  return false;

	case bfd_reloc_overflow:
	  if (use_saved_addend_p)
	    /* Ignore overflow until we reach the last relocation for
	       a given location.  */
	    ;
	  else
	    {
	      BFD_ASSERT (name != NULL);
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
	    }
	  break;

	case bfd_reloc_ok:
	  break;

	default:
	  abort ();
	  break;
	}

      /* If we've got another relocation for the address, keep going
	 until we reach the last one.  */
      if (use_saved_addend_p)
	{
	  addend = value;
	  continue;
	}

      /* Actually perform the relocation.  */
      if (!mips_elf64_perform_relocation (info, howto, rel, value, input_bfd,
					  input_section, contents,
					  require_jalx))
	return false;
    }

  return true;
}

/* Create dynamic sections when linking against a dynamic object.  */

boolean
mips_elf64_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);

  /* Mips ABI requests the .dynamic section to be read only.  */
  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != NULL)
    {
      if (! bfd_set_section_flags (abfd, s, flags))
	return false;
    }

  /* We need to create .got section.  */
  if (! mips_elf64_create_got_section (abfd, info))
    return false;

  /* Create the .msym section on IRIX6.  It is used by the dynamic
     linker to speed up dynamic relocations, and to avoid computing
     the ELF hash for symbols.  */
  if (!mips_elf64_create_msym_section (abfd))
    return false;

  /* Create .stub section.  */
  if (bfd_get_section_by_name (abfd, ".MIPS.stubs") == NULL)
    {
      s = bfd_make_section (abfd, ".MIPS.stubs");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_CODE)
	  || ! bfd_set_section_alignment (abfd, s, 3))
	return false;
    }

  return true;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

boolean
mips_elf64_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
{
  bfd *dynobj;
  struct mips_elf64_link_hash_entry *hmips;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

  /* If this symbol is defined in a dynamic object, we need to copy
     any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output
     file.  */
  hmips = (struct mips_elf64_link_hash_entry *) h;
  if (! info->relocateable
      && hmips->possibly_dynamic_relocs != 0
      && (h->root.type == bfd_link_hash_defweak
	  || (h->elf_link_hash_flags
	      & ELF_LINK_HASH_DEF_REGULAR) == 0))
    {
      mips_elf64_allocate_dynamic_relocations (dynobj,
					       hmips->possibly_dynamic_relocs);
      if (hmips->readonly_reloc)
	/* We tell the dynamic linker that there are relocations
	   against the text segment.  */
	info->flags |= DF_TEXTREL;
    }

  /* For a function, create a stub, if allowed.  */
  if (! hmips->no_fn_stub
      && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      if (! elf_hash_table (info)->dynamic_sections_created)
	return true;

      /* If this symbol is not defined in a regular file, then set
	 the symbol to the stub location.  This is required to make
	 function pointers compare as equal between the normal
	 executable and the shared library.  */
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* We need .stub section.  */
	  s = bfd_get_section_by_name (dynobj, ".MIPS.stubs");
	  BFD_ASSERT (s != NULL);

	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;

	  /* XXX Write this stub address somewhere.  */
	  h->plt.offset = s->_raw_size;

	  /* Make room for this stub code.  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;

	  /* The last half word of the stub will be filled with the index
	     of this symbol in .dynsym section.  */
	  return true;
	}
    }
  else if ((h->type == STT_FUNC)
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) == 0)
    {
      /* This will set the entry for this symbol in the GOT to 0, and
         the dynamic linker will take care of this.  */
      h->root.u.def.value = 0;
      return true;
    }

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->weakdef != NULL)
    {
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
      return true;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  return true;
}

/* This function is called after all the input files have been read,
   and the input sections have been assigned to output sections.  */

boolean
mips_elf64_always_size_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
{
  if (info->relocateable
      || ! mips_elf64_hash_table (info)->mips16_stubs_seen)
    return true;

  mips_elf64_link_hash_traverse (mips_elf64_hash_table (info),
				 mips_elf64_check_mips16_stubs,
				 (PTR) NULL);

  return true;
}

/* Check the mips16 stubs for a particular symbol, and see if we can
   discard them.  */

static boolean
mips_elf64_check_mips16_stubs (h, data)
     struct mips_elf64_link_hash_entry *h;
     PTR data ATTRIBUTE_UNUSED;
{
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

  if (h->fn_stub != NULL
      && ! h->need_fn_stub)
    {
      /* We don't need the fn_stub; the only references to this symbol
         are 16 bit calls.  Clobber the size to 0 to prevent it from
         being included in the link.  */
      h->fn_stub->_raw_size = 0;
      h->fn_stub->_cooked_size = 0;
      h->fn_stub->flags &= ~SEC_RELOC;
      h->fn_stub->reloc_count = 0;
      h->fn_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_stub->_raw_size = 0;
      h->call_stub->_cooked_size = 0;
      h->call_stub->flags &= ~SEC_RELOC;
      h->call_stub->reloc_count = 0;
      h->call_stub->flags |= SEC_EXCLUDE;
    }

  if (h->call_fp_stub != NULL
      && h->root.other == STO_MIPS16)
    {
      /* We don't need the call_stub; this is a 16 bit function, so
         calls from other 16 bit functions are OK.  Clobber the size
         to 0 to prevent it from being included in the link.  */
      h->call_fp_stub->_raw_size = 0;
      h->call_fp_stub->_cooked_size = 0;
      h->call_fp_stub->flags &= ~SEC_RELOC;
      h->call_fp_stub->reloc_count = 0;
      h->call_fp_stub->flags |= SEC_EXCLUDE;
    }

  return true;
}

/* Set the sizes of the dynamic sections.  */

boolean
mips_elf64_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *s;
  boolean reltext;
  struct mips_elf64_got_info *g = NULL;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (! info->shared)
	{
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->_raw_size = strlen ("/usr/lib64/libc.so.1") + 1;
	  s->contents = (bfd_byte *) "/usr/lib64/libc.so.1";
	}
    }

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  reltext = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      strip = false;

      if (strncmp (name, ".rel", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* We only strip the section if the output section name
                 has the same name.  Otherwise, there might be several
                 input sections for this output section.  FIXME: This
                 code is probably not needed these days anyhow, since
                 the linker now does not create empty output sections.  */
	      if (s->output_section != NULL
		  && strcmp (name,
			     bfd_get_section_name (s->output_section->owner,
						   s->output_section)) == 0)
		strip = true;
	    }
	  else
	    {
	      const char *outname;
	      asection *target;

	      /* If this relocation section applies to a read only
                 section, then we probably need a DT_TEXTREL entry.
                 If the relocation section is .rel.dyn, we always
                 assert a DT_TEXTREL entry rather than testing whether
                 there exists a relocation to a read only section or
                 not.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 4);
	      if ((target != NULL
		   && (target->flags & SEC_READONLY) != 0
		   && (target->flags & SEC_ALLOC) != 0)
		  || strcmp (outname, "rel.dyn") == 0)
		reltext = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      if (strcmp (name, "rel.dyn") != 0)
		s->reloc_count = 0;
	    }
	}
      else if (strncmp (name, ".got", 4) == 0)
	{
	  int i;
	  bfd_size_type loadable_size = 0;
	  bfd_size_type local_gotno;
	  bfd *sub;

	  BFD_ASSERT (elf_section_data (s) != NULL);
	  g = (struct mips_elf64_got_info *) elf_section_data (s)->tdata;
	  BFD_ASSERT (g != NULL);

	  /* Calculate the total loadable size of the output.  That
	     will give us the maximum number of GOT_PAGE entries
	     required.  */
	  for (sub = info->input_bfds; sub; sub = sub->link_next)
	    {
	      asection *subsection;

	      for (subsection = sub->sections;
		   subsection;
		   subsection = subsection->next)
		{
		  if ((subsection->flags & SEC_ALLOC) == 0)
		    continue;
		  loadable_size += (subsection->_raw_size + 0xf) & ~0xf;
		}
	    }
	  loadable_size += MIPS_FUNCTION_STUB_SIZE;

	  /* Assume there are two loadable segments consisting of
	     contiguous sections.  Is 5 enough?  */
	  local_gotno = (loadable_size >> 16) + 5;
	    /* It's possible we will need GOT_PAGE entries as well as
	       GOT16 entries.  Often, these will be able to share GOT
	       entries, but not always.  */
	    local_gotno *= 2;

	  g->local_gotno += local_gotno;
	  s->_raw_size += local_gotno * 8;

	  /* There has to be a global GOT entry for every symbol with
	     a dynamic symbol table index of DT_MIPS_GOTSYM or
	     higher.  Therefore, it make sense to put those symbols
	     that need GOT entries at the end of the symbol table.  We
	     do that here.  */
 	  if (!mips_elf64_sort_hash_table (info, 1))
 	    return false;

	  if (g->global_gotsym != NULL)
	    i = elf_hash_table (info)->dynsymcount - g->global_gotsym->dynindx;
	  else
	    /* If there are no global symbols, or none requiring
	       relocations, then GLOBAL_GOTSYM will be NULL.  */
	    i = 0;
	  g->global_gotno = i;
	  s->_raw_size += i * 8;
	}
      else if (strcmp (name, ".MIPS.stubs") == 0)
	{
	  /* Irix rld assumes that the function stub isn't at the end
	     of .text section. So put a dummy. XXX  */
	  s->_raw_size += MIPS_FUNCTION_STUB_SIZE;
	}
      else if (strcmp (name, ".msym")
	       == 0)
	s->_raw_size = (sizeof (Elf32_External_Msym)
			* (elf_hash_table (info)->dynsymcount
			   + bfd_count_sections (output_bfd)));
      else if (strncmp (name, ".init", 5) != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (strip)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return false;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_mips_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  /* SGI object has the equivalence of DT_DEBUG in the
	     DT_MIPS_RLD_MAP entry.  */
	  if (!bfd_elf64_add_dynamic_entry (info, DT_MIPS_RLD_MAP, 0))
	    return false;
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
		return false;
	    }
	}
      else
	{
	  /* Shared libraries on traditional mips have DT_DEBUG.  */
	  if (!SGI_COMPAT (output_bfd))
	    {
	      if (!bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
		return false;
	    }
	}

      if (reltext && SGI_COMPAT (output_bfd))
	info->flags |= DF_TEXTREL;

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
	    return false;
	}

      if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0))
	return false;

      if (bfd_get_section_by_name (dynobj, "rel.dyn"))
	{
	  if (! bfd_elf64_add_dynamic_entry (info, DT_REL, 0))
	    return false;

	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELSZ, 0))
	    return false;

	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELENT, 0))
	    return false;
	}

      if (SGI_COMPAT (output_bfd))
	{
	  if (!bfd_elf64_add_dynamic_entry (info, DT_MIPS_CONFLICTNO, 0))
	    return false;
	}

      if (SGI_COMPAT (output_bfd))
	{
	  if (!bfd_elf64_add_dynamic_entry (info, DT_MIPS_LIBLISTNO, 0))
	    return false;
	}

      if (bfd_get_section_by_name (dynobj, ".conflict") != NULL)
	{
	  if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_CONFLICT, 0))
	    return false;

	  s = bfd_get_section_by_name (dynobj, ".liblist");
	  BFD_ASSERT (s != NULL);

	  if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_LIBLIST, 0))
	    return false;
	}

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_RLD_VERSION, 0))
	return false;

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_FLAGS, 0))
	return false;

#if 0
      /* Time stamps in executable files are a bad idea.  */
      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0))
	return false;
#endif

#if 0 /* FIXME  */
      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_IVERSION, 0))
	return false;
#endif

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_BASE_ADDRESS, 0))
	return false;

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_LOCAL_GOTNO, 0))
	return false;

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_SYMTABNO, 0))
	return false;

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_UNREFEXTNO, 0))
	return false;

      if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_GOTSYM, 0))
	return false;

      if ((bfd_get_section_by_name(dynobj, ".MIPS.options"))
	  && !bfd_elf64_add_dynamic_entry (info, DT_MIPS_OPTIONS, 0))
	return false;

      if (bfd_get_section_by_name (dynobj, ".msym")
	  && !bfd_elf64_add_dynamic_entry (info, DT_MIPS_MSYM, 0))
	return false;
    }

  return true;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

boolean
mips_elf64_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  bfd *dynobj;
  bfd_vma gval;
  asection *sgot;
  asection *smsym;
  struct mips_elf64_got_info *g;
  const char *name;
  struct mips_elf64_link_hash_entry *mh;

  dynobj = elf_hash_table (info)->dynobj;
  gval = sym->st_value;
  mh = (struct mips_elf64_link_hash_entry *) h;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *s;
      bfd_byte stub[MIPS_FUNCTION_STUB_SIZE];

      /* This symbol has a stub.  Set it up.  */

      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (dynobj, ".MIPS.stubs");
      BFD_ASSERT (s != NULL);

      /* FIXME: Can h->dynindex be more than 64K?  */
      if (h->dynindx & 0xffff0000)
	return false;

      /* Fill the stub.  */
      bfd_put_32 (output_bfd, STUB_LW, stub);
      bfd_put_32 (output_bfd, STUB_MOVE, stub + 4);
      bfd_put_32 (output_bfd, STUB_JALR, stub + 8);
      bfd_put_32 (output_bfd, STUB_LI16 + h->dynindx, stub + 12);

      BFD_ASSERT (h->plt.offset <= s->_raw_size);
      memcpy (s->contents + h->plt.offset, stub, MIPS_FUNCTION_STUB_SIZE);

      /* Mark the symbol as undefined.  plt.offset != -1 occurs
	 only for the referenced symbol.  */
      sym->st_shndx = SHN_UNDEF;

      /* The run-time linker uses the st_value field of the symbol
	 to reset the global offset table entry for this external
	 to its stub address when unlinking a shared object.  */
      gval = s->output_section->vma + s->output_offset + h->plt.offset;
      sym->st_value = gval;
    }

  BFD_ASSERT (h->dynindx != -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0);

  sgot = bfd_get_section_by_name (dynobj, ".got");
  BFD_ASSERT (sgot != NULL);
  BFD_ASSERT (elf_section_data (sgot) != NULL);
  g = (struct mips_elf64_got_info *) elf_section_data (sgot)->tdata;
  BFD_ASSERT (g != NULL);

  /* Run through the global symbol table, creating GOT entries for all
     the symbols that need them.  */
  if (g->global_gotsym != NULL
      && h->dynindx >= g->global_gotsym->dynindx)
    {
      bfd_vma offset;
      bfd_vma value;

      if (sym->st_value)
	value = sym->st_value;
      else
	{
	  /* For an entity defined in a shared object, this will be
	     NULL.  (For functions in shared objects for
	     which we have created stubs, ST_VALUE will be non-NULL.
	     That's because such the functions are now no longer defined
	     in a shared object.)  */

	  if (info->shared && h->root.type == bfd_link_hash_undefined)
	    value = 0;
	  else
	    value = h->root.u.def.value;
	}
      offset = mips_elf64_global_got_index (dynobj, h);
      bfd_put_64 (output_bfd, value, sgot->contents + offset);
    }

  /* Create a .msym entry, if appropriate.  */
  smsym = bfd_get_section_by_name (dynobj, ".msym");
  if (smsym)
    {
      Elf32_Internal_Msym msym;

      msym.ms_hash_value = bfd_elf_hash (h->root.root.string);
      /* It is undocumented what the `1' indicates, but IRIX6 uses
	 this value.  */
      msym.ms_info = ELF32_MS_INFO (mh->min_dyn_reloc_index, 1);
      mips_elf64_swap_msym_out
	(dynobj, &msym,
	 ((Elf32_External_Msym *) smsym->contents) + h->dynindx);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  name = h->root.root.string;
  if (strcmp (name, "_DYNAMIC") == 0
      || strcmp (name, "_GLOBAL_OFFSET_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;
  else if (strcmp (name, "_DYNAMIC_LINK") == 0
	   || strcmp (name, "_DYNAMIC_LINKING") == 0)
    {
      sym->st_shndx = SHN_ABS;
      sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);
      sym->st_value = 1;
    }
  else if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS)
    {
      if (h->type == STT_FUNC)
	sym->st_shndx = SHN_MIPS_TEXT;
      else if (h->type == STT_OBJECT)
	sym->st_shndx = SHN_MIPS_DATA;
    }

  /* Handle the IRIX6-specific symbols.  */

    {
  /* The linker script takes care of providing names and values for
     these, but we must place them into the right sections.  */
  static const char* const text_section_symbols[] = {
    "_ftext",
    "_etext",
    "__dso_displacement",
    "__elf_header",
    "__program_header_table",
    NULL
  };

  static const char* const data_section_symbols[] = {
    "_fdata",
    "_edata",
    "_end",
    "_fbss",
    NULL
  };

  const char* const *p;
  int i;

  for (i = 0; i < 2; ++i)
    for (p = (i == 0) ? text_section_symbols : data_section_symbols;
	 *p;
	 ++p)
      if (strcmp (*p, name) == 0)
	{
	  /* All of these symbols are given type STT_SECTION by the
	     IRIX6 linker.  */
	  sym->st_info = ELF_ST_INFO (STB_GLOBAL, STT_SECTION);

	  /* The IRIX linker puts these symbols in special sections.  */
	  if (i == 0)
	    sym->st_shndx = SHN_MIPS_TEXT;
	  else
	    sym->st_shndx = SHN_MIPS_DATA;

	  break;
	}
    }

  return true;
}

/* Finish up the dynamic sections.  */

boolean
mips_elf64_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
{
  bfd *dynobj;
  asection *sdyn;
  asection *sgot;
  struct mips_elf64_got_info *g;

  dynobj = elf_hash_table (info)->dynobj;

  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");

  sgot = bfd_get_section_by_name (dynobj, ".got");
  if (sgot == NULL)
    g = NULL;
  else
    {
      BFD_ASSERT (elf_section_data (sgot) != NULL);
      g = (struct mips_elf64_got_info *) elf_section_data (sgot)->tdata;
      BFD_ASSERT (g != NULL);
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd_byte *b;

      BFD_ASSERT (sdyn != NULL);
      BFD_ASSERT (g != NULL);

      for (b = sdyn->contents;
	   b < sdyn->contents + sdyn->_raw_size;
	   b += get_elf_backend_data (dynobj)->s->sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  size_t elemsize;
	  asection *s;
	  boolean swap_out_p;

	  /* Read in the current dynamic entry.  */
	  (*get_elf_backend_data (dynobj)->s->swap_dyn_in) (dynobj, b, &dyn);

	  /* Assume that we're going to modify it and write it out.  */
	  swap_out_p = true;

	  switch (dyn.d_tag)
	    {
	    case DT_RELENT:
	      s = bfd_get_section_by_name(dynobj, "rel.dyn");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = get_elf_backend_data (dynobj)->s->sizeof_rel;
	      break;

	    case DT_STRSZ:
	      /* Rewrite DT_STRSZ.  */
	      dyn.d_un.d_val =
		_bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_MIPS_CONFLICT:
	      name = ".conflict";
	      goto get_vma;
	    case DT_MIPS_LIBLIST:
	      name = ".liblist";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_RLD_VERSION:
	      dyn.d_un.d_val = 1; /* XXX */
	      break;

	    case DT_MIPS_FLAGS:
	      dyn.d_un.d_val = RHF_NOTPOT; /* XXX */
	      break;

	    case DT_MIPS_CONFLICTNO:
	      name = ".conflict";
	      elemsize = sizeof (Elf32_Conflict);
	      goto set_elemno;

	    case DT_MIPS_LIBLISTNO:
	      name = ".liblist";
	      elemsize = sizeof (Elf32_Lib);
	    set_elemno:
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s != NULL)
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val = s->_cooked_size / elemsize;
		  else
		    dyn.d_un.d_val = s->_raw_size / elemsize;
		}
	      else
		dyn.d_un.d_val = 0;
	      break;

	    case DT_MIPS_TIME_STAMP:
	      time ((time_t *) &dyn.d_un.d_val);
	      break;

	    case DT_MIPS_ICHECKSUM:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;

	    case DT_MIPS_IVERSION:
	      /* XXX FIXME: */
	      swap_out_p = false;
	      break;

	    case DT_MIPS_BASE_ADDRESS:
	      s = output_bfd->sections;
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma & ~(0xffff);
	      break;

	    case DT_MIPS_LOCAL_GOTNO:
	      dyn.d_un.d_val = g->local_gotno;
	      break;

	    case DT_MIPS_UNREFEXTNO:
	      /* The index into the dynamic symbol table which is the
		 entry of the first external symbol that is not
		 referenced within the same object.  */
	      dyn.d_un.d_val = bfd_count_sections (output_bfd) + 1;
	      break;

	    case DT_MIPS_GOTSYM:
	      if (g->global_gotsym)
		{
		  dyn.d_un.d_val = g->global_gotsym->dynindx;
		  break;
		}
	      /* In case if we don't have global got symbols we default
		 to setting DT_MIPS_GOTSYM to the same value as
		 DT_MIPS_SYMTABNO, so we just fall through.  */

	    case DT_MIPS_SYMTABNO:
	      name = ".dynsym";
	      elemsize = get_elf_backend_data (output_bfd)->s->sizeof_sym;
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);

	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size / elemsize;
	      else
		dyn.d_un.d_val = s->_raw_size / elemsize;
	      break;

	    case DT_MIPS_HIPAGENO:
	      dyn.d_un.d_val = g->local_gotno - MIPS_RESERVED_GOTNO;
	      break;

	    case DT_MIPS_OPTIONS:
	      s = bfd_get_section_by_name(output_bfd, ".MIPS.options");
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    case DT_MIPS_MSYM:
	      s = bfd_get_section_by_name(output_bfd, ".msym");
	      dyn.d_un.d_ptr = s->vma;
	      break;

	    default:
	      swap_out_p = false;
	      break;
	    }

	  if (swap_out_p)
	    (*get_elf_backend_data (dynobj)->s->swap_dyn_out)
	      (dynobj, &dyn, b);
	}
    }

  /* The first entry of the global offset table will be filled at
     runtime. The second entry will be used by some runtime loaders.
     This isn't the case of Irix rld.  */
  if (sgot != NULL && sgot->_raw_size > 0)
    {
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents);
      bfd_put_64 (output_bfd, (bfd_vma) 0x80000000, sgot->contents + 8);
    }

  if (sgot != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 8;

  {
    asection *smsym;
    asection *s;

    /* ??? The section symbols for the output sections were set up in
       _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these
       symbols.  Should we do so?  */

    smsym = bfd_get_section_by_name (dynobj, ".msym");
    if (smsym != NULL)
      {
	Elf32_Internal_Msym msym;

	msym.ms_hash_value = 0;
	msym.ms_info = ELF32_MS_INFO (0, 1);

	for (s = output_bfd->sections; s != NULL; s = s->next)
	  {
	    long dynindx = elf_section_data (s)->dynindx;

	    mips_elf64_swap_msym_out
	      (output_bfd, &msym,
	       (((Elf32_External_Msym *) smsym->contents)
		+ dynindx));
	  }
      }

    /* Clean up a first relocation in .rel.dyn.  */
    s = bfd_get_section_by_name (dynobj, "rel.dyn");
    if (s != NULL && s->_raw_size > 0)
      memset (s->contents, 0, get_elf_backend_data (dynobj)->s->sizeof_rel);
  }

  return true;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

asection *
mips_elf64_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
{
  if (h != NULL)
    {
      switch (ELF64_R_TYPE (rel->r_info))
	{
	case R_MIPS_GNU_VTINHERIT:
	case R_MIPS_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

boolean
mips_elf64_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
{
#if 0
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    switch (ELF64_R_TYPE (rel->r_info))
      {
      case R_MIPS_GOT16:
      case R_MIPS_CALL16:
      case R_MIPS_CALL_HI16:
      case R_MIPS_CALL_LO16:
      case R_MIPS_GOT_HI16:
      case R_MIPS_GOT_LO16:
	/* ??? It would seem that the existing MIPS code does no sort
	   of reference counting or whatnot on its GOT and PLT entries,
	   so it is not possible to garbage collect them at this time.  */
	break;

      default:
	break;
      }
#endif

  return true;
}

/* Create the .got section to hold the global offset table. */

static boolean
mips_elf64_create_got_section (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  flagword flags;
  register asection *s;
  struct elf_link_hash_entry *h;
  struct mips_elf64_got_info *g;

  /* This function may be called more than once.  */
  if (bfd_get_section_by_name (abfd, ".got"))
    return true;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);

  s = bfd_make_section (abfd, ".got");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, flags)
      || ! bfd_set_section_alignment (abfd, s, 4))
    return false;

  /* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the
     linker script because we don't want to define the symbol if we
     are not creating a global offset table.  */
  h = NULL;
  if (! (_bfd_generic_link_add_one_symbol
	 (info, abfd, "_GLOBAL_OFFSET_TABLE_", BSF_GLOBAL, s,
	  (bfd_vma) 0, (const char *) NULL, false,
	  get_elf_backend_data (abfd)->collect,
	  (struct bfd_link_hash_entry **) &h)))
    return false;
  h->elf_link_hash_flags &=~ ELF_LINK_NON_ELF;
  h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
  h->type = STT_OBJECT;

  if (info->shared
      && ! bfd_elf64_link_record_dynamic_symbol (info, h))
    return false;

  /* The first several global offset table entries are reserved.  */
  s->_raw_size = MIPS_RESERVED_GOTNO * (get_elf_backend_data (abfd)->s->arch_size / 8);

  g = (struct mips_elf64_got_info *) bfd_alloc (abfd,
					  sizeof (struct mips_elf64_got_info));
  if (g == NULL)
    return false;
  g->global_gotsym = NULL;
  g->local_gotno = MIPS_RESERVED_GOTNO;
  g->assigned_gotno = MIPS_RESERVED_GOTNO;
  if (elf_section_data (s) == NULL)
    {
      s->used_by_bfd =
	(PTR) bfd_zalloc (abfd, sizeof (struct bfd_elf_section_data));
      if (elf_section_data (s) == NULL)
	return false;
    }
  elf_section_data (s)->tdata = (PTR) g;
  elf_section_data (s)->this_hdr.sh_flags 
    |= SHF_ALLOC | SHF_WRITE | SHF_MIPS_GPREL;

  return true;
}

/* If H is a symbol that needs a global GOT entry, but has a dynamic
   symbol table index lower than any we've seen to date, record it for
   posterity.  */

static boolean
mips_elf64_record_global_got_symbol (h, info, g)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
     struct mips_elf64_got_info *g ATTRIBUTE_UNUSED;
{
  /* A global symbol in the GOT must also be in the dynamic symbol
     table.  */
  if (h->dynindx == -1
      && !bfd_elf64_link_record_dynamic_symbol (info, h))
    return false;
  
  /* If we've already marked this entry as needing GOT space, we don't
     need to do it again.  */
  if (h->got.offset != (bfd_vma) - 1)
    return true;

  /* By setting this to a value other than -1, we are indicating that
     there needs to be a GOT entry for H.  Avoid using zero, as the
     generic ELF copy_indirect_symbol tests for <= 0.  */
  h->got.offset = 1;

  return true;
}

/* Returns the .msym section for ABFD, creating it if it does not
   already exist.  Returns NULL to indicate error.  */

static asection *
mips_elf64_create_msym_section (abfd)
     bfd *abfd;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, ".msym");
  if (!s)
    {
      s = bfd_make_section (abfd, ".msym");
      if (!s
	  || !bfd_set_section_flags (abfd, s,
				     SEC_ALLOC
				     | SEC_LOAD
				     | SEC_HAS_CONTENTS
				     | SEC_LINKER_CREATED
				     | SEC_READONLY)
	  || !bfd_set_section_alignment (abfd, s, 3))
	return NULL;
    }

  return s;
}

/* Add room for N relocations to the .rel.dyn section in ABFD.  */

static void
mips_elf64_allocate_dynamic_relocations (abfd, n)
     bfd *abfd;
     unsigned int n;
{
  asection *s;

  s = bfd_get_section_by_name (abfd, ".rel.dyn");
  BFD_ASSERT (s != NULL);
  
  if (s->_raw_size == 0)
    {
      /* Make room for a null element. */
      s->_raw_size += get_elf_backend_data (abfd)->s->sizeof_rel;
      ++s->reloc_count;
    }
  s->_raw_size += n * get_elf_backend_data (abfd)->s->sizeof_rel;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table.  */

boolean
mips_elf64_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
{
  const char *name;
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct mips_elf64_got_info *g;
  size_t extsymoff;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *sreloc;
  struct elf_backend_data *bed;

  if (info->relocateable)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  extsymoff = (elf_bad_symtab (abfd)) ? 0 : symtab_hdr->sh_info;

  /* Check for the mips16 stub sections.  */

  name = bfd_get_section_name (abfd, sec);
  if (strncmp (name, FN_STUB, sizeof FN_STUB - 1) == 0)
    {
      unsigned long r_symndx;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF64_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  asection *o;

	  /* This stub is for a local symbol.  This stub will only be
             needed if there is some relocation in this BFD, other
             than a 16 bit function call, which refers to this symbol.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      Elf_Internal_Rela *sec_relocs;
	      const Elf_Internal_Rela *r, *rend;

	      /* We can ignore stub sections when looking for relocs.  */
	      if ((o->flags & SEC_RELOC) == 0
		  || o->reloc_count == 0
		  || strncmp (bfd_get_section_name (abfd, o), FN_STUB,
			      sizeof FN_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_STUB,
			      sizeof CALL_STUB - 1) == 0
		  || strncmp (bfd_get_section_name (abfd, o), CALL_FP_STUB,
			      sizeof CALL_FP_STUB - 1) == 0)
		continue;

	      sec_relocs = (_bfd_elf64_link_read_relocs
			    (abfd, o, (PTR) NULL,
			     (Elf_Internal_Rela *) NULL,
			     info->keep_memory));
	      if (sec_relocs == NULL)
		return false;

	      rend = sec_relocs + o->reloc_count;
	      for (r = sec_relocs; r < rend; r++)
		if (ELF64_R_SYM (r->r_info) == r_symndx
		    && ELF64_R_TYPE (r->r_info) != R_MIPS16_26)
		  break;

	      if (! info->keep_memory)
		free (sec_relocs);

	      if (r < rend)
		break;
	    }

	  if (o == NULL)
	    {
	      /* There is no non-call reloc for this stub, so we do
                 not need it.  Since this function is called before
                 the linker maps input sections to output sections, we
                 can easily discard it by setting the SEC_EXCLUDE
                 flag.  */
	      sec->flags |= SEC_EXCLUDE;
	      return true;
	    }

	  /* Record this stub in an array of local symbol stubs for
             this BFD.  */
	  if (elf_tdata (abfd)->local_stubs == NULL)
	    {
	      unsigned long symcount;
	      asection **n;
	      bfd_size_type amt;

	      if (elf_bad_symtab (abfd))
		symcount = NUM_SHDR_ENTRIES (symtab_hdr);
	      else
		symcount = symtab_hdr->sh_info;
	      amt = symcount * sizeof (asection *);
	      n = (asection **) bfd_zalloc (abfd, amt);
	      if (n == NULL)
		return false;
	      elf_tdata (abfd)->local_stubs = n;
	    }

	  elf_tdata (abfd)->local_stubs[r_symndx] = sec;

	  /* We don't need to set mips16_stubs_seen in this case.
             That flag is used to see whether we need to look through
             the global symbol table for stubs.  We don't need to set
             it here, because we just have a local stub.  */
	}
      else
	{
	  struct mips_elf64_link_hash_entry *h;

	  h = ((struct mips_elf64_link_hash_entry *)
	       sym_hashes[r_symndx - extsymoff]);

	  /* H is the symbol this stub is for.  */

	  h->fn_stub = sec;
	  mips_elf64_hash_table (info)->mips16_stubs_seen = true;
	}
    }
  else if (strncmp (name, CALL_STUB, sizeof CALL_STUB - 1) == 0
	   || strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
    {
      unsigned long r_symndx;
      struct mips_elf64_link_hash_entry *h;
      asection **loc;

      /* Look at the relocation information to figure out which symbol
         this is for.  */

      r_symndx = ELF64_R_SYM (relocs->r_info);

      if (r_symndx < extsymoff
	  || sym_hashes[r_symndx - extsymoff] == NULL)
	{
	  /* This stub was actually built for a static symbol defined
	     in the same file.  We assume that all static symbols in
	     mips16 code are themselves mips16, so we can simply
	     discard this stub.  Since this function is called before
	     the linker maps input sections to output sections, we can
	     easily discard it by setting the SEC_EXCLUDE flag.  */
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      h = ((struct mips_elf64_link_hash_entry *)
	   sym_hashes[r_symndx - extsymoff]);

      /* H is the symbol this stub is for.  */

      if (strncmp (name, CALL_FP_STUB, sizeof CALL_FP_STUB - 1) == 0)
	loc = &h->call_fp_stub;
      else
	loc = &h->call_stub;

      /* If we already have an appropriate stub for this function, we
	 don't need another one, so we can discard this one.  Since
	 this function is called before the linker maps input sections
	 to output sections, we can easily discard it by setting the
	 SEC_EXCLUDE flag.  We can also discard this section if we
	 happen to already know that this is a mips16 function; it is
	 not necessary to check this here, as it is checked later, but
	 it is slightly faster to check now.  */
      if (*loc != NULL || h->root.other == STO_MIPS16)
	{
	  sec->flags |= SEC_EXCLUDE;
	  return true;
	}

      *loc = sec;
      mips_elf64_hash_table (info)->mips16_stubs_seen = true;
    }

  if (dynobj == NULL)
    {
      sgot = NULL;
      g = NULL;
    }
  else
    {
      sgot = bfd_get_section_by_name (dynobj, ".got");
      if (sgot == NULL)
	g = NULL;
      else
	{
	  BFD_ASSERT (elf_section_data (sgot) != NULL);
	  g = (struct mips_elf64_got_info *) elf_section_data (sgot)->tdata;
	  BFD_ASSERT (g != NULL);
	}
    }

  sreloc = NULL;
  bed = get_elf_backend_data (abfd);
  rel_end = relocs + sec->reloc_count * bed->s->int_rels_per_ext_rel;
  for (rel = relocs; rel < rel_end; ++rel)
    {
      unsigned long r_symndx;
      int r_type;
      struct elf_link_hash_entry *h;

      r_symndx = ELF64_R_SYM (rel->r_info);
      r_type = ELF64_MIPS_R_TYPE (rel->r_info);

      if (r_symndx < extsymoff)
	h = NULL;
      else if (r_symndx >= extsymoff + NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler)
	    (_("%s: Malformed reloc detected for section %s"),
	     bfd_archive_filename (abfd), name);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	}
      else
	{
	  h = sym_hashes[r_symndx - extsymoff];

	  /* This may be an indirect symbol created because of a version.  */
	  if (h != NULL)
	    {
	      while (h->root.type == bfd_link_hash_indirect)
		h = (struct elf_link_hash_entry *) h->root.u.i.link;
	    }
	}

      /* Some relocs require a global offset table.  */
      if (dynobj == NULL || sgot == NULL)
	{
	  switch (r_type)
	    {
	    case R_MIPS_GOT16:
	    case R_MIPS_CALL16:
	    case R_MIPS_CALL_HI16:
	    case R_MIPS_CALL_LO16:
	    case R_MIPS_GOT_HI16:
	    case R_MIPS_GOT_LO16:
	    case R_MIPS_GOT_PAGE:
	    case R_MIPS_GOT_OFST:
	    case R_MIPS_GOT_DISP:
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! mips_elf64_create_got_section (dynobj, info))
		return false;
	      g = _mips_elf64_got_info (dynobj, &sgot);
	      break;

	    case R_MIPS_32:
	    case R_MIPS_REL32:
	    case R_MIPS_64:
	      if (dynobj == NULL
		  && (info->shared || h != NULL)
		  && (sec->flags & SEC_ALLOC) != 0)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      break;

	    default:
	      break;
	    }
	}

      if (!h && (r_type == R_MIPS_CALL_LO16
		 || r_type == R_MIPS_GOT_LO16
		 || r_type == R_MIPS_GOT_DISP))
	{
	  /* We may need a local GOT entry for this relocation.  We
	     don't count R_MIPS_GOT_PAGE because we can estimate the
	     maximum number of pages needed by looking at the size of
	     the segment.  Similar comments apply to R_MIPS_GOT16 and
	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or
	     R_MIPS_CALL_HI16 because these are always followed by an
	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.

	     This estimation is very conservative since we can merge
	     duplicate entries in the GOT.  In order to be less
	     conservative, we could actually build the GOT here,
	     rather than in relocate_section.  */
	  g->local_gotno++;
	  sgot->_raw_size += get_elf_backend_data (dynobj)->s->arch_size / 8;
	}

      switch (r_type)
	{
	case R_MIPS_CALL16:
	  if (h == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%s: CALL16 reloc at 0x%lx not against global symbol"),
		 bfd_archive_filename (abfd), (unsigned long) rel->r_offset);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  /* Fall through.  */

	case R_MIPS_CALL_HI16:
	case R_MIPS_CALL_LO16:
	  if (h != NULL)
	    {
	      /* This symbol requires a global offset table entry.  */
	      if (!mips_elf64_record_global_got_symbol (h, info, g))
		return false;

	      /* We need a stub, not a plt entry for the undefined
		 function.  But we record it as if it needs plt.  See
		 elf_adjust_dynamic_symbol in elflink.h.  */
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->type = STT_FUNC;
	    }
	  break;

	case R_MIPS_GOT16:
	case R_MIPS_GOT_HI16:
	case R_MIPS_GOT_LO16:
	case R_MIPS_GOT_DISP:
	  /* This symbol requires a global offset table entry.  */
	  if (h && !mips_elf64_record_global_got_symbol (h, info, g))
	    return false;
	  break;

	case R_MIPS_32:
	case R_MIPS_REL32:
	case R_MIPS_64:
	  if ((info->shared || h != NULL)
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      if (sreloc == NULL)
		{
		  const char *name = ".rel.dyn";

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section (dynobj, name);
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (dynobj, sreloc,
						      (SEC_ALLOC
						       | SEC_LOAD
						       | SEC_HAS_CONTENTS
						       | SEC_IN_MEMORY
						       | SEC_LINKER_CREATED
						       | SEC_READONLY))
			  || ! bfd_set_section_alignment (dynobj, sreloc,
							  4))
			return false;
		    }
		}
#define MIPS_READONLY_SECTION (SEC_ALLOC | SEC_LOAD | SEC_READONLY)
	      if (info->shared)
		{
		  /* When creating a shared object, we must copy these
		     reloc types into the output file as R_MIPS_REL32
		     relocs.  We make room for this reloc in the
		     .rel.dyn reloc section.  */
		  mips_elf64_allocate_dynamic_relocations (dynobj, 1);
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We tell the dynamic linker that there are
		       relocations against the text segment.  */
		    info->flags |= DF_TEXTREL;
		}
	      else
		{
		  struct mips_elf64_link_hash_entry *hmips;

		  /* We only need to copy this reloc if the symbol is
                     defined in a dynamic object.  */
		  hmips = (struct mips_elf64_link_hash_entry *) h;
		  ++hmips->possibly_dynamic_relocs;
		  if ((sec->flags & MIPS_READONLY_SECTION)
		      == MIPS_READONLY_SECTION)
		    /* We need it to tell the dynamic linker if there
		       are relocations against the text segment.  */
		    hmips->readonly_reloc = true;
		}
	     
	      /* Even though we don't directly need a GOT entry for
		 this symbol, a symbol must have a dynamic symbol
		 table index greater that DT_MIPS_GOTSYM if there are
		 dynamic relocations against it.  */
	      if (h != NULL
		  && !mips_elf64_record_global_got_symbol (h, info, g))
		return false;
	    }
	  break;

	case R_MIPS_26:
	case R_MIPS_GPREL16:
	case R_MIPS_LITERAL:
	case R_MIPS_GPREL32:
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_MIPS_GNU_VTINHERIT:
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_MIPS_GNU_VTENTRY:
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_offset))
	    return false;
	  break;

	default:
	  break;
	}
    }

  return true;
}

/* Structure used to pass information to mips_elf64_output_extsym.  */

struct extsym_info
{
  bfd *abfd;
  struct bfd_link_info *info;
  struct ecoff_debug_info *debug;
  const struct ecoff_debug_swap *swap;
  boolean failed;
};

/* This routine is used to write out ECOFF debugging external symbol
   information.  It is called via mips_elf64_link_hash_traverse.  The
   ECOFF external symbol information must match the ELF external
   symbol information.  Unfortunately, at this point we don't know
   whether a symbol is required by reloc information, so the two
   tables may wind up being different.  We must sort out the external
   symbol information before we can set the final size of the .mdebug
   section, and we must set the size of the .mdebug section before we
   can relocate any sections, and we can't know which symbols are
   required by relocation until we relocate the sections.
   Fortunately, it is relatively unlikely that any symbol will be
   stripped but required by a reloc.  In particular, it can not happen
   when generating a final executable.  */

static boolean
mips_elf64_output_extsym (h, data)
     struct mips_elf64_link_hash_entry *h;
     PTR data;
{
  struct extsym_info *einfo = (struct extsym_info *) data;
  boolean strip;
  asection *sec, *output_section;

  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

  if (h->root.indx == -2)
    strip = false;
  else if (((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	    || (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) != 0)
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0
	   && (h->root.elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR) == 0)
    strip = true;
  else if (einfo->info->strip == strip_all
	   || (einfo->info->strip == strip_some
	       && bfd_hash_lookup (einfo->info->keep_hash,
				   h->root.root.root.string,
				   false, false) == NULL))
    strip = true;
  else
    strip = false;

  if (strip)
    return true;

  if (h->esym.ifd == -2)
    {
      h->esym.jmptbl = 0;
      h->esym.cobol_main = 0;
      h->esym.weakext = 0;
      h->esym.reserved = 0;
      h->esym.ifd = ifdNil;
      h->esym.asym.value = 0;
      h->esym.asym.st = stGlobal;

      if (h->root.root.type == bfd_link_hash_undefined
	      || h->root.root.type == bfd_link_hash_undefweak)
	{
	  const char *name;

	  /* Use undefined class.  Also, set class and type for some
             special symbols.  */
	  name = h->root.root.root.string;
	  h->esym.asym.sc = scUndefined;
	}
      else if (h->root.root.type != bfd_link_hash_defined
	  && h->root.root.type != bfd_link_hash_defweak)
	h->esym.asym.sc = scAbs;
      else
	{
	  const char *name;

	  sec = h->root.root.u.def.section;
	  output_section = sec->output_section;

	  /* When making a shared library and symbol h is the one from
	     the another shared library, OUTPUT_SECTION may be null.  */
	  if (output_section == NULL)
	    h->esym.asym.sc = scUndefined;
	  else
	    {
	      name = bfd_section_name (output_section->owner, output_section);

	      if (strcmp (name, ".text") == 0)
		h->esym.asym.sc = scText;
	      else if (strcmp (name, ".data") == 0)
		h->esym.asym.sc = scData;
	      else if (strcmp (name, ".sdata") == 0)
		h->esym.asym.sc = scSData;
	      else if (strcmp (name, ".rodata") == 0
		       || strcmp (name, ".rdata") == 0)
		h->esym.asym.sc = scRData;
	      else if (strcmp (name, ".bss") == 0)
		h->esym.asym.sc = scBss;
	      else if (strcmp (name, ".sbss") == 0)
		h->esym.asym.sc = scSBss;
	      else if (strcmp (name, ".init") == 0)
		h->esym.asym.sc = scInit;
	      else if (strcmp (name, ".fini") == 0)
		h->esym.asym.sc = scFini;
	      else
		h->esym.asym.sc = scAbs;
	    }
	}

      h->esym.asym.reserved = 0;
      h->esym.asym.index = indexNil;
    }

  if (h->root.root.type == bfd_link_hash_common)
    h->esym.asym.value = h->root.root.u.c.size;
  else if (h->root.root.type == bfd_link_hash_defined
	   || h->root.root.type == bfd_link_hash_defweak)
    {
      if (h->esym.asym.sc == scCommon)
	h->esym.asym.sc = scBss;
      else if (h->esym.asym.sc == scSCommon)
	h->esym.asym.sc = scSBss;

      sec = h->root.root.u.def.section;
      output_section = sec->output_section;
      if (output_section != NULL)
	h->esym.asym.value = (h->root.root.u.def.value
			      + sec->output_offset
			      + output_section->vma);
      else
	h->esym.asym.value = 0;
    }
  else if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
    {
      struct mips_elf64_link_hash_entry *hd = h;
      boolean no_fn_stub = h->no_fn_stub;

      while (hd->root.root.type == bfd_link_hash_indirect)
	{
	  hd = (struct mips_elf64_link_hash_entry *)h->root.root.u.i.link;
	  no_fn_stub = no_fn_stub || hd->no_fn_stub;
	}

      if (!no_fn_stub)
	{
	  /* Set type and value for a symbol with a function stub.  */
	  h->esym.asym.st = stProc;
	  sec = hd->root.root.u.def.section;
	  if (sec == NULL)
	    h->esym.asym.value = 0;
	  else
	    {
	      output_section = sec->output_section;
	      if (output_section != NULL)
		h->esym.asym.value = (hd->root.plt.offset
				      + sec->output_offset
				      + output_section->vma);
	      else
		h->esym.asym.value = 0;
	    }
#if 0 /* FIXME?  */
	  h->esym.ifd = 0;
#endif
	}
    }

  if (! bfd_ecoff_debug_one_external (einfo->abfd, einfo->debug, einfo->swap,
				      h->root.root.root.string,
				      &h->esym))
    {
      einfo->failed = true;
      return false;
    }

  return true;
}

/* Swap an entry in a .gptab section.  Note that these routines rely
   on the equivalence of the two elements of the union.  */

static void
mips_elf64_swap_gptab_in (abfd, ex, in)
     bfd *abfd;
     const Elf32_External_gptab *ex;
     Elf32_gptab *in;
{
  in->gt_entry.gt_g_value = H_GET_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = H_GET_32 (abfd, ex->gt_entry.gt_bytes);
}

static void
mips_elf64_swap_gptab_out (abfd, in, ex)
     bfd *abfd;
     const Elf32_gptab *in;
     Elf32_External_gptab *ex;
{
  H_PUT_32 (abfd, (bfd_vma) in->gt_entry.gt_g_value,
		ex->gt_entry.gt_g_value);
  H_PUT_32 (abfd, (bfd_vma) in->gt_entry.gt_bytes,
		ex->gt_entry.gt_bytes);
}

/* A comparison routine used to sort .gptab entries.  */

static int
gptab_compare (p1, p2)
     const PTR p1;
     const PTR p2;
{
  const Elf32_gptab *a1 = (const Elf32_gptab *) p1;
  const Elf32_gptab *a2 = (const Elf32_gptab *) p2;

  return a1->gt_entry.gt_g_value - a2->gt_entry.gt_g_value;
}

/* We need to use a special link routine to handle the .mdebug section.
   We need to merge all instances of this section together, not write
   them all out sequentially.  */

boolean
mips_elf64_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  asection **secpp;
  asection *o;
  struct bfd_link_order *p;
  asection *mdebug_sec, *gptab_data_sec, *gptab_bss_sec;
  struct ecoff_debug_info debug;
  const struct ecoff_debug_swap *swap
    = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;
  HDRR *symhdr = &debug.symbolic_header;
  PTR mdebug_handle = NULL;
  asection *s;
  EXTR esym;
  unsigned int i;
  static const char * const secname[] =
      { ".text", ".init", ".fini", ".data",
          ".rodata", ".sdata", ".sbss", ".bss" };
  static const int sc[] = { scText, scInit, scFini, scData,
                          scRData, scSData, scSBss, scBss };

  /* If all the things we linked together were PIC, but we're
     producing an executable (rather than a shared object), then the
     resulting file is CPIC (i.e., it calls PIC code.)  */
  if (!info->shared
      && !info->relocateable
      && elf_elfheader (abfd)->e_flags & EF_MIPS_PIC)
    {
      elf_elfheader (abfd)->e_flags &= ~EF_MIPS_PIC;
      elf_elfheader (abfd)->e_flags |= EF_MIPS_CPIC;
    }

  /* We'd carefully arranged the dynamic symbol indices, and then the
     generic size_dynamic_sections renumbered them out from under us.
     Rather than trying somehow to prevent the renumbering, just do
     the sort again.  */
  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *got;
      struct mips_elf64_got_info *g;

      /* When we resort, we must tell mips_elf64_sort_hash_table what
	 the lowest index it may use is.  That's the number of section
	 symbols we're going to add.  The generic ELF linker only
	 adds these symbols when building a shared object.  Note that
	 we count the sections after (possibly) removing the .options
	 section above.  */
      if (!mips_elf64_sort_hash_table (info, (info->shared 
					    ? bfd_count_sections (abfd) + 1
					    : 1)))
        return false;

      /* Make sure we didn't grow the global .got region.  */
      dynobj = elf_hash_table (info)->dynobj;
      got = bfd_get_section_by_name (dynobj, ".got");
      g = (struct mips_elf64_got_info *) elf_section_data (got)->tdata;

      if (g->global_gotsym != NULL)
	BFD_ASSERT ((elf_hash_table (info)->dynsymcount
		     - g->global_gotsym->dynindx)
		    <= g->global_gotno);
    }

  /* We include .MIPS.options, even though we don't process it quite right.
     (Some entries are supposed to be merged.)  At IRIX6 empirically we seem
     to be better off including it than not.  */
  for (secpp = &abfd->sections; *secpp != NULL; secpp = &(*secpp)->next)
    {
      if (strcmp ((*secpp)->name, ".MIPS.options") == 0)
	{
	  for (p = (*secpp)->link_order_head; p != NULL; p = p->next)
	    if (p->type == bfd_indirect_link_order)
	      p->u.indirect.section->flags &=~ SEC_HAS_CONTENTS;
	  (*secpp)->link_order_head = NULL;
	  bfd_section_list_remove (abfd, secpp);
	  --abfd->section_count;
	    
	  break;
	}
    }

  /* Get a value for the GP register.  */
  if (elf_gp (abfd) == 0)
    {
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (info->hash, "_gp", false, false, true);
      if (h != (struct bfd_link_hash_entry *) NULL
	  && h->type == bfd_link_hash_defined)
	elf_gp (abfd) = (h->u.def.value
			 + h->u.def.section->output_section->vma
			 + h->u.def.section->output_offset);
      else if (info->relocateable)
	{
	  bfd_vma lo = MINUS_ONE;

	  /* Find the GP-relative section with the lowest offset.  */
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if (o->vma < lo 
		&& (elf_section_data (o)->this_hdr.sh_flags & SHF_MIPS_GPREL))
	      lo = o->vma;

	  /* And calculate GP relative to that.  */
	  elf_gp (abfd) = (lo + 0x7ff0);
	}
      else
	{
	  /* If the relocate_section function needs to do a reloc
	     involving the GP value, it should make a reloc_dangerous
	     callback to warn that GP is not defined.  */
	}
    }

  /* Go through the sections and collect the .mdebug information.  */
  mdebug_sec = NULL;
  gptab_data_sec = NULL;
  gptab_bss_sec = NULL;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
    {
      if (strcmp (o->name, ".mdebug") == 0)
	{
	  struct extsym_info einfo;
	  bfd_vma last;

	  /* We have found the .mdebug section in the output file.
	     Look through all the link_orders comprising it and merge
	     the information together.  */
	  symhdr->magic = swap->sym_magic;
	  /* FIXME: What should the version stamp be?  */
	  symhdr->vstamp = 0;
	  symhdr->ilineMax = 0;
	  symhdr->cbLine = 0;
	  symhdr->idnMax = 0;
	  symhdr->ipdMax = 0;
	  symhdr->isymMax = 0;
	  symhdr->ioptMax = 0;
	  symhdr->iauxMax = 0;
	  symhdr->issMax = 0;
	  symhdr->issExtMax = 0;
	  symhdr->ifdMax = 0;
	  symhdr->crfd = 0;
	  symhdr->iextMax = 0;

	  /* We accumulate the debugging information itself in the
	     debug_info structure.  */
	  debug.line = NULL;
	  debug.external_dnr = NULL;
	  debug.external_pdr = NULL;
	  debug.external_sym = NULL;
	  debug.external_opt = NULL;
	  debug.external_aux = NULL;
	  debug.ss = NULL;
	  debug.ssext = debug.ssext_end = NULL;
	  debug.external_fdr = NULL;
	  debug.external_rfd = NULL;
	  debug.external_ext = debug.external_ext_end = NULL;

	  mdebug_handle = bfd_ecoff_debug_init (abfd, &debug, swap, info);
	  if (mdebug_handle == (PTR) NULL)
	    return false;

          esym.jmptbl = 0;
          esym.cobol_main = 0;
          esym.weakext = 0;
          esym.reserved = 0;
          esym.ifd = ifdNil;
          esym.asym.iss = issNil;
          esym.asym.st = stLocal;
          esym.asym.reserved = 0;
          esym.asym.index = indexNil;
          last = 0;
	  for (i = 0; i < sizeof (secname) / sizeof (secname[0]); i++)
            {
              esym.asym.sc = sc[i];
              s = bfd_get_section_by_name (abfd, secname[i]);
              if (s != NULL)
                {
                  esym.asym.value = s->vma;
                  last = s->vma + s->_raw_size;
                }
              else
                esym.asym.value = last;
              if (!bfd_ecoff_debug_one_external (abfd, &debug, swap,
                                                 secname[i], &esym))
                return false;
            }

	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      const struct ecoff_debug_swap *input_swap;
	      struct ecoff_debug_info input_debug;
	      char *eraw_src;
	      char *eraw_end;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      if (bfd_get_flavour (input_bfd) != bfd_target_elf_flavour
		  || (get_elf_backend_data (input_bfd)
		      ->elf_backend_ecoff_debug_swap) == NULL)
		{
		  /* I don't know what a non MIPS ELF bfd would be
		     doing with a .mdebug section, but I don't really
		     want to deal with it.  */
		  continue;
		}

	      input_swap = (get_elf_backend_data (input_bfd)
			    ->elf_backend_ecoff_debug_swap);

	      BFD_ASSERT (p->size == input_section->_raw_size);

	      /* The ECOFF linking code expects that we have already
		 read in the debugging information and set up an
		 ecoff_debug_info structure, so we do that now.  */
	      if (! _bfd_mips_elf_read_ecoff_info (input_bfd, input_section,
						   &input_debug))
		return false;

	      if (! (bfd_ecoff_debug_accumulate
		     (mdebug_handle, abfd, &debug, swap, input_bfd,
		      &input_debug, input_swap, info)))
		return false;

	      /* Loop through the external symbols.  For each one with
		 interesting information, try to find the symbol in
		 the linker global hash table and save the information
		 for the output external symbols.  */
	      eraw_src = input_debug.external_ext;
	      eraw_end = (eraw_src
			  + (input_debug.symbolic_header.iextMax
			     * input_swap->external_ext_size));
	      for (;
		   eraw_src < eraw_end;
		   eraw_src += input_swap->external_ext_size)
		{
		  EXTR ext;
		  const char *name;
		  struct mips_elf64_link_hash_entry *h;

		  (*input_swap->swap_ext_in) (input_bfd, (PTR) eraw_src, &ext);
		  if (ext.asym.sc == scNil
		      || ext.asym.sc == scUndefined
		      || ext.asym.sc == scSUndefined)
		    continue;

		  name = input_debug.ssext + ext.asym.iss;
		  h = mips_elf64_link_hash_lookup (mips_elf64_hash_table (info),
						 name, false, false, true);
		  if (h == NULL || h->esym.ifd != -2)
		    continue;

		  if (ext.ifd != -1)
		    {
		      BFD_ASSERT (ext.ifd
				  < input_debug.symbolic_header.ifdMax);
		      ext.ifd = input_debug.ifdmap[ext.ifd];
		    }

		  h->esym = ext;
		}

	      /* Free up the information we just read.  */
	      free (input_debug.line);
	      free (input_debug.external_dnr);
	      free (input_debug.external_pdr);
	      free (input_debug.external_sym);
	      free (input_debug.external_opt);
	      free (input_debug.external_aux);
	      free (input_debug.ss);
	      free (input_debug.ssext);
	      free (input_debug.external_fdr);
	      free (input_debug.external_rfd);
	      free (input_debug.external_ext);

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* Build the external symbol information.  */
	  einfo.abfd = abfd;
	  einfo.info = info;
	  einfo.debug = &debug;
	  einfo.swap = swap;
	  einfo.failed = false;
	  mips_elf64_link_hash_traverse (mips_elf64_hash_table (info),
					 mips_elf64_output_extsym,
					 (PTR) &einfo);
	  if (einfo.failed)
	    return false;

	  /* Set the size of the .mdebug section.  */
	  o->_raw_size = bfd_ecoff_debug_size (abfd, &debug, swap);

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;

	  mdebug_sec = o;
	}

      if (strncmp (o->name, ".gptab.", sizeof ".gptab." - 1) == 0)
	{
	  const char *subname;
	  unsigned int c;
	  Elf32_gptab *tab;
	  Elf32_External_gptab *ext_tab;
	  unsigned int i;

	  /* The .gptab.sdata and .gptab.sbss sections hold
	     information describing how the small data area would
	     change depending upon the -G switch.  These sections
	     not used in executables files.  */
	  if (! info->relocateable)
	    {
	      asection **secpp;

	      for (p = o->link_order_head;
		   p != (struct bfd_link_order *) NULL;
		   p = p->next)
		{
		  asection *input_section;

		  if (p->type != bfd_indirect_link_order)
		    {
		      if (p->type == bfd_data_link_order)
			continue;
		      abort ();
		    }

		  input_section = p->u.indirect.section;

		  /* Hack: reset the SEC_HAS_CONTENTS flag so that
		     elf_link_input_bfd ignores this section.  */
		  input_section->flags &=~ SEC_HAS_CONTENTS;
		}

	      /* Skip this section later on (I don't think this
		 currently matters, but someday it might).  */
	      o->link_order_head = (struct bfd_link_order *) NULL;

	      /* Really remove the section.  */
	      for (secpp = &abfd->sections;
		   *secpp != o;
		   secpp = &(*secpp)->next)
		;
	      bfd_section_list_remove (abfd, secpp);
	      --abfd->section_count;

	      continue;
	    }

	  /* There is one gptab for initialized data, and one for
	     uninitialized data.  */
	  if (strcmp (o->name, ".gptab.sdata") == 0)
	    gptab_data_sec = o;
	  else if (strcmp (o->name, ".gptab.sbss") == 0)
	    gptab_bss_sec = o;
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s: illegal section name `%s'"),
		 bfd_archive_filename (abfd), o->name);
	      bfd_set_error (bfd_error_nonrepresentable_section);
	      return false;
	    }

	  /* The linker script always combines .gptab.data and
	     .gptab.sdata into .gptab.sdata, and likewise for
	     .gptab.bss and .gptab.sbss.  It is possible that there is
	     no .sdata or .sbss section in the output file, in which
	     case we must change the name of the output section.  */
	  subname = o->name + sizeof ".gptab" - 1;
	  if (bfd_get_section_by_name (abfd, subname) == NULL)
	    {
	      if (o == gptab_data_sec)
		o->name = ".gptab.data";
	      else
		o->name = ".gptab.bss";
	      subname = o->name + sizeof ".gptab" - 1;
	      BFD_ASSERT (bfd_get_section_by_name (abfd, subname) != NULL);
	    }

	  /* Set up the first entry.  */
	  c = 1;
	  tab = (Elf32_gptab *) bfd_malloc (c * sizeof (Elf32_gptab));
	  if (tab == NULL)
	    return false;
	  tab[0].gt_header.gt_current_g_value = elf_gp_size (abfd);
	  tab[0].gt_header.gt_unused = 0;

	  /* Combine the input sections.  */
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
	    {
	      asection *input_section;
	      bfd *input_bfd;
	      bfd_size_type size;
	      unsigned long last;
	      bfd_size_type gpentry;

	      if (p->type != bfd_indirect_link_order)
		{
		  if (p->type == bfd_data_link_order)
		    continue;
		  abort ();
		}

	      input_section = p->u.indirect.section;
	      input_bfd = input_section->owner;

	      /* Combine the gptab entries for this input section one
		 by one.  We know that the input gptab entries are
		 sorted by ascending -G value.  */
	      size = bfd_section_size (input_bfd, input_section);
	      last = 0;
	      for (gpentry = sizeof (Elf32_External_gptab);
		   gpentry < size;
		   gpentry += sizeof (Elf32_External_gptab))
		{
		  Elf32_External_gptab ext_gptab;
		  Elf32_gptab int_gptab;
		  unsigned long val;
		  unsigned long add;
		  boolean exact;
		  unsigned int look;

		  if (! (bfd_get_section_contents
			 (input_bfd, input_section, (PTR) &ext_gptab,
			  gpentry, sizeof (Elf32_External_gptab))))
		    {
		      free (tab);
		      return false;
		    }

		  mips_elf64_swap_gptab_in (input_bfd, &ext_gptab,
						&int_gptab);
		  val = int_gptab.gt_entry.gt_g_value;
		  add = int_gptab.gt_entry.gt_bytes - last;

		  exact = false;
		  for (look = 1; look < c; look++)
		    {
		      if (tab[look].gt_entry.gt_g_value >= val)
			tab[look].gt_entry.gt_bytes += add;

		      if (tab[look].gt_entry.gt_g_value == val)
			exact = true;
		    }

		  if (! exact)
		    {
		      Elf32_gptab *new_tab;
		      unsigned int max;

		      /* We need a new table entry.  */
		      new_tab = ((Elf32_gptab *)
				 bfd_realloc ((PTR) tab,
					      (c + 1) * sizeof (Elf32_gptab)));
		      if (new_tab == NULL)
			{
			  free (tab);
			  return false;
			}
		      tab = new_tab;
		      tab[c].gt_entry.gt_g_value = val;
		      tab[c].gt_entry.gt_bytes = add;

		      /* Merge in the size for the next smallest -G
			 value, since that will be implied by this new
			 value.  */
		      max = 0;
		      for (look = 1; look < c; look++)
			{
			  if (tab[look].gt_entry.gt_g_value < val
			      && (max == 0
				  || (tab[look].gt_entry.gt_g_value
				      > tab[max].gt_entry.gt_g_value)))
			    max = look;
			}
		      if (max != 0)
			tab[c].gt_entry.gt_bytes +=
			  tab[max].gt_entry.gt_bytes;

		      ++c;
		    }

		  last = int_gptab.gt_entry.gt_bytes;
		}

	      /* Hack: reset the SEC_HAS_CONTENTS flag so that
		 elf_link_input_bfd ignores this section.  */
	      input_section->flags &=~ SEC_HAS_CONTENTS;
	    }

	  /* The table must be sorted by -G value.  */
	  if (c > 2)
	    qsort (tab + 1, c - 1, sizeof (tab[0]), gptab_compare);

	  /* Swap out the table.  */
	  ext_tab = ((Elf32_External_gptab *)
		     bfd_alloc (abfd, c * sizeof (Elf32_External_gptab)));
	  if (ext_tab == NULL)
	    {
	      free (tab);
	      return false;
	    }

	  for (i = 0; i < c; i++)
	    mips_elf64_swap_gptab_out (abfd, tab + i, ext_tab + i);
	  free (tab);

	  o->_raw_size = c * sizeof (Elf32_External_gptab);
	  o->contents = (bfd_byte *) ext_tab;

	  /* Skip this section later on (I don't think this currently
	     matters, but someday it might).  */
	  o->link_order_head = (struct bfd_link_order *) NULL;
	}
    }

  /* Invoke the regular ELF backend linker to do all the work.  */
  if (!bfd_elf64_bfd_final_link (abfd, info))
     return false;

  /* Now write out the computed sections.  */
  if (mdebug_sec != (asection *) NULL)
    {
      BFD_ASSERT (abfd->output_has_begun);
      if (! bfd_ecoff_write_accumulated_debug (mdebug_handle, abfd, &debug,
					       swap, info,
					       mdebug_sec->filepos))
	return false;

      bfd_ecoff_debug_free (mdebug_handle, abfd, &debug, swap, info);
    }
  if (gptab_data_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_data_sec,
				      gptab_data_sec->contents,
				      (file_ptr) 0,
				      gptab_data_sec->_raw_size))
	return false;
    }

  if (gptab_bss_sec != (asection *) NULL)
    {
      if (! bfd_set_section_contents (abfd, gptab_bss_sec,
				      gptab_bss_sec->contents,
				      (file_ptr) 0,
				      gptab_bss_sec->_raw_size))
	return false;
    }

  return true;
}

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf64_ecoff_debug_swap =
{
  /* Symbol table magic number.  */
  magicSym2,
  /* Alignment of debugging information.  E.g., 4.  */
  8,
  /* Sizes of external symbolic information.  */
  sizeof (struct hdr_ext),
  sizeof (struct dnr_ext),
  sizeof (struct pdr_ext),
  sizeof (struct sym_ext),
  sizeof (struct opt_ext),
  sizeof (struct fdr_ext),
  sizeof (struct rfd_ext),
  sizeof (struct ext_ext),
  /* Functions to swap in external symbolic data.  */
  ecoff_swap_hdr_in,
  ecoff_swap_dnr_in,
  ecoff_swap_pdr_in,
  ecoff_swap_sym_in,
  ecoff_swap_opt_in,
  ecoff_swap_fdr_in,
  ecoff_swap_rfd_in,
  ecoff_swap_ext_in,
  _bfd_ecoff_swap_tir_in,
  _bfd_ecoff_swap_rndx_in,
  /* Functions to swap out external symbolic data.  */
  ecoff_swap_hdr_out,
  ecoff_swap_dnr_out,
  ecoff_swap_pdr_out,
  ecoff_swap_sym_out,
  ecoff_swap_opt_out,
  ecoff_swap_fdr_out,
  ecoff_swap_rfd_out,
  ecoff_swap_ext_out,
  _bfd_ecoff_swap_tir_out,
  _bfd_ecoff_swap_rndx_out,
  /* Function to read in symbolic data.  */
  _bfd_mips_elf_read_ecoff_info
};

/* Relocations in the 64 bit MIPS ELF ABI are more complex than in
   standard ELF.  This structure is used to redirect the relocation
   handling routines.  */

const struct elf_size_info mips_elf64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_Mips_External_Rel),
  sizeof (Elf64_Mips_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  4,            /* hash-table entry size */
  3,            /* internal relocations per external relocations */
  64,		/* arch_size */
  8,		/* file_align */
  ELFCLASS64,
  EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  mips_elf64_write_relocs,
  bfd_elf64_swap_symbol_out,
  mips_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  mips_elf64_be_swap_reloc_in,
  mips_elf64_be_swap_reloc_out,
  mips_elf64_be_swap_reloca_in,
  mips_elf64_be_swap_reloca_out
};

#define ELF_ARCH			bfd_arch_mips
#define ELF_MACHINE_CODE		EM_MIPS

#define ELF_MAXPAGESIZE			0x1000

#define elf_backend_collect		true
#define elf_backend_type_change_ok	true
#define elf_backend_can_gc_sections	true
#define elf_info_to_howto		mips_elf64_info_to_howto_rela
#define elf_info_to_howto_rel		mips_elf64_info_to_howto_rel
#define elf_backend_object_p		_bfd_mips_elf_object_p
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_section_from_shdr	_bfd_mips_elf_section_from_shdr
#define elf_backend_fake_sections	_bfd_mips_elf_fake_sections
#define elf_backend_section_from_bfd_section \
					_bfd_mips_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook	_bfd_mips_elf_add_symbol_hook
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
#define elf_backend_create_dynamic_sections \
					mips_elf64_create_dynamic_sections
#define elf_backend_check_relocs	mips_elf64_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					mips_elf64_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					mips_elf64_always_size_sections
#define elf_backend_size_dynamic_sections \
					mips_elf64_size_dynamic_sections
#define elf_backend_relocate_section    mips_elf64_relocate_section
#define elf_backend_finish_dynamic_symbol \
					mips_elf64_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					mips_elf64_finish_dynamic_sections
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_additional_program_headers \
					mips_elf64_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_gc_mark_hook	mips_elf64_gc_mark_hook
#define elf_backend_gc_sweep_hook	mips_elf64_gc_sweep_hook
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
#define elf_backend_size_info		mips_elf64_size_info

#define elf_backend_got_header_size	(4 * MIPS_RESERVED_GOTNO)
#define elf_backend_plt_header_size	0

/* MIPS ELF64 can use a mixture of REL and RELA, but some Relocations
 * work better/work only in RELA, so we default to this.  */
#define elf_backend_may_use_rel_p	1
#define elf_backend_may_use_rela_p	1
#define elf_backend_default_use_rela_p	1

/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit
   MIPS-specific function only applies to IRIX5, which had no 64-bit
   ABI.  */
#define bfd_elf64_find_nearest_line	_bfd_mips_elf_find_nearest_line
#define bfd_elf64_set_section_contents	_bfd_mips_elf_set_section_contents
#define bfd_elf64_bfd_link_hash_table_create \
					mips_elf64_link_hash_table_create
#define bfd_elf64_bfd_final_link	mips_elf64_final_link
#define bfd_elf64_bfd_merge_private_bfd_data \
					_bfd_mips_elf_merge_private_bfd_data
#define bfd_elf64_bfd_set_private_flags	_bfd_mips_elf_set_private_flags
#define bfd_elf64_bfd_print_private_bfd_data \
					_bfd_mips_elf_print_private_bfd_data

#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_bfd_reloc_type_lookup	mips_elf64_reloc_type_lookup
d2761 1
a2761 1
				_bfd_archive_coff_slurp_extended_name_table
d2763 1
a2763 1
				_bfd_archive_coff_construct_extended_name_table
d2765 1
a2765 1
					_bfd_archive_coff_truncate_arname
d2768 1
a2768 1
				_bfd_archive_coff_openr_next_archived_file
d2770 1
a2770 1
					_bfd_archive_coff_get_elt_at_index
d2772 1
a2772 1
					_bfd_archive_coff_generic_stat_arch_elt
d2774 1
a2774 1
				_bfd_archive_coff_update_armap_timestamp
@


1.28
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3055 3
d3096 3
a3098 3
				elf_hash_table (info)), 
			       mips_elf64_sort_hash_table_f, 
			       &hsd);
d4691 3
d6138 3
d6631 2
a6632 2
				       mips_elf64_output_extsym,
				       (PTR) &einfo);
@


1.27
log
@	Support arbitrary length fill patterns.
	* linker.c (bfd_new_link_order): Zero all fields with bfd_zalloc.
	(_bfd_default_link_order): Remove bfd_fill_link_order code.
	Call default_data_link_order.
	(default_fill_link_order): Delete.
	(default_data_link_order): New function.
	* elf32-mips.c (_bfd_mips_elf_final_link): Replace occurrences
	of bfd_fill_link_order with bfd_data_link_order.
	* elf64-alpha.c (elf64_alpha_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
@
text
@d3399 3
@


1.26
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d6521 1
a6521 1
		  if (p->type == bfd_fill_link_order)
d6658 1
a6658 1
		      if (p->type == bfd_fill_link_order)
d6737 1
a6737 1
		  if (p->type == bfd_fill_link_order)
@


1.26.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a3398 3
  /* FIXME: For -2 runtime relocation needs to be skipped, but
     properly resolved statically and installed.  */
  BFD_ASSERT (outrel[0].r_offset != (bfd_vma) -2);
@


1.26.2.2
log
@Merge from mainline.
@
text
@a3054 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

d3093 3
a3095 3
				  elf_hash_table (info)), 
				 mips_elf64_sort_hash_table_f, 
				 &hsd);
a4687 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

a6131 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct mips_elf64_link_hash_entry *) h->root.root.u.i.link;

d6622 2
a6623 2
					 mips_elf64_output_extsym,
					 (PTR) &einfo);
@


1.25
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d6395 1
a6395 1
	  *secpp = (*secpp)->next;
d6679 1
a6679 1
	      *secpp = (*secpp)->next;
@


1.24
log
@	* elf32-mips.c (_bfd_mips_elf_relocate_section): Formatting.
	* elf64-mips.c: Add most of the fixes and tweaks done in elf32-mips.c
	over the last months. Add some code for mips16 handling.
	(mips_elf64_check_mips16_stubs): New function.
	(mips_elf64_stub_section_p): Likewise.
	(mips_elf64_calculate_relocation): Change interface to support mips16.
	(mips_elf64_perform_relocation): Likewise.
@
text
@a7028 2
#define bfd_elf64_bfd_copy_private_bfd_data \
					_bfd_mips_elf_copy_private_bfd_data
@


1.23
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d164 1
a164 1
	   bfd_vma *, asection *, boolean));
d168 2
a169 1
	   Elf_Internal_Sym *, asection **, bfd_vma *, const char **));
d173 3
a175 2
  PARAMS ((reloc_howto_type *, const Elf_Internal_Rela *, bfd_vma, bfd *,
	   bfd_byte *));
d185 2
d208 1
d2768 22
d2791 38
d2835 2
d2893 5
d2923 2
d3060 1
a3060 1
  if (h->root.got.offset != 0)
d3118 2
a3119 2
  in->ms_hash_value = bfd_h_get_32 (abfd, ex->ms_hash_value);
  in->ms_info = bfd_h_get_32 (abfd, ex->ms_info);
d3130 2
a3131 2
  bfd_h_put_32 (abfd, in->ms_hash_value, ex->ms_hash_value);
  bfd_h_put_32 (abfd, in->ms_info, ex->ms_info);
d3370 1
a3370 1
				    symbol, addendp, input_section, local_p)
a3378 1
     boolean local_p;
d3391 3
d3396 3
d3403 1
a3403 1
  if (elf_section_data (input_section)->stab_info == NULL)
a3404 1
      outrel[0].r_offset = rel[0].r_offset;
a3413 6
      outrel[0].r_offset
	= (_bfd_stab_section_offset
	   (output_bfd, &elf_hash_table (info)->stab_info,
	    input_section,
	    &elf_section_data (input_section)->stab_info,
	    rel->r_offset));
d3466 1
a3466 1
	  *addendp += symbol - sec->output_section->vma;
d3471 5
a3475 4
      /* If the relocation is against a local symbol was previously an absolute
	 relocation, we must adjust it by the value we give it in the dynamic
	 symbol table.  */
      if (local_p && r_type != R_MIPS_REL32)
d3521 2
d3530 3
a3532 11
mips_elf64_calculate_relocation (abfd, 
			       input_bfd,
			       input_section,
			       info,
			       relocation,
			       addend,
			       howto,
			       local_syms,
			       local_sections,
			       valuep,
			       namep)
d3544 1
d3577 2
d3616 4
d3626 2
d3661 3
a3663 1
      else if (info->shared && !info->symbolic && !info->no_undefined
d3689 60
d3751 8
d3790 1
a3790 1
      else if (r_type == R_MIPS_GOT16)
d3803 1
a3803 1
					  abfd, g);
d3836 5
a3840 2
	       && ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)
		   != 0)))
d3851 1
a3851 1
						     input_section, local_p))
d3882 6
d3890 1
a3890 1
	value = (((addend << 2) | (p & 0xf0000000)) + symbol) >> 2;
d3929 1
a3951 1
    case R_MIPS_CALL16:
d4050 3
a4052 1
   relocation applies.
d4057 4
a4060 1
mips_elf64_perform_relocation (howto, relocation, value, abfd, contents)
d4064 2
a4065 1
     bfd *abfd;
d4067 1
d4069 107
a4175 2
  bfd_byte *location = contents + relocation->r_offset;
  bfd_vma x = mips_elf64_obtain_contents (howto, relocation, abfd, contents);
d4178 43
a4220 2
  x = (x & ~howto->dst_mask) | (value & howto->dst_mask);
  
d4222 1
a4222 1
  bfd_put (8 * bfd_get_reloc_size (howto), abfd, x, location);
d4226 14
d4267 1
d4272 1
d4289 1
a4289 2
	      >= (rel_hdr->sh_size / rel_hdr->sh_entsize
		  * bed->s->int_rels_per_ext_rel))
d4424 3
a4426 2
	      if (!mips_elf64_perform_relocation (howto, rel, addend, input_bfd,
						contents))
d4446 5
a4450 11
      switch (mips_elf64_calculate_relocation (output_bfd, 
					       input_bfd,
					       input_section,
					       info,
					       rel,
					       addend,
					       howto,
					       local_syms,
					       local_sections,
					       &value,
					       &name))
d4464 4
a4467 2
	  abort ();
	  break;
d4501 3
a4503 2
      if (!mips_elf64_perform_relocation (howto, rel, value, input_bfd,
					contents))
d4588 3
a4590 1
      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4600 3
a4602 2
  /* For a function, create a stub, if needed.  */
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d4666 58
d5606 1
a5606 1
  /* If we've already marked this entry as need GOT space, we don't
d5612 3
a5614 2
     there needs to be a GOT entry for H.  */
  h->got.offset = 0;
d5697 2
d5700 155
d5888 1
a5888 1
      else if (r_symndx >= extsymoff + (symtab_hdr->sh_size / symtab_hdr->sh_entsize))
d5891 2
a5892 1
	    (_("Malformed reloc detected for section %s"), name);
d5950 4
a5953 4
	     the segment.  Similar comments apply to R_MIPS_GOT16.  We
	     don't count R_MIPS_GOT_HI16, or R_MIPS_CALL_HI16 because
	     these are always followed by an R_MIPS_GOT_LO16 or
	     R_MIPS_CALL_LO16.
d5970 1
a5970 1
		 bfd_get_filename (abfd), (unsigned long) rel->r_offset);
d6233 10
a6242 6
      /* Set type and value for a symbol with a function stub.  */
      h->esym.asym.st = stProc;
      sec = h->root.root.u.def.section;
      if (sec == NULL)
	h->esym.asym.value = 0;
      else
d6244 5
a6248 5
	  output_section = sec->output_section;
	  if (output_section != NULL)
	    h->esym.asym.value = (h->root.plt.offset
				  + sec->output_offset
				  + output_section->vma);
d6250 9
a6258 2
	    h->esym.asym.value = 0;
	}
d6260 1
a6260 1
      h->esym.ifd = 0;
d6262 1
d6285 2
a6286 2
  in->gt_entry.gt_g_value = bfd_h_get_32 (abfd, ex->gt_entry.gt_g_value);
  in->gt_entry.gt_bytes = bfd_h_get_32 (abfd, ex->gt_entry.gt_bytes);
d6295 1
a6295 1
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_g_value,
d6297 1
a6297 1
  bfd_h_put_32 (abfd, (bfd_vma) in->gt_entry.gt_bytes,
a6333 1
  bfd_vma last;
d6335 1
a6335 1
  static const char * const name[] =
d6443 1
d6492 1
a6492 1
          for (i = 0; i < 8; i++)
d6495 1
a6495 1
              s = bfd_get_section_by_name (abfd, name[i]);
d6504 1
a6504 1
                                                 name[i], &esym))
d6695 1
a6695 1
		 bfd_get_filename (abfd), o->name);
@


1.22
log
@	* elf64-mips.c (mips_elf64_link_hash_entry): New link hash.
	(mips_elf64_high): New Function.
	(mips_elf64_higher): Likewise.
	(mips_elf64_highest): Likewise.
	(mips_elf64_info_to_howto_rel): Likewise.
	(mips_elf64_info_to_howto_rela): Likewise.
	(mips_elf64_write_rel): Likewise.
	(mips_elf64_write_rela): Likewise.
	(mips_elf64_link_hash_newfunc): Likewise.
	(mips_elf64_hi16_reloc): Likewise.
	(mips_elf64_higher_reloc): Likewise.
	(mips_elf64_highest_reloc): Likewise.
	(mips_elf64_gprel16_reloc): Likewise.
	(mips_elf64_gprel16_reloca): Likewise.
	(mips_elf64_literal_reloc): Likewise.
	(mips_elf64_gprel32_reloc): Likewise.
	(mips_elf64_shift6_reloc): Likewise.
	(mips_elf64_got16_reloc): Likewise.
	(mips_elf64_assign_gp): Likewise.
	(mips_elf64_final_gp): Likewise.
	(gprel16_with_gp): Likewise.
	(mips_elf64_additional_program_headers): Likewise.
	(mips_elf64_link_hash_table_create): Likewise.
	(mips_elf64_got_offset_from_index): Likewise.
	(_mips_elf64_got_info): Likewise.
	(mips_elf64_sign_extend): Likewise.
	(mips_elf64_overflow_p): Likewise.
	(mips_elf64_global_got_index): Likewise.
	(mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_swap_msym_out): Likewise.
	(mips_elf64_create_local_got_entry): Likewise.
	(mips_elf64_local_got_index): Likewise.
	(mips_elf64_got_page): Likewise.
	(mips_elf64_got16_entry): Likewise.
	(mips_elf64_local_relocation_p): Likewise.
	(mips_elf64_next_relocation): Likewise.
	(mips_elf64_create_dynamic_relocation): Likewise.
	(mips_elf64_calculate_relocation): Likewise.
	(mips_elf64_obtain_contents): Likewise.
	(mips_elf64_perform_relocation): Likewise.
	(mips_elf64_relocate_section): Likewise.
	(mips_elf64_create_dynamic_sections): Likewise.
	(mips_elf64_adjust_dynamic_symbol): Likewise.
	(mips_elf64_always_size_sections): Likewise.
	(mips_elf64_size_dynamic_sections): Likewise.
	(mips_elf64_finish_dynamic_symbol): Likewise.
	(mips_elf64_finish_dynamic_sections): Likewise.
	(mips_elf64_gc_mark_hook): Likewise.
	(mips_elf64_gc_sweep_hook): Likewise.
	(mips_elf64_create_got_section): Likewise.
	(mips_elf64_record_global_got_symbol): Likewise.
	(mips_elf64_create_msym_section): Likewise.
	(mips_elf64_allocate_dynamic_relocations): Likewise.
	(mips_elf64_check_relocs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	(mips_elf64_swap_gptab_in): Likewise.
	(mips_elf64_swap_gptab_out): Likewise.
	(gptab_compare): Likewise.
	(mips_elf64_final_link): Likewise.
	(prev_reloc_addend): Remenber addend of previous parts of a combined
	reloc.
	(ELF_MIPS_GP_OFFSET): New define.
	(STUB_LW,STUB_MOVE,STUB_JALR,STUB_LI16): Likewise.
	(MIPS_FUNCTION_STUB_SIZE): Likewise.
	(mips_elf64_howto_rel): Fix HOWTO defines.
	(mips_elf64_howto_rela): Likewise.
	(mips_elf64_swap_reloca_out): Fix signedness.
	(mips_elf64_be_swap_reloc_in): Use ELF64* instead of ELF32*.
	(mips_elf64_be_swap_reloca_in): Likewise.
	(mips_elf64_be_swap_reloc_out): Likewise. Preserve extended type info.
	(mips_elf64_be_swap_reloca_out): Likewise.
@
text
@d5091 1
a5091 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.21
log
@	* Makefile.am: split up BFD_LIBS like statements in BFD32_LIBS and
	BFD64_LIBS, make the latter depending on the availability of BFD64.
	Add archive64.c source file.
	* archive64.c: New file implementing bfd_elf64_archive_slurp_armap
	and bfd_elf64_archive_write_armap, code from elf64-mips.c
	* archive.c (bfd_slurp_armap): Add ELF64 archive support.
	* config.bfd (mips*-*-irix6*): Allow with BFD64 only.
	(mips64*el-*-linux*): Likewise.
	(mips*el-*-linux*): Likewise. Reorder entries.
	* configure.in (bfd_libs): Define in dependency of BFD64 and
	AC_SUBST it.
	* elf64-mips.c (mips_elf64_slurp_armap): Remove, use
	bfd_elf64_archive_slurp_armap instead.
	(mips_elf64_write_armap): Remove, use bfd_elf64_archive_write_armap
	instead.
@
text
@d30 14
d64 2
d86 3
d91 4
d101 126
d235 8
d267 1
a267 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d271 1
a271 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d275 2
a276 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d323 2
a324 2
	 0x3ffffff,		/* src_mask */
	 0x3ffffff,		/* dst_mask */
d335 1
a335 1
	 _bfd_mips_elf_hi16_reloc,	/* special_function */
d338 2
a339 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d350 1
a350 1
	 _bfd_mips_elf_lo16_reloc,	/* special_function */
d353 2
a354 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d365 1
a365 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d368 2
a369 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d380 1
a380 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d383 2
a384 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d395 1
a395 1
	 _bfd_mips_elf_got16_reloc,	/* special_function */
d397 3
a399 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
d413 3
a415 3
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d428 3
a430 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
d440 2
a441 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
a467 2
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
d475 1
a475 1
	 bfd_elf_generic_reloc,	/* special_function */
d508 1
a508 1
	 false,			/* partial_inplace */
d524 1
a524 1
	 false,			/* partial_inplace */
d540 1
a540 1
	 false,			/* partial_inplace */
d556 1
a556 1
	 false,			/* partial_inplace */
d572 1
a572 1
	 false,			/* partial_inplace */
d650 1
a650 1
	 bfd_elf_generic_reloc,	/* special_function */
d653 2
a654 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
a657 1
  /* FIXME: Not handled correctly.  */
d665 1
a665 1
	 bfd_elf_generic_reloc,	/* special_function */
d668 2
a669 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d684 2
a685 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d700 2
a701 2
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
d704 2
a705 3
  /* I'm not sure what the remaining relocs are, but they are defined
     on Irix 6.  */

d738 2
d759 1
a759 1
	 0,			/* bitsize */
d767 1
a767 1
	 0,			/* dst_mask */
d793 1
a793 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d797 1
a797 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d802 1
a802 1
	 0xffff,		/* dst_mask */
d850 1
a850 1
	 0x3ffffff,		/* dst_mask */
d853 1
d866 1
a866 1
	 0xffff,		/* dst_mask */
d881 1
a881 1
	 0xffff,		/* dst_mask */
d892 1
a892 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d894 1
a894 1
	 true,			/* partial_inplace */
d896 1
a896 1
	 0xffff,		/* dst_mask */
d907 1
a907 1
	 _bfd_mips_elf_gprel16_reloc, /* special_function */
d909 1
a909 1
	 true,			/* partial_inplace */
d911 1
a911 1
	 0xffff,		/* dst_mask */
d927 1
a927 1
	 0xffff,		/* dst_mask */
d942 2
a943 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d958 1
a958 1
	 0xffff,		/* dst_mask */
d968 2
a969 2
	 complain_overflow_bitfield, /* complain_on_overflow */
	 _bfd_mips_elf_gprel32_reloc, /* special_function */
d971 1
a971 1
	 true,			/* partial_inplace */
a995 2
  /* FIXME: This is not handled correctly; a special function is
     needed to put the most significant bit in the right place.  */
d1003 1
a1003 1
	 bfd_elf_generic_reloc,	/* special_function */
d1182 1
a1182 1
	 0xffff,		/* dst_mask */
d1197 1
a1197 1
	 0xffff,		/* dst_mask */
d1213 1
a1213 1
	 0xffff,		/* dst_mask */
d1229 1
a1229 1
	 0xffff,		/* dst_mask */
d1232 2
a1233 3
  /* I'm not sure what the remaining relocs are, but they are defined
     on Irix 6.  */

d1266 2
d1287 1
a1287 1
	 0,			/* bitsize */
d1295 1
a1295 1
	 0,			/* dst_mask */
d1362 1
a1362 1
  H_PUT_64 (abfd, src->r_addend, dst->r_addend);
d1380 1
a1380 1
  dst[0].r_info = ELF32_R_INFO (mirel.r_sym, mirel.r_type);
d1382 1
a1382 1
  dst[1].r_info = ELF32_R_INFO (mirel.r_ssym, mirel.r_type2);
d1384 1
a1384 1
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirel.r_type3);
d1402 1
a1402 1
  dst[0].r_info = ELF32_R_INFO (mirela.r_sym, mirela.r_type);
d1405 1
a1405 1
  dst[1].r_info = ELF32_R_INFO (mirela.r_ssym, mirela.r_type2);
d1408 1
a1408 1
  dst[2].r_info = ELF32_R_INFO (STN_UNDEF, mirela.r_type3);
d1422 9
a1430 6
  mirel.r_offset = src->r_offset;
  mirel.r_type = ELF32_R_TYPE (src->r_info);
  mirel.r_sym = ELF32_R_SYM (src->r_info);
  mirel.r_type2 = R_MIPS_NONE;
  mirel.r_ssym = STN_UNDEF;
  mirel.r_type3 = R_MIPS_NONE;
d1446 13
a1458 7
  mirela.r_offset = src->r_offset;
  mirela.r_type = ELF32_R_TYPE (src->r_info);
  mirela.r_addend = src->r_addend;
  mirela.r_sym = ELF32_R_SYM (src->r_info);
  mirela.r_type2 = R_MIPS_NONE;
  mirela.r_ssym = STN_UNDEF;
  mirela.r_type3 = R_MIPS_NONE;
d1464 10
a1473 1
/* A mapping from BFD reloc types to MIPS ELF reloc types.  */
d1475 3
a1477 1
struct elf_reloc_map
d1479 4
a1482 3
  bfd_reloc_code_real_type bfd_reloc_val;
  enum elf_mips_reloc_type elf_reloc_val;
};
d1484 3
a1486 1
static const struct elf_reloc_map mips_reloc_map[] =
d1488 2
a1489 24
  { BFD_RELOC_NONE, R_MIPS_NONE, },
  { BFD_RELOC_16, R_MIPS_16 },
  { BFD_RELOC_32, R_MIPS_32 },
  { BFD_RELOC_64, R_MIPS_64 },
  { BFD_RELOC_CTOR, R_MIPS_64 },
  { BFD_RELOC_32_PCREL, R_MIPS_REL32 },
  { BFD_RELOC_MIPS_JMP, R_MIPS_26 },
  { BFD_RELOC_HI16_S, R_MIPS_HI16 },
  { BFD_RELOC_LO16, R_MIPS_LO16 },
  { BFD_RELOC_GPREL16, R_MIPS_GPREL16 },
  { BFD_RELOC_MIPS_LITERAL, R_MIPS_LITERAL },
  { BFD_RELOC_MIPS_GOT16, R_MIPS_GOT16 },
  { BFD_RELOC_16_PCREL, R_MIPS_PC16 },
  { BFD_RELOC_MIPS_CALL16, R_MIPS_CALL16 },
  { BFD_RELOC_GPREL32, R_MIPS_GPREL32 },
  { BFD_RELOC_MIPS_GOT_HI16, R_MIPS_GOT_HI16 },
  { BFD_RELOC_MIPS_GOT_LO16, R_MIPS_GOT_LO16 },
  { BFD_RELOC_MIPS_CALL_HI16, R_MIPS_CALL_HI16 },
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 },
  { BFD_RELOC_MIPS_SUB, R_MIPS_SUB },
  { BFD_RELOC_MIPS_GOT_PAGE, R_MIPS_GOT_PAGE },
  { BFD_RELOC_MIPS_GOT_OFST, R_MIPS_GOT_OFST },
  { BFD_RELOC_MIPS_GOT_DISP, R_MIPS_GOT_DISP }
};
d1491 1
a1491 1
/* Given a BFD reloc type, return a howto structure.  */
d1493 8
a1500 2
static reloc_howto_type *
mips_elf64_reloc_type_lookup (abfd, code)
d1502 6
a1507 1
     bfd_reloc_code_real_type code;
d1509 18
a1526 1
  unsigned int i;
d1528 22
a1549 1
  for (i = 0; i < sizeof (mips_reloc_map) / sizeof (struct elf_reloc_map); i++)
d1551 3
a1553 3
      if (mips_reloc_map[i].bfd_reloc_val == code)
	{
	  int v;
d1555 3
a1557 4
	  v = (int) mips_reloc_map[i].elf_reloc_val;
	  return &mips_elf64_howto_table_rel[v];
	}
    }
d1559 1
a1559 1
  return NULL;
d1562 1
a1562 2
/* Since each entry in an SHT_REL or SHT_RELA section can represent up
   to three relocs, we must tell the user to allocate more space.  */
d1564 8
a1571 2
static long
mips_elf64_get_reloc_upper_bound (abfd, sec)
d1573 54
a1626 1
     asection *sec;
d1628 18
a1645 1
  return (sec->reloc_count * 3 + 1) * sizeof (arelent *);
d1648 2
a1649 1
/* Read the relocations from one reloc section.  */
d1652 3
a1654 5
mips_elf64_slurp_one_reloc_table (abfd, asect, symbols, rel_hdr)
     bfd *abfd;
     asection *asect;
     asymbol **symbols;
     const Elf_Internal_Shdr *rel_hdr;
a1655 4
  PTR allocated = NULL;
  bfd_byte *native_relocs;
  arelent *relents;
  arelent *relent;
d1657 1
a1658 2
  int entsize;
  reloc_howto_type *howto_table;
d1660 4
a1663 7
  allocated = (PTR) bfd_malloc (rel_hdr->sh_size);
  if (allocated == NULL)
    return false;

  if (bfd_seek (abfd, rel_hdr->sh_offset, SEEK_SET) != 0
      || (bfd_bread (allocated, rel_hdr->sh_size, abfd) != rel_hdr->sh_size))
    goto error_return;
d1665 2
a1666 1
  native_relocs = (bfd_byte *) allocated;
d1668 9
a1676 1
  relents = asect->relocation + asect->reloc_count;
d1678 9
a1686 3
  entsize = rel_hdr->sh_entsize;
  BFD_ASSERT (entsize == sizeof (Elf64_Mips_External_Rel)
	      || entsize == sizeof (Elf64_Mips_External_Rela));
d1688 7
a1694 1
  count = rel_hdr->sh_size / entsize;
d1696 2
a1697 4
  if (entsize == sizeof (Elf64_Mips_External_Rel))
    howto_table = mips_elf64_howto_table_rel;
  else
    howto_table = mips_elf64_howto_table_rela;
d1699 16
a1714 2
  relent = relents;
  for (i = 0; i < count; i++, native_relocs += entsize)
d1716 3
a1718 3
      Elf64_Mips_Internal_Rela rela;
      boolean used_sym, used_ssym;
      int ir;
d1720 12
a1731 5
      if (entsize == sizeof (Elf64_Mips_External_Rela))
	mips_elf64_swap_reloca_in (abfd,
				   (Elf64_Mips_External_Rela *) native_relocs,
				   &rela);
      else
d1733 3
a1735 12
	  Elf64_Mips_Internal_Rel rel;

	  mips_elf64_swap_reloc_in (abfd,
				    (Elf64_Mips_External_Rel *) native_relocs,
				    &rel);
	  rela.r_offset = rel.r_offset;
	  rela.r_sym = rel.r_sym;
	  rela.r_ssym = rel.r_ssym;
	  rela.r_type3 = rel.r_type3;
	  rela.r_type2 = rel.r_type2;
	  rela.r_type = rel.r_type;
	  rela.r_addend = 0;
d1737 1
d1739 2
a1740 1
      /* Each entry represents up to three actual relocations.  */
d1742 544
a2285 5
      used_sym = false;
      used_ssym = false;
      for (ir = 0; ir < 3; ir++)
	{
	  enum elf_mips_reloc_type type;
d2468 2
a2469 3
  unsigned int count;
  Elf_Internal_Shdr *rela_hdr;
  Elf64_Mips_External_Rela *ext_rela;
a2470 2
  asymbol *last_sym = 0;
  int last_sym_idx = 0;
d2515 25
a2539 1
  rela_hdr = &elf_section_data (sec)->rel_hdr;
d2541 3
a2543 3
  rela_hdr->sh_size = rela_hdr->sh_entsize * count;
  rela_hdr->contents = (PTR) bfd_alloc (abfd, rela_hdr->sh_size);
  if (rela_hdr->contents == NULL)
d2549 2
a2550 2
  ext_rela = (Elf64_Mips_External_Rela *) rela_hdr->contents;
  for (idx = 0; idx < sec->reloc_count; idx++, ext_rela++)
d2553 1
a2553 1
      Elf64_Mips_Internal_Rela int_rela;
d2564 1
a2564 1
	int_rela.r_offset = ptr->address;
d2566 1
a2566 1
	int_rela.r_offset = ptr->address + sec->vma;
d2583 2
a2584 5
      int_rela.r_sym = n;

      int_rela.r_addend = ptr->addend;

      int_rela.r_ssym = RSS_UNDEF;
d2593 3
a2595 3
      int_rela.r_type = ptr->howto->type;
      int_rela.r_type2 = (int) R_MIPS_NONE;
      int_rela.r_type3 = (int) R_MIPS_NONE;
d2612 1
a2612 1
	    int_rela.r_type2 = r->howto->type;
d2614 1
a2614 1
	    int_rela.r_type3 = r->howto->type;
d2619 1
a2619 1
      mips_elf64_swap_reloca_out (abfd, &int_rela, ext_rela);
d2622 2
a2623 2
  BFD_ASSERT (ext_rela - (Elf64_Mips_External_Rela *) rela_hdr->contents
	      == (int) count);
d2625 3722
a6346 4

/* ECOFF swapping routines.  These are used when dealing with the
   .mdebug section, which is in the ECOFF debugging format.  */
static const struct ecoff_debug_swap mips_elf64_ecoff_debug_swap =
a6420 4
#define TARGET_LITTLE_SYM		bfd_elf64_littlemips_vec
#define TARGET_LITTLE_NAME		"elf64-littlemips"
#define TARGET_BIG_SYM			bfd_elf64_bigmips_vec
#define TARGET_BIG_NAME			"elf64-bigmips"
d6429 2
a6430 1
#define elf_backend_size_info		mips_elf64_size_info
d6432 2
a6437 8
#define elf_backend_section_processing	_bfd_mips_elf_section_processing
#define elf_backend_symbol_processing	_bfd_mips_elf_symbol_processing
#define elf_backend_additional_program_headers \
					_bfd_mips_elf_additional_program_headers
#define elf_backend_modify_segment_map	_bfd_mips_elf_modify_segment_map
#define elf_backend_final_write_processing \
					_bfd_mips_elf_final_write_processing
#define elf_backend_ecoff_debug_swap	&mips_elf64_ecoff_debug_swap
d6439 2
d6442 2
a6443 2
					_bfd_mips_elf_create_dynamic_sections
#define elf_backend_check_relocs	_bfd_mips_elf_check_relocs
d6445 1
a6445 1
					_bfd_mips_elf_adjust_dynamic_symbol
d6447 1
a6447 1
					_bfd_mips_elf_always_size_sections
d6449 2
a6450 4
					_bfd_mips_elf_size_dynamic_sections
#define elf_backend_relocate_section    _bfd_mips_elf_relocate_section
#define elf_backend_link_output_symbol_hook \
					_bfd_mips_elf_link_output_symbol_hook
d6452 1
a6452 1
					_bfd_mips_elf_finish_dynamic_symbol
d6454 12
a6465 4
					_bfd_mips_elf_finish_dynamic_sections
#define elf_backend_gc_mark_hook	_bfd_mips_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook	_bfd_mips_elf_gc_sweep_hook
#define elf_backend_got_header_size	(4*MIPS_RESERVED_GOTNO)
d6480 2
a6481 2
					_bfd_mips_elf_link_hash_table_create
#define bfd_elf64_bfd_final_link	_bfd_mips_elf_final_link
d6513 6
d6521 1
a6521 3
/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */
d6523 1
d6534 1
a6534 1
/* Include the target file again for this target */
@


1.20
log
@	* coff-mips.c (mips_bfd_reloc_type_lookup): Replace
	BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	* pe-mips.c (mips_bfd_reloc_type_lookup): Likewise.
	* elf32-mips.c (mips_reloc_map): Likewise. Replace
	BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	* elf64-mips.c (mips_reloc_map): Likewise.
	* reloc.c (BFD_RELOC_MIPS_GPREL): Remove.
	(BFD_RELOC_MIPS_GPREL32): Remove.
	* config/tc-mips.c (macro_build): Replace BFD_RELOC_MIPS_GPREL
	by BFD_RELOC_GPREL16.
	(load_address): Likewise.
	(macro): Likewise.
	(md_apply_fix): Likewise. Replace BFD_RELOC_MIPS_GPREL32 by
	BFD_RELOC_GPREL32.
	(s_gpword): Replace BFD_RELOC_MIPS_GPREL32 by BFD_RELOC_GPREL32.
	(tc_gen_reloc): Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
	*config/tc-mips.h: Replace BFD_RELOC_MIPS_GPREL by BFD_RELOC_GPREL16.
@
text
@d28 1
a28 3
   writing the relocations here.

   The MIPS 64-bit ELF ABI also uses an unusual archive map format.  */
a77 3
static boolean mips_elf64_slurp_armap PARAMS ((bfd *));
static boolean mips_elf64_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
a1765 211
/* Irix 6 defines a brand new archive map format, so that they can
   have archives more than 4 GB in size.  */

/* Read an Irix 6 armap.  */

static boolean
mips_elf64_slurp_armap (abfd)
     bfd *abfd;
{
  struct artdata *ardata = bfd_ardata (abfd);
  char nextname[17];
  file_ptr arhdrpos;
  bfd_size_type i, parsed_size, nsymz, stringsize, carsym_size, ptrsize;
  struct areltdata *mapdata;
  bfd_byte int_buf[8];
  char *stringbase;
  bfd_byte *raw_armap = NULL;
  carsym *carsyms;
  bfd_size_type amt;

  ardata->symdefs = NULL;

  /* Get the name of the first element.  */
  arhdrpos = bfd_tell (abfd);
  i = bfd_bread ((PTR) nextname, (bfd_size_type) 16, abfd);
  if (i == 0)
    return true;
  if (i != 16)
    return false;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return false;

  /* Archives with traditional armaps are still permitted.  */
  if (strncmp (nextname, "/               ", 16) == 0)
    return bfd_slurp_armap (abfd);

  if (strncmp (nextname, "/SYM64/         ", 16) != 0)
    {
      bfd_has_map (abfd) = false;
      return true;
    }

  mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);
  if (mapdata == NULL)
    return false;
  parsed_size = mapdata->parsed_size;
  bfd_release (abfd, (PTR) mapdata);

  if (bfd_bread (int_buf, (bfd_size_type) 8, abfd) != 8)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      return false;
    }

  nsymz = bfd_getb64 (int_buf);
  stringsize = parsed_size - 8 * nsymz - 8;

  carsym_size = nsymz * sizeof (carsym);
  ptrsize = 8 * nsymz;

  amt = carsym_size + stringsize + 1;
  ardata->symdefs = (carsym *) bfd_zalloc (abfd, amt);
  if (ardata->symdefs == NULL)
    return false;
  carsyms = ardata->symdefs;
  stringbase = ((char *) ardata->symdefs) + carsym_size;

  raw_armap = (bfd_byte *) bfd_alloc (abfd, ptrsize);
  if (raw_armap == NULL)
    goto error_return;

  if (bfd_bread (raw_armap, ptrsize, abfd) != ptrsize
      || bfd_bread (stringbase, stringsize, abfd) != stringsize)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_malformed_archive);
      goto error_return;
    }

  for (i = 0; i < nsymz; i++)
    {
      carsyms->file_offset = bfd_getb64 (raw_armap + i * 8);
      carsyms->name = stringbase;
      stringbase += strlen (stringbase) + 1;
      ++carsyms;
    }
  *stringbase = '\0';

  ardata->symdef_count = nsymz;
  ardata->first_file_filepos = arhdrpos + sizeof (struct ar_hdr) + parsed_size;

  bfd_has_map (abfd) = true;
  bfd_release (abfd, raw_armap);

  return true;

 error_return:
  if (raw_armap != NULL)
    bfd_release (abfd, raw_armap);
  if (ardata->symdefs != NULL)
    bfd_release (abfd, ardata->symdefs);
  return false;
}

/* Write out an Irix 6 armap.  The Irix 6 tools are supposed to be
   able to handle ordinary ELF armaps, but at least on Irix 6.2 the
   linker crashes.  */

static boolean
mips_elf64_write_armap (arch, elength, map, symbol_count, stridx)
     bfd *arch;
     unsigned int elength;
     struct orl *map;
     unsigned int symbol_count;
     int stridx;
{
  unsigned int ranlibsize = (symbol_count * 8) + 8;
  unsigned int stringsize = stridx;
  unsigned int mapsize = stringsize + ranlibsize;
  file_ptr archive_member_file_ptr;
  bfd *current = arch->archive_head;
  unsigned int count;
  struct ar_hdr hdr;
  unsigned int i;
  int padding;
  bfd_byte buf[8];

  padding = BFD_ALIGN (mapsize, 8) - mapsize;
  mapsize += padding;

  /* work out where the first object file will go in the archive */
  archive_member_file_ptr = (mapsize
			     + elength
			     + sizeof (struct ar_hdr)
			     + SARMAG);

  memset ((char *) (&hdr), 0, sizeof (struct ar_hdr));
  strcpy (hdr.ar_name, "/SYM64/");
  sprintf (hdr.ar_size, "%-10d", (int) mapsize);
  sprintf (hdr.ar_date, "%ld", (long) time (NULL));
  /* This, at least, is what Intel coff sets the values to.: */
  sprintf ((hdr.ar_uid), "%d", 0);
  sprintf ((hdr.ar_gid), "%d", 0);
  sprintf ((hdr.ar_mode), "%-7o", (unsigned) 0);
  strncpy (hdr.ar_fmag, ARFMAG, 2);

  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Write the ar header for this item and the number of symbols */

  if (bfd_bwrite ((PTR) &hdr, (bfd_size_type) sizeof (struct ar_hdr), arch)
      != sizeof (struct ar_hdr))
    return false;

  bfd_putb64 ((bfd_vma) symbol_count, buf);
  if (bfd_bwrite (buf, (bfd_size_type) 8, arch) != 8)
    return false;

  /* Two passes, first write the file offsets for each symbol -
     remembering that each offset is on a two byte boundary.  */

  /* Write out the file offset for the file associated with each
     symbol, and remember to keep the offsets padded out.  */

  current = arch->archive_head;
  count = 0;
  while (current != (bfd *) NULL && count < symbol_count)
    {
      /* For each symbol which is used defined in this object, write out
	 the object file's address in the archive */

      while (map[count].u.abfd == current)
	{
	  bfd_putb64 ((bfd_vma) archive_member_file_ptr, buf);
	  if (bfd_bwrite (buf, (bfd_size_type) 8, arch) != 8)
	    return false;
	  count++;
	}
      /* Add size of this archive entry */
      archive_member_file_ptr += (arelt_size (current)
				  + sizeof (struct ar_hdr));
      /* remember about the even alignment */
      archive_member_file_ptr += archive_member_file_ptr % 2;
      current = current->next;
    }

  /* now write the strings themselves */
  for (count = 0; count < symbol_count; count++)
    {
      size_t len = strlen (*map[count].name) + 1;

      if (bfd_bwrite (*map[count].name, (bfd_size_type) len, arch) != len)
	return false;
    }

  /* The spec says that this should be padded to an 8 byte boundary.
     However, the Irix 6.2 tools do not appear to do this.  */
  while (padding != 0)
    {
      if (bfd_bwrite ("", (bfd_size_type) 1, arch) != 1)
	return false;
      --padding;
    }

  return true;
}

d1916 4
a1919 1
#define bfd_elf64_archive_slurp_armap	mips_elf64_slurp_armap
a1925 1
#define bfd_elf64_archive_write_armap	mips_elf64_write_armap
@


1.19
log
@	* elf64-mips.c (elf_backend_may_use_rela_p): New define.
	(elf_backend_default_use_rela_p): New define.
@
text
@d1324 1
a1324 1
  { BFD_RELOC_MIPS_GPREL, R_MIPS_GPREL16 },
d1329 1
a1329 1
  { BFD_RELOC_MIPS_GPREL32, R_MIPS_GPREL32 },
@


1.18
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2106 6
a2111 1
#define elf_backend_may_use_rel_p       1
@


1.17
log
@	* elf64-mips.c (mips_elf64_howto_table_rel): Fix relocation HOWTO
	definitions.
	(mips_elf64_howto_table_rel): Likewise.
@
text
@d1157 6
a1162 6
  dst->r_offset = bfd_h_get_64 (abfd, (bfd_byte *) src->r_offset);
  dst->r_sym = bfd_h_get_32 (abfd, (bfd_byte *) src->r_sym);
  dst->r_ssym = bfd_h_get_8 (abfd, (bfd_byte *) src->r_ssym);
  dst->r_type3 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type3);
  dst->r_type2 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type2);
  dst->r_type = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type);
d1173 7
a1179 7
  dst->r_offset = bfd_h_get_64 (abfd, (bfd_byte *) src->r_offset);
  dst->r_sym = bfd_h_get_32 (abfd, (bfd_byte *) src->r_sym);
  dst->r_ssym = bfd_h_get_8 (abfd, (bfd_byte *) src->r_ssym);
  dst->r_type3 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type3);
  dst->r_type2 = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type2);
  dst->r_type = bfd_h_get_8 (abfd, (bfd_byte *) src->r_type);
  dst->r_addend = bfd_h_get_signed_64 (abfd, (bfd_byte *) src->r_addend);
d1190 6
a1195 6
  bfd_h_put_64 (abfd, src->r_offset, (bfd_byte *) dst->r_offset);
  bfd_h_put_32 (abfd, src->r_sym, (bfd_byte *) dst->r_sym);
  bfd_h_put_8 (abfd, src->r_ssym, (bfd_byte *) dst->r_ssym);
  bfd_h_put_8 (abfd, src->r_type3, (bfd_byte *) dst->r_type3);
  bfd_h_put_8 (abfd, src->r_type2, (bfd_byte *) dst->r_type2);
  bfd_h_put_8 (abfd, src->r_type, (bfd_byte *) dst->r_type);
d1206 7
a1212 7
  bfd_h_put_64 (abfd, src->r_offset, (bfd_byte *) dst->r_offset);
  bfd_h_put_32 (abfd, src->r_sym, (bfd_byte *) dst->r_sym);
  bfd_h_put_8 (abfd, src->r_ssym, (bfd_byte *) dst->r_ssym);
  bfd_h_put_8 (abfd, src->r_type3, (bfd_byte *) dst->r_type3);
  bfd_h_put_8 (abfd, src->r_type2, (bfd_byte *) dst->r_type2);
  bfd_h_put_8 (abfd, src->r_type, (bfd_byte *) dst->r_type);
  bfd_h_put_64 (abfd, src->r_addend, (bfd_byte *) dst->r_addend);
d1313 1
a1313 1
static CONST struct elf_reloc_map mips_reloc_map[] =
d1394 1
a1394 1
    goto error_return;
d1397 1
a1397 1
      || (bfd_read (allocated, 1, rel_hdr->sh_size, abfd) != rel_hdr->sh_size))
d1586 1
d1601 3
a1603 3
  asect->relocation = ((arelent *)
		       bfd_alloc (abfd,
				  asect->reloc_count * 3 * sizeof (arelent)));
d1789 1
d1795 1
a1795 1
  i = bfd_read ((PTR) nextname, 1, 16, abfd);
d1801 1
a1801 1
  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)
d1820 1
a1820 1
  if (bfd_read (int_buf, 1, 8, abfd) != 8)
d1833 2
a1834 1
  ardata->symdefs = (carsym *) bfd_zalloc (abfd, carsym_size + stringsize + 1);
d1844 2
a1845 2
  if (bfd_read (raw_armap, 1, ptrsize, abfd) != ptrsize
      || bfd_read (stringbase, 1, stringsize, abfd) != stringsize)
d1925 1
a1925 1
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), arch)
d1929 2
a1930 2
  bfd_putb64 (symbol_count, buf);
  if (bfd_write (buf, 1, 8, arch) != 8)
d1946 1
a1946 1
      while (((bfd *) (map[count]).pos) == current)
d1948 2
a1949 2
	  bfd_putb64 (archive_member_file_ptr, buf);
	  if (bfd_write (buf, 1, 8, arch) != 8)
d1966 1
a1966 1
      if (bfd_write (*map[count].name, 1, len, arch) != len)
d1974 1
a1974 1
      if (bfd_write ("", 1, 1, arch) != 1)
@


1.16
log
@	* elf64-mips.c (UNUSED_RELOC): Define.
	(mips_elf64_howto_table_rel): Use it.
	(mips_elf64_howto_table_rela): Here too.
	(mips_elf64_write_relocs): Fix signed/unsigned warning.
@
text
@d134 1
a134 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d149 1
a149 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d157 1
a157 1
  /* 26 bit branch address.  */
d166 1
a166 1
				   detection, because the upper four
d339 1
a339 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d355 1
a355 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d358 1
a358 1
	 true,			/* partial_inplace */
d371 1
a371 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d374 1
a374 1
	 true,			/* partial_inplace */
d387 1
a387 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d390 1
a390 1
	 true,			/* partial_inplace */
d406 1
a406 1
	 true,			/* partial_inplace */
d422 1
a422 1
	 true,			/* partial_inplace */
d435 1
a435 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d447 2
a448 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d454 3
a456 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d464 2
a465 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d471 3
a473 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d480 2
a481 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d487 3
a489 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
a492 1
  /* FIXME: Not handled correctly.  */
d535 2
a536 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d551 2
a552 2
	 0x0000ffff,		/* src_mask */
	 0x0000ffff,		/* dst_mask */
d560 2
a561 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d567 3
a569 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d574 2
a575 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d578 1
a578 1
	 complain_overflow_dont, /* complain_on_overflow */
d581 3
a583 17
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_MIPS_ADD_IMMEDIATE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_ADD_IMMEDIATE", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d586 3
a588 13
  HOWTO (R_MIPS_PJUMP,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PJUMP",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d592 2
a593 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d599 3
a601 3
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d608 1
a608 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d616 2
a617 2
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
d650 1
a650 1
	 true,			/* partial_inplace */
d662 1
a662 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d665 1
a665 1
	 true,			/* partial_inplace */
d677 1
a677 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d680 1
a680 1
	 true,			/* partial_inplace */
d685 1
a685 1
  /* 26 bit branch address.  */
d694 1
a694 1
				   detection, because the upper four
d698 1
a698 1
	 true,			/* partial_inplace */
d713 1
a713 1
	 true,			/* partial_inplace */
d728 1
a728 1
	 true,			/* partial_inplace */
d772 1
a772 1
	 bfd_elf_generic_reloc,	/* special_function */
d789 1
a789 1
	 true,			/* partial_inplace */
d839 1
a839 1
	 true,			/* partial_inplace */
d856 1
a856 1
	 true,			/* partial_inplace */
d868 1
a868 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d871 1
a871 1
	 true,			/* partial_inplace */
d884 1
a884 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d887 1
a887 1
	 true,			/* partial_inplace */
d900 1
a900 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d903 1
a903 1
	 true,			/* partial_inplace */
d916 1
a916 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d919 1
a919 1
	 true,			/* partial_inplace */
d935 1
a935 1
	 true,			/* partial_inplace */
d951 1
a951 1
	 true,			/* partial_inplace */
d964 1
a964 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d967 1
a967 1
	 true,			/* partial_inplace */
d976 2
a977 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d985 1
a985 1
	 0,			/* dst_mask */
d993 2
a994 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1002 1
a1002 1
	 0,			/* dst_mask */
d1009 2
a1010 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1018 1
a1018 1
	 0,			/* dst_mask */
a1021 1
  /* FIXME: Not handled correctly.  */
d1029 1
a1029 1
	 bfd_elf_generic_reloc,	/* special_function */
d1031 1
a1031 1
	 true,			/* partial_inplace */
a1036 1
  /* FIXME: Not handled correctly.  */
d1044 1
a1044 1
	 bfd_elf_generic_reloc,	/* special_function */
d1046 1
a1046 1
	 true,			/* partial_inplace */
d1062 1
a1062 1
	 true,			/* partial_inplace */
d1064 1
a1064 1
	 0x0000ffff,		/* dst_mask */
d1078 1
a1078 1
	 true,			/* partial_inplace */
d1080 1
a1080 1
	 0x0000ffff,		/* dst_mask */
d1088 2
a1089 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1097 1
a1097 1
	 0,			/* dst_mask */
d1102 2
a1103 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1106 1
a1106 1
	 complain_overflow_dont, /* complain_on_overflow */
d1111 1
a1111 15
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */

  HOWTO (R_MIPS_ADD_IMMEDIATE,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_ADD_IMMEDIATE", /* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
d1114 3
a1116 13
  HOWTO (R_MIPS_PJUMP,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 false,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_MIPS_PJUMP",	/* name */
	 false,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 false),		/* pcrel_offset */
d1120 2
a1121 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1129 1
a1129 1
	 0,			/* dst_mask */
d1136 1
a1136 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d1144 2
a1145 2
	 0x00000000,		/* src_mask */
	 0x00000000,		/* dst_mask */
@


1.15
log
@	* elf64-gen.c (elf_generic_info_to_howto): Add unused attribute.
	(elf_generic_info_to_howto_rel): Likewise.
	* coff-alpha.c (reloc_nil): Likewise.
	(alpha_ecoff_bad_format_hook): Likewise.
	(alpha_adjust_reloc_out): Likewise.
	(alpha_bfd_reloc_type_lookup): Likewise.
	(alpha_convert_external_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_nil): Likewise.
	(elf64_alpha_reloc_bad): Likewise.
	(elf64_alpha_reloc_gpdisp): Likewise.
	(elf64_alpha_bfd_reloc_type_lookup): Likewise.
	(elf64_alpha_info_to_howto): Likewise.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_is_local_label_name): Likewise.
	(elf64_alpha_merge_ind_symbols): Likewise.
	* elf64-mips.c (mips_elf64_reloc_type_lookup): Likewise.
	(mips_elf64_get_reloc_upper_bound): Likewise.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Likewise.
	(nlm_alpha_get_public_offset): Likewise.
@
text
@d93 2
d296 3
a298 3
    { 13 },
    { 14 },
    { 15 },
d850 3
a852 3
    { 13 },
    { 14 },
    { 15 },
d1818 1
a1818 1
	      == count);
@


1.14
log
@2001-04-05  Steven J. Hill  <sjhill@@cotw.com>

	* config.bfd (mips*el*-*-linux-gnu*): Use traditional little
	endian MIPS ELF target.
	* config.bfd (mips*-*-linux-gnu*): Use traditional big endian
	MIPS ELF target.

	* configure.in (bfd_elf64_tradbigmips_vec): New. Traditional
	64bit big endian MIPS ELF target.
	(bfd_elf64_tradlittlemips_vec): New. Traditional 64bit little
	endian MIPS ELF target.
	* configure: Regenerated.

	* elf32-mips.c (IRIX_COMPAT): Handle traditional 64bit and
	little endian targets.
	(mips_elf_sym_is_global): Handle traditional targets.

	* elf64-mips.c (bfd_elf64_tradbigmips_vec): New. Traditional
	64bit big endian MIPS ELF target.
	(bfd_elf64_tradlittlemips_vec): New. Traditional 64bit little
	endian MIPS ELF target.

	* targets.c: (_bfd_target_vector): Add bfd_elf64_tradbigmips_vec
	and bfd_elf64_tradlittlemips_vec.
@
text
@d163 1
a163 1
	 			/* This needs complex overflow
d716 1
a716 1
	 			/* This needs complex overflow
d1393 1
a1393 1
     bfd *abfd;
d1417 1
a1417 1
     bfd *abfd;
@


1.13
log
@Update copyright notices
@
text
@d2192 17
@


1.12
log
@oops - omitted from previous delta
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.11
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* elf64-alpha.c: Fix formatting.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
@
text
@d164 1
a164 1
				   bits must match the PC.  */
d717 1
a717 1
				   bits must match the PC.  */
@


1.11.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.11.2.2
log
@Merge from mainline.
@
text
@d163 1
a163 1
				/* This needs complex overflow
d165 1
a165 1
				   bits must match the PC + 4.  */
d716 1
a716 1
				/* This needs complex overflow
d718 1
a718 1
				   bits must match the PC + 4.  */
d1393 1
a1393 1
     bfd *abfd ATTRIBUTE_UNUSED;
d1417 1
a1417 1
     bfd *abfd ATTRIBUTE_UNUSED;
a2190 17
#include "elf64-target.h"

/* Support for traditional mips targets */

#define INCLUDED_TARGET_FILE            /* More a type of flag */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME
#undef TARGET_BIG_SYM
#undef TARGET_BIG_NAME

#define TARGET_LITTLE_SYM               bfd_elf64_tradlittlemips_vec
#define TARGET_LITTLE_NAME              "elf64-tradlittlemips"
#define TARGET_BIG_SYM                  bfd_elf64_tradbigmips_vec
#define TARGET_BIG_NAME                 "elf64-tradbigmips"

/* Include the target file again for this target */
@


1.10
log
@The MIPS thinks that addresses are signed.  Sign extend MIPS ECOFF
addresses.
@
text
@d626 1
a626 1
  /* Protected jump conversion.  This is an optimization hint.  No 
d1180 1
a1180 1
  /* Protected jump conversion.  This is an optimization hint.  No 
d1273 1
a1273 1
  mips_elf64_swap_reloc_in (abfd, 
d1295 1
a1295 1
  mips_elf64_swap_reloca_in (abfd, 
d1327 1
a1327 1
  mips_elf64_swap_reloc_out (abfd, &mirel, 
d1349 1
a1349 1
  mips_elf64_swap_reloca_out (abfd, &mirela, 
d2153 1
a2153 1
/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit 
@


1.9
log
@Revert previous patch.
@
text
@d48 1
a48 1
#define ECOFF_64
@


1.8
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a2188 1
#define _bfd_elf64_allow_commons_in_armap bfd_false
@


1.7
log
@	* dwarf2.c (read_attribute): Support DW_FORM_ref8.
	* elf32-mips.c (mips_elf_link_hash_entry): Change mips_32_relocs
	to possibly_dynamic_relocs.  Adjust usage throughout code.
	(elf_mips_howto_table): Handle R_MIPS_64 correctly.
	(elf_mips_ctor64_howto): Likewise.
	(mips_elf_calculate_relocation): Handle R_MIPS_64 like R_MIPS_32.
	Adjust indentation.
	(mips_elf_relocate_section): Handle R_MIPS_64 in 32-bit mode.
	(_bfd_mips_elf_check_relocs): Handle R_MIPS_64 like R_MIPS_32.
	Use MIPS_ELF_GOT_SIZE to calculate the size of GOT entries.
	* elf64-mips.c (elf_backend_may_use_rel_p): Define.
@
text
@d2189 1
@


1.6
log
@	* elf-bfd.h (_bfd_mips_elf_section_from_shdr): Constify.
	(_bfd_mips_elf_create_dynamic_sections): New function.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_finish_dynamic_sections): Likewise.
	(_bfd_mips_elf_gc_mark_hook): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_always_size_sections): Likewise.
	(_bfd_mips_elf_size_dynamic_sections): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(_bfd_mips_elf_link_hash_table_create): Likewise.
	(_bfd_mips_elf_print_private_data): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(_bfd_mips_elf_final_link): Likewise.
	(_bfd_mips_elf_additional_program_headers): Likewise.
	(_bfd_mips_elf_modify_segment_map): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf32_object_p): Move contents into
	_bfd_mips_elf_object_p.
	(mips_elf_additional_program_headers): Rename to
	_bfd_mips_elf_additional_program_headers.
	(mips_elf_modify_segment_map): Rename to
	_bfd_mips_elf_modify_segment_map.
	(elf_mips_abi_name): Change prototype.
	(mips_elf32_section_from_shdr): Merge into
	_bfd_mips_elf_section_from_shdr.
	(mips_elf32_section_processing): Merge into
	_bfd_mips_elf_section_processing.
	(mips_elf_final_link): Rename to _bfd_mips_elf_final_link.  Invoke
	the right back-end ELF linker.
	(mips_elf_relocate_section): Rename to
	_bfd_mips_elf_relocate_section.  Clean up.  Adjust for 64-bit code.
	(mips_elf_link_output_symbol_hook): Rename to
	_bfd_mips_elf_link_output_symbol_hook.
	(mips_elf_create_dynamic_section): Rename to
	_bfd_mips_elf_create_dynamic_section.
	(mips_elf_check_relocs): Rename to _bfd_mips_elf_check_relocs.
	Adjust for 64-bit code.  Use mips_elf_got_section.
	(mips_elf_adjust_dynamic_symbol): Rename to
	_bfd_mips_elf_adjust_dynamic_symbol.  Use
	mips_elf_allocate_dynamic_relocations.
	(mips_elf_finish_dynamic_symbol): Rename to
	_bfd_mips_elf_finish_dynamic_symbol.  Use mips_elf_got_section.
	Adjust for 64-bit code.
	(mips_elf_finish_dynamic_sections): Rename to
	_bfd_mips_elf_finish_dynamic_sections.  Adjust for 64-bit code.
	(mips_elf_always_size_sections): Rename to
	_bfd_mips_elf_always_size_sections.
	(mips_elf_add_symbol_hook): Rename to
	_bfd_mips_elf_add_symbol_hook.
	(mips_elf_next_lo16_addend): Constify.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_obtain_contents): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(mips_elf_create_dynamic_relocation): Likewise.
	(mips_elf_allocate_dynamic_relocations): New function.
	(MIPS_ELF_REL_DYN_SECTION_NAME): New macro.
	(MIPS_ELF_REL_SIZE): Likewise.
	(MIPS_ELF_DYN_SIZE): Likewise.
	(MIPS_ELF_GOT_SIZE): Likewise.
	(MIPS_ELF_SYM_SIZE): Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Likewise.
	(MIPS_ELF_GET_WORD): Likewise.
	(MIPS_ELF_PUT_WORD): Likewise.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	(STUB_LW): Conditionalize for 64-bit value.
	(elf_mips_howto_table): Add R_MIPS_HIGHER and R_MIPS_HIGHEST
	entries.
	(_bfd_mips_elf_merge_private_bfd_data): Merge e_ident[EI_CLASS].
	Check it for inconsistency.
	(_bfd_mips_elf_print_private_bfd_data): Print ABI=64 for 64-bit
	ABI.
	(_bfd_mips_elf_fake_sections): Remove duplicate handling of
	.msym.
	(mips_elf_global_got_index): Use MIPS_ELF_GOT_SIZE.
	(mips_elf_got_offset_from_index): Use misp_elf_got_section.
	(mips_elf_create_local_got_entry): Use MIPS_ELF_GOT_SIZE.
	(mips_elf_local_got_index): Likewise.
	(mips_elf_got_page): Likewise.
	(mips_elf_got_info): Likewise.
	(mips_elf_create_dynamic_relocation): Handle 32-bit/64-bit split.
	(ELF_DYNAMIC_INTERPRETER): Handle 64-bit code.
	(mips_elf_create_dynamic_sections): Use MIPS_ELF_LOG_FILE_ALIGN,
	instead of constant `2'.
	(mips_elf_create_got_section): Tidy.  Use MIPS_ELF_GOT_SIZE.
	(mips_elf_create_msym_section): Use MIPS_ELF_LOG_FILE_ALIGN.
	(mips_elf_size_dynamic_sections): Use
	MIPS_ELF_REL_DYN_SECTION_NAME, MIPS_ELF_GOT_SIZE,
	MIPS_ELF_ADD_DYNAMIC_ENTRY.  Remove #if 0'd code.
	Adjust all releveant entries in elf backend table.
	* elf64-mips.c (mips_elf64_section_from_shdr): Remove.
	(mips_elf64_section_processing): Likewise.
	Adjust elf backend entries to use _bfd_mips_elf variants now
	publicly available.
@
text
@d2151 1
@


1.5
log
@	* elflink.h (elf_link_create_dynamic_sections): Handle non-standard
	hash-entry sizes.
	(size_dynamic_sections): Likewise.
	(elf_link_output_extsym): Likewise.
	* elf.c: (elf_fake_sections): Likewise.
	* libbfd.c (bfd_get): New macro.
	(bfd_put): Likewise.
	* bfd-in2.h: Regenerated.
	* elf-bfd.h (elf_size_info): Add hash_entry_size,
	int_rels_per_ext_rel, swap_dyn_out, swap_reloc_in, swap_reloc_out,
	wap_reloca_in, and swap_reloca_out.
	* elflink.h (elf_link_read_relocs_from_section): Adjust to handle
	multiple internal relocations per external relocation.
	(link_read_relocs): Likewise.
	(elf_bfd_final_link): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	* elfcode.h (elf_swap_dyn_out): Adjust type to match
	elf_swap_dyn_in.
	(size_info): Add entries for new fields.
	* elf64-mips.c (mips_elf64_swap_reloc_out): Enable.
	(mips_elf64_be_swap_reloc_in): New function.
	(mips_elf64_be_swap_reloc_out): Likewise.
	(mips_elf64_be_swap_reloca_in): Likewise.
	(mips_elf64_be_swap_reloca_out): Likewise.
	(mips_elf64_size_info): Add entries for new fields.
@
text
@d4 2
a78 4
static boolean mips_elf64_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
static boolean mips_elf64_section_processing
  PARAMS ((bfd *, Elf_Internal_Shdr *));
d87 3
a1817 109
/* Handle a 64-bit MIPS ELF specific section.  */

static boolean
mips_elf64_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     char *name;
{
  if (! _bfd_mips_elf_section_from_shdr (abfd, hdr, name))
    return false;

  /* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and
     set the gp value based on what we find.  We may see both
     SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,
     they should agree.  */
  if (hdr->sh_type == SHT_MIPS_OPTIONS)
    {
      bfd_byte *contents, *l, *lend;

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == NULL)
	return false;
      if (! bfd_get_section_contents (abfd, hdr->bfd_section, contents,
				      (file_ptr) 0, hdr->sh_size))
	{
	  free (contents);
	  return false;
	}
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      Elf64_Internal_RegInfo intreg;

	      bfd_mips_elf64_swap_reginfo_in
		(abfd,
		 ((Elf64_External_RegInfo *)
		  (l + sizeof (Elf_External_Options))),
		 &intreg);
	      elf_gp (abfd) = intreg.ri_gp_value;
	    }
	  l += intopt.size;
	}
      free (contents);
    }

  return true;
}

/* Work over a section just before writing it out.  We update the GP
   value in the SHT_MIPS_OPTIONS section based on the value we are
   using.  */

static boolean
mips_elf64_section_processing (abfd, hdr)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
{
  if (hdr->sh_type == SHT_MIPS_OPTIONS
      && hdr->bfd_section != NULL
      && elf_section_data (hdr->bfd_section) != NULL
      && elf_section_data (hdr->bfd_section)->tdata != NULL)
    {
      bfd_byte *contents, *l, *lend;

      /* We stored the section contents in the elf_section_data tdata
	 field in the set_section_contents routine.  We save the
	 section contents so that we don't have to read them again.
	 At this point we know that elf_gp is set, so we can look
	 through the section contents to see if there is an
	 ODK_REGINFO structure.  */

      contents = (bfd_byte *) elf_section_data (hdr->bfd_section)->tdata;
      l = contents;
      lend = contents + hdr->sh_size;
      while (l + sizeof (Elf_External_Options) <= lend)
	{
	  Elf_Internal_Options intopt;

	  bfd_mips_elf_swap_options_in (abfd, (Elf_External_Options *) l,
					&intopt);
	  if (intopt.kind == ODK_REGINFO)
	    {
	      bfd_byte buf[8];

	      if (bfd_seek (abfd,
			    (hdr->sh_offset
			     + (l - contents)
			     + sizeof (Elf_External_Options)
			     + (sizeof (Elf64_External_RegInfo) - 8)),
			     SEEK_SET) == -1)
		return false;
	      bfd_h_put_64 (abfd, elf_gp (abfd), buf);
	      if (bfd_write (buf, 1, 8, abfd) != 8)
		return false;
	    }
	  l += intopt.size;
	}
    }

  return _bfd_mips_elf_section_processing (abfd, hdr);
}

d2110 1
d2112 4
d2118 1
a2118 1
#define elf_backend_section_from_shdr	mips_elf64_section_from_shdr
d2122 1
a2122 1
#define elf_backend_section_processing	mips_elf64_section_processing
d2124 3
d2130 25
a2154 1

a2155 2
#define bfd_elf64_get_reloc_upper_bound mips_elf64_get_reloc_upper_bound
#define bfd_elf64_bfd_reloc_type_lookup	mips_elf64_reloc_type_lookup
d2157 3
d2165 2
d2168 2
@


1.4
log
@	* elf32-mips.c (elf_mips_howto_table): Add R_MIPS_JALR.
	* elf64-mips.c (mips_elf64_howto_table_rel): Likewise.
	(mips_elf64_howto_table_rela): Likewise.
@
text
@a54 1
#if 0
a57 1
#endif
d61 8
a1228 4
#if 0

/* This is not currently used.  */

a1244 2
#endif /* 0 */

d1262 90
d2192 2
d2204 6
a2209 1
  bfd_elf64_swap_dyn_in
@


1.3
log
@Update copyright.
@
text
@d617 17
a633 1
	 false)			/* pcrel_offset */
d1171 17
a1187 1
	 false)			/* pcrel_offset */
@


1.2
log
@	* reloc.c (BFD_RELOC_MIPS_SUB): New relocation.
	(BFD_RELOC_MIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MIPS_GOT_DISP): Likewise.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* elf32-mips.c (mips_info_to_howto_rela): New function.
	(USE_REL): Adjust for new conventions.
	(MINUS_ONE): New macro.
	(elf_mips_howto_table): Add R_MIPS_SUB.
	(mips_r): Add entries for MIPS_SUB, MIPS_GOT_PAGE, MIPS_GOT_OFST,
	and MIPS_GOT_DISP.
	(mips_elf_final_write_processing): Set sh_link, not sh_info, for a
	.MIPS.content section.
	(_bfd_mips_elf_fake_sections): Treat all sections that begin
	with .MIPS.content as .MIPS.content sections.  Set
	SHF_MNIPS_NOSTRIP for such section.
	(elf_info_to_howto): Define to mips_info_to_howto_rela.
	* elf64-mips.c (mips_r):  Add entries for MIPS_SUB, MIPS_GOT_PAGE,
	MIPS_GOT_OFST, and MIPS_GOT_DISP.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d1258 5
a1262 1
  { BFD_RELOC_MIPS_CALL_LO16, R_MIPS_CALL_LO16 }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

