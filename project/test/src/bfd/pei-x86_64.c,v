head	1.10;
access;
symbols
	sid-snapshot-20180601:1.10
	sid-snapshot-20180501:1.10
	sid-snapshot-20180401:1.10
	sid-snapshot-20180301:1.10
	sid-snapshot-20180201:1.10
	sid-snapshot-20180101:1.10
	sid-snapshot-20171201:1.10
	sid-snapshot-20171101:1.10
	sid-snapshot-20171001:1.10
	sid-snapshot-20170901:1.10
	sid-snapshot-20170801:1.10
	sid-snapshot-20170701:1.10
	sid-snapshot-20170601:1.10
	sid-snapshot-20170501:1.10
	sid-snapshot-20170401:1.10
	sid-snapshot-20170301:1.10
	sid-snapshot-20170201:1.10
	sid-snapshot-20170101:1.10
	sid-snapshot-20161201:1.10
	sid-snapshot-20161101:1.10
	sid-snapshot-20160901:1.10
	sid-snapshot-20160801:1.10
	sid-snapshot-20160701:1.10
	sid-snapshot-20160601:1.10
	sid-snapshot-20160501:1.10
	sid-snapshot-20160401:1.10
	sid-snapshot-20160301:1.10
	sid-snapshot-20160201:1.10
	sid-snapshot-20160101:1.10
	sid-snapshot-20151201:1.10
	sid-snapshot-20151101:1.10
	sid-snapshot-20151001:1.10
	sid-snapshot-20150901:1.10
	sid-snapshot-20150801:1.10
	sid-snapshot-20150701:1.10
	sid-snapshot-20150601:1.10
	sid-snapshot-20150501:1.10
	sid-snapshot-20150401:1.10
	sid-snapshot-20150301:1.10
	sid-snapshot-20150201:1.10
	sid-snapshot-20150101:1.10
	sid-snapshot-20141201:1.10
	sid-snapshot-20141101:1.10
	sid-snapshot-20141001:1.10
	sid-snapshot-20140901:1.10
	sid-snapshot-20140801:1.10
	sid-snapshot-20140701:1.10
	sid-snapshot-20140601:1.10
	sid-snapshot-20140501:1.10
	sid-snapshot-20140401:1.10
	sid-snapshot-20140301:1.10
	sid-snapshot-20140201:1.10
	sid-snapshot-20140101:1.10
	sid-snapshot-20131201:1.10
	sid-snapshot-20131101:1.10
	sid-snapshot-20131001:1.10
	binutils-2_24-branch:1.10.0.4
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.9
	sid-snapshot-20130901:1.10
	gdb_7_6_1-2013-08-30-release:1.10
	sid-snapshot-20130801:1.10
	sid-snapshot-20130701:1.10
	sid-snapshot-20130601:1.10
	sid-snapshot-20130501:1.10
	gdb_7_6-2013-04-26-release:1.10
	sid-snapshot-20130401:1.10
	binutils-2_23_2:1.9
	gdb_7_6-branch:1.10.0.2
	gdb_7_6-2013-03-12-branchpoint:1.10
	sid-snapshot-20130301:1.10
	sid-snapshot-20130201:1.10
	sid-snapshot-20130101:1.9
	sid-snapshot-20121201:1.9
	gdb_7_5_1-2012-11-29-release:1.9
	binutils-2_23_1:1.9
	sid-snapshot-20121101:1.9
	binutils-2_23:1.9
	sid-snapshot-20121001:1.9
	sid-snapshot-20120901:1.9
	gdb_7_5-2012-08-17-release:1.9
	sid-snapshot-20120801:1.9
	binutils-2_23-branch:1.9.0.14
	binutils-2_23-branchpoint:1.9
	gdb_7_5-branch:1.9.0.12
	gdb_7_5-2012-07-18-branchpoint:1.9
	sid-snapshot-20120701:1.9
	sid-snapshot-20120601:1.9
	sid-snapshot-20120501:1.9
	binutils-2_22_branch:1.9.0.10
	gdb_7_4_1-2012-04-26-release:1.9
	sid-snapshot-20120401:1.9
	sid-snapshot-20120301:1.9
	sid-snapshot-20120201:1.9
	gdb_7_4-2012-01-24-release:1.9
	sid-snapshot-20120101:1.9
	gdb_7_4-branch:1.9.0.8
	gdb_7_4-2011-12-13-branchpoint:1.9
	sid-snapshot-20111201:1.9
	binutils-2_22:1.9
	sid-snapshot-20111101:1.9
	sid-snapshot-20111001:1.9
	binutils-2_22-branch:1.9.0.6
	binutils-2_22-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.9
	sid-snapshot-20110901:1.9
	sid-snapshot-20110801:1.9
	gdb_7_3-2011-07-26-release:1.9
	sid-snapshot-20110701:1.9
	sid-snapshot-20110601:1.9
	sid-snapshot-20110501:1.9
	gdb_7_3-branch:1.9.0.4
	gdb_7_3-2011-04-01-branchpoint:1.9
	sid-snapshot-20110401:1.9
	sid-snapshot-20110301:1.9
	sid-snapshot-20110201:1.9
	sid-snapshot-20110101:1.9
	binutils-2_21:1.9
	sid-snapshot-20101201:1.9
	binutils-2_21-branch:1.9.0.2
	binutils-2_21-branchpoint:1.9
	sid-snapshot-20101101:1.9
	sid-snapshot-20101001:1.8
	binutils-2_20_1:1.5
	gdb_7_2-2010-09-02-release:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	gdb_7_2-branch:1.6.0.2
	gdb_7_2-2010-07-07-branchpoint:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.5
	gdb_7_1-2010-03-18-release:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.10
	gdb_7_1-2010-02-18-branchpoint:1.5
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	gdb_7_0_1-2009-12-22-release:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	binutils-2_20:1.5
	gdb_7_0-2009-10-06-release:1.5
	sid-snapshot-20091001:1.5
	gdb_7_0-branch:1.5.0.8
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.3
	binutils-arc-20081103-branch:1.3.0.26
	binutils-arc-20081103-branchpoint:1.3
	binutils-2_20-branch:1.5.0.6
	binutils-2_20-branchpoint:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	msnyder-checkpoint-072509-branch:1.5.0.4
	msnyder-checkpoint-072509-branchpoint:1.5
	sid-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.2
	dje-cgen-play1-branchpoint:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.4
	arc-20081103-branch:1.3.0.24
	arc-20081103-branchpoint:1.3
	arc-insight_6_8-branch:1.3.0.22
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.20
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.4
	binutils-2_19_1:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	reverse-20081226-branch:1.3.0.18
	reverse-20081226-branchpoint:1.3
	sid-snapshot-20081201:1.3
	multiprocess-20081120-branch:1.3.0.16
	multiprocess-20081120-branchpoint:1.3
	sid-snapshot-20081101:1.3
	binutils-2_19:1.3
	sid-snapshot-20081001:1.3
	reverse-20080930-branch:1.3.0.14
	reverse-20080930-branchpoint:1.3
	binutils-2_19-branch:1.3.0.12
	binutils-2_19-branchpoint:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	reverse-20080717-branch:1.3.0.10
	reverse-20080717-branchpoint:1.3
	sid-snapshot-20080701:1.3
	msnyder-reverse-20080609-branch:1.3.0.8
	msnyder-reverse-20080609-branchpoint:1.3
	drow-reverse-20070409-branch:1.1.0.4
	drow-reverse-20070409-branchpoint:1.1
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-2008-03-27-release:1.3
	sid-snapshot-20080301:1.3
	gdb_6_8-branch:1.3.0.6
	gdb_6_8-2008-02-26-branchpoint:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	sid-snapshot-20071001:1.3
	gdb_6_7-branch:1.3.0.4
	gdb_6_7-2007-09-07-branchpoint:1.3
	binutils-2_18:1.3
	binutils-2_18-branch:1.3.0.2
	binutils-2_18-branchpoint:1.3
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1
	binutils_latest_snapshot:1.10;
locks; strict;
comment	@ * @;


1.10
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.08.15.54.18;	author ktietz;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.15.17.27.30;	author ktietz;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.14.20.40.39;	author ktietz;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.27.17.26.09;	author ktietz;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.21.02.13.47;	author davek;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.18.18.23.07;	author davek;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.20.11.35.07;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for Intel 386 PE IMAGE COFF files.
   Copyright 2006, 2007, 2009 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.

   Written by Kai Tietz, OneVision Software GmbH&CoKg.  */

#include "sysdep.h"
#include "bfd.h"

#define TARGET_SYM 		x86_64pei_vec
#define TARGET_NAME 		"pei-x86-64"
#define COFF_IMAGE_WITH_PE
#define COFF_WITH_PE
#define COFF_WITH_pex64
#define PCRELOFFSET 		TRUE
#if defined (USE_MINGW64_LEADING_UNDERSCORES)
#define TARGET_UNDERSCORE 	'_'
#else
#define TARGET_UNDERSCORE 	0
#endif
/* Long section names not allowed in executable images, only object files.  */
#define COFF_LONG_SECTION_NAMES 0
#define COFF_SUPPORT_GNU_LINKONCE
#define COFF_LONG_FILENAMES
#define PDATA_ROW_SIZE	(3 * 4)

#define COFF_SECTION_ALIGNMENT_ENTRIES \
{ COFF_SECTION_NAME_EXACT_MATCH (".bss"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".data"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".rdata"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".text"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".idata"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".pdata"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".debug"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_PARTIAL_MATCH (".gnu.linkonce.wi."), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }

/* Note we have to make sure not to include headers twice.
   Not all headers are wrapped in #ifdef guards, so we define
   PEI_HEADERS to prevent double including in coff-x86_64.c  */
#define PEI_HEADERS
#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "coff/x86_64.h"
#include "coff/internal.h"
#include "coff/pe.h"
#include "libcoff.h"
#include "libpei.h"
#include "libiberty.h"

#undef AOUTSZ
#define AOUTSZ		PEPAOUTSZ
#define PEAOUTHDR	PEPAOUTHDR

static const char *pex_regs[16] = {
  "rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
  "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};

static void
pex64_get_runtime_function (bfd *abfd, struct pex64_runtime_function *rf,
			    const void *data)
{
  const struct external_pex64_runtime_function *ex_rf =
    (const struct external_pex64_runtime_function *) data;
  rf->rva_BeginAddress = bfd_get_32 (abfd, ex_rf->rva_BeginAddress);
  rf->rva_EndAddress = bfd_get_32 (abfd, ex_rf->rva_EndAddress);
  rf->rva_UnwindData =	bfd_get_32 (abfd, ex_rf->rva_UnwindData);
  rf->isChained = PEX64_IS_RUNTIME_FUNCTION_CHAINED (rf);
  rf->rva_UnwindData = PEX64_GET_UNWINDDATA_UNIFIED_RVA (rf);
}

static void
pex64_get_unwind_info (bfd *abfd, struct pex64_unwind_info *ui, void *data)
{
  struct external_pex64_unwind_info *ex_ui =
    (struct external_pex64_unwind_info *) data;
  bfd_byte *ex_dta = (bfd_byte *) data;

  memset (ui, 0, sizeof (struct pex64_unwind_info));
  ui->Version = PEX64_UWI_VERSION (ex_ui->Version_Flags);
  ui->Flags = PEX64_UWI_FLAGS (ex_ui->Version_Flags);
  ui->SizeOfPrologue = (bfd_vma) ex_ui->SizeOfPrologue;
  ui->CountOfCodes = (bfd_vma) ex_ui->CountOfCodes;
  ui->FrameRegister = PEX64_UWI_FRAMEREG (ex_ui->FrameRegisterOffset);
  ui->FrameOffset = PEX64_UWI_FRAMEOFF (ex_ui->FrameRegisterOffset);
  ui->sizeofUnwindCodes = PEX64_UWI_SIZEOF_UWCODE_ARRAY (ui->CountOfCodes);
  ui->SizeOfBlock = ui->sizeofUnwindCodes + 4;
  ui->rawUnwindCodes = &ex_dta[4];
  ex_dta += ui->SizeOfBlock;
  switch (ui->Flags)
    {
    case UNW_FLAG_CHAININFO:
      ui->rva_FunctionEntry = bfd_get_32 (abfd, ex_dta);
      ui->SizeOfBlock += 4;
      return;
    default:
      return;
    }
}

static void
pex64_xdata_print_uwd_codes (FILE *file, struct pex64_unwind_info *ui,
			     bfd_vma pc_addr)
{
  bfd_vma i;
  bfd_vma tmp = 0;
  const bfd_byte *insns[256];
  bfd_vma insns_count = 0;
  const bfd_byte *dta = ui->rawUnwindCodes;

  if (ui->CountOfCodes == 0 || !dta)
    return;

  /* Sort array ascending. Note: it is stored in reversed order.  */
  for (i = 0; i < ui->CountOfCodes; i++)
    {
      const bfd_byte *t;

      t = insns[insns_count++] = &dta[i * 2];
      switch (PEX64_UNWCODE_CODE (t[1]))
	{
	case UWOP_PUSH_NONVOL:
	case UWOP_ALLOC_SMALL:
	case UWOP_SET_FPREG:
	case UWOP_PUSH_MACHFRAME:
	  break;
	case UWOP_ALLOC_LARGE:
	  if (PEX64_UNWCODE_INFO (t[1]) == 0)
	    {
	      i += 1;
	      break;
	    }
	  else if (PEX64_UNWCODE_INFO (t[1]) == 1)
	    {
	      i += 2;
	      break;
	    }
	  /* fall through.  */
	default:
	  fprintf (file, "\t contains unknown code (%u).\n",
		   (unsigned int) PEX64_UNWCODE_CODE (t[1]));
	  return;
	case UWOP_SAVE_NONVOL:
	case UWOP_SAVE_XMM:
	case UWOP_SAVE_XMM128:
	  i++;
	  break;
	case UWOP_SAVE_NONVOL_FAR:
	case UWOP_SAVE_XMM_FAR:
	case UWOP_SAVE_XMM128_FAR:
	  i += 2;
	  break;
	}
    }
  fprintf (file, "\t At pc 0x");
  fprintf_vma (file, pc_addr);
  fprintf (file, " there are the following saves (in logical order).\n");
  for (i = insns_count; i > 0;)
    {
      --i;
      dta = insns[i];
      fprintf (file, "\t  insn ends at pc+0x%02x: ", (unsigned int) dta[0]);
      switch (PEX64_UNWCODE_CODE (dta[1]))
	{
	case UWOP_PUSH_NONVOL:
	  fprintf (file, "push %s.\n", pex_regs[PEX64_UNWCODE_INFO (dta[1])]);
	  break;
	case UWOP_ALLOC_LARGE:
	  if (PEX64_UNWCODE_INFO (dta[1]) == 0)
	    {
	      tmp = (bfd_vma) (*((unsigned short *) &dta[2]));
	      tmp *= 8;
	    }
	  else
	    tmp = (bfd_vma) (*((unsigned int *)&dta[2]));
	  fprintf (file, "save stack region of size 0x");
	  fprintf_vma (file, tmp);
	  fprintf (file,".\n");
	  break;
	case UWOP_ALLOC_SMALL:
	  tmp = (bfd_vma) PEX64_UNWCODE_INFO (dta[1]);
	  tmp += 1;
	  tmp *= 8;
	  fprintf (file, "save stack region of size 0x");
	  fprintf_vma (file, tmp);
	  fprintf (file,".\n");
	  break;
	case UWOP_SET_FPREG:
	  tmp = (bfd_vma) PEX64_UNWCODE_INFO (dta[1]);
	  tmp *= 16;
	  fprintf (file, "FPReg = (FrameReg) + 0x");
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_NONVOL:
	  fprintf (file, "mov %s at 0x",
		   pex_regs[PEX64_UNWCODE_INFO (dta[1])]);
	  tmp = (bfd_vma) (*((unsigned short *) &dta[2]));
	  tmp *= 8;
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_NONVOL_FAR:
	  fprintf (file, "mov %s at 0x",
		   pex_regs[PEX64_UNWCODE_INFO (dta[1])]);
	  tmp = (bfd_vma) (*((unsigned int *) &dta[2]));
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_XMM:
	  tmp = (bfd_vma) (*((unsigned short *) &dta[2]));
	  tmp *= 8;
	  fprintf (file, "mov mm%u at 0x",
		   (unsigned int) PEX64_UNWCODE_INFO (dta[1]));
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_XMM_FAR:
	  tmp = (bfd_vma) (*((unsigned int *) &dta[2]));
	  fprintf (file, "mov mm%u at 0x",
		   (unsigned int) PEX64_UNWCODE_INFO (dta[1]));
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_XMM128:
	  tmp = (bfd_vma) (*((unsigned short *) &dta[2]));
	  tmp *= 16;
	  fprintf (file, "mov xmm%u at 0x",
		   (unsigned int) PEX64_UNWCODE_INFO ( dta[1]));
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_SAVE_XMM128_FAR:
	  tmp = (bfd_vma) (*((unsigned int *) &dta[2]));
	  fprintf (file, "mov xmm%u at 0x",
		   (unsigned int) PEX64_UNWCODE_INFO (dta[1]));
	  fprintf_vma (file, tmp);
	  fprintf (file, ".\n");
	  break;
	case UWOP_PUSH_MACHFRAME:
	  fprintf (file, "interrupt entry (SS, old RSP, EFLAGS, CS, RIP");
	  if (PEX64_UNWCODE_INFO (dta[1]) == 0)
	    {
	      fprintf (file, ")");
	    }
	  else if (PEX64_UNWCODE_INFO (dta[1]) == 1)
	    {
	      fprintf (file, ",ErrorCode)");
	    }
	  else
	    fprintf (file, ", unknown(%u))",
		     (unsigned int) PEX64_UNWCODE_INFO (dta[1]));
	  fprintf (file,".\n");
	  break;
	default:
	  fprintf (file, "unknown code %u.\n",
		   (unsigned int) PEX64_UNWCODE_INFO (dta[1]));
	  break;
      }
    }
}

static asection *
pex64_get_section_by_rva (bfd *abfd, bfd_vma addr, const char *sec_name)
{
  asection *section = bfd_get_section_by_name (abfd, sec_name);
  bfd_vma vsize;
  bfd_size_type datasize = 0;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return NULL;
  vsize = section->vma - pe_data (abfd)->pe_opthdr.ImageBase;
  datasize = section->size;
  if (!datasize || vsize > addr || (vsize + datasize) < addr)
    return NULL;
  return section;
}

static void
pex64_dump_xdata (FILE *file, bfd *abfd, bfd_vma addr, bfd_vma pc_addr,
		  bfd_vma *endx)
{
  asection *section = pex64_get_section_by_rva (abfd, addr, ".rdata");
  bfd_vma vsize;
  bfd_byte *data = NULL;
  bfd_vma end_addr;

  if (!section)
    section = pex64_get_section_by_rva (abfd, addr, ".data");
  if (!section)
    section = pex64_get_section_by_rva (abfd, addr, ".xdata");
  if (!section)
    {
      section = pex64_get_section_by_rva (abfd, addr, ".pdata");
      if (section)
	{
	  fprintf (file, "\t Shares information with pdata element at 0x");
	  fprintf_vma (file, addr + pe_data (abfd)->pe_opthdr.ImageBase);
	  fprintf (file, ".\n");
	}
    }
  if (!section)
    return;

  vsize = section->vma - pe_data (abfd)->pe_opthdr.ImageBase;
  addr -= vsize;

  if (endx)
    end_addr = endx[0] - vsize;
  else
    end_addr = (section->rawsize != 0 ? section->rawsize : section->size);

  if (bfd_malloc_and_get_section (abfd, section, &data))
    {
      struct pex64_unwind_info ui;

      if (!data)
	return;

      pex64_get_unwind_info (abfd, &ui, &data[addr]);

      if (ui.Version != 1)
	{
	  fprintf (file, "\tVersion %u (unknown).\n", (unsigned int) ui.Version);
	  return;
	}

      fprintf (file, "\tFlags: ");
      switch (ui.Flags)
	{
	case UNW_FLAG_NHANDLER:
	  fprintf (file, "UNW_FLAG_NHANDLER");
	  break;
	case UNW_FLAG_EHANDLER:
	  fprintf (file, "UNW_FLAG_EHANDLER");
	  break;
	case UNW_FLAG_UHANDLER:
	  fprintf (file, "UNW_FLAG_UHANDLER");
	  break;
	case UNW_FLAG_FHANDLER:
	  fprintf (file, "UNW_FLAG_FHANDLER = (UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER)");
	  break;
	case UNW_FLAG_CHAININFO:
	  fprintf (file, "UNW_FLAG_CHAININFO");
	  break;
	default:
	  fprintf (file, "unknown flags value 0x%x", (unsigned int) ui.Flags);
	  break;
	}
      fprintf (file, ".\n");
      if (ui.CountOfCodes != 0)
	fprintf (file, "\tEntry has %u codes.", (unsigned int) ui.CountOfCodes);
      fprintf (file, "\tPrologue size: %u, Frame offset = 0x%x.\n",
	       (unsigned int) ui.SizeOfPrologue, (unsigned int) ui.FrameOffset);
      fprintf (file, "\tFrame register is %s.\n",
	ui.FrameRegister == 0 ? "none"
			      : pex_regs[(unsigned int) ui.FrameRegister]);

      pex64_xdata_print_uwd_codes (file, &ui, pc_addr);

      /* Now we need end of this xdata block.  */
      addr += ui.SizeOfBlock;
      if (addr < end_addr)
        {
	  unsigned int i;
	  fprintf (file,"\tUser data:\n");
	  for (i = 0; addr < end_addr; addr += 1, i++)
	    {
	      if ((i & 15) == 0)
	        fprintf (file, "\t  %03x:", i);
	      fprintf (file, " %02x", data[addr]);
	      if ((i & 15) == 15)
	        fprintf (file, "\n");
	    }
	  if ((i & 15) != 0)
	    fprintf (file, "\n");
        }
    }
  if (data != NULL)
    free (data);
}

static int
sort_xdata_arr (const void *l, const void *r)
{
  const bfd_vma *lp = (const bfd_vma *) l;
  const bfd_vma *rp = (const bfd_vma *) r;

  if (*lp == *rp)
    return 0;
  return (*lp < *rp ? -1 : 1);
}

static bfd_boolean
pex64_bfd_print_pdata (bfd *abfd, void *vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = NULL;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type stop;
  bfd_vma prev_beginaddress = 0;
  int onaline = PDATA_ROW_SIZE;
  int seen_error = 0;
  bfd_vma *xdata_arr;
  int xdata_arr_cnt;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return TRUE;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     _("warning: .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));

  fprintf (file, _("vma:\t\t\tBeginAddress\t EndAddress\t  UnwindData\n"));

  datasize = section->size;
  if (datasize == 0)
    return TRUE;

  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  xdata_arr = (bfd_vma *) xmalloc (sizeof (bfd_vma) * ((stop / onaline) + 1));
  xdata_arr_cnt = 0;
  /* Do sanity check of pdata.  */
  for (i = 0; i < stop; i += onaline)
    {
      struct pex64_runtime_function rf;

      if (i + PDATA_ROW_SIZE > stop)
	break;
      pex64_get_runtime_function (abfd, &rf, &data[i]);

      if (rf.rva_BeginAddress == 0 && rf.rva_EndAddress == 0
	  && rf.rva_UnwindData == 0)
	/* We are probably into the padding of the section now.  */
	break;
      fputc (' ', file);
      fprintf_vma (file, i + section->vma);
      fprintf (file, ":\t");
      fprintf_vma (file, rf.rva_BeginAddress);
      fputc (' ', file);
      fprintf_vma (file, rf.rva_EndAddress);
      fputc (' ', file);
      fprintf_vma (file, rf.rva_UnwindData);
      fprintf (file, "\n");
      if (i != 0 && rf.rva_BeginAddress <= prev_beginaddress)
	{
	  seen_error = 1;
	  fprintf (file, "  has %s begin address as predecessor\n",
	    (rf.rva_BeginAddress < prev_beginaddress ? "smaller" : "same"));
        }
      prev_beginaddress = rf.rva_BeginAddress;
      /* Now we check for negative addresses.  */
      if ((prev_beginaddress & 0x80000000) != 0)
	{
	  seen_error = 1;
	  fprintf (file, "  has negative begin address\n");
	}
      if ((rf.rva_EndAddress & 0x80000000) != 0)
	{
	  seen_error = 1;
	  fprintf (file, "  has negative end address\n");
	}
      if ((rf.rva_UnwindData & 0x80000000) != 0)
	{
	  seen_error = 1;
	  fprintf (file, "  has negative unwind address\n");
	}
      if (rf.rva_UnwindData && !rf.isChained)
        xdata_arr[xdata_arr_cnt++] = rf.rva_UnwindData;
    }

  if (seen_error)
    {
      free (data);
      free (xdata_arr);

      return TRUE;
    }

  /* Add end of list marker.  */
  xdata_arr[xdata_arr_cnt++] = ~((bfd_vma) 0);

  /* Sort start RVAs of xdata.  */
  if (xdata_arr_cnt > 1)
    qsort (xdata_arr, (size_t) xdata_arr_cnt, sizeof (bfd_vma),
	   sort_xdata_arr);

  /* Do dump of pdata related xdata.  */

  for (i = 0; i < stop; i += onaline)
    {
      struct pex64_runtime_function rf;

      if (i + PDATA_ROW_SIZE > stop)
	break;
      pex64_get_runtime_function (abfd, &rf, &data[i]);

      if (rf.rva_BeginAddress == 0 && rf.rva_EndAddress == 0
	  && rf.rva_UnwindData == 0)
	/* We are probably into the padding of the section now.  */
	break;
      if (i == 0)
        fprintf (file, "\nDump of .xdata\n");
      fputc (' ', file);
      fprintf_vma (file, rf.rva_UnwindData);
      fprintf (file, ":\n");

      rf.rva_BeginAddress += pe_data (abfd)->pe_opthdr.ImageBase;
      rf.rva_EndAddress += pe_data (abfd)->pe_opthdr.ImageBase;

      if (rf.rva_UnwindData != 0)
	{
	  if (rf.isChained)
	    {
	      fprintf (file, "\t shares information with pdata element at 0x");
	      fprintf_vma (file, rf.rva_UnwindData);
	      fprintf (file, ".\n");
	    }
	  else
	    {
	      bfd_vma *p;

	      /* Search for the current entry in the sorted array.  */
	      p = (bfd_vma *)
	          bsearch (&rf.rva_UnwindData, xdata_arr,
			   (size_t) xdata_arr_cnt, sizeof (bfd_vma),
			   sort_xdata_arr);

	      /* Advance to the next pointer into the xdata section.  We may
		 have shared xdata entries, which will result in a string of
		 identical pointers in the array; advance past all of them.  */
	      while (p[0] <= rf.rva_UnwindData)
		++p;
	      if (p[0] == ~((bfd_vma) 0))
		p = NULL;

	      pex64_dump_xdata (file, abfd, rf.rva_UnwindData,
				rf.rva_BeginAddress, p);
	    }
	}
    }

  free (data);
  free (xdata_arr);

  return TRUE;
}

#define bfd_pe_print_pdata   pex64_bfd_print_pdata

#include "coff-x86_64.c"
@


1.9
log
@2010-10-08  Kai Tietz  <kai.tietz@@onevision.com>

	* pei-x86_64.c (find_next_xdata_or_end): Removed.
	(pex64_dump_xdata): Remove arguments stop, onaline,
	and pdata. New argument endx.  Print term "none"
	instead of misleading "CFA".
	(sort_xdata_arr): New function.
	(pex64_bfd_print_pdata): Use binary search/sort for unwind-RVAs
	instead of searching quadratic.
@
text
@d20 1
a20 1
   
d387 1
a387 1
      
@


1.8
log
@2010-09-15  Kai Tietz  <kai.tietz@@onevision.com>

        * pei-x86_64.c (pex64_get_unwind_info): Reorgnized.
        (pex64_get_scope_entry): Removed.
        (find_next_xdata_or_end): New helper.
        (pex64_dump_xdata): Reworked.
        (pex64_bfd_print_pdata): Add checking for
        valid pdata sorting and values. Reworked
        output.
@
text
@a305 32
static bfd_vma
find_next_xdata_or_end (bfd *abfd, bfd_byte *pdata, bfd_size_type stop,
			int onaline, bfd_vma cur_address, bfd_vma max_size)
{
  bfd_size_type i;
  bfd_vma ret = 0;

  for (i = 0; i < stop; i += onaline)
    {
      struct pex64_runtime_function rf;

      if (i + PDATA_ROW_SIZE > stop)
	break;
      pex64_get_runtime_function (abfd, &rf, &pdata[i]);

      if (rf.rva_BeginAddress == 0 && rf.rva_EndAddress == 0
	  && rf.rva_UnwindData == 0)
	/* We are probably into the padding of the section now.  */
	break;
      if (rf.rva_UnwindData != 0 && !rf.isChained)
        {
	  if (!ret && rf.rva_UnwindData > cur_address)
	    ret = rf.rva_UnwindData;
	  else if (rf.rva_UnwindData > cur_address && ret > rf.rva_UnwindData)
	    ret = rf.rva_UnwindData;
	}
    }
  if (!ret)
    return max_size;
  return ret;
}

d308 1
a308 1
		  bfd_size_type stop, int onaline, bfd_byte *pdata)
d335 4
a338 2
  end_addr = find_next_xdata_or_end (abfd, pdata, stop, onaline, addr + vsize,
  				     vsize + (section->rawsize != 0 ? section->rawsize : section->size));
a339 1
  end_addr -= vsize;
d383 1
a383 1
	ui.FrameRegister == 0 ? "CFA"
d410 11
d433 2
d463 2
d510 2
d517 1
d521 9
d562 20
a581 2
	    pex64_dump_xdata (file, abfd, rf.rva_UnwindData, rf.rva_BeginAddress,
	    		      stop, onaline, data);
d586 1
@


1.7
log
@2010-09-14  Kai Tietz  <kai.tietz@@onevision.com>

        * pe-x86_64.c (COFF_SECTION_ALIGNMENT_ENTRIES): Make
        .rdata, .data, and .text partial matched section names.
        * pei-x86_64.c: Likewise.
@
text
@a116 11
    case UNW_FLAG_EHANDLER:
      ui->rva_ExceptionHandler = bfd_get_32 (abfd, ex_dta);
      break;
    case UNW_FLAG_UHANDLER:
      ui->rva_TerminationHandler = bfd_get_32 (abfd, ex_dta);
      break;
    case UNW_FLAG_FHANDLER:
      ui->rva_FrameHandler = bfd_get_32 (abfd, ex_dta);
      ui->FrameHandlerArgument = bfd_get_32 (abfd, ex_dta + 4);
      ui->SizeOfBlock += 8;
      return;
a123 20
  ex_dta += 4;
  ui->SizeOfBlock += 8;
  ui->CountOfScopes = bfd_get_32 (abfd, ex_dta);
  ex_dta += 4;
  ui->rawScopeEntries = ex_dta;
  ui->SizeOfBlock += (ui->CountOfScopes * PEX64_SCOPE_ENTRY_SIZE);
}

static void
pex64_get_scope_entry (bfd *abfd, struct pex64_scope_entry *se,
		       bfd_vma idx, const bfd_byte *x)
{
  const struct external_pex64_scope_entry *ex_se;
  x += (idx * PEX64_SCOPE_ENTRY_SIZE);
  ex_se = (const struct external_pex64_scope_entry *) x;
  memset (se, 0, sizeof (struct pex64_scope_entry));
  se->rva_BeginAddress = bfd_get_32 (abfd, ex_se->rva_BeginAddress);
  se->rva_EndAddress = bfd_get_32 (abfd, ex_se->rva_EndAddress);
  se->rva_HandlerAddress = bfd_get_32 (abfd, ex_se->rva_HandlerAddress);
  se->rva_JumpAddress = bfd_get_32 (abfd, ex_se->rva_JumpAddress);
d306 32
d339 2
a340 1
pex64_dump_xdata (FILE *file, bfd *abfd, bfd_vma addr, bfd_vma pc_addr)
d345 1
a345 1
  bfd_vma i;
d363 1
d366 5
d419 17
a435 34
      switch (ui.Flags)
	{
	case UNW_FLAG_NHANDLER:
	  return;
	case UNW_FLAG_EHANDLER:
	  fprintf (file, "\texception_handler at 0x%x.\n", (unsigned int) ui.rva_ExceptionHandler);
	  break;
	case UNW_FLAG_UHANDLER:
	  fprintf (file, "\ttermination_handler at 0x%x.\n", (unsigned int) ui.rva_TerminationHandler);
	case UNW_FLAG_FHANDLER:
	  fprintf (file, "\tframe_handler at 0x%x.\n", (unsigned int) ui.rva_FrameHandler);
	  fprintf (file, "\t Argument for FrameHandler: 0x%x.\n",
		   (unsigned int) ui.FrameHandlerArgument);
	  return;
	case UNW_FLAG_CHAININFO:
	  fprintf (file, "\t Function Entry: 0x%x\n", (unsigned int) ui.rva_FunctionEntry);
	  return;
	default:
	  fprintf (file, "\t Unknown flag value of 0x%x\n", (unsigned int) ui.Flags);
	  return;
	}
      fprintf (file, "\t 0x%x # of scope(s)\n", (unsigned int) ui.CountOfScopes);
      for (i = 0; i < ui.CountOfScopes; i++)
	{
	  struct pex64_scope_entry se;
	  pex64_get_scope_entry (abfd, &se, i, ui.rawScopeEntries);
	  fprintf (file, "\t scope #%u: BeginAddress: 0x%x, EndAddress: 0x%x,"
		   "\n\t\tHandlerAddress:0x%x, JumpTarget:0x%x\n",
		   (unsigned int) (i + 1),
		   (unsigned int) se.rva_BeginAddress,
		   (unsigned int) se.rva_EndAddress,
		   (unsigned int) se.rva_HandlerAddress,
		   (unsigned int) se.rva_JumpAddress);
	}
d449 2
a450 1
  bfd_size_type start, stop;
d452 1
d481 2
a482 3
  start = 0;

  for (i = start; i < stop; i += onaline)
a493 1

a496 1
      rf.rva_BeginAddress += pe_data (abfd)->pe_opthdr.ImageBase;
a498 1
      rf.rva_EndAddress += pe_data (abfd)->pe_opthdr.ImageBase;
d503 53
d562 1
a562 1
	      fprintf_vma (file, rf.rva_UnwindData + pe_data (abfd)->pe_opthdr.ImageBase);
d566 2
a567 1
	    pex64_dump_xdata (file, abfd, rf.rva_UnwindData, rf.rva_BeginAddress);
@


1.6
log
@2010-04-27  Kai Tietz  <kai.tietz@@onevision.com>

	* pe-x86_64.c (TARGET_UNDERSCORE): Set value dependent
	to USE_MINGW64_LEADING_UNDERSCORES.
        * pei-x86_64.c (TARGET_UNDERSCORE): Likewise.
	* config.bfd: Change underscoring default for x64 mingw
	to false.
	* coffcode.h (coff_write_relocs): Add check that dereferenced
	sym_ptr_ptr isn't NULL.
	* config.in (USE_MINGW64_LEADING_UNDERSCORES): New.
	* configure: Regenerated.
	* configure.in: Add option '--enable-leading-mingw64-underscores'
	and define config.in variable USE_MINGW64_LEADING_UNDERSCORES.
@
text
@d46 1
a46 1
{ COFF_SECTION_NAME_EXACT_MATCH (".data"), \
d48 1
a48 1
{ COFF_SECTION_NAME_EXACT_MATCH (".rdata"), \
d50 1
a50 1
{ COFF_SECTION_NAME_EXACT_MATCH (".text"), \
@


1.5
log
@bfd/ChangeLog

2009-04-21  Kai Tietz  <kai.tietz@@onevision.com>

	* coff-x86_64.c (PEI_HEADERS): Protect includes.
	(bfd_pe_print_pdata): Remove #ifdef PE variation.
	* pei-x86_64.c (PEI_HEADERS): Define to prevent double
	include in coff-x86_64.c of headers.
	(PDATA_ROW_SIZE): New define.
	(pex_regs[]): New static array.
	(pex64_get_runtime_function): New static function.
	(pex64_get_unwind_info): Likewise.
	(pex64_get_scope_entry): Likewise.
	(pex64_xdata_print_uwd_codes): Likewise.
	(pep_get_section_by_rva): Likewise.
	(pex64_dump_xdata): Likewise.
	(pex64_bfd_print_pdata): Likewise.
	(bfd_pe_print_pdata): Define as pex64_bfd_print_pdata.
	* peXXigen.c (_bfd_pex64_print_pdata): Removed implementation.
	* libpei.h (_bfd_pex64_print_pdata): Removed declaration.

include/ChangeLog

2009-04-21  Kai Tietz  <kai.tietz@@onevision.com>

	* coff/pe.h (pex64_runtime_function): New structure.
	(external_pex64_runtime_function): Likewise.
	(pex64_unwind_code): Likewise.
	(external_pex64_unwind_code): Likewise.
	(pex64_unwind_info): Likewise.
	(external_pex64_unwind_info): Likewise.
	(external_pex64_scope): Likewise.
	(pex64_scope): Likewise.
	(pex64_scope_entry):  Likewise.
	(external_pex64_scope_entry): Likewise.
	(PEX64_IS_RUNTIME_FUNCTION_CHAINED): New macro.
	(PEX64_GET_UNWINDDATA_UNIFIED_RVA): Likewise.
	(PEX64_UNWCODE_CODE): Likewise.
	(PEX64_UNWCODE_INFO): Likewise.
	(UWOP_...): Add defines for unwind code.
	(UNW_FLAG_...): Add defined for unwind info flags.
	(PEX64_SCOPE_ENTRY_SIZE): New macro.
	(PEX64_UWI_VERSION): Likewise.
	(PEX64_UWI_FLAGS): Likewise.
	(PEX64_UWI_FRAMEREG): Likewise.
	(PEX64_UWI_FRAMEOFF): Likewise.
	(PEX64_UWI_SIZEOF_UWCODE_ARRAY): Likewise.
	(PEX64_OFFSET_TO_UNWIND_CODE): Likewise.
	(PEX64_OFFSET_TO_HANDLER_RVA): Likewise.
	(PEX64_OFFSET_TO_SCOPE_COUNT): Likewise.
	(PEX64_SCOPE_ENTRY): Likewise.
@
text
@d32 1
d34 3
@


1.4
log
@bfd/ChangeLog

	* coff-alpha.c (alpha_ecoff_backend_data):  Initialise fields which
	control long section name handling with ECOFF_NO_LONG_SECTION_NAMES.
	* coff-mips.c (mips_ecoff_backend_data):  Likewise.
	* coff-rs6000.c (bfd_xcoff_backend_data):  Initialise fields which
	control long section name handling with XCOFF_NO_LONG_SECTION_NAMES.
	(bfd_pmac_xcoff_backend_data):  Likewise.
	* coff64-rs6000.c (bfd_xcoff_backend_data):  Likewise.
	(bfd_xcoff_aix5_backend_data):  Likewise.
	(xcoff64_write_object_contents):  Delete unused long_section_names
	local variable.
	* coff-sh.c (bfd_coff_small_swap_table):  Initialise long section
	name members using COFF_DEFAULT_LONG_SECTION_NAMES and make entire
	struct non-const.
	* coffcode.h (documentation):  Update to describe long section names.
	(COFFLONGSECTIONCATHELPER):  New helper macro.
	(BLANKOR1TOODD):  Likewise.
	(COFF_ENABLE_LONG_SECTION_NAMES):  Likewise.
	(COFF_LONG_SECTION_NAMES_SETTER):  Likewise.
	(COFF_DEFAULT_LONG_SECTION_NAMES):  Likewise.
	(bfd_coff_set_long_section_names_allowed):  New function.
	(bfd_coff_set_long_section_names_disallowed):  Likewise.
	(struct bfd_coff_backend_data):  Add new backend hook function
	pointer _bfd_coff_set_long_section_names.
	(bfd_coff_set_long_section_names):  New backend hook.
	(coff_write_object_contents):  Only generate long section names if
	bfd_coff_long_section_names() indicates they are currently enabled.
	(bfd_coff_std_swap_table):  Make non-const, and initialise long
	section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff0_swap_table):  Likewise to both.
	(ticoff1_swap_table):  Again, likewise to both.
	* coffgen.c (make_a_section_from_file):  Allow long section names
	as inputs even if not currently allowed for outputs.
	* ecoff.c (_bfd_ecoff_no_long_sections):  New function.
	* efi-app-ia32.c (COFF_LONG_SECTION_NAMES):  Define to 0, not blank.
	* efi-app-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-app-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-bsdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia32.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-ia64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* efi-rtdrv-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-arm.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-i386.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mcore.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-mips.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-ppc.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-sh.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* pei-x86_64.c (COFF_LONG_SECTION_NAMES):  Likewise.
	* libcoff-in.h:  Update copyright year to cause updated copyright
	year in generated libcoff.h, and fix typo.
	* libcoff.h:  Regenerated.
	* libecoff.h (ECOFF_NO_LONG_SECTION_NAMES):  New macro.
	(_bfd_ecoff_no_long_sections):  Add prototype.
	* libxcoff.h (XCOFF_NO_LONG_SECTION_NAMES):  New macro.
	* pe-mips.c (COFF_LONG_SECTION_NAMES):  Define empty if not already
	defined by an including .c file.
	* ticoff.h (ticoff0_swap_table):  Make non-const, and initialise
	long section name fields using COFF_DEFAULT_LONG_SECTION_NAMES.
	(ticoff1_swap_table):  Likewise to both.

ld/ChangeLog

	* ld.texinfo:  Update to mention long section name options.
	* NEWS:  Mention new behaviour and command-line options.
	* pe-dll.c (pe_use_coff_long_section_names):  New global variable.
	(pe_output_file_set_long_section_names):  New function.
	(pe_dll_build_sections):  Call it on output BFDs.
	(pe_exe_build_sections):  Likewise.
	(pe_dll_fill_sections):  Likewise.
	(pe_exe_fill_sections):  Likewise.
	* pe-dll.h (pe_use_coff_long_section_names):  Declare extern.
	(pe_output_file_set_long_section_names):  Add prototype.
	* pep-dll.c (pe_use_coff_long_section_names):  Define pep_ alias.
	(pe_output_file_set_long_section_names):  Likewise.
	* pep-dll.h (pep_use_coff_long_section_names):  Declare extern.
	(pep_output_file_set_long_section_names):  Add prototype.
	* pe.em (OPTION_ENABLE_LONG_SECTION_NAMES):  New getopt value macro.
	(OPTION_DISABLE_LONG_SECTION_NAMES):  Likewise.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pe_output_file_set_long_section_names.
	* pep.em (enum options):  Extend enum with new getopt option values.
	(gld${EMULATION_NAME}_add_options):  Add new options to xtra_long[].
	(gld_${EMULATION_NAME}_list_options):  Describe them.
	(gld${EMULATION_NAME}_handle_option):  Set or clear global
	pe_use_coff_long_section_names flag when options recognised.
	(gld_${EMULATION_NAME}_after_open):  En/disable long section names
	for main output bfd by calling pep_output_file_set_long_section_names.

ld/testsuite/ChangeLog

	* ld-pe/longsecn-1.d:  New test file.
	* ld-pe/longsecn-2.d:  Likewise.
	* ld-pe/longsecn-3.d:  Likewise.
	* ld-pe/longsecn-4.d:  Likewise.
	* ld-pe/longsecn-5.d:  Likewise.
	* ld-pe/longsecn.d:  Likewise.
	* ld-pe/longsecn.exp:  New test control script.
	* ld-pe/longsecn.s:  New test source file.
@
text
@d37 1
d57 474
@


1.3
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 2006, 2007 Free Software Foundation, Inc.
d33 2
a34 1
#define COFF_LONG_SECTION_NAMES
@


1.2
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2 of the License, or
d18 2
a19 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.1
log
@Add x86_64-mingw64 target
@
text
@d2 1
a2 1
   Copyright 2006 Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@

