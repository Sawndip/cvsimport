head	1.27;
access;
symbols
	sid-snapshot-20180601:1.27
	sid-snapshot-20180501:1.27
	sid-snapshot-20180401:1.27
	sid-snapshot-20180301:1.27
	sid-snapshot-20180201:1.27
	sid-snapshot-20180101:1.27
	sid-snapshot-20171201:1.27
	sid-snapshot-20171101:1.27
	sid-snapshot-20171001:1.27
	sid-snapshot-20170901:1.27
	sid-snapshot-20170801:1.27
	sid-snapshot-20170701:1.27
	sid-snapshot-20170601:1.27
	sid-snapshot-20170501:1.27
	sid-snapshot-20170401:1.27
	sid-snapshot-20170301:1.27
	sid-snapshot-20170201:1.27
	sid-snapshot-20170101:1.27
	sid-snapshot-20161201:1.27
	sid-snapshot-20161101:1.27
	sid-snapshot-20160901:1.27
	sid-snapshot-20160801:1.27
	sid-snapshot-20160701:1.27
	sid-snapshot-20160601:1.27
	sid-snapshot-20160501:1.27
	sid-snapshot-20160401:1.27
	sid-snapshot-20160301:1.27
	sid-snapshot-20160201:1.27
	sid-snapshot-20160101:1.27
	sid-snapshot-20151201:1.27
	sid-snapshot-20151101:1.27
	sid-snapshot-20151001:1.27
	sid-snapshot-20150901:1.27
	sid-snapshot-20150801:1.27
	sid-snapshot-20150701:1.27
	sid-snapshot-20150601:1.27
	sid-snapshot-20150501:1.27
	sid-snapshot-20150401:1.27
	sid-snapshot-20150301:1.27
	sid-snapshot-20150201:1.27
	sid-snapshot-20150101:1.27
	sid-snapshot-20141201:1.27
	sid-snapshot-20141101:1.27
	sid-snapshot-20141001:1.27
	sid-snapshot-20140901:1.27
	sid-snapshot-20140801:1.27
	sid-snapshot-20140701:1.27
	sid-snapshot-20140601:1.27
	sid-snapshot-20140501:1.27
	sid-snapshot-20140401:1.27
	sid-snapshot-20140301:1.27
	sid-snapshot-20140201:1.27
	sid-snapshot-20140101:1.27
	sid-snapshot-20131201:1.27
	sid-snapshot-20131101:1.27
	sid-snapshot-20131001:1.27
	binutils-2_24-branch:1.27.0.4
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.25
	sid-snapshot-20130901:1.27
	gdb_7_6_1-2013-08-30-release:1.27
	sid-snapshot-20130801:1.27
	sid-snapshot-20130701:1.27
	sid-snapshot-20130601:1.27
	sid-snapshot-20130501:1.27
	gdb_7_6-2013-04-26-release:1.27
	sid-snapshot-20130401:1.27
	binutils-2_23_2:1.26
	gdb_7_6-branch:1.27.0.2
	gdb_7_6-2013-03-12-branchpoint:1.27
	sid-snapshot-20130301:1.27
	sid-snapshot-20130201:1.27
	sid-snapshot-20130101:1.26
	sid-snapshot-20121201:1.26
	gdb_7_5_1-2012-11-29-release:1.26
	binutils-2_23_1:1.26
	sid-snapshot-20121101:1.26
	binutils-2_23:1.26
	sid-snapshot-20121001:1.26
	sid-snapshot-20120901:1.26
	gdb_7_5-2012-08-17-release:1.26
	sid-snapshot-20120801:1.26
	binutils-2_23-branch:1.26.0.4
	binutils-2_23-branchpoint:1.26
	gdb_7_5-branch:1.26.0.2
	gdb_7_5-2012-07-18-branchpoint:1.26
	sid-snapshot-20120701:1.25
	sid-snapshot-20120601:1.25
	sid-snapshot-20120501:1.25
	binutils-2_22_branch:1.25.0.14
	gdb_7_4_1-2012-04-26-release:1.25
	sid-snapshot-20120401:1.25
	sid-snapshot-20120301:1.25
	sid-snapshot-20120201:1.25
	gdb_7_4-2012-01-24-release:1.25
	sid-snapshot-20120101:1.25
	gdb_7_4-branch:1.25.0.12
	gdb_7_4-2011-12-13-branchpoint:1.25
	sid-snapshot-20111201:1.25
	binutils-2_22:1.25
	sid-snapshot-20111101:1.25
	sid-snapshot-20111001:1.25
	binutils-2_22-branch:1.25.0.10
	binutils-2_22-branchpoint:1.25
	gdb_7_3_1-2011-09-04-release:1.25
	sid-snapshot-20110901:1.25
	sid-snapshot-20110801:1.25
	gdb_7_3-2011-07-26-release:1.25
	sid-snapshot-20110701:1.25
	sid-snapshot-20110601:1.25
	sid-snapshot-20110501:1.25
	gdb_7_3-branch:1.25.0.8
	gdb_7_3-2011-04-01-branchpoint:1.25
	sid-snapshot-20110401:1.25
	sid-snapshot-20110301:1.25
	sid-snapshot-20110201:1.25
	sid-snapshot-20110101:1.25
	binutils-2_21:1.25
	sid-snapshot-20101201:1.25
	binutils-2_21-branch:1.25.0.6
	binutils-2_21-branchpoint:1.25
	sid-snapshot-20101101:1.25
	sid-snapshot-20101001:1.25
	binutils-2_20_1:1.24
	gdb_7_2-2010-09-02-release:1.25
	sid-snapshot-20100901:1.25
	sid-snapshot-20100801:1.25
	gdb_7_2-branch:1.25.0.4
	gdb_7_2-2010-07-07-branchpoint:1.25
	sid-snapshot-20100701:1.25
	sid-snapshot-20100601:1.25
	sid-snapshot-20100501:1.25
	sid-snapshot-20100401:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.2
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.24
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.24
	gdb_7_0-2009-10-06-release:1.24
	sid-snapshot-20091001:1.25
	gdb_7_0-branch:1.24.0.20
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.23
	binutils-arc-20081103-branch:1.24.0.18
	binutils-arc-20081103-branchpoint:1.24
	binutils-2_20-branch:1.24.0.16
	binutils-2_20-branchpoint:1.24
	sid-snapshot-20090901:1.24
	sid-snapshot-20090801:1.24
	msnyder-checkpoint-072509-branch:1.24.0.14
	msnyder-checkpoint-072509-branchpoint:1.24
	sid-snapshot-20090701:1.24
	dje-cgen-play1-branch:1.24.0.12
	dje-cgen-play1-branchpoint:1.24
	sid-snapshot-20090601:1.24
	sid-snapshot-20090501:1.24
	sid-snapshot-20090401:1.24
	arc-20081103-branch:1.24.0.10
	arc-20081103-branchpoint:1.24
	arc-insight_6_8-branch:1.23.0.14
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.12
	insight_6_8-branchpoint:1.23
	sid-snapshot-20090301:1.24
	binutils-2_19_1:1.24
	sid-snapshot-20090201:1.24
	sid-snapshot-20090101:1.24
	reverse-20081226-branch:1.24.0.8
	reverse-20081226-branchpoint:1.24
	sid-snapshot-20081201:1.24
	multiprocess-20081120-branch:1.24.0.6
	multiprocess-20081120-branchpoint:1.24
	sid-snapshot-20081101:1.24
	binutils-2_19:1.24
	sid-snapshot-20081001:1.24
	reverse-20080930-branch:1.24.0.4
	reverse-20080930-branchpoint:1.24
	binutils-2_19-branch:1.24.0.2
	binutils-2_19-branchpoint:1.24
	sid-snapshot-20080901:1.24
	sid-snapshot-20080801:1.24
	reverse-20080717-branch:1.23.0.10
	reverse-20080717-branchpoint:1.23
	sid-snapshot-20080701:1.23
	msnyder-reverse-20080609-branch:1.23.0.8
	msnyder-reverse-20080609-branchpoint:1.23
	drow-reverse-20070409-branch:1.21.0.8
	drow-reverse-20070409-branchpoint:1.21
	sid-snapshot-20080601:1.23
	sid-snapshot-20080501:1.23
	sid-snapshot-20080403:1.23
	sid-snapshot-20080401:1.23
	gdb_6_8-2008-03-27-release:1.23
	sid-snapshot-20080301:1.23
	gdb_6_8-branch:1.23.0.6
	gdb_6_8-2008-02-26-branchpoint:1.23
	sid-snapshot-20080201:1.23
	sid-snapshot-20080101:1.23
	sid-snapshot-20071201:1.23
	sid-snapshot-20071101:1.23
	gdb_6_7_1-2007-10-29-release:1.23
	gdb_6_7-2007-10-10-release:1.23
	sid-snapshot-20071001:1.23
	gdb_6_7-branch:1.23.0.4
	gdb_6_7-2007-09-07-branchpoint:1.23
	binutils-2_18:1.23
	binutils-2_18-branch:1.23.0.2
	binutils-2_18-branchpoint:1.23
	insight_6_6-20070208-release:1.21
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	gdb_6_6-2006-12-18-release:1.21
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	gdb_6_6-branch:1.21.0.6
	gdb_6_6-2006-11-15-branchpoint:1.21
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	insight_6_5-20061003-release:1.21
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.21
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.21
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.21.0.4
	gdb_6_5-2006-05-14-branchpoint:1.21
	binutils-csl-coldfire-4_1-10:1.20
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.21.0.2
	nickrob-async-20060513-branchpoint:1.21
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.10
	msnyder-reverse-20060502-branchpoint:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.16
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.16
	readline_5_1-import-branch:1.20.0.8
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.20.0.6
	binutils-2_17-branchpoint:1.20
	gdb-csl-symbian-20060226-branch:1.19.0.14
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.20.0.4
	msnyder-reverse-20060331-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.2
	binutils-csl-2_17-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.19.0.12
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.10
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.8
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.4
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.2
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.16.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	msnyder-tracepoint-checkpoint-branch:1.18.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.18
	gdb-csl-arm-20050325-2005-q1b:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	binutils-csl-arm-2005q1a:1.16
	csl-arm-20050325-branch:1.16.0.6
	csl-arm-20050325-branchpoint:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.14
	gdb_6_3-20041109-release:1.14
	gdb_6_3-branch:1.14.0.2
	gdb_6_3-20041019-branchpoint:1.14
	csl-arm-2004-q3:1.14
	drow_intercu-merge-20040921:1.14
	drow_intercu-merge-20040915:1.14
	jimb-gdb_6_2-e500-branch:1.13.0.6
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.14
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.12
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.8
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	drow-cplus-merge-20040113:1.12
	csl-arm-2003-q4:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.11.0.6
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.4
	cagney_x86i386-20030821-branch:1.11.0.2
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.10.0.36
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.10
	binutils-2_14:1.10
	cagney_convert-20030606-branch:1.10.0.32
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.30
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.26
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	binutils-2_14-branch:1.10.0.22
	binutils-2_14-branchpoint:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.20
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.18
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.16
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.14
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.12
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.10
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.8
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.6
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.4
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.2
	cagney-unwind-20030108-branchpoint:1.10
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.14
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.12
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.10
	gdb_5_3-branch:1.8.0.8
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.6
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.4
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	kseitz_interps-20020528-branch:1.6.0.10
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.8
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.13.14.22.45;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.25.19.13.26;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.04.05.05.25;	author bje;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.06.19.21.13;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.15.53.07;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.07.19.21;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.11.40.59;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.31.23.13.18;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.13.03.15.55;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.24.06.12.24;	author cgd;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.16.16.25.06;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.25.06.21.51;	author amodra;	state Exp;
branches
	1.8.12.1
	1.8.14.1;
next	1.7;

1.7
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches
	1.6.8.1
	1.6.10.1;
next	1.5;

1.5
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.22.00.56.55;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.12.10.29.02;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.12.8.1
date	2004.09.16.17.00.19;	author drow;	state Exp;
branches;
next	;

1.8.12.1
date	2002.12.23.19.37.36;	author carlton;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.06.27.21.49.10;	author carlton;	state Exp;
branches;
next	1.8.12.3;

1.8.12.3
date	2003.12.15.23.59.18;	author carlton;	state Exp;
branches;
next	;

1.8.14.1
date	2003.12.14.20.26.37;	author drow;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.15.16.42.36;	author cagney;	state Exp;
branches;
next	;

1.6.10.1
date	2002.06.20.01.29.59;	author kseitz;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2002.07.22.21.46.41;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* Routines to link ECOFF debugging information.
   Copyright 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2012  Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support, <ian@@cygnus.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "objalloc.h"
#include "aout/stab_gnu.h"
#include "coff/internal.h"
#include "coff/sym.h"
#include "coff/symconst.h"
#include "coff/ecoff.h"
#include "libcoff.h"
#include "libecoff.h"

/* Routines to swap auxiliary information in and out.  I am assuming
   that the auxiliary information format is always going to be target
   independent.  */

/* Swap in a type information record.
   BIGEND says whether AUX symbols are big-endian or little-endian; this
   info comes from the file header record (fh-fBigendian).  */

void
_bfd_ecoff_swap_tir_in (int bigend, const struct tir_ext *ext_copy,
			TIR *intern)
{
  struct tir_ext ext[1];

  *ext = *ext_copy;		/* Make it reasonable to do in-place.  */

  /* now the fun stuff...  */
  if (bigend)
    {
      intern->fBitfield   = 0 != (ext->t_bits1[0] & TIR_BITS1_FBITFIELD_BIG);
      intern->continued   = 0 != (ext->t_bits1[0] & TIR_BITS1_CONTINUED_BIG);
      intern->bt          = (ext->t_bits1[0] & TIR_BITS1_BT_BIG)
                          >>                   TIR_BITS1_BT_SH_BIG;
      intern->tq4         = (ext->t_tq45[0] & TIR_BITS_TQ4_BIG)
			  >>		      TIR_BITS_TQ4_SH_BIG;
      intern->tq5         = (ext->t_tq45[0] & TIR_BITS_TQ5_BIG)
			  >>		      TIR_BITS_TQ5_SH_BIG;
      intern->tq0         = (ext->t_tq01[0] & TIR_BITS_TQ0_BIG)
			  >>		      TIR_BITS_TQ0_SH_BIG;
      intern->tq1         = (ext->t_tq01[0] & TIR_BITS_TQ1_BIG)
			  >>		      TIR_BITS_TQ1_SH_BIG;
      intern->tq2         = (ext->t_tq23[0] & TIR_BITS_TQ2_BIG)
			  >>		      TIR_BITS_TQ2_SH_BIG;
      intern->tq3         = (ext->t_tq23[0] & TIR_BITS_TQ3_BIG)
			  >>		      TIR_BITS_TQ3_SH_BIG;
    }
  else
    {
      intern->fBitfield   = 0 != (ext->t_bits1[0] & TIR_BITS1_FBITFIELD_LITTLE);
      intern->continued   = 0 != (ext->t_bits1[0] & TIR_BITS1_CONTINUED_LITTLE);
      intern->bt          = (ext->t_bits1[0] & TIR_BITS1_BT_LITTLE)
			  >>		    TIR_BITS1_BT_SH_LITTLE;
      intern->tq4         = (ext->t_tq45[0] & TIR_BITS_TQ4_LITTLE)
			  >>		    TIR_BITS_TQ4_SH_LITTLE;
      intern->tq5         = (ext->t_tq45[0] & TIR_BITS_TQ5_LITTLE)
			  >>		    TIR_BITS_TQ5_SH_LITTLE;
      intern->tq0         = (ext->t_tq01[0] & TIR_BITS_TQ0_LITTLE)
			  >>		    TIR_BITS_TQ0_SH_LITTLE;
      intern->tq1         = (ext->t_tq01[0] & TIR_BITS_TQ1_LITTLE)
			  >>		    TIR_BITS_TQ1_SH_LITTLE;
      intern->tq2         = (ext->t_tq23[0] & TIR_BITS_TQ2_LITTLE)
			  >>		    TIR_BITS_TQ2_SH_LITTLE;
      intern->tq3         = (ext->t_tq23[0] & TIR_BITS_TQ3_LITTLE)
			  >>		    TIR_BITS_TQ3_SH_LITTLE;
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a type information record.
   BIGEND says whether AUX symbols are big-endian or little-endian; this
   info comes from the file header record (fh-fBigendian).  */

void
_bfd_ecoff_swap_tir_out (int bigend,
			 const TIR *intern_copy,
			 struct tir_ext *ext)
{
  TIR intern[1];

  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */

  /* now the fun stuff...  */
  if (bigend)
    {
      ext->t_bits1[0] = ((intern->fBitfield ? TIR_BITS1_FBITFIELD_BIG : 0)
		       | (intern->continued ? TIR_BITS1_CONTINUED_BIG : 0)
		       | ((intern->bt << TIR_BITS1_BT_SH_BIG)
			  & TIR_BITS1_BT_BIG));
      ext->t_tq45[0] = (((intern->tq4 << TIR_BITS_TQ4_SH_BIG)
		       & TIR_BITS_TQ4_BIG)
		      | ((intern->tq5 << TIR_BITS_TQ5_SH_BIG)
			 & TIR_BITS_TQ5_BIG));
      ext->t_tq01[0] = (((intern->tq0 << TIR_BITS_TQ0_SH_BIG)
		       & TIR_BITS_TQ0_BIG)
		      | ((intern->tq1 << TIR_BITS_TQ1_SH_BIG)
			 & TIR_BITS_TQ1_BIG));
      ext->t_tq23[0] = (((intern->tq2 << TIR_BITS_TQ2_SH_BIG)
		       & TIR_BITS_TQ2_BIG)
		      | ((intern->tq3 << TIR_BITS_TQ3_SH_BIG)
			 & TIR_BITS_TQ3_BIG));
    }
  else
    {
      ext->t_bits1[0] = ((intern->fBitfield ? TIR_BITS1_FBITFIELD_LITTLE : 0)
		       | (intern->continued ? TIR_BITS1_CONTINUED_LITTLE : 0)
		       | ((intern->bt << TIR_BITS1_BT_SH_LITTLE)
			  & TIR_BITS1_BT_LITTLE));
      ext->t_tq45[0] = (((intern->tq4 << TIR_BITS_TQ4_SH_LITTLE)
		       & TIR_BITS_TQ4_LITTLE)
		      | ((intern->tq5 << TIR_BITS_TQ5_SH_LITTLE)
			 & TIR_BITS_TQ5_LITTLE));
      ext->t_tq01[0] = (((intern->tq0 << TIR_BITS_TQ0_SH_LITTLE)
		       & TIR_BITS_TQ0_LITTLE)
		      | ((intern->tq1 << TIR_BITS_TQ1_SH_LITTLE)
			 & TIR_BITS_TQ1_LITTLE));
      ext->t_tq23[0] = (((intern->tq2 << TIR_BITS_TQ2_SH_LITTLE)
		       & TIR_BITS_TQ2_LITTLE)
		      | ((intern->tq3 << TIR_BITS_TQ3_SH_LITTLE)
			 & TIR_BITS_TQ3_LITTLE));
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap in a relative symbol record.  BIGEND says whether it is in
   big-endian or little-endian format.*/

void
_bfd_ecoff_swap_rndx_in (int bigend,
			 const struct rndx_ext *ext_copy,
			 RNDXR *intern)
{
  struct rndx_ext ext[1];

  *ext = *ext_copy;		/* Make it reasonable to do in-place.  */

  /* now the fun stuff...  */
  if (bigend)
    {
      intern->rfd   = (ext->r_bits[0] << RNDX_BITS0_RFD_SH_LEFT_BIG)
		  | ((ext->r_bits[1] & RNDX_BITS1_RFD_BIG)
		    		    >> RNDX_BITS1_RFD_SH_BIG);
      intern->index = ((ext->r_bits[1] & RNDX_BITS1_INDEX_BIG)
		    		    << RNDX_BITS1_INDEX_SH_LEFT_BIG)
		  | (ext->r_bits[2] << RNDX_BITS2_INDEX_SH_LEFT_BIG)
		  | (ext->r_bits[3] << RNDX_BITS3_INDEX_SH_LEFT_BIG);
    }
  else
    {
      intern->rfd   = (ext->r_bits[0] << RNDX_BITS0_RFD_SH_LEFT_LITTLE)
		  | ((ext->r_bits[1] & RNDX_BITS1_RFD_LITTLE)
		    		    << RNDX_BITS1_RFD_SH_LEFT_LITTLE);
      intern->index = ((ext->r_bits[1] & RNDX_BITS1_INDEX_LITTLE)
		    		    >> RNDX_BITS1_INDEX_SH_LITTLE)
		  | (ext->r_bits[2] << RNDX_BITS2_INDEX_SH_LEFT_LITTLE)
		  | ((unsigned int) ext->r_bits[3]
		     << RNDX_BITS3_INDEX_SH_LEFT_LITTLE);
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* Swap out a relative symbol record.  BIGEND says whether it is in
   big-endian or little-endian format.*/

void
_bfd_ecoff_swap_rndx_out (int bigend,
			  const RNDXR *intern_copy,
			  struct rndx_ext *ext)
{
  RNDXR intern[1];

  *intern = *intern_copy;	/* Make it reasonable to do in-place.  */

  /* now the fun stuff...  */
  if (bigend)
    {
      ext->r_bits[0] = intern->rfd >> RNDX_BITS0_RFD_SH_LEFT_BIG;
      ext->r_bits[1] = (((intern->rfd << RNDX_BITS1_RFD_SH_BIG)
		       & RNDX_BITS1_RFD_BIG)
		      | ((intern->index >> RNDX_BITS1_INDEX_SH_LEFT_BIG)
			 & RNDX_BITS1_INDEX_BIG));
      ext->r_bits[2] = intern->index >> RNDX_BITS2_INDEX_SH_LEFT_BIG;
      ext->r_bits[3] = intern->index >> RNDX_BITS3_INDEX_SH_LEFT_BIG;
    }
  else
    {
      ext->r_bits[0] = intern->rfd >> RNDX_BITS0_RFD_SH_LEFT_LITTLE;
      ext->r_bits[1] = (((intern->rfd >> RNDX_BITS1_RFD_SH_LEFT_LITTLE)
		       & RNDX_BITS1_RFD_LITTLE)
		      | ((intern->index << RNDX_BITS1_INDEX_SH_LITTLE)
			 & RNDX_BITS1_INDEX_LITTLE));
      ext->r_bits[2] = intern->index >> RNDX_BITS2_INDEX_SH_LEFT_LITTLE;
      ext->r_bits[3] = intern->index >> RNDX_BITS3_INDEX_SH_LEFT_LITTLE;
    }

#ifdef TEST
  if (memcmp ((char *)ext, (char *)intern, sizeof (*intern)) != 0)
    abort ();
#endif
}

/* The minimum amount of data to allocate.  */
#define ALLOC_SIZE (4064)

/* Add bytes to a buffer.  Return success.  */

static bfd_boolean
ecoff_add_bytes (char **buf, char **bufend, size_t need)
{
  size_t have;
  size_t want;
  char *newbuf;

  have = *bufend - *buf;
  if (have > need)
    want = ALLOC_SIZE;
  else
    {
      want = need - have;
      if (want < ALLOC_SIZE)
	want = ALLOC_SIZE;
    }
  newbuf = (char *) bfd_realloc (*buf, (bfd_size_type) have + want);
  if (newbuf == NULL)
    return FALSE;
  *buf = newbuf;
  *bufend = *buf + have + want;
  return TRUE;
}

/* We keep a hash table which maps strings to numbers.  We use it to
   map FDR names to indices in the output file, and to map local
   strings when combining stabs debugging information.  */

struct string_hash_entry
{
  struct bfd_hash_entry root;
  /* FDR index or string table offset.  */
  long val;
  /* Next entry in string table.  */
  struct string_hash_entry *next;
};

struct string_hash_table
{
  struct bfd_hash_table table;
};

/* Routine to create an entry in a string hash table.  */

static struct bfd_hash_entry *
string_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table,
		     const char *string)
{
  struct string_hash_entry *ret = (struct string_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct string_hash_entry *) NULL)
    ret = ((struct string_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct string_hash_entry)));
  if (ret == (struct string_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct string_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->val = -1;
      ret->next = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Look up an entry in an string hash table.  */

#define string_hash_lookup(t, string, create, copy) \
  ((struct string_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))

/* We can't afford to read in all the debugging information when we do
   a link.  Instead, we build a list of these structures to show how
   different parts of the input file map to the output file.  */

struct shuffle
{
  /* The next entry in this linked list.  */
  struct shuffle *next;
  /* The length of the information.  */
  unsigned long size;
  /* Whether this information comes from a file or not.  */
  bfd_boolean filep;
  union
    {
      struct
	{
	  /* The BFD the data comes from.  */
	  bfd *input_bfd;
	  /* The offset within input_bfd.  */
	  file_ptr offset;
	} file;
      /* The data to be written out.  */
      void * memory;
    } u;
};

/* This structure holds information across calls to
   bfd_ecoff_debug_accumulate.  */

struct accumulate
{
  /* The FDR hash table.  */
  struct string_hash_table fdr_hash;
  /* The strings hash table.  */
  struct string_hash_table str_hash;
  /* Linked lists describing how to shuffle the input debug
     information into the output file.  We keep a pointer to both the
     head and the tail.  */
  struct shuffle *line;
  struct shuffle *line_end;
  struct shuffle *pdr;
  struct shuffle *pdr_end;
  struct shuffle *sym;
  struct shuffle *sym_end;
  struct shuffle *opt;
  struct shuffle *opt_end;
  struct shuffle *aux;
  struct shuffle *aux_end;
  struct shuffle *ss;
  struct shuffle *ss_end;
  struct string_hash_entry *ss_hash;
  struct string_hash_entry *ss_hash_end;
  struct shuffle *fdr;
  struct shuffle *fdr_end;
  struct shuffle *rfd;
  struct shuffle *rfd_end;
  /* The size of the largest file shuffle.  */
  unsigned long largest_file_shuffle;
  /* An objalloc for debugging information.  */
  struct objalloc *memory;
};

/* Add a file entry to a shuffle list.  */

static bfd_boolean
add_file_shuffle (struct accumulate *ainfo,
		  struct shuffle **head,
		  struct shuffle **tail,
		  bfd *input_bfd,
		  file_ptr offset,
		  unsigned long size)
{
  struct shuffle *n;

  if (*tail != (struct shuffle *) NULL
      && (*tail)->filep
      && (*tail)->u.file.input_bfd == input_bfd
      && (*tail)->u.file.offset + (*tail)->size == (unsigned long) offset)
    {
      /* Just merge this entry onto the existing one.  */
      (*tail)->size += size;
      if ((*tail)->size > ainfo->largest_file_shuffle)
	ainfo->largest_file_shuffle = (*tail)->size;
      return TRUE;
    }

  n = (struct shuffle *) objalloc_alloc (ainfo->memory,
					 sizeof (struct shuffle));
  if (!n)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  n->next = NULL;
  n->size = size;
  n->filep = TRUE;
  n->u.file.input_bfd = input_bfd;
  n->u.file.offset = offset;
  if (*head == (struct shuffle *) NULL)
    *head = n;
  if (*tail != (struct shuffle *) NULL)
    (*tail)->next = n;
  *tail = n;
  if (size > ainfo->largest_file_shuffle)
    ainfo->largest_file_shuffle = size;
  return TRUE;
}

/* Add a memory entry to a shuffle list.  */

static bfd_boolean
add_memory_shuffle (struct accumulate *ainfo,
		    struct shuffle **head,
		    struct shuffle **tail,
		    bfd_byte *data,
		    unsigned long size)
{
  struct shuffle *n;

  n = (struct shuffle *) objalloc_alloc (ainfo->memory,
					 sizeof (struct shuffle));
  if (!n)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  n->next = NULL;
  n->size = size;
  n->filep = FALSE;
  n->u.memory = data;
  if (*head == (struct shuffle *) NULL)
    *head = n;
  if (*tail != (struct shuffle *) NULL)
    (*tail)->next = n;
  *tail = n;
  return TRUE;
}

/* Initialize the FDR hash table.  This returns a handle which is then
   passed in to bfd_ecoff_debug_accumulate, et. al.  */

void *
bfd_ecoff_debug_init (bfd *output_bfd ATTRIBUTE_UNUSED,
		      struct ecoff_debug_info *output_debug,
		      const struct ecoff_debug_swap *output_swap ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  struct accumulate *ainfo;
  bfd_size_type amt = sizeof (struct accumulate);

  ainfo = (struct accumulate *) bfd_malloc (amt);
  if (!ainfo)
    return NULL;
  if (!bfd_hash_table_init_n (&ainfo->fdr_hash.table, string_hash_newfunc,
			      sizeof (struct string_hash_entry), 1021))
    return NULL;

  ainfo->line = NULL;
  ainfo->line_end = NULL;
  ainfo->pdr = NULL;
  ainfo->pdr_end = NULL;
  ainfo->sym = NULL;
  ainfo->sym_end = NULL;
  ainfo->opt = NULL;
  ainfo->opt_end = NULL;
  ainfo->aux = NULL;
  ainfo->aux_end = NULL;
  ainfo->ss = NULL;
  ainfo->ss_end = NULL;
  ainfo->ss_hash = NULL;
  ainfo->ss_hash_end = NULL;
  ainfo->fdr = NULL;
  ainfo->fdr_end = NULL;
  ainfo->rfd = NULL;
  ainfo->rfd_end = NULL;

  ainfo->largest_file_shuffle = 0;

  if (! info->relocatable)
    {
      if (!bfd_hash_table_init (&ainfo->str_hash.table, string_hash_newfunc,
				sizeof (struct string_hash_entry)))
	return NULL;

      /* The first entry in the string table is the empty string.  */
      output_debug->symbolic_header.issMax = 1;
    }

  ainfo->memory = objalloc_create ();
  if (ainfo->memory == NULL)
    {
      bfd_set_error (bfd_error_no_memory);
      return NULL;
    }

  return ainfo;
}

/* Free the accumulated debugging information.  */

void
bfd_ecoff_debug_free (void * handle,
		      bfd *output_bfd ATTRIBUTE_UNUSED,
		      struct ecoff_debug_info *output_debug ATTRIBUTE_UNUSED,
		      const struct ecoff_debug_swap *output_swap ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  struct accumulate *ainfo = (struct accumulate *) handle;

  bfd_hash_table_free (&ainfo->fdr_hash.table);

  if (! info->relocatable)
    bfd_hash_table_free (&ainfo->str_hash.table);

  objalloc_free (ainfo->memory);

  free (ainfo);
}

/* Accumulate the debugging information from INPUT_BFD into
   OUTPUT_BFD.  The INPUT_DEBUG argument points to some ECOFF
   debugging information which we want to link into the information
   pointed to by the OUTPUT_DEBUG argument.  OUTPUT_SWAP and
   INPUT_SWAP point to the swapping information needed.  INFO is the
   linker information structure.  HANDLE is returned by
   bfd_ecoff_debug_init.  */

bfd_boolean
bfd_ecoff_debug_accumulate (void * handle,
			    bfd *output_bfd,
			    struct ecoff_debug_info *output_debug,
			    const struct ecoff_debug_swap *output_swap,
			    bfd *input_bfd,
			    struct ecoff_debug_info *input_debug,
			    const struct ecoff_debug_swap *input_swap,
			    struct bfd_link_info *info)
{
  struct accumulate *ainfo = (struct accumulate *) handle;
  void (* const swap_sym_in) (bfd *, void *, SYMR *)
    = input_swap->swap_sym_in;
  void (* const swap_rfd_in) (bfd *, void *, RFDT *)
    = input_swap->swap_rfd_in;
  void (* const swap_sym_out) (bfd *, const SYMR *, void *)
    = output_swap->swap_sym_out;
  void (* const swap_fdr_out) (bfd *, const FDR *, void *)
    = output_swap->swap_fdr_out;
  void (* const swap_rfd_out) (bfd *, const RFDT *, void *)
    = output_swap->swap_rfd_out;
  bfd_size_type external_pdr_size = output_swap->external_pdr_size;
  bfd_size_type external_sym_size = output_swap->external_sym_size;
  bfd_size_type external_opt_size = output_swap->external_opt_size;
  bfd_size_type external_fdr_size = output_swap->external_fdr_size;
  bfd_size_type external_rfd_size = output_swap->external_rfd_size;
  HDRR * const output_symhdr = &output_debug->symbolic_header;
  HDRR * const input_symhdr = &input_debug->symbolic_header;
  bfd_vma section_adjust[scMax];
  asection *sec;
  bfd_byte *fdr_start;
  bfd_byte *fdr_ptr;
  bfd_byte *fdr_end;
  bfd_size_type fdr_add;
  unsigned int copied;
  RFDT i;
  unsigned long sz;
  bfd_byte *rfd_out;
  bfd_byte *rfd_in;
  bfd_byte *rfd_end;
  long newrfdbase = 0;
  long oldrfdbase = 0;
  bfd_byte *fdr_out;
  bfd_size_type amt;

  /* Use section_adjust to hold the value to add to a symbol in a
     particular section.  */
  memset (section_adjust, 0, sizeof section_adjust);

#define SET(name, indx) \
  sec = bfd_get_section_by_name (input_bfd, name); \
  if (sec != NULL) \
    section_adjust[indx] = (sec->output_section->vma \
			    + sec->output_offset \
			    - sec->vma);

  SET (".text", scText);
  SET (".data", scData);
  SET (".bss", scBss);
  SET (".sdata", scSData);
  SET (".sbss", scSBss);
  /* scRdata section may be either .rdata or .rodata.  */
  SET (".rdata", scRData);
  SET (".rodata", scRData);
  SET (".init", scInit);
  SET (".fini", scFini);
  SET (".rconst", scRConst);

#undef SET

  /* Find all the debugging information based on the FDR's.  We need
     to handle them whether they are swapped or not.  */
  if (input_debug->fdr != (FDR *) NULL)
    {
      fdr_start = (bfd_byte *) input_debug->fdr;
      fdr_add = sizeof (FDR);
    }
  else
    {
      fdr_start = (bfd_byte *) input_debug->external_fdr;
      fdr_add = input_swap->external_fdr_size;
    }
  fdr_end = fdr_start + input_symhdr->ifdMax * fdr_add;

  amt = input_symhdr->ifdMax;
  amt *= sizeof (RFDT);
  input_debug->ifdmap = (RFDT *) bfd_alloc (input_bfd, amt);

  sz = (input_symhdr->crfd + input_symhdr->ifdMax) * external_rfd_size;
  rfd_out = (bfd_byte *) objalloc_alloc (ainfo->memory, sz);
  if (!input_debug->ifdmap || !rfd_out)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  if (!add_memory_shuffle (ainfo, &ainfo->rfd, &ainfo->rfd_end, rfd_out, sz))
    return FALSE;

  copied = 0;

  /* Look through the FDR's to see which ones we are going to include
     in the final output.  We do not want duplicate FDR information
     for header files, because ECOFF debugging is often very large.
     When we find an FDR with no line information which can be merged,
     we look it up in a hash table to ensure that we only include it
     once.  We keep a table mapping FDR numbers to the final number
     they get with the BFD, so that we can refer to it when we write
     out the external symbols.  */
  for (fdr_ptr = fdr_start, i = 0;
       fdr_ptr < fdr_end;
       fdr_ptr += fdr_add, i++, rfd_out += external_rfd_size)
    {
      FDR fdr;

      if (input_debug->fdr != (FDR *) NULL)
	fdr = *(FDR *) fdr_ptr;
      else
	(*input_swap->swap_fdr_in) (input_bfd, fdr_ptr, &fdr);

      /* See if this FDR can be merged with an existing one.  */
      if (fdr.cbLine == 0 && fdr.rss != -1 && fdr.fMerge)
	{
	  const char *name;
	  char *lookup;
	  struct string_hash_entry *fh;

	  /* We look up a string formed from the file name and the
	     number of symbols and aux entries.  Sometimes an include
	     file will conditionally define a typedef or something
	     based on the order of include files.  Using the number of
	     symbols and aux entries as a hash reduces the chance that
	     we will merge symbol information that should not be
	     merged.  */
	  name = input_debug->ss + fdr.issBase + fdr.rss;

	  lookup = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 20);
	  if (lookup == NULL)
	    return FALSE;
	  sprintf (lookup, "%s %lx %lx", name, (unsigned long) fdr.csym,
		   (unsigned long) fdr.caux);

	  fh = string_hash_lookup (&ainfo->fdr_hash, lookup, TRUE, TRUE);
	  free (lookup);
	  if (fh == (struct string_hash_entry *) NULL)
	    return FALSE;

	  if (fh->val != -1)
	    {
	      input_debug->ifdmap[i] = fh->val;
	      (*swap_rfd_out) (output_bfd, input_debug->ifdmap + i, rfd_out);

	      /* Don't copy this FDR.  */
	      continue;
	    }

	  fh->val = output_symhdr->ifdMax + copied;
	}

      input_debug->ifdmap[i] = output_symhdr->ifdMax + copied;
      (*swap_rfd_out) (output_bfd, input_debug->ifdmap + i, rfd_out);
      ++copied;
    }

  newrfdbase = output_symhdr->crfd;
  output_symhdr->crfd += input_symhdr->ifdMax;

  /* Copy over any existing RFD's.  RFD's are only created by the
     linker, so this will only happen for input files which are the
     result of a partial link.  */
  rfd_in = (bfd_byte *) input_debug->external_rfd;
  rfd_end = rfd_in + input_symhdr->crfd * input_swap->external_rfd_size;
  for (;
       rfd_in < rfd_end;
       rfd_in += input_swap->external_rfd_size)
    {
      RFDT rfd;

      (*swap_rfd_in) (input_bfd, rfd_in, &rfd);
      BFD_ASSERT (rfd >= 0 && rfd < input_symhdr->ifdMax);
      rfd = input_debug->ifdmap[rfd];
      (*swap_rfd_out) (output_bfd, &rfd, rfd_out);
      rfd_out += external_rfd_size;
    }

  oldrfdbase = output_symhdr->crfd;
  output_symhdr->crfd += input_symhdr->crfd;

  /* Look through the FDR's and copy over all associated debugging
     information.  */
  sz = copied * external_fdr_size;
  fdr_out = (bfd_byte *) objalloc_alloc (ainfo->memory, sz);
  if (!fdr_out)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  if (!add_memory_shuffle (ainfo, &ainfo->fdr, &ainfo->fdr_end, fdr_out, sz))
    return FALSE;
  for (fdr_ptr = fdr_start, i = 0;
       fdr_ptr < fdr_end;
       fdr_ptr += fdr_add, i++)
    {
      FDR fdr;
      bfd_byte *sym_out;
      bfd_byte *lraw_src;
      bfd_byte *lraw_end;
      bfd_boolean fgotfilename;

      if (input_debug->ifdmap[i] < output_symhdr->ifdMax)
	{
	  /* We are not copying this FDR.  */
	  continue;
	}

      if (input_debug->fdr != (FDR *) NULL)
	fdr = *(FDR *) fdr_ptr;
      else
	(*input_swap->swap_fdr_in) (input_bfd, fdr_ptr, &fdr);

      /* FIXME: It is conceivable that this FDR points to the .init or
	 .fini section, in which case this will not do the right
	 thing.  */
      fdr.adr += section_adjust[scText];

      /* Swap in the local symbols, adjust their values, and swap them
	 out again.  */
      fgotfilename = FALSE;
      sz = fdr.csym * external_sym_size;
      sym_out = (bfd_byte *) objalloc_alloc (ainfo->memory, sz);
      if (!sym_out)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
      if (!add_memory_shuffle (ainfo, &ainfo->sym, &ainfo->sym_end, sym_out,
			       sz))
	return FALSE;
      lraw_src = ((bfd_byte *) input_debug->external_sym
		  + fdr.isymBase * input_swap->external_sym_size);
      lraw_end = lraw_src + fdr.csym * input_swap->external_sym_size;
      for (;  lraw_src < lraw_end;  lraw_src += input_swap->external_sym_size)
	{
	  SYMR internal_sym;

	  (*swap_sym_in) (input_bfd, lraw_src, &internal_sym);

	  BFD_ASSERT (internal_sym.sc != scCommon
		      && internal_sym.sc != scSCommon);

	  /* Adjust the symbol value if appropriate.  */
	  switch (internal_sym.st)
	    {
	    case stNil:
	      if (ECOFF_IS_STAB (&internal_sym))
		break;
	      /* Fall through.  */
	    case stGlobal:
	    case stStatic:
	    case stLabel:
	    case stProc:
	    case stStaticProc:
	      internal_sym.value += section_adjust[internal_sym.sc];
	      break;

	    default:
	      break;
	    }

	  /* If we are doing a final link, we hash all the strings in
	     the local symbol table together.  This reduces the amount
	     of space required by debugging information.  We don't do
	     this when performing a relocatable link because it would
	     prevent us from easily merging different FDR's.  */
	  if (! info->relocatable)
	    {
	      bfd_boolean ffilename;
	      const char *name;

	      if (! fgotfilename && internal_sym.iss == fdr.rss)
		ffilename = TRUE;
	      else
		ffilename = FALSE;

	      /* Hash the name into the string table.  */
	      name = input_debug->ss + fdr.issBase + internal_sym.iss;
	      if (*name == '\0')
		internal_sym.iss = 0;
	      else
		{
		  struct string_hash_entry *sh;

		  sh = string_hash_lookup (&ainfo->str_hash, name, TRUE, TRUE);
		  if (sh == (struct string_hash_entry *) NULL)
		    return FALSE;
		  if (sh->val == -1)
		    {
		      sh->val = output_symhdr->issMax;
		      output_symhdr->issMax += strlen (name) + 1;
		      if (ainfo->ss_hash == (struct string_hash_entry *) NULL)
			ainfo->ss_hash = sh;
		      if (ainfo->ss_hash_end
			  != (struct string_hash_entry *) NULL)
			ainfo->ss_hash_end->next = sh;
		      ainfo->ss_hash_end = sh;
		    }
		  internal_sym.iss = sh->val;
		}

	      if (ffilename)
		{
		  fdr.rss = internal_sym.iss;
		  fgotfilename = TRUE;
		}
	    }

	  (*swap_sym_out) (output_bfd, &internal_sym, sym_out);
	  sym_out += external_sym_size;
	}

      fdr.isymBase = output_symhdr->isymMax;
      output_symhdr->isymMax += fdr.csym;

      /* Copy the information that does not need swapping.  */

      /* FIXME: If we are relaxing, we need to adjust the line
	 numbers.  Frankly, forget it.  Anybody using stabs debugging
	 information will not use this line number information, and
	 stabs are adjusted correctly.  */
      if (fdr.cbLine > 0)
	{
	  file_ptr pos = input_symhdr->cbLineOffset + fdr.cbLineOffset;
	  if (!add_file_shuffle (ainfo, &ainfo->line, &ainfo->line_end,
				 input_bfd, pos, (unsigned long) fdr.cbLine))
	    return FALSE;
	  fdr.ilineBase = output_symhdr->ilineMax;
	  fdr.cbLineOffset = output_symhdr->cbLine;
	  output_symhdr->ilineMax += fdr.cline;
	  output_symhdr->cbLine += fdr.cbLine;
	}
      if (fdr.caux > 0)
	{
	  file_ptr pos = (input_symhdr->cbAuxOffset
			  + fdr.iauxBase * sizeof (union aux_ext));
	  if (!add_file_shuffle (ainfo, &ainfo->aux, &ainfo->aux_end,
				 input_bfd, pos,
				 fdr.caux * sizeof (union aux_ext)))
	    return FALSE;
	  fdr.iauxBase = output_symhdr->iauxMax;
	  output_symhdr->iauxMax += fdr.caux;
	}
      if (! info->relocatable)
	{

	  /* When are are hashing strings, we lie about the number of
	     strings attached to each FDR.  We need to set cbSs
	     because some versions of dbx apparently use it to decide
	     how much of the string table to read in.  */
	  fdr.issBase = 0;
	  fdr.cbSs = output_symhdr->issMax;
	}
      else if (fdr.cbSs > 0)
	{
	  file_ptr pos = input_symhdr->cbSsOffset + fdr.issBase;
	  if (!add_file_shuffle (ainfo, &ainfo->ss, &ainfo->ss_end,
				 input_bfd, pos, (unsigned long) fdr.cbSs))
	    return FALSE;
	  fdr.issBase = output_symhdr->issMax;
	  output_symhdr->issMax += fdr.cbSs;
	}

      if (output_bfd->xvec->header_byteorder
	  == input_bfd->xvec->header_byteorder)
	{
	  /* The two BFD's have the same endianness, and we don't have
	     to adjust the PDR addresses, so simply copying the
	     information will suffice.  */
	  BFD_ASSERT (external_pdr_size == input_swap->external_pdr_size);
	  if (fdr.cpd > 0)
	    {
	      file_ptr pos = (input_symhdr->cbPdOffset
			      + fdr.ipdFirst * external_pdr_size);
	      unsigned long size = fdr.cpd * external_pdr_size;
	      if (!add_file_shuffle (ainfo, &ainfo->pdr, &ainfo->pdr_end,
				     input_bfd, pos, size))
		return FALSE;
	    }
	  BFD_ASSERT (external_opt_size == input_swap->external_opt_size);
	  if (fdr.copt > 0)
	    {
	      file_ptr pos = (input_symhdr->cbOptOffset
			      + fdr.ioptBase * external_opt_size);
	      unsigned long size = fdr.copt * external_opt_size;
	      if (!add_file_shuffle (ainfo, &ainfo->opt, &ainfo->opt_end,
				     input_bfd, pos, size))
		return FALSE;
	    }
	}
      else
	{
	  bfd_size_type outsz, insz;
	  bfd_byte *in;
	  bfd_byte *end;
	  bfd_byte *out;

	  /* The two BFD's have different endianness, so we must swap
	     everything in and out.  This code would always work, but
	     it would be unnecessarily slow in the normal case.  */
	  outsz = external_pdr_size;
	  insz = input_swap->external_pdr_size;
	  in = ((bfd_byte *) input_debug->external_pdr
		+ fdr.ipdFirst * insz);
	  end = in + fdr.cpd * insz;
	  sz = fdr.cpd * outsz;
	  out = (bfd_byte *) objalloc_alloc (ainfo->memory, sz);
	  if (!out)
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return FALSE;
	    }
	  if (!add_memory_shuffle (ainfo, &ainfo->pdr, &ainfo->pdr_end, out,
				   sz))
	    return FALSE;
	  for (; in < end; in += insz, out += outsz)
	    {
	      PDR pdr;

	      (*input_swap->swap_pdr_in) (input_bfd, in, &pdr);
	      (*output_swap->swap_pdr_out) (output_bfd, &pdr, out);
	    }

	  /* Swap over the optimization information.  */
	  outsz = external_opt_size;
	  insz = input_swap->external_opt_size;
	  in = ((bfd_byte *) input_debug->external_opt
		+ fdr.ioptBase * insz);
	  end = in + fdr.copt * insz;
	  sz = fdr.copt * outsz;
	  out = (bfd_byte *) objalloc_alloc (ainfo->memory, sz);
	  if (!out)
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return FALSE;
	    }
	  if (!add_memory_shuffle (ainfo, &ainfo->opt, &ainfo->opt_end, out,
				   sz))
	    return FALSE;
	  for (; in < end; in += insz, out += outsz)
	    {
	      OPTR opt;

	      (*input_swap->swap_opt_in) (input_bfd, in, &opt);
	      (*output_swap->swap_opt_out) (output_bfd, &opt, out);
	    }
	}

      fdr.ipdFirst = output_symhdr->ipdMax;
      output_symhdr->ipdMax += fdr.cpd;
      fdr.ioptBase = output_symhdr->ioptMax;
      output_symhdr->ioptMax += fdr.copt;

      if (fdr.crfd <= 0)
	{
	  /* Point this FDR at the table of RFD's we created.  */
	  fdr.rfdBase = newrfdbase;
	  fdr.crfd = input_symhdr->ifdMax;
	}
      else
	{
	  /* Point this FDR at the remapped RFD's.  */
	  fdr.rfdBase += oldrfdbase;
	}

      (*swap_fdr_out) (output_bfd, &fdr, fdr_out);
      fdr_out += external_fdr_size;
      ++output_symhdr->ifdMax;
    }

  return TRUE;
}

/* Add a string to the debugging information we are accumulating.
   Return the offset from the fdr string base.  */

static long
ecoff_add_string (struct accumulate *ainfo,
		  struct bfd_link_info *info,
		  struct ecoff_debug_info *debug,
		  FDR *fdr,
		  const char *string)
{
  HDRR *symhdr;
  size_t len;
  bfd_size_type ret;

  symhdr = &debug->symbolic_header;
  len = strlen (string);
  if (info->relocatable)
    {
      if (!add_memory_shuffle (ainfo, &ainfo->ss, &ainfo->ss_end,
                               (bfd_byte *) string, len + 1))
	return -1;
      ret = symhdr->issMax;
      symhdr->issMax += len + 1;
      fdr->cbSs += len + 1;
    }
  else
    {
      struct string_hash_entry *sh;

      sh = string_hash_lookup (&ainfo->str_hash, string, TRUE, TRUE);
      if (sh == (struct string_hash_entry *) NULL)
	return -1;
      if (sh->val == -1)
	{
	  sh->val = symhdr->issMax;
	  symhdr->issMax += len + 1;
	  if (ainfo->ss_hash == (struct string_hash_entry *) NULL)
	    ainfo->ss_hash = sh;
	  if (ainfo->ss_hash_end
	      != (struct string_hash_entry *) NULL)
	    ainfo->ss_hash_end->next = sh;
	  ainfo->ss_hash_end = sh;
	}
      ret = sh->val;
    }

  return ret;
}

/* Add debugging information from a non-ECOFF file.  */

bfd_boolean
bfd_ecoff_debug_accumulate_other (void * handle,
				  bfd *output_bfd,
				  struct ecoff_debug_info *output_debug,
				  const struct ecoff_debug_swap *output_swap,
				  bfd *input_bfd,
				  struct bfd_link_info *info)
{
  struct accumulate *ainfo = (struct accumulate *) handle;
  void (* const swap_sym_out) (bfd *, const SYMR *, void *)
    = output_swap->swap_sym_out;
  HDRR *output_symhdr = &output_debug->symbolic_header;
  FDR fdr;
  asection *sec;
  asymbol **symbols;
  asymbol **sym_ptr;
  asymbol **sym_end;
  long symsize;
  long symcount;
  void * external_fdr;

  memset (&fdr, 0, sizeof fdr);

  sec = bfd_get_section_by_name (input_bfd, ".text");
  if (sec != NULL)
    fdr.adr = sec->output_section->vma + sec->output_offset;
  else
    {
      /* FIXME: What about .init or .fini?  */
      fdr.adr = 0;
    }

  fdr.issBase = output_symhdr->issMax;
  fdr.cbSs = 0;
  fdr.rss = ecoff_add_string (ainfo, info, output_debug, &fdr,
			      input_bfd->filename);
  if (fdr.rss == -1)
    return FALSE;
  fdr.isymBase = output_symhdr->isymMax;

  /* Get the local symbols from the input BFD.  */
  symsize = bfd_get_symtab_upper_bound (input_bfd);
  if (symsize < 0)
    return FALSE;
  symbols = (asymbol **) bfd_alloc (output_bfd, (bfd_size_type) symsize);
  if (symbols == (asymbol **) NULL)
    return FALSE;
  symcount = bfd_canonicalize_symtab (input_bfd, symbols);
  if (symcount < 0)
    return FALSE;
  sym_end = symbols + symcount;

  /* Handle the local symbols.  Any external symbols are handled
     separately.  */
  fdr.csym = 0;
  for (sym_ptr = symbols; sym_ptr != sym_end; sym_ptr++)
    {
      SYMR internal_sym;
      void * external_sym;

      if (((*sym_ptr)->flags & BSF_EXPORT) != 0)
	continue;
      memset (&internal_sym, 0, sizeof internal_sym);
      internal_sym.iss = ecoff_add_string (ainfo, info, output_debug, &fdr,
					   (*sym_ptr)->name);

      if (internal_sym.iss == -1)
	return FALSE;
      if (bfd_is_com_section ((*sym_ptr)->section)
	  || bfd_is_und_section ((*sym_ptr)->section))
	internal_sym.value = (*sym_ptr)->value;
      else
	internal_sym.value = ((*sym_ptr)->value
			      + (*sym_ptr)->section->output_offset
			      + (*sym_ptr)->section->output_section->vma);
      internal_sym.st = stNil;
      internal_sym.sc = scUndefined;
      internal_sym.index = indexNil;

      external_sym = objalloc_alloc (ainfo->memory,
				     output_swap->external_sym_size);
      if (!external_sym)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return FALSE;
	}
      (*swap_sym_out) (output_bfd, &internal_sym, external_sym);
      add_memory_shuffle (ainfo, &ainfo->sym, &ainfo->sym_end,
			  (bfd_byte *) external_sym,
			  (unsigned long) output_swap->external_sym_size);
      ++fdr.csym;
      ++output_symhdr->isymMax;
    }

  bfd_release (output_bfd, symbols);

  /* Leave everything else in the FDR zeroed out.  This will cause
     the lang field to be langC.  The fBigendian field will
     indicate little endian format, but it doesn't matter because
     it only applies to aux fields and there are none.  */
  external_fdr = objalloc_alloc (ainfo->memory,
				 output_swap->external_fdr_size);
  if (!external_fdr)
    {
      bfd_set_error (bfd_error_no_memory);
      return FALSE;
    }
  (*output_swap->swap_fdr_out) (output_bfd, &fdr, external_fdr);
  add_memory_shuffle (ainfo, &ainfo->fdr, &ainfo->fdr_end,
		      (bfd_byte *) external_fdr,
		      (unsigned long) output_swap->external_fdr_size);

  ++output_symhdr->ifdMax;

  return TRUE;
}

/* Set up ECOFF debugging information for the external symbols.
   FIXME: This is done using a memory buffer, but it should be
   probably be changed to use a shuffle structure.  The assembler uses
   this interface, so that must be changed to do something else.  */

bfd_boolean
bfd_ecoff_debug_externals (bfd *abfd,
			   struct ecoff_debug_info *debug,
			   const struct ecoff_debug_swap *swap,
			   bfd_boolean relocatable,
			   bfd_boolean (*get_extr) (asymbol *, EXTR *),
			   void (*set_index) (asymbol *, bfd_size_type))
{
  HDRR * const symhdr = &debug->symbolic_header;
  asymbol **sym_ptr_ptr;
  size_t c;

  sym_ptr_ptr = bfd_get_outsymbols (abfd);
  if (sym_ptr_ptr == NULL)
    return TRUE;

  for (c = bfd_get_symcount (abfd); c > 0; c--, sym_ptr_ptr++)
    {
      asymbol *sym_ptr;
      EXTR esym;

      sym_ptr = *sym_ptr_ptr;

      /* Get the external symbol information.  */
      if (! (*get_extr) (sym_ptr, &esym))
	continue;

      /* If we're producing an executable, move common symbols into
	 bss.  */
      if (! relocatable)
	{
	  if (esym.asym.sc == scCommon)
	    esym.asym.sc = scBss;
	  else if (esym.asym.sc == scSCommon)
	    esym.asym.sc = scSBss;
	}

      if (bfd_is_com_section (sym_ptr->section)
	  || bfd_is_und_section (sym_ptr->section)
	  || sym_ptr->section->output_section == (asection *) NULL)
	{
	  /* FIXME: gas does not keep the value of a small undefined
	     symbol in the symbol itself, because of relocation
	     problems.  */
	  if (esym.asym.sc != scSUndefined
	      || esym.asym.value == 0
	      || sym_ptr->value != 0)
	    esym.asym.value = sym_ptr->value;
	}
      else
	esym.asym.value = (sym_ptr->value
			   + sym_ptr->section->output_offset
			   + sym_ptr->section->output_section->vma);

      if (set_index)
	(*set_index) (sym_ptr, (bfd_size_type) symhdr->iextMax);

      if (! bfd_ecoff_debug_one_external (abfd, debug, swap,
					  sym_ptr->name, &esym))
	return FALSE;
    }

  return TRUE;
}

/* Add a single external symbol to the debugging information.  */

bfd_boolean
bfd_ecoff_debug_one_external (bfd *abfd,
			      struct ecoff_debug_info *debug,
			      const struct ecoff_debug_swap *swap,
			      const char *name,
			      EXTR *esym)
{
  const bfd_size_type external_ext_size = swap->external_ext_size;
  void (* const swap_ext_out) (bfd *, const EXTR *, void *)
    = swap->swap_ext_out;
  HDRR * const symhdr = &debug->symbolic_header;
  size_t namelen;

  namelen = strlen (name);

  if ((size_t) (debug->ssext_end - debug->ssext)
      < symhdr->issExtMax + namelen + 1)
    {
      if (! ecoff_add_bytes ((char **) &debug->ssext,
			     (char **) &debug->ssext_end,
			     symhdr->issExtMax + namelen + 1))
	return FALSE;
    }
  if ((size_t) ((char *) debug->external_ext_end
		- (char *) debug->external_ext)
      < (symhdr->iextMax + 1) * external_ext_size)
    {
      char *external_ext = (char *) debug->external_ext;
      char *external_ext_end = (char *) debug->external_ext_end;
      if (! ecoff_add_bytes ((char **) &external_ext,
			     (char **) &external_ext_end,
			     (symhdr->iextMax + 1) * (size_t) external_ext_size))
	return FALSE;
      debug->external_ext = external_ext;
      debug->external_ext_end = external_ext_end;
    }

  esym->asym.iss = symhdr->issExtMax;

  (*swap_ext_out) (abfd, esym,
		   ((char *) debug->external_ext
		    + symhdr->iextMax * swap->external_ext_size));

  ++symhdr->iextMax;

  strcpy (debug->ssext + symhdr->issExtMax, name);
  symhdr->issExtMax += namelen + 1;

  return TRUE;
}

/* Align the ECOFF debugging information.  */

static void
ecoff_align_debug (bfd *abfd ATTRIBUTE_UNUSED,
		   struct ecoff_debug_info *debug,
		   const struct ecoff_debug_swap *swap)
{
  HDRR * const symhdr = &debug->symbolic_header;
  bfd_size_type debug_align, aux_align, rfd_align;
  size_t add;

  /* Adjust the counts so that structures are aligned.  */
  debug_align = swap->debug_align;
  aux_align = debug_align / sizeof (union aux_ext);
  rfd_align = debug_align / swap->external_rfd_size;

  add = debug_align - (symhdr->cbLine & (debug_align - 1));
  if (add != debug_align)
    {
      if (debug->line != (unsigned char *) NULL)
	memset ((debug->line + symhdr->cbLine), 0, add);
      symhdr->cbLine += add;
    }

  add = debug_align - (symhdr->issMax & (debug_align - 1));
  if (add != debug_align)
    {
      if (debug->ss != (char *) NULL)
	memset ((debug->ss + symhdr->issMax), 0, add);
      symhdr->issMax += add;
    }

  add = debug_align - (symhdr->issExtMax & (debug_align - 1));
  if (add != debug_align)
    {
      if (debug->ssext != (char *) NULL)
	memset ((debug->ssext + symhdr->issExtMax), 0, add);
      symhdr->issExtMax += add;
    }

  add = aux_align - (symhdr->iauxMax & (aux_align - 1));
  if (add != aux_align)
    {
      if (debug->external_aux != (union aux_ext *) NULL)
	memset ((debug->external_aux + symhdr->iauxMax), 0,
		add * sizeof (union aux_ext));
      symhdr->iauxMax += add;
    }

  add = rfd_align - (symhdr->crfd & (rfd_align - 1));
  if (add != rfd_align)
    {
      if (debug->external_rfd != NULL)
	memset (((char *) debug->external_rfd
		 + symhdr->crfd * swap->external_rfd_size),
		0, (size_t) (add * swap->external_rfd_size));
      symhdr->crfd += add;
    }
}

/* Return the size required by the ECOFF debugging information.  */

bfd_size_type
bfd_ecoff_debug_size (bfd *abfd,
		      struct ecoff_debug_info *debug,
		      const struct ecoff_debug_swap *swap)
{
  bfd_size_type tot;

  ecoff_align_debug (abfd, debug, swap);
  tot = swap->external_hdr_size;

#define ADD(count, size) \
  tot += debug->symbolic_header.count * size

  ADD (cbLine, sizeof (unsigned char));
  ADD (idnMax, swap->external_dnr_size);
  ADD (ipdMax, swap->external_pdr_size);
  ADD (isymMax, swap->external_sym_size);
  ADD (ioptMax, swap->external_opt_size);
  ADD (iauxMax, sizeof (union aux_ext));
  ADD (issMax, sizeof (char));
  ADD (issExtMax, sizeof (char));
  ADD (ifdMax, swap->external_fdr_size);
  ADD (crfd, swap->external_rfd_size);
  ADD (iextMax, swap->external_ext_size);

#undef ADD

  return tot;
}

/* Write out the ECOFF symbolic header, given the file position it is
   going to be placed at.  This assumes that the counts are set
   correctly.  */

static bfd_boolean
ecoff_write_symhdr (bfd *abfd,
		    struct ecoff_debug_info *debug,
		    const struct ecoff_debug_swap *swap,
		    file_ptr where)
{
  HDRR * const symhdr = &debug->symbolic_header;
  char *buff = NULL;

  ecoff_align_debug (abfd, debug, swap);

  /* Go to the right location in the file.  */
  if (bfd_seek (abfd, where, SEEK_SET) != 0)
    return FALSE;

  where += swap->external_hdr_size;

  symhdr->magic = swap->sym_magic;

  /* Fill in the file offsets.  */
#define SET(offset, count, size) \
  if (symhdr->count == 0) \
    symhdr->offset = 0; \
  else \
    { \
      symhdr->offset = where; \
      where += symhdr->count * size; \
    }

  SET (cbLineOffset, cbLine, sizeof (unsigned char));
  SET (cbDnOffset, idnMax, swap->external_dnr_size);
  SET (cbPdOffset, ipdMax, swap->external_pdr_size);
  SET (cbSymOffset, isymMax, swap->external_sym_size);
  SET (cbOptOffset, ioptMax, swap->external_opt_size);
  SET (cbAuxOffset, iauxMax, sizeof (union aux_ext));
  SET (cbSsOffset, issMax, sizeof (char));
  SET (cbSsExtOffset, issExtMax, sizeof (char));
  SET (cbFdOffset, ifdMax, swap->external_fdr_size);
  SET (cbRfdOffset, crfd, swap->external_rfd_size);
  SET (cbExtOffset, iextMax, swap->external_ext_size);
#undef SET

  buff = (char *) bfd_malloc (swap->external_hdr_size);
  if (buff == NULL && swap->external_hdr_size != 0)
    goto error_return;

  (*swap->swap_hdr_out) (abfd, symhdr, buff);
  if (bfd_bwrite (buff, swap->external_hdr_size, abfd)
      != swap->external_hdr_size)
    goto error_return;

  if (buff != NULL)
    free (buff);
  return TRUE;
 error_return:
  if (buff != NULL)
    free (buff);
  return FALSE;
}

/* Write out the ECOFF debugging information.  This function assumes
   that the information (the pointers and counts) in *DEBUG have been
   set correctly.  WHERE is the position in the file to write the
   information to.  This function fills in the file offsets in the
   symbolic header.  */

bfd_boolean
bfd_ecoff_write_debug (bfd *abfd,
		       struct ecoff_debug_info *debug,
		       const struct ecoff_debug_swap *swap,
		       file_ptr where)
{
  HDRR * const symhdr = &debug->symbolic_header;

  if (! ecoff_write_symhdr (abfd, debug, swap, where))
    return FALSE;

#define WRITE(ptr, count, size, offset) \
  BFD_ASSERT (symhdr->offset == 0 \
	      || (bfd_vma) bfd_tell (abfd) == symhdr->offset); \
  if (bfd_bwrite (debug->ptr, (bfd_size_type) size * symhdr->count, abfd)\
      != size * symhdr->count) \
    return FALSE;

  WRITE (line, cbLine, sizeof (unsigned char), cbLineOffset);
  WRITE (external_dnr, idnMax, swap->external_dnr_size, cbDnOffset);
  WRITE (external_pdr, ipdMax, swap->external_pdr_size, cbPdOffset);
  WRITE (external_sym, isymMax, swap->external_sym_size, cbSymOffset);
  WRITE (external_opt, ioptMax, swap->external_opt_size, cbOptOffset);
  WRITE (external_aux, iauxMax, (bfd_size_type) sizeof (union aux_ext),
	 cbAuxOffset);
  WRITE (ss, issMax, sizeof (char), cbSsOffset);
  WRITE (ssext, issExtMax, sizeof (char), cbSsExtOffset);
  WRITE (external_fdr, ifdMax, swap->external_fdr_size, cbFdOffset);
  WRITE (external_rfd, crfd, swap->external_rfd_size, cbRfdOffset);
  WRITE (external_ext, iextMax, swap->external_ext_size, cbExtOffset);
#undef WRITE

  return TRUE;
}

/* Write out a shuffle list.  */


static bfd_boolean
ecoff_write_shuffle (bfd *abfd,
		     const struct ecoff_debug_swap *swap,
		     struct shuffle *shuffle,
		     void * space)
{
  struct shuffle *l;
  unsigned long total;

  total = 0;
  for (l = shuffle; l != (struct shuffle *) NULL; l = l->next)
    {
      if (! l->filep)
	{
	  if (bfd_bwrite (l->u.memory, (bfd_size_type) l->size, abfd)
	      != l->size)
	    return FALSE;
	}
      else
	{
	  if (bfd_seek (l->u.file.input_bfd, l->u.file.offset, SEEK_SET) != 0
	      || bfd_bread (space, (bfd_size_type) l->size,
			   l->u.file.input_bfd) != l->size
	      || bfd_bwrite (space, (bfd_size_type) l->size, abfd) != l->size)
	    return FALSE;
	}
      total += l->size;
    }

  if ((total & (swap->debug_align - 1)) != 0)
    {
      unsigned int i;
      bfd_byte *s;

      i = swap->debug_align - (total & (swap->debug_align - 1));
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
      if (s == NULL && i != 0)
	return FALSE;

      if (bfd_bwrite (s, (bfd_size_type) i, abfd) != i)
	{
	  free (s);
	  return FALSE;
	}
      free (s);
    }

  return TRUE;
}

/* Write out debugging information using accumulated linker
   information.  */

bfd_boolean
bfd_ecoff_write_accumulated_debug (void * handle,
				   bfd *abfd,
				   struct ecoff_debug_info *debug,
				   const struct ecoff_debug_swap *swap,
				   struct bfd_link_info *info,
				   file_ptr where)
{
  struct accumulate *ainfo = (struct accumulate *) handle;
  void * space = NULL;
  bfd_size_type amt;

  if (! ecoff_write_symhdr (abfd, debug, swap, where))
    goto error_return;

  amt = ainfo->largest_file_shuffle;
  space = bfd_malloc (amt);
  if (space == NULL && ainfo->largest_file_shuffle != 0)
    goto error_return;

  if (! ecoff_write_shuffle (abfd, swap, ainfo->line, space)
      || ! ecoff_write_shuffle (abfd, swap, ainfo->pdr, space)
      || ! ecoff_write_shuffle (abfd, swap, ainfo->sym, space)
      || ! ecoff_write_shuffle (abfd, swap, ainfo->opt, space)
      || ! ecoff_write_shuffle (abfd, swap, ainfo->aux, space))
    goto error_return;

  /* The string table is written out from the hash table if this is a
     final link.  */
  if (info->relocatable)
    {
      BFD_ASSERT (ainfo->ss_hash == (struct string_hash_entry *) NULL);
      if (! ecoff_write_shuffle (abfd, swap, ainfo->ss, space))
	goto error_return;
    }
  else
    {
      unsigned long total;
      bfd_byte null;
      struct string_hash_entry *sh;

      BFD_ASSERT (ainfo->ss == (struct shuffle *) NULL);
      null = 0;
      if (bfd_bwrite (&null, (bfd_size_type) 1, abfd) != 1)
	goto error_return;
      total = 1;
      BFD_ASSERT (ainfo->ss_hash == NULL || ainfo->ss_hash->val == 1);
      for (sh = ainfo->ss_hash;
	   sh != (struct string_hash_entry *) NULL;
	   sh = sh->next)
	{
	  size_t len;

	  len = strlen (sh->root.string);
	  amt = len + 1;
	  if (bfd_bwrite (sh->root.string, amt, abfd) != amt)
	    goto error_return;
	  total += len + 1;
	}

      if ((total & (swap->debug_align - 1)) != 0)
	{
	  unsigned int i;
	  bfd_byte *s;

	  i = swap->debug_align - (total & (swap->debug_align - 1));
	  s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
	  if (s == NULL && i != 0)
	    goto error_return;

	  if (bfd_bwrite (s, (bfd_size_type) i, abfd) != i)
	    {
	      free (s);
	      goto error_return;
	    }
	  free (s);
	}
    }

  /* The external strings and symbol are not converted over to using
     shuffles.  FIXME: They probably should be.  */
  amt = debug->symbolic_header.issExtMax;
  if (bfd_bwrite (debug->ssext, amt, abfd) != amt)
    goto error_return;
  if ((debug->symbolic_header.issExtMax & (swap->debug_align - 1)) != 0)
    {
      unsigned int i;
      bfd_byte *s;

      i = (swap->debug_align
	   - (debug->symbolic_header.issExtMax & (swap->debug_align - 1)));
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
      if (s == NULL && i != 0)
	goto error_return;

      if (bfd_bwrite (s, (bfd_size_type) i, abfd) != i)
	{
	  free (s);
	  goto error_return;
	}
      free (s);
    }

  if (! ecoff_write_shuffle (abfd, swap, ainfo->fdr, space)
      || ! ecoff_write_shuffle (abfd, swap, ainfo->rfd, space))
    goto error_return;

  BFD_ASSERT (debug->symbolic_header.cbExtOffset == 0
	      || (debug->symbolic_header.cbExtOffset
		  == (bfd_vma) bfd_tell (abfd)));

  amt = debug->symbolic_header.iextMax * swap->external_ext_size;
  if (bfd_bwrite (debug->external_ext, amt, abfd) != amt)
    goto error_return;

  if (space != NULL)
    free (space);
  return TRUE;

 error_return:
  if (space != NULL)
    free (space);
  return FALSE;
}

/* Handle the find_nearest_line function for both ECOFF and MIPS ELF
   files.  */

/* Compare FDR entries.  This is called via qsort.  */

static int
cmp_fdrtab_entry (const void * leftp, const void * rightp)
{
  const struct ecoff_fdrtab_entry *lp =
    (const struct ecoff_fdrtab_entry *) leftp;
  const struct ecoff_fdrtab_entry *rp =
    (const struct ecoff_fdrtab_entry *) rightp;

  if (lp->base_addr < rp->base_addr)
    return -1;
  if (lp->base_addr > rp->base_addr)
    return 1;
  return 0;
}

/* Each file descriptor (FDR) has a memory address, to simplify
   looking up an FDR by address, we build a table covering all FDRs
   that have a least one procedure descriptor in them.  The final
   table will be sorted by address so we can look it up via binary
   search.  */

static bfd_boolean
mk_fdrtab (bfd *abfd,
	   struct ecoff_debug_info * const debug_info,
	   const struct ecoff_debug_swap * const debug_swap,
	   struct ecoff_find_line *line_info)
{
  struct ecoff_fdrtab_entry *tab;
  FDR *fdr_ptr;
  FDR *fdr_start;
  FDR *fdr_end;
  bfd_boolean stabs;
  long len;
  bfd_size_type amt;

  fdr_start = debug_info->fdr;
  fdr_end = fdr_start + debug_info->symbolic_header.ifdMax;

  /* First, let's see how long the table needs to be.  */
  for (len = 0, fdr_ptr = fdr_start; fdr_ptr < fdr_end; fdr_ptr++)
    {
      if (fdr_ptr->cpd == 0)	/* Skip FDRs that have no PDRs.  */
	continue;
      ++len;
    }

  /* Now, create and fill in the table.  */
  amt = (bfd_size_type) len * sizeof (struct ecoff_fdrtab_entry);
  line_info->fdrtab = (struct ecoff_fdrtab_entry*) bfd_zalloc (abfd, amt);
  if (line_info->fdrtab == NULL)
    return FALSE;
  line_info->fdrtab_len = len;

  tab = line_info->fdrtab;
  for (fdr_ptr = fdr_start; fdr_ptr < fdr_end; fdr_ptr++)
    {
      if (fdr_ptr->cpd == 0)
	continue;

      /* Check whether this file has stabs debugging information.  In
	 a file with stabs debugging information, the second local
	 symbol is named @@stabs.  */
      stabs = FALSE;
      if (fdr_ptr->csym >= 2)
	{
	  char *sym_ptr;
	  SYMR sym;

	  sym_ptr = ((char *) debug_info->external_sym
		     + (fdr_ptr->isymBase + 1) * debug_swap->external_sym_size);
	  (*debug_swap->swap_sym_in) (abfd, sym_ptr, &sym);
	  if (strcmp (debug_info->ss + fdr_ptr->issBase + sym.iss,
		      STABS_SYMBOL) == 0)
	    stabs = TRUE;
	}

      if (!stabs)
	{
	  /* eraxxon: There are at least two problems with this computation:
	     1) PDRs do *not* contain offsets but full vma's; and typically the
	     address of the first PDR is the address of the FDR, which will
	     make (most) of the results of the original computation 0!
	     2) Once in a wacky while, the Compaq compiler generated PDR
	     addresses do not equal the FDR vma, but they (the PDR address)
	     are still vma's and not offsets.  Cf. comments in
	     'lookup_line'.  */
	  /* The address of the first PDR is the offset of that
	     procedure relative to the beginning of file FDR.  */
	  tab->base_addr = fdr_ptr->adr;
	}
      else
	{
	  /* XXX I don't know about stabs, so this is a guess
	     (davidm@@cs.arizona.edu).  */
	  tab->base_addr = fdr_ptr->adr;
	}
      tab->fdr = fdr_ptr;
      ++tab;
    }

  /* Finally, the table is sorted in increasing memory-address order.
     The table is mostly sorted already, but there are cases (e.g.,
     static functions in include files), where this does not hold.
     Use "odump -PFv" to verify...  */
  qsort (line_info->fdrtab, (size_t) len,
	 sizeof (struct ecoff_fdrtab_entry), cmp_fdrtab_entry);

  return TRUE;
}

/* Return index of first FDR that covers to OFFSET.  */

static long
fdrtab_lookup (struct ecoff_find_line *line_info, bfd_vma offset)
{
  long low, high, len;
  long mid = -1;
  struct ecoff_fdrtab_entry *tab;

  len = line_info->fdrtab_len;
  if (len == 0)
    return -1;

  tab = line_info->fdrtab;
  for (low = 0, high = len - 1 ; low != high ;)
    {
      mid = (high + low) / 2;
      if (offset >= tab[mid].base_addr && offset < tab[mid + 1].base_addr)
	goto find_min;

      if (tab[mid].base_addr > offset)
	high = mid;
      else
	low = mid + 1;
    }

  /* eraxxon: at this point 'offset' is either lower than the lowest entry or
     higher than the highest entry. In the former case high = low = mid = 0;
     we want to return -1.  In the latter case, low = high and mid = low - 1;
     we want to return the index of the highest entry.  Only in former case
     will the following 'catch-all' test be true.  */
  ++mid;

  /* Last entry is catch-all for all higher addresses.  */
  if (offset < tab[mid].base_addr)
    return -1;

 find_min:

  /* eraxxon: There may be multiple FDRs in the table with the
     same base_addr; make sure that we are at the first one.  */
  while (mid > 0 && tab[mid - 1].base_addr == tab[mid].base_addr)
    --mid;

  return mid;
}

/* Look up a line given an address, storing the information in
   LINE_INFO->cache.  */

static bfd_boolean
lookup_line (bfd *abfd,
	     struct ecoff_debug_info * const debug_info,
	     const struct ecoff_debug_swap * const debug_swap,
	     struct ecoff_find_line *line_info)
{
  struct ecoff_fdrtab_entry *tab;
  bfd_vma offset;
  bfd_boolean stabs;
  FDR *fdr_ptr;
  int i;

  /* eraxxon: note that 'offset' is the full vma, not a section offset.  */
  offset = line_info->cache.start;

  /* Build FDR table (sorted by object file's base-address) if we
     don't have it already.  */
  if (line_info->fdrtab == NULL
      && !mk_fdrtab (abfd, debug_info, debug_swap, line_info))
    return FALSE;

  tab = line_info->fdrtab;

  /* Find first FDR for address OFFSET.  */
  i = fdrtab_lookup (line_info, offset);
  if (i < 0)
    return FALSE;		/* no FDR, no fun...  */

  /* eraxxon: 'fdrtab_lookup' doesn't give what we want, at least for Compaq's
     C++ compiler 6.2.  Consider three FDRs with starting addresses of x, y,
     and z, respectively, such that x < y < z.  Assume further that
     y < 'offset' < z.  It is possible at times that the PDR for 'offset' is
     associated with FDR x and *not* with FDR y.  Erg!!

     From a binary dump of my C++ test case 'moo' using Compaq's coffobjanl
     (output format has been edited for our purposes):

     FDR [2]: (main.C): First instruction: 0x12000207c <x>
       PDR [5] for File [2]: LoopTest__Xv                 <0x1200020a0> (a)
       PDR [7] for File [2]: foo__Xv                      <0x120002168>
     FDR [1]: (-1):     First instruction: 0x1200020e8 <y>
       PDR [3] for File [1]:                              <0x120001ad0> (b)
     FDR [6]: (-1):     First instruction: 0x1200026f0 <z>

     (a) In the case of PDR5, the vma is such that the first few instructions
     of the procedure can be found.  But since the size of this procedure is
     160b, the vma will soon cross into the 'address space' of FDR1 and no
     debugging info will be found.  How repugnant!

     (b) It is also possible for a PDR to have a *lower* vma than its associated
     FDR; see FDR1 and PDR3.  Gross!

     Since the FDRs that are causing so much havok (in this case) 1) do not
     describe actual files (fdr.rss == -1), and 2) contain only compiler
     generated routines, I thought a simple fix would be to exclude them from
     the FDR table in 'mk_fdrtab'.  But, besides not knowing for certain
     whether this would be correct, it creates an additional problem.  If we
     happen to ask for source file info on a compiler generated (procedure)
     symbol -- which is still in the symbol table -- the result can be
     information from a real procedure!  This is because compiler generated
     procedures with vma's higher than the last FDR in the fdr table will be
     associated with a PDR from this FDR, specifically the PDR with the
     highest vma.  This wasn't a problem before, because each procedure had a
     PDR.  (Yes, this problem could be eliminated if we kept the size of the
     last PDR around, but things are already getting ugly).

     Probably, a better solution would be to have a sorted PDR table.  Each
     PDR would have a pointer to its FDR so file information could still be
     obtained.  A FDR table could still be constructed if necessary -- since
     it only contains pointers, not much extra memory would be used -- but
     the PDR table would be searched to locate debugging info.

     There is still at least one remaining issue.  Sometimes a FDR can have a
     bogus name, but contain PDRs that should belong to another FDR with a
     real name.  E.g:

     FDR [3]: 0000000120001b50 (/home/.../Array.H~alt~deccxx_5E5A62AD)
       PDR [a] for File [3]: 0000000120001b50
       PDR [b] for File [3]: 0000000120001cf0
       PDR [c] for File [3]: 0000000120001dc8
       PDR [d] for File [3]: 0000000120001e40
       PDR [e] for File [3]: 0000000120001eb8
       PDR [f] for File [3]: 0000000120001f4c
     FDR [4]: 0000000120001b50 (/home/.../Array.H)

     Here, FDR4 has the correct name, but should (seemingly) contain PDRa-f.
     The symbol table for PDR4 does contain symbols for PDRa-f, but so does
     the symbol table for FDR3.  However the former is different; perhaps this
     can be detected easily. (I'm not sure at this point.)  This problem only
     seems to be associated with files with templates.  I am assuming the idea
     is that there is a 'fake' FDR (with PDRs) for each differently typed set
     of templates that must be generated.  Currently, FDR4 is completely
     excluded from the FDR table in 'mk_fdrtab' because it contains no PDRs.

     Since I don't have time to prepare a real fix for this right now, be
     prepared for 'A Horrible Hack' to force the inspection of all non-stabs
     FDRs.  It's coming...  */
  fdr_ptr = tab[i].fdr;

  /* Check whether this file has stabs debugging information.  In a
     file with stabs debugging information, the second local symbol is
     named @@stabs.  */
  stabs = FALSE;
  if (fdr_ptr->csym >= 2)
    {
      char *sym_ptr;
      SYMR sym;

      sym_ptr = ((char *) debug_info->external_sym
		 + (fdr_ptr->isymBase + 1) * debug_swap->external_sym_size);
      (*debug_swap->swap_sym_in) (abfd, sym_ptr, &sym);
      if (strcmp (debug_info->ss + fdr_ptr->issBase + sym.iss,
		  STABS_SYMBOL) == 0)
	stabs = TRUE;
    }

  if (!stabs)
    {
      bfd_size_type external_pdr_size;
      char *pdr_ptr;
      char *best_pdr = NULL;
      FDR *best_fdr;
      bfd_signed_vma best_dist = -1;
      PDR pdr;
      unsigned char *line_ptr;
      unsigned char *line_end;
      int lineno;
      /* This file uses ECOFF debugging information.  Each FDR has a
         list of procedure descriptors (PDR).  The address in the FDR
         is the absolute address of the first procedure.  The address
         in the first PDR gives the offset of that procedure relative
         to the object file's base-address.  The addresses in
         subsequent PDRs specify each procedure's address relative to
         the object file's base-address.  To make things more juicy,
         whenever the PROF bit in the PDR is set, the real entry point
         of the procedure may be 16 bytes below what would normally be
         the procedure's entry point.  Instead, DEC came up with a
         wicked scheme to create profiled libraries "on the fly":
         instead of shipping a regular and a profiled version of each
         library, they insert 16 bytes of unused space in front of
         each procedure and set the "prof" bit in the PDR to indicate
         that there is a gap there (this is done automagically by "as"
         when option "-pg" is specified).  Thus, normally, you link
         against such a library and, except for lots of 16 byte gaps
         between functions, things will behave as usual.  However,
         when invoking "ld" with option "-pg", it will fill those gaps
         with code that calls mcount().  It then moves the function's
         entry point down by 16 bytes, and out pops a binary that has
         all functions profiled.

         NOTE: Neither FDRs nor PDRs are strictly sorted in memory
               order.  For example, when including header-files that
               define functions, the FDRs follow behind the including
               file, even though their code may have been generated at
               a lower address.  File coff-alpha.c from libbfd
               illustrates this (use "odump -PFv" to look at a file's
               FDR/PDR).  Similarly, PDRs are sometimes out of order
               as well.  An example of this is OSF/1 v3.0 libc's
               malloc.c.  I'm not sure why this happens, but it could
               be due to optimizations that reorder a function's
               position within an object-file.

         Strategy:

         On the first call to this function, we build a table of FDRs
         that is sorted by the base-address of the object-file the FDR
         is referring to.  Notice that each object-file may contain
         code from multiple source files (e.g., due to code defined in
         include files).  Thus, for any given base-address, there may
         be multiple FDRs (but this case is, fortunately, uncommon).
         lookup(addr) guarantees to return the first FDR that applies
         to address ADDR.  Thus, after invoking lookup(), we have a
         list of FDRs that may contain the PDR for ADDR.  Next, we
         walk through the PDRs of these FDRs and locate the one that
         is closest to ADDR (i.e., for which the difference between
         ADDR and the PDR's entry point is positive and minimal).
         Once, the right FDR and PDR are located, we simply walk
         through the line-number table to lookup the line-number that
         best matches ADDR.  Obviously, things could be sped up by
         keeping a sorted list of PDRs instead of a sorted list of
         FDRs.  However, this would increase space requirements
         considerably, which is undesirable.  */
      external_pdr_size = debug_swap->external_pdr_size;

      /* eraxxon: The Horrible Hack: Because of the problems above, set 'i'
	 to 0 so we look through all FDRs.

	 Because FDR's without any symbols are assumed to be non-stabs,
	 searching through all FDRs may cause the following code to try to
	 read stabs FDRs as ECOFF ones.  However, I don't think this will
	 harm anything.  */
      i = 0;

      /* Search FDR list starting at tab[i] for the PDR that best matches
         OFFSET.  Normally, the FDR list is only one entry long.  */
      best_fdr = NULL;
      do
	{
	  /* eraxxon: 'dist' and 'min_dist' can be negative now
             because we iterate over every FDR rather than just ones
             with a base address less than or equal to 'offset'.  */
	  bfd_signed_vma dist = -1, min_dist = -1;
	  char *pdr_hold;
	  char *pdr_end;

	  fdr_ptr = tab[i].fdr;

	  pdr_ptr = ((char *) debug_info->external_pdr
		     + fdr_ptr->ipdFirst * external_pdr_size);
	  pdr_end = pdr_ptr + fdr_ptr->cpd * external_pdr_size;
	  (*debug_swap->swap_pdr_in) (abfd, pdr_ptr, &pdr);
	  /* Find PDR that is closest to OFFSET.  If pdr.prof is set,
	     the procedure entry-point *may* be 0x10 below pdr.adr.  We
	     simply pretend that pdr.prof *implies* a lower entry-point.
	     This is safe because it just means that may identify 4 NOPs
	     in front of the function as belonging to the function.  */
	  for (pdr_hold = NULL;
	       pdr_ptr < pdr_end;
	       (pdr_ptr += external_pdr_size,
		(*debug_swap->swap_pdr_in) (abfd, pdr_ptr, &pdr)))
	    {
	      if (offset >= (pdr.adr - 0x10 * pdr.prof))
		{
		  dist = offset - (pdr.adr - 0x10 * pdr.prof);

		  /* eraxxon: 'dist' can be negative now.  Note that
                     'min_dist' can be negative if 'pdr_hold' below is NULL.  */
		  if (!pdr_hold || (dist >= 0 && dist < min_dist))
		    {
		      min_dist = dist;
		      pdr_hold = pdr_ptr;
		    }
		}
	    }

	  if (!best_pdr || (min_dist >= 0 && min_dist < best_dist))
	    {
	      best_dist = (bfd_vma) min_dist;
	      best_fdr = fdr_ptr;
	      best_pdr = pdr_hold;
	    }
	  /* Continue looping until base_addr of next entry is different.  */
	}
      /* eraxxon: We want to iterate over all FDRs.
	 See previous comment about 'fdrtab_lookup'.  */
      while (++i < line_info->fdrtab_len);

      if (!best_fdr || !best_pdr)
	return FALSE;			/* Shouldn't happen...  */

      /* Phew, finally we got something that we can hold onto.  */
      fdr_ptr = best_fdr;
      pdr_ptr = best_pdr;
      (*debug_swap->swap_pdr_in) (abfd, pdr_ptr, &pdr);
      /* Now we can look for the actual line number.  The line numbers
         are stored in a very funky format, which I won't try to
         describe.  The search is bounded by the end of the FDRs line
         number entries.  */
      line_end = debug_info->line + fdr_ptr->cbLineOffset + fdr_ptr->cbLine;

      /* Make offset relative to procedure entry.  */
      offset -= pdr.adr - 0x10 * pdr.prof;
      lineno = pdr.lnLow;
      line_ptr = debug_info->line + fdr_ptr->cbLineOffset + pdr.cbLineOffset;
      while (line_ptr < line_end)
	{
	  int delta;
	  unsigned int count;

	  delta = *line_ptr >> 4;
	  if (delta >= 0x8)
	    delta -= 0x10;
	  count = (*line_ptr & 0xf) + 1;
	  ++line_ptr;
	  if (delta == -8)
	    {
	      delta = (((line_ptr[0]) & 0xff) << 8) + ((line_ptr[1]) & 0xff);
	      if (delta >= 0x8000)
		delta -= 0x10000;
	      line_ptr += 2;
	    }
	  lineno += delta;
	  if (offset < count * 4)
	    {
	      line_info->cache.stop += count * 4 - offset;
	      break;
	    }
	  offset -= count * 4;
	}

      /* If fdr_ptr->rss is -1, then this file does not have full
         symbols, at least according to gdb/mipsread.c.  */
      if (fdr_ptr->rss == -1)
	{
	  line_info->cache.filename = NULL;
	  if (pdr.isym == -1)
	    line_info->cache.functionname = NULL;
	  else
	    {
	      EXTR proc_ext;

	      (*debug_swap->swap_ext_in)
		(abfd,
		 ((char *) debug_info->external_ext
		  + pdr.isym * debug_swap->external_ext_size),
		 &proc_ext);
	      line_info->cache.functionname = (debug_info->ssext
					       + proc_ext.asym.iss);
	    }
	}
      else
	{
	  SYMR proc_sym;

	  line_info->cache.filename = (debug_info->ss
				       + fdr_ptr->issBase
				       + fdr_ptr->rss);
	  (*debug_swap->swap_sym_in)
	    (abfd,
	     ((char *) debug_info->external_sym
	      + ((fdr_ptr->isymBase + pdr.isym)
		 * debug_swap->external_sym_size)),
	     &proc_sym);
	  line_info->cache.functionname = (debug_info->ss
					   + fdr_ptr->issBase
					   + proc_sym.iss);
	}
      if (lineno == ilineNil)
	lineno = 0;
      line_info->cache.line_num = lineno;
    }
  else
    {
      bfd_size_type external_sym_size;
      const char *directory_name;
      const char *main_file_name;
      const char *current_file_name;
      const char *function_name;
      const char *line_file_name;
      bfd_vma low_func_vma;
      bfd_vma low_line_vma;
      bfd_boolean past_line;
      bfd_boolean past_fn;
      char *sym_ptr, *sym_ptr_end;
      size_t len, funclen;
      char *buffer = NULL;

      /* This file uses stabs debugging information.  When gcc is not
	 optimizing, it will put the line number information before
	 the function name stabs entry.  When gcc is optimizing, it
	 will put the stabs entry for all the function first, followed
	 by the line number information.  (This appears to happen
	 because of the two output files used by the -mgpopt switch,
	 which is implied by -O).  This means that we must keep
	 looking through the symbols until we find both a line number
	 and a function name which are beyond the address we want.  */

      line_info->cache.filename = NULL;
      line_info->cache.functionname = NULL;
      line_info->cache.line_num = 0;

      directory_name = NULL;
      main_file_name = NULL;
      current_file_name = NULL;
      function_name = NULL;
      line_file_name = NULL;
      low_func_vma = 0;
      low_line_vma = 0;
      past_line = FALSE;
      past_fn = FALSE;

      external_sym_size = debug_swap->external_sym_size;

      sym_ptr = ((char *) debug_info->external_sym
		 + (fdr_ptr->isymBase + 2) * external_sym_size);
      sym_ptr_end = sym_ptr + (fdr_ptr->csym - 2) * external_sym_size;
      for (;
	   sym_ptr < sym_ptr_end && (! past_line || ! past_fn);
	   sym_ptr += external_sym_size)
	{
	  SYMR sym;

	  (*debug_swap->swap_sym_in) (abfd, sym_ptr, &sym);

	  if (ECOFF_IS_STAB (&sym))
	    {
	      switch (ECOFF_UNMARK_STAB (sym.index))
		{
		case N_SO:
		  main_file_name = current_file_name =
		    debug_info->ss + fdr_ptr->issBase + sym.iss;

		  /* Check the next symbol to see if it is also an
                     N_SO symbol.  */
		  if (sym_ptr + external_sym_size < sym_ptr_end)
		    {
		      SYMR nextsym;

		      (*debug_swap->swap_sym_in) (abfd,
						  sym_ptr + external_sym_size,
						  &nextsym);
		      if (ECOFF_IS_STAB (&nextsym)
			  && ECOFF_UNMARK_STAB (nextsym.index) == N_SO)
			{
 			  directory_name = current_file_name;
			  main_file_name = current_file_name =
			    debug_info->ss + fdr_ptr->issBase + nextsym.iss;
			  sym_ptr += external_sym_size;
			}
		    }
		  break;

		case N_SOL:
		  current_file_name =
		    debug_info->ss + fdr_ptr->issBase + sym.iss;
		  break;

		case N_FUN:
		  if (sym.value > offset)
		    past_fn = TRUE;
		  else if (sym.value >= low_func_vma)
		    {
		      low_func_vma = sym.value;
		      function_name =
			debug_info->ss + fdr_ptr->issBase + sym.iss;
		    }
		  break;
		}
	    }
	  else if (sym.st == stLabel && sym.index != indexNil)
	    {
	      if (sym.value > offset)
		past_line = TRUE;
	      else if (sym.value >= low_line_vma)
		{
		  low_line_vma = sym.value;
		  line_file_name = current_file_name;
		  line_info->cache.line_num = sym.index;
		}
	    }
	}

      if (line_info->cache.line_num != 0)
	main_file_name = line_file_name;

      /* We need to remove the stuff after the colon in the function
         name.  We also need to put the directory name and the file
         name together.  */
      if (function_name == NULL)
	len = funclen = 0;
      else
	len = funclen = strlen (function_name) + 1;

      if (main_file_name != NULL
	  && directory_name != NULL
	  && main_file_name[0] != '/')
	len += strlen (directory_name) + strlen (main_file_name) + 1;

      if (len != 0)
	{
	  if (line_info->find_buffer != NULL)
	    free (line_info->find_buffer);
	  buffer = (char *) bfd_malloc ((bfd_size_type) len);
	  if (buffer == NULL)
	    return FALSE;
	  line_info->find_buffer = buffer;
	}

      if (function_name != NULL)
	{
	  char *colon;

	  strcpy (buffer, function_name);
	  colon = strchr (buffer, ':');
	  if (colon != NULL)
	    *colon = '\0';
	  line_info->cache.functionname = buffer;
	}

      if (main_file_name != NULL)
	{
	  if (directory_name == NULL || main_file_name[0] == '/')
	    line_info->cache.filename = main_file_name;
	  else
	    {
	      sprintf (buffer + funclen, "%s%s", directory_name,
		       main_file_name);
	      line_info->cache.filename = buffer + funclen;
	    }
	}
    }

  return TRUE;
}

/* Do the work of find_nearest_line.  */

bfd_boolean
_bfd_ecoff_locate_line (bfd *abfd,
			asection *section,
			bfd_vma offset,
			struct ecoff_debug_info * const debug_info,
			const struct ecoff_debug_swap * const debug_swap,
			struct ecoff_find_line *line_info,
			const char **filename_ptr,
			const char **functionname_ptr,
			unsigned int *retline_ptr)
{
  offset += section->vma;

  if (line_info->cache.sect == NULL
      || line_info->cache.sect != section
      || offset < line_info->cache.start
      || offset >= line_info->cache.stop)
    {
      line_info->cache.sect = section;
      line_info->cache.start = offset;
      line_info->cache.stop = offset;
      if (! lookup_line (abfd, debug_info, debug_swap, line_info))
	{
	  line_info->cache.sect = NULL;
	  return FALSE;
	}
    }

  *filename_ptr = line_info->cache.filename;
  *functionname_ptr = line_info->cache.functionname;
  *retline_ptr = line_info->cache.line_num;

  return TRUE;
}

/* These routines copy symbolic information into a memory buffer.

   FIXME: The whole point of the shuffle code is to avoid storing
   everything in memory, since the linker is such a memory hog.  This
   code makes that effort useless.  It is only called by the MIPS ELF
   code when generating a shared library, so it is not that big a
   deal, but it should be fixed eventually.  */

/* Collect a shuffle into a memory buffer.  */

static bfd_boolean
ecoff_collect_shuffle (struct shuffle *l, bfd_byte *buff)
{
  unsigned long total;

  total = 0;
  for (; l != (struct shuffle *) NULL; l = l->next)
    {
      if (! l->filep)
	memcpy (buff, l->u.memory, l->size);
      else
	{
	  if (bfd_seek (l->u.file.input_bfd, l->u.file.offset, SEEK_SET) != 0
	      || (bfd_bread (buff, (bfd_size_type) l->size, l->u.file.input_bfd)
		  != l->size))
	    return FALSE;
	}
      total += l->size;
      buff += l->size;
    }

  return TRUE;
}

/* Copy PDR information into a memory buffer.  */

bfd_boolean
_bfd_ecoff_get_accumulated_pdr (void * handle,
				bfd_byte *buff)
{
  struct accumulate *ainfo = (struct accumulate *) handle;

  return ecoff_collect_shuffle (ainfo->pdr, buff);
}

/* Copy symbol information into a memory buffer.  */

bfd_boolean
_bfd_ecoff_get_accumulated_sym (void * handle, bfd_byte *buff)
{
  struct accumulate *ainfo = (struct accumulate *) handle;

  return ecoff_collect_shuffle (ainfo->sym, buff);
}

/* Copy the string table into a memory buffer.  */

bfd_boolean
_bfd_ecoff_get_accumulated_ss (void * handle, bfd_byte *buff)
{
  struct accumulate *ainfo = (struct accumulate *) handle;
  struct string_hash_entry *sh;
  unsigned long total;

  /* The string table is written out from the hash table if this is a
     final link.  */
  BFD_ASSERT (ainfo->ss == (struct shuffle *) NULL);
  *buff++ = '\0';
  total = 1;
  BFD_ASSERT (ainfo->ss_hash == NULL || ainfo->ss_hash->val == 1);
  for (sh = ainfo->ss_hash;
       sh != (struct string_hash_entry *) NULL;
       sh = sh->next)
    {
      size_t len;

      len = strlen (sh->root.string);
      memcpy (buff, sh->root.string, len + 1);
      total += len + 1;
      buff += len + 1;
    }

  return TRUE;
}
@


1.26
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d1791 1
a1791 1
	  tab->base_addr = fdr_ptr->adr; 
d1890 1
a1890 1
  
d2055 1
a2055 1
      
d2100 1
a2100 1
	      best_dist = (bfd_vma) min_dist;  
@


1.25
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a35 22
static bfd_boolean ecoff_add_bytes
  PARAMS ((char **buf, char **bufend, size_t need));
static struct bfd_hash_entry *string_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *));
static void ecoff_align_debug
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap));
static bfd_boolean ecoff_write_symhdr
  PARAMS ((bfd *, struct ecoff_debug_info *, const struct ecoff_debug_swap *,
	   file_ptr where));
static int cmp_fdrtab_entry
  PARAMS ((const PTR, const PTR));
static bfd_boolean mk_fdrtab
  PARAMS ((bfd *, struct ecoff_debug_info * const,
	   const struct ecoff_debug_swap * const, struct ecoff_find_line *));
static long fdrtab_lookup
  PARAMS ((struct ecoff_find_line *, bfd_vma));
static bfd_boolean lookup_line
  PARAMS ((bfd *, struct ecoff_debug_info * const,
	   const struct ecoff_debug_swap * const, struct ecoff_find_line *));

d45 2
a46 4
_bfd_ecoff_swap_tir_in (bigend, ext_copy, intern)
     int bigend;
     const struct tir_ext *ext_copy;
     TIR *intern;
d53 38
a90 35
  if (bigend) {
    intern->fBitfield   = 0 != (ext->t_bits1[0] & TIR_BITS1_FBITFIELD_BIG);
    intern->continued   = 0 != (ext->t_bits1[0] & TIR_BITS1_CONTINUED_BIG);
    intern->bt          = (ext->t_bits1[0] & TIR_BITS1_BT_BIG)
			>>		    TIR_BITS1_BT_SH_BIG;
    intern->tq4         = (ext->t_tq45[0] & TIR_BITS_TQ4_BIG)
			>>		    TIR_BITS_TQ4_SH_BIG;
    intern->tq5         = (ext->t_tq45[0] & TIR_BITS_TQ5_BIG)
			>>		    TIR_BITS_TQ5_SH_BIG;
    intern->tq0         = (ext->t_tq01[0] & TIR_BITS_TQ0_BIG)
			>>		    TIR_BITS_TQ0_SH_BIG;
    intern->tq1         = (ext->t_tq01[0] & TIR_BITS_TQ1_BIG)
			>>		    TIR_BITS_TQ1_SH_BIG;
    intern->tq2         = (ext->t_tq23[0] & TIR_BITS_TQ2_BIG)
			>>		    TIR_BITS_TQ2_SH_BIG;
    intern->tq3         = (ext->t_tq23[0] & TIR_BITS_TQ3_BIG)
			>>		    TIR_BITS_TQ3_SH_BIG;
  } else {
    intern->fBitfield   = 0 != (ext->t_bits1[0] & TIR_BITS1_FBITFIELD_LITTLE);
    intern->continued   = 0 != (ext->t_bits1[0] & TIR_BITS1_CONTINUED_LITTLE);
    intern->bt          = (ext->t_bits1[0] & TIR_BITS1_BT_LITTLE)
			>>		    TIR_BITS1_BT_SH_LITTLE;
    intern->tq4         = (ext->t_tq45[0] & TIR_BITS_TQ4_LITTLE)
			>>		    TIR_BITS_TQ4_SH_LITTLE;
    intern->tq5         = (ext->t_tq45[0] & TIR_BITS_TQ5_LITTLE)
			>>		    TIR_BITS_TQ5_SH_LITTLE;
    intern->tq0         = (ext->t_tq01[0] & TIR_BITS_TQ0_LITTLE)
			>>		    TIR_BITS_TQ0_SH_LITTLE;
    intern->tq1         = (ext->t_tq01[0] & TIR_BITS_TQ1_LITTLE)
			>>		    TIR_BITS_TQ1_SH_LITTLE;
    intern->tq2         = (ext->t_tq23[0] & TIR_BITS_TQ2_LITTLE)
			>>		    TIR_BITS_TQ2_SH_LITTLE;
    intern->tq3         = (ext->t_tq23[0] & TIR_BITS_TQ3_LITTLE)
			>>		    TIR_BITS_TQ3_SH_LITTLE;
  }
d103 3
a105 4
_bfd_ecoff_swap_tir_out (bigend, intern_copy, ext)
     int bigend;
     const TIR *intern_copy;
     struct tir_ext *ext;
d112 3
a114 2
  if (bigend) {
    ext->t_bits1[0] = ((intern->fBitfield ? TIR_BITS1_FBITFIELD_BIG : 0)
d118 1
a118 1
    ext->t_tq45[0] = (((intern->tq4 << TIR_BITS_TQ4_SH_BIG)
d122 1
a122 1
    ext->t_tq01[0] = (((intern->tq0 << TIR_BITS_TQ0_SH_BIG)
d126 1
a126 1
    ext->t_tq23[0] = (((intern->tq2 << TIR_BITS_TQ2_SH_BIG)
d130 4
a133 2
  } else {
    ext->t_bits1[0] = ((intern->fBitfield ? TIR_BITS1_FBITFIELD_LITTLE : 0)
d137 1
a137 1
    ext->t_tq45[0] = (((intern->tq4 << TIR_BITS_TQ4_SH_LITTLE)
d141 1
a141 1
    ext->t_tq01[0] = (((intern->tq0 << TIR_BITS_TQ0_SH_LITTLE)
d145 1
a145 1
    ext->t_tq23[0] = (((intern->tq2 << TIR_BITS_TQ2_SH_LITTLE)
d149 1
a149 1
  }
d161 3
a163 4
_bfd_ecoff_swap_rndx_in (bigend, ext_copy, intern)
     int bigend;
     const struct rndx_ext *ext_copy;
     RNDXR *intern;
d170 3
a172 2
  if (bigend) {
    intern->rfd   = (ext->r_bits[0] << RNDX_BITS0_RFD_SH_LEFT_BIG)
d175 1
a175 1
    intern->index = ((ext->r_bits[1] & RNDX_BITS1_INDEX_BIG)
d179 4
a182 2
  } else {
    intern->rfd   = (ext->r_bits[0] << RNDX_BITS0_RFD_SH_LEFT_LITTLE)
d185 1
a185 1
    intern->index = ((ext->r_bits[1] & RNDX_BITS1_INDEX_LITTLE)
d190 1
a190 1
  }
d202 3
a204 4
_bfd_ecoff_swap_rndx_out (bigend, intern_copy, ext)
     int bigend;
     const RNDXR *intern_copy;
     struct rndx_ext *ext;
d211 4
a214 3
  if (bigend) {
    ext->r_bits[0] = intern->rfd >> RNDX_BITS0_RFD_SH_LEFT_BIG;
    ext->r_bits[1] = (((intern->rfd << RNDX_BITS1_RFD_SH_BIG)
d218 7
a224 5
    ext->r_bits[2] = intern->index >> RNDX_BITS2_INDEX_SH_LEFT_BIG;
    ext->r_bits[3] = intern->index >> RNDX_BITS3_INDEX_SH_LEFT_BIG;
  } else {
    ext->r_bits[0] = intern->rfd >> RNDX_BITS0_RFD_SH_LEFT_LITTLE;
    ext->r_bits[1] = (((intern->rfd >> RNDX_BITS1_RFD_SH_LEFT_LITTLE)
d228 3
a230 3
    ext->r_bits[2] = intern->index >> RNDX_BITS2_INDEX_SH_LEFT_LITTLE;
    ext->r_bits[3] = intern->index >> RNDX_BITS3_INDEX_SH_LEFT_LITTLE;
  }
d244 1
a244 4
ecoff_add_bytes (buf, bufend, need)
     char **buf;
     char **bufend;
     size_t need;
d288 3
a290 4
string_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d344 1
a344 1
      PTR memory;
a385 4
static bfd_boolean add_file_shuffle
  PARAMS ((struct accumulate *, struct shuffle **, struct shuffle **,
	   bfd *, file_ptr, unsigned long));

d387 6
a392 7
add_file_shuffle (ainfo, head, tail, input_bfd, offset, size)
     struct accumulate *ainfo;
     struct shuffle **head;
     struct shuffle **tail;
     bfd *input_bfd;
     file_ptr offset;
     unsigned long size;
a431 4
static bfd_boolean add_memory_shuffle
  PARAMS ((struct accumulate *, struct shuffle **head, struct shuffle **tail,
	   bfd_byte *data, unsigned long size));

d433 5
a437 6
add_memory_shuffle (ainfo, head, tail, data, size)
     struct accumulate *ainfo;
     struct shuffle **head;
     struct shuffle **tail;
     bfd_byte *data;
     unsigned long size;
d451 1
a451 1
  n->u.memory = (PTR) data;
d463 5
a467 6
PTR
bfd_ecoff_debug_init (output_bfd, output_debug, output_swap, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct ecoff_debug_info *output_debug;
     const struct ecoff_debug_swap *output_swap ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d517 1
a517 1
  return (PTR) ainfo;
d523 5
a527 6
bfd_ecoff_debug_free (handle, output_bfd, output_debug, output_swap, info)
     PTR handle;
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct ecoff_debug_info *output_debug ATTRIBUTE_UNUSED;
     const struct ecoff_debug_swap *output_swap ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d550 8
a557 11
bfd_ecoff_debug_accumulate (handle, output_bfd, output_debug, output_swap,
			    input_bfd, input_debug, input_swap,
			    info)
     PTR handle;
     bfd *output_bfd;
     struct ecoff_debug_info *output_debug;
     const struct ecoff_debug_swap *output_swap;
     bfd *input_bfd;
     struct ecoff_debug_info *input_debug;
     const struct ecoff_debug_swap *input_swap;
     struct bfd_link_info *info;
d560 1
a560 1
  void (* const swap_sym_in) PARAMS ((bfd *, PTR, SYMR *))
d562 1
a562 1
  void (* const swap_rfd_in) PARAMS ((bfd *, PTR, RFDT *))
d564 1
a564 1
  void (* const swap_sym_out) PARAMS ((bfd *, const SYMR *, PTR))
d566 1
a566 1
  void (* const swap_fdr_out) PARAMS ((bfd *, const FDR *, PTR))
d568 1
a568 1
  void (* const swap_rfd_out) PARAMS ((bfd *, const RFDT *, PTR))
d596 1
a596 1
  memset ((PTR) section_adjust, 0, sizeof section_adjust);
d666 1
a666 1
	(*input_swap->swap_fdr_in) (input_bfd, (PTR) fdr_ptr, &fdr);
d698 1
a698 2
	      (*swap_rfd_out) (output_bfd, input_debug->ifdmap + i,
			       (PTR) rfd_out);
d708 1
a708 1
      (*swap_rfd_out) (output_bfd, input_debug->ifdmap + i, (PTR) rfd_out);
d726 1
a726 1
      (*swap_rfd_in) (input_bfd, (PTR) rfd_in, &rfd);
d729 1
a729 1
      (*swap_rfd_out) (output_bfd, &rfd, (PTR) rfd_out);
d766 1
a766 1
	(*input_swap->swap_fdr_in) (input_bfd, (PTR) fdr_ptr, &fdr);
d793 1
a793 1
	  (*swap_sym_in) (input_bfd, (PTR) lraw_src, &internal_sym);
d975 2
a976 2
	      (*input_swap->swap_pdr_in) (input_bfd, (PTR) in, &pdr);
	      (*output_swap->swap_pdr_out) (output_bfd, &pdr, (PTR) out);
d999 2
a1000 2
	      (*input_swap->swap_opt_in) (input_bfd, (PTR) in, &opt);
	      (*output_swap->swap_opt_out) (output_bfd, &opt, (PTR) out);
a1031 4
static long ecoff_add_string
  PARAMS ((struct accumulate *, struct bfd_link_info *,
	   struct ecoff_debug_info *, FDR *fdr, const char *string));

d1033 5
a1037 6
ecoff_add_string (ainfo, info, debug, fdr, string)
     struct accumulate *ainfo;
     struct bfd_link_info *info;
     struct ecoff_debug_info *debug;
     FDR *fdr;
     const char *string;
d1081 6
a1086 8
bfd_ecoff_debug_accumulate_other (handle, output_bfd, output_debug,
				  output_swap, input_bfd, info)
     PTR handle;
     bfd *output_bfd;
     struct ecoff_debug_info *output_debug;
     const struct ecoff_debug_swap *output_swap;
     bfd *input_bfd;
     struct bfd_link_info *info;
d1089 1
a1089 1
  void (* const swap_sym_out) PARAMS ((bfd *, const SYMR *, PTR))
d1099 1
a1099 1
  PTR external_fdr;
d1101 1
a1101 1
  memset ((PTR) &fdr, 0, sizeof fdr);
d1138 1
a1138 1
      PTR external_sym;
d1142 1
a1142 1
      memset ((PTR) &internal_sym, 0, sizeof internal_sym);
d1159 2
a1160 2
      external_sym = (PTR) objalloc_alloc (ainfo->memory,
					   output_swap->external_sym_size);
d1174 1
a1174 1
  bfd_release (output_bfd, (PTR) symbols);
d1180 2
a1181 2
  external_fdr = (PTR) objalloc_alloc (ainfo->memory,
				       output_swap->external_fdr_size);
d1203 6
a1208 8
bfd_ecoff_debug_externals (abfd, debug, swap, relocatable, get_extr,
			   set_index)
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
     bfd_boolean relocatable;
     bfd_boolean (*get_extr) PARAMS ((asymbol *, EXTR *));
     void (*set_index) PARAMS ((asymbol *, bfd_size_type));
d1270 5
a1274 6
bfd_ecoff_debug_one_external (abfd, debug, swap, name, esym)
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
     const char *name;
     EXTR *esym;
d1277 1
a1277 1
  void (* const swap_ext_out) PARAMS ((bfd *, const EXTR *, PTR))
d1323 3
a1325 4
ecoff_align_debug (abfd, debug, swap)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
d1340 1
a1340 1
	memset ((PTR) (debug->line + symhdr->cbLine), 0, add);
d1348 1
a1348 1
	memset ((PTR) (debug->ss + symhdr->issMax), 0, add);
d1356 1
a1356 1
	memset ((PTR) (debug->ssext + symhdr->issExtMax), 0, add);
d1364 1
a1364 1
	memset ((PTR) (debug->external_aux + symhdr->iauxMax), 0,
d1372 3
a1374 3
      if (debug->external_rfd != (PTR) NULL)
	memset ((PTR) ((char *) debug->external_rfd
		       + symhdr->crfd * swap->external_rfd_size),
d1383 3
a1385 4
bfd_ecoff_debug_size (abfd, debug, swap)
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
d1417 4
a1420 5
ecoff_write_symhdr (abfd, debug, swap, where)
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
     file_ptr where;
d1483 4
a1486 5
bfd_ecoff_write_debug (abfd, debug, swap, where)
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
     file_ptr where;
d1496 1
a1496 1
  if (bfd_bwrite ((PTR) debug->ptr, (bfd_size_type) size * symhdr->count, abfd)\
a1518 3
static bfd_boolean ecoff_write_shuffle
  PARAMS ((bfd *, const struct ecoff_debug_swap *, struct shuffle *,
	   PTR space));
d1521 4
a1524 5
ecoff_write_shuffle (abfd, swap, shuffle, space)
     bfd *abfd;
     const struct ecoff_debug_swap *swap;
     struct shuffle *shuffle;
     PTR space;
d1526 1
a1526 1
  register struct shuffle *l;
d1559 1
a1559 1
      if (bfd_bwrite ((PTR) s, (bfd_size_type) i, abfd) != i)
d1574 6
a1579 7
bfd_ecoff_write_accumulated_debug (handle, abfd, debug, swap, info, where)
     PTR handle;
     bfd *abfd;
     struct ecoff_debug_info *debug;
     const struct ecoff_debug_swap *swap;
     struct bfd_link_info *info;
     file_ptr where;
d1582 1
a1582 1
  PTR space = NULL;
d1589 1
a1589 1
  space = (PTR) bfd_malloc (amt);
d1616 1
a1616 1
      if (bfd_bwrite ((PTR) &null, (bfd_size_type) 1, abfd) != 1)
d1628 1
a1628 1
	  if (bfd_bwrite ((PTR) sh->root.string, amt, abfd) != amt)
d1643 1
a1643 1
	  if (bfd_bwrite ((PTR) s, (bfd_size_type) i, abfd) != i)
d1668 1
a1668 1
      if (bfd_bwrite ((PTR) s, (bfd_size_type) i, abfd) != i)
d1704 1
a1704 3
cmp_fdrtab_entry (leftp, rightp)
     const PTR leftp;
     const PTR rightp;
d1725 4
a1728 5
mk_fdrtab (abfd, debug_info, debug_swap, line_info)
     bfd *abfd;
     struct ecoff_debug_info * const debug_info;
     const struct ecoff_debug_swap * const debug_swap;
     struct ecoff_find_line *line_info;
d1807 1
a1807 1
  qsort ((PTR) line_info->fdrtab, (size_t) len,
d1816 1
a1816 3
fdrtab_lookup (line_info, offset)
     struct ecoff_find_line *line_info;
     bfd_vma offset;
d1864 4
a1867 5
lookup_line (abfd, debug_info, debug_swap, line_info)
     bfd *abfd;
     struct ecoff_debug_info * const debug_info;
     const struct ecoff_debug_swap * const debug_swap;
     struct ecoff_find_line *line_info;
d2073 1
a2073 1
	  (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
d2082 1
a2082 1
		(*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr)))
d2116 1
a2116 1
      (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
d2361 9
a2369 11
_bfd_ecoff_locate_line (abfd, section, offset, debug_info, debug_swap,
			line_info, filename_ptr, functionname_ptr, retline_ptr)
     bfd *abfd;
     asection *section;
     bfd_vma offset;
     struct ecoff_debug_info * const debug_info;
     const struct ecoff_debug_swap * const debug_swap;
     struct ecoff_find_line *line_info;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *retline_ptr;
a2404 3
static bfd_boolean ecoff_collect_shuffle
  PARAMS ((struct shuffle *, bfd_byte *));

d2406 1
a2406 3
ecoff_collect_shuffle (l, buff)
     struct shuffle *l;
     bfd_byte *buff;
d2432 2
a2433 3
_bfd_ecoff_get_accumulated_pdr (handle, buff)
     PTR handle;
     bfd_byte *buff;
d2443 1
a2443 3
_bfd_ecoff_get_accumulated_sym (handle, buff)
     PTR handle;
     bfd_byte *buff;
d2453 1
a2453 3
_bfd_ecoff_get_accumulated_ss (handle, buff)
     PTR handle;
     bfd_byte *buff;
d2472 1
a2472 1
      memcpy (buff, (PTR) sh->root.string, len + 1);
@


1.24
log
@Silence gcc printf warnings
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d1087 2
a1088 2
      if (!add_memory_shuffle (ainfo, &ainfo->ss, &ainfo->ss_end, (PTR) string,
			       len + 1))
d1210 1
a1210 1
			  external_sym,
d1231 1
a1231 1
		      external_fdr,
d1341 2
a1342 2
      char *external_ext = debug->external_ext;
      char *external_ext_end = debug->external_ext_end;
d1506 1
a1506 1
  buff = (PTR) bfd_malloc (swap->external_hdr_size);
@


1.23
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d721 2
a722 1
	  sprintf (lookup, "%s %lx %lx", name, fdr.csym, fdr.caux);
@


1.22
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.21
log
@	* coff-or32.c (bfd_section_from_shdr): Remove unused local
	variable `ptr'.
	* cofflink.c (process_embedded_commands): Remove unused local
	variables `had_read' and `had_shared'.
	* ecofflink.c (bfd_ecoff_debug_accumulate): Remove unused local
	variable `fdr_adr'.
	* ihex.c (ihex_read_section): Remove unused local variable `addr'.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@


1.20
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@a784 1
      bfd_vma fdr_adr;
a800 2
      fdr_adr = fdr.adr;

@


1.19
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d504 2
a505 2
  if (! bfd_hash_table_init_n (&ainfo->fdr_hash.table, string_hash_newfunc,
			       1021))
d531 2
a532 1
      if (! bfd_hash_table_init (&ainfo->str_hash.table, string_hash_newfunc))
@


1.18
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1341 4
a1344 2
      if (! ecoff_add_bytes ((char **) &debug->external_ext,
			     (char **) &debug->external_ext_end,
d1347 2
@


1.17
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.16
log
@update copyright dates
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.15
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.14
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@a1841 14
#if 0
	    bfd_size_type external_pdr_size;
	    char *pdr_ptr;
	    PDR pdr;
	    
	    external_pdr_size = debug_swap->external_pdr_size;
	    
	    pdr_ptr = ((char *) debug_info->external_pdr
	              + fdr_ptr->ipdFirst * external_pdr_size);
	    (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
	  /* The address of the first PDR is the offset of that
	     procedure relative to the beginning of file FDR.  */
	    tab->base_addr = fdr_ptr->adr - pdr.adr;
#else
a1844 1
#endif
a2102 5
#if 0 /* eraxxon: PDR addresses (pdr.adr) are not relative to FDRs!
	 Leave 'offset' alone.  */
      /* Make offset relative to object file's start-address.  */
      offset -= tab[i].base_addr;
#endif
@


1.13
log
@[ bfd/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * coff-mips.c (mips_relhi_reloc, mips_rello_reloc)
        (mips_switch_reloc, mips_read_relocs, mips_relax_section)
        (mips_relax_pcrel16, PCREL16_EXPANSION_ADJUSTMENT): Remove.
        (mips_relocate_hi): Remove now-unused 'adjust' and 'pcrel' arguments,
        and update comments to reflect current usage.
        (mips_howto_table): Remove entries for MIPS_R_RELHI, MIPS_R_RELLO,
        and MIPS_R_SWITCH, as well as several empty entries.  Update comment
        for MIPS_R_PCREL16.
        (mips_ecoff_swap_reloc_in, mips_ecoff_swap_reloc_out)
        (mips_adjust_reloc_out, mips_bfd_reloc_type_lookup): Remove support
        for MIPS_R_SWITCH, MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (mips_adjust_reloc_in): Likewise, adjust maximum accepted relocation
        type number to be MIPS_R_PCREL16.
        (mips_relocate_section): Remove support for link-time relaxation
        of branches used by embedded-PIC.  Remove support for MIPS_R_SWITCH,
        MIPS_R_RELLO, and MIPS_R_RELHI relocations.
        (_bfd_ecoff_bfd_relax_section): Redefine to bfd_generic_relax_section.
        * ecoff.c (ecoff_indirect_link_order): Remove support for link-time
        relaxation of branches used by embedded-PIC.
        * ecofflink.c (bfd_ecoff_debug_accumulate): Likewise.
        * libecoff.h (struct ecoff_section_tdata): Remove embedded-PIC
        related members, update comment.
        * pe-mips.c: Remove disabled (commented-out and #if 0'd)
        code related to embedded-PIC.
        * elfxx-mips.c (_bfd_mips_elf_read_ecoff_info): Remove
        initialization of now-removed 'adjust' member of
        'struct ecoff_debug_info'.

[ include/coff/ChangeLog ]
2004-04-23  Chris Demetriou  <cgd@@broadcom.com>

        * mips.h (MIPS_R_RELHI, MIPS_R_RELLO, MIPS_R_SWITCH): Remove
        (MIPS_R_PCREL16): Update comment.
        * ecoff.h (struct ecoff_value_adjust): Remove structure.
        (struct ecoff_debug_info): Remove 'adjust' member.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d1157 1
a1157 1
			      bfd_archive_filename (input_bfd));
@


1.12
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@a802 14
      /* Adjust the FDR address for any changes that may have been
	 made by relaxing.  */
      if (input_debug->adjust != (struct ecoff_value_adjust *) NULL)
	{
	  struct ecoff_value_adjust *adjust;

	  for (adjust = input_debug->adjust;
	       adjust != (struct ecoff_value_adjust *) NULL;
	       adjust = adjust->next)
	    if (fdr_adr >= adjust->start
		&& fdr_adr < adjust->end)
	      fdr.adr += adjust->adjust;
	}

a844 13
	      if (input_debug->adjust != (struct ecoff_value_adjust *) NULL)
		{
		  bfd_vma value;
		  struct ecoff_value_adjust *adjust;

		  value = internal_sym.value;
		  for (adjust = input_debug->adjust;
		       adjust != (struct ecoff_value_adjust *) NULL;
		       adjust = adjust->next)
		    if (value >= adjust->start
			&& value < adjust->end)
		      internal_sym.value += adjust->adjust;
		}
d954 2
a955 3
      if ((output_bfd->xvec->header_byteorder
	   == input_bfd->xvec->header_byteorder)
	  && input_debug->adjust == (struct ecoff_value_adjust *) NULL)
a1010 17

	      /* If we have been relaxing, we may have to adjust the
		 address.  */
	      if (input_debug->adjust != (struct ecoff_value_adjust *) NULL)
		{
		  bfd_vma adr;
		  struct ecoff_value_adjust *adjust;

		  adr = fdr_adr + pdr.adr;
		  for (adjust = input_debug->adjust;
		       adjust != (struct ecoff_value_adjust *) NULL;
		       adjust = adjust->next)
		    if (adr >= adjust->start
			&& adr < adjust->end)
		      pdr.adr += adjust->adjust;
		}

@


1.12.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003, 2004
d803 14
d859 13
d981 3
a983 2
      if (output_bfd->xvec->header_byteorder
	  == input_bfd->xvec->header_byteorder)
d1039 17
d1202 1
a1202 1
			      input_bfd->filename);
@


1.11
log
@Correct spelling of "relocatable".
@
text
@d2010 1
a2010 1
     y < 'offset' < z.  It is possble at times that the PDR for 'offset' is
d2033 1
a2033 1
     genarated routines, I thought a simple fix would be to exclude them from
@


1.10
log
@Fix the reading of the debugging information of Tru64/Alpha binaries that
are produced by recent Compaq compilers.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002
d529 1
a529 1
  if (! info->relocateable)
d562 1
a562 1
  if (! info->relocateable)
d882 1
a882 1
	     this when performing a relocateable link because it would
d884 1
a884 1
	  if (! info->relocateable)
d961 1
a961 1
      if (! info->relocateable)
d1130 1
a1130 1
  if (info->relocateable)
d1290 1
a1290 1
bfd_ecoff_debug_externals (abfd, debug, swap, relocateable, get_extr,
d1295 1
a1295 1
     bfd_boolean relocateable;
d1320 1
a1320 1
      if (! relocateable)
d1697 1
a1697 1
  if (info->relocateable)
@


1.9
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1839 1
a1839 1
  /* First, let's see how long the table needs to be: */
d1842 1
a1842 1
      if (fdr_ptr->cpd == 0)	/* skip FDRs that have no PDRs */
d1847 1
a1847 2
  /* Now, create and fill in the table: */

d1870 1
a1870 1
		     + (fdr_ptr->isymBase + 1)*debug_swap->external_sym_size);
d1879 22
a1900 9
	  bfd_size_type external_pdr_size;
	  char *pdr_ptr;
	  PDR pdr;

	  external_pdr_size = debug_swap->external_pdr_size;

	  pdr_ptr = ((char *) debug_info->external_pdr
		     + fdr_ptr->ipdFirst * external_pdr_size);
	  (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
d1903 2
a1904 1
	  tab->base_addr = fdr_ptr->adr - pdr.adr;
d1909 1
a1909 1
	     (davidm@@cs.arizona.edu): */
d1953 6
d1961 1
a1961 1
  /* last entry is catch-all for all higher addresses: */
d1967 2
d1991 1
d2002 1
a2002 1
  /* find first FDR for address OFFSET */
d2006 70
d2101 1
a2101 1
      bfd_vma best_dist = ~(bfd_vma) 0;
d2163 3
a2165 1
      /* Make offset relative to object file's start-address: */
d2167 10
d2182 4
a2185 1
	  bfd_vma dist, min_dist = 0;
d2208 4
a2211 1
		  if (!pdr_hold || dist < min_dist)
d2219 1
a2219 1
	  if (!best_pdr || min_dist < best_dist)
d2221 1
a2221 1
	      best_dist = min_dist;
d2225 1
a2225 1
	  /* continue looping until base_addr of next entry is different: */
d2227 3
a2229 2
      while (++i < line_info->fdrtab_len
	     && tab[i].base_addr == tab[i - 1].base_addr);
d2232 1
a2232 1
	return FALSE;			/* shouldn't happen...  */
d2234 1
a2234 1
      /* phew, finally we got something that we can hold onto: */
d2244 1
a2244 1
      /* Make offset relative to procedure entry: */
@


1.8
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d35 2
a36 2
static boolean ecoff_add_bytes PARAMS ((char **buf, char **bufend,
					size_t need));
d40 14
a53 13
static void ecoff_align_debug PARAMS ((bfd *abfd,
				       struct ecoff_debug_info *debug,
				       const struct ecoff_debug_swap *swap));
static boolean ecoff_write_symhdr PARAMS ((bfd *, struct ecoff_debug_info *,
					   const struct ecoff_debug_swap *,
					   file_ptr where));
static int cmp_fdrtab_entry PARAMS ((const PTR, const PTR));
static boolean mk_fdrtab PARAMS ((bfd *,
				  struct ecoff_debug_info * const,
				  const struct ecoff_debug_swap * const,
				  struct ecoff_find_line *));
static long fdrtab_lookup PARAMS ((struct ecoff_find_line *, bfd_vma));
static boolean lookup_line
d257 1
a257 1
static boolean
d278 1
a278 1
    return false;
d281 1
a281 1
  return true;
d351 1
a351 1
  boolean filep;
d404 3
a406 4
static boolean add_file_shuffle PARAMS ((struct accumulate *,
				      struct shuffle **,
				      struct shuffle **, bfd *, file_ptr,
				      unsigned long));
d408 1
a408 1
static boolean
d428 1
a428 1
      return true;
d436 1
a436 1
      return false;
d440 1
a440 1
  n->filep = true;
d450 1
a450 1
  return true;
d455 3
a457 4
static boolean add_memory_shuffle PARAMS ((struct accumulate *,
					   struct shuffle **head,
					   struct shuffle **tail,
					   bfd_byte *data, unsigned long size));
d459 1
a459 1
static boolean
d474 1
a474 1
      return false;
d478 1
a478 1
  n->filep = false;
d485 1
a485 1
  return true;
d578 1
a578 1
boolean
d674 1
a674 1
      return false;
d677 1
a677 1
    return false;
d718 1
a718 1
	    return false;
d721 1
a721 1
	  fh = string_hash_lookup (&ainfo->fdr_hash, lookup, true, true);
d724 1
a724 1
	    return false;
d775 1
a775 1
      return false;
d778 1
a778 1
    return false;
d788 1
a788 1
      boolean fgotfilename;
d824 1
a824 1
      fgotfilename = false;
d830 1
a830 1
	  return false;
d834 1
a834 1
	return false;
d886 1
a886 1
	      boolean ffilename;
d890 1
a890 1
		ffilename = true;
d892 1
a892 1
		ffilename = false;
d902 1
a902 1
		  sh = string_hash_lookup (&ainfo->str_hash, name, true, true);
d904 1
a904 1
		    return false;
d922 1
a922 1
		  fgotfilename = true;
d944 1
a944 1
	    return false;
d957 1
a957 1
	    return false;
d976 1
a976 1
	    return false;
d996 1
a996 1
		return false;
d1006 1
a1006 1
		return false;
d1029 1
a1029 1
	      return false;
d1033 1
a1033 1
	    return false;
d1070 1
a1070 1
	      return false;
d1074 1
a1074 1
	    return false;
d1106 1
a1106 1
  return true;
d1112 3
a1114 4
static long ecoff_add_string PARAMS ((struct accumulate *,
				      struct bfd_link_info *,
				      struct ecoff_debug_info *,
				      FDR *fdr, const char *string));
d1143 1
a1143 1
      sh = string_hash_lookup (&ainfo->str_hash, string, true, true);
d1165 1
a1165 1
boolean
d1204 1
a1204 1
    return false;
d1210 1
a1210 1
    return false;
d1213 1
a1213 1
    return false;
d1216 1
a1216 1
    return false;
d1234 1
a1234 1
	return false;
d1251 1
a1251 1
	  return false;
d1272 1
a1272 1
      return false;
d1281 1
a1281 1
  return true;
d1289 1
a1289 1
boolean
d1295 2
a1296 2
     boolean relocateable;
     boolean (*get_extr) PARAMS ((asymbol *, EXTR *));
d1305 1
a1305 1
    return true;
d1350 1
a1350 1
	return false;
d1353 1
a1353 1
  return true;
d1358 1
a1358 1
boolean
d1380 1
a1380 1
	return false;
d1389 1
a1389 1
	return false;
d1403 1
a1403 1
  return true;
d1504 1
a1504 1
static boolean
d1518 1
a1518 1
    return false;
d1558 1
a1558 1
  return true;
d1562 1
a1562 1
  return false;
d1571 1
a1571 1
boolean
d1581 1
a1581 1
    return false;
d1588 1
a1588 1
    return false;
d1604 1
a1604 1
  return true;
d1609 3
a1611 3
static boolean ecoff_write_shuffle PARAMS ((bfd *,
					    const struct ecoff_debug_swap *,
					    struct shuffle *, PTR space));
d1613 1
a1613 1
static boolean
d1630 1
a1630 1
	    return false;
d1638 1
a1638 1
	    return false;
d1651 1
a1651 1
	return false;
d1656 1
a1656 1
	  return false;
d1661 1
a1661 1
  return true;
d1667 1
a1667 1
boolean
d1785 1
a1785 1
  return true;
d1790 1
a1790 1
  return false;
d1821 1
a1821 1
static boolean
d1832 1
a1832 1
  boolean stabs;
d1852 1
a1852 1
    return false;
d1864 1
a1864 1
      stabs = false;
d1875 1
a1875 1
	    stabs = true;
d1910 1
a1910 1
  return true;
d1957 1
a1957 1
static boolean
d1966 1
a1966 1
  boolean stabs;
d1976 1
a1976 1
    return false;
d1983 1
a1983 1
    return false;		/* no FDR, no fun...  */
d1989 1
a1989 1
  stabs = false;
d2000 1
a2000 1
	stabs = true;
d2121 1
a2121 1
	return false;			/* shouldn't happen...  */
d2214 2
a2215 2
      boolean past_line;
      boolean past_fn;
d2241 2
a2242 2
      past_line = false;
      past_fn = false;
d2292 1
a2292 1
		    past_fn = true;
d2305 1
a2305 1
		past_line = true;
d2337 1
a2337 1
	    return false;
d2365 1
a2365 1
  return true;
d2370 1
a2370 1
boolean
d2396 1
a2396 1
	  return false;
d2404 1
a2404 1
  return true;
d2417 2
a2418 1
static boolean ecoff_collect_shuffle PARAMS ((struct shuffle *, bfd_byte *));
d2420 1
a2420 1
static boolean
d2437 1
a2437 1
	    return false;
d2443 1
a2443 1
  return true;
d2448 1
a2448 1
boolean
d2460 1
a2460 1
boolean
d2472 1
a2472 1
boolean
d2499 1
a2499 1
  return true;
@


1.8.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 2
a36 2
static bfd_boolean ecoff_add_bytes
  PARAMS ((char **buf, char **bufend, size_t need));
d40 13
a52 14
static void ecoff_align_debug
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap));
static bfd_boolean ecoff_write_symhdr
  PARAMS ((bfd *, struct ecoff_debug_info *, const struct ecoff_debug_swap *,
	   file_ptr where));
static int cmp_fdrtab_entry
  PARAMS ((const PTR, const PTR));
static bfd_boolean mk_fdrtab
  PARAMS ((bfd *, struct ecoff_debug_info * const,
	   const struct ecoff_debug_swap * const, struct ecoff_find_line *));
static long fdrtab_lookup
  PARAMS ((struct ecoff_find_line *, bfd_vma));
static bfd_boolean lookup_line
d256 1
a256 1
static bfd_boolean
d277 1
a277 1
    return FALSE;
d280 1
a280 1
  return TRUE;
d350 1
a350 1
  bfd_boolean filep;
d403 4
a406 3
static bfd_boolean add_file_shuffle
  PARAMS ((struct accumulate *, struct shuffle **, struct shuffle **,
	   bfd *, file_ptr, unsigned long));
d408 1
a408 1
static bfd_boolean
d428 1
a428 1
      return TRUE;
d436 1
a436 1
      return FALSE;
d440 1
a440 1
  n->filep = TRUE;
d450 1
a450 1
  return TRUE;
d455 4
a458 3
static bfd_boolean add_memory_shuffle
  PARAMS ((struct accumulate *, struct shuffle **head, struct shuffle **tail,
	   bfd_byte *data, unsigned long size));
d460 1
a460 1
static bfd_boolean
d475 1
a475 1
      return FALSE;
d479 1
a479 1
  n->filep = FALSE;
d486 1
a486 1
  return TRUE;
d530 1
a530 1
  if (! info->relocatable)
d563 1
a563 1
  if (! info->relocatable)
d579 1
a579 1
bfd_boolean
d675 1
a675 1
      return FALSE;
d678 1
a678 1
    return FALSE;
d719 1
a719 1
	    return FALSE;
d722 1
a722 1
	  fh = string_hash_lookup (&ainfo->fdr_hash, lookup, TRUE, TRUE);
d725 1
a725 1
	    return FALSE;
d776 1
a776 1
      return FALSE;
d779 1
a779 1
    return FALSE;
d789 1
a789 1
      bfd_boolean fgotfilename;
d825 1
a825 1
      fgotfilename = FALSE;
d831 1
a831 1
	  return FALSE;
d835 1
a835 1
	return FALSE;
d883 1
a883 1
	     this when performing a relocatable link because it would
d885 1
a885 1
	  if (! info->relocatable)
d887 1
a887 1
	      bfd_boolean ffilename;
d891 1
a891 1
		ffilename = TRUE;
d893 1
a893 1
		ffilename = FALSE;
d903 1
a903 1
		  sh = string_hash_lookup (&ainfo->str_hash, name, TRUE, TRUE);
d905 1
a905 1
		    return FALSE;
d923 1
a923 1
		  fgotfilename = TRUE;
d945 1
a945 1
	    return FALSE;
d958 1
a958 1
	    return FALSE;
d962 1
a962 1
      if (! info->relocatable)
d977 1
a977 1
	    return FALSE;
d997 1
a997 1
		return FALSE;
d1007 1
a1007 1
		return FALSE;
d1030 1
a1030 1
	      return FALSE;
d1034 1
a1034 1
	    return FALSE;
d1071 1
a1071 1
	      return FALSE;
d1075 1
a1075 1
	    return FALSE;
d1107 1
a1107 1
  return TRUE;
d1113 4
a1116 3
static long ecoff_add_string
  PARAMS ((struct accumulate *, struct bfd_link_info *,
	   struct ecoff_debug_info *, FDR *fdr, const char *string));
d1132 1
a1132 1
  if (info->relocatable)
d1145 1
a1145 1
      sh = string_hash_lookup (&ainfo->str_hash, string, TRUE, TRUE);
d1167 1
a1167 1
bfd_boolean
d1206 1
a1206 1
    return FALSE;
d1212 1
a1212 1
    return FALSE;
d1215 1
a1215 1
    return FALSE;
d1218 1
a1218 1
    return FALSE;
d1236 1
a1236 1
	return FALSE;
d1253 1
a1253 1
	  return FALSE;
d1274 1
a1274 1
      return FALSE;
d1283 1
a1283 1
  return TRUE;
d1291 2
a1292 2
bfd_boolean
bfd_ecoff_debug_externals (abfd, debug, swap, relocatable, get_extr,
d1297 2
a1298 2
     bfd_boolean relocatable;
     bfd_boolean (*get_extr) PARAMS ((asymbol *, EXTR *));
d1307 1
a1307 1
    return TRUE;
d1322 1
a1322 1
      if (! relocatable)
d1352 1
a1352 1
	return FALSE;
d1355 1
a1355 1
  return TRUE;
d1360 1
a1360 1
bfd_boolean
d1382 1
a1382 1
	return FALSE;
d1391 1
a1391 1
	return FALSE;
d1405 1
a1405 1
  return TRUE;
d1506 1
a1506 1
static bfd_boolean
d1520 1
a1520 1
    return FALSE;
d1560 1
a1560 1
  return TRUE;
d1564 1
a1564 1
  return FALSE;
d1573 1
a1573 1
bfd_boolean
d1583 1
a1583 1
    return FALSE;
d1590 1
a1590 1
    return FALSE;
d1606 1
a1606 1
  return TRUE;
d1611 3
a1613 3
static bfd_boolean ecoff_write_shuffle
  PARAMS ((bfd *, const struct ecoff_debug_swap *, struct shuffle *,
	   PTR space));
d1615 1
a1615 1
static bfd_boolean
d1632 1
a1632 1
	    return FALSE;
d1640 1
a1640 1
	    return FALSE;
d1653 1
a1653 1
	return FALSE;
d1658 1
a1658 1
	  return FALSE;
d1663 1
a1663 1
  return TRUE;
d1669 1
a1669 1
bfd_boolean
d1699 1
a1699 1
  if (info->relocatable)
d1787 1
a1787 1
  return TRUE;
d1792 1
a1792 1
  return FALSE;
d1823 1
a1823 1
static bfd_boolean
d1834 1
a1834 1
  bfd_boolean stabs;
d1841 1
a1841 1
  /* First, let's see how long the table needs to be.  */
d1844 1
a1844 1
      if (fdr_ptr->cpd == 0)	/* Skip FDRs that have no PDRs.  */
d1849 2
a1850 1
  /* Now, create and fill in the table.  */
d1854 1
a1854 1
    return FALSE;
d1866 1
a1866 1
      stabs = FALSE;
d1873 1
a1873 1
		     + (fdr_ptr->isymBase + 1) * debug_swap->external_sym_size);
d1877 1
a1877 1
	    stabs = TRUE;
d1882 9
a1890 18
	  /* eraxxon: There are at least two problems with this computation:
	     1) PDRs do *not* contain offsets but full vma's; and typically the
	     address of the first PDR is the address of the FDR, which will
	     make (most) of the results of the original computation 0!
	     2) Once in a wacky while, the Compaq compiler generated PDR
	     addresses do not equal the FDR vma, but they (the PDR address)
	     are still vma's and not offsets.  Cf. comments in
	     'lookup_line'.  */
#if 0
	    bfd_size_type external_pdr_size;
	    char *pdr_ptr;
	    PDR pdr;
	    
	    external_pdr_size = debug_swap->external_pdr_size;
	    
	    pdr_ptr = ((char *) debug_info->external_pdr
	              + fdr_ptr->ipdFirst * external_pdr_size);
	    (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
d1893 1
a1893 6
	    tab->base_addr = fdr_ptr->adr - pdr.adr;
#else
	  /* The address of the first PDR is the offset of that
	     procedure relative to the beginning of file FDR.  */
	  tab->base_addr = fdr_ptr->adr; 
#endif
d1898 1
a1898 1
	     (davidm@@cs.arizona.edu).  */
d1912 1
a1912 1
  return TRUE;
a1941 6

  /* eraxxon: at this point 'offset' is either lower than the lowest entry or
     higher than the highest entry. In the former case high = low = mid = 0;
     we want to return -1.  In the latter case, low = high and mid = low - 1;
     we want to return the index of the highest entry.  Only in former case
     will the following 'catch-all' test be true.  */
d1944 1
a1944 1
  /* Last entry is catch-all for all higher addresses.  */
a1949 2
  /* eraxxon: There may be multiple FDRs in the table with the
     same base_addr; make sure that we are at the first one.  */
d1959 1
a1959 1
static bfd_boolean
d1968 1
a1968 1
  bfd_boolean stabs;
a1971 1
  /* eraxxon: note that 'offset' is the full vma, not a section offset.  */
d1978 1
a1978 1
    return FALSE;
d1982 1
a1982 1
  /* Find first FDR for address OFFSET.  */
d1985 1
a1985 71
    return FALSE;		/* no FDR, no fun...  */
  
  /* eraxxon: 'fdrtab_lookup' doesn't give what we want, at least for Compaq's
     C++ compiler 6.2.  Consider three FDRs with starting addresses of x, y,
     and z, respectively, such that x < y < z.  Assume further that
     y < 'offset' < z.  It is possible at times that the PDR for 'offset' is
     associated with FDR x and *not* with FDR y.  Erg!!

     From a binary dump of my C++ test case 'moo' using Compaq's coffobjanl
     (output format has been edited for our purposes):

     FDR [2]: (main.C): First instruction: 0x12000207c <x>
       PDR [5] for File [2]: LoopTest__Xv                 <0x1200020a0> (a)
       PDR [7] for File [2]: foo__Xv                      <0x120002168>
     FDR [1]: (-1):     First instruction: 0x1200020e8 <y>
       PDR [3] for File [1]:                              <0x120001ad0> (b)
     FDR [6]: (-1):     First instruction: 0x1200026f0 <z>

     (a) In the case of PDR5, the vma is such that the first few instructions
     of the procedure can be found.  But since the size of this procedure is
     160b, the vma will soon cross into the 'address space' of FDR1 and no
     debugging info will be found.  How repugnant!

     (b) It is also possible for a PDR to have a *lower* vma than its associated
     FDR; see FDR1 and PDR3.  Gross!

     Since the FDRs that are causing so much havok (in this case) 1) do not
     describe actual files (fdr.rss == -1), and 2) contain only compiler
     generated routines, I thought a simple fix would be to exclude them from
     the FDR table in 'mk_fdrtab'.  But, besides not knowing for certain
     whether this would be correct, it creates an additional problem.  If we
     happen to ask for source file info on a compiler generated (procedure)
     symbol -- which is still in the symbol table -- the result can be
     information from a real procedure!  This is because compiler generated
     procedures with vma's higher than the last FDR in the fdr table will be
     associated with a PDR from this FDR, specifically the PDR with the
     highest vma.  This wasn't a problem before, because each procedure had a
     PDR.  (Yes, this problem could be eliminated if we kept the size of the
     last PDR around, but things are already getting ugly).

     Probably, a better solution would be to have a sorted PDR table.  Each
     PDR would have a pointer to its FDR so file information could still be
     obtained.  A FDR table could still be constructed if necessary -- since
     it only contains pointers, not much extra memory would be used -- but
     the PDR table would be searched to locate debugging info.

     There is still at least one remaining issue.  Sometimes a FDR can have a
     bogus name, but contain PDRs that should belong to another FDR with a
     real name.  E.g:

     FDR [3]: 0000000120001b50 (/home/.../Array.H~alt~deccxx_5E5A62AD)
       PDR [a] for File [3]: 0000000120001b50
       PDR [b] for File [3]: 0000000120001cf0
       PDR [c] for File [3]: 0000000120001dc8
       PDR [d] for File [3]: 0000000120001e40
       PDR [e] for File [3]: 0000000120001eb8
       PDR [f] for File [3]: 0000000120001f4c
     FDR [4]: 0000000120001b50 (/home/.../Array.H)

     Here, FDR4 has the correct name, but should (seemingly) contain PDRa-f.
     The symbol table for PDR4 does contain symbols for PDRa-f, but so does
     the symbol table for FDR3.  However the former is different; perhaps this
     can be detected easily. (I'm not sure at this point.)  This problem only
     seems to be associated with files with templates.  I am assuming the idea
     is that there is a 'fake' FDR (with PDRs) for each differently typed set
     of templates that must be generated.  Currently, FDR4 is completely
     excluded from the FDR table in 'mk_fdrtab' because it contains no PDRs.

     Since I don't have time to prepare a real fix for this right now, be
     prepared for 'A Horrible Hack' to force the inspection of all non-stabs
     FDRs.  It's coming...  */
d1991 1
a1991 1
  stabs = FALSE;
d2002 1
a2002 1
	stabs = TRUE;
d2011 1
a2011 1
      bfd_signed_vma best_dist = -1;
d2073 1
a2073 3
#if 0 /* eraxxon: PDR addresses (pdr.adr) are not relative to FDRs!
	 Leave 'offset' alone.  */
      /* Make offset relative to object file's start-address.  */
a2074 10
#endif
      /* eraxxon: The Horrible Hack: Because of the problems above, set 'i'
	 to 0 so we look through all FDRs.

	 Because FDR's without any symbols are assumed to be non-stabs,
	 searching through all FDRs may cause the following code to try to
	 read stabs FDRs as ECOFF ones.  However, I don't think this will
	 harm anything.  */
      i = 0;
      
d2080 1
a2080 4
	  /* eraxxon: 'dist' and 'min_dist' can be negative now
             because we iterate over every FDR rather than just ones
             with a base address less than or equal to 'offset'.  */
	  bfd_signed_vma dist = -1, min_dist = -1;
d2103 1
a2103 4

		  /* eraxxon: 'dist' can be negative now.  Note that
                     'min_dist' can be negative if 'pdr_hold' below is NULL.  */
		  if (!pdr_hold || (dist >= 0 && dist < min_dist))
d2111 1
a2111 1
	  if (!best_pdr || (min_dist >= 0 && min_dist < best_dist))
d2113 1
a2113 1
	      best_dist = (bfd_vma) min_dist;  
d2117 1
a2117 1
	  /* Continue looping until base_addr of next entry is different.  */
d2119 2
a2120 3
      /* eraxxon: We want to iterate over all FDRs.
	 See previous comment about 'fdrtab_lookup'.  */
      while (++i < line_info->fdrtab_len);
d2123 1
a2123 1
	return FALSE;			/* Shouldn't happen...  */
d2125 1
a2125 1
      /* Phew, finally we got something that we can hold onto.  */
d2135 1
a2135 1
      /* Make offset relative to procedure entry.  */
d2216 2
a2217 2
      bfd_boolean past_line;
      bfd_boolean past_fn;
d2243 2
a2244 2
      past_line = FALSE;
      past_fn = FALSE;
d2294 1
a2294 1
		    past_fn = TRUE;
d2307 1
a2307 1
		past_line = TRUE;
d2339 1
a2339 1
	    return FALSE;
d2367 1
a2367 1
  return TRUE;
d2372 1
a2372 1
bfd_boolean
d2398 1
a2398 1
	  return FALSE;
d2406 1
a2406 1
  return TRUE;
d2419 1
a2419 2
static bfd_boolean ecoff_collect_shuffle
  PARAMS ((struct shuffle *, bfd_byte *));
d2421 1
a2421 1
static bfd_boolean
d2438 1
a2438 1
	    return FALSE;
d2444 1
a2444 1
  return TRUE;
d2449 1
a2449 1
bfd_boolean
d2461 1
a2461 1
bfd_boolean
d2473 1
a2473 1
bfd_boolean
d2500 1
a2500 1
  return TRUE;
@


1.8.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d35 2
a36 2
static bfd_boolean ecoff_add_bytes
  PARAMS ((char **buf, char **bufend, size_t need));
d40 13
a52 14
static void ecoff_align_debug
  PARAMS ((bfd *abfd, struct ecoff_debug_info *debug,
	   const struct ecoff_debug_swap *swap));
static bfd_boolean ecoff_write_symhdr
  PARAMS ((bfd *, struct ecoff_debug_info *, const struct ecoff_debug_swap *,
	   file_ptr where));
static int cmp_fdrtab_entry
  PARAMS ((const PTR, const PTR));
static bfd_boolean mk_fdrtab
  PARAMS ((bfd *, struct ecoff_debug_info * const,
	   const struct ecoff_debug_swap * const, struct ecoff_find_line *));
static long fdrtab_lookup
  PARAMS ((struct ecoff_find_line *, bfd_vma));
static bfd_boolean lookup_line
d256 1
a256 1
static bfd_boolean
d277 1
a277 1
    return FALSE;
d280 1
a280 1
  return TRUE;
d350 1
a350 1
  bfd_boolean filep;
d403 4
a406 3
static bfd_boolean add_file_shuffle
  PARAMS ((struct accumulate *, struct shuffle **, struct shuffle **,
	   bfd *, file_ptr, unsigned long));
d408 1
a408 1
static bfd_boolean
d428 1
a428 1
      return TRUE;
d436 1
a436 1
      return FALSE;
d440 1
a440 1
  n->filep = TRUE;
d450 1
a450 1
  return TRUE;
d455 4
a458 3
static bfd_boolean add_memory_shuffle
  PARAMS ((struct accumulate *, struct shuffle **head, struct shuffle **tail,
	   bfd_byte *data, unsigned long size));
d460 1
a460 1
static bfd_boolean
d475 1
a475 1
      return FALSE;
d479 1
a479 1
  n->filep = FALSE;
d486 1
a486 1
  return TRUE;
d579 1
a579 1
bfd_boolean
d675 1
a675 1
      return FALSE;
d678 1
a678 1
    return FALSE;
d719 1
a719 1
	    return FALSE;
d722 1
a722 1
	  fh = string_hash_lookup (&ainfo->fdr_hash, lookup, TRUE, TRUE);
d725 1
a725 1
	    return FALSE;
d776 1
a776 1
      return FALSE;
d779 1
a779 1
    return FALSE;
d789 1
a789 1
      bfd_boolean fgotfilename;
d825 1
a825 1
      fgotfilename = FALSE;
d831 1
a831 1
	  return FALSE;
d835 1
a835 1
	return FALSE;
d887 1
a887 1
	      bfd_boolean ffilename;
d891 1
a891 1
		ffilename = TRUE;
d893 1
a893 1
		ffilename = FALSE;
d903 1
a903 1
		  sh = string_hash_lookup (&ainfo->str_hash, name, TRUE, TRUE);
d905 1
a905 1
		    return FALSE;
d923 1
a923 1
		  fgotfilename = TRUE;
d945 1
a945 1
	    return FALSE;
d958 1
a958 1
	    return FALSE;
d977 1
a977 1
	    return FALSE;
d997 1
a997 1
		return FALSE;
d1007 1
a1007 1
		return FALSE;
d1030 1
a1030 1
	      return FALSE;
d1034 1
a1034 1
	    return FALSE;
d1071 1
a1071 1
	      return FALSE;
d1075 1
a1075 1
	    return FALSE;
d1107 1
a1107 1
  return TRUE;
d1113 4
a1116 3
static long ecoff_add_string
  PARAMS ((struct accumulate *, struct bfd_link_info *,
	   struct ecoff_debug_info *, FDR *fdr, const char *string));
d1145 1
a1145 1
      sh = string_hash_lookup (&ainfo->str_hash, string, TRUE, TRUE);
d1167 1
a1167 1
bfd_boolean
d1206 1
a1206 1
    return FALSE;
d1212 1
a1212 1
    return FALSE;
d1215 1
a1215 1
    return FALSE;
d1218 1
a1218 1
    return FALSE;
d1236 1
a1236 1
	return FALSE;
d1253 1
a1253 1
	  return FALSE;
d1274 1
a1274 1
      return FALSE;
d1283 1
a1283 1
  return TRUE;
d1291 1
a1291 1
bfd_boolean
d1297 2
a1298 2
     bfd_boolean relocateable;
     bfd_boolean (*get_extr) PARAMS ((asymbol *, EXTR *));
d1307 1
a1307 1
    return TRUE;
d1352 1
a1352 1
	return FALSE;
d1355 1
a1355 1
  return TRUE;
d1360 1
a1360 1
bfd_boolean
d1382 1
a1382 1
	return FALSE;
d1391 1
a1391 1
	return FALSE;
d1405 1
a1405 1
  return TRUE;
d1506 1
a1506 1
static bfd_boolean
d1520 1
a1520 1
    return FALSE;
d1560 1
a1560 1
  return TRUE;
d1564 1
a1564 1
  return FALSE;
d1573 1
a1573 1
bfd_boolean
d1583 1
a1583 1
    return FALSE;
d1590 1
a1590 1
    return FALSE;
d1606 1
a1606 1
  return TRUE;
d1611 3
a1613 3
static bfd_boolean ecoff_write_shuffle
  PARAMS ((bfd *, const struct ecoff_debug_swap *, struct shuffle *,
	   PTR space));
d1615 1
a1615 1
static bfd_boolean
d1632 1
a1632 1
	    return FALSE;
d1640 1
a1640 1
	    return FALSE;
d1653 1
a1653 1
	return FALSE;
d1658 1
a1658 1
	  return FALSE;
d1663 1
a1663 1
  return TRUE;
d1669 1
a1669 1
bfd_boolean
d1787 1
a1787 1
  return TRUE;
d1792 1
a1792 1
  return FALSE;
d1823 1
a1823 1
static bfd_boolean
d1834 1
a1834 1
  bfd_boolean stabs;
d1841 1
a1841 1
  /* First, let's see how long the table needs to be.  */
d1844 1
a1844 1
      if (fdr_ptr->cpd == 0)	/* Skip FDRs that have no PDRs.  */
d1849 2
a1850 1
  /* Now, create and fill in the table.  */
d1854 1
a1854 1
    return FALSE;
d1866 1
a1866 1
      stabs = FALSE;
d1873 1
a1873 1
		     + (fdr_ptr->isymBase + 1) * debug_swap->external_sym_size);
d1877 1
a1877 1
	    stabs = TRUE;
d1882 9
a1890 18
	  /* eraxxon: There are at least two problems with this computation:
	     1) PDRs do *not* contain offsets but full vma's; and typically the
	     address of the first PDR is the address of the FDR, which will
	     make (most) of the results of the original computation 0!
	     2) Once in a wacky while, the Compaq compiler generated PDR
	     addresses do not equal the FDR vma, but they (the PDR address)
	     are still vma's and not offsets.  Cf. comments in
	     'lookup_line'.  */
#if 0
	    bfd_size_type external_pdr_size;
	    char *pdr_ptr;
	    PDR pdr;
	    
	    external_pdr_size = debug_swap->external_pdr_size;
	    
	    pdr_ptr = ((char *) debug_info->external_pdr
	              + fdr_ptr->ipdFirst * external_pdr_size);
	    (*debug_swap->swap_pdr_in) (abfd, (PTR) pdr_ptr, &pdr);
d1893 1
a1893 6
	    tab->base_addr = fdr_ptr->adr - pdr.adr;
#else
	  /* The address of the first PDR is the offset of that
	     procedure relative to the beginning of file FDR.  */
	  tab->base_addr = fdr_ptr->adr; 
#endif
d1898 1
a1898 1
	     (davidm@@cs.arizona.edu).  */
d1912 1
a1912 1
  return TRUE;
a1941 6

  /* eraxxon: at this point 'offset' is either lower than the lowest entry or
     higher than the highest entry. In the former case high = low = mid = 0;
     we want to return -1.  In the latter case, low = high and mid = low - 1;
     we want to return the index of the highest entry.  Only in former case
     will the following 'catch-all' test be true.  */
d1944 1
a1944 1
  /* Last entry is catch-all for all higher addresses.  */
a1949 2
  /* eraxxon: There may be multiple FDRs in the table with the
     same base_addr; make sure that we are at the first one.  */
d1959 1
a1959 1
static bfd_boolean
d1968 1
a1968 1
  bfd_boolean stabs;
a1971 1
  /* eraxxon: note that 'offset' is the full vma, not a section offset.  */
d1978 1
a1978 1
    return FALSE;
d1982 1
a1982 1
  /* Find first FDR for address OFFSET.  */
d1985 1
a1985 71
    return FALSE;		/* no FDR, no fun...  */
  
  /* eraxxon: 'fdrtab_lookup' doesn't give what we want, at least for Compaq's
     C++ compiler 6.2.  Consider three FDRs with starting addresses of x, y,
     and z, respectively, such that x < y < z.  Assume further that
     y < 'offset' < z.  It is possble at times that the PDR for 'offset' is
     associated with FDR x and *not* with FDR y.  Erg!!

     From a binary dump of my C++ test case 'moo' using Compaq's coffobjanl
     (output format has been edited for our purposes):

     FDR [2]: (main.C): First instruction: 0x12000207c <x>
       PDR [5] for File [2]: LoopTest__Xv                 <0x1200020a0> (a)
       PDR [7] for File [2]: foo__Xv                      <0x120002168>
     FDR [1]: (-1):     First instruction: 0x1200020e8 <y>
       PDR [3] for File [1]:                              <0x120001ad0> (b)
     FDR [6]: (-1):     First instruction: 0x1200026f0 <z>

     (a) In the case of PDR5, the vma is such that the first few instructions
     of the procedure can be found.  But since the size of this procedure is
     160b, the vma will soon cross into the 'address space' of FDR1 and no
     debugging info will be found.  How repugnant!

     (b) It is also possible for a PDR to have a *lower* vma than its associated
     FDR; see FDR1 and PDR3.  Gross!

     Since the FDRs that are causing so much havok (in this case) 1) do not
     describe actual files (fdr.rss == -1), and 2) contain only compiler
     genarated routines, I thought a simple fix would be to exclude them from
     the FDR table in 'mk_fdrtab'.  But, besides not knowing for certain
     whether this would be correct, it creates an additional problem.  If we
     happen to ask for source file info on a compiler generated (procedure)
     symbol -- which is still in the symbol table -- the result can be
     information from a real procedure!  This is because compiler generated
     procedures with vma's higher than the last FDR in the fdr table will be
     associated with a PDR from this FDR, specifically the PDR with the
     highest vma.  This wasn't a problem before, because each procedure had a
     PDR.  (Yes, this problem could be eliminated if we kept the size of the
     last PDR around, but things are already getting ugly).

     Probably, a better solution would be to have a sorted PDR table.  Each
     PDR would have a pointer to its FDR so file information could still be
     obtained.  A FDR table could still be constructed if necessary -- since
     it only contains pointers, not much extra memory would be used -- but
     the PDR table would be searched to locate debugging info.

     There is still at least one remaining issue.  Sometimes a FDR can have a
     bogus name, but contain PDRs that should belong to another FDR with a
     real name.  E.g:

     FDR [3]: 0000000120001b50 (/home/.../Array.H~alt~deccxx_5E5A62AD)
       PDR [a] for File [3]: 0000000120001b50
       PDR [b] for File [3]: 0000000120001cf0
       PDR [c] for File [3]: 0000000120001dc8
       PDR [d] for File [3]: 0000000120001e40
       PDR [e] for File [3]: 0000000120001eb8
       PDR [f] for File [3]: 0000000120001f4c
     FDR [4]: 0000000120001b50 (/home/.../Array.H)

     Here, FDR4 has the correct name, but should (seemingly) contain PDRa-f.
     The symbol table for PDR4 does contain symbols for PDRa-f, but so does
     the symbol table for FDR3.  However the former is different; perhaps this
     can be detected easily. (I'm not sure at this point.)  This problem only
     seems to be associated with files with templates.  I am assuming the idea
     is that there is a 'fake' FDR (with PDRs) for each differently typed set
     of templates that must be generated.  Currently, FDR4 is completely
     excluded from the FDR table in 'mk_fdrtab' because it contains no PDRs.

     Since I don't have time to prepare a real fix for this right now, be
     prepared for 'A Horrible Hack' to force the inspection of all non-stabs
     FDRs.  It's coming...  */
d1991 1
a1991 1
  stabs = FALSE;
d2002 1
a2002 1
	stabs = TRUE;
d2011 1
a2011 1
      bfd_signed_vma best_dist = -1;
d2073 1
a2073 3
#if 0 /* eraxxon: PDR addresses (pdr.adr) are not relative to FDRs!
	 Leave 'offset' alone.  */
      /* Make offset relative to object file's start-address.  */
a2074 10
#endif
      /* eraxxon: The Horrible Hack: Because of the problems above, set 'i'
	 to 0 so we look through all FDRs.

	 Because FDR's without any symbols are assumed to be non-stabs,
	 searching through all FDRs may cause the following code to try to
	 read stabs FDRs as ECOFF ones.  However, I don't think this will
	 harm anything.  */
      i = 0;
      
d2080 1
a2080 4
	  /* eraxxon: 'dist' and 'min_dist' can be negative now
             because we iterate over every FDR rather than just ones
             with a base address less than or equal to 'offset'.  */
	  bfd_signed_vma dist = -1, min_dist = -1;
d2103 1
a2103 4

		  /* eraxxon: 'dist' can be negative now.  Note that
                     'min_dist' can be negative if 'pdr_hold' below is NULL.  */
		  if (!pdr_hold || (dist >= 0 && dist < min_dist))
d2111 1
a2111 1
	  if (!best_pdr || (min_dist >= 0 && min_dist < best_dist))
d2113 1
a2113 1
	      best_dist = (bfd_vma) min_dist;  
d2117 1
a2117 1
	  /* Continue looping until base_addr of next entry is different.  */
d2119 2
a2120 3
      /* eraxxon: We want to iterate over all FDRs.
	 See previous comment about 'fdrtab_lookup'.  */
      while (++i < line_info->fdrtab_len);
d2123 1
a2123 1
	return FALSE;			/* Shouldn't happen...  */
d2125 1
a2125 1
      /* Phew, finally we got something that we can hold onto.  */
d2135 1
a2135 1
      /* Make offset relative to procedure entry.  */
d2216 2
a2217 2
      bfd_boolean past_line;
      bfd_boolean past_fn;
d2243 2
a2244 2
      past_line = FALSE;
      past_fn = FALSE;
d2294 1
a2294 1
		    past_fn = TRUE;
d2307 1
a2307 1
		past_line = TRUE;
d2339 1
a2339 1
	    return FALSE;
d2367 1
a2367 1
  return TRUE;
d2372 1
a2372 1
bfd_boolean
d2398 1
a2398 1
	  return FALSE;
d2406 1
a2406 1
  return TRUE;
d2419 1
a2419 2
static bfd_boolean ecoff_collect_shuffle
  PARAMS ((struct shuffle *, bfd_byte *));
d2421 1
a2421 1
static bfd_boolean
d2438 1
a2438 1
	    return FALSE;
d2444 1
a2444 1
  return TRUE;
d2449 1
a2449 1
bfd_boolean
d2461 1
a2461 1
bfd_boolean
d2473 1
a2473 1
bfd_boolean
d2500 1
a2500 1
  return TRUE;
@


1.8.12.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002, 2003
d529 1
a529 1
  if (! info->relocatable)
d562 1
a562 1
  if (! info->relocatable)
d882 1
a882 1
	     this when performing a relocatable link because it would
d884 1
a884 1
	  if (! info->relocatable)
d961 1
a961 1
      if (! info->relocatable)
d1130 1
a1130 1
  if (info->relocatable)
d1290 1
a1290 1
bfd_ecoff_debug_externals (abfd, debug, swap, relocatable, get_extr,
d1295 1
a1295 1
     bfd_boolean relocatable;
d1320 1
a1320 1
      if (! relocatable)
d1697 1
a1697 1
  if (info->relocatable)
@


1.8.12.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d2010 1
a2010 1
     y < 'offset' < z.  It is possible at times that the PDR for 'offset' is
d2033 1
a2033 1
     generated routines, I thought a simple fix would be to exclude them from
@


1.7
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d1317 1
a1317 1
      if ((*get_extr) (sym_ptr, &esym) == false)
d1322 1
a1322 1
      if (relocateable == false)
d1379 3
a1381 4
      if (ecoff_add_bytes ((char **) &debug->ssext,
			   (char **) &debug->ssext_end,
			   symhdr->issExtMax + namelen + 1)
	  == false)
d1388 3
a1390 4
      if (ecoff_add_bytes ((char **) &debug->external_ext,
			   (char **) &debug->external_ext_end,
			   (symhdr->iextMax + 1) * (size_t) external_ext_size)
	  == false)
@


1.6
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001
d1653 1
a1653 1
      s = (bfd_byte *) bfd_malloc ((bfd_size_type) i);
a1656 1
      memset ((PTR) s, 0, i);
d1738 1
a1738 1
	  s = (bfd_byte *) bfd_malloc ((bfd_size_type) i);
d1741 1
a1741 1
	  memset ((PTR) s, 0, i);
d1763 1
a1763 1
      s = (bfd_byte *) bfd_malloc ((bfd_size_type) i);
d1766 1
a1766 1
      memset ((PTR) s, 0, i);
@


1.6.10.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002
d1653 1
a1653 1
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1657 1
d1739 1
a1739 1
	  s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1742 1
a1742 1

d1764 1
a1764 1
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1767 1
a1767 1

@


1.6.10.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1317 1
a1317 1
      if (! (*get_extr) (sym_ptr, &esym))
d1322 1
a1322 1
      if (! relocateable)
d1379 4
a1382 3
      if (! ecoff_add_bytes ((char **) &debug->ssext,
			     (char **) &debug->ssext_end,
			     symhdr->issExtMax + namelen + 1))
d1389 4
a1392 3
      if (! ecoff_add_bytes ((char **) &debug->external_ext,
			     (char **) &debug->external_ext_end,
			     (symhdr->iextMax + 1) * (size_t) external_ext_size))
@


1.6.8.1
log
@merge from trunk
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000, 2001, 2002
d1653 1
a1653 1
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1657 1
d1739 1
a1739 1
	  s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1742 1
a1742 1

d1764 1
a1764 1
      s = (bfd_byte *) bfd_zmalloc ((bfd_size_type) i);
d1767 1
a1767 1

@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1204 1
a1204 1
			      bfd_get_filename (input_bfd));
@


1.4
log
@Update copyright notices
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 2000
d275 1
a275 1
  newbuf = (char *) bfd_realloc (*buf, have + want);
d500 1
d502 1
a502 1
  ainfo = (struct accumulate *) bfd_malloc (sizeof (struct accumulate));
d625 1
d666 3
a668 3
  input_debug->ifdmap = (RFDT *) bfd_alloc (input_bfd,
					    (input_symhdr->ifdMax
					     * sizeof (RFDT)));
d717 1
a717 1
	  lookup = (char *) bfd_malloc (strlen (name) + 20);
d942 1
d944 1
a944 3
				 input_bfd,
				 input_symhdr->cbLineOffset + fdr.cbLineOffset,
				 fdr.cbLine))
d953 2
d956 1
a956 3
				 input_bfd,
				 (input_symhdr->cbAuxOffset
				  + fdr.iauxBase * sizeof (union aux_ext)),
d974 1
d976 1
a976 3
				 input_bfd,
				 input_symhdr->cbSsOffset + fdr.issBase,
				 fdr.cbSs))
d992 3
d996 1
a996 4
				     input_bfd,
				     (input_symhdr->cbPdOffset
				      + fdr.ipdFirst * external_pdr_size),
				     fdr.cpd * external_pdr_size))
d1002 3
d1006 1
a1006 4
				     input_bfd,
				     (input_symhdr->cbOptOffset
				      + fdr.ioptBase * external_opt_size),
				     fdr.copt * external_opt_size))
d1213 1
a1213 1
  symbols = (asymbol **) bfd_alloc (output_bfd, symsize);
d1257 2
a1258 1
			  external_sym, output_swap->external_sym_size);
d1278 2
a1279 1
		      external_fdr, output_swap->external_fdr_size);
d1391 1
a1391 1
			   (symhdr->iextMax + 1) * external_ext_size)
d1551 1
a1551 1
  buff = (PTR) bfd_malloc ((size_t) swap->external_hdr_size);
d1556 1
a1556 1
  if (bfd_write (buff, 1, swap->external_hdr_size, abfd)
d1590 1
a1590 1
  if (bfd_write ((PTR) debug->ptr, size, symhdr->count, abfd) \
d1599 2
a1600 1
  WRITE (external_aux, iauxMax, sizeof (union aux_ext), cbAuxOffset);
d1632 2
a1633 1
	  if (bfd_write (l->u.memory, 1, l->size, abfd) != l->size)
d1639 3
a1641 2
	      || bfd_read (space, 1, l->size, l->u.file.input_bfd) != l->size
	      || bfd_write (space, 1, l->size, abfd) != l->size)
d1653 1
a1653 1
      s = (bfd_byte *) bfd_malloc (i);
d1658 1
a1658 1
      if (bfd_write ((PTR) s, 1, i, abfd) != i)
d1683 1
d1688 2
a1689 1
  space = (PTR) bfd_malloc (ainfo->largest_file_shuffle);
d1716 1
a1716 1
      if (bfd_write ((PTR) &null, 1, 1, abfd) != 1)
d1727 2
a1728 1
	  if (bfd_write ((PTR) sh->root.string, 1, len + 1, abfd) != len + 1)
d1739 1
a1739 1
	  s = (bfd_byte *) bfd_malloc (i);
d1743 1
a1743 1
	  if (bfd_write ((PTR) s, 1, i, abfd) != i)
d1754 2
a1755 2
  if (bfd_write (debug->ssext, 1, debug->symbolic_header.issExtMax, abfd)
      != (bfd_size_type) debug->symbolic_header.issExtMax)
d1764 1
a1764 1
      s = (bfd_byte *) bfd_malloc (i);
d1768 1
a1768 1
      if (bfd_write ((PTR) s, 1, i, abfd) != i)
d1784 2
a1785 3
  if (bfd_write (debug->external_ext, swap->external_ext_size,
		 debug->symbolic_header.iextMax, abfd)
      != debug->symbolic_header.iextMax * swap->external_ext_size)
d1839 1
d1854 2
a1855 3
  line_info->fdrtab = ((struct ecoff_fdrtab_entry*)
		       bfd_zalloc (abfd,
				   len * sizeof (struct ecoff_fdrtab_entry)));
d1912 1
a1912 1
  qsort ((PTR) line_info->fdrtab, len,
d2014 1
a2014 1
      bfd_vma best_dist = ~0;
d2340 1
a2340 1
	  buffer = (char *) bfd_malloc (len);
d2439 2
a2440 1
	      || bfd_read (buff, 1, l->size, l->u.file.input_bfd) != l->size)
@


1.3
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* ecoff.c: Fix formatting.
	* ecofflink.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 94, 95, 96, 97, 99, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1993, 1994, 1995, 1996, 1997, 2000
   Free Software Foundation, Inc.
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 97, 1999 Free Software Foundation, Inc.
d72 2
a73 2
  
  /* now the fun stuff... */
d112 1
a112 1
    abort();
d129 2
a130 2
  
  /* now the fun stuff... */
d169 1
a169 1
    abort();
d185 2
a186 2
  
  /* now the fun stuff... */
d208 1
a208 1
    abort();
d224 2
a225 2
  
  /* now the fun stuff... */
d246 1
a246 1
    abort();
d468 1
a468 1
     
a490 1
/*ARGSUSED*/
a548 1
/*ARGSUSED*/
d558 1
a558 1
  
a576 1
/*ARGSUSED*/
a1408 1
/*ARGSUSED*/
d1966 1
a1966 1
  
d1968 1
a1968 1
     
d1980 1
a1980 1
    return false;		/* no FDR, no fun... */
d2045 1
a2045 1
        
d2047 1
a2047 1
         
d2078 1
a2078 1
	  
d2080 1
a2080 1
	  
d2105 1
a2105 1
	  
d2118 1
a2118 1
	return false;			/* shouldn't happen... */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993, 94, 95, 96, 1997 Free Software Foundation, Inc.
d494 1
a494 1
     bfd *output_bfd;
d496 1
a496 1
     const struct ecoff_debug_swap *output_swap;
d554 3
a556 3
     bfd *output_bfd;
     struct ecoff_debug_info *output_debug;
     const struct ecoff_debug_swap *output_swap;
d1415 1
a1415 1
     bfd *abfd;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

