head	1.45;
access;
symbols
	sid-snapshot-20180601:1.45
	sid-snapshot-20180501:1.45
	sid-snapshot-20180401:1.45
	sid-snapshot-20180301:1.45
	sid-snapshot-20180201:1.45
	sid-snapshot-20180101:1.45
	sid-snapshot-20171201:1.45
	sid-snapshot-20171101:1.45
	sid-snapshot-20171001:1.45
	sid-snapshot-20170901:1.45
	sid-snapshot-20170801:1.45
	sid-snapshot-20170701:1.45
	sid-snapshot-20170601:1.45
	sid-snapshot-20170501:1.45
	sid-snapshot-20170401:1.45
	sid-snapshot-20170301:1.45
	sid-snapshot-20170201:1.45
	sid-snapshot-20170101:1.45
	sid-snapshot-20161201:1.45
	sid-snapshot-20161101:1.45
	sid-snapshot-20160901:1.45
	sid-snapshot-20160801:1.45
	sid-snapshot-20160701:1.45
	sid-snapshot-20160601:1.45
	sid-snapshot-20160501:1.45
	sid-snapshot-20160401:1.45
	sid-snapshot-20160301:1.45
	sid-snapshot-20160201:1.45
	sid-snapshot-20160101:1.45
	sid-snapshot-20151201:1.45
	sid-snapshot-20151101:1.45
	sid-snapshot-20151001:1.45
	sid-snapshot-20150901:1.45
	sid-snapshot-20150801:1.45
	sid-snapshot-20150701:1.45
	sid-snapshot-20150601:1.45
	sid-snapshot-20150501:1.45
	sid-snapshot-20150401:1.45
	sid-snapshot-20150301:1.45
	sid-snapshot-20150201:1.45
	sid-snapshot-20150101:1.45
	sid-snapshot-20141201:1.45
	sid-snapshot-20141101:1.45
	sid-snapshot-20141001:1.45
	sid-snapshot-20140901:1.45
	sid-snapshot-20140801:1.45
	sid-snapshot-20140701:1.45
	sid-snapshot-20140601:1.45
	sid-snapshot-20140501:1.45
	sid-snapshot-20140401:1.45
	sid-snapshot-20140301:1.45
	sid-snapshot-20140201:1.45
	sid-snapshot-20140101:1.45
	sid-snapshot-20131201:1.45
	sid-snapshot-20131101:1.45
	sid-snapshot-20131001:1.45
	binutils-2_24-branch:1.45.0.2
	binutils-2_24-branchpoint:1.45
	binutils-2_21_1:1.38
	sid-snapshot-20130901:1.45
	gdb_7_6_1-2013-08-30-release:1.44
	sid-snapshot-20130801:1.45
	sid-snapshot-20130701:1.45
	sid-snapshot-20130601:1.45
	sid-snapshot-20130501:1.44
	gdb_7_6-2013-04-26-release:1.44
	sid-snapshot-20130401:1.44
	binutils-2_23_2:1.41.4.1
	gdb_7_6-branch:1.44.0.2
	gdb_7_6-2013-03-12-branchpoint:1.44
	sid-snapshot-20130301:1.44
	sid-snapshot-20130201:1.44
	sid-snapshot-20130101:1.43
	sid-snapshot-20121201:1.43
	gdb_7_5_1-2012-11-29-release:1.41
	binutils-2_23_1:1.41
	sid-snapshot-20121101:1.42
	binutils-2_23:1.41
	sid-snapshot-20121001:1.41
	sid-snapshot-20120901:1.41
	gdb_7_5-2012-08-17-release:1.41
	sid-snapshot-20120801:1.41
	binutils-2_23-branch:1.41.0.4
	binutils-2_23-branchpoint:1.41
	gdb_7_5-branch:1.41.0.2
	gdb_7_5-2012-07-18-branchpoint:1.41
	sid-snapshot-20120701:1.40
	sid-snapshot-20120601:1.40
	sid-snapshot-20120501:1.40
	binutils-2_22_branch:1.39.0.6
	gdb_7_4_1-2012-04-26-release:1.39
	sid-snapshot-20120401:1.40
	sid-snapshot-20120301:1.40
	sid-snapshot-20120201:1.40
	gdb_7_4-2012-01-24-release:1.39
	sid-snapshot-20120101:1.39
	gdb_7_4-branch:1.39.0.4
	gdb_7_4-2011-12-13-branchpoint:1.39
	sid-snapshot-20111201:1.39
	binutils-2_22:1.39
	sid-snapshot-20111101:1.39
	sid-snapshot-20111001:1.39
	binutils-2_22-branch:1.39.0.2
	binutils-2_22-branchpoint:1.39
	gdb_7_3_1-2011-09-04-release:1.38
	sid-snapshot-20110901:1.39
	sid-snapshot-20110801:1.39
	gdb_7_3-2011-07-26-release:1.38
	sid-snapshot-20110701:1.39
	sid-snapshot-20110601:1.38
	sid-snapshot-20110501:1.38
	gdb_7_3-branch:1.38.0.8
	gdb_7_3-2011-04-01-branchpoint:1.38
	sid-snapshot-20110401:1.38
	sid-snapshot-20110301:1.38
	sid-snapshot-20110201:1.38
	sid-snapshot-20110101:1.38
	binutils-2_21:1.38
	sid-snapshot-20101201:1.38
	binutils-2_21-branch:1.38.0.6
	binutils-2_21-branchpoint:1.38
	sid-snapshot-20101101:1.38
	sid-snapshot-20101001:1.38
	binutils-2_20_1:1.36.2.1
	gdb_7_2-2010-09-02-release:1.38
	sid-snapshot-20100901:1.38
	sid-snapshot-20100801:1.38
	gdb_7_2-branch:1.38.0.4
	gdb_7_2-2010-07-07-branchpoint:1.38
	sid-snapshot-20100701:1.38
	sid-snapshot-20100601:1.38
	sid-snapshot-20100501:1.38
	sid-snapshot-20100401:1.38
	gdb_7_1-2010-03-18-release:1.38
	sid-snapshot-20100301:1.38
	gdb_7_1-branch:1.38.0.2
	gdb_7_1-2010-02-18-branchpoint:1.38
	sid-snapshot-20100201:1.38
	sid-snapshot-20100101:1.38
	gdb_7_0_1-2009-12-22-release:1.37
	sid-snapshot-20091201:1.37
	sid-snapshot-20091101:1.37
	binutils-2_20:1.36.2.1
	gdb_7_0-2009-10-06-release:1.37
	sid-snapshot-20091001:1.37
	gdb_7_0-branch:1.37.0.2
	gdb_7_0-2009-09-16-branchpoint:1.37
	arc-sim-20090309:1.31
	binutils-arc-20081103-branch:1.34.0.8
	binutils-arc-20081103-branchpoint:1.34
	binutils-2_20-branch:1.36.0.2
	binutils-2_20-branchpoint:1.36
	sid-snapshot-20090901:1.35
	sid-snapshot-20090801:1.35
	msnyder-checkpoint-072509-branch:1.35.0.4
	msnyder-checkpoint-072509-branchpoint:1.35
	sid-snapshot-20090701:1.35
	dje-cgen-play1-branch:1.35.0.2
	dje-cgen-play1-branchpoint:1.35
	sid-snapshot-20090601:1.34
	sid-snapshot-20090501:1.34
	sid-snapshot-20090401:1.34
	arc-20081103-branch:1.34.0.6
	arc-20081103-branchpoint:1.34
	arc-insight_6_8-branch:1.31.0.6
	arc-insight_6_8-branchpoint:1.31
	insight_6_8-branch:1.31.0.4
	insight_6_8-branchpoint:1.31
	sid-snapshot-20090301:1.34
	binutils-2_19_1:1.33
	sid-snapshot-20090201:1.34
	sid-snapshot-20090101:1.34
	reverse-20081226-branch:1.34.0.4
	reverse-20081226-branchpoint:1.34
	sid-snapshot-20081201:1.34
	multiprocess-20081120-branch:1.34.0.2
	multiprocess-20081120-branchpoint:1.34
	sid-snapshot-20081101:1.34
	binutils-2_19:1.33
	sid-snapshot-20081001:1.33
	reverse-20080930-branch:1.33.0.8
	reverse-20080930-branchpoint:1.33
	binutils-2_19-branch:1.33.0.6
	binutils-2_19-branchpoint:1.33
	sid-snapshot-20080901:1.33
	sid-snapshot-20080801:1.33
	reverse-20080717-branch:1.33.0.4
	reverse-20080717-branchpoint:1.33
	sid-snapshot-20080701:1.33
	msnyder-reverse-20080609-branch:1.33.0.2
	msnyder-reverse-20080609-branchpoint:1.33
	drow-reverse-20070409-branch:1.28.0.28
	drow-reverse-20070409-branchpoint:1.28
	sid-snapshot-20080601:1.33
	sid-snapshot-20080501:1.32
	sid-snapshot-20080403:1.32
	sid-snapshot-20080401:1.32
	gdb_6_8-2008-03-27-release:1.31
	sid-snapshot-20080301:1.31
	gdb_6_8-branch:1.31.0.2
	gdb_6_8-2008-02-26-branchpoint:1.31
	sid-snapshot-20080201:1.30
	sid-snapshot-20080101:1.30
	sid-snapshot-20071201:1.30
	sid-snapshot-20071101:1.30
	gdb_6_7_1-2007-10-29-release:1.30
	gdb_6_7-2007-10-10-release:1.30
	sid-snapshot-20071001:1.30
	gdb_6_7-branch:1.30.0.4
	gdb_6_7-2007-09-07-branchpoint:1.30
	binutils-2_18:1.30
	binutils-2_18-branch:1.30.0.2
	binutils-2_18-branchpoint:1.30
	insight_6_6-20070208-release:1.28
	binutils-csl-coldfire-4_1-32:1.28
	binutils-csl-sourcerygxx-4_1-32:1.28
	gdb_6_6-2006-12-18-release:1.28
	binutils-csl-innovasic-fido-3_4_4-33:1.28
	binutils-csl-sourcerygxx-3_4_4-32:1.17
	binutils-csl-coldfire-4_1-30:1.28
	binutils-csl-sourcerygxx-4_1-30:1.28
	binutils-csl-coldfire-4_1-28:1.28
	binutils-csl-sourcerygxx-4_1-29:1.28
	binutils-csl-sourcerygxx-4_1-28:1.28
	gdb_6_6-branch:1.28.0.26
	gdb_6_6-2006-11-15-branchpoint:1.28
	binutils-csl-arm-2006q3-27:1.28
	binutils-csl-sourcerygxx-4_1-27:1.28
	binutils-csl-arm-2006q3-26:1.28
	binutils-csl-sourcerygxx-4_1-26:1.28
	binutils-csl-sourcerygxx-4_1-25:1.28
	binutils-csl-sourcerygxx-4_1-24:1.28
	binutils-csl-sourcerygxx-4_1-23:1.28
	insight_6_5-20061003-release:1.28
	gdb-csl-symbian-6_4_50_20060226-12:1.28
	binutils-csl-sourcerygxx-4_1-21:1.28
	binutils-csl-arm-2006q3-21:1.28
	binutils-csl-sourcerygxx-4_1-22:1.28
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.28
	binutils-csl-sourcerygxx-4_1-20:1.28
	binutils-csl-arm-2006q3-19:1.28
	binutils-csl-sourcerygxx-4_1-19:1.28
	binutils-csl-sourcerygxx-4_1-18:1.28
	binutils-csl-renesas-4_1-9:1.28
	gdb-csl-sourcerygxx-3_4_4-25:1.28
	binutils-csl-sourcerygxx-3_4_4-25:1.17
	nickrob-async-20060828-mergepoint:1.28
	gdb-csl-symbian-6_4_50_20060226-11:1.28
	binutils-csl-renesas-4_1-8:1.28
	binutils-csl-renesas-4_1-7:1.28
	binutils-csl-renesas-4_1-6:1.28
	gdb-csl-sourcerygxx-4_1-17:1.28
	binutils-csl-sourcerygxx-4_1-17:1.28
	gdb-csl-20060226-branch-local-2:1.28
	gdb-csl-sourcerygxx-4_1-14:1.28
	binutils-csl-sourcerygxx-4_1-14:1.28
	binutils-csl-sourcerygxx-4_1-15:1.28
	gdb-csl-sourcerygxx-4_1-13:1.28
	binutils-csl-sourcerygxx-4_1-13:1.28
	binutils-2_17:1.28
	gdb-csl-sourcerygxx-4_1-12:1.28
	binutils-csl-sourcerygxx-4_1-12:1.28
	gdb-csl-sourcerygxx-3_4_4-21:1.28
	binutils-csl-sourcerygxx-3_4_4-21:1.28
	gdb_6_5-20060621-release:1.28
	binutils-csl-wrs-linux-3_4_4-24:1.17
	binutils-csl-wrs-linux-3_4_4-23:1.17
	gdb-csl-sourcerygxx-4_1-9:1.28
	binutils-csl-sourcerygxx-4_1-9:1.28
	gdb-csl-sourcerygxx-4_1-8:1.28
	binutils-csl-sourcerygxx-4_1-8:1.28
	gdb-csl-sourcerygxx-4_1-7:1.28
	binutils-csl-sourcerygxx-4_1-7:1.28
	gdb-csl-arm-2006q1-6:1.28
	binutils-csl-arm-2006q1-6:1.28
	gdb-csl-sourcerygxx-4_1-6:1.28
	binutils-csl-sourcerygxx-4_1-6:1.28
	binutils-csl-wrs-linux-3_4_4-22:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.28
	gdb-csl-symbian-6_4_50_20060226-9:1.28
	gdb-csl-symbian-6_4_50_20060226-8:1.28
	gdb-csl-coldfire-4_1-11:1.28
	binutils-csl-coldfire-4_1-11:1.28
	gdb-csl-sourcerygxx-3_4_4-19:1.28
	binutils-csl-sourcerygxx-3_4_4-19:1.28
	gdb-csl-coldfire-4_1-10:1.28
	gdb_6_5-branch:1.28.0.24
	gdb_6_5-2006-05-14-branchpoint:1.28
	binutils-csl-coldfire-4_1-10:1.28
	gdb-csl-sourcerygxx-4_1-5:1.28
	binutils-csl-sourcerygxx-4_1-5:1.28
	nickrob-async-20060513-branch:1.28.0.22
	nickrob-async-20060513-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-4:1.28
	binutils-csl-sourcerygxx-4_1-4:1.28
	msnyder-reverse-20060502-branch:1.28.0.20
	msnyder-reverse-20060502-branchpoint:1.28
	binutils-csl-wrs-linux-3_4_4-21:1.17
	gdb-csl-morpho-4_1-4:1.28
	binutils-csl-morpho-4_1-4:1.28
	gdb-csl-sourcerygxx-3_4_4-17:1.28
	binutils-csl-sourcerygxx-3_4_4-17:1.28
	binutils-csl-wrs-linux-3_4_4-20:1.17
	readline_5_1-import-branch:1.28.0.18
	readline_5_1-import-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.28
	binutils-2_17-branch:1.28.0.16
	binutils-2_17-branchpoint:1.28
	gdb-csl-symbian-20060226-branch:1.28.0.14
	gdb-csl-symbian-20060226-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.28
	msnyder-reverse-20060331-branch:1.28.0.12
	msnyder-reverse-20060331-branchpoint:1.28
	binutils-csl-2_17-branch:1.28.0.10
	binutils-csl-2_17-branchpoint:1.28
	gdb-csl-available-20060303-branch:1.28.0.8
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.28.0.6
	gdb-csl-20060226-branchpoint:1.28
	gdb_6_4-20051202-release:1.27.2.1
	msnyder-fork-checkpoint-branch:1.28.0.4
	msnyder-fork-checkpoint-branchpoint:1.28
	gdb-csl-gxxpro-6_3-branch:1.28.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.27.0.2
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb-csl-arm-20051020-branch:1.21.0.2
	gdb-csl-arm-20051020-branchpoint:1.21
	binutils-csl-gxxpro-3_4-branch:1.17.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.17
	binutils-2_16_1:1.17
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.17
	binutils-csl-arm-2005q1b:1.17
	binutils-2_16:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	binutils-csl-arm-2005q1a:1.17
	csl-arm-20050325-branch:1.17.0.6
	csl-arm-20050325-branchpoint:1.17
	binutils-csl-arm-2005q1-branch:1.17.0.4
	binutils-csl-arm-2005q1-branchpoint:1.17
	binutils-2_16-branch:1.17.0.2
	binutils-2_16-branchpoint:1.17
	csl-arm-2004-q3d:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.4
	gdb_6_3-20041019-branchpoint:1.16
	csl-arm-2004-q3:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.16.0.6
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.12
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.10
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.6
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.4
	cagney_bfdfile-20040213-branch:1.11.0.2
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.8
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	csl-arm-2003-q4:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.10.0.6
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.4
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.36
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.9
	binutils-2_14:1.9
	cagney_convert-20030606-branch:1.9.0.32
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.30
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.26
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	binutils-2_14-branch:1.9.0.22
	binutils-2_14-branchpoint:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.20
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.18
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.16
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.14
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.12
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.10
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.8
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.6
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.4
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.2
	cagney-unwind-20030108-branchpoint:1.9
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.14
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.12
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.10
	gdb_5_3-branch:1.8.0.8
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.6
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.4
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	kseitz_interps-20020528-branch:1.7.0.10
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.8
	cagney_regbuf-20020515-branchpoint:1.7
	binutils-2_12_1:1.7
	jimb-macro-020506-branch:1.7.0.6
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	binutils-2_12:1.7
	gdb_5_2-branch:1.7.0.4
	gdb_5_2-2002-03-03-branchpoint:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.1.1.1.2.2
	binutils-2_10:1.1.1.1.2.2
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.45
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2013.05.27.07.55.17;	author mark;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.14.13.14.08;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.07.00.55.04;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2012.10.22.04.51.52;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.13.14.22.42;	author nickc;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	2012.01.10.11.51.09;	author gingold;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.27.08.41.00;	author gingold;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.11.15.42.38;	author gingold;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.02.07.18.35;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2009.06.11.00.41.03;	author ppluzhnikov;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.30.09.05.32;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.01.15.45.43;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.14.18.39.41;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.11.13.52.02;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.03.16.06.10;	author drow;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.27.05.31.16;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2005.10.27.03.36.57;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.27.03.22.13;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.26.12.17.42;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.26.07.38.25;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.26.04.29.53;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.05.21.24.23;	author bwilson;	state Exp;
branches;
next	1.20;

1.20
date	2005.07.14.07.22.02;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.04.15.53.01;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.02.09.03.51;	author jbeulich;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.17.11.55.02;	author guitton;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.17.11.47.18;	author guitton;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.05.15.39.11;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.22.16.17.31;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.21.17.05.11;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.11.23.23.20;	author cagney;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches
	1.10.8.1;
next	1.9;

1.9
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.8.12.1
	1.8.14.1;
next	1.7;

1.7
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.14.07.03.48;	author amodra;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.11.28.21.42.16;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.13.11.55;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.19.19.11;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.4.1
date	2013.01.21.13.48.35;	author amodra;	state Exp;
branches;
next	;

1.36.2.1
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;

1.27.2.1
date	2005.11.03.19.53.30;	author drow;	state Exp;
branches;
next	;

1.11.6.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.10.8.1
date	2004.01.22.17.03.42;	author cagney;	state Exp;
branches;
next	;

1.8.12.1
date	2002.12.23.19.37.24;	author carlton;	state Exp;
branches;
next	1.8.12.2;

1.8.12.2
date	2003.08.05.17.12.43;	author carlton;	state Exp;
branches;
next	;

1.8.14.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.7.10.1
date	2002.07.22.21.46.38;	author kseitz;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.04.03.19.19.52;	author ian;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	2000.05.28.10.57.50;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.45
log
@bfd: Make bfd_cache_max_open depend on actual open file limit.

The current hard coded limit of open files in bfd/cache.c is 10. This
is pretty low these days. Binaries are often linked against much more
than 10 files (and sometimes against more than 100 shared libraries).
When debugging with GDB some files are opened and closed multiple
times because of this low limit. If possible make the BFD cache file
limit depend on the actual open file limit of the process so more BFD
files can be open at the same time.

    * cache.c (BFD_CACHE_MAX_OPEN): Remove define.
    (max_open_files): New static int initialized to zero.
    (bfd_cache_max_open): New static function to set and return
    max_open_files.
    (bfd_cache_init): Use bfd_cache_max_open.
    (bfd_open_file): Likewise.
    * configure.in (AC_CHECK_HEADERS): Add sys/resource.h.
    (AC_CHECK_FUNCS): Add getrlimit.
    * configure: Regenerated.
    * config.in: Likewise.
    * sysdep.h: Check and include sys/resource.h for getrlimit.
@
text
@/* BFD library -- caching of file descriptors.

   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002,
   2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.

   Hacked by Steve Chamberlain of Cygnus Support (steve@@cygnus.com).

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/*
SECTION
	File caching

	The file caching mechanism is embedded within BFD and allows
	the application to open as many BFDs as it wants without
	regard to the underlying operating system's file descriptor
	limit (often as low as 20 open files).  The module in
	<<cache.c>> maintains a least recently used list of
	<<bfd_cache_max_open>> files, and exports the name
	<<bfd_cache_lookup>>, which runs around and makes sure that
	the required BFD is open. If not, then it chooses a file to
	close, closes it and opens the one wanted, returning its file
	handle.

SUBSECTION
	Caching functions
*/

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "libiberty.h"
#include "bfd_stdint.h"

#ifdef HAVE_MMAP
#include <sys/mman.h>
#endif

/* In some cases we can optimize cache operation when reopening files.
   For instance, a flush is entirely unnecessary if the file is already
   closed, so a flush would use CACHE_NO_OPEN.  Similarly, a seek using
   SEEK_SET or SEEK_END need not first seek to the current position.
   For stat we ignore seek errors, just in case the file has changed
   while we weren't looking.  If it has, then it's possible that the
   file is shorter and we don't want a seek error to prevent us doing
   the stat.  */
enum cache_flag {
  CACHE_NORMAL = 0,
  CACHE_NO_OPEN = 1,
  CACHE_NO_SEEK = 2,
  CACHE_NO_SEEK_ERROR = 4
};

/* The maximum number of files which the cache will keep open at
   one time.  When needed call bfd_cache_max_open to initialize.  */

static int max_open_files = 0;

/* Set max_open_files, if not already set, to 12.5% of the allowed open
   file descriptors, but at least 10, and return the value.  */
static int
bfd_cache_max_open (void)
{
  if (max_open_files == 0)
    {
      int max;
#ifdef HAVE_GETRLIMIT
      struct rlimit rlim;
      if (getrlimit (RLIMIT_NOFILE, &rlim) == 0
	  && rlim.rlim_cur != RLIM_INFINITY)
	max = rlim.rlim_cur / 8;
      else
#endif /* HAVE_GETRLIMIT */
#ifdef _SC_OPEN_MAX
	max = sysconf (_SC_OPEN_MAX) / 8;
#else
	max = 10;
#endif /* _SC_OPEN_MAX */
      max_open_files = max < 10 ? 10 : max;
    }

  return max_open_files;
}

/* The number of BFD files we have open.  */

static int open_files;

/* Zero, or a pointer to the topmost BFD on the chain.  This is
   used by the <<bfd_cache_lookup>> macro in @@file{libbfd.h} to
   determine when it can avoid a function call.  */

static bfd *bfd_last_cache = NULL;

/* Insert a BFD into the cache.  */

static void
insert (bfd *abfd)
{
  if (bfd_last_cache == NULL)
    {
      abfd->lru_next = abfd;
      abfd->lru_prev = abfd;
    }
  else
    {
      abfd->lru_next = bfd_last_cache;
      abfd->lru_prev = bfd_last_cache->lru_prev;
      abfd->lru_prev->lru_next = abfd;
      abfd->lru_next->lru_prev = abfd;
    }
  bfd_last_cache = abfd;
}

/* Remove a BFD from the cache.  */

static void
snip (bfd *abfd)
{
  abfd->lru_prev->lru_next = abfd->lru_next;
  abfd->lru_next->lru_prev = abfd->lru_prev;
  if (abfd == bfd_last_cache)
    {
      bfd_last_cache = abfd->lru_next;
      if (abfd == bfd_last_cache)
	bfd_last_cache = NULL;
    }
}

/* Close a BFD and remove it from the cache.  */

static bfd_boolean
bfd_cache_delete (bfd *abfd)
{
  bfd_boolean ret;

  if (fclose ((FILE *) abfd->iostream) == 0)
    ret = TRUE;
  else
    {
      ret = FALSE;
      bfd_set_error (bfd_error_system_call);
    }

  snip (abfd);

  abfd->iostream = NULL;
  --open_files;

  return ret;
}

/* We need to open a new file, and the cache is full.  Find the least
   recently used cacheable BFD and close it.  */

static bfd_boolean
close_one (void)
{
  register bfd *to_kill;

  if (bfd_last_cache == NULL)
    to_kill = NULL;
  else
    {
      for (to_kill = bfd_last_cache->lru_prev;
	   ! to_kill->cacheable;
	   to_kill = to_kill->lru_prev)
	{
	  if (to_kill == bfd_last_cache)
	    {
	      to_kill = NULL;
	      break;
	    }
	}
    }

  if (to_kill == NULL)
    {
      /* There are no open cacheable BFD's.  */
      return TRUE;
    }

  to_kill->where = real_ftell ((FILE *) to_kill->iostream);

  return bfd_cache_delete (to_kill);
}

/* Check to see if the required BFD is the same as the last one
   looked up. If so, then it can use the stream in the BFD with
   impunity, since it can't have changed since the last lookup;
   otherwise, it has to perform the complicated lookup function.  */

#define bfd_cache_lookup(x, flag) \
  ((x) == bfd_last_cache			\
   ? (FILE *) (bfd_last_cache->iostream)	\
   : bfd_cache_lookup_worker (x, flag))

/* Called when the macro <<bfd_cache_lookup>> fails to find a
   quick answer.  Find a file descriptor for @@var{abfd}.  If
   necessary, it open it.  If there are already more than
   <<bfd_cache_max_open>> files open, it tries to close one first, to
   avoid running out of file descriptors.  It will return NULL
   if it is unable to (re)open the @@var{abfd}.  */

static FILE *
bfd_cache_lookup_worker (bfd *abfd, enum cache_flag flag)
{
  bfd *orig_bfd = abfd;
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

  while (abfd->my_archive)
    abfd = abfd->my_archive;

  if (abfd->iostream != NULL)
    {
      /* Move the file to the start of the cache.  */
      if (abfd != bfd_last_cache)
	{
	  snip (abfd);
	  insert (abfd);
	}
      return (FILE *) abfd->iostream;
    }

  if (flag & CACHE_NO_OPEN)
    return NULL;

  if (bfd_open_file (abfd) == NULL)
    ;
  else if (!(flag & CACHE_NO_SEEK)
	   && real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0
	   && !(flag & CACHE_NO_SEEK_ERROR))
    bfd_set_error (bfd_error_system_call);
  else
    return (FILE *) abfd->iostream;

  (*_bfd_error_handler) (_("reopening %B: %s\n"),
			 orig_bfd, bfd_errmsg (bfd_get_error ()));
  return NULL;
}

static file_ptr
cache_btell (struct bfd *abfd)
{
  FILE *f = bfd_cache_lookup (abfd, CACHE_NO_OPEN);
  if (f == NULL)
    return abfd->where;
  return real_ftell (f);
}

static int
cache_bseek (struct bfd *abfd, file_ptr offset, int whence)
{
  FILE *f = bfd_cache_lookup (abfd, whence != SEEK_CUR ? CACHE_NO_SEEK : CACHE_NORMAL);
  if (f == NULL)
    return -1;
  return real_fseek (f, offset, whence);
}

/* Note that archive entries don't have streams; they share their parent's.
   This allows someone to play with the iostream behind BFD's back.

   Also, note that the origin pointer points to the beginning of a file's
   contents (0 for non-archive elements).  For archive entries this is the
   first octet in the file, NOT the beginning of the archive header.  */

static file_ptr
cache_bread_1 (struct bfd *abfd, void *buf, file_ptr nbytes)
{
  FILE *f;
  file_ptr nread;
  /* FIXME - this looks like an optimization, but it's really to cover
     up for a feature of some OSs (not solaris - sigh) that
     ld/pe-dll.c takes advantage of (apparently) when it creates BFDs
     internally and tries to link against them.  BFD seems to be smart
     enough to realize there are no symbol records in the "file" that
     doesn't exist but attempts to read them anyway.  On Solaris,
     attempting to read zero bytes from a NULL file results in a core
     dump, but on other platforms it just returns zero bytes read.
     This makes it to something reasonable. - DJ */
  if (nbytes == 0)
    return 0;

  f = bfd_cache_lookup (abfd, CACHE_NORMAL);
  if (f == NULL)
    return 0;

#if defined (__VAX) && defined (VMS)
  /* Apparently fread on Vax VMS does not keep the record length
     information.  */
  nread = read (fileno (f), buf, nbytes);
  /* Set bfd_error if we did not read as much data as we expected.  If
     the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.  */
  if (nread == (file_ptr)-1)
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
#else
  nread = fread (buf, 1, nbytes, f);
  /* Set bfd_error if we did not read as much data as we expected.  If
     the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.  */
  if (nread < nbytes && ferror (f))
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
#endif
  if (nread < nbytes)
    /* This may or may not be an error, but in case the calling code
       bails out because of it, set the right error code.  */
    bfd_set_error (bfd_error_file_truncated);
  return nread;
}

static file_ptr
cache_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
{
  file_ptr nread = 0;

  /* Some filesystems are unable to handle reads that are too large
     (for instance, NetApp shares with oplocks turned off).  To avoid
     hitting this limitation, we read the buffer in chunks of 8MB max.  */
  while (nread < nbytes)
    {
      const file_ptr max_chunk_size = 0x800000;
      file_ptr chunk_size = nbytes - nread;
      file_ptr chunk_nread;

      if (chunk_size > max_chunk_size)
        chunk_size = max_chunk_size;

      chunk_nread = cache_bread_1 (abfd, (char *) buf + nread, chunk_size);

      /* Update the nread count.

         We just have to be careful of the case when cache_bread_1 returns
         a negative count:  If this is our first read, then set nread to
         that negative count in order to return that negative value to the
         caller.  Otherwise, don't add it to our total count, or we would
         end up returning a smaller number of bytes read than we actually
         did.  */
      if (nread == 0 || chunk_nread > 0)
        nread += chunk_nread;

      if (chunk_nread < chunk_size)
        break;
    }

  return nread;
}

static file_ptr
cache_bwrite (struct bfd *abfd, const void *where, file_ptr nbytes)
{
  file_ptr nwrite;
  FILE *f = bfd_cache_lookup (abfd, CACHE_NORMAL);

  if (f == NULL)
    return 0;
  nwrite = fwrite (where, 1, nbytes, f);
  if (nwrite < nbytes && ferror (f))
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
  return nwrite;
}

static int
cache_bclose (struct bfd *abfd)
{
  return bfd_cache_close (abfd) - 1;
}

static int
cache_bflush (struct bfd *abfd)
{
  int sts;
  FILE *f = bfd_cache_lookup (abfd, CACHE_NO_OPEN);

  if (f == NULL)
    return 0;
  sts = fflush (f);
  if (sts < 0)
    bfd_set_error (bfd_error_system_call);
  return sts;
}

static int
cache_bstat (struct bfd *abfd, struct stat *sb)
{
  int sts;
  FILE *f = bfd_cache_lookup (abfd, CACHE_NO_SEEK_ERROR);

  if (f == NULL)
    return -1;
  sts = fstat (fileno (f), sb);
  if (sts < 0)
    bfd_set_error (bfd_error_system_call);
  return sts;
}

static void *
cache_bmmap (struct bfd *abfd ATTRIBUTE_UNUSED,
	     void *addr ATTRIBUTE_UNUSED,
	     bfd_size_type len ATTRIBUTE_UNUSED,
	     int prot ATTRIBUTE_UNUSED,
	     int flags ATTRIBUTE_UNUSED,
	     file_ptr offset ATTRIBUTE_UNUSED,
             void **map_addr ATTRIBUTE_UNUSED,
             bfd_size_type *map_len ATTRIBUTE_UNUSED)
{
  void *ret = (void *) -1;

  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();
#ifdef HAVE_MMAP
  else
    {
      static uintptr_t pagesize_m1;
      FILE *f;
      file_ptr pg_offset;
      bfd_size_type pg_len;

      f = bfd_cache_lookup (abfd, CACHE_NO_SEEK_ERROR);
      if (f == NULL)
	return ret;

      if (pagesize_m1 == 0)
        pagesize_m1 = getpagesize () - 1;

      /* Handle archive members.  */
      if (abfd->my_archive != NULL)
        offset += abfd->origin;

      /* Align.  */
      pg_offset = offset & ~pagesize_m1;
      pg_len = (len + (offset - pg_offset) + pagesize_m1) & ~pagesize_m1;

      ret = mmap (addr, pg_len, prot, flags, fileno (f), pg_offset);
      if (ret == (void *) -1)
	bfd_set_error (bfd_error_system_call);
      else
        {
          *map_addr = ret;
          *map_len = pg_len;
          ret = (char *) ret + (offset & pagesize_m1);
        }
    }
#endif

  return ret;
}

static const struct bfd_iovec cache_iovec =
{
  &cache_bread, &cache_bwrite, &cache_btell, &cache_bseek,
  &cache_bclose, &cache_bflush, &cache_bstat, &cache_bmmap
};

/*
INTERNAL_FUNCTION
	bfd_cache_init

SYNOPSIS
	bfd_boolean bfd_cache_init (bfd *abfd);

DESCRIPTION
	Add a newly opened BFD to the cache.
*/

bfd_boolean
bfd_cache_init (bfd *abfd)
{
  BFD_ASSERT (abfd->iostream != NULL);
  if (open_files >= bfd_cache_max_open ())
    {
      if (! close_one ())
	return FALSE;
    }
  abfd->iovec = &cache_iovec;
  insert (abfd);
  ++open_files;
  return TRUE;
}

/*
INTERNAL_FUNCTION
	bfd_cache_close

SYNOPSIS
	bfd_boolean bfd_cache_close (bfd *abfd);

DESCRIPTION
	Remove the BFD @@var{abfd} from the cache. If the attached file is open,
	then close it too.

RETURNS
	<<FALSE>> is returned if closing the file fails, <<TRUE>> is
	returned if all is well.
*/

bfd_boolean
bfd_cache_close (bfd *abfd)
{
  if (abfd->iovec != &cache_iovec)
    return TRUE;

  if (abfd->iostream == NULL)
    /* Previously closed.  */
    return TRUE;

  return bfd_cache_delete (abfd);
}

/*
FUNCTION
	bfd_cache_close_all

SYNOPSIS
	bfd_boolean bfd_cache_close_all (void);

DESCRIPTION
	Remove all BFDs from the cache. If the attached file is open,
	then close it too.

RETURNS
	<<FALSE>> is returned if closing one of the file fails, <<TRUE>> is
	returned if all is well.
*/

bfd_boolean
bfd_cache_close_all ()
{
  bfd_boolean ret = TRUE;

  while (bfd_last_cache != NULL)
    ret &= bfd_cache_close (bfd_last_cache);

  return ret;
}

/*
INTERNAL_FUNCTION
	bfd_open_file

SYNOPSIS
	FILE* bfd_open_file (bfd *abfd);

DESCRIPTION
	Call the OS to open a file for @@var{abfd}.  Return the <<FILE *>>
	(possibly <<NULL>>) that results from this operation.  Set up the
	BFD so that future accesses know the file is open. If the <<FILE *>>
	returned is <<NULL>>, then it won't have been put in the
	cache, so it won't have to be removed from it.
*/

FILE *
bfd_open_file (bfd *abfd)
{
  abfd->cacheable = TRUE;	/* Allow it to be closed later.  */

  if (open_files >= bfd_cache_max_open ())
    {
      if (! close_one ())
	return NULL;
    }

  switch (abfd->direction)
    {
    case read_direction:
    case no_direction:
      abfd->iostream = real_fopen (abfd->filename, FOPEN_RB);
      break;
    case both_direction:
    case write_direction:
      if (abfd->opened_once)
	{
	  abfd->iostream = real_fopen (abfd->filename, FOPEN_RUB);
	  if (abfd->iostream == NULL)
	    abfd->iostream = real_fopen (abfd->filename, FOPEN_WUB);
	}
      else
	{
	  /* Create the file.

	     Some operating systems won't let us overwrite a running
	     binary.  For them, we want to unlink the file first.

	     However, gcc 2.95 will create temporary files using
	     O_EXCL and tight permissions to prevent other users from
	     substituting other .o files during the compilation.  gcc
	     will then tell the assembler to use the newly created
	     file as an output file.  If we unlink the file here, we
	     open a brief window when another user could still
	     substitute a file.

	     So we unlink the output file if and only if it has
	     non-zero size.  */
#ifndef __MSDOS__
	  /* Don't do this for MSDOS: it doesn't care about overwriting
	     a running binary, but if this file is already open by
	     another BFD, we will be in deep trouble if we delete an
	     open file.  In fact, objdump does just that if invoked with
	     the --info option.  */
	  struct stat s;

	  if (stat (abfd->filename, &s) == 0 && s.st_size != 0)
	    unlink_if_ordinary (abfd->filename);
#endif
	  abfd->iostream = real_fopen (abfd->filename, FOPEN_WUB);
	  abfd->opened_once = TRUE;
	}
      break;
    }

  if (abfd->iostream == NULL)
    bfd_set_error (bfd_error_system_call);
  else
    {
      if (! bfd_cache_init (abfd))
	return NULL;
    }

  return (FILE *) abfd->iostream;
}
@


1.44
log
@	PR binutils/14813
	* bfdio.c (struct bfd_iovec <bclose>): Revert 2012-11-06.
	(memory_bclose): Likewise.  Return 0 on success.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose, bfd_close): Likewise.
	* vms-lib.c (vms_lib_bclose): Likewise.
	* libbfd.h: Regenerate.
@
text
@d34 1
a34 1
	<<BFD_CACHE_MAX_OPEN>> files, and exports the name
d70 1
a70 1
   one time.  */
d72 27
a98 1
#define BFD_CACHE_MAX_OPEN 10
d216 1
a216 1
   <<BFD_CACHE_MAX_OPEN>> files open, it tries to close one first, to
d495 1
a495 1
  if (open_files >= BFD_CACHE_MAX_OPEN)
d582 1
a582 1
  if (open_files >= BFD_CACHE_MAX_OPEN)
@


1.43
log
@Change return type of bclose to bfd_boolean

	PR binutils/14813
	* bfdio.c (bfd_iovec): Change return type of bclose to
	bfd_boolean.
	(memory_bclose): Change return type to bfd_boolean.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose): Likewise.  Return TRUE on success.
	* vms-lib.c (vms_lib_bclose): Likewise.  Return TRUE.
	* libbfd.h: Regenerated.
@
text
@d362 1
a362 1
static bfd_boolean
d365 1
a365 1
  return bfd_cache_close (abfd);
@


1.42
log
@	* cache.c (cache_bmmap): Don't use void* arithmetic.
@
text
@d362 1
a362 1
static int
@


1.41
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d440 1
a440 1
          ret += offset & pagesize_m1;
@


1.41.4.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d365 1
a365 1
  return bfd_cache_close (abfd) - 1;
@


1.40
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (bfd_tell): Handle nested archives.
	(bfd_seek): Ditto.
	* cache.c (bfd_cache_lookup_worker): Ditto.
	* archive.c (_bfd_get_elt_at_filepos): Remove code dealing with
	nested archives.
	(bfd_generic_openr_next_archived_file): Likewise.
@
text
@d566 1
a566 1
      abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_RB);
d572 1
a572 1
	  abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_RUB);
d574 1
a574 1
	    abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_WUB);
d604 1
a604 1
	  abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_WUB);
@


1.39
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* cache.c: Include bfd_stdint.h.
	(cache_bmmap): Change profile.  Return region start and size.
	* bfdio.c (struct bfd_iovec): Change bmmap profile.
	(bfd_mmap): Change profile and adjust.   Update comment.
	(memory_bmmap): Change profile.
	* opncls.c (opncls_bmmap): Change profile.
	* vms-lib.c (vms_lib_bmmap): Likewise.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d201 1
a201 1
  if (abfd->my_archive)
@


1.38
log
@2009-12-11  Tristan Gingold  <gingold@@adacore.com>

	* som.c (bfd_som_set_subsection_attributes)
	(bfd_section_from_som_symbol, som_reloc_queue_fix): Fix shadowed
	variable warnings.
	* cache.c (close_one): Likewise.
@
text
@d48 1
d402 3
a404 1
	     file_ptr offset ATTRIBUTE_UNUSED)
d413 6
a418 1
      FILE *f = bfd_cache_lookup (abfd, CACHE_NO_SEEK_ERROR);
d422 12
a433 1
      ret = mmap (addr, len, prot, flags, fileno (f), offset);
d436 6
@


1.37
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d147 1
a147 1
  register bfd *kill;
d150 1
a150 1
    kill = NULL;
d153 3
a155 3
      for (kill = bfd_last_cache->lru_prev;
	   ! kill->cacheable;
	   kill = kill->lru_prev)
d157 1
a157 1
	  if (kill == bfd_last_cache)
d159 1
a159 1
	      kill = NULL;
d165 1
a165 1
  if (kill == NULL)
d171 1
a171 1
  kill->where = real_ftell ((FILE *) kill->iostream);
d173 1
a173 1
  return bfd_cache_delete (kill);
@


1.36
log
@update copyright dates
@
text
@d243 1
a243 1
  FILE *f = bfd_cache_lookup (abfd, whence != SEEK_CUR ? CACHE_NO_SEEK : 0);
d273 1
a273 1
  f = bfd_cache_lookup (abfd, 0);
d348 1
a348 1
  FILE *f = bfd_cache_lookup (abfd, 0);
@


1.36.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d243 1
a243 1
  FILE *f = bfd_cache_lookup (abfd, whence != SEEK_CUR ? CACHE_NO_SEEK : CACHE_NORMAL);
d273 1
a273 1
  f = bfd_cache_lookup (abfd, CACHE_NORMAL);
d348 1
a348 1
  FILE *f = bfd_cache_lookup (abfd, CACHE_NORMAL);
@


1.35
log
@2009-06-10  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* bfd-in2.h: bfd_mmap prototype
	* bfdio.c (bfd_mmap): New function.
	* libbfd.h (bfd_iovec): Add bmmap.
	* cache.c (cache_bmap): New function.
	(cache_iovec): Initialize bmmap member.
	* opencls.c (opncls_bmmap): New function.
	(opncls_iovec): Initialize bmmap member.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.34
log
@ * cache.c (cache_bread): Cast void * pointer before performing
 arithmetic on it.
@
text
@d49 4
d395 28
d426 1
a426 1
  &cache_bclose, &cache_bflush, &cache_bstat
@


1.33
log
@        * cache.c (cache_bread_1): Renames cache_bread.
        (cache_bread): New function.
@
text
@d320 1
a320 1
      chunk_nread = cache_bread_1 (abfd, buf + nread, chunk_size);
d345 1
d368 1
d382 1
d391 2
a392 1
static const struct bfd_iovec cache_iovec = {
@


1.32
log
@	* cache.c (close_one): Remove mtime hack.

	* corefile.c (reopen_exec_file): Use exec_bfd_mtime.
	* exec.c (exec_bfd_mtime): Define.
	(exec_close): Clear it.
	(exec_file_attach): Set it.
	* gdbcore.h (exec_bfd_mtime): Declare.
	* source.c (find_source_lines): Do not use bfd_get_mtime.
@
text
@d253 1
a253 1
cache_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
d304 37
@


1.31
log
@	* cache.c (cache_bread): Set bfd_error_file_truncated if EOF
	was reached.
	* srec.c (srec_scan): Calculate the checksum.  Complain on mismatch.
@
text
@a168 16
  /* Save the file st_mtime.  This is a hack so that gdb can detect when
     an executable has been deleted and recreated.  The only thing that
     makes this reasonable is that st_mtime doesn't change when a file
     is unlinked, so saving st_mtime makes BFD's file cache operation
     a little more transparent for this particular usage pattern.  If we
     hadn't closed the file then we would not have lost the original
     contents, st_mtime etc.  Of course, if something is writing to an
     existing file, then this is the wrong thing to do.
     FIXME: gdb should save these times itself on first opening a file,
     and this hack be removed.  */
  if (kill->direction == no_direction || kill->direction == read_direction)
    {
      bfd_get_mtime (kill);
      kill->mtime_set = TRUE;
    }

@


1.30
log
@Switch sources over to use the GPL version 3
@
text
@d312 4
@


1.29
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 14
a23 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.28
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@d4 1
a4 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d43 1
a44 1
#include "sysdep.h"
@


1.27
log
@	PR 973
	* cache.c (enum cache_flag): New.
	(close_one): Save file mtime.
	(bfd_cache_lookup): Add flag arg, adjust all users.
	(bfd_cache_lookup_worker): Likewise.
	(cache_btell): Use CACHE_NO_OPEN and return abfd->where if file
	not open.
	(cache_bflush): Similarly, and return success of file not open.
	(cache_bseek): Use CACHE_NO_SEEK if SEEK_SET or SEEK_END.
	(cache_bstat): Use CACHE_NO_SEEK_ERROR.
@
text
@d479 1
a479 1
      abfd->iostream = (PTR) fopen (abfd->filename, FOPEN_RB);
d485 1
a485 1
	  abfd->iostream = (PTR) fopen (abfd->filename, FOPEN_RUB);
d487 1
a487 1
	    abfd->iostream = (PTR) fopen (abfd->filename, FOPEN_WUB);
d517 1
a517 1
	  abfd->iostream = (PTR) fopen (abfd->filename, FOPEN_WUB);
@


1.27.2.1
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@d479 1
a479 1
      abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_RB);
d485 1
a485 1
	  abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_RUB);
d487 1
a487 1
	    abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_WUB);
d517 1
a517 1
	  abfd->iostream = (PTR) real_fopen (abfd->filename, FOPEN_WUB);
@


1.26
log
@	* cache.c (BFD_CACHE_MAX_OPEN): Make private to this file.
	(bfd_last_cache, bfd_cache_lookup, bfd_cache_lookup_worker): Likewise.
	* libbfd-in.h (bfd_cache_lookup_worker, bfd_last_cache): Delete.
	* libbfd.h: Regenerate.
@
text
@d48 15
d168 16
d192 1
a192 1
#define bfd_cache_lookup(x) \
d195 1
a195 1
   : bfd_cache_lookup_worker (x))
d205 1
a205 1
bfd_cache_lookup_worker (bfd *abfd)
d225 3
d230 3
a232 1
  else if (real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
d245 1
a245 1
  FILE *f = bfd_cache_lookup (abfd);
d247 1
a247 1
    return -1;
d254 1
a254 1
  FILE *f = bfd_cache_lookup (abfd);
d284 1
a284 1
  f = bfd_cache_lookup (abfd);
d318 1
a318 1
  FILE *f = bfd_cache_lookup (abfd);
d340 1
a340 1
  FILE *f = bfd_cache_lookup (abfd);
d342 1
a342 1
    return -1;
d353 1
a353 1
  FILE *f = bfd_cache_lookup (abfd);
@


1.25
log
@	* cache.c: Reorganize file to avoid forward reference.
@
text
@d4 1
a4 1
   2003, 2004 Free Software Foundation, Inc.
d48 2
a49 7
/*
INTERNAL_FUNCTION
	BFD_CACHE_MAX_OPEN macro

DESCRIPTION
	The maximum number of files which the cache will keep open at
	one time.
d51 1
a51 3
.#define BFD_CACHE_MAX_OPEN 10

*/
d57 3
a59 12
/*
INTERNAL_FUNCTION
	bfd_last_cache

SYNOPSIS
	extern bfd *bfd_last_cache;

DESCRIPTION
	Zero, or a pointer to the topmost BFD on the chain.  This is
	used by the <<bfd_cache_lookup>> macro in @@file{libbfd.h} to
	determine when it can avoid a function call.
*/
d61 1
a61 1
bfd *bfd_last_cache = NULL;
d156 16
a171 20
/*
  INTERNAL_FUNCTION
  	bfd_cache_lookup

  DESCRIPTION
 	Check to see if the required BFD is the same as the last one
 	looked up. If so, then it can use the stream in the BFD with
 	impunity, since it can't have changed since the last lookup;
 	otherwise, it has to perform the complicated lookup function.

  .#define bfd_cache_lookup(x) \
  .    ((x) == bfd_last_cache ? \
  .      (FILE *) (bfd_last_cache->iostream): \
  .       bfd_cache_lookup_worker (x))

 */

/*
INTERNAL_FUNCTION
	bfd_cache_lookup_worker
d173 1
a173 13
SYNOPSIS
	FILE *bfd_cache_lookup_worker (bfd *abfd);

DESCRIPTION
	Called when the macro <<bfd_cache_lookup>> fails to find a
	quick answer.  Find a file descriptor for @@var{abfd}.  If
	necessary, it open it.  If there are already more than
	<<BFD_CACHE_MAX_OPEN>> files open, it tries to close one first, to
	avoid running out of file descriptors.  It will return NULL
	if it is unable to (re)open the @@var{abfd}.
*/

FILE *
@


1.24
log
@	* cache.c (bfd_cache_lookup_worker): Don't abort on failing to
	reopen file.
	(cache_btell, cache_bseek, cache_bflush, cache_bstat): Return -1 on
	bfd_cache_lookup failure.
	(cache_bread, cache_bwrite): Return 0 on the same.
	* bfdwin.c (bfd_get_file_window): Likewise.
	* hppabsd-core.c (hppabsd_core_core_file_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.
@
text
@d48 30
a77 1
static bfd_boolean bfd_cache_delete (bfd *);
d79 158
a364 141
	BFD_CACHE_MAX_OPEN macro

DESCRIPTION
	The maximum number of files which the cache will keep open at
	one time.

.#define BFD_CACHE_MAX_OPEN 10

*/

/* The number of BFD files we have open.  */

static int open_files;

/*
INTERNAL_FUNCTION
	bfd_last_cache

SYNOPSIS
	extern bfd *bfd_last_cache;

DESCRIPTION
	Zero, or a pointer to the topmost BFD on the chain.  This is
	used by the <<bfd_cache_lookup>> macro in @@file{libbfd.h} to
	determine when it can avoid a function call.
*/

bfd *bfd_last_cache = NULL;

/*
  INTERNAL_FUNCTION
  	bfd_cache_lookup

  DESCRIPTION
 	Check to see if the required BFD is the same as the last one
 	looked up. If so, then it can use the stream in the BFD with
 	impunity, since it can't have changed since the last lookup;
 	otherwise, it has to perform the complicated lookup function.

  .#define bfd_cache_lookup(x) \
  .    ((x) == bfd_last_cache ? \
  .      (FILE *) (bfd_last_cache->iostream): \
  .       bfd_cache_lookup_worker (x))

 */

/* Insert a BFD into the cache.  */

static void
insert (bfd *abfd)
{
  if (bfd_last_cache == NULL)
    {
      abfd->lru_next = abfd;
      abfd->lru_prev = abfd;
    }
  else
    {
      abfd->lru_next = bfd_last_cache;
      abfd->lru_prev = bfd_last_cache->lru_prev;
      abfd->lru_prev->lru_next = abfd;
      abfd->lru_next->lru_prev = abfd;
    }
  bfd_last_cache = abfd;
}

/* Remove a BFD from the cache.  */

static void
snip (bfd *abfd)
{
  abfd->lru_prev->lru_next = abfd->lru_next;
  abfd->lru_next->lru_prev = abfd->lru_prev;
  if (abfd == bfd_last_cache)
    {
      bfd_last_cache = abfd->lru_next;
      if (abfd == bfd_last_cache)
	bfd_last_cache = NULL;
    }
}

/* We need to open a new file, and the cache is full.  Find the least
   recently used cacheable BFD and close it.  */

static bfd_boolean
close_one (void)
{
  register bfd *kill;

  if (bfd_last_cache == NULL)
    kill = NULL;
  else
    {
      for (kill = bfd_last_cache->lru_prev;
	   ! kill->cacheable;
	   kill = kill->lru_prev)
	{
	  if (kill == bfd_last_cache)
	    {
	      kill = NULL;
	      break;
	    }
	}
    }

  if (kill == NULL)
    {
      /* There are no open cacheable BFD's.  */
      return TRUE;
    }

  kill->where = real_ftell ((FILE *) kill->iostream);

  return bfd_cache_delete (kill);
}

/* Close a BFD and remove it from the cache.  */

static bfd_boolean
bfd_cache_delete (bfd *abfd)
{
  bfd_boolean ret;

  if (fclose ((FILE *) abfd->iostream) == 0)
    ret = TRUE;
  else
    {
      ret = FALSE;
      bfd_set_error (bfd_error_system_call);
    }

  snip (abfd);

  abfd->iostream = NULL;
  --open_files;

  return ret;
}

/*
INTERNAL_FUNCTION
a528 49

/*
INTERNAL_FUNCTION
	bfd_cache_lookup_worker

SYNOPSIS
	FILE *bfd_cache_lookup_worker (bfd *abfd);

DESCRIPTION
	Called when the macro <<bfd_cache_lookup>> fails to find a
	quick answer.  Find a file descriptor for @@var{abfd}.  If
	necessary, it open it.  If there are already more than
	<<BFD_CACHE_MAX_OPEN>> files open, it tries to close one first, to
	avoid running out of file descriptors.  It will return NULL
	if it is unable to (re)open the @@var{abfd}.
*/

FILE *
bfd_cache_lookup_worker (bfd *abfd)
{
  bfd *orig_bfd = abfd;
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

  if (abfd->my_archive)
    abfd = abfd->my_archive;

  if (abfd->iostream != NULL)
    {
      /* Move the file to the start of the cache.  */
      if (abfd != bfd_last_cache)
	{
	  snip (abfd);
	  insert (abfd);
	}
      return (FILE *) abfd->iostream;
    }

  if (bfd_open_file (abfd) == NULL)
    ;
  else if (real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
    bfd_set_error (bfd_error_system_call);
  else
    return (FILE *) abfd->iostream;

  (*_bfd_error_handler) (_("reopening %B: %s\n"),
			 orig_bfd, bfd_errmsg (bfd_get_error ()));
  return NULL;
}
@


1.23
log
@	* cache.c (bfd_cache_lookup_worker): Use bfd_error_handler
	rather than bfd_perror.  Print file name.  Internationalise.
@
text
@d54 4
a57 1
  return real_ftell (bfd_cache_lookup (abfd));
d63 4
a66 1
  return real_fseek (bfd_cache_lookup (abfd), offset, whence);
d79 1
d93 4
d100 1
a100 1
  nread = read (fileno (bfd_cache_lookup (abfd)), buf, nbytes);
d110 1
a110 1
  nread = fread (buf, 1, nbytes, bfd_cache_lookup (abfd));
d114 1
a114 1
  if (nread < nbytes && ferror (bfd_cache_lookup (abfd)))
d126 6
a131 2
  file_ptr nwrite = fwrite (where, 1, nbytes, bfd_cache_lookup (abfd));
  if (nwrite < nbytes && ferror (bfd_cache_lookup (abfd)))
d148 5
a152 1
  int sts = fflush (bfd_cache_lookup (abfd));
d161 5
a165 1
  int sts = fstat (fileno (bfd_cache_lookup (abfd)), sb);
d496 2
a497 2
	avoid running out of file descriptors.  It will abort rather than
	returning NULL if it is unable to (re)open the @@var{abfd}.
a529 1
  abort ();
@


1.22
log
@	* cache.c (bfd_open_file): Set bfd_error_system_call on failure
	to open file.
	(bfd_cache_lookup_worker): Remove check that file pos is in
	unsigned long range.  Print system error before aborting.
@
text
@d480 1
d505 2
a506 1
  bfd_perror ("Cannot continue");
@


1.21
log
@        * archive.c: Add missing SUBSECTION for documentation.
        * bfd.c: Likewise.
        * cache.c: Likewise.
        * corefile.c: Likewise.
        * format.c: Likewise.
        * init.c: Likewise.
        * libbfd.c: Likewise.
        * opncls.c: Likewise.
        * elf.c: Remove blank line after SECTION heading.
        * reloc.c: Change "howto manager" SECTION to a SUBSECTION.
@
text
@d450 3
a452 1
  if (abfd->iostream != NULL)
d494 1
d496 5
d502 1
a502 6
    {
      if (bfd_open_file (abfd) == NULL
	  || abfd->where != (unsigned long) abfd->where
	  || real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
	abort ();
    }
d504 3
a506 1
  return (FILE *) abfd->iostream;
@


1.20
log
@(bfd_last_cache): Initialise to NULL.
@
text
@d39 2
@


1.19
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d180 1
a180 1
bfd *bfd_last_cache;
@


1.18
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.17
log
@bfd/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* Makefile.am: Add dependency of cache.o on libiberty.h.
	* cache.c: Include libiberty.h.
	(bfd_open_file): Use unlink_if_ordinary instead of unlink.

binutils/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ar.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* objcopy.c (copy_file): Likewise.
	(strip_main): Likewise.

gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* as.c (main): Use unlink_if_ordinary instead of unlink.
	* messages.c (as_fatal): Likewise.

ld/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ldmain.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* pe-dll.c (pe_dll_generate_implib): Likewise.
@
text
@d22 1
a22 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.16
log
@cache.c (bfd_cache_close_all): Add missing return statement.
@
text
@d44 1
d440 1
a440 1
	    unlink (abfd->filename);
@


1.15
log
@	* bfd-in.h (bfd_cache_close_all): New function declaration.
	* bfd-in2.h: Regenerate.
	* cache.c (bfd_cache_close_all): New function definition.
@
text
@d369 2
@


1.14
log
@PR/136 - Have bfd_cache_lookup_worker() abort rather than return an
(unchecked-for) NULL.
@
text
@d347 25
@


1.13
log
@2004-04-22  Andrew Cagney  <cagney@@redhat.com>

	* cache.c (bfd_cache_close): Check for a previously closed file.
@
text
@d192 3
a194 3
  .    ((x)==bfd_last_cache? \
  .      (FILE*) (bfd_last_cache->iostream): \
  .       bfd_cache_lookup_worker(x))
d441 2
a442 1
	avoid running out of file descriptors.
d465 4
a468 6
      if (bfd_open_file (abfd) == NULL)
	return NULL;
      if (abfd->where != (unsigned long) abfd->where)
	return NULL;
      if (real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
	return NULL;
@


1.12
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* opncls.c (_bfd_new_bfd_contained_in): Copy "iovec".
	(struct opncls, opncls_btell, opncls_bseek, opncls_bread)
	(opncls_bwrite, opncls_bclose, opncls_bflush)
	(opncls_bstat, opncls_iovec, bfd_openr_iovec): Implement a
	bfd iovec that uses function callbacks.
	(bfd_close): Use the iovec's bclose.
	* cache.c (cache_btell, cache_bseek, cache_bread, cache_bwrite)
	(cache_bclose, cache_bflush, cache_bstat)
	(cache_iovec): New functions and global variable, implement a
	cache "iovec", where applicable set bfd_error.
	(bfd_cache_init, bfd_cache_close): Set/test the bfd's iovec.
	* bfdio.c (struct bfd_iovec): Define.
	(real_read): Delete function.
	(bfd_bread, bfd_bread, bfd_bwrite, bfd_tell, bfd_flush, bfd_stat)
	(bfd_seek, bfd_get_mtime, bfd_get_size): Use the bfd's "iovec",
	assume that bread and bwrite set bfd_error.
	* bfd.c (struct bfd): Add "iovec", update comments.
	* bfd-in2.h, libbfd.h: Re-generate.
@
text
@d339 4
@


1.11
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* bfd-in.h: Update copyright.
	(bfd_tell): Change return type to file_ptr.
	* bfd-in2.h: Re-generate.
	* cache.c: Update copyright.
	(bfd_cache_lookup_worker): Use real_fseek, do not cast offset
	parameter.
	(close_one): Use real_ftell.
	* bfdio.c: Update copyright.
	(real_ftell, real_fseek): New functions.
	(bfd_tell): Use real_fseek and real_ftell, change return type to
	file_ptr.
	(bfd_seek): Use real_ftell and real_fseek, change type of
	file_position to a file_ptr.
	* libbfd-in.h: Update copyright.
	(real_ftell, real_fseek): Declare.
	* libbfd.h: Re-generate.
@
text
@d47 103
d311 1
d336 1
a336 2
  if (abfd->iostream == NULL
      || (abfd->flags & BFD_IN_MEMORY) != 0)
@


1.11.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a46 103

static file_ptr
cache_btell (struct bfd *abfd)
{
  return real_ftell (bfd_cache_lookup (abfd));
}

static int
cache_bseek (struct bfd *abfd, file_ptr offset, int whence)
{
  return real_fseek (bfd_cache_lookup (abfd), offset, whence);
}

/* Note that archive entries don't have streams; they share their parent's.
   This allows someone to play with the iostream behind BFD's back.

   Also, note that the origin pointer points to the beginning of a file's
   contents (0 for non-archive elements).  For archive entries this is the
   first octet in the file, NOT the beginning of the archive header.  */

static file_ptr
cache_bread (struct bfd *abfd, void *buf, file_ptr nbytes)
{
  file_ptr nread;
  /* FIXME - this looks like an optimization, but it's really to cover
     up for a feature of some OSs (not solaris - sigh) that
     ld/pe-dll.c takes advantage of (apparently) when it creates BFDs
     internally and tries to link against them.  BFD seems to be smart
     enough to realize there are no symbol records in the "file" that
     doesn't exist but attempts to read them anyway.  On Solaris,
     attempting to read zero bytes from a NULL file results in a core
     dump, but on other platforms it just returns zero bytes read.
     This makes it to something reasonable. - DJ */
  if (nbytes == 0)
    return 0;

#if defined (__VAX) && defined (VMS)
  /* Apparently fread on Vax VMS does not keep the record length
     information.  */
  nread = read (fileno (bfd_cache_lookup (abfd)), buf, nbytes);
  /* Set bfd_error if we did not read as much data as we expected.  If
     the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.  */
  if (nread == (file_ptr)-1)
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
#else
  nread = fread (buf, 1, nbytes, bfd_cache_lookup (abfd));
  /* Set bfd_error if we did not read as much data as we expected.  If
     the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.  */
  if (nread < nbytes && ferror (bfd_cache_lookup (abfd)))
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
#endif
  return nread;
}

static file_ptr
cache_bwrite (struct bfd *abfd, const void *where, file_ptr nbytes)
{
  file_ptr nwrite = fwrite (where, 1, nbytes, bfd_cache_lookup (abfd));
  if (nwrite < nbytes && ferror (bfd_cache_lookup (abfd)))
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
  return nwrite;
}

static int
cache_bclose (struct bfd *abfd)
{
  return bfd_cache_close (abfd);
}

static int
cache_bflush (struct bfd *abfd)
{
  int sts = fflush (bfd_cache_lookup (abfd));
  if (sts < 0)
    bfd_set_error (bfd_error_system_call);
  return sts;
}

static int
cache_bstat (struct bfd *abfd, struct stat *sb)
{
  int sts = fstat (fileno (bfd_cache_lookup (abfd)), sb);
  if (sts < 0)
    bfd_set_error (bfd_error_system_call);
  return sts;
}

static const struct bfd_iovec cache_iovec = {
  &cache_bread, &cache_bwrite, &cache_btell, &cache_bseek,
  &cache_bclose, &cache_bflush, &cache_bstat
};

d89 3
a91 3
  .    ((x) == bfd_last_cache ? \
  .      (FILE *) (bfd_last_cache->iostream): \
  .       bfd_cache_lookup_worker (x))
a207 1
  abfd->iovec = &cache_iovec;
d232 2
a233 5
  if (abfd->iovec != &cache_iovec)
    return TRUE;

  if (abfd->iostream == NULL)
    /* Previously closed.  */
a239 27
FUNCTION
	bfd_cache_close_all

SYNOPSIS
	bfd_boolean bfd_cache_close_all (void);

DESCRIPTION
	Remove all BFDs from the cache. If the attached file is open,
	then close it too.

RETURNS
	<<FALSE>> is returned if closing one of the file fails, <<TRUE>> is
	returned if all is well.
*/

bfd_boolean
bfd_cache_close_all ()
{
  bfd_boolean ret = TRUE;

  while (bfd_last_cache != NULL)
    ret &= bfd_cache_close (bfd_last_cache);

  return ret;
}

/*
d334 1
a334 2
	avoid running out of file descriptors.  It will abort rather than
	returning NULL if it is unable to (re)open the @@var{abfd}.
d357 6
a362 4
      if (bfd_open_file (abfd) == NULL
	  || abfd->where != (unsigned long) abfd->where
	  || real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
	abort ();
@


1.10
log
@Convert to C90 and a few tweaks.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d160 1
a160 1
  kill->where = ftell ((FILE *) kill->iostream);
d361 1
a361 1
      if (fseek ((FILE *) abfd->iostream, (long) abfd->where, SEEK_SET) != 0)
@


1.10.8.1
log
@Index: bfd/ChangeLog
2004-01-21  Andrew Cagney  <cagney@@redhat.com>

	* bfdio.c: Update copyright.  Include "bfdio.h".
	(real_ftell, real_fseek): New functions.
	(bfd_tell): Use real_ftell, change return-type to file_ptr.
	(bfd_seek): Use real_ftell and real_fseek.  Change type of
	file_position to a file_ptr.
	* cache.c: Update copyright.  Include "bfdio.h".
	(close_one): Use real_ftell.
	(bfd_cache_lookup_worker): Use real_fseek, use ufile_ptr in cast.
	* bfd-in.h: Update copyright.
	(file_ptr, ufile_ptr): Specify type using @@BFD_FILE_PTR@@.
	(bfd_tell): Make return-type "file_ptr".
	* bfd-in2.h: Re-generate.
	* configure.in (AC_CHECK_FUNCS): Check for ftello, ftello64,
	fseeko and fseeko64.
	* config.in, configure: Re-generate.
	* libbfd-in.h: Update copyright.
	(real_ftell, real_fseek): Declare.
	* libbfd.h: Re-generate.
	* elf.c (offset_vma_page_alignment): New function.
	(assign_file_positions_for_segments): Replace broken modulo code
	with offset_vma_page_alignment.
	(assign_file_positions_except_relocs): Ditto.

Index: gdb/testsuite/ChangeLog
2004-01-22  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/bigcore.exp: New file.
	* gdb.base/bigcore.c: New file.
@
text
@d2 2
a3 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.

d158 1
a158 1
  kill->where = real_ftell ((FILE *) kill->iostream);
d357 1
a357 1
      if (abfd->where != (ufile_ptr) abfd->where)
d359 1
a359 1
      if (real_fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
@


1.9
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002
d43 1
a43 4
static void insert PARAMS ((bfd *));
static void snip PARAMS ((bfd *));
static bfd_boolean close_one PARAMS ((void));
static bfd_boolean bfd_cache_delete PARAMS ((bfd *));
d95 2
a96 3
static INLINE void
insert (abfd)
     bfd *abfd;
d115 2
a116 3
static INLINE void
snip (abfd)
     bfd *abfd;
d132 1
a132 1
close_one ()
d166 1
a166 2
bfd_cache_delete (abfd)
     bfd *abfd;
d198 1
a198 2
bfd_cache_init (abfd)
     bfd *abfd;
d228 1
a228 2
bfd_cache_close (abfd)
     bfd *abfd;
d242 1
a242 1
	FILE* bfd_open_file(bfd *abfd);
d253 1
a253 2
bfd_open_file (abfd)
     bfd *abfd;
d325 1
a325 1
	FILE *bfd_cache_lookup_worker(bfd *abfd);
d336 1
a336 2
bfd_cache_lookup_worker (abfd)
     bfd *abfd;
@


1.8
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d45 2
a46 2
static boolean close_one PARAMS ((void));
static boolean bfd_cache_delete PARAMS ((bfd *));
d136 1
a136 1
static boolean
d160 1
a160 1
      return true;
d170 1
a170 1
static boolean
d174 1
a174 1
  boolean ret;
d177 1
a177 1
    ret = true;
d180 1
a180 1
      ret = false;
d197 1
a197 1
	boolean bfd_cache_init (bfd *abfd);
d203 1
a203 1
boolean
d211 1
a211 1
	return false;
d215 1
a215 1
  return true;
d223 1
a223 1
	boolean bfd_cache_close (bfd *abfd);
d230 1
a230 1
	<<false>> is returned if closing the file fails, <<true>> is
d234 1
a234 1
boolean
d240 1
a240 1
    return true;
d264 1
a264 1
  abfd->cacheable = true;	/* Allow it to be closed later.  */
d315 1
a315 1
	  abfd->opened_once = true;
@


1.8.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002, 2003
d43 4
a46 1
static bfd_boolean bfd_cache_delete (bfd *);
d98 3
a100 2
static void
insert (bfd *abfd)
d119 3
a121 2
static void
snip (bfd *abfd)
d136 2
a137 2
static bfd_boolean
close_one (void)
d160 1
a160 1
      return TRUE;
d170 3
a172 2
static bfd_boolean
bfd_cache_delete (bfd *abfd)
d174 1
a174 1
  bfd_boolean ret;
d177 1
a177 1
    ret = TRUE;
d180 1
a180 1
      ret = FALSE;
d197 1
a197 1
	bfd_boolean bfd_cache_init (bfd *abfd);
d203 3
a205 2
bfd_boolean
bfd_cache_init (bfd *abfd)
d211 1
a211 1
	return FALSE;
d215 1
a215 1
  return TRUE;
d223 1
a223 1
	bfd_boolean bfd_cache_close (bfd *abfd);
d230 1
a230 1
	<<FALSE>> is returned if closing the file fails, <<TRUE>> is
d234 3
a236 2
bfd_boolean
bfd_cache_close (bfd *abfd)
d240 1
a240 1
    return TRUE;
d250 1
a250 1
	FILE* bfd_open_file (bfd *abfd);
d261 2
a262 1
bfd_open_file (bfd *abfd)
d264 1
a264 1
  abfd->cacheable = TRUE;	/* Allow it to be closed later.  */
d315 1
a315 1
	  abfd->opened_once = TRUE;
d334 1
a334 1
	FILE *bfd_cache_lookup_worker (bfd *abfd);
d345 2
a346 1
bfd_cache_lookup_worker (bfd *abfd)
@


1.8.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d45 2
a46 2
static bfd_boolean close_one PARAMS ((void));
static bfd_boolean bfd_cache_delete PARAMS ((bfd *));
d136 1
a136 1
static bfd_boolean
d160 1
a160 1
      return TRUE;
d170 1
a170 1
static bfd_boolean
d174 1
a174 1
  bfd_boolean ret;
d177 1
a177 1
    ret = TRUE;
d180 1
a180 1
      ret = FALSE;
d197 1
a197 1
	bfd_boolean bfd_cache_init (bfd *abfd);
d203 1
a203 1
bfd_boolean
d211 1
a211 1
	return FALSE;
d215 1
a215 1
  return TRUE;
d223 1
a223 1
	bfd_boolean bfd_cache_close (bfd *abfd);
d230 1
a230 1
	<<FALSE>> is returned if closing the file fails, <<TRUE>> is
d234 1
a234 1
bfd_boolean
d240 1
a240 1
    return TRUE;
d264 1
a264 1
  abfd->cacheable = TRUE;	/* Allow it to be closed later.  */
d315 1
a315 1
	  abfd->opened_once = TRUE;
@


1.8.12.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002, 2003
d43 4
a46 1
static bfd_boolean bfd_cache_delete (bfd *);
d98 3
a100 2
static void
insert (bfd *abfd)
d119 3
a121 2
static void
snip (bfd *abfd)
d137 1
a137 1
close_one (void)
d171 2
a172 1
bfd_cache_delete (bfd *abfd)
d204 2
a205 1
bfd_cache_init (bfd *abfd)
d235 2
a236 1
bfd_cache_close (bfd *abfd)
d250 1
a250 1
	FILE* bfd_open_file (bfd *abfd);
d261 2
a262 1
bfd_open_file (bfd *abfd)
d334 1
a334 1
	FILE *bfd_cache_lookup_worker (bfd *abfd);
d345 2
a346 1
bfd_cache_lookup_worker (bfd *abfd)
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001
d280 1
a280 1
      if (abfd->opened_once == true)
@


1.7.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001, 2002
d280 1
a280 1
      if (abfd->opened_once)
@


1.6
log
@Update copyright notices
@
text
@d367 3
a369 1
      if (fseek ((FILE *) abfd->iostream, abfd->where, SEEK_SET) != 0)
@


1.5
log
@Use SEGREL32 relocs for elf32-hppa unwind.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996, 2000, 2001
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1996, 2000, 2001
@


1.4
log
@2000-11-28  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffswap.h: Likewise.
	* corefile.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996, 2000
d314 1
a314 1
	  abfd->iostream = (PTR) fopen (abfd->filename, FOPEN_WB);
@


1.3
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d35 1
a35 1
	handle. 
d82 1
a82 1
 
d88 1
a88 1
 
d91 1
a91 1
  .      (FILE*)(bfd_last_cache->iostream): \
d93 1
a93 2
 
 
d264 1
a264 1
  abfd->cacheable = true;	/* Allow it to be closed later. */
d341 1
a341 1
	avoid running out of file descriptors.  
d351 1
a351 1
  if (abfd->my_archive) 
@


1.2
log
@2000-04-03  H.J. Lu  <hjl@@gnu.org>

	* cache.c (bfd_open_file): Unlink the output file only if
	it has none zero size.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
d304 6
d314 1
@


1.1
log
@Initial revision
@
text
@d288 19
a306 4
	  /* Create the file.  Unlink it first, for the convenience of
             operating systems which worry about overwriting running
             binaries.  */
	  unlink (abfd->filename);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@2000-04-03  H.J. Lu  <hjl@@gnu.org>

	* cache.c (bfd_open_file): Unlink the output file only if
	it has none zero size.
@
text
@d288 4
a291 19
	  /* Create the file.

	     Some operating systems won't let us overwrite a running
	     binary.  For them, we want to unlink the file first.

	     However, gcc 2.95 will create temporary files using
	     O_EXCL and tight permissions to prevent other users from
	     substituting other .o files during the compilation.  gcc
	     will then tell the assembler to use the newly created
	     file as an output file.  If we unlink the file here, we
	     open a brief window when another user could still
	     substitute a file.

	     So we unlink the output file if and only if it has
	     non-zero size.  */
	  struct stat s;

	  if (stat (abfd->filename, &s) == 0 && s.st_size != 0)
	    unlink (abfd->filename);
@


1.1.1.1.2.2
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 2
   Copyright 1990, 91, 92, 93, 94, 95, 1996, 2000
   Free Software Foundation, Inc.
a302 6
#ifndef __MSDOS__
	  /* Don't do this for MSDOS: it doesn't care about overwriting
	     a running binary, but if this file is already open by
	     another BFD, we will be in deep trouble if we delete an
	     open file.  In fact, objdump does just that if invoked with
	     the --info option.  */
a306 1
#endif
@


