head	1.88;
access;
symbols
	sid-snapshot-20180601:1.88
	sid-snapshot-20180501:1.88
	sid-snapshot-20180401:1.88
	sid-snapshot-20180301:1.88
	sid-snapshot-20180201:1.88
	sid-snapshot-20180101:1.88
	sid-snapshot-20171201:1.88
	sid-snapshot-20171101:1.88
	sid-snapshot-20171001:1.88
	sid-snapshot-20170901:1.88
	sid-snapshot-20170801:1.88
	sid-snapshot-20170701:1.88
	sid-snapshot-20170601:1.88
	sid-snapshot-20170501:1.88
	sid-snapshot-20170401:1.88
	sid-snapshot-20170301:1.88
	sid-snapshot-20170201:1.88
	sid-snapshot-20170101:1.88
	sid-snapshot-20161201:1.88
	sid-snapshot-20161101:1.88
	sid-snapshot-20160901:1.88
	sid-snapshot-20160801:1.88
	sid-snapshot-20160701:1.88
	sid-snapshot-20160601:1.88
	sid-snapshot-20160501:1.88
	sid-snapshot-20160401:1.88
	sid-snapshot-20160301:1.88
	sid-snapshot-20160201:1.88
	sid-snapshot-20160101:1.88
	sid-snapshot-20151201:1.88
	sid-snapshot-20151101:1.88
	sid-snapshot-20151001:1.88
	sid-snapshot-20150901:1.88
	sid-snapshot-20150801:1.88
	sid-snapshot-20150701:1.88
	sid-snapshot-20150601:1.88
	sid-snapshot-20150501:1.88
	sid-snapshot-20150401:1.88
	sid-snapshot-20150301:1.88
	sid-snapshot-20150201:1.88
	sid-snapshot-20150101:1.88
	sid-snapshot-20141201:1.88
	sid-snapshot-20141101:1.88
	sid-snapshot-20141001:1.88
	sid-snapshot-20140901:1.88
	sid-snapshot-20140801:1.88
	sid-snapshot-20140701:1.88
	sid-snapshot-20140601:1.88
	sid-snapshot-20140501:1.88
	sid-snapshot-20140401:1.88
	sid-snapshot-20140301:1.88
	sid-snapshot-20140201:1.88
	sid-snapshot-20140101:1.88
	sid-snapshot-20131201:1.88
	sid-snapshot-20131101:1.88
	sid-snapshot-20131001:1.88
	binutils-2_24-branch:1.88.0.8
	binutils-2_24-branchpoint:1.88
	binutils-2_21_1:1.84.2.2
	sid-snapshot-20130901:1.88
	gdb_7_6_1-2013-08-30-release:1.88
	sid-snapshot-20130801:1.88
	sid-snapshot-20130701:1.88
	sid-snapshot-20130601:1.88
	sid-snapshot-20130501:1.88
	gdb_7_6-2013-04-26-release:1.88
	sid-snapshot-20130401:1.88
	binutils-2_23_2:1.88
	gdb_7_6-branch:1.88.0.6
	gdb_7_6-2013-03-12-branchpoint:1.88
	sid-snapshot-20130301:1.88
	sid-snapshot-20130201:1.88
	sid-snapshot-20130101:1.88
	sid-snapshot-20121201:1.88
	gdb_7_5_1-2012-11-29-release:1.88
	binutils-2_23_1:1.88
	sid-snapshot-20121101:1.88
	binutils-2_23:1.88
	sid-snapshot-20121001:1.88
	sid-snapshot-20120901:1.88
	gdb_7_5-2012-08-17-release:1.88
	sid-snapshot-20120801:1.88
	binutils-2_23-branch:1.88.0.4
	binutils-2_23-branchpoint:1.88
	gdb_7_5-branch:1.88.0.2
	gdb_7_5-2012-07-18-branchpoint:1.88
	sid-snapshot-20120701:1.88
	sid-snapshot-20120601:1.88
	sid-snapshot-20120501:1.87
	binutils-2_22_branch:1.87.0.6
	gdb_7_4_1-2012-04-26-release:1.87
	sid-snapshot-20120401:1.87
	sid-snapshot-20120301:1.87
	sid-snapshot-20120201:1.87
	gdb_7_4-2012-01-24-release:1.87
	sid-snapshot-20120101:1.87
	gdb_7_4-branch:1.87.0.4
	gdb_7_4-2011-12-13-branchpoint:1.87
	sid-snapshot-20111201:1.87
	binutils-2_22:1.87
	sid-snapshot-20111101:1.87
	sid-snapshot-20111001:1.87
	binutils-2_22-branch:1.87.0.2
	binutils-2_22-branchpoint:1.87
	gdb_7_3_1-2011-09-04-release:1.86
	sid-snapshot-20110901:1.87
	sid-snapshot-20110801:1.87
	gdb_7_3-2011-07-26-release:1.86
	sid-snapshot-20110701:1.87
	sid-snapshot-20110601:1.86
	sid-snapshot-20110501:1.86
	gdb_7_3-branch:1.86.0.2
	gdb_7_3-2011-04-01-branchpoint:1.86
	sid-snapshot-20110401:1.86
	sid-snapshot-20110301:1.85
	sid-snapshot-20110201:1.85
	sid-snapshot-20110101:1.85
	binutils-2_21:1.84
	sid-snapshot-20101201:1.84
	binutils-2_21-branch:1.84.0.2
	binutils-2_21-branchpoint:1.84
	sid-snapshot-20101101:1.84
	sid-snapshot-20101001:1.83
	binutils-2_20_1:1.77.2.1
	gdb_7_2-2010-09-02-release:1.81
	sid-snapshot-20100901:1.83
	sid-snapshot-20100801:1.82
	gdb_7_2-branch:1.81.0.2
	gdb_7_2-2010-07-07-branchpoint:1.81
	sid-snapshot-20100701:1.81
	sid-snapshot-20100601:1.81
	sid-snapshot-20100501:1.81
	sid-snapshot-20100401:1.80
	gdb_7_1-2010-03-18-release:1.80
	sid-snapshot-20100301:1.80
	gdb_7_1-branch:1.80.0.2
	gdb_7_1-2010-02-18-branchpoint:1.80
	sid-snapshot-20100201:1.80
	sid-snapshot-20100101:1.80
	gdb_7_0_1-2009-12-22-release:1.78
	sid-snapshot-20091201:1.79
	sid-snapshot-20091101:1.79
	binutils-2_20:1.77.2.1
	gdb_7_0-2009-10-06-release:1.78
	sid-snapshot-20091001:1.78
	gdb_7_0-branch:1.78.0.2
	gdb_7_0-2009-09-16-branchpoint:1.78
	arc-sim-20090309:1.72
	binutils-arc-20081103-branch:1.72.0.22
	binutils-arc-20081103-branchpoint:1.72
	binutils-2_20-branch:1.77.0.2
	binutils-2_20-branchpoint:1.77
	sid-snapshot-20090901:1.76
	sid-snapshot-20090801:1.75
	msnyder-checkpoint-072509-branch:1.75.0.2
	msnyder-checkpoint-072509-branchpoint:1.75
	sid-snapshot-20090701:1.74
	dje-cgen-play1-branch:1.74.0.2
	dje-cgen-play1-branchpoint:1.74
	sid-snapshot-20090601:1.74
	sid-snapshot-20090501:1.74
	sid-snapshot-20090401:1.74
	arc-20081103-branch:1.72.0.20
	arc-20081103-branchpoint:1.72
	arc-insight_6_8-branch:1.72.0.18
	arc-insight_6_8-branchpoint:1.72
	insight_6_8-branch:1.72.0.16
	insight_6_8-branchpoint:1.72
	sid-snapshot-20090301:1.74
	binutils-2_19_1:1.72
	sid-snapshot-20090201:1.73
	sid-snapshot-20090101:1.73
	reverse-20081226-branch:1.73.0.2
	reverse-20081226-branchpoint:1.73
	sid-snapshot-20081201:1.73
	multiprocess-20081120-branch:1.72.0.14
	multiprocess-20081120-branchpoint:1.72
	sid-snapshot-20081101:1.72
	binutils-2_19:1.72
	sid-snapshot-20081001:1.72
	reverse-20080930-branch:1.72.0.12
	reverse-20080930-branchpoint:1.72
	binutils-2_19-branch:1.72.0.10
	binutils-2_19-branchpoint:1.72
	sid-snapshot-20080901:1.72
	sid-snapshot-20080801:1.72
	reverse-20080717-branch:1.72.0.8
	reverse-20080717-branchpoint:1.72
	sid-snapshot-20080701:1.72
	msnyder-reverse-20080609-branch:1.72.0.6
	msnyder-reverse-20080609-branchpoint:1.72
	drow-reverse-20070409-branch:1.63.0.2
	drow-reverse-20070409-branchpoint:1.63
	sid-snapshot-20080601:1.72
	sid-snapshot-20080501:1.72
	sid-snapshot-20080403:1.72
	sid-snapshot-20080401:1.72
	gdb_6_8-2008-03-27-release:1.72
	sid-snapshot-20080301:1.72
	gdb_6_8-branch:1.72.0.4
	gdb_6_8-2008-02-26-branchpoint:1.72
	sid-snapshot-20080201:1.72
	sid-snapshot-20080101:1.72
	sid-snapshot-20071201:1.72
	sid-snapshot-20071101:1.72
	gdb_6_7_1-2007-10-29-release:1.72
	gdb_6_7-2007-10-10-release:1.72
	sid-snapshot-20071001:1.72
	gdb_6_7-branch:1.72.0.2
	gdb_6_7-2007-09-07-branchpoint:1.72
	binutils-2_18:1.71
	binutils-2_18-branch:1.71.0.2
	binutils-2_18-branchpoint:1.71
	insight_6_6-20070208-release:1.62
	binutils-csl-coldfire-4_1-32:1.60
	binutils-csl-sourcerygxx-4_1-32:1.60
	gdb_6_6-2006-12-18-release:1.62
	binutils-csl-innovasic-fido-3_4_4-33:1.60
	binutils-csl-sourcerygxx-3_4_4-32:1.53
	binutils-csl-coldfire-4_1-30:1.60
	binutils-csl-sourcerygxx-4_1-30:1.60
	binutils-csl-coldfire-4_1-28:1.60
	binutils-csl-sourcerygxx-4_1-29:1.60
	binutils-csl-sourcerygxx-4_1-28:1.60
	gdb_6_6-branch:1.62.0.2
	gdb_6_6-2006-11-15-branchpoint:1.62
	binutils-csl-arm-2006q3-27:1.60
	binutils-csl-sourcerygxx-4_1-27:1.60
	binutils-csl-arm-2006q3-26:1.60
	binutils-csl-sourcerygxx-4_1-26:1.60
	binutils-csl-sourcerygxx-4_1-25:1.60
	binutils-csl-sourcerygxx-4_1-24:1.60
	binutils-csl-sourcerygxx-4_1-23:1.60
	insight_6_5-20061003-release:1.61
	gdb-csl-symbian-6_4_50_20060226-12:1.59
	binutils-csl-sourcerygxx-4_1-21:1.60
	binutils-csl-arm-2006q3-21:1.60
	binutils-csl-sourcerygxx-4_1-22:1.60
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.60
	binutils-csl-sourcerygxx-4_1-20:1.60
	binutils-csl-arm-2006q3-19:1.60
	binutils-csl-sourcerygxx-4_1-19:1.60
	binutils-csl-sourcerygxx-4_1-18:1.60
	binutils-csl-renesas-4_1-9:1.60
	gdb-csl-sourcerygxx-3_4_4-25:1.59
	binutils-csl-sourcerygxx-3_4_4-25:1.53
	nickrob-async-20060828-mergepoint:1.62
	gdb-csl-symbian-6_4_50_20060226-11:1.59
	binutils-csl-renesas-4_1-8:1.60
	binutils-csl-renesas-4_1-7:1.60
	binutils-csl-renesas-4_1-6:1.60
	gdb-csl-sourcerygxx-4_1-17:1.59
	binutils-csl-sourcerygxx-4_1-17:1.60
	gdb-csl-20060226-branch-local-2:1.59
	gdb-csl-sourcerygxx-4_1-14:1.59
	binutils-csl-sourcerygxx-4_1-14:1.60
	binutils-csl-sourcerygxx-4_1-15:1.60
	gdb-csl-sourcerygxx-4_1-13:1.59
	binutils-csl-sourcerygxx-4_1-13:1.60
	binutils-2_17:1.60
	gdb-csl-sourcerygxx-4_1-12:1.59
	binutils-csl-sourcerygxx-4_1-12:1.60
	gdb-csl-sourcerygxx-3_4_4-21:1.59
	binutils-csl-sourcerygxx-3_4_4-21:1.60
	gdb_6_5-20060621-release:1.61
	binutils-csl-wrs-linux-3_4_4-24:1.53
	binutils-csl-wrs-linux-3_4_4-23:1.53
	gdb-csl-sourcerygxx-4_1-9:1.59
	binutils-csl-sourcerygxx-4_1-9:1.60
	gdb-csl-sourcerygxx-4_1-8:1.59
	binutils-csl-sourcerygxx-4_1-8:1.60
	gdb-csl-sourcerygxx-4_1-7:1.59
	binutils-csl-sourcerygxx-4_1-7:1.60
	gdb-csl-arm-2006q1-6:1.59
	binutils-csl-arm-2006q1-6:1.60
	gdb-csl-sourcerygxx-4_1-6:1.59
	binutils-csl-sourcerygxx-4_1-6:1.60
	binutils-csl-wrs-linux-3_4_4-22:1.53
	gdb-csl-symbian-6_4_50_20060226-10:1.59
	gdb-csl-symbian-6_4_50_20060226-9:1.59
	gdb-csl-symbian-6_4_50_20060226-8:1.59
	gdb-csl-coldfire-4_1-11:1.59
	binutils-csl-coldfire-4_1-11:1.60
	gdb-csl-sourcerygxx-3_4_4-19:1.59
	binutils-csl-sourcerygxx-3_4_4-19:1.60
	gdb-csl-coldfire-4_1-10:1.59
	gdb_6_5-branch:1.61.0.4
	gdb_6_5-2006-05-14-branchpoint:1.61
	binutils-csl-coldfire-4_1-10:1.60
	gdb-csl-sourcerygxx-4_1-5:1.59
	binutils-csl-sourcerygxx-4_1-5:1.60
	nickrob-async-20060513-branch:1.61.0.2
	nickrob-async-20060513-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-4:1.59
	binutils-csl-sourcerygxx-4_1-4:1.60
	msnyder-reverse-20060502-branch:1.60.0.10
	msnyder-reverse-20060502-branchpoint:1.60
	binutils-csl-wrs-linux-3_4_4-21:1.53
	gdb-csl-morpho-4_1-4:1.59
	binutils-csl-morpho-4_1-4:1.60
	gdb-csl-sourcerygxx-3_4_4-17:1.59
	binutils-csl-sourcerygxx-3_4_4-17:1.60
	binutils-csl-wrs-linux-3_4_4-20:1.53
	readline_5_1-import-branch:1.60.0.8
	readline_5_1-import-branchpoint:1.60
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.59
	binutils-2_17-branch:1.60.0.6
	binutils-2_17-branchpoint:1.60
	gdb-csl-symbian-20060226-branch:1.59.0.12
	gdb-csl-symbian-20060226-branchpoint:1.59
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.59
	msnyder-reverse-20060331-branch:1.60.0.4
	msnyder-reverse-20060331-branchpoint:1.60
	binutils-csl-2_17-branch:1.60.0.2
	binutils-csl-2_17-branchpoint:1.60
	gdb-csl-available-20060303-branch:1.59.0.10
	gdb-csl-available-20060303-branchpoint:1.59
	gdb-csl-20060226-branch:1.59.0.8
	gdb-csl-20060226-branchpoint:1.59
	gdb_6_4-20051202-release:1.59
	msnyder-fork-checkpoint-branch:1.59.0.6
	msnyder-fork-checkpoint-branchpoint:1.59
	gdb-csl-gxxpro-6_3-branch:1.59.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.59
	gdb_6_4-branch:1.59.0.2
	gdb_6_4-2005-11-01-branchpoint:1.59
	gdb-csl-arm-20051020-branch:1.58.0.2
	gdb-csl-arm-20051020-branchpoint:1.58
	binutils-csl-gxxpro-3_4-branch:1.53.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.53
	binutils-2_16_1:1.53
	msnyder-tracepoint-checkpoint-branch:1.57.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.57
	gdb-csl-arm-20050325-2005-q1b:1.53
	binutils-csl-arm-2005q1b:1.53
	binutils-2_16:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	binutils-csl-arm-2005q1a:1.53
	csl-arm-20050325-branch:1.53.0.6
	csl-arm-20050325-branchpoint:1.53
	binutils-csl-arm-2005q1-branch:1.53.0.4
	binutils-csl-arm-2005q1-branchpoint:1.53
	binutils-2_16-branch:1.53.0.2
	binutils-2_16-branchpoint:1.53
	csl-arm-2004-q3d:1.48
	gdb_6_3-20041109-release:1.47
	gdb_6_3-branch:1.47.0.4
	gdb_6_3-20041019-branchpoint:1.47
	csl-arm-2004-q3:1.47
	drow_intercu-merge-20040921:1.47
	drow_intercu-merge-20040915:1.47
	jimb-gdb_6_2-e500-branch:1.47.0.6
	jimb-gdb_6_2-e500-branchpoint:1.47
	gdb_6_2-20040730-release:1.47
	gdb_6_2-branch:1.47.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.47
	gdb_6_1_1-20040616-release:1.45
	binutils-2_15:1.45
	binutils-2_15-branchpoint:1.45
	csl-arm-2004-q1a:1.45
	csl-arm-2004-q1:1.45
	gdb_6_1-2004-04-05-release:1.45
	drow_intercu-merge-20040402:1.45
	drow_intercu-merge-20040327:1.45
	ezannoni_pie-20040323-branch:1.45.0.14
	ezannoni_pie-20040323-branchpoint:1.45
	cagney_tramp-20040321-mergepoint:1.45
	cagney_tramp-20040309-branch:1.45.0.12
	cagney_tramp-20040309-branchpoint:1.45
	gdb_6_1-branch:1.45.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.45
	drow_intercu-20040221-branch:1.45.0.8
	drow_intercu-20040221-branchpoint:1.45
	binutils-2_15-branch:1.45.0.6
	cagney_bfdfile-20040213-branch:1.45.0.4
	cagney_bfdfile-20040213-branchpoint:1.45
	drow-cplus-merge-20040208:1.45
	carlton_dictionary-20040126-merge:1.45
	cagney_bigcore-20040122-branch:1.45.0.2
	cagney_bigcore-20040122-branchpoint:1.45
	drow-cplus-merge-20040113:1.45
	csl-arm-2003-q4:1.45
	drow-cplus-merge-20031224:1.45
	drow-cplus-merge-20031220:1.45
	carlton_dictionary-20031215-merge:1.45
	drow-cplus-merge-20031214:1.45
	carlton-dictionary-20031111-merge:1.44
	gdb_6_0-2003-10-04-release:1.40
	kettenis_sparc-20030918-branch:1.41.0.6
	kettenis_sparc-20030918-branchpoint:1.41
	carlton_dictionary-20030917-merge:1.41
	ezannoni_pie-20030916-branchpoint:1.41
	ezannoni_pie-20030916-branch:1.41.0.4
	cagney_x86i386-20030821-branch:1.41.0.2
	cagney_x86i386-20030821-branchpoint:1.41
	carlton_dictionary-20030805-merge:1.41
	carlton_dictionary-20030627-merge:1.41
	gdb_6_0-branch:1.40.0.22
	gdb_6_0-2003-06-23-branchpoint:1.40
	jimb-ppc64-linux-20030613-branch:1.40.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.40
	binutils-2_14:1.40
	cagney_convert-20030606-branch:1.40.0.18
	cagney_convert-20030606-branchpoint:1.40
	cagney_writestrings-20030508-branch:1.40.0.16
	cagney_writestrings-20030508-branchpoint:1.40
	jimb-ppc64-linux-20030528-branch:1.40.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.40
	carlton_dictionary-20030523-merge:1.40
	cagney_fileio-20030521-branch:1.40.0.12
	cagney_fileio-20030521-branchpoint:1.40
	kettenis_i386newframe-20030517-mergepoint:1.40
	jimb-ppc64-linux-20030509-branch:1.40.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.40
	kettenis_i386newframe-20030504-mergepoint:1.40
	carlton_dictionary-20030430-merge:1.40
	binutils-2_14-branch:1.40.0.8
	binutils-2_14-branchpoint:1.40
	kettenis_i386newframe-20030419-branch:1.40.0.6
	kettenis_i386newframe-20030419-branchpoint:1.40
	carlton_dictionary-20030416-merge:1.40
	cagney_frameaddr-20030409-mergepoint:1.40
	kettenis_i386newframe-20030406-branch:1.40.0.4
	kettenis_i386newframe-20030406-branchpoint:1.40
	cagney_frameaddr-20030403-branchpoint:1.40
	cagney_frameaddr-20030403-branch:1.40.0.2
	cagney_framebase-20030330-mergepoint:1.39
	cagney_framebase-20030326-branch:1.39.0.14
	cagney_framebase-20030326-branchpoint:1.39
	cagney_lazyid-20030317-branch:1.39.0.12
	cagney_lazyid-20030317-branchpoint:1.39
	kettenis-i386newframe-20030316-mergepoint:1.39
	offbyone-20030313-branch:1.39.0.10
	offbyone-20030313-branchpoint:1.39
	kettenis-i386newframe-20030308-branch:1.39.0.8
	kettenis-i386newframe-20030308-branchpoint:1.39
	carlton_dictionary-20030305-merge:1.39
	cagney_offbyone-20030303-branch:1.39.0.6
	cagney_offbyone-20030303-branchpoint:1.39
	carlton_dictionary-20030207-merge:1.39
	interps-20030202-branch:1.39.0.4
	interps-20030202-branchpoint:1.39
	cagney-unwind-20030108-branch:1.39.0.2
	cagney-unwind-20030108-branchpoint:1.39
	binutils-2_13_2_1:1.30.2.3
	binutils-2_13_2:1.30.2.3
	carlton_dictionary-20021223-merge:1.38
	gdb_5_3-2002-12-12-release:1.35
	carlton_dictionary-20021115-merge:1.36
	binutils-2_13_1:1.30.2.2
	kseitz_interps-20021105-merge:1.36
	kseitz_interps-20021103-merge:1.36
	drow-cplus-merge-20021020:1.35
	drow-cplus-merge-20021025:1.35
	carlton_dictionary-20021025-merge:1.36
	carlton_dictionary-20021011-merge:1.35
	drow-cplus-branch:1.35.0.8
	drow-cplus-branchpoint:1.35
	kseitz_interps-20020930-merge:1.35
	carlton_dictionary-20020927-merge:1.35
	carlton_dictionary-branch:1.35.0.6
	carlton_dictionary-20020920-branchpoint:1.35
	sid-20020905-branchpoint:1.35
	sid-20020905-branch:1.35.0.4
	gdb_5_3-branch:1.35.0.2
	gdb_5_3-2002-09-04-branchpoint:1.35
	kseitz_interps-20020829-merge:1.34
	cagney_sysregs-20020825-branch:1.33.0.4
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.2
	readline_4_3-import-branchpoint:1.33
	binutils-2_13:1.30
	gdb_5_2_1-2002-07-23-release:1.27
	binutils-2_13-branchpoint:1.30
	binutils-2_13-branch:1.30.0.2
	kseitz_interps-20020528-branch:1.28.0.6
	kseitz_interps-20020528-branchpoint:1.28
	cagney_regbuf-20020515-branch:1.28.0.4
	cagney_regbuf-20020515-branchpoint:1.28
	binutils-2_12_1:1.27.2.1
	jimb-macro-020506-branch:1.28.0.2
	jimb-macro-020506-branchpoint:1.28
	gdb_5_2-2002-04-29-release:1.27
	binutils-2_12:1.27
	gdb_5_2-branch:1.27.0.4
	gdb_5_2-2002-03-03-branchpoint:1.27
	binutils-2_12-branch:1.27.0.2
	binutils-2_12-branchpoint:1.27
	gdb_5_1_1-2002-01-24-release:1.20
	gdb_5_1_0_1-2002-01-03-release:1.20
	cygnus_cvs_20020108_pre:1.27
	gdb_5_1_0_1-2002-01-03-branch:1.20.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.20
	gdb_5_1-2001-11-21-release:1.20
	gdb_s390-2001-09-26-branch:1.20.0.4
	gdb_s390-2001-09-26-branchpoint:1.20
	gdb_5_1-2001-07-29-branch:1.20.0.2
	gdb_5_1-2001-07-29-branchpoint:1.20
	binutils-2_11_2:1.15.2.2
	binutils-2_11_1:1.15.2.2
	binutils-2_11:1.15
	x86_64versiong3:1.16
	binutils-2_11-branch:1.15.0.2
	insight-precleanup-2001-01-01:1.14
	binutils-2_10_1:1.4.2.1
	binutils-2_10:1.4.2.1
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.5
	gdb_4_18_2-2000-05-18-release:1.5
	gdb_4_95_1-2000-05-11-snapshot:1.5
	gdb_4_95_0-2000-04-27-snapshot:1.5
	gdb_5_0-2000-04-10-branch:1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.5
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.88
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.88
date	2012.05.01.16.07.33;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2011.06.13.00.59.09;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2011.03.03.23.47.21;	author msnyder;	state Exp;
branches;
next	1.85;

1.85
date	2010.12.13.01.06.15;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2010.10.14.01.31.26;	author davek;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2010.08.25.07.02.40;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2010.07.22.14.07.10;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.09.14.40.15;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.11.13.42.00;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.14.05.54.28;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.02.07.18.35;	author amodra;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2009.07.02.17.08.51;	author tromey;	state Exp;
branches;
next	1.74;

1.74
date	2009.02.03.18.16.02;	author jsm28;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.28.18.02.16;	author ths;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.09.23.14.55;	author msnyder;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.01.19.58.40;	author msnyder;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.01.07.50.16;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.01.07.43.36;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.27.19.04.39;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2007.07.26.18.30.28;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.03.15.55.38;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.28.13.50.57;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2005.08.18.03.48.26;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.04.15.52.59;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.04.11.00.07;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.04.07.19.19;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.11.08.23.00;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.03.11.40.55;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.07.02.58.27;	author hp;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.07.02.51.28;	author hp;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.31.23.13.13;	author bje;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.09.06.08.44;	author ian;	state Exp;
branches;
next	1.48;

1.48
date	2004.10.21.15.28.15;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.27.15.08.05;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.24.04.46.14;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.24.18.06.39;	author kazu;	state Exp;
branches
	1.45.8.1;
next	1.44;

1.44
date	2003.11.04.10.41.50;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.16.04.11.04;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.30.16.17.11;	author cgd;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.25.06.40.17;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.31.18.13.24;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.31.07.29.25;	author cgd;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.10.16.15.27;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.30.08.39.34;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.25.02.45.53;	author danglin;	state Exp;
branches;
next	1.35;

1.35
date	2002.09.02.05.58.55;	author amodra;	state Exp;
branches
	1.35.6.1
	1.35.8.1;
next	1.34;

1.34
date	2002.08.26.08.46.21;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2002.08.08.00.11.37;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.31.12.50.06;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.25.06.21.47;	author amodra;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.28.03.27.42;	author amodra;	state Exp;
branches
	1.28.4.1
	1.28.6.1;
next	1.27;

1.27
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2001.09.21.02.12.28;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.19.05.33.11;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.18.09.57.21;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.31.21.24.28;	author echristo;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.14.10.01.29;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.13.07.58.05;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.23.17.26.35;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.08.21.03.56;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.27.18.45.45;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.23.20.27.53;	author kazu;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.12.02.01.10.31;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.02.00.52.54;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.01.21.35.35;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.28.21.42.15;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.20.19.05.12;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.07.19.11.31;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.20.16.21.06;	author hp;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.15.18.42.00;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.26.13.11.55;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.03.11.44.45;	author hp;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.07.12.10.28.24;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.19.49.23;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.84.2.1
date	2011.02.01.12.25.32;	author amodra;	state Exp;
branches;
next	1.84.2.2;

1.84.2.2
date	2011.05.29.04.50.55;	author amodra;	state Exp;
branches;
next	;

1.77.2.1
date	2009.09.09.21.40.17;	author nickc;	state Exp;
branches;
next	;

1.45.8.1
date	2004.09.16.17.00.11;	author drow;	state Exp;
branches;
next	;

1.35.6.1
date	2002.10.25.23.49.46;	author carlton;	state Exp;
branches;
next	1.35.6.2;

1.35.6.2
date	2002.12.23.19.37.21;	author carlton;	state Exp;
branches;
next	1.35.6.3;

1.35.6.3
date	2003.02.07.19.17.35;	author carlton;	state Exp;
branches;
next	1.35.6.4;

1.35.6.4
date	2003.04.16.19.56.40;	author carlton;	state Exp;
branches;
next	1.35.6.5;

1.35.6.5
date	2003.06.27.21.49.05;	author carlton;	state Exp;
branches;
next	1.35.6.6;

1.35.6.6
date	2003.11.11.23.50.06;	author carlton;	state Exp;
branches;
next	1.35.6.7;

1.35.6.7
date	2003.12.15.23.59.10;	author carlton;	state Exp;
branches;
next	;

1.35.8.1
date	2003.12.14.20.26.33;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2002.09.23.22.12.37;	author drow;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.10.28.18.45.42;	author drow;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2002.12.15.22.31.45;	author drow;	state Exp;
branches;
next	;

1.28.4.1
date	2002.06.15.16.42.34;	author cagney;	state Exp;
branches;
next	;

1.28.6.1
date	2002.06.20.01.29.33;	author kseitz;	state Exp;
branches;
next	1.28.6.2;

1.28.6.2
date	2002.07.22.21.46.38;	author kseitz;	state Exp;
branches;
next	1.28.6.3;

1.28.6.3
date	2002.08.09.18.34.09;	author kseitz;	state Exp;
branches;
next	1.28.6.4;

1.28.6.4
date	2002.08.30.22.52.34;	author kseitz;	state Exp;
branches;
next	1.28.6.5;

1.28.6.5
date	2002.10.01.00.45.41;	author kseitz;	state Exp;
branches;
next	1.28.6.6;

1.28.6.6
date	2002.11.03.22.01.33;	author ezannoni;	state Exp;
branches;
next	;

1.27.2.1
date	2002.04.04.14.52.53;	author amodra;	state Exp;
branches;
next	;

1.15.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.06.11.10.03.59;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2000.05.28.10.57.49;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.88
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@/* BFD semi-generic back-end for a.out binaries.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/*
SECTION
	a.out backends

DESCRIPTION

	BFD supports a number of different flavours of a.out format,
	though the major differences are only the sizes of the
	structures on disk, and the shape of the relocation
	information.

	The support is split into a basic support file @@file{aoutx.h}
	and other files which derive functions from the base. One
	derivation file is @@file{aoutf1.h} (for a.out flavour 1), and
	adds to the basic a.out functions support for sun3, sun4, 386
	and 29k a.out files, to create a target jump vector for a
	specific target.

	This information is further split out into more specific files
	for each machine, including @@file{sunos.c} for sun3 and sun4,
	@@file{newsos3.c} for the Sony NEWS, and @@file{demo64.c} for a
	demonstration of a 64 bit a.out format.

	The base file @@file{aoutx.h} defines general mechanisms for
	reading and writing records to and from disk and various
	other methods which BFD requires. It is included by
	@@file{aout32.c} and @@file{aout64.c} to form the names
	<<aout_32_swap_exec_header_in>>, <<aout_64_swap_exec_header_in>>, etc.

	As an example, this is what goes on to make the back end for a
	sun4, from @@file{aout32.c}:

|	#define ARCH_SIZE 32
|	#include "aoutx.h"

	Which exports names:

|	...
|	aout_32_canonicalize_reloc
|	aout_32_find_nearest_line
|	aout_32_get_lineno
|	aout_32_get_reloc_upper_bound
|	...

	from @@file{sunos.c}:

|	#define TARGET_NAME "a.out-sunos-big"
|	#define VECNAME    sunos_big_vec
|	#include "aoutf1.h"

	requires all the names from @@file{aout32.c}, and produces the jump vector

|	sunos_big_vec

	The file @@file{host-aout.c} is a special case.  It is for a large set
	of hosts that use ``more or less standard'' a.out files, and
	for which cross-debugging is not interesting.  It uses the
	standard 32-bit a.out support routines, but determines the
	file offsets and addresses of the text, data, and BSS
	sections, the machine architecture and machine type, and the
	entry point address, in a host-dependent manner.  Once these
	values have been determined, generic code is used to handle
	the  object file.

	When porting it to run on a new system, you must supply:

|        HOST_PAGE_SIZE
|        HOST_SEGMENT_SIZE
|        HOST_MACHINE_ARCH       (optional)
|        HOST_MACHINE_MACHINE    (optional)
|        HOST_TEXT_START_ADDR
|        HOST_STACK_END_ADDR

	in the file @@file{../include/sys/h-@@var{XXX}.h} (for your host).  These
	values, plus the structures and macros defined in @@file{a.out.h} on
	your host system, will produce a BFD target that will access
	ordinary a.out files on your host. To configure a new machine
	to use @@file{host-aout.c}, specify:

|	TDEFAULTS = -DDEFAULT_VECTOR=host_aout_big_vec
|	TDEPFILES= host-aout.o trad-core.o

	in the @@file{config/@@var{XXX}.mt} file, and modify @@file{configure.in}
	to use the
	@@file{@@var{XXX}.mt} file (by setting "<<bfd_target=XXX>>") when your
	configuration is selected.  */

/* Some assumptions:
   * Any BFD with D_PAGED set is ZMAGIC, and vice versa.
     Doesn't matter what the setting of WP_TEXT is on output, but it'll
     get set on input.
   * Any BFD with D_PAGED clear and WP_TEXT set is NMAGIC.
   * Any BFD with both flags clear is OMAGIC.
   (Just want to make these explicit, so the conditions tested in this
   file make sense if you're more familiar with a.out than with BFD.)  */

#define KEEPIT udata.i

#include "sysdep.h"
#include "bfd.h"
#include "safe-ctype.h"
#include "bfdlink.h"

#include "libaout.h"
#include "libbfd.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"
#include "aout/ar.h"

/*
SUBSECTION
	Relocations

DESCRIPTION
	The file @@file{aoutx.h} provides for both the @@emph{standard}
	and @@emph{extended} forms of a.out relocation records.

	The standard records contain only an
	address, a symbol index, and a type field. The extended records
	(used on 29ks and sparcs) also have a full integer for an
	addend.  */

#ifndef CTOR_TABLE_RELOC_HOWTO
#define CTOR_TABLE_RELOC_IDX 2
#define CTOR_TABLE_RELOC_HOWTO(BFD)					\
  ((obj_reloc_entry_size (BFD) == RELOC_EXT_SIZE			\
    ? howto_table_ext : howto_table_std)				\
   + CTOR_TABLE_RELOC_IDX)
#endif

#ifndef MY_swap_std_reloc_in
#define MY_swap_std_reloc_in NAME (aout, swap_std_reloc_in)
#endif

#ifndef MY_swap_ext_reloc_in
#define MY_swap_ext_reloc_in NAME (aout, swap_ext_reloc_in)
#endif

#ifndef MY_swap_std_reloc_out
#define MY_swap_std_reloc_out NAME (aout, swap_std_reloc_out)
#endif

#ifndef MY_swap_ext_reloc_out
#define MY_swap_ext_reloc_out NAME (aout, swap_ext_reloc_out)
#endif

#ifndef MY_final_link_relocate
#define MY_final_link_relocate _bfd_final_link_relocate
#endif

#ifndef MY_relocate_contents
#define MY_relocate_contents _bfd_relocate_contents
#endif

#define howto_table_ext NAME (aout, ext_howto_table)
#define howto_table_std NAME (aout, std_howto_table)

reloc_howto_type howto_table_ext[] =
{
  /*     Type         rs   size bsz  pcrel bitpos ovrf                  sf name          part_inpl readmask setmask pcdone.  */
  HOWTO (RELOC_8,       0,  0,  8,  FALSE, 0, complain_overflow_bitfield, 0, "8",           FALSE, 0, 0x000000ff, FALSE),
  HOWTO (RELOC_16,      0,  1, 	16, FALSE, 0, complain_overflow_bitfield, 0, "16",          FALSE, 0, 0x0000ffff, FALSE),
  HOWTO (RELOC_32,      0,  2, 	32, FALSE, 0, complain_overflow_bitfield, 0, "32",          FALSE, 0, 0xffffffff, FALSE),
  HOWTO (RELOC_DISP8,   0,  0, 	8,  TRUE,  0, complain_overflow_signed,   0, "DISP8", 	    FALSE, 0, 0x000000ff, FALSE),
  HOWTO (RELOC_DISP16,  0,  1, 	16, TRUE,  0, complain_overflow_signed,   0, "DISP16", 	    FALSE, 0, 0x0000ffff, FALSE),
  HOWTO (RELOC_DISP32,  0,  2, 	32, TRUE,  0, complain_overflow_signed,   0, "DISP32", 	    FALSE, 0, 0xffffffff, FALSE),
  HOWTO (RELOC_WDISP30, 2,  2, 	30, TRUE,  0, complain_overflow_signed,   0, "WDISP30",     FALSE, 0, 0x3fffffff, FALSE),
  HOWTO (RELOC_WDISP22, 2,  2, 	22, TRUE,  0, complain_overflow_signed,   0, "WDISP22",     FALSE, 0, 0x003fffff, FALSE),
  HOWTO (RELOC_HI22,   10,  2, 	22, FALSE, 0, complain_overflow_bitfield, 0, "HI22",	    FALSE, 0, 0x003fffff, FALSE),
  HOWTO (RELOC_22,      0,  2, 	22, FALSE, 0, complain_overflow_bitfield, 0, "22",          FALSE, 0, 0x003fffff, FALSE),
  HOWTO (RELOC_13,      0,  2, 	13, FALSE, 0, complain_overflow_bitfield, 0, "13",          FALSE, 0, 0x00001fff, FALSE),
  HOWTO (RELOC_LO10,    0,  2, 	10, FALSE, 0, complain_overflow_dont,     0, "LO10",        FALSE, 0, 0x000003ff, FALSE),
  HOWTO (RELOC_SFA_BASE,0,  2, 	32, FALSE, 0, complain_overflow_bitfield, 0, "SFA_BASE",    FALSE, 0, 0xffffffff, FALSE),
  HOWTO (RELOC_SFA_OFF13,0, 2, 	32, FALSE, 0, complain_overflow_bitfield, 0, "SFA_OFF13",   FALSE, 0, 0xffffffff, FALSE),
  HOWTO (RELOC_BASE10,  0,  2, 	10, FALSE, 0, complain_overflow_dont,     0, "BASE10",      FALSE, 0, 0x000003ff, FALSE),
  HOWTO (RELOC_BASE13,  0,  2,	13, FALSE, 0, complain_overflow_signed,   0, "BASE13",      FALSE, 0, 0x00001fff, FALSE),
  HOWTO (RELOC_BASE22, 10,  2,	22, FALSE, 0, complain_overflow_bitfield, 0, "BASE22",      FALSE, 0, 0x003fffff, FALSE),
  HOWTO (RELOC_PC10,    0,  2,	10, TRUE,  0, complain_overflow_dont,     0, "PC10",	    FALSE, 0, 0x000003ff, TRUE),
  HOWTO (RELOC_PC22,   10,  2,	22, TRUE,  0, complain_overflow_signed,   0, "PC22",  	    FALSE, 0, 0x003fffff, TRUE),
  HOWTO (RELOC_JMP_TBL, 2,  2, 	30, TRUE,  0, complain_overflow_signed,   0, "JMP_TBL",     FALSE, 0, 0x3fffffff, FALSE),
  HOWTO (RELOC_SEGOFF16,0,  2,	0,  FALSE, 0, complain_overflow_bitfield, 0, "SEGOFF16",    FALSE, 0, 0x00000000, FALSE),
  HOWTO (RELOC_GLOB_DAT,0,  2,	0,  FALSE, 0, complain_overflow_bitfield, 0, "GLOB_DAT",    FALSE, 0, 0x00000000, FALSE),
  HOWTO (RELOC_JMP_SLOT,0,  2,	0,  FALSE, 0, complain_overflow_bitfield, 0, "JMP_SLOT",    FALSE, 0, 0x00000000, FALSE),
  HOWTO (RELOC_RELATIVE,0,  2,	0,  FALSE, 0, complain_overflow_bitfield, 0, "RELATIVE",    FALSE, 0, 0x00000000, FALSE),
  HOWTO (0,             0,  0,  0,  FALSE, 0, complain_overflow_dont,     0, "R_SPARC_NONE",FALSE, 0, 0x00000000, TRUE),
  HOWTO (0,             0,  0,  0,  FALSE, 0, complain_overflow_dont,     0, "R_SPARC_NONE",FALSE, 0, 0x00000000, TRUE),
#define RELOC_SPARC_REV32 RELOC_WDISP19
  HOWTO (RELOC_SPARC_REV32, 0, 2, 32, FALSE, 0, complain_overflow_dont,   0,"R_SPARC_REV32",FALSE, 0, 0xffffffff, FALSE),
};

/* Convert standard reloc records to "arelent" format (incl byte swap).  */

reloc_howto_type howto_table_std[] =
{
  /* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone.  */
HOWTO ( 0,	       0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",		TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 1,	       0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 2,	       0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 3,	       0,  4, 	64, FALSE, 0, complain_overflow_bitfield,0,"64",	TRUE, 0xdeaddead,0xdeaddead, FALSE),
HOWTO ( 4,	       0,  0, 	8,  TRUE,  0, complain_overflow_signed,  0,"DISP8",	TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 5,	       0,  1, 	16, TRUE,  0, complain_overflow_signed,  0,"DISP16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 6,	       0,  2, 	32, TRUE,  0, complain_overflow_signed,  0,"DISP32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 7,	       0,  4, 	64, TRUE,  0, complain_overflow_signed,  0,"DISP64",	TRUE, 0xfeedface,0xfeedface, FALSE),
HOWTO ( 8,	       0,  2,    0, FALSE, 0, complain_overflow_bitfield,0,"GOT_REL",	FALSE,         0,0x00000000, FALSE),
HOWTO ( 9,	       0,  1,   16, FALSE, 0, complain_overflow_bitfield,0,"BASE16",	FALSE,0xffffffff,0xffffffff, FALSE),
HOWTO (10,	       0,  2,   32, FALSE, 0, complain_overflow_bitfield,0,"BASE32",	FALSE,0xffffffff,0xffffffff, FALSE),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
  HOWTO (16,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"JMP_TABLE", FALSE,         0,0x00000000, FALSE),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
  HOWTO (32,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",  FALSE,         0,0x00000000, FALSE),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
EMPTY_HOWTO (-1),
  HOWTO (40,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"BASEREL",   FALSE,         0,0x00000000, FALSE),
};

#define TABLE_SIZE(TABLE)	(sizeof (TABLE) / sizeof (TABLE[0]))

reloc_howto_type *
NAME (aout, reloc_type_lookup) (bfd *abfd, bfd_reloc_code_real_type code)
{
#define EXT(i, j)	case i: return & howto_table_ext [j]
#define STD(i, j)	case i: return & howto_table_std [j]
  int ext = obj_reloc_entry_size (abfd) == RELOC_EXT_SIZE;

  if (code == BFD_RELOC_CTOR)
    switch (bfd_arch_bits_per_address (abfd))
      {
      case 32:
	code = BFD_RELOC_32;
	break;
      case 64:
	code = BFD_RELOC_64;
	break;
      }

  if (ext)
    switch (code)
      {
	EXT (BFD_RELOC_8, 0);
	EXT (BFD_RELOC_16, 1);
	EXT (BFD_RELOC_32, 2);
	EXT (BFD_RELOC_HI22, 8);
	EXT (BFD_RELOC_LO10, 11);
	EXT (BFD_RELOC_32_PCREL_S2, 6);
	EXT (BFD_RELOC_SPARC_WDISP22, 7);
	EXT (BFD_RELOC_SPARC13, 10);
	EXT (BFD_RELOC_SPARC_GOT10, 14);
	EXT (BFD_RELOC_SPARC_BASE13, 15);
	EXT (BFD_RELOC_SPARC_GOT13, 15);
	EXT (BFD_RELOC_SPARC_GOT22, 16);
	EXT (BFD_RELOC_SPARC_PC10, 17);
	EXT (BFD_RELOC_SPARC_PC22, 18);
	EXT (BFD_RELOC_SPARC_WPLT30, 19);
	EXT (BFD_RELOC_SPARC_REV32, 26);
      default:
	return NULL;
      }
  else
    /* std relocs.  */
    switch (code)
      {
	STD (BFD_RELOC_8, 0);
	STD (BFD_RELOC_16, 1);
	STD (BFD_RELOC_32, 2);
	STD (BFD_RELOC_8_PCREL, 4);
	STD (BFD_RELOC_16_PCREL, 5);
	STD (BFD_RELOC_32_PCREL, 6);
	STD (BFD_RELOC_16_BASEREL, 9);
	STD (BFD_RELOC_32_BASEREL, 10);
      default:
	return NULL;
      }
}

reloc_howto_type *
NAME (aout, reloc_name_lookup) (bfd *abfd, const char *r_name)
{
  unsigned int i, size;
  reloc_howto_type *howto_table;

  if (obj_reloc_entry_size (abfd) == RELOC_EXT_SIZE)
    {
      howto_table = howto_table_ext;
      size = sizeof (howto_table_ext) / sizeof (howto_table_ext[0]);
    }
  else
    {
      howto_table = howto_table_std;
      size = sizeof (howto_table_std) / sizeof (howto_table_std[0]);
    }

  for (i = 0; i < size; i++)
    if (howto_table[i].name != NULL
	&& strcasecmp (howto_table[i].name, r_name) == 0)
      return &howto_table[i];

  return NULL;
}

/*
SUBSECTION
	Internal entry points

DESCRIPTION
	@@file{aoutx.h} exports several routines for accessing the
	contents of an a.out file, which are gathered and exported in
	turn by various format specific files (eg sunos.c).
*/

/*
FUNCTION
	 aout_@@var{size}_swap_exec_header_in

SYNOPSIS
	void aout_@@var{size}_swap_exec_header_in,
           (bfd *abfd,
            struct external_exec *bytes,
            struct internal_exec *execp);

DESCRIPTION
	Swap the information in an executable header @@var{raw_bytes} taken
	from a raw byte stream memory image into the internal exec header
	structure @@var{execp}.
*/

#ifndef NAME_swap_exec_header_in
void
NAME (aout, swap_exec_header_in) (bfd *abfd,
				  struct external_exec *bytes,
				  struct internal_exec *execp)
{
  /* The internal_exec structure has some fields that are unused in this
     configuration (IE for i960), so ensure that all such uninitialized
     fields are zero'd out.  There are places where two of these structs
     are memcmp'd, and thus the contents do matter.  */
  memset ((void *) execp, 0, sizeof (struct internal_exec));
  /* Now fill in fields in the execp, from the bytes in the raw data.  */
  execp->a_info   = H_GET_32 (abfd, bytes->e_info);
  execp->a_text   = GET_WORD (abfd, bytes->e_text);
  execp->a_data   = GET_WORD (abfd, bytes->e_data);
  execp->a_bss    = GET_WORD (abfd, bytes->e_bss);
  execp->a_syms   = GET_WORD (abfd, bytes->e_syms);
  execp->a_entry  = GET_WORD (abfd, bytes->e_entry);
  execp->a_trsize = GET_WORD (abfd, bytes->e_trsize);
  execp->a_drsize = GET_WORD (abfd, bytes->e_drsize);
}
#define NAME_swap_exec_header_in NAME (aout, swap_exec_header_in)
#endif

/*
FUNCTION
	aout_@@var{size}_swap_exec_header_out

SYNOPSIS
	void aout_@@var{size}_swap_exec_header_out
	  (bfd *abfd,
	   struct internal_exec *execp,
	   struct external_exec *raw_bytes);

DESCRIPTION
	Swap the information in an internal exec header structure
	@@var{execp} into the buffer @@var{raw_bytes} ready for writing to disk.
*/
void
NAME (aout, swap_exec_header_out) (bfd *abfd,
				   struct internal_exec *execp,
				   struct external_exec *bytes)
{
  /* Now fill in fields in the raw data, from the fields in the exec struct.  */
  H_PUT_32 (abfd, execp->a_info  , bytes->e_info);
  PUT_WORD (abfd, execp->a_text  , bytes->e_text);
  PUT_WORD (abfd, execp->a_data  , bytes->e_data);
  PUT_WORD (abfd, execp->a_bss   , bytes->e_bss);
  PUT_WORD (abfd, execp->a_syms  , bytes->e_syms);
  PUT_WORD (abfd, execp->a_entry , bytes->e_entry);
  PUT_WORD (abfd, execp->a_trsize, bytes->e_trsize);
  PUT_WORD (abfd, execp->a_drsize, bytes->e_drsize);
}

/* Make all the section for an a.out file.  */

bfd_boolean
NAME (aout, make_sections) (bfd *abfd)
{
  if (obj_textsec (abfd) == NULL && bfd_make_section (abfd, ".text") == NULL)
    return FALSE;
  if (obj_datasec (abfd) == NULL && bfd_make_section (abfd, ".data") == NULL)
    return FALSE;
  if (obj_bsssec (abfd) == NULL && bfd_make_section (abfd, ".bss") == NULL)
    return FALSE;
  return TRUE;
}

/*
FUNCTION
	aout_@@var{size}_some_aout_object_p

SYNOPSIS
	const bfd_target *aout_@@var{size}_some_aout_object_p
	 (bfd *abfd,
          struct internal_exec *execp,
	  const bfd_target *(*callback_to_real_object_p) (bfd *));

DESCRIPTION
	Some a.out variant thinks that the file open in @@var{abfd}
	checking is an a.out file.  Do some more checking, and set up
	for access if it really is.  Call back to the calling
	environment's "finish up" function just before returning, to
	handle any last-minute setup.
*/

const bfd_target *
NAME (aout, some_aout_object_p) (bfd *abfd,
				 struct internal_exec *execp,
				 const bfd_target *(*callback_to_real_object_p) (bfd *))
{
  struct aout_data_struct *rawptr, *oldrawptr;
  const bfd_target *result;
  bfd_size_type amt = sizeof (* rawptr);

  rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);
  if (rawptr == NULL)
    return NULL;

  oldrawptr = abfd->tdata.aout_data;
  abfd->tdata.aout_data = rawptr;

  /* Copy the contents of the old tdata struct.
     In particular, we want the subformat, since for hpux it was set in
     hp300hpux.c:swap_exec_header_in and will be used in
     hp300hpux.c:callback.  */
  if (oldrawptr != NULL)
    *abfd->tdata.aout_data = *oldrawptr;

  abfd->tdata.aout_data->a.hdr = &rawptr->e;
  /* Copy in the internal_exec struct.  */
  *(abfd->tdata.aout_data->a.hdr) = *execp;
  execp = abfd->tdata.aout_data->a.hdr;

  /* Set the file flags.  */
  abfd->flags = BFD_NO_FLAGS;
  if (execp->a_drsize || execp->a_trsize)
    abfd->flags |= HAS_RELOC;
  /* Setting of EXEC_P has been deferred to the bottom of this function.  */
  if (execp->a_syms)
    abfd->flags |= HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS;
  if (N_DYNAMIC (*execp))
    abfd->flags |= DYNAMIC;

  if (N_MAGIC (*execp) == ZMAGIC)
    {
      abfd->flags |= D_PAGED | WP_TEXT;
      adata (abfd).magic = z_magic;
    }
  else if (N_MAGIC (*execp) == QMAGIC)
    {
      abfd->flags |= D_PAGED | WP_TEXT;
      adata (abfd).magic = z_magic;
      adata (abfd).subformat = q_magic_format;
    }
  else if (N_MAGIC (*execp) == NMAGIC)
    {
      abfd->flags |= WP_TEXT;
      adata (abfd).magic = n_magic;
    }
  else if (N_MAGIC (*execp) == OMAGIC
	   || N_MAGIC (*execp) == BMAGIC)
    adata (abfd).magic = o_magic;
  else
    /* Should have been checked with N_BADMAG before this routine
       was called.  */
    abort ();

  bfd_get_start_address (abfd) = execp->a_entry;

  obj_aout_symbols (abfd) = NULL;
  bfd_get_symcount (abfd) = execp->a_syms / sizeof (struct external_nlist);

  /* The default relocation entry size is that of traditional V7 Unix.  */
  obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;

  /* The default symbol entry size is that of traditional Unix.  */
  obj_symbol_entry_size (abfd) = EXTERNAL_NLIST_SIZE;

#ifdef USE_MMAP
  bfd_init_window (&obj_aout_sym_window (abfd));
  bfd_init_window (&obj_aout_string_window (abfd));
#endif
  obj_aout_external_syms (abfd) = NULL;
  obj_aout_external_strings (abfd) = NULL;
  obj_aout_sym_hashes (abfd) = NULL;

  if (! NAME (aout, make_sections) (abfd))
    goto error_ret;

  obj_datasec (abfd)->size = execp->a_data;
  obj_bsssec (abfd)->size = execp->a_bss;

  obj_textsec (abfd)->flags =
    (execp->a_trsize != 0
     ? (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS | SEC_RELOC)
     : (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS));
  obj_datasec (abfd)->flags =
    (execp->a_drsize != 0
     ? (SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_HAS_CONTENTS | SEC_RELOC)
     : (SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_HAS_CONTENTS));
  obj_bsssec (abfd)->flags = SEC_ALLOC;

#ifdef THIS_IS_ONLY_DOCUMENTATION
  /* The common code can't fill in these things because they depend
     on either the start address of the text segment, the rounding
     up of virtual addresses between segments, or the starting file
     position of the text segment -- all of which varies among different
     versions of a.out.  */

  /* Call back to the format-dependent code to fill in the rest of the
     fields and do any further cleanup.  Things that should be filled
     in by the callback:  */

  struct exec *execp = exec_hdr (abfd);

  obj_textsec (abfd)->size = N_TXTSIZE (*execp);
  /* Data and bss are already filled in since they're so standard.  */

  /* The virtual memory addresses of the sections.  */
  obj_textsec (abfd)->vma = N_TXTADDR (*execp);
  obj_datasec (abfd)->vma = N_DATADDR (*execp);
  obj_bsssec  (abfd)->vma = N_BSSADDR (*execp);

  /* The file offsets of the sections.  */
  obj_textsec (abfd)->filepos = N_TXTOFF (*execp);
  obj_datasec (abfd)->filepos = N_DATOFF (*execp);

  /* The file offsets of the relocation info.  */
  obj_textsec (abfd)->rel_filepos = N_TRELOFF (*execp);
  obj_datasec (abfd)->rel_filepos = N_DRELOFF (*execp);

  /* The file offsets of the string table and symbol table.  */
  obj_str_filepos (abfd) = N_STROFF (*execp);
  obj_sym_filepos (abfd) = N_SYMOFF (*execp);

  /* Determine the architecture and machine type of the object file.  */
  switch (N_MACHTYPE (*exec_hdr (abfd)))
    {
    default:
      abfd->obj_arch = bfd_arch_obscure;
      break;
    }

  adata (abfd)->page_size = TARGET_PAGE_SIZE;
  adata (abfd)->segment_size = SEGMENT_SIZE;
  adata (abfd)->exec_bytes_size = EXEC_BYTES_SIZE;

  return abfd->xvec;

  /* The architecture is encoded in various ways in various a.out variants,
     or is not encoded at all in some of them.  The relocation size depends
     on the architecture and the a.out variant.  Finally, the return value
     is the bfd_target vector in use.  If an error occurs, return zero and
     set bfd_error to the appropriate error code.

     Formats such as b.out, which have additional fields in the a.out
     header, should cope with them in this callback as well.  */
#endif				/* DOCUMENTATION */

  result = (*callback_to_real_object_p) (abfd);

  /* Now that the segment addresses have been worked out, take a better
     guess at whether the file is executable.  If the entry point
     is within the text segment, assume it is.  (This makes files
     executable even if their entry point address is 0, as long as
     their text starts at zero.).

     This test had to be changed to deal with systems where the text segment
     runs at a different location than the default.  The problem is that the
     entry address can appear to be outside the text segment, thus causing an
     erroneous conclusion that the file isn't executable.

     To fix this, we now accept any non-zero entry point as an indication of
     executability.  This will work most of the time, since only the linker
     sets the entry point, and that is likely to be non-zero for most systems.  */

  if (execp->a_entry != 0
      || (execp->a_entry >= obj_textsec (abfd)->vma
	  && execp->a_entry < (obj_textsec (abfd)->vma
			       + obj_textsec (abfd)->size)
	  && execp->a_trsize == 0
	  && execp->a_drsize == 0))
    abfd->flags |= EXEC_P;
#ifdef STAT_FOR_EXEC
  else
    {
      struct stat stat_buf;

      /* The original heuristic doesn't work in some important cases.
        The a.out file has no information about the text start
        address.  For files (like kernels) linked to non-standard
        addresses (ld -Ttext nnn) the entry point may not be between
        the default text start (obj_textsec(abfd)->vma) and
        (obj_textsec(abfd)->vma) + text size.  This is not just a mach
        issue.  Many kernels are loaded at non standard addresses.  */
      if (abfd->iostream != NULL
	  && (abfd->flags & BFD_IN_MEMORY) == 0
	  && (fstat (fileno ((FILE *) (abfd->iostream)), &stat_buf) == 0)
	  && ((stat_buf.st_mode & 0111) != 0))
	abfd->flags |= EXEC_P;
    }
#endif /* STAT_FOR_EXEC */

  if (result)
    return result;

 error_ret:
  bfd_release (abfd, rawptr);
  abfd->tdata.aout_data = oldrawptr;
  return NULL;
}

/*
FUNCTION
	aout_@@var{size}_mkobject

SYNOPSIS
	bfd_boolean aout_@@var{size}_mkobject, (bfd *abfd);

DESCRIPTION
	Initialize BFD @@var{abfd} for use with a.out files.
*/

bfd_boolean
NAME (aout, mkobject) (bfd *abfd)
{
  struct aout_data_struct *rawptr;
  bfd_size_type amt = sizeof (* rawptr);

  bfd_set_error (bfd_error_system_call);

  rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);
  if (rawptr == NULL)
    return FALSE;

  abfd->tdata.aout_data = rawptr;
  exec_hdr (abfd) = &(rawptr->e);

  obj_textsec (abfd) = NULL;
  obj_datasec (abfd) = NULL;
  obj_bsssec (abfd) = NULL;

  return TRUE;
}

/*
FUNCTION
	aout_@@var{size}_machine_type

SYNOPSIS
	enum machine_type  aout_@@var{size}_machine_type
	 (enum bfd_architecture arch,
	  unsigned long machine,
          bfd_boolean *unknown);

DESCRIPTION
	Keep track of machine architecture and machine type for
	a.out's. Return the <<machine_type>> for a particular
	architecture and machine, or <<M_UNKNOWN>> if that exact architecture
	and machine can't be represented in a.out format.

	If the architecture is understood, machine type 0 (default)
	is always understood.
*/

enum machine_type
NAME (aout, machine_type) (enum bfd_architecture arch,
			   unsigned long machine,
			   bfd_boolean *unknown)
{
  enum machine_type arch_flags;

  arch_flags = M_UNKNOWN;
  *unknown = TRUE;

  switch (arch)
    {
    case bfd_arch_sparc:
      if (machine == 0
	  || machine == bfd_mach_sparc
	  || machine == bfd_mach_sparc_sparclite
	  || machine == bfd_mach_sparc_sparclite_le
	  || machine == bfd_mach_sparc_v8plus
	  || machine == bfd_mach_sparc_v8plusa
	  || machine == bfd_mach_sparc_v8plusb
	  || machine == bfd_mach_sparc_v9
	  || machine == bfd_mach_sparc_v9a
	  || machine == bfd_mach_sparc_v9b)
	arch_flags = M_SPARC;
      else if (machine == bfd_mach_sparc_sparclet)
	arch_flags = M_SPARCLET;
      break;

    case bfd_arch_m68k:
      switch (machine)
	{
	case 0:		      arch_flags = M_68010; break;
	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = FALSE; break;
	case bfd_mach_m68010: arch_flags = M_68010; break;
	case bfd_mach_m68020: arch_flags = M_68020; break;
	default:	      arch_flags = M_UNKNOWN; break;
	}
      break;

    case bfd_arch_i386:
      if (machine == 0
	  || machine == bfd_mach_i386_i386
	  || machine == bfd_mach_i386_i386_intel_syntax)
	arch_flags = M_386;
      break;

    case bfd_arch_arm:
      if (machine == 0)
	arch_flags = M_ARM;
      break;

    case bfd_arch_mips:
      switch (machine)
	{
	case 0:
	case bfd_mach_mips3000:
	case bfd_mach_mips3900:
	  arch_flags = M_MIPS1;
	  break;
	case bfd_mach_mips6000:
	  arch_flags = M_MIPS2;
	  break;
	case bfd_mach_mips4000:
	case bfd_mach_mips4010:
	case bfd_mach_mips4100:
	case bfd_mach_mips4300:
	case bfd_mach_mips4400:
	case bfd_mach_mips4600:
	case bfd_mach_mips4650:
	case bfd_mach_mips8000:
	case bfd_mach_mips9000:
	case bfd_mach_mips10000:
	case bfd_mach_mips12000:
	case bfd_mach_mips14000:
	case bfd_mach_mips16000:
	case bfd_mach_mips16:
	case bfd_mach_mipsisa32:
	case bfd_mach_mipsisa32r2:
	case bfd_mach_mips5:
	case bfd_mach_mipsisa64:
	case bfd_mach_mipsisa64r2:
	case bfd_mach_mips_sb1:
	case bfd_mach_mips_xlr:
	  /* FIXME: These should be MIPS3, MIPS4, MIPS16, MIPS32, etc.  */
	  arch_flags = M_MIPS2;
	  break;
	default:
	  arch_flags = M_UNKNOWN;
	  break;
	}
      break;

    case bfd_arch_ns32k:
      switch (machine)
	{
	case 0:    	arch_flags = M_NS32532; break;
	case 32032:	arch_flags = M_NS32032; break;
	case 32532:	arch_flags = M_NS32532; break;
	default:	arch_flags = M_UNKNOWN; break;
	}
      break;

    case bfd_arch_vax:
      *unknown = FALSE;
      break;

    case bfd_arch_cris:
      if (machine == 0 || machine == 255)
	arch_flags = M_CRIS;
      break;

    case bfd_arch_m88k:
      *unknown = FALSE;
      break;

    default:
      arch_flags = M_UNKNOWN;
    }

  if (arch_flags != M_UNKNOWN)
    *unknown = FALSE;

  return arch_flags;
}

/*
FUNCTION
	aout_@@var{size}_set_arch_mach

SYNOPSIS
	bfd_boolean aout_@@var{size}_set_arch_mach,
	 (bfd *,
	  enum bfd_architecture arch,
	  unsigned long machine);

DESCRIPTION
	Set the architecture and the machine of the BFD @@var{abfd} to the
	values @@var{arch} and @@var{machine}.  Verify that @@var{abfd}'s format
	can support the architecture required.
*/

bfd_boolean
NAME (aout, set_arch_mach) (bfd *abfd,
			    enum bfd_architecture arch,
			    unsigned long machine)
{
  if (! bfd_default_set_arch_mach (abfd, arch, machine))
    return FALSE;

  if (arch != bfd_arch_unknown)
    {
      bfd_boolean unknown;

      NAME (aout, machine_type) (arch, machine, &unknown);
      if (unknown)
	return FALSE;
    }

  /* Determine the size of a relocation entry.  */
  switch (arch)
    {
    case bfd_arch_sparc:
    case bfd_arch_mips:
      obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
      break;
    default:
      obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
      break;
    }

  return (*aout_backend_info (abfd)->set_sizes) (abfd);
}

static void
adjust_o_magic (bfd *abfd, struct internal_exec *execp)
{
  file_ptr pos = adata (abfd).exec_bytes_size;
  bfd_vma vma = 0;
  int pad = 0;

  /* Text.  */
  obj_textsec (abfd)->filepos = pos;
  if (!obj_textsec (abfd)->user_set_vma)
    obj_textsec (abfd)->vma = vma;
  else
    vma = obj_textsec (abfd)->vma;

  pos += obj_textsec (abfd)->size;
  vma += obj_textsec (abfd)->size;

  /* Data.  */
  if (!obj_datasec (abfd)->user_set_vma)
    {
      obj_textsec (abfd)->size += pad;
      pos += pad;
      vma += pad;
      obj_datasec (abfd)->vma = vma;
    }
  else
    vma = obj_datasec (abfd)->vma;
  obj_datasec (abfd)->filepos = pos;
  pos += obj_datasec (abfd)->size;
  vma += obj_datasec (abfd)->size;

  /* BSS.  */
  if (!obj_bsssec (abfd)->user_set_vma)
    {
      obj_datasec (abfd)->size += pad;
      pos += pad;
      vma += pad;
      obj_bsssec (abfd)->vma = vma;
    }
  else
    {
      /* The VMA of the .bss section is set by the VMA of the
         .data section plus the size of the .data section.  We may
         need to add padding bytes to make this true.  */
      pad = obj_bsssec (abfd)->vma - vma;
      if (pad > 0)
	{
	  obj_datasec (abfd)->size += pad;
	  pos += pad;
	}
    }
  obj_bsssec (abfd)->filepos = pos;

  /* Fix up the exec header.  */
  execp->a_text = obj_textsec (abfd)->size;
  execp->a_data = obj_datasec (abfd)->size;
  execp->a_bss = obj_bsssec (abfd)->size;
  N_SET_MAGIC (*execp, OMAGIC);
}

static void
adjust_z_magic (bfd *abfd, struct internal_exec *execp)
{
  bfd_size_type data_pad, text_pad;
  file_ptr text_end;
  const struct aout_backend_data *abdp;
  /* TRUE if text includes exec header.  */
  bfd_boolean ztih;

  abdp = aout_backend_info (abfd);

  /* Text.  */
  ztih = (abdp != NULL
	  && (abdp->text_includes_header
	      || obj_aout_subformat (abfd) == q_magic_format));
  obj_textsec (abfd)->filepos = (ztih
				 ? adata (abfd).exec_bytes_size
				 : adata (abfd).zmagic_disk_block_size);
  if (! obj_textsec (abfd)->user_set_vma)
    {
      /* ?? Do we really need to check for relocs here?  */
      obj_textsec (abfd)->vma = ((abfd->flags & HAS_RELOC)
				 ? 0
				 : (ztih
				    ? (abdp->default_text_vma
				       + adata (abfd).exec_bytes_size)
				    : abdp->default_text_vma));
      text_pad = 0;
    }
  else
    {
      /* The .text section is being loaded at an unusual address.  We
         may need to pad it such that the .data section starts at a page
         boundary.  */
      if (ztih)
	text_pad = ((obj_textsec (abfd)->filepos - obj_textsec (abfd)->vma)
		    & (adata (abfd).page_size - 1));
      else
	text_pad = ((- obj_textsec (abfd)->vma)
		    & (adata (abfd).page_size - 1));
    }

  /* Find start of data.  */
  if (ztih)
    {
      text_end = obj_textsec (abfd)->filepos + obj_textsec (abfd)->size;
      text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;
    }
  else
    {
      /* Note that if page_size == zmagic_disk_block_size, then
	 filepos == page_size, and this case is the same as the ztih
	 case.  */
      text_end = obj_textsec (abfd)->size;
      text_pad += BFD_ALIGN (text_end, adata (abfd).page_size) - text_end;
      text_end += obj_textsec (abfd)->filepos;
    }
  obj_textsec (abfd)->size += text_pad;
  text_end += text_pad;

  /* Data.  */
  if (!obj_datasec (abfd)->user_set_vma)
    {
      bfd_vma vma;
      vma = obj_textsec (abfd)->vma + obj_textsec (abfd)->size;
      obj_datasec (abfd)->vma = BFD_ALIGN (vma, adata (abfd).segment_size);
    }
  if (abdp && abdp->zmagic_mapped_contiguous)
    {
      asection * text = obj_textsec (abfd);
      asection * data = obj_datasec (abfd);

      text_pad = data->vma - (text->vma + text->size);
      /* Only pad the text section if the data
	 section is going to be placed after it.  */
      if (text_pad > 0)
	text->size += text_pad;
    }
  obj_datasec (abfd)->filepos = (obj_textsec (abfd)->filepos
				 + obj_textsec (abfd)->size);

  /* Fix up exec header while we're at it.  */
  execp->a_text = obj_textsec (abfd)->size;
  if (ztih && (!abdp || (abdp && !abdp->exec_header_not_counted)))
    execp->a_text += adata (abfd).exec_bytes_size;
  if (obj_aout_subformat (abfd) == q_magic_format)
    N_SET_MAGIC (*execp, QMAGIC);
  else
    N_SET_MAGIC (*execp, ZMAGIC);

  /* Spec says data section should be rounded up to page boundary.  */
  obj_datasec (abfd)->size
    = align_power (obj_datasec (abfd)->size,
		   obj_bsssec (abfd)->alignment_power);
  execp->a_data = BFD_ALIGN (obj_datasec (abfd)->size,
			     adata (abfd).page_size);
  data_pad = execp->a_data - obj_datasec (abfd)->size;

  /* BSS.  */
  if (!obj_bsssec (abfd)->user_set_vma)
    obj_bsssec (abfd)->vma = (obj_datasec (abfd)->vma
			      + obj_datasec (abfd)->size);
  /* If the BSS immediately follows the data section and extra space
     in the page is left after the data section, fudge data
     in the header so that the bss section looks smaller by that
     amount.  We'll start the bss section there, and lie to the OS.
     (Note that a linker script, as well as the above assignment,
     could have explicitly set the BSS vma to immediately follow
     the data section.)  */
  if (align_power (obj_bsssec (abfd)->vma, obj_bsssec (abfd)->alignment_power)
      == obj_datasec (abfd)->vma + obj_datasec (abfd)->size)
    execp->a_bss = (data_pad > obj_bsssec (abfd)->size
		    ? 0 : obj_bsssec (abfd)->size - data_pad);
  else
    execp->a_bss = obj_bsssec (abfd)->size;
}

static void
adjust_n_magic (bfd *abfd, struct internal_exec *execp)
{
  file_ptr pos = adata (abfd).exec_bytes_size;
  bfd_vma vma = 0;
  int pad;

  /* Text.  */
  obj_textsec (abfd)->filepos = pos;
  if (!obj_textsec (abfd)->user_set_vma)
    obj_textsec (abfd)->vma = vma;
  else
    vma = obj_textsec (abfd)->vma;
  pos += obj_textsec (abfd)->size;
  vma += obj_textsec (abfd)->size;

  /* Data.  */
  obj_datasec (abfd)->filepos = pos;
  if (!obj_datasec (abfd)->user_set_vma)
    obj_datasec (abfd)->vma = BFD_ALIGN (vma, adata (abfd).segment_size);
  vma = obj_datasec (abfd)->vma;

  /* Since BSS follows data immediately, see if it needs alignment.  */
  vma += obj_datasec (abfd)->size;
  pad = align_power (vma, obj_bsssec (abfd)->alignment_power) - vma;
  obj_datasec (abfd)->size += pad;
  pos += obj_datasec (abfd)->size;

  /* BSS.  */
  if (!obj_bsssec (abfd)->user_set_vma)
    obj_bsssec (abfd)->vma = vma;
  else
    vma = obj_bsssec (abfd)->vma;

  /* Fix up exec header.  */
  execp->a_text = obj_textsec (abfd)->size;
  execp->a_data = obj_datasec (abfd)->size;
  execp->a_bss = obj_bsssec (abfd)->size;
  N_SET_MAGIC (*execp, NMAGIC);
}

bfd_boolean
NAME (aout, adjust_sizes_and_vmas) (bfd *abfd,
				    bfd_size_type *text_size,
				    file_ptr *text_end ATTRIBUTE_UNUSED)
{
  struct internal_exec *execp = exec_hdr (abfd);

  if (! NAME (aout, make_sections) (abfd))
    return FALSE;

  if (adata (abfd).magic != undecided_magic)
    return TRUE;

  obj_textsec (abfd)->size =
    align_power (obj_textsec (abfd)->size,
		 obj_textsec (abfd)->alignment_power);

  *text_size = obj_textsec (abfd)->size;
  /* Rule (heuristic) for when to pad to a new page.  Note that there
     are (at least) two ways demand-paged (ZMAGIC) files have been
     handled.  Most Berkeley-based systems start the text segment at
     (TARGET_PAGE_SIZE).  However, newer versions of SUNOS start the text
     segment right after the exec header; the latter is counted in the
     text segment size, and is paged in by the kernel with the rest of
     the text.  */

  /* This perhaps isn't the right way to do this, but made it simpler for me
     to understand enough to implement it.  Better would probably be to go
     right from BFD flags to alignment/positioning characteristics.  But the
     old code was sloppy enough about handling the flags, and had enough
     other magic, that it was a little hard for me to understand.  I think
     I understand it better now, but I haven't time to do the cleanup this
     minute.  */

  if (abfd->flags & D_PAGED)
    /* Whether or not WP_TEXT is set -- let D_PAGED override.  */
    adata (abfd).magic = z_magic;
  else if (abfd->flags & WP_TEXT)
    adata (abfd).magic = n_magic;
  else
    adata (abfd).magic = o_magic;

#ifdef BFD_AOUT_DEBUG /* requires gcc2 */
#if __GNUC__ >= 2
  fprintf (stderr, "%s text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x,%x>\n",
	   ({ char *str;
	      switch (adata (abfd).magic)
		{
		case n_magic: str = "NMAGIC"; break;
		case o_magic: str = "OMAGIC"; break;
		case z_magic: str = "ZMAGIC"; break;
		default: abort ();
		}
	      str;
	    }),
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,
	   	obj_textsec (abfd)->alignment_power,
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,
	   	obj_datasec (abfd)->alignment_power,
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size,
	   	obj_bsssec (abfd)->alignment_power);
#endif
#endif

  switch (adata (abfd).magic)
    {
    case o_magic:
      adjust_o_magic (abfd, execp);
      break;
    case z_magic:
      adjust_z_magic (abfd, execp);
      break;
    case n_magic:
      adjust_n_magic (abfd, execp);
      break;
    default:
      abort ();
    }

#ifdef BFD_AOUT_DEBUG
  fprintf (stderr, "       text=<%x,%x,%x> data=<%x,%x,%x> bss=<%x,%x>\n",
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,
	   	obj_textsec (abfd)->filepos,
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,
	   	obj_datasec (abfd)->filepos,
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size);
#endif

  return TRUE;
}

/*
FUNCTION
	aout_@@var{size}_new_section_hook

SYNOPSIS
        bfd_boolean aout_@@var{size}_new_section_hook,
	   (bfd *abfd,
	    asection *newsect);

DESCRIPTION
	Called by the BFD in response to a @@code{bfd_make_section}
	request.
*/
bfd_boolean
NAME (aout, new_section_hook) (bfd *abfd, asection *newsect)
{
  /* Align to double at least.  */
  newsect->alignment_power = bfd_get_arch_info (abfd)->section_align_power;

  if (bfd_get_format (abfd) == bfd_object)
    {
      if (obj_textsec (abfd) == NULL && !strcmp (newsect->name, ".text"))
	{
	  obj_textsec (abfd)= newsect;
	  newsect->target_index = N_TEXT;
	}
      else if (obj_datasec (abfd) == NULL && !strcmp (newsect->name, ".data"))
	{
	  obj_datasec (abfd) = newsect;
	  newsect->target_index = N_DATA;
	}
      else if (obj_bsssec (abfd) == NULL && !strcmp (newsect->name, ".bss"))
	{
	  obj_bsssec (abfd) = newsect;
	  newsect->target_index = N_BSS;
	}
    }

  /* We allow more than three sections internally.  */
  return _bfd_generic_new_section_hook (abfd, newsect);
}

bfd_boolean
NAME (aout, set_section_contents) (bfd *abfd,
				   sec_ptr section,
				   const void * location,
				   file_ptr offset,
				   bfd_size_type count)
{
  file_ptr text_end;
  bfd_size_type text_size;

  if (! abfd->output_has_begun)
    {
      if (! NAME (aout, adjust_sizes_and_vmas) (abfd, &text_size, &text_end))
	return FALSE;
    }

  if (section == obj_bsssec (abfd))
    {
      bfd_set_error (bfd_error_no_contents);
      return FALSE;
    }

  if (section != obj_textsec (abfd)
      && section != obj_datasec (abfd))
    {
      if (aout_section_merge_with_text_p (abfd, section))
	section->filepos = obj_textsec (abfd)->filepos +
			   (section->vma - obj_textsec (abfd)->vma);
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, section));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
    }

  if (count != 0)
    {
      if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
	  || bfd_bwrite (location, count, abfd) != count)
	return FALSE;
    }

  return TRUE;
}

/* Read the external symbols from an a.out file.  */

static bfd_boolean
aout_get_external_symbols (bfd *abfd)
{
  if (obj_aout_external_syms (abfd) == NULL)
    {
      bfd_size_type count;
      struct external_nlist *syms;

      count = exec_hdr (abfd)->a_syms / EXTERNAL_NLIST_SIZE;
      if (count == 0)
	return TRUE;		/* Nothing to do.  */

#ifdef USE_MMAP
      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd),
				 exec_hdr (abfd)->a_syms,
				 &obj_aout_sym_window (abfd), TRUE))
	return FALSE;
      syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;
#else
      /* We allocate using malloc to make the values easy to free
	 later on.  If we put them on the objalloc it might not be
	 possible to free them.  */
      syms = (struct external_nlist *) bfd_malloc (count * EXTERNAL_NLIST_SIZE);
      if (syms == NULL)
	return FALSE;

      {
	bfd_size_type amt;
	amt = exec_hdr (abfd)->a_syms;
	if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
	    || bfd_bread (syms, amt, abfd) != amt)
	  {
	    free (syms);
	    return FALSE;
	  }
      }
#endif

      obj_aout_external_syms (abfd) = syms;
      obj_aout_external_sym_count (abfd) = count;
    }

  if (obj_aout_external_strings (abfd) == NULL
      && exec_hdr (abfd)->a_syms != 0)
    {
      unsigned char string_chars[BYTES_IN_WORD];
      bfd_size_type stringsize;
      char *strings;
      bfd_size_type amt = BYTES_IN_WORD;

      /* Get the size of the strings.  */
      if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0
	  || bfd_bread ((void *) string_chars, amt, abfd) != amt)
	return FALSE;
      stringsize = GET_WORD (abfd, string_chars);

#ifdef USE_MMAP
      if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
				 &obj_aout_string_window (abfd), TRUE))
	return FALSE;
      strings = (char *) obj_aout_string_window (abfd).data;
#else
      strings = (char *) bfd_malloc (stringsize + 1);
      if (strings == NULL)
	return FALSE;

      /* Skip space for the string count in the buffer for convenience
	 when using indexes.  */
      amt = stringsize - BYTES_IN_WORD;
      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)
	{
	  free (strings);
	  return FALSE;
	}
#endif

      /* Ensure that a zero index yields an empty string.  */
      strings[0] = '\0';

      strings[stringsize - 1] = 0;

      obj_aout_external_strings (abfd) = strings;
      obj_aout_external_string_size (abfd) = stringsize;
    }

  return TRUE;
}

/* Translate an a.out symbol into a BFD symbol.  The desc, other, type
   and symbol->value fields of CACHE_PTR will be set from the a.out
   nlist structure.  This function is responsible for setting
   symbol->flags and symbol->section, and adjusting symbol->value.  */

static bfd_boolean
translate_from_native_sym_flags (bfd *abfd, aout_symbol_type *cache_ptr)
{
  flagword visible;

  if ((cache_ptr->type & N_STAB) != 0
      || cache_ptr->type == N_FN)
    {
      asection *sec;

      /* This is a debugging symbol.  */
      cache_ptr->symbol.flags = BSF_DEBUGGING;

      /* Work out the symbol section.  */
      switch (cache_ptr->type & N_TYPE)
	{
	case N_TEXT:
	case N_FN:
	  sec = obj_textsec (abfd);
	  break;
	case N_DATA:
	  sec = obj_datasec (abfd);
	  break;
	case N_BSS:
	  sec = obj_bsssec (abfd);
	  break;
	default:
	case N_ABS:
	  sec = bfd_abs_section_ptr;
	  break;
	}

      cache_ptr->symbol.section = sec;
      cache_ptr->symbol.value -= sec->vma;

      return TRUE;
    }

  /* Get the default visibility.  This does not apply to all types, so
     we just hold it in a local variable to use if wanted.  */
  if ((cache_ptr->type & N_EXT) == 0)
    visible = BSF_LOCAL;
  else
    visible = BSF_GLOBAL;

  switch (cache_ptr->type)
    {
    default:
    case N_ABS: case N_ABS | N_EXT:
      cache_ptr->symbol.section = bfd_abs_section_ptr;
      cache_ptr->symbol.flags = visible;
      break;

    case N_UNDF | N_EXT:
      if (cache_ptr->symbol.value != 0)
	{
	  /* This is a common symbol.  */
	  cache_ptr->symbol.flags = BSF_GLOBAL;
	  cache_ptr->symbol.section = bfd_com_section_ptr;
	}
      else
	{
	  cache_ptr->symbol.flags = 0;
	  cache_ptr->symbol.section = bfd_und_section_ptr;
	}
      break;

    case N_TEXT: case N_TEXT | N_EXT:
      cache_ptr->symbol.section = obj_textsec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = visible;
      break;

      /* N_SETV symbols used to represent set vectors placed in the
	 data section.  They are no longer generated.  Theoretically,
	 it was possible to extract the entries and combine them with
	 new ones, although I don't know if that was ever actually
	 done.  Unless that feature is restored, treat them as data
	 symbols.  */
    case N_SETV: case N_SETV | N_EXT:
    case N_DATA: case N_DATA | N_EXT:
      cache_ptr->symbol.section = obj_datasec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = visible;
      break;

    case N_BSS: case N_BSS | N_EXT:
      cache_ptr->symbol.section = obj_bsssec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = visible;
      break;

    case N_SETA: case N_SETA | N_EXT:
    case N_SETT: case N_SETT | N_EXT:
    case N_SETD: case N_SETD | N_EXT:
    case N_SETB: case N_SETB | N_EXT:
      {
	/* This code is no longer needed.  It used to be used to make
           the linker handle set symbols, but they are now handled in
           the add_symbols routine instead.  */
	switch (cache_ptr->type & N_TYPE)
	  {
	  case N_SETA:
	    cache_ptr->symbol.section = bfd_abs_section_ptr;
	    break;
	  case N_SETT:
	    cache_ptr->symbol.section = obj_textsec (abfd);
	    break;
	  case N_SETD:
	    cache_ptr->symbol.section = obj_datasec (abfd);
	    break;
	  case N_SETB:
	    cache_ptr->symbol.section = obj_bsssec (abfd);
	    break;
	  }

	cache_ptr->symbol.flags |= BSF_CONSTRUCTOR;
      }
      break;

    case N_WARNING:
      /* This symbol is the text of a warning message.  The next
	 symbol is the symbol to associate the warning with.  If a
	 reference is made to that symbol, a warning is issued.  */
      cache_ptr->symbol.flags = BSF_DEBUGGING | BSF_WARNING;
      cache_ptr->symbol.section = bfd_abs_section_ptr;
      break;

    case N_INDR: case N_INDR | N_EXT:
      /* An indirect symbol.  This consists of two symbols in a row.
	 The first symbol is the name of the indirection.  The second
	 symbol is the name of the target.  A reference to the first
	 symbol becomes a reference to the second.  */
      cache_ptr->symbol.flags = BSF_DEBUGGING | BSF_INDIRECT | visible;
      cache_ptr->symbol.section = bfd_ind_section_ptr;
      break;

    case N_WEAKU:
      cache_ptr->symbol.section = bfd_und_section_ptr;
      cache_ptr->symbol.flags = BSF_WEAK;
      break;

    case N_WEAKA:
      cache_ptr->symbol.section = bfd_abs_section_ptr;
      cache_ptr->symbol.flags = BSF_WEAK;
      break;

    case N_WEAKT:
      cache_ptr->symbol.section = obj_textsec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = BSF_WEAK;
      break;

    case N_WEAKD:
      cache_ptr->symbol.section = obj_datasec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = BSF_WEAK;
      break;

    case N_WEAKB:
      cache_ptr->symbol.section = obj_bsssec (abfd);
      cache_ptr->symbol.value -= cache_ptr->symbol.section->vma;
      cache_ptr->symbol.flags = BSF_WEAK;
      break;
    }

  return TRUE;
}

/* Set the fields of SYM_POINTER according to CACHE_PTR.  */

static bfd_boolean
translate_to_native_sym_flags (bfd *abfd,
			       asymbol *cache_ptr,
			       struct external_nlist *sym_pointer)
{
  bfd_vma value = cache_ptr->value;
  asection *sec;
  bfd_vma off;

  /* Mask out any existing type bits in case copying from one section
     to another.  */
  sym_pointer->e_type[0] &= ~N_TYPE;

  sec = bfd_get_section (cache_ptr);
  off = 0;

  if (sec == NULL)
    {
      /* This case occurs, e.g., for the *DEBUG* section of a COFF
	 file.  */
      (*_bfd_error_handler)
	(_("%s: can not represent section for symbol `%s' in a.out object file format"),
	 bfd_get_filename (abfd),
	 cache_ptr->name != NULL ? cache_ptr->name : _("*unknown*"));
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
    }

  if (sec->output_section != NULL)
    {
      off = sec->output_offset;
      sec = sec->output_section;
    }

  if (bfd_is_abs_section (sec))
    sym_pointer->e_type[0] |= N_ABS;
  else if (sec == obj_textsec (abfd))
    sym_pointer->e_type[0] |= N_TEXT;
  else if (sec == obj_datasec (abfd))
    sym_pointer->e_type[0] |= N_DATA;
  else if (sec == obj_bsssec (abfd))
    sym_pointer->e_type[0] |= N_BSS;
  else if (bfd_is_und_section (sec))
    sym_pointer->e_type[0] = N_UNDF | N_EXT;
  else if (bfd_is_ind_section (sec))
    sym_pointer->e_type[0] = N_INDR;
  else if (bfd_is_com_section (sec))
    sym_pointer->e_type[0] = N_UNDF | N_EXT;
  else
    {
      if (aout_section_merge_with_text_p (abfd, sec))
	sym_pointer->e_type[0] |= N_TEXT;
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, sec));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
    }

  /* Turn the symbol from section relative to absolute again.  */
  value += sec->vma + off;

  if ((cache_ptr->flags & BSF_WARNING) != 0)
    sym_pointer->e_type[0] = N_WARNING;

  if ((cache_ptr->flags & BSF_DEBUGGING) != 0)
    sym_pointer->e_type[0] = ((aout_symbol_type *) cache_ptr)->type;
  else if ((cache_ptr->flags & BSF_GLOBAL) != 0)
    sym_pointer->e_type[0] |= N_EXT;
  else if ((cache_ptr->flags & BSF_LOCAL) != 0)
    sym_pointer->e_type[0] &= ~N_EXT;

  if ((cache_ptr->flags & BSF_CONSTRUCTOR) != 0)
    {
      int type = ((aout_symbol_type *) cache_ptr)->type;

      switch (type)
	{
	case N_ABS:	type = N_SETA; break;
	case N_TEXT:	type = N_SETT; break;
	case N_DATA:	type = N_SETD; break;
	case N_BSS:	type = N_SETB; break;
	}
      sym_pointer->e_type[0] = type;
    }

  if ((cache_ptr->flags & BSF_WEAK) != 0)
    {
      int type;

      switch (sym_pointer->e_type[0] & N_TYPE)
	{
	default:
	case N_ABS:	type = N_WEAKA; break;
	case N_TEXT:	type = N_WEAKT; break;
	case N_DATA:	type = N_WEAKD; break;
	case N_BSS:	type = N_WEAKB; break;
	case N_UNDF:	type = N_WEAKU; break;
	}
      sym_pointer->e_type[0] = type;
    }

  PUT_WORD (abfd, value, sym_pointer->e_value);

  return TRUE;
}

/* Native-level interface to symbols.  */

asymbol *
NAME (aout, make_empty_symbol) (bfd *abfd)
{
  bfd_size_type amt = sizeof (aout_symbol_type);

  aout_symbol_type *new_symbol = (aout_symbol_type *) bfd_zalloc (abfd, amt);
  if (!new_symbol)
    return NULL;
  new_symbol->symbol.the_bfd = abfd;

  return &new_symbol->symbol;
}

/* Translate a set of internal symbols into external symbols.  */

bfd_boolean
NAME (aout, translate_symbol_table) (bfd *abfd,
				     aout_symbol_type *in,
				     struct external_nlist *ext,
				     bfd_size_type count,
				     char *str,
				     bfd_size_type strsize,
				     bfd_boolean dynamic)
{
  struct external_nlist *ext_end;

  ext_end = ext + count;
  for (; ext < ext_end; ext++, in++)
    {
      bfd_vma x;

      x = GET_WORD (abfd, ext->e_strx);
      in->symbol.the_bfd = abfd;

      /* For the normal symbols, the zero index points at the number
	 of bytes in the string table but is to be interpreted as the
	 null string.  For the dynamic symbols, the number of bytes in
	 the string table is stored in the __DYNAMIC structure and the
	 zero index points at an actual string.  */
      if (x == 0 && ! dynamic)
	in->symbol.name = "";
      else if (x < strsize)
	in->symbol.name = str + x;
      else
	return FALSE;

      in->symbol.value = GET_SWORD (abfd,  ext->e_value);
      in->desc = H_GET_16 (abfd, ext->e_desc);
      in->other = H_GET_8 (abfd, ext->e_other);
      in->type = H_GET_8 (abfd,  ext->e_type);
      in->symbol.udata.p = NULL;

      if (! translate_from_native_sym_flags (abfd, in))
	return FALSE;

      if (dynamic)
	in->symbol.flags |= BSF_DYNAMIC;
    }

  return TRUE;
}

/* We read the symbols into a buffer, which is discarded when this
   function exits.  We read the strings into a buffer large enough to
   hold them all plus all the cached symbol entries.  */

bfd_boolean
NAME (aout, slurp_symbol_table) (bfd *abfd)
{
  struct external_nlist *old_external_syms;
  aout_symbol_type *cached;
  bfd_size_type cached_size;

  /* If there's no work to be done, don't do any.  */
  if (obj_aout_symbols (abfd) != NULL)
    return TRUE;

  old_external_syms = obj_aout_external_syms (abfd);

  if (! aout_get_external_symbols (abfd))
    return FALSE;

  cached_size = obj_aout_external_sym_count (abfd);
  if (cached_size == 0)
    return TRUE;		/* Nothing to do.  */

  cached_size *= sizeof (aout_symbol_type);
  cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
  if (cached == NULL)
    return FALSE;

  /* Convert from external symbol information to internal.  */
  if (! (NAME (aout, translate_symbol_table)
	 (abfd, cached,
	  obj_aout_external_syms (abfd),
	  obj_aout_external_sym_count (abfd),
	  obj_aout_external_strings (abfd),
	  obj_aout_external_string_size (abfd),
	  FALSE)))
    {
      free (cached);
      return FALSE;
    }

  bfd_get_symcount (abfd) = obj_aout_external_sym_count (abfd);

  obj_aout_symbols (abfd) = cached;

  /* It is very likely that anybody who calls this function will not
     want the external symbol information, so if it was allocated
     because of our call to aout_get_external_symbols, we free it up
     right away to save space.  */
  if (old_external_syms == NULL
      && obj_aout_external_syms (abfd) != NULL)
    {
#ifdef USE_MMAP
      bfd_free_window (&obj_aout_sym_window (abfd));
#else
      free (obj_aout_external_syms (abfd));
#endif
      obj_aout_external_syms (abfd) = NULL;
    }

  return TRUE;
}

/* We use a hash table when writing out symbols so that we only write
   out a particular string once.  This helps particularly when the
   linker writes out stabs debugging entries, because each different
   contributing object file tends to have many duplicate stabs
   strings.

   This hash table code breaks dbx on SunOS 4.1.3, so we don't do it
   if BFD_TRADITIONAL_FORMAT is set.  */

/* Get the index of a string in a strtab, adding it if it is not
   already present.  */

static inline bfd_size_type
add_to_stringtab (bfd *abfd,
		  struct bfd_strtab_hash *tab,
		  const char *str,
		  bfd_boolean copy)
{
  bfd_boolean hash;
  bfd_size_type str_index;

  /* An index of 0 always means the empty string.  */
  if (str == 0 || *str == '\0')
    return 0;

  /* Don't hash if BFD_TRADITIONAL_FORMAT is set, because SunOS dbx
     doesn't understand a hashed string table.  */
  hash = TRUE;
  if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
    hash = FALSE;

  str_index = _bfd_stringtab_add (tab, str, hash, copy);

  if (str_index != (bfd_size_type) -1)
    /* Add BYTES_IN_WORD to the return value to account for the
       space taken up by the string table size.  */
    str_index += BYTES_IN_WORD;

  return str_index;
}

/* Write out a strtab.  ABFD is already at the right location in the
   file.  */

static bfd_boolean
emit_stringtab (bfd *abfd, struct bfd_strtab_hash *tab)
{
  bfd_byte buffer[BYTES_IN_WORD];
  bfd_size_type amt = BYTES_IN_WORD;

  /* The string table starts with the size.  */
  PUT_WORD (abfd, _bfd_stringtab_size (tab) + BYTES_IN_WORD, buffer);
  if (bfd_bwrite ((void *) buffer, amt, abfd) != amt)
    return FALSE;

  return _bfd_stringtab_emit (abfd, tab);
}

bfd_boolean
NAME (aout, write_syms) (bfd *abfd)
{
  unsigned int count ;
  asymbol **generic = bfd_get_outsymbols (abfd);
  struct bfd_strtab_hash *strtab;

  strtab = _bfd_stringtab_init ();
  if (strtab == NULL)
    return FALSE;

  for (count = 0; count < bfd_get_symcount (abfd); count++)
    {
      asymbol *g = generic[count];
      bfd_size_type indx;
      struct external_nlist nsp;
      bfd_size_type amt;

      indx = add_to_stringtab (abfd, strtab, g->name, FALSE);
      if (indx == (bfd_size_type) -1)
	goto error_return;
      PUT_WORD (abfd, indx, (bfd_byte *) nsp.e_strx);

      if (bfd_asymbol_flavour (g) == abfd->xvec->flavour)
	{
	  H_PUT_16 (abfd, aout_symbol (g)->desc,  nsp.e_desc);
	  H_PUT_8  (abfd, aout_symbol (g)->other, nsp.e_other);
	  H_PUT_8  (abfd, aout_symbol (g)->type,  nsp.e_type);
	}
      else
	{
	  H_PUT_16 (abfd, 0, nsp.e_desc);
	  H_PUT_8  (abfd, 0, nsp.e_other);
	  H_PUT_8  (abfd, 0, nsp.e_type);
	}

      if (! translate_to_native_sym_flags (abfd, g, &nsp))
	goto error_return;

      amt = EXTERNAL_NLIST_SIZE;
      if (bfd_bwrite ((void *) &nsp, amt, abfd) != amt)
	goto error_return;

      /* NB: `KEEPIT' currently overlays `udata.p', so set this only
	 here, at the end.  */
      g->KEEPIT = count;
    }

  if (! emit_stringtab (abfd, strtab))
    goto error_return;

  _bfd_stringtab_free (strtab);

  return TRUE;

error_return:
  _bfd_stringtab_free (strtab);
  return FALSE;
}

long
NAME (aout, canonicalize_symtab) (bfd *abfd, asymbol **location)
{
  unsigned int counter = 0;
  aout_symbol_type *symbase;

  if (!NAME (aout, slurp_symbol_table) (abfd))
    return -1;

  for (symbase = obj_aout_symbols (abfd);
       counter++ < bfd_get_symcount (abfd);
       )
    *(location++) = (asymbol *) (symbase++);
  *location++ =0;
  return bfd_get_symcount (abfd);
}

/* Standard reloc stuff.  */
/* Output standard relocation information to a file in target byte order.  */

extern void  NAME (aout, swap_std_reloc_out)
  (bfd *, arelent *, struct reloc_std_external *);

void
NAME (aout, swap_std_reloc_out) (bfd *abfd,
				 arelent *g,
				 struct reloc_std_external *natptr)
{
  int r_index;
  asymbol *sym = *(g->sym_ptr_ptr);
  int r_extern;
  unsigned int r_length;
  int r_pcrel;
  int r_baserel, r_jmptable, r_relative;
  asection *output_section = sym->section->output_section;

  PUT_WORD (abfd, g->address, natptr->r_address);

  r_length = g->howto->size ;	/* Size as a power of two.  */
  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC?  */
  /* XXX This relies on relocs coming from a.out files.  */
  r_baserel = (g->howto->type & 8) != 0;
  r_jmptable = (g->howto->type & 16) != 0;
  r_relative = (g->howto->type & 32) != 0;

  /* Name was clobbered by aout_write_syms to be symbol index.  */

  /* If this relocation is relative to a symbol then set the
     r_index to the symbols index, and the r_extern bit.

     Absolute symbols can come in in two ways, either as an offset
     from the abs section, or as a symbol which has an abs value.
     check for that here.  */

  if (bfd_is_com_section (output_section)
      || bfd_is_abs_section (output_section)
      || bfd_is_und_section (output_section)
      /* PR gas/3041  a.out relocs against weak symbols
	 must be treated as if they were against externs.  */
      || (sym->flags & BSF_WEAK))
    {
      if (bfd_abs_section_ptr->symbol == sym)
	{
	  /* Whoops, looked like an abs symbol, but is
	     really an offset from the abs section.  */
	  r_index = N_ABS;
	  r_extern = 0;
	}
      else
	{
	  /* Fill in symbol.  */
	  r_extern = 1;
	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
	}
    }
  else
    {
      /* Just an ordinary section.  */
      r_extern = 0;
      r_index  = output_section->target_index;
    }

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      natptr->r_index[0] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[2] = r_index;
      natptr->r_type[0] = ((r_extern ? RELOC_STD_BITS_EXTERN_BIG : 0)
			   | (r_pcrel ? RELOC_STD_BITS_PCREL_BIG : 0)
			   | (r_baserel ? RELOC_STD_BITS_BASEREL_BIG : 0)
			   | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_BIG : 0)
			   | (r_relative ? RELOC_STD_BITS_RELATIVE_BIG : 0)
			   | (r_length << RELOC_STD_BITS_LENGTH_SH_BIG));
    }
  else
    {
      natptr->r_index[2] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[0] = r_index;
      natptr->r_type[0] = ((r_extern ? RELOC_STD_BITS_EXTERN_LITTLE : 0)
			   | (r_pcrel ? RELOC_STD_BITS_PCREL_LITTLE : 0)
			   | (r_baserel ? RELOC_STD_BITS_BASEREL_LITTLE : 0)
			   | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_LITTLE : 0)
			   | (r_relative ? RELOC_STD_BITS_RELATIVE_LITTLE : 0)
			   | (r_length << RELOC_STD_BITS_LENGTH_SH_LITTLE));
    }
}

/* Extended stuff.  */
/* Output extended relocation information to a file in target byte order.  */

extern void NAME (aout, swap_ext_reloc_out)
  (bfd *, arelent *, struct reloc_ext_external *);

void
NAME (aout, swap_ext_reloc_out) (bfd *abfd,
				 arelent *g,
				 struct reloc_ext_external *natptr)
{
  int r_index;
  int r_extern;
  unsigned int r_type;
  bfd_vma r_addend;
  asymbol *sym = *(g->sym_ptr_ptr);
  asection *output_section = sym->section->output_section;

  PUT_WORD (abfd, g->address, natptr->r_address);

  r_type = (unsigned int) g->howto->type;

  r_addend = g->addend;
  if ((sym->flags & BSF_SECTION_SYM) != 0)
    r_addend += (*(g->sym_ptr_ptr))->section->output_section->vma;

  /* If this relocation is relative to a symbol then set the
     r_index to the symbols index, and the r_extern bit.

     Absolute symbols can come in in two ways, either as an offset
     from the abs section, or as a symbol which has an abs value.
     check for that here.  */
  if (bfd_is_abs_section (bfd_get_section (sym)))
    {
      r_extern = 0;
      r_index = N_ABS;
    }
  else if ((sym->flags & BSF_SECTION_SYM) == 0)
    {
      if (bfd_is_und_section (bfd_get_section (sym))
	  || (sym->flags & BSF_GLOBAL) != 0)
	r_extern = 1;
      else
	r_extern = 0;
      r_index = (*(g->sym_ptr_ptr))->KEEPIT;
    }
  else
    {
      /* Just an ordinary section.  */
      r_extern = 0;
      r_index = output_section->target_index;
    }

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      natptr->r_index[0] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[2] = r_index;
      natptr->r_type[0] = ((r_extern ? RELOC_EXT_BITS_EXTERN_BIG : 0)
			   | (r_type << RELOC_EXT_BITS_TYPE_SH_BIG));
    }
  else
    {
      natptr->r_index[2] = r_index >> 16;
      natptr->r_index[1] = r_index >> 8;
      natptr->r_index[0] = r_index;
      natptr->r_type[0] = ((r_extern ? RELOC_EXT_BITS_EXTERN_LITTLE : 0)
			   | (r_type << RELOC_EXT_BITS_TYPE_SH_LITTLE));
    }

  PUT_WORD (abfd, r_addend, natptr->r_addend);
}

/* BFD deals internally with all things based from the section they're
   in. so, something in 10 bytes into a text section  with a base of
   50 would have a symbol (.text+10) and know .text vma was 50.

   Aout keeps all it's symbols based from zero, so the symbol would
   contain 60. This macro subs the base of each section from the value
   to give the true offset from the section.  */

#define MOVE_ADDRESS(ad)						\
  if (r_extern)								\
    {									\
      /* Undefined symbol.  */						\
      cache_ptr->sym_ptr_ptr = symbols + r_index;			\
      cache_ptr->addend = ad;						\
    }									\
   else									\
    {									\
      /* Defined, section relative.  Replace symbol with pointer to	\
	 symbol which points to section.  */				\
      switch (r_index)							\
	{								\
	case N_TEXT:							\
	case N_TEXT | N_EXT:						\
	  cache_ptr->sym_ptr_ptr = obj_textsec (abfd)->symbol_ptr_ptr;	\
	  cache_ptr->addend = ad - su->textsec->vma;			\
	  break;							\
	case N_DATA:							\
	case N_DATA | N_EXT:						\
	  cache_ptr->sym_ptr_ptr = obj_datasec (abfd)->symbol_ptr_ptr;	\
	  cache_ptr->addend = ad - su->datasec->vma;			\
	  break;							\
	case N_BSS:							\
	case N_BSS | N_EXT:						\
	  cache_ptr->sym_ptr_ptr = obj_bsssec (abfd)->symbol_ptr_ptr;	\
	  cache_ptr->addend = ad - su->bsssec->vma;			\
	  break;							\
	default:							\
	case N_ABS:							\
	case N_ABS | N_EXT:						\
	  cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;	\
	  cache_ptr->addend = ad;					\
	  break;							\
	}								\
    }

void
NAME (aout, swap_ext_reloc_in) (bfd *abfd,
				struct reloc_ext_external *bytes,
				arelent *cache_ptr,
				asymbol **symbols,
				bfd_size_type symcount)
{
  unsigned int r_index;
  int r_extern;
  unsigned int r_type;
  struct aoutdata *su = &(abfd->tdata.aout_data->a);

  cache_ptr->address = (GET_SWORD (abfd, bytes->r_address));

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
		 | bytes->r_index[2]);
      r_extern = (0 != (bytes->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
      r_type = ((bytes->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		>> RELOC_EXT_BITS_TYPE_SH_BIG);
    }
  else
    {
      r_index =  (((unsigned int) bytes->r_index[2] << 16)
		  | ((unsigned int) bytes->r_index[1] << 8)
		  | bytes->r_index[0]);
      r_extern = (0 != (bytes->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
      r_type = ((bytes->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		>> RELOC_EXT_BITS_TYPE_SH_LITTLE);
    }

  if (r_type < TABLE_SIZE (howto_table_ext))
    cache_ptr->howto = howto_table_ext + r_type;
  else
    cache_ptr->howto = NULL;

  /* Base relative relocs are always against the symbol table,
     regardless of the setting of r_extern.  r_extern just reflects
     whether the symbol the reloc is against is local or global.  */
  if (r_type == (unsigned int) RELOC_BASE10
      || r_type == (unsigned int) RELOC_BASE13
      || r_type == (unsigned int) RELOC_BASE22)
    r_extern = 1;

  if (r_extern && r_index > symcount)
    {
      /* We could arrange to return an error, but it might be useful
         to see the file even if it is bad.  */
      r_extern = 0;
      r_index = N_ABS;
    }

  MOVE_ADDRESS (GET_SWORD (abfd, bytes->r_addend));
}

void
NAME (aout, swap_std_reloc_in) (bfd *abfd,
				struct reloc_std_external *bytes,
				arelent *cache_ptr,
				asymbol **symbols,
				bfd_size_type symcount)
{
  unsigned int r_index;
  int r_extern;
  unsigned int r_length;
  int r_pcrel;
  int r_baserel, r_jmptable, r_relative;
  struct aoutdata  *su = &(abfd->tdata.aout_data->a);
  unsigned int howto_idx;

  cache_ptr->address = H_GET_32 (abfd, bytes->r_address);

  /* Now the fun stuff.  */
  if (bfd_header_big_endian (abfd))
    {
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
		 | bytes->r_index[2]);
      r_extern  = (0 != (bytes->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
      r_pcrel   = (0 != (bytes->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
      r_baserel = (0 != (bytes->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
      r_jmptable= (0 != (bytes->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
      r_relative= (0 != (bytes->r_type[0] & RELOC_STD_BITS_RELATIVE_BIG));
      r_length  = ((bytes->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
		   >> RELOC_STD_BITS_LENGTH_SH_BIG);
    }
  else
    {
      r_index = (((unsigned int) bytes->r_index[2] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
		 | bytes->r_index[0]);
      r_extern  = (0 != (bytes->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
      r_pcrel   = (0 != (bytes->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
      r_baserel = (0 != (bytes->r_type[0] & RELOC_STD_BITS_BASEREL_LITTLE));
      r_jmptable= (0 != (bytes->r_type[0] & RELOC_STD_BITS_JMPTABLE_LITTLE));
      r_relative= (0 != (bytes->r_type[0] & RELOC_STD_BITS_RELATIVE_LITTLE));
      r_length  = ((bytes->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
		   >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
    }

  howto_idx = (r_length + 4 * r_pcrel + 8 * r_baserel
	       + 16 * r_jmptable + 32 * r_relative);
  if (howto_idx < TABLE_SIZE (howto_table_std))
    {
      cache_ptr->howto = howto_table_std + howto_idx;
      if (cache_ptr->howto->type == (unsigned int) -1)
	cache_ptr->howto = NULL;
    }
  else
    cache_ptr->howto = NULL;

  /* Base relative relocs are always against the symbol table,
     regardless of the setting of r_extern.  r_extern just reflects
     whether the symbol the reloc is against is local or global.  */
  if (r_baserel)
    r_extern = 1;

  if (r_extern && r_index > symcount)
    {
      /* We could arrange to return an error, but it might be useful
         to see the file even if it is bad.  */
      r_extern = 0;
      r_index = N_ABS;
    }

  MOVE_ADDRESS (0);
}

/* Read and swap the relocs for a section.  */

bfd_boolean
NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)
{
  bfd_size_type count;
  bfd_size_type reloc_size;
  void * relocs;
  arelent *reloc_cache;
  size_t each_size;
  unsigned int counter = 0;
  arelent *cache_ptr;
  bfd_size_type amt;

  if (asect->relocation)
    return TRUE;

  if (asect->flags & SEC_CONSTRUCTOR)
    return TRUE;

  if (asect == obj_datasec (abfd))
    reloc_size = exec_hdr (abfd)->a_drsize;
  else if (asect == obj_textsec (abfd))
    reloc_size = exec_hdr (abfd)->a_trsize;
  else if (asect == obj_bsssec (abfd))
    reloc_size = 0;
  else
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  if (reloc_size == 0)
    return TRUE;		/* Nothing to be done.  */

  if (bfd_seek (abfd, asect->rel_filepos, SEEK_SET) != 0)
    return FALSE;

  each_size = obj_reloc_entry_size (abfd);

  count = reloc_size / each_size;
  if (count == 0)
    return TRUE;		/* Nothing to be done.  */

  amt = count * sizeof (arelent);
  reloc_cache = (arelent *) bfd_zmalloc (amt);
  if (reloc_cache == NULL)
    return FALSE;

  relocs = bfd_malloc (reloc_size);
  if (relocs == NULL)
    {
      free (reloc_cache);
      return FALSE;
    }

  if (bfd_bread (relocs, reloc_size, abfd) != reloc_size)
    {
      free (relocs);
      free (reloc_cache);
      return FALSE;
    }

  cache_ptr = reloc_cache;
  if (each_size == RELOC_EXT_SIZE)
    {
      struct reloc_ext_external *rptr = (struct reloc_ext_external *) relocs;

      for (; counter < count; counter++, rptr++, cache_ptr++)
	MY_swap_ext_reloc_in (abfd, rptr, cache_ptr, symbols,
			      (bfd_size_type) bfd_get_symcount (abfd));
    }
  else
    {
      struct reloc_std_external *rptr = (struct reloc_std_external *) relocs;

      for (; counter < count; counter++, rptr++, cache_ptr++)
	MY_swap_std_reloc_in (abfd, rptr, cache_ptr, symbols,
			      (bfd_size_type) bfd_get_symcount (abfd));
    }

  free (relocs);

  asect->relocation = reloc_cache;
  asect->reloc_count = cache_ptr - reloc_cache;

  return TRUE;
}

/* Write out a relocation section into an object file.  */

bfd_boolean
NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)
{
  arelent **generic;
  unsigned char *native, *natptr;
  size_t each_size;

  unsigned int count = section->reloc_count;
  bfd_size_type natsize;

  if (count == 0 || section->orelocation == NULL)
    return TRUE;

  each_size = obj_reloc_entry_size (abfd);
  natsize = (bfd_size_type) each_size * count;
  native = (unsigned char *) bfd_zalloc (abfd, natsize);
  if (!native)
    return FALSE;

  generic = section->orelocation;

  if (each_size == RELOC_EXT_SIZE)
    {
      for (natptr = native;
	   count != 0;
	   --count, natptr += each_size, ++generic)
	MY_swap_ext_reloc_out (abfd, *generic,
			       (struct reloc_ext_external *) natptr);
    }
  else
    {
      for (natptr = native;
	   count != 0;
	   --count, natptr += each_size, ++generic)
	MY_swap_std_reloc_out (abfd, *generic,
			       (struct reloc_std_external *) natptr);
    }

  if (bfd_bwrite ((void *) native, natsize, abfd) != natsize)
    {
      bfd_release (abfd, native);
      return FALSE;
    }
  bfd_release (abfd, native);

  return TRUE;
}

/* This is stupid.  This function should be a boolean predicate.  */

long
NAME (aout, canonicalize_reloc) (bfd *abfd,
				 sec_ptr section,
				 arelent **relptr,
				 asymbol **symbols)
{
  arelent *tblptr = section->relocation;
  unsigned int count;

  if (section == obj_bsssec (abfd))
    {
      *relptr = NULL;
      return 0;
    }

  if (!(tblptr || NAME (aout, slurp_reloc_table) (abfd, section, symbols)))
    return -1;

  if (section->flags & SEC_CONSTRUCTOR)
    {
      arelent_chain *chain = section->constructor_chain;
      for (count = 0; count < section->reloc_count; count ++)
	{
	  *relptr ++ = &chain->relent;
	  chain = chain->next;
	}
    }
  else
    {
      tblptr = section->relocation;

      for (count = 0; count++ < section->reloc_count; )
	{
	  *relptr++ = tblptr++;
	}
    }
  *relptr = 0;

  return section->reloc_count;
}

long
NAME (aout, get_reloc_upper_bound) (bfd *abfd, sec_ptr asect)
{
  if (bfd_get_format (abfd) != bfd_object)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  if (asect->flags & SEC_CONSTRUCTOR)
    return sizeof (arelent *) * (asect->reloc_count + 1);

  if (asect == obj_datasec (abfd))
    return sizeof (arelent *)
      * ((exec_hdr (abfd)->a_drsize / obj_reloc_entry_size (abfd))
	 + 1);

  if (asect == obj_textsec (abfd))
    return sizeof (arelent *)
      * ((exec_hdr (abfd)->a_trsize / obj_reloc_entry_size (abfd))
	 + 1);

  if (asect == obj_bsssec (abfd))
    return sizeof (arelent *);

  if (asect == obj_bsssec (abfd))
    return 0;

  bfd_set_error (bfd_error_invalid_operation);
  return -1;
}

long
NAME (aout, get_symtab_upper_bound) (bfd *abfd)
{
  if (!NAME (aout, slurp_symbol_table) (abfd))
    return -1;

  return (bfd_get_symcount (abfd)+1) * (sizeof (aout_symbol_type *));
}

alent *
NAME (aout, get_lineno) (bfd *ignore_abfd ATTRIBUTE_UNUSED,
			 asymbol *ignore_symbol ATTRIBUTE_UNUSED)
{
  return NULL;
}

void
NAME (aout, get_symbol_info) (bfd *ignore_abfd ATTRIBUTE_UNUSED,
			      asymbol *symbol,
			      symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);

  if (ret->type == '?')
    {
      int type_code = aout_symbol (symbol)->type & 0xff;
      const char *stab_name = bfd_get_stab_name (type_code);
      static char buf[10];

      if (stab_name == NULL)
	{
	  sprintf (buf, "(%d)", type_code);
	  stab_name = buf;
	}
      ret->type = '-';
      ret->stab_type = type_code;
      ret->stab_other = (unsigned) (aout_symbol (symbol)->other & 0xff);
      ret->stab_desc = (unsigned) (aout_symbol (symbol)->desc & 0xffff);
      ret->stab_name = stab_name;
    }
}

void
NAME (aout, print_symbol) (bfd *abfd,
			   void * afile,
			   asymbol *symbol,
			   bfd_print_symbol_type how)
{
  FILE *file = (FILE *)afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      if (symbol->name)
	fprintf (file,"%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file,"%4x %2x %2x",
	       (unsigned) (aout_symbol (symbol)->desc & 0xffff),
	       (unsigned) (aout_symbol (symbol)->other & 0xff),
	       (unsigned) (aout_symbol (symbol)->type));
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name = symbol->section->name;

	bfd_print_symbol_vandf (abfd, (void *)file, symbol);

	fprintf (file," %-5s %04x %02x %02x",
		 section_name,
		 (unsigned) (aout_symbol (symbol)->desc & 0xffff),
		 (unsigned) (aout_symbol (symbol)->other & 0xff),
		 (unsigned) (aout_symbol (symbol)->type & 0xff));
	if (symbol->name)
	  fprintf (file," %s", symbol->name);
      }
      break;
    }
}

/* If we don't have to allocate more than 1MB to hold the generic
   symbols, we use the generic minisymbol methord: it's faster, since
   it only translates the symbols once, not multiple times.  */
#define MINISYM_THRESHOLD (1000000 / sizeof (asymbol))

/* Read minisymbols.  For minisymbols, we use the unmodified a.out
   symbols.  The minisymbol_to_symbol function translates these into
   BFD asymbol structures.  */

long
NAME (aout, read_minisymbols) (bfd *abfd,
			       bfd_boolean dynamic,
			       void * *minisymsp,
			       unsigned int *sizep)
{
  if (dynamic)
    /* We could handle the dynamic symbols here as well, but it's
       easier to hand them off.  */
    return _bfd_generic_read_minisymbols (abfd, dynamic, minisymsp, sizep);

  if (! aout_get_external_symbols (abfd))
    return -1;

  if (obj_aout_external_sym_count (abfd) < MINISYM_THRESHOLD)
    return _bfd_generic_read_minisymbols (abfd, dynamic, minisymsp, sizep);

  *minisymsp = (void *) obj_aout_external_syms (abfd);

  /* By passing the external symbols back from this routine, we are
     giving up control over the memory block.  Clear
     obj_aout_external_syms, so that we do not try to free it
     ourselves.  */
  obj_aout_external_syms (abfd) = NULL;

  *sizep = EXTERNAL_NLIST_SIZE;
  return obj_aout_external_sym_count (abfd);
}

/* Convert a minisymbol to a BFD asymbol.  A minisymbol is just an
   unmodified a.out symbol.  The SYM argument is a structure returned
   by bfd_make_empty_symbol, which we fill in here.  */

asymbol *
NAME (aout, minisymbol_to_symbol) (bfd *abfd,
				   bfd_boolean dynamic,
				   const void * minisym,
				   asymbol *sym)
{
  if (dynamic
      || obj_aout_external_sym_count (abfd) < MINISYM_THRESHOLD)
    return _bfd_generic_minisymbol_to_symbol (abfd, dynamic, minisym, sym);

  memset (sym, 0, sizeof (aout_symbol_type));

  /* We call translate_symbol_table to translate a single symbol.  */
  if (! (NAME (aout, translate_symbol_table)
	 (abfd,
	  (aout_symbol_type *) sym,
	  (struct external_nlist *) minisym,
	  (bfd_size_type) 1,
	  obj_aout_external_strings (abfd),
	  obj_aout_external_string_size (abfd),
	  FALSE)))
    return NULL;

  return sym;
}

/* Provided a BFD, a section and an offset into the section, calculate
   and return the name of the source file and the line nearest to the
   wanted location.  */

bfd_boolean
NAME (aout, find_nearest_line) (bfd *abfd,
				asection *section,
				asymbol **symbols,
				bfd_vma offset,
				const char **filename_ptr,
				const char **functionname_ptr,
				unsigned int *line_ptr)
{
  /* Run down the file looking for the filename, function and linenumber.  */
  asymbol **p;
  const char *directory_name = NULL;
  const char *main_file_name = NULL;
  const char *current_file_name = NULL;
  const char *line_file_name = NULL;      /* Value of current_file_name at line number.  */
  const char *line_directory_name = NULL; /* Value of directory_name at line number.  */
  bfd_vma low_line_vma = 0;
  bfd_vma low_func_vma = 0;
  asymbol *func = 0;
  bfd_size_type filelen, funclen;
  char *buf;

  *filename_ptr = abfd->filename;
  *functionname_ptr = 0;
  *line_ptr = 0;

  if (symbols != NULL)
    {
      for (p = symbols; *p; p++)
	{
	  aout_symbol_type  *q = (aout_symbol_type *) (*p);
	next:
	  switch (q->type)
	    {
	    case N_TEXT:
	      /* If this looks like a file name symbol, and it comes after
		 the line number we have found so far, but before the
		 offset, then we have probably not found the right line
		 number.  */
	      if (q->symbol.value <= offset
		  && ((q->symbol.value > low_line_vma
		       && (line_file_name != NULL
			   || *line_ptr != 0))
		      || (q->symbol.value > low_func_vma
			  && func != NULL)))
		{
		  const char *symname;

		  symname = q->symbol.name;
		  if (strcmp (symname + strlen (symname) - 2, ".o") == 0)
		    {
		      if (q->symbol.value > low_line_vma)
			{
			  *line_ptr = 0;
			  line_file_name = NULL;
			}
		      if (q->symbol.value > low_func_vma)
			func = NULL;
		    }
		}
	      break;

	    case N_SO:
	      /* If this symbol is less than the offset, but greater than
		 the line number we have found so far, then we have not
		 found the right line number.  */
	      if (q->symbol.value <= offset)
		{
		  if (q->symbol.value > low_line_vma)
		    {
		      *line_ptr = 0;
		      line_file_name = NULL;
		    }
		  if (q->symbol.value > low_func_vma)
		    func = NULL;
		}

	      main_file_name = current_file_name = q->symbol.name;
	      /* Look ahead to next symbol to check if that too is an N_SO.  */
	      p++;
	      if (*p == NULL)
		goto done;
	      q = (aout_symbol_type *) (*p);
	      if (q->type != (int)N_SO)
		goto next;

	      /* Found a second N_SO  First is directory; second is filename.  */
	      directory_name = current_file_name;
	      main_file_name = current_file_name = q->symbol.name;
	      if (obj_textsec (abfd) != section)
		goto done;
	      break;
	    case N_SOL:
	      current_file_name = q->symbol.name;
	      break;

	    case N_SLINE:

	    case N_DSLINE:
	    case N_BSLINE:
	      /* We'll keep this if it resolves nearer than the one we have
		 already.  */
	      if (q->symbol.value >= low_line_vma
		  && q->symbol.value <= offset)
		{
		  *line_ptr = q->desc;
		  low_line_vma = q->symbol.value;
		  line_file_name = current_file_name;
		  line_directory_name = directory_name;
		}
	      break;
	    case N_FUN:
	      {
		/* We'll keep this if it is nearer than the one we have already.  */
		if (q->symbol.value >= low_func_vma &&
		    q->symbol.value <= offset)
		  {
		    low_func_vma = q->symbol.value;
		    func = (asymbol *)q;
		  }
		else if (q->symbol.value > offset)
		  goto done;
	      }
	      break;
	    }
	}
    }

 done:
  if (*line_ptr != 0)
    {
      main_file_name = line_file_name;
      directory_name = line_directory_name;
    }

  if (main_file_name == NULL
      || IS_ABSOLUTE_PATH (main_file_name)
      || directory_name == NULL)
    filelen = 0;
  else
    filelen = strlen (directory_name) + strlen (main_file_name);

  if (func == NULL)
    funclen = 0;
  else
    funclen = strlen (bfd_asymbol_name (func));

  if (adata (abfd).line_buf != NULL)
    free (adata (abfd).line_buf);

  if (filelen + funclen == 0)
    adata (abfd).line_buf = buf = NULL;
  else
    {
      buf = (char *) bfd_malloc (filelen + funclen + 3);
      adata (abfd).line_buf = buf;
      if (buf == NULL)
	return FALSE;
    }

  if (main_file_name != NULL)
    {
      if (IS_ABSOLUTE_PATH (main_file_name) || directory_name == NULL)
	*filename_ptr = main_file_name;
      else
	{
	  sprintf (buf, "%s%s", directory_name, main_file_name);
	  *filename_ptr = buf;
	  buf += filelen + 1;
	}
    }

  if (func)
    {
      const char *function = func->name;
      char *colon;

      /* The caller expects a symbol name.  We actually have a
	 function name, without the leading underscore.  Put the
	 underscore back in, so that the caller gets a symbol name.  */
      if (bfd_get_symbol_leading_char (abfd) == '\0')
	strcpy (buf, function);
      else
	{
	  buf[0] = bfd_get_symbol_leading_char (abfd);
	  strcpy (buf + 1, function);
	}
      /* Have to remove : stuff.  */
      colon = strchr (buf, ':');
      if (colon != NULL)
	*colon = '\0';
      *functionname_ptr = buf;
    }

  return TRUE;
}

int
NAME (aout, sizeof_headers) (bfd *abfd,
			     struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return adata (abfd).exec_bytes_size;
}

/* Free all information we have cached for this BFD.  We can always
   read it again later if we need it.  */

bfd_boolean
NAME (aout, bfd_free_cached_info) (bfd *abfd)
{
  asection *o;

  if (bfd_get_format (abfd) != bfd_object
      || abfd->tdata.aout_data == NULL)
    return TRUE;

#define BFCI_FREE(x) if (x != NULL) { free (x); x = NULL; }
  BFCI_FREE (obj_aout_symbols (abfd));
#ifdef USE_MMAP
  obj_aout_external_syms (abfd) = 0;
  bfd_free_window (&obj_aout_sym_window (abfd));
  bfd_free_window (&obj_aout_string_window (abfd));
  obj_aout_external_strings (abfd) = 0;
#else
  BFCI_FREE (obj_aout_external_syms (abfd));
  BFCI_FREE (obj_aout_external_strings (abfd));
#endif
  for (o = abfd->sections; o != NULL; o = o->next)
    BFCI_FREE (o->relocation);
#undef BFCI_FREE

  return TRUE;
}

/* a.out link code.  */

/* Routine to create an entry in an a.out link hash table.  */

struct bfd_hash_entry *
NAME (aout, link_hash_newfunc) (struct bfd_hash_entry *entry,
				struct bfd_hash_table *table,
				const char *string)
{
  struct aout_link_hash_entry *ret = (struct aout_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct aout_link_hash_entry *) bfd_hash_allocate (table,
                                                             sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct aout_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret)
    {
      /* Set local fields.  */
      ret->written = FALSE;
      ret->indx = -1;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Initialize an a.out link hash table.  */

bfd_boolean
NAME (aout, link_hash_table_init) (struct aout_link_hash_table *table,
				   bfd *abfd,
				   struct bfd_hash_entry *(*newfunc)
				   (struct bfd_hash_entry *, struct bfd_hash_table *,
				    const char *),
				   unsigned int entsize)
{
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);
}

/* Create an a.out link hash table.  */

struct bfd_link_hash_table *
NAME (aout, link_hash_table_create) (bfd *abfd)
{
  struct aout_link_hash_table *ret;
  bfd_size_type amt = sizeof (* ret);

  ret = (struct aout_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (!NAME (aout, link_hash_table_init) (ret, abfd,
					  NAME (aout, link_hash_newfunc),
					  sizeof (struct aout_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }
  return &ret->root;
}

/* Add all symbols from an object file to the hash table.  */

static bfd_boolean
aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean (*add_one_symbol)
    (struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	     bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **);
  struct external_nlist *syms;
  bfd_size_type sym_count;
  char *strings;
  bfd_boolean copy;
  struct aout_link_hash_entry **sym_hash;
  struct external_nlist *p;
  struct external_nlist *pend;
  bfd_size_type amt;

  syms = obj_aout_external_syms (abfd);
  sym_count = obj_aout_external_sym_count (abfd);
  strings = obj_aout_external_strings (abfd);
  if (info->keep_memory)
    copy = FALSE;
  else
    copy = TRUE;

  if (aout_backend_info (abfd)->add_dynamic_symbols != NULL)
    {
      if (! ((*aout_backend_info (abfd)->add_dynamic_symbols)
	     (abfd, info, &syms, &sym_count, &strings)))
	return FALSE;
    }

  if (sym_count == 0)
    return TRUE;		/* Nothing to do.  */

  /* We keep a list of the linker hash table entries that correspond
     to particular symbols.  We could just look them up in the hash
     table, but keeping the list is more efficient.  Perhaps this
     should be conditional on info->keep_memory.  */
  amt = sym_count * sizeof (struct aout_link_hash_entry *);
  sym_hash = (struct aout_link_hash_entry **) bfd_alloc (abfd, amt);
  if (sym_hash == NULL)
    return FALSE;
  obj_aout_sym_hashes (abfd) = sym_hash;

  add_one_symbol = aout_backend_info (abfd)->add_one_symbol;
  if (add_one_symbol == NULL)
    add_one_symbol = _bfd_generic_link_add_one_symbol;

  p = syms;
  pend = p + sym_count;
  for (; p < pend; p++, sym_hash++)
    {
      int type;
      const char *name;
      bfd_vma value;
      asection *section;
      flagword flags;
      const char *string;

      *sym_hash = NULL;

      type = H_GET_8 (abfd, p->e_type);

      /* Ignore debugging symbols.  */
      if ((type & N_STAB) != 0)
	continue;

      name = strings + GET_WORD (abfd, p->e_strx);
      value = GET_WORD (abfd, p->e_value);
      flags = BSF_GLOBAL;
      string = NULL;
      switch (type)
	{
	default:
	  abort ();

	case N_UNDF:
	case N_ABS:
	case N_TEXT:
	case N_DATA:
	case N_BSS:
	case N_FN_SEQ:
	case N_COMM:
	case N_SETV:
	case N_FN:
	  /* Ignore symbols that are not externally visible.  */
	  continue;
	case N_INDR:
	  /* Ignore local indirect symbol.  */
	  ++p;
	  ++sym_hash;
	  continue;

	case N_UNDF | N_EXT:
	  if (value == 0)
	    {
	      section = bfd_und_section_ptr;
	      flags = 0;
	    }
	  else
	    section = bfd_com_section_ptr;
	  break;
	case N_ABS | N_EXT:
	  section = bfd_abs_section_ptr;
	  break;
	case N_TEXT | N_EXT:
	  section = obj_textsec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_DATA | N_EXT:
	case N_SETV | N_EXT:
	  /* Treat N_SETV symbols as N_DATA symbol; see comment in
	     translate_from_native_sym_flags.  */
	  section = obj_datasec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_BSS | N_EXT:
	  section = obj_bsssec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_INDR | N_EXT:
	  /* An indirect symbol.  The next symbol is the symbol
	     which this one really is.  */
	  BFD_ASSERT (p + 1 < pend);
	  ++p;
	  string = strings + GET_WORD (abfd, p->e_strx);
	  section = bfd_ind_section_ptr;
	  flags |= BSF_INDIRECT;
	  break;
	case N_COMM | N_EXT:
	  section = bfd_com_section_ptr;
	  break;
	case N_SETA: case N_SETA | N_EXT:
	  section = bfd_abs_section_ptr;
	  flags |= BSF_CONSTRUCTOR;
	  break;
	case N_SETT: case N_SETT | N_EXT:
	  section = obj_textsec (abfd);
	  flags |= BSF_CONSTRUCTOR;
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_SETD: case N_SETD | N_EXT:
	  section = obj_datasec (abfd);
	  flags |= BSF_CONSTRUCTOR;
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_SETB: case N_SETB | N_EXT:
	  section = obj_bsssec (abfd);
	  flags |= BSF_CONSTRUCTOR;
	  value -= bfd_get_section_vma (abfd, section);
	  break;
	case N_WARNING:
	  /* A warning symbol.  The next symbol is the one to warn
	     about.  If there is no next symbol, just look away.  */
	  if (p + 1 >= pend)
	    return TRUE;
	  ++p;
	  string = name;
	  name = strings + GET_WORD (abfd, p->e_strx);
	  section = bfd_und_section_ptr;
	  flags |= BSF_WARNING;
	  break;
	case N_WEAKU:
	  section = bfd_und_section_ptr;
	  flags = BSF_WEAK;
	  break;
	case N_WEAKA:
	  section = bfd_abs_section_ptr;
	  flags = BSF_WEAK;
	  break;
	case N_WEAKT:
	  section = obj_textsec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  flags = BSF_WEAK;
	  break;
	case N_WEAKD:
	  section = obj_datasec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  flags = BSF_WEAK;
	  break;
	case N_WEAKB:
	  section = obj_bsssec (abfd);
	  value -= bfd_get_section_vma (abfd, section);
	  flags = BSF_WEAK;
	  break;
	}

      if (! ((*add_one_symbol)
	     (info, abfd, name, flags, section, value, string, copy, FALSE,
	      (struct bfd_link_hash_entry **) sym_hash)))
	return FALSE;

      /* Restrict the maximum alignment of a common symbol based on
	 the architecture, since a.out has no way to represent
	 alignment requirements of a section in a .o file.  FIXME:
	 This isn't quite right: it should use the architecture of the
	 output file, not the input files.  */
      if ((*sym_hash)->root.type == bfd_link_hash_common
	  && ((*sym_hash)->root.u.c.p->alignment_power >
	      bfd_get_arch_info (abfd)->section_align_power))
	(*sym_hash)->root.u.c.p->alignment_power =
	  bfd_get_arch_info (abfd)->section_align_power;

      /* If this is a set symbol, and we are not building sets, then
	 it is possible for the hash entry to not have been set.  In
	 such a case, treat the symbol as not globally defined.  */
      if ((*sym_hash)->root.type == bfd_link_hash_new)
	{
	  BFD_ASSERT ((flags & BSF_CONSTRUCTOR) != 0);
	  *sym_hash = NULL;
	}

      if (type == (N_INDR | N_EXT) || type == N_WARNING)
	++sym_hash;
    }

  return TRUE;
}

/* Free up the internal symbols read from an a.out file.  */

static bfd_boolean
aout_link_free_symbols (bfd *abfd)
{
  if (obj_aout_external_syms (abfd) != NULL)
    {
#ifdef USE_MMAP
      bfd_free_window (&obj_aout_sym_window (abfd));
#else
      free ((void *) obj_aout_external_syms (abfd));
#endif
      obj_aout_external_syms (abfd) = NULL;
    }
  if (obj_aout_external_strings (abfd) != NULL)
    {
#ifdef USE_MMAP
      bfd_free_window (&obj_aout_string_window (abfd));
#else
      free ((void *) obj_aout_external_strings (abfd));
#endif
      obj_aout_external_strings (abfd) = NULL;
    }
  return TRUE;
}

/* Add symbols from an a.out object file.  */

static bfd_boolean
aout_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  if (! aout_get_external_symbols (abfd))
    return FALSE;
  if (! aout_link_add_symbols (abfd, info))
    return FALSE;
  if (! info->keep_memory)
    {
      if (! aout_link_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Look through the internal symbols to see if this object file should
   be included in the link.  We should include this object file if it
   defines any symbols which are currently undefined.  If this object
   file defines a common symbol, then we may adjust the size of the
   known symbol but we do not include the object file in the link
   (unless there is some other reason to include it).  */

static bfd_boolean
aout_link_check_ar_symbols (bfd *abfd,
			    struct bfd_link_info *info,
			    bfd_boolean *pneeded,
			    bfd **subsbfd)
{
  struct external_nlist *p;
  struct external_nlist *pend;
  char *strings;

  *pneeded = FALSE;

  /* Look through all the symbols.  */
  p = obj_aout_external_syms (abfd);
  pend = p + obj_aout_external_sym_count (abfd);
  strings = obj_aout_external_strings (abfd);
  for (; p < pend; p++)
    {
      int type = H_GET_8 (abfd, p->e_type);
      const char *name;
      struct bfd_link_hash_entry *h;

      /* Ignore symbols that are not externally visible.  This is an
	 optimization only, as we check the type more thoroughly
	 below.  */
      if (((type & N_EXT) == 0
	   || (type & N_STAB) != 0
	   || type == N_FN)
	  && type != N_WEAKA
	  && type != N_WEAKT
	  && type != N_WEAKD
	  && type != N_WEAKB)
	{
	  if (type == N_WARNING
	      || type == N_INDR)
	    ++p;
	  continue;
	}

      name = strings + GET_WORD (abfd, p->e_strx);
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* We are only interested in symbols that are currently
	 undefined or common.  */
      if (h == NULL
	  || (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common))
	{
	  if (type == (N_INDR | N_EXT))
	    ++p;
	  continue;
	}

      if (type == (N_TEXT | N_EXT)
	  || type == (N_DATA | N_EXT)
	  || type == (N_BSS | N_EXT)
	  || type == (N_ABS | N_EXT)
	  || type == (N_INDR | N_EXT))
	{
	  /* This object file defines this symbol.  We must link it
	     in.  This is true regardless of whether the current
	     definition of the symbol is undefined or common.

             If the current definition is common, we have a case in
	     which we have already seen an object file including:
	         int a;
	     and this object file from the archive includes:
	         int a = 5;
	     In such a case, whether to include this object is target
             dependant for backward compatibility.

	     FIXME: The SunOS 4.1.3 linker will pull in the archive
	     element if the symbol is defined in the .data section,
	     but not if it is defined in the .text section.  That
	     seems a bit crazy to me, and it has not been implemented
	     yet.  However, it might be correct.  */
	  if (h->type == bfd_link_hash_common)
	    {
	      int skip = 0;

	      switch (info->common_skip_ar_symbols)
		{
		case bfd_link_common_skip_text:
		  skip = (type == (N_TEXT | N_EXT));
		  break;
		case bfd_link_common_skip_data:
		  skip = (type == (N_DATA | N_EXT));
		  break;
		default:
		case bfd_link_common_skip_all:
		  skip = 1;
		  break;
		}

	      if (skip)
		continue;
	    }

	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, name, subsbfd))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}

      if (type == (N_UNDF | N_EXT))
	{
	  bfd_vma value;

	  value = GET_WORD (abfd, p->e_value);
	  if (value != 0)
	    {
	      /* This symbol is common in the object from the archive
		 file.  */
	      if (h->type == bfd_link_hash_undefined)
		{
		  bfd *symbfd;
		  unsigned int power;

		  symbfd = h->u.undef.abfd;
		  if (symbfd == NULL)
		    {
		      /* This symbol was created as undefined from
			 outside BFD.  We assume that we should link
			 in the object file.  This is done for the -u
			 option in the linker.  */
		      if (!(*info->callbacks
			    ->add_archive_element) (info, abfd, name, subsbfd))
			return FALSE;
		      *pneeded = TRUE;
		      return TRUE;
		    }
		  /* Turn the current link symbol into a common
		     symbol.  It is already on the undefs list.  */
		  h->type = bfd_link_hash_common;
		  h->u.c.p = (struct bfd_link_hash_common_entry *)
		    bfd_hash_allocate (&info->hash->table,
				       sizeof (struct bfd_link_hash_common_entry));
		  if (h->u.c.p == NULL)
		    return FALSE;

		  h->u.c.size = value;

		  /* FIXME: This isn't quite right.  The maximum
		     alignment of a common symbol should be set by the
		     architecture of the output file, not of the input
		     file.  */
		  power = bfd_log2 (value);
		  if (power > bfd_get_arch_info (abfd)->section_align_power)
		    power = bfd_get_arch_info (abfd)->section_align_power;
		  h->u.c.p->alignment_power = power;

		  h->u.c.p->section = bfd_make_section_old_way (symbfd,
								"COMMON");
		}
	      else
		{
		  /* Adjust the size of the common symbol if
		     necessary.  */
		  if (value > h->u.c.size)
		    h->u.c.size = value;
		}
	    }
	}

      if (type == N_WEAKA
	  || type == N_WEAKT
	  || type == N_WEAKD
	  || type == N_WEAKB)
	{
	  /* This symbol is weak but defined.  We must pull it in if
	     the current link symbol is undefined, but we don't want
	     it if the current link symbol is common.  */
	  if (h->type == bfd_link_hash_undefined)
	    {
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}
    }

  /* We do not need this object file.  */
  return TRUE;
}
/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called from
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
aout_link_check_archive_element (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean *pneeded)
{
  bfd *oldbfd;
  bfd_boolean needed;

  if (!aout_get_external_symbols (abfd))
    return FALSE;

  oldbfd = abfd;
  if (!aout_link_check_ar_symbols (abfd, info, pneeded, &abfd))
    return FALSE;

  needed = *pneeded;
  if (needed)
    {
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (abfd != oldbfd)
	{
	  if (!info->keep_memory
	      && !aout_link_free_symbols (oldbfd))
	    return FALSE;
	  if (!aout_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!aout_link_add_symbols (abfd, info))
	return FALSE;
    }

  if (!info->keep_memory || !needed)
    {
      if (!aout_link_free_symbols (abfd))
	return FALSE;
    }

  return TRUE;
}

/* Given an a.out BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
NAME (aout, link_add_symbols) (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return aout_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return _bfd_generic_link_add_archive_symbols
	(abfd, info, aout_link_check_archive_element);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* A hash table used for header files with N_BINCL entries.  */

struct aout_link_includes_table
{
  struct bfd_hash_table root;
};

/* A linked list of totals that we have found for a particular header
   file.  */

struct aout_link_includes_totals
{
  struct aout_link_includes_totals *next;
  bfd_vma total;
};

/* An entry in the header file hash table.  */

struct aout_link_includes_entry
{
  struct bfd_hash_entry root;
  /* List of totals we have found for this file.  */
  struct aout_link_includes_totals *totals;
};

/* Look up an entry in an the header file hash table.  */

#define aout_link_includes_lookup(table, string, create, copy)		\
  ((struct aout_link_includes_entry *)					\
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

/* During the final link step we need to pass around a bunch of
   information, so we do it in an instance of this structure.  */

struct aout_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output bfd.  */
  bfd *output_bfd;
  /* Reloc file positions.  */
  file_ptr treloff, dreloff;
  /* File position of symbols.  */
  file_ptr symoff;
  /* String table.  */
  struct bfd_strtab_hash *strtab;
  /* Header file hash table.  */
  struct aout_link_includes_table includes;
  /* A buffer large enough to hold the contents of any section.  */
  bfd_byte *contents;
  /* A buffer large enough to hold the relocs of any section.  */
  void * relocs;
  /* A buffer large enough to hold the symbol map of any input BFD.  */
  int *symbol_map;
  /* A buffer large enough to hold output symbols of any input BFD.  */
  struct external_nlist *output_syms;
};

/* The function to create a new entry in the header file hash table.  */

static struct bfd_hash_entry *
aout_link_includes_newfunc (struct bfd_hash_entry *entry,
			    struct bfd_hash_table *table,
			    const char *string)
{
  struct aout_link_includes_entry *ret =
    (struct aout_link_includes_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = (struct aout_link_includes_entry *)
        bfd_hash_allocate (table, sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct aout_link_includes_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
  if (ret)
    {
      /* Set local fields.  */
      ret->totals = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Write out a symbol that was not associated with an a.out input
   object.  */

static bfd_boolean
aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)
{
  struct aout_link_hash_entry *h = (struct aout_link_hash_entry *) bh;
  struct aout_final_link_info *flaginfo = (struct aout_final_link_info *) data;
  bfd *output_bfd;
  int type;
  bfd_vma val;
  struct external_nlist outsym;
  bfd_size_type indx;
  bfd_size_type amt;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct aout_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  output_bfd = flaginfo->output_bfd;

  if (aout_backend_info (output_bfd)->write_dynamic_symbol != NULL)
    {
      if (! ((*aout_backend_info (output_bfd)->write_dynamic_symbol)
	     (output_bfd, flaginfo->info, h)))
	{
	  /* FIXME: No way to handle errors.  */
	  abort ();
	}
    }

  if (h->written)
    return TRUE;

  h->written = TRUE;

  /* An indx of -2 means the symbol must be written.  */
  if (h->indx != -2
      && (flaginfo->info->strip == strip_all
	  || (flaginfo->info->strip == strip_some
	      && bfd_hash_lookup (flaginfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
    return TRUE;

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_warning:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return TRUE;
    case bfd_link_hash_new:
      /* This can happen for set symbols when sets are not being
         built.  */
      return TRUE;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;

	sec = h->root.u.def.section->output_section;
	BFD_ASSERT (bfd_is_abs_section (sec)
		    || sec->owner == output_bfd);
	if (sec == obj_textsec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_TEXT : N_WEAKT;
	else if (sec == obj_datasec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_DATA : N_WEAKD;
	else if (sec == obj_bsssec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_BSS : N_WEAKB;
	else
	  type = h->root.type == bfd_link_hash_defined ? N_ABS : N_WEAKA;
	type |= N_EXT;
	val = (h->root.u.def.value
	       + sec->vma
	       + h->root.u.def.section->output_offset);
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
      break;
    case bfd_link_hash_indirect:
      /* We ignore these symbols, since the indirected symbol is
	 already in the hash table.  */
      return TRUE;
    }

  H_PUT_8 (output_bfd, type, outsym.e_type);
  H_PUT_8 (output_bfd, 0, outsym.e_other);
  H_PUT_16 (output_bfd, 0, outsym.e_desc);
  indx = add_to_stringtab (output_bfd, flaginfo->strtab, h->root.root.string,
			   FALSE);
  if (indx == - (bfd_size_type) 1)
    /* FIXME: No way to handle errors.  */
    abort ();

  PUT_WORD (output_bfd, indx, outsym.e_strx);
  PUT_WORD (output_bfd, val, outsym.e_value);

  amt = EXTERNAL_NLIST_SIZE;
  if (bfd_seek (output_bfd, flaginfo->symoff, SEEK_SET) != 0
      || bfd_bwrite ((void *) &outsym, amt, output_bfd) != amt)
    /* FIXME: No way to handle errors.  */
    abort ();

  flaginfo->symoff += EXTERNAL_NLIST_SIZE;
  h->indx = obj_aout_external_sym_count (output_bfd);
  ++obj_aout_external_sym_count (output_bfd);

  return TRUE;
}

/* Handle a link order which is supposed to generate a reloc.  */

static bfd_boolean
aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,
			    asection *o,
			    struct bfd_link_order *p)
{
  struct bfd_link_order_reloc *pr;
  int r_index;
  int r_extern;
  reloc_howto_type *howto;
  file_ptr *reloff_ptr = NULL;
  struct reloc_std_external srel;
  struct reloc_ext_external erel;
  void * rel_ptr;
  bfd_size_type amt;

  pr = p->u.reloc.p;

  if (p->type == bfd_section_reloc_link_order)
    {
      r_extern = 0;
      if (bfd_is_abs_section (pr->u.section))
	r_index = N_ABS | N_EXT;
      else
	{
	  BFD_ASSERT (pr->u.section->owner == flaginfo->output_bfd);
	  r_index = pr->u.section->target_index;
	}
    }
  else
    {
      struct aout_link_hash_entry *h;

      BFD_ASSERT (p->type == bfd_symbol_reloc_link_order);
      r_extern = 1;
      h = ((struct aout_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (flaginfo->output_bfd, flaginfo->info,
					 pr->u.name, FALSE, FALSE, TRUE));
      if (h != NULL
	  && h->indx >= 0)
	r_index = h->indx;
      else if (h != NULL)
	{
	  /* We decided to strip this symbol, but it turns out that we
	     can't.  Note that we lose the other and desc information
	     here.  I don't think that will ever matter for a global
	     symbol.  */
	  h->indx = -2;
	  h->written = FALSE;
	  if (!aout_link_write_other_symbol (&h->root.root, flaginfo))
	    return FALSE;
	  r_index = h->indx;
	}
      else
	{
	  if (! ((*flaginfo->info->callbacks->unattached_reloc)
		 (flaginfo->info, pr->u.name, NULL, NULL, (bfd_vma) 0)))
	    return FALSE;
	  r_index = 0;
	}
    }

  howto = bfd_reloc_type_lookup (flaginfo->output_bfd, pr->reloc);
  if (howto == 0)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (o == obj_textsec (flaginfo->output_bfd))
    reloff_ptr = &flaginfo->treloff;
  else if (o == obj_datasec (flaginfo->output_bfd))
    reloff_ptr = &flaginfo->dreloff;
  else
    abort ();

  if (obj_reloc_entry_size (flaginfo->output_bfd) == RELOC_STD_SIZE)
    {
#ifdef MY_put_reloc
      MY_put_reloc (flaginfo->output_bfd, r_extern, r_index, p->offset, howto,
		    &srel);
#else
      {
	int r_pcrel;
	int r_baserel;
	int r_jmptable;
	int r_relative;
	int r_length;

	r_pcrel = (int) howto->pc_relative;
	r_baserel = (howto->type & 8) != 0;
	r_jmptable = (howto->type & 16) != 0;
	r_relative = (howto->type & 32) != 0;
	r_length = howto->size;

	PUT_WORD (flaginfo->output_bfd, p->offset, srel.r_address);
	if (bfd_header_big_endian (flaginfo->output_bfd))
	  {
	    srel.r_index[0] = r_index >> 16;
	    srel.r_index[1] = r_index >> 8;
	    srel.r_index[2] = r_index;
	    srel.r_type[0] =
	      ((r_extern ?     RELOC_STD_BITS_EXTERN_BIG : 0)
	       | (r_pcrel ?    RELOC_STD_BITS_PCREL_BIG : 0)
	       | (r_baserel ?  RELOC_STD_BITS_BASEREL_BIG : 0)
	       | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_BIG : 0)
	       | (r_relative ? RELOC_STD_BITS_RELATIVE_BIG : 0)
	       | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
	  }
	else
	  {
	    srel.r_index[2] = r_index >> 16;
	    srel.r_index[1] = r_index >> 8;
	    srel.r_index[0] = r_index;
	    srel.r_type[0] =
	      ((r_extern ?     RELOC_STD_BITS_EXTERN_LITTLE : 0)
	       | (r_pcrel ?    RELOC_STD_BITS_PCREL_LITTLE : 0)
	       | (r_baserel ?  RELOC_STD_BITS_BASEREL_LITTLE : 0)
	       | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_LITTLE : 0)
	       | (r_relative ? RELOC_STD_BITS_RELATIVE_LITTLE : 0)
	       | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
	  }
      }
#endif
      rel_ptr = (void *) &srel;

      /* We have to write the addend into the object file, since
	 standard a.out relocs are in place.  It would be more
	 reliable if we had the current contents of the file here,
	 rather than assuming zeroes, but we can't read the file since
	 it was opened using bfd_openw.  */
      if (pr->addend != 0)
	{
	  bfd_size_type size;
	  bfd_reloc_status_type r;
	  bfd_byte *buf;
	  bfd_boolean ok;

	  size = bfd_get_reloc_size (howto);
	  buf = (bfd_byte *) bfd_zmalloc (size);
	  if (buf == NULL)
	    return FALSE;
	  r = MY_relocate_contents (howto, flaginfo->output_bfd,
				    (bfd_vma) pr->addend, buf);
	  switch (r)
	    {
	    case bfd_reloc_ok:
	      break;
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      if (! ((*flaginfo->info->callbacks->reloc_overflow)
		     (flaginfo->info, NULL,
		      (p->type == bfd_section_reloc_link_order
		       ? bfd_section_name (flaginfo->output_bfd,
					   pr->u.section)
		       : pr->u.name),
		      howto->name, pr->addend, NULL, NULL, (bfd_vma) 0)))
		{
		  free (buf);
		  return FALSE;
		}
	      break;
	    }
	  ok = bfd_set_section_contents (flaginfo->output_bfd, o, (void *) buf,
					 (file_ptr) p->offset, size);
	  free (buf);
	  if (! ok)
	    return FALSE;
	}
    }
  else
    {
#ifdef MY_put_ext_reloc
      MY_put_ext_reloc (flaginfo->output_bfd, r_extern, r_index, p->offset,
			howto, &erel, pr->addend);
#else
      PUT_WORD (flaginfo->output_bfd, p->offset, erel.r_address);

      if (bfd_header_big_endian (flaginfo->output_bfd))
	{
	  erel.r_index[0] = r_index >> 16;
	  erel.r_index[1] = r_index >> 8;
	  erel.r_index[2] = r_index;
	  erel.r_type[0] =
	    ((r_extern ? RELOC_EXT_BITS_EXTERN_BIG : 0)
	     | (howto->type << RELOC_EXT_BITS_TYPE_SH_BIG));
	}
      else
	{
	  erel.r_index[2] = r_index >> 16;
	  erel.r_index[1] = r_index >> 8;
	  erel.r_index[0] = r_index;
	  erel.r_type[0] =
	    (r_extern ? RELOC_EXT_BITS_EXTERN_LITTLE : 0)
	      | (howto->type << RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}

      PUT_WORD (flaginfo->output_bfd, (bfd_vma) pr->addend, erel.r_addend);
#endif /* MY_put_ext_reloc */

      rel_ptr = (void *) &erel;
    }

  amt = obj_reloc_entry_size (flaginfo->output_bfd);
  if (bfd_seek (flaginfo->output_bfd, *reloff_ptr, SEEK_SET) != 0
      || bfd_bwrite (rel_ptr, amt, flaginfo->output_bfd) != amt)
    return FALSE;

  *reloff_ptr += obj_reloc_entry_size (flaginfo->output_bfd);

  /* Assert that the relocs have not run into the symbols, and that n
     the text relocs have not run into the data relocs.  */
  BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (flaginfo->output_bfd)
	      && (reloff_ptr != &flaginfo->treloff
		  || (*reloff_ptr
		      <= obj_datasec (flaginfo->output_bfd)->rel_filepos)));

  return TRUE;
}

/* Get the section corresponding to a reloc index.  */

static INLINE asection *
aout_reloc_index_to_section (bfd *abfd, int indx)
{
  switch (indx & N_TYPE)
    {
    case N_TEXT:   return obj_textsec (abfd);
    case N_DATA:   return obj_datasec (abfd);
    case N_BSS:    return obj_bsssec (abfd);
    case N_ABS:
    case N_UNDF:   return bfd_abs_section_ptr;
    default:       abort ();
    }
  return NULL;
}

/* Relocate an a.out section using standard a.out relocs.  */

static bfd_boolean
aout_link_input_section_std (struct aout_final_link_info *flaginfo,
			     bfd *input_bfd,
			     asection *input_section,
			     struct reloc_std_external *relocs,
			     bfd_size_type rel_size,
			     bfd_byte *contents)
{
  bfd_boolean (*check_dynamic_reloc)
    (struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, void *, bfd_byte *, bfd_boolean *,
	     bfd_vma *);
  bfd *output_bfd;
  bfd_boolean relocatable;
  struct external_nlist *syms;
  char *strings;
  struct aout_link_hash_entry **sym_hashes;
  int *symbol_map;
  bfd_size_type reloc_count;
  struct reloc_std_external *rel;
  struct reloc_std_external *rel_end;

  output_bfd = flaginfo->output_bfd;
  check_dynamic_reloc = aout_backend_info (output_bfd)->check_dynamic_reloc;

  BFD_ASSERT (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE);
  BFD_ASSERT (input_bfd->xvec->header_byteorder
	      == output_bfd->xvec->header_byteorder);

  relocatable = flaginfo->info->relocatable;
  syms = obj_aout_external_syms (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  sym_hashes = obj_aout_sym_hashes (input_bfd);
  symbol_map = flaginfo->symbol_map;

  reloc_count = rel_size / RELOC_STD_SIZE;
  rel = relocs;
  rel_end = rel + reloc_count;
  for (; rel < rel_end; rel++)
    {
      bfd_vma r_addr;
      int r_index;
      int r_extern;
      int r_pcrel;
      int r_baserel = 0;
      reloc_howto_type *howto;
      struct aout_link_hash_entry *h = NULL;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_addr = GET_SWORD (input_bfd, rel->r_address);

#ifdef MY_reloc_howto
      howto = MY_reloc_howto (input_bfd, rel, r_index, r_extern, r_pcrel);
#else
      {
	int r_jmptable;
	int r_relative;
	int r_length;
	unsigned int howto_idx;

	if (bfd_header_big_endian (input_bfd))
	  {
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
			  | rel->r_index[2]);
	    r_extern  = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
	    r_pcrel   = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
	    r_baserel = (0 != (rel->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
	    r_jmptable= (0 != (rel->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
	    r_relative= (0 != (rel->r_type[0] & RELOC_STD_BITS_RELATIVE_BIG));
	    r_length  = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
			 >> RELOC_STD_BITS_LENGTH_SH_BIG);
	  }
	else
	  {
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
			 | rel->r_index[0]);
	    r_extern  = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
	    r_pcrel   = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
	    r_baserel = (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_BASEREL_LITTLE));
	    r_jmptable= (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_JMPTABLE_LITTLE));
	    r_relative= (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_RELATIVE_LITTLE));
	    r_length  = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
			 >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
	  }

	howto_idx = (r_length + 4 * r_pcrel + 8 * r_baserel
		     + 16 * r_jmptable + 32 * r_relative);
	if (howto_idx < TABLE_SIZE (howto_table_std))
	  howto = howto_table_std + howto_idx;
	else
	  howto = NULL;
      }
#endif

      if (howto == NULL)
	{
	  (*flaginfo->info->callbacks->einfo)
	    (_("%P: %B: unexpected relocation type\n"), input_bfd);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (relocatable)
	{
	  /* We are generating a relocatable output file, and must
	     modify the reloc accordingly.  */
	  if (r_extern)
	    {
	      /* If we know the symbol this relocation is against,
		 convert it into a relocation against a section.  This
		 is what the native linker does.  */
	      h = sym_hashes[r_index];
	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  asection *output_section;

		  /* Change the r_extern value.  */
		  if (bfd_header_big_endian (output_bfd))
		    rel->r_type[0] &=~ RELOC_STD_BITS_EXTERN_BIG;
		  else
		    rel->r_type[0] &=~ RELOC_STD_BITS_EXTERN_LITTLE;

		  /* Compute a new r_index.  */
		  output_section = h->root.u.def.section->output_section;
		  if (output_section == obj_textsec (output_bfd))
		    r_index = N_TEXT;
		  else if (output_section == obj_datasec (output_bfd))
		    r_index = N_DATA;
		  else if (output_section == obj_bsssec (output_bfd))
		    r_index = N_BSS;
		  else
		    r_index = N_ABS;

		  /* Add the symbol value and the section VMA to the
		     addend stored in the contents.  */
		  relocation = (h->root.u.def.value
				+ output_section->vma
				+ h->root.u.def.section->output_offset);
		}
	      else
		{
		  /* We must change r_index according to the symbol
		     map.  */
		  r_index = symbol_map[r_index];

		  if (r_index == -1)
		    {
		      if (h != NULL)
			{
			  /* We decided to strip this symbol, but it
                             turns out that we can't.  Note that we
                             lose the other and desc information here.
                             I don't think that will ever matter for a
                             global symbol.  */
			  if (h->indx < 0)
			    {
			      h->indx = -2;
			      h->written = FALSE;
			      if (!aout_link_write_other_symbol (&h->root.root,
								 flaginfo))
				return FALSE;
			    }
			  r_index = h->indx;
			}
		      else
			{
			  const char *name;

			  name = strings + GET_WORD (input_bfd,
						     syms[r_index].e_strx);
			  if (! ((*flaginfo->info->callbacks->unattached_reloc)
				 (flaginfo->info, name, input_bfd, input_section,
				  r_addr)))
			    return FALSE;
			  r_index = 0;
			}
		    }

		  relocation = 0;
		}

	      /* Write out the new r_index value.  */
	      if (bfd_header_big_endian (output_bfd))
		{
		  rel->r_index[0] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[2] = r_index;
		}
	      else
		{
		  rel->r_index[2] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[0] = r_index;
		}
	    }
	  else
	    {
	      asection *section;

	      /* This is a relocation against a section.  We must
		 adjust by the amount that the section moved.  */
	      section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (section->output_section->vma
			    + section->output_offset
			    - section->vma);
	    }

	  /* Change the address of the relocation.  */
	  PUT_WORD (output_bfd,
		    r_addr + input_section->output_offset,
		    rel->r_address);

	  /* Adjust a PC relative relocation by removing the reference
	     to the original address in the section and including the
	     reference to the new address.  */
	  if (r_pcrel)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   - input_section->vma);

#ifdef MY_relocatable_reloc
	  MY_relocatable_reloc (howto, output_bfd, rel, relocation, r_addr);
#endif

	  if (relocation == 0)
	    r = bfd_reloc_ok;
	  else
	    r = MY_relocate_contents (howto,
					input_bfd, relocation,
					contents + r_addr);
	}
      else
	{
	  bfd_boolean hundef;

	  /* We are generating an executable, and must do a full
	     relocation.  */
	  hundef = FALSE;

	  if (r_extern)
	    {
	      h = sym_hashes[r_index];

	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  relocation = (h->root.u.def.value
				+ h->root.u.def.section->output_section->vma
				+ h->root.u.def.section->output_offset);
		}
	      else if (h != NULL
		       && h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
	      else
		{
		  hundef = TRUE;
		  relocation = 0;
		}
	    }
	  else
	    {
	      asection *section;

	      section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (section->output_section->vma
			    + section->output_offset
			    - section->vma);
	      if (r_pcrel)
		relocation += input_section->vma;
	    }

	  if (check_dynamic_reloc != NULL)
	    {
	      bfd_boolean skip;

	      if (! ((*check_dynamic_reloc)
		     (flaginfo->info, input_bfd, input_section, h,
		      (void *) rel, contents, &skip, &relocation)))
		return FALSE;
	      if (skip)
		continue;
	    }

	  /* Now warn if a global symbol is undefined.  We could not
             do this earlier, because check_dynamic_reloc might want
             to skip this reloc.  */
	  if (hundef && ! flaginfo->info->shared && ! r_baserel)
	    {
	      const char *name;

	      if (h != NULL)
		name = h->root.root.string;
	      else
		name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
	      if (! ((*flaginfo->info->callbacks->undefined_symbol)
		     (flaginfo->info, name, input_bfd, input_section,
		     r_addr, TRUE)))
		return FALSE;
	    }

	  r = MY_final_link_relocate (howto,
				      input_bfd, input_section,
				      contents, r_addr, relocation,
				      (bfd_vma) 0);
	}

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else if (r_extern)
		  name = strings + GET_WORD (input_bfd,
					     syms[r_index].e_strx);
		else
		  {
		    asection *s;

		    s = aout_reloc_index_to_section (input_bfd, r_index);
		    name = bfd_section_name (input_bfd, s);
		  }
		if (! ((*flaginfo->info->callbacks->reloc_overflow)
		       (flaginfo->info, (h ? &h->root : NULL), name,
			howto->name, (bfd_vma) 0, input_bfd,
			input_section, r_addr)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* Relocate an a.out section using extended a.out relocs.  */

static bfd_boolean
aout_link_input_section_ext (struct aout_final_link_info *flaginfo,
			     bfd *input_bfd,
			     asection *input_section,
			     struct reloc_ext_external *relocs,
			     bfd_size_type rel_size,
			     bfd_byte *contents)
{
  bfd_boolean (*check_dynamic_reloc)
    (struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, void *, bfd_byte *, bfd_boolean *,
	     bfd_vma *);
  bfd *output_bfd;
  bfd_boolean relocatable;
  struct external_nlist *syms;
  char *strings;
  struct aout_link_hash_entry **sym_hashes;
  int *symbol_map;
  bfd_size_type reloc_count;
  struct reloc_ext_external *rel;
  struct reloc_ext_external *rel_end;

  output_bfd = flaginfo->output_bfd;
  check_dynamic_reloc = aout_backend_info (output_bfd)->check_dynamic_reloc;

  BFD_ASSERT (obj_reloc_entry_size (input_bfd) == RELOC_EXT_SIZE);
  BFD_ASSERT (input_bfd->xvec->header_byteorder
	      == output_bfd->xvec->header_byteorder);

  relocatable = flaginfo->info->relocatable;
  syms = obj_aout_external_syms (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  sym_hashes = obj_aout_sym_hashes (input_bfd);
  symbol_map = flaginfo->symbol_map;

  reloc_count = rel_size / RELOC_EXT_SIZE;
  rel = relocs;
  rel_end = rel + reloc_count;
  for (; rel < rel_end; rel++)
    {
      bfd_vma r_addr;
      int r_index;
      int r_extern;
      unsigned int r_type;
      bfd_vma r_addend;
      struct aout_link_hash_entry *h = NULL;
      asection *r_section = NULL;
      bfd_vma relocation;

      r_addr = GET_SWORD (input_bfd, rel->r_address);

      if (bfd_header_big_endian (input_bfd))
	{
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
		      | rel->r_index[2]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
	  r_type   = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		      >> RELOC_EXT_BITS_TYPE_SH_BIG);
	}
      else
	{
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
		      | rel->r_index[0]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
	  r_type   = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		      >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}

      r_addend = GET_SWORD (input_bfd, rel->r_addend);

      if (r_type >= TABLE_SIZE (howto_table_ext))
	{
	  (*flaginfo->info->callbacks->einfo)
	    (_("%P: %B: unexpected relocation type\n"), input_bfd);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (relocatable)
	{
	  /* We are generating a relocatable output file, and must
	     modify the reloc accordingly.  */
	  if (r_extern
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
	    {
	      /* If we know the symbol this relocation is against,
		 convert it into a relocation against a section.  This
		 is what the native linker does.  */
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
		h = NULL;
	      else
		h = sym_hashes[r_index];
	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  asection *output_section;

		  /* Change the r_extern value.  */
		  if (bfd_header_big_endian (output_bfd))
		    rel->r_type[0] &=~ RELOC_EXT_BITS_EXTERN_BIG;
		  else
		    rel->r_type[0] &=~ RELOC_EXT_BITS_EXTERN_LITTLE;

		  /* Compute a new r_index.  */
		  output_section = h->root.u.def.section->output_section;
		  if (output_section == obj_textsec (output_bfd))
		    r_index = N_TEXT;
		  else if (output_section == obj_datasec (output_bfd))
		    r_index = N_DATA;
		  else if (output_section == obj_bsssec (output_bfd))
		    r_index = N_BSS;
		  else
		    r_index = N_ABS;

		  /* Add the symbol value and the section VMA to the
		     addend.  */
		  relocation = (h->root.u.def.value
				+ output_section->vma
				+ h->root.u.def.section->output_offset);

		  /* Now RELOCATION is the VMA of the final
		     destination.  If this is a PC relative reloc,
		     then ADDEND is the negative of the source VMA.
		     We want to set ADDEND to the difference between
		     the destination VMA and the source VMA, which
		     means we must adjust RELOCATION by the change in
		     the source VMA.  This is done below.  */
		}
	      else
		{
		  /* We must change r_index according to the symbol
		     map.  */
		  r_index = symbol_map[r_index];

		  if (r_index == -1)
		    {
		      if (h != NULL)
			{
			  /* We decided to strip this symbol, but it
                             turns out that we can't.  Note that we
                             lose the other and desc information here.
                             I don't think that will ever matter for a
                             global symbol.  */
			  if (h->indx < 0)
			    {
			      h->indx = -2;
			      h->written = FALSE;
			      if (!aout_link_write_other_symbol (&h->root.root,
								 flaginfo))
				return FALSE;
			    }
			  r_index = h->indx;
			}
		      else
			{
			  const char *name;

			  name = strings + GET_WORD (input_bfd,
						     syms[r_index].e_strx);
			  if (! ((*flaginfo->info->callbacks->unattached_reloc)
				 (flaginfo->info, name, input_bfd, input_section,
				  r_addr)))
			    return FALSE;
			  r_index = 0;
			}
		    }

		  relocation = 0;

		  /* If this is a PC relative reloc, then the addend
		     is the negative of the source VMA.  We must
		     adjust it by the change in the source VMA.  This
		     is done below.  */
		}

	      /* Write out the new r_index value.  */
	      if (bfd_header_big_endian (output_bfd))
		{
		  rel->r_index[0] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[2] = r_index;
		}
	      else
		{
		  rel->r_index[2] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[0] = r_index;
		}
	    }
	  else
	    {
	      /* This is a relocation against a section.  We must
		 adjust by the amount that the section moved.  */
	      r_section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    - r_section->vma);

	      /* If this is a PC relative reloc, then the addend is
		 the difference in VMA between the destination and the
		 source.  We have just adjusted for the change in VMA
		 of the destination, so we must also adjust by the
		 change in VMA of the source.  This is done below.  */
	    }

	  /* As described above, we must always adjust a PC relative
	     reloc by the change in VMA of the source.  However, if
	     pcrel_offset is set, then the addend does not include the
	     location within the section, in which case we don't need
	     to adjust anything.  */
	  if (howto_table_ext[r_type].pc_relative
	      && ! howto_table_ext[r_type].pcrel_offset)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   - input_section->vma);

	  /* Change the addend if necessary.  */
	  if (relocation != 0)
	    PUT_WORD (output_bfd, r_addend + relocation, rel->r_addend);

	  /* Change the address of the relocation.  */
	  PUT_WORD (output_bfd,
		    r_addr + input_section->output_offset,
		    rel->r_address);
	}
      else
	{
	  bfd_boolean hundef;
	  bfd_reloc_status_type r;

	  /* We are generating an executable, and must do a full
	     relocation.  */
	  hundef = FALSE;

	  if (r_extern)
	    {
	      h = sym_hashes[r_index];

	      if (h != NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  relocation = (h->root.u.def.value
				+ h->root.u.def.section->output_section->vma
				+ h->root.u.def.section->output_offset);
		}
	      else if (h != NULL
		       && h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
	      else
		{
		  hundef = TRUE;
		  relocation = 0;
		}
	    }
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
	    {
	      struct external_nlist *sym;
	      int type;

	      /* For base relative relocs, r_index is always an index
                 into the symbol table, even if r_extern is 0.  */
	      sym = syms + r_index;
	      type = H_GET_8 (input_bfd, sym->e_type);
	      if ((type & N_TYPE) == N_TEXT
		  || type == N_WEAKT)
		r_section = obj_textsec (input_bfd);
	      else if ((type & N_TYPE) == N_DATA
		       || type == N_WEAKD)
		r_section = obj_datasec (input_bfd);
	      else if ((type & N_TYPE) == N_BSS
		       || type == N_WEAKB)
		r_section = obj_bsssec (input_bfd);
	      else if ((type & N_TYPE) == N_ABS
		       || type == N_WEAKA)
		r_section = bfd_abs_section_ptr;
	      else
		abort ();
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    + (GET_WORD (input_bfd, sym->e_value)
			       - r_section->vma));
	    }
	  else
	    {
	      r_section = aout_reloc_index_to_section (input_bfd, r_index);

	      /* If this is a PC relative reloc, then R_ADDEND is the
		 difference between the two vmas, or
		   old_dest_sec + old_dest_off - (old_src_sec + old_src_off)
		 where
		   old_dest_sec == section->vma
		 and
		   old_src_sec == input_section->vma
		 and
		   old_src_off == r_addr

		 _bfd_final_link_relocate expects RELOCATION +
		 R_ADDEND to be the VMA of the destination minus
		 r_addr (the minus r_addr is because this relocation
		 is not pcrel_offset, which is a bit confusing and
		 should, perhaps, be changed), or
		   new_dest_sec
		 where
		   new_dest_sec == output_section->vma + output_offset
		 We arrange for this to happen by setting RELOCATION to
		   new_dest_sec + old_src_sec - old_dest_sec

		 If this is not a PC relative reloc, then R_ADDEND is
		 simply the VMA of the destination, so we set
		 RELOCATION to the change in the destination VMA, or
		   new_dest_sec - old_dest_sec
		 */
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    - r_section->vma);
	      if (howto_table_ext[r_type].pc_relative)
		relocation += input_section->vma;
	    }

	  if (check_dynamic_reloc != NULL)
	    {
	      bfd_boolean skip;

	      if (! ((*check_dynamic_reloc)
		     (flaginfo->info, input_bfd, input_section, h,
		      (void *) rel, contents, &skip, &relocation)))
		return FALSE;
	      if (skip)
		continue;
	    }

	  /* Now warn if a global symbol is undefined.  We could not
             do this earlier, because check_dynamic_reloc might want
             to skip this reloc.  */
	  if (hundef
	      && ! flaginfo->info->shared
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
	    {
	      const char *name;

	      if (h != NULL)
		name = h->root.root.string;
	      else
		name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
	      if (! ((*flaginfo->info->callbacks->undefined_symbol)
		     (flaginfo->info, name, input_bfd, input_section,
		     r_addr, TRUE)))
		return FALSE;
	    }

	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
	    r = MY_final_link_relocate (howto_table_ext + r_type,
					input_bfd, input_section,
					contents, r_addr, relocation,
					r_addend);
	  else
	    {
	      bfd_vma x;

	      x = bfd_get_32 (input_bfd, contents + r_addr);
	      x = x + relocation + r_addend;
	      bfd_putl32 (/*input_bfd,*/ x, contents + r_addr);
	      r = bfd_reloc_ok;
	    }

	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		default:
		case bfd_reloc_outofrange:
		  abort ();
		case bfd_reloc_overflow:
		  {
		    const char *name;

		    if (h != NULL)
		      name = NULL;
		    else if (r_extern
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
		      name = strings + GET_WORD (input_bfd,
						 syms[r_index].e_strx);
		    else
		      {
			asection *s;

			s = aout_reloc_index_to_section (input_bfd, r_index);
			name = bfd_section_name (input_bfd, s);
		      }
		    if (! ((*flaginfo->info->callbacks->reloc_overflow)
			   (flaginfo->info, (h ? &h->root : NULL), name,
			    howto_table_ext[r_type].name,
			    r_addend, input_bfd, input_section, r_addr)))
		      return FALSE;
		  }
		  break;
		}
	    }
	}
    }

  return TRUE;
}

/* Link an a.out section into the output file.  */

static bfd_boolean
aout_link_input_section (struct aout_final_link_info *flaginfo,
			 bfd *input_bfd,
			 asection *input_section,
			 file_ptr *reloff_ptr,
			 bfd_size_type rel_size)
{
  bfd_size_type input_size;
  void * relocs;

  /* Get the section contents.  */
  input_size = input_section->size;
  if (! bfd_get_section_contents (input_bfd, input_section,
				  (void *) flaginfo->contents,
				  (file_ptr) 0, input_size))
    return FALSE;

  /* Read in the relocs if we haven't already done it.  */
  if (aout_section_data (input_section) != NULL
      && aout_section_data (input_section)->relocs != NULL)
    relocs = aout_section_data (input_section)->relocs;
  else
    {
      relocs = flaginfo->relocs;
      if (rel_size > 0)
	{
	  if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0
	      || bfd_bread (relocs, rel_size, input_bfd) != rel_size)
	    return FALSE;
	}
    }

  /* Relocate the section contents.  */
  if (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE)
    {
      if (! aout_link_input_section_std (flaginfo, input_bfd, input_section,
					 (struct reloc_std_external *) relocs,
					 rel_size, flaginfo->contents))
	return FALSE;
    }
  else
    {
      if (! aout_link_input_section_ext (flaginfo, input_bfd, input_section,
					 (struct reloc_ext_external *) relocs,
					 rel_size, flaginfo->contents))
	return FALSE;
    }

  /* Write out the section contents.  */
  if (! bfd_set_section_contents (flaginfo->output_bfd,
				  input_section->output_section,
				  (void *) flaginfo->contents,
				  (file_ptr) input_section->output_offset,
				  input_size))
    return FALSE;

  /* If we are producing relocatable output, the relocs were
     modified, and we now write them out.  */
  if (flaginfo->info->relocatable && rel_size > 0)
    {
      if (bfd_seek (flaginfo->output_bfd, *reloff_ptr, SEEK_SET) != 0)
	return FALSE;
      if (bfd_bwrite (relocs, rel_size, flaginfo->output_bfd) != rel_size)
	return FALSE;
      *reloff_ptr += rel_size;

      /* Assert that the relocs have not run into the symbols, and
	 that if these are the text relocs they have not run into the
	 data relocs.  */
      BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (flaginfo->output_bfd)
		  && (reloff_ptr != &flaginfo->treloff
		      || (*reloff_ptr
			  <= obj_datasec (flaginfo->output_bfd)->rel_filepos)));
    }

  return TRUE;
}

/* Adjust and write out the symbols for an a.out file.  Set the new
   symbol indices into a symbol_map.  */

static bfd_boolean
aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)
{
  bfd *output_bfd;
  bfd_size_type sym_count;
  char *strings;
  enum bfd_link_strip strip;
  enum bfd_link_discard discard;
  struct external_nlist *outsym;
  bfd_size_type strtab_index;
  struct external_nlist *sym;
  struct external_nlist *sym_end;
  struct aout_link_hash_entry **sym_hash;
  int *symbol_map;
  bfd_boolean pass;
  bfd_boolean skip_next;

  output_bfd = flaginfo->output_bfd;
  sym_count = obj_aout_external_sym_count (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  strip = flaginfo->info->strip;
  discard = flaginfo->info->discard;
  outsym = flaginfo->output_syms;

  /* First write out a symbol for this object file, unless we are
     discarding such symbols.  */
  if (strip != strip_all
      && (strip != strip_some
	  || bfd_hash_lookup (flaginfo->info->keep_hash, input_bfd->filename,
			      FALSE, FALSE) != NULL)
      && discard != discard_all)
    {
      H_PUT_8 (output_bfd, N_TEXT, outsym->e_type);
      H_PUT_8 (output_bfd, 0, outsym->e_other);
      H_PUT_16 (output_bfd, 0, outsym->e_desc);
      strtab_index = add_to_stringtab (output_bfd, flaginfo->strtab,
				       input_bfd->filename, FALSE);
      if (strtab_index == (bfd_size_type) -1)
	return FALSE;
      PUT_WORD (output_bfd, strtab_index, outsym->e_strx);
      PUT_WORD (output_bfd,
		(bfd_get_section_vma (output_bfd,
				      obj_textsec (input_bfd)->output_section)
		 + obj_textsec (input_bfd)->output_offset),
		outsym->e_value);
      ++obj_aout_external_sym_count (output_bfd);
      ++outsym;
    }

  pass = FALSE;
  skip_next = FALSE;
  sym = obj_aout_external_syms (input_bfd);
  sym_end = sym + sym_count;
  sym_hash = obj_aout_sym_hashes (input_bfd);
  symbol_map = flaginfo->symbol_map;
  memset (symbol_map, 0, (size_t) sym_count * sizeof *symbol_map);
  for (; sym < sym_end; sym++, sym_hash++, symbol_map++)
    {
      const char *name;
      int type;
      struct aout_link_hash_entry *h;
      bfd_boolean skip;
      asection *symsec;
      bfd_vma val = 0;
      bfd_boolean copy;

      /* We set *symbol_map to 0 above for all symbols.  If it has
         already been set to -1 for this symbol, it means that we are
         discarding it because it appears in a duplicate header file.
         See the N_BINCL code below.  */
      if (*symbol_map == -1)
	continue;

      /* Initialize *symbol_map to -1, which means that the symbol was
         not copied into the output file.  We will change it later if
         we do copy the symbol over.  */
      *symbol_map = -1;

      type = H_GET_8 (input_bfd, sym->e_type);
      name = strings + GET_WORD (input_bfd, sym->e_strx);

      h = NULL;

      if (pass)
	{
	  /* Pass this symbol through.  It is the target of an
	     indirect or warning symbol.  */
	  val = GET_WORD (input_bfd, sym->e_value);
	  pass = FALSE;
	}
      else if (skip_next)
	{
	  /* Skip this symbol, which is the target of an indirect
	     symbol that we have changed to no longer be an indirect
	     symbol.  */
	  skip_next = FALSE;
	  continue;
	}
      else
	{
	  struct aout_link_hash_entry *hresolve;

	  /* We have saved the hash table entry for this symbol, if
	     there is one.  Note that we could just look it up again
	     in the hash table, provided we first check that it is an
	     external symbol.  */
	  h = *sym_hash;

	  /* Use the name from the hash table, in case the symbol was
             wrapped.  */
	  if (h != NULL
	      && h->root.type != bfd_link_hash_warning)
	    name = h->root.root.string;

	  /* If this is an indirect or warning symbol, then change
	     hresolve to the base symbol.  We also change *sym_hash so
	     that the relocation routines relocate against the real
	     symbol.  */
	  hresolve = h;
	  if (h != (struct aout_link_hash_entry *) NULL
	      && (h->root.type == bfd_link_hash_indirect
		  || h->root.type == bfd_link_hash_warning))
	    {
	      hresolve = (struct aout_link_hash_entry *) h->root.u.i.link;
	      while (hresolve->root.type == bfd_link_hash_indirect
		     || hresolve->root.type == bfd_link_hash_warning)
		hresolve = ((struct aout_link_hash_entry *)
			    hresolve->root.u.i.link);
	      *sym_hash = hresolve;
	    }

	  /* If the symbol has already been written out, skip it.  */
	  if (h != NULL
	      && h->written)
	    {
	      if ((type & N_TYPE) == N_INDR
		  || type == N_WARNING)
		skip_next = TRUE;
	      *symbol_map = h->indx;
	      continue;
	    }

	  /* See if we are stripping this symbol.  */
	  skip = FALSE;
	  switch (strip)
	    {
	    case strip_none:
	      break;
	    case strip_debugger:
	      if ((type & N_STAB) != 0)
		skip = TRUE;
	      break;
	    case strip_some:
	      if (bfd_hash_lookup (flaginfo->info->keep_hash, name, FALSE, FALSE)
		  == NULL)
		skip = TRUE;
	      break;
	    case strip_all:
	      skip = TRUE;
	      break;
	    }
	  if (skip)
	    {
	      if (h != NULL)
		h->written = TRUE;
	      continue;
	    }

	  /* Get the value of the symbol.  */
	  if ((type & N_TYPE) == N_TEXT
	      || type == N_WEAKT)
	    symsec = obj_textsec (input_bfd);
	  else if ((type & N_TYPE) == N_DATA
		   || type == N_WEAKD)
	    symsec = obj_datasec (input_bfd);
	  else if ((type & N_TYPE) == N_BSS
		   || type == N_WEAKB)
	    symsec = obj_bsssec (input_bfd);
	  else if ((type & N_TYPE) == N_ABS
		   || type == N_WEAKA)
	    symsec = bfd_abs_section_ptr;
	  else if (((type & N_TYPE) == N_INDR
		    && (hresolve == NULL
			|| (hresolve->root.type != bfd_link_hash_defined
			    && hresolve->root.type != bfd_link_hash_defweak
			    && hresolve->root.type != bfd_link_hash_common)))
		   || type == N_WARNING)
	    {
	      /* Pass the next symbol through unchanged.  The
		 condition above for indirect symbols is so that if
		 the indirect symbol was defined, we output it with
		 the correct definition so the debugger will
		 understand it.  */
	      pass = TRUE;
	      val = GET_WORD (input_bfd, sym->e_value);
	      symsec = NULL;
	    }
	  else if ((type & N_STAB) != 0)
	    {
	      val = GET_WORD (input_bfd, sym->e_value);
	      symsec = NULL;
	    }
	  else
	    {
	      /* If we get here with an indirect symbol, it means that
		 we are outputting it with a real definition.  In such
		 a case we do not want to output the next symbol,
		 which is the target of the indirection.  */
	      if ((type & N_TYPE) == N_INDR)
		skip_next = TRUE;

	      symsec = NULL;

	      /* We need to get the value from the hash table.  We use
		 hresolve so that if we have defined an indirect
		 symbol we output the final definition.  */
	      if (h == NULL)
		{
		  switch (type & N_TYPE)
		    {
		    case N_SETT:
		      symsec = obj_textsec (input_bfd);
		      break;
		    case N_SETD:
		      symsec = obj_datasec (input_bfd);
		      break;
		    case N_SETB:
		      symsec = obj_bsssec (input_bfd);
		      break;
		    case N_SETA:
		      symsec = bfd_abs_section_ptr;
		      break;
		    default:
		      val = 0;
		      break;
		    }
		}
	      else if (hresolve->root.type == bfd_link_hash_defined
		       || hresolve->root.type == bfd_link_hash_defweak)
		{
		  asection *input_section;
		  asection *output_section;

		  /* This case usually means a common symbol which was
		     turned into a defined symbol.  */
		  input_section = hresolve->root.u.def.section;
		  output_section = input_section->output_section;
		  BFD_ASSERT (bfd_is_abs_section (output_section)
			      || output_section->owner == output_bfd);
		  val = (hresolve->root.u.def.value
			 + bfd_get_section_vma (output_bfd, output_section)
			 + input_section->output_offset);

		  /* Get the correct type based on the section.  If
		     this is a constructed set, force it to be
		     globally visible.  */
		  if (type == N_SETT
		      || type == N_SETD
		      || type == N_SETB
		      || type == N_SETA)
		    type |= N_EXT;

		  type &=~ N_TYPE;

		  if (output_section == obj_textsec (output_bfd))
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_TEXT
			     : N_WEAKT);
		  else if (output_section == obj_datasec (output_bfd))
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_DATA
			     : N_WEAKD);
		  else if (output_section == obj_bsssec (output_bfd))
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_BSS
			     : N_WEAKB);
		  else
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_ABS
			     : N_WEAKA);
		}
	      else if (hresolve->root.type == bfd_link_hash_common)
		val = hresolve->root.u.c.size;
	      else if (hresolve->root.type == bfd_link_hash_undefweak)
		{
		  val = 0;
		  type = N_WEAKU;
		}
	      else
		val = 0;
	    }
	  if (symsec != NULL)
	    val = (symsec->output_section->vma
		   + symsec->output_offset
		   + (GET_WORD (input_bfd, sym->e_value)
		      - symsec->vma));

	  /* If this is a global symbol set the written flag, and if
	     it is a local symbol see if we should discard it.  */
	  if (h != NULL)
	    {
	      h->written = TRUE;
	      h->indx = obj_aout_external_sym_count (output_bfd);
	    }
	  else if ((type & N_TYPE) != N_SETT
		   && (type & N_TYPE) != N_SETD
		   && (type & N_TYPE) != N_SETB
		   && (type & N_TYPE) != N_SETA)
	    {
	      switch (discard)
		{
		case discard_none:
		case discard_sec_merge:
		  break;
		case discard_l:
		  if ((type & N_STAB) == 0
		      && bfd_is_local_label_name (input_bfd, name))
		    skip = TRUE;
		  break;
		case discard_all:
		  skip = TRUE;
		  break;
		}
	      if (skip)
		{
		  pass = FALSE;
		  continue;
		}
	    }

	  /* An N_BINCL symbol indicates the start of the stabs
	     entries for a header file.  We need to scan ahead to the
	     next N_EINCL symbol, ignoring nesting, adding up all the
	     characters in the symbol names, not including the file
	     numbers in types (the first number after an open
	     parenthesis).  */
	  if (type == (int) N_BINCL)
	    {
	      struct external_nlist *incl_sym;
	      int nest;
	      struct aout_link_includes_entry *incl_entry;
	      struct aout_link_includes_totals *t;

	      val = 0;
	      nest = 0;
	      for (incl_sym = sym + 1; incl_sym < sym_end; incl_sym++)
		{
		  int incl_type;

		  incl_type = H_GET_8 (input_bfd, incl_sym->e_type);
		  if (incl_type == (int) N_EINCL)
		    {
		      if (nest == 0)
			break;
		      --nest;
		    }
		  else if (incl_type == (int) N_BINCL)
		    ++nest;
		  else if (nest == 0)
		    {
		      const char *s;

		      s = strings + GET_WORD (input_bfd, incl_sym->e_strx);
		      for (; *s != '\0'; s++)
			{
			  val += *s;
			  if (*s == '(')
			    {
			      /* Skip the file number.  */
			      ++s;
			      while (ISDIGIT (*s))
				++s;
			      --s;
			    }
			}
		    }
		}

	      /* If we have already included a header file with the
                 same value, then replace this one with an N_EXCL
                 symbol.  */
	      copy = (bfd_boolean) (! flaginfo->info->keep_memory);
	      incl_entry = aout_link_includes_lookup (&flaginfo->includes,
						      name, TRUE, copy);
	      if (incl_entry == NULL)
		return FALSE;
	      for (t = incl_entry->totals; t != NULL; t = t->next)
		if (t->total == val)
		  break;
	      if (t == NULL)
		{
		  /* This is the first time we have seen this header
                     file with this set of stabs strings.  */
		  t = (struct aout_link_includes_totals *)
                      bfd_hash_allocate (&flaginfo->includes.root,
					 sizeof *t);
		  if (t == NULL)
		    return FALSE;
		  t->total = val;
		  t->next = incl_entry->totals;
		  incl_entry->totals = t;
		}
	      else
		{
		  int *incl_map;

		  /* This is a duplicate header file.  We must change
                     it to be an N_EXCL entry, and mark all the
                     included symbols to prevent outputting them.  */
		  type = (int) N_EXCL;

		  nest = 0;
		  for (incl_sym = sym + 1, incl_map = symbol_map + 1;
		       incl_sym < sym_end;
		       incl_sym++, incl_map++)
		    {
		      int incl_type;

		      incl_type = H_GET_8 (input_bfd, incl_sym->e_type);
		      if (incl_type == (int) N_EINCL)
			{
			  if (nest == 0)
			    {
			      *incl_map = -1;
			      break;
			    }
			  --nest;
			}
		      else if (incl_type == (int) N_BINCL)
			++nest;
		      else if (nest == 0)
			*incl_map = -1;
		    }
		}
	    }
	}

      /* Copy this symbol into the list of symbols we are going to
	 write out.  */
      H_PUT_8 (output_bfd, type, outsym->e_type);
      H_PUT_8 (output_bfd, H_GET_8 (input_bfd, sym->e_other), outsym->e_other);
      H_PUT_16 (output_bfd, H_GET_16 (input_bfd, sym->e_desc), outsym->e_desc);
      copy = FALSE;
      if (! flaginfo->info->keep_memory)
	{
	  /* name points into a string table which we are going to
	     free.  If there is a hash table entry, use that string.
	     Otherwise, copy name into memory.  */
	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    copy = TRUE;
	}
      strtab_index = add_to_stringtab (output_bfd, flaginfo->strtab,
				       name, copy);
      if (strtab_index == (bfd_size_type) -1)
	return FALSE;
      PUT_WORD (output_bfd, strtab_index, outsym->e_strx);
      PUT_WORD (output_bfd, val, outsym->e_value);
      *symbol_map = obj_aout_external_sym_count (output_bfd);
      ++obj_aout_external_sym_count (output_bfd);
      ++outsym;
    }

  /* Write out the output symbols we have just constructed.  */
  if (outsym > flaginfo->output_syms)
    {
      bfd_size_type outsym_size;

      if (bfd_seek (output_bfd, flaginfo->symoff, SEEK_SET) != 0)
	return FALSE;
      outsym_size = outsym - flaginfo->output_syms;
      outsym_size *= EXTERNAL_NLIST_SIZE;
      if (bfd_bwrite ((void *) flaginfo->output_syms, outsym_size, output_bfd)
	  != outsym_size)
	return FALSE;
      flaginfo->symoff += outsym_size;
    }

  return TRUE;
}

/* Link an a.out input BFD into the output file.  */

static bfd_boolean
aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)
{
  BFD_ASSERT (bfd_get_format (input_bfd) == bfd_object);

  /* If this is a dynamic object, it may need special handling.  */
  if ((input_bfd->flags & DYNAMIC) != 0
      && aout_backend_info (input_bfd)->link_dynamic_object != NULL)
    return ((*aout_backend_info (input_bfd)->link_dynamic_object)
	    (flaginfo->info, input_bfd));

  /* Get the symbols.  We probably have them already, unless
     flaginfo->info->keep_memory is FALSE.  */
  if (! aout_get_external_symbols (input_bfd))
    return FALSE;

  /* Write out the symbols and get a map of the new indices.  The map
     is placed into flaginfo->symbol_map.  */
  if (! aout_link_write_symbols (flaginfo, input_bfd))
    return FALSE;

  /* Relocate and write out the sections.  These functions use the
     symbol map created by aout_link_write_symbols.  The linker_mark
     field will be set if these sections are to be included in the
     link, which will normally be the case.  */
  if (obj_textsec (input_bfd)->linker_mark)
    {
      if (! aout_link_input_section (flaginfo, input_bfd,
				     obj_textsec (input_bfd),
				     &flaginfo->treloff,
				     exec_hdr (input_bfd)->a_trsize))
	return FALSE;
    }
  if (obj_datasec (input_bfd)->linker_mark)
    {
      if (! aout_link_input_section (flaginfo, input_bfd,
				     obj_datasec (input_bfd),
				     &flaginfo->dreloff,
				     exec_hdr (input_bfd)->a_drsize))
	return FALSE;
    }

  /* If we are not keeping memory, we don't need the symbols any
     longer.  We still need them if we are keeping memory, because the
     strings in the hash table point into them.  */
  if (! flaginfo->info->keep_memory)
    {
      if (! aout_link_free_symbols (input_bfd))
	return FALSE;
    }

  return TRUE;
}

/* Do the final link step.  This is called on the output BFD.  The
   INFO structure should point to a list of BFDs linked through the
   link_next field which can be used to find each BFD which takes part
   in the output.  Also, each section in ABFD should point to a list
   of bfd_link_order structures which list all the input sections for
   the output section.  */

bfd_boolean
NAME (aout, final_link) (bfd *abfd,
			 struct bfd_link_info *info,
			 void (*callback) (bfd *, file_ptr *, file_ptr *, file_ptr *))
{
  struct aout_final_link_info aout_info;
  bfd_boolean includes_hash_initialized = FALSE;
  bfd *sub;
  bfd_size_type trsize, drsize;
  bfd_size_type max_contents_size;
  bfd_size_type max_relocs_size;
  bfd_size_type max_sym_count;
  bfd_size_type text_size;
  file_ptr text_end;
  struct bfd_link_order *p;
  asection *o;
  bfd_boolean have_link_order_relocs;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  aout_info.info = info;
  aout_info.output_bfd = abfd;
  aout_info.contents = NULL;
  aout_info.relocs = NULL;
  aout_info.symbol_map = NULL;
  aout_info.output_syms = NULL;

  if (!bfd_hash_table_init_n (&aout_info.includes.root,
			      aout_link_includes_newfunc,
			      sizeof (struct aout_link_includes_entry),
			      251))
    goto error_return;
  includes_hash_initialized = TRUE;

  /* Figure out the largest section size.  Also, if generating
     relocatable output, count the relocs.  */
  trsize = 0;
  drsize = 0;
  max_contents_size = 0;
  max_relocs_size = 0;
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;

      if (info->relocatable)
	{
	  if (bfd_get_flavour (sub) == bfd_target_aout_flavour)
	    {
	      trsize += exec_hdr (sub)->a_trsize;
	      drsize += exec_hdr (sub)->a_drsize;
	    }
	  else
	    {
	      /* FIXME: We need to identify the .text and .data sections
		 and call get_reloc_upper_bound and canonicalize_reloc to
		 work out the number of relocs needed, and then multiply
		 by the reloc size.  */
	      (*_bfd_error_handler)
		(_("%s: relocatable link from %s to %s not supported"),
		 bfd_get_filename (abfd),
		 sub->xvec->name, abfd->xvec->name);
	      bfd_set_error (bfd_error_invalid_operation);
	      goto error_return;
	    }
	}

      if (bfd_get_flavour (sub) == bfd_target_aout_flavour)
	{
	  sz = obj_textsec (sub)->size;
	  if (sz > max_contents_size)
	    max_contents_size = sz;
	  sz = obj_datasec (sub)->size;
	  if (sz > max_contents_size)
	    max_contents_size = sz;

	  sz = exec_hdr (sub)->a_trsize;
	  if (sz > max_relocs_size)
	    max_relocs_size = sz;
	  sz = exec_hdr (sub)->a_drsize;
	  if (sz > max_relocs_size)
	    max_relocs_size = sz;

	  sz = obj_aout_external_sym_count (sub);
	  if (sz > max_sym_count)
	    max_sym_count = sz;
	}
    }

  if (info->relocatable)
    {
      if (obj_textsec (abfd) != NULL)
	trsize += (_bfd_count_link_order_relocs (obj_textsec (abfd)
						 ->map_head.link_order)
		   * obj_reloc_entry_size (abfd));
      if (obj_datasec (abfd) != NULL)
	drsize += (_bfd_count_link_order_relocs (obj_datasec (abfd)
						 ->map_head.link_order)
		   * obj_reloc_entry_size (abfd));
    }

  exec_hdr (abfd)->a_trsize = trsize;
  exec_hdr (abfd)->a_drsize = drsize;

  exec_hdr (abfd)->a_entry = bfd_get_start_address (abfd);

  /* Adjust the section sizes and vmas according to the magic number.
     This sets a_text, a_data and a_bss in the exec_hdr and sets the
     filepos for each section.  */
  if (! NAME (aout, adjust_sizes_and_vmas) (abfd, &text_size, &text_end))
    goto error_return;

  /* The relocation and symbol file positions differ among a.out
     targets.  We are passed a callback routine from the backend
     specific code to handle this.
     FIXME: At this point we do not know how much space the symbol
     table will require.  This will not work for any (nonstandard)
     a.out target that needs to know the symbol table size before it
     can compute the relocation file positions.  This may or may not
     be the case for the hp300hpux target, for example.  */
  (*callback) (abfd, &aout_info.treloff, &aout_info.dreloff,
	       &aout_info.symoff);
  obj_textsec (abfd)->rel_filepos = aout_info.treloff;
  obj_datasec (abfd)->rel_filepos = aout_info.dreloff;
  obj_sym_filepos (abfd) = aout_info.symoff;

  /* We keep a count of the symbols as we output them.  */
  obj_aout_external_sym_count (abfd) = 0;

  /* We accumulate the string table as we write out the symbols.  */
  aout_info.strtab = _bfd_stringtab_init ();
  if (aout_info.strtab == NULL)
    goto error_return;

  /* Allocate buffers to hold section contents and relocs.  */
  aout_info.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  aout_info.relocs = bfd_malloc (max_relocs_size);
  aout_info.symbol_map = (int *) bfd_malloc (max_sym_count * sizeof (int));
  aout_info.output_syms = (struct external_nlist *)
      bfd_malloc ((max_sym_count + 1) * sizeof (struct external_nlist));
  if ((aout_info.contents == NULL && max_contents_size != 0)
      || (aout_info.relocs == NULL && max_relocs_size != 0)
      || (aout_info.symbol_map == NULL && max_sym_count != 0)
      || aout_info.output_syms == NULL)
    goto error_return;

  /* If we have a symbol named __DYNAMIC, force it out now.  This is
     required by SunOS.  Doing this here rather than in sunos.c is a
     hack, but it's easier than exporting everything which would be
     needed.  */
  {
    struct aout_link_hash_entry *h;

    h = aout_link_hash_lookup (aout_hash_table (info), "__DYNAMIC",
			       FALSE, FALSE, FALSE);
    if (h != NULL)
      aout_link_write_other_symbol (&h->root.root, &aout_info);
  }

  /* The most time efficient way to do the link would be to read all
     the input object files into memory and then sort out the
     information into the output file.  Unfortunately, that will
     probably use too much memory.  Another method would be to step
     through everything that composes the text section and write it
     out, and then everything that composes the data section and write
     it out, and then write out the relocs, and then write out the
     symbols.  Unfortunately, that requires reading stuff from each
     input file several times, and we will not be able to keep all the
     input files open simultaneously, and reopening them will be slow.

     What we do is basically process one input file at a time.  We do
     everything we need to do with an input file once--copy over the
     section contents, handle the relocation information, and write
     out the symbols--and then we throw away the information we read
     from it.  This approach requires a lot of lseeks of the output
     file, which is unfortunate but still faster than reopening a lot
     of files.

     We use the output_has_begun field of the input BFDs to see
     whether we have already handled it.  */
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;

  /* Mark all sections which are to be included in the link.  This
     will normally be every section.  We need to do this so that we
     can identify any sections which the linker has decided to not
     include.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	if (p->type == bfd_indirect_link_order)
	  p->u.indirect.section->linker_mark = TRUE;
    }

  have_link_order_relocs = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order;
	   p != NULL;
	   p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_aout_flavour))
	    {
	      bfd *input_bfd;

	      input_bfd = p->u.indirect.section->owner;
	      if (! input_bfd->output_has_begun)
		{
		  if (! aout_link_input_bfd (&aout_info, input_bfd))
		    goto error_return;
		  input_bfd->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      /* These are handled below.  */
	      have_link_order_relocs = TRUE;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  /* Write out any symbols that we have not already written out.  */
  bfd_hash_traverse (&info->hash->table,
		     aout_link_write_other_symbol,
		     &aout_info);

  /* Now handle any relocs we were asked to create by the linker.
     These did not come from any input file.  We must do these after
     we have written out all the symbols, so that we know the symbol
     indices to use.  */
  if (have_link_order_relocs)
    {
      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  for (p = o->map_head.link_order;
	       p != NULL;
	       p = p->next)
	    {
	      if (p->type == bfd_section_reloc_link_order
		  || p->type == bfd_symbol_reloc_link_order)
		{
		  if (! aout_link_reloc_link_order (&aout_info, o, p))
		    goto error_return;
		}
	    }
	}
    }

  if (aout_info.contents != NULL)
    {
      free (aout_info.contents);
      aout_info.contents = NULL;
    }
  if (aout_info.relocs != NULL)
    {
      free (aout_info.relocs);
      aout_info.relocs = NULL;
    }
  if (aout_info.symbol_map != NULL)
    {
      free (aout_info.symbol_map);
      aout_info.symbol_map = NULL;
    }
  if (aout_info.output_syms != NULL)
    {
      free (aout_info.output_syms);
      aout_info.output_syms = NULL;
    }
  if (includes_hash_initialized)
    {
      bfd_hash_table_free (&aout_info.includes.root);
      includes_hash_initialized = FALSE;
    }

  /* Finish up any dynamic linking we may be doing.  */
  if (aout_backend_info (abfd)->finish_dynamic_link != NULL)
    {
      if (! (*aout_backend_info (abfd)->finish_dynamic_link) (abfd, info))
	goto error_return;
    }

  /* Update the header information.  */
  abfd->symcount = obj_aout_external_sym_count (abfd);
  exec_hdr (abfd)->a_syms = abfd->symcount * EXTERNAL_NLIST_SIZE;
  obj_str_filepos (abfd) = obj_sym_filepos (abfd) + exec_hdr (abfd)->a_syms;
  obj_textsec (abfd)->reloc_count =
    exec_hdr (abfd)->a_trsize / obj_reloc_entry_size (abfd);
  obj_datasec (abfd)->reloc_count =
    exec_hdr (abfd)->a_drsize / obj_reloc_entry_size (abfd);

  /* Write out the string table, unless there are no symbols.  */
  if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0)
    goto error_return;
  if (abfd->symcount > 0)
    {
      if (!emit_stringtab (abfd, aout_info.strtab))
	goto error_return;
    }
  else
    {
      bfd_byte b[BYTES_IN_WORD];

      memset (b, 0, BYTES_IN_WORD);
      if (bfd_bwrite (b, (bfd_size_type) BYTES_IN_WORD, abfd) != BYTES_IN_WORD)
	goto error_return;
    }

  return TRUE;

 error_return:
  if (aout_info.contents != NULL)
    free (aout_info.contents);
  if (aout_info.relocs != NULL)
    free (aout_info.relocs);
  if (aout_info.symbol_map != NULL)
    free (aout_info.symbol_map);
  if (aout_info.output_syms != NULL)
    free (aout_info.output_syms);
  if (includes_hash_initialized)
    bfd_hash_table_free (&aout_info.includes.root);
  return FALSE;
}
@


1.87
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d3557 1
a3557 1
  struct aout_final_link_info *finfo = (struct aout_final_link_info *) data;
d3572 1
a3572 1
  output_bfd = finfo->output_bfd;
d3577 1
a3577 1
	     (output_bfd, finfo->info, h)))
d3591 3
a3593 3
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
d3651 1
a3651 1
  indx = add_to_stringtab (output_bfd, finfo->strtab, h->root.root.string,
d3661 1
a3661 1
  if (bfd_seek (output_bfd, finfo->symoff, SEEK_SET) != 0
d3666 1
a3666 1
  finfo->symoff += EXTERNAL_NLIST_SIZE;
d3676 1
a3676 1
aout_link_reloc_link_order (struct aout_final_link_info *finfo,
d3699 1
a3699 1
	  BFD_ASSERT (pr->u.section->owner == finfo->output_bfd);
d3710 1
a3710 1
	   bfd_wrapped_link_hash_lookup (finfo->output_bfd, finfo->info,
d3723 1
a3723 1
	  if (!aout_link_write_other_symbol (&h->root.root, finfo))
d3729 2
a3730 2
	  if (! ((*finfo->info->callbacks->unattached_reloc)
		 (finfo->info, pr->u.name, NULL, NULL, (bfd_vma) 0)))
d3736 1
a3736 1
  howto = bfd_reloc_type_lookup (finfo->output_bfd, pr->reloc);
d3743 4
a3746 4
  if (o == obj_textsec (finfo->output_bfd))
    reloff_ptr = &finfo->treloff;
  else if (o == obj_datasec (finfo->output_bfd))
    reloff_ptr = &finfo->dreloff;
d3750 1
a3750 1
  if (obj_reloc_entry_size (finfo->output_bfd) == RELOC_STD_SIZE)
d3753 1
a3753 1
      MY_put_reloc (finfo->output_bfd, r_extern, r_index, p->offset, howto,
d3769 2
a3770 2
	PUT_WORD (finfo->output_bfd, p->offset, srel.r_address);
	if (bfd_header_big_endian (finfo->output_bfd))
d3816 1
a3816 1
	  r = MY_relocate_contents (howto, finfo->output_bfd,
d3826 2
a3827 2
	      if (! ((*finfo->info->callbacks->reloc_overflow)
		     (finfo->info, NULL,
d3829 1
a3829 1
		       ? bfd_section_name (finfo->output_bfd,
d3839 1
a3839 1
	  ok = bfd_set_section_contents (finfo->output_bfd, o, (void *) buf,
d3849 1
a3849 1
      MY_put_ext_reloc (finfo->output_bfd, r_extern, r_index, p->offset,
d3852 1
a3852 1
      PUT_WORD (finfo->output_bfd, p->offset, erel.r_address);
d3854 1
a3854 1
      if (bfd_header_big_endian (finfo->output_bfd))
d3873 1
a3873 1
      PUT_WORD (finfo->output_bfd, (bfd_vma) pr->addend, erel.r_addend);
d3879 3
a3881 3
  amt = obj_reloc_entry_size (finfo->output_bfd);
  if (bfd_seek (finfo->output_bfd, *reloff_ptr, SEEK_SET) != 0
      || bfd_bwrite (rel_ptr, amt, finfo->output_bfd) != amt)
d3884 1
a3884 1
  *reloff_ptr += obj_reloc_entry_size (finfo->output_bfd);
d3888 2
a3889 2
  BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (finfo->output_bfd)
	      && (reloff_ptr != &finfo->treloff
d3891 1
a3891 1
		      <= obj_datasec (finfo->output_bfd)->rel_filepos)));
d3916 1
a3916 1
aout_link_input_section_std (struct aout_final_link_info *finfo,
d3937 1
a3937 1
  output_bfd = finfo->output_bfd;
d3944 1
a3944 1
  relocatable = finfo->info->relocatable;
d3948 1
a3948 1
  symbol_map = finfo->symbol_map;
d4017 1
a4017 1
	  (*finfo->info->callbacks->einfo)
d4082 1
a4082 1
								 finfo))
d4093 2
a4094 2
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, input_section,
d4200 1
a4200 1
		     (finfo->info, input_bfd, input_section, h,
d4210 1
a4210 1
	  if (hundef && ! finfo->info->shared && ! r_baserel)
d4218 2
a4219 2
	      if (! ((*finfo->info->callbacks->undefined_symbol)
		     (finfo->info, name, input_bfd, input_section,
d4253 2
a4254 2
		if (! ((*finfo->info->callbacks->reloc_overflow)
		       (finfo->info, (h ? &h->root : NULL), name,
d4270 1
a4270 1
aout_link_input_section_ext (struct aout_final_link_info *finfo,
d4291 1
a4291 1
  output_bfd = finfo->output_bfd;
d4298 1
a4298 1
  relocatable = finfo->info->relocatable;
d4302 1
a4302 1
  symbol_map = finfo->symbol_map;
d4343 1
a4343 1
	  (*finfo->info->callbacks->einfo)
d4424 1
a4424 1
								 finfo))
d4435 2
a4436 2
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, input_section,
d4603 1
a4603 1
		     (finfo->info, input_bfd, input_section, h,
d4614 1
a4614 1
	      && ! finfo->info->shared
d4625 2
a4626 2
	      if (! ((*finfo->info->callbacks->undefined_symbol)
		     (finfo->info, name, input_bfd, input_section,
d4672 2
a4673 2
		    if (! ((*finfo->info->callbacks->reloc_overflow)
			   (finfo->info, (h ? &h->root : NULL), name,
d4690 1
a4690 1
aout_link_input_section (struct aout_final_link_info *finfo,
d4702 1
a4702 1
				  (void *) finfo->contents,
d4712 1
a4712 1
      relocs = finfo->relocs;
d4724 1
a4724 1
      if (! aout_link_input_section_std (finfo, input_bfd, input_section,
d4726 1
a4726 1
					 rel_size, finfo->contents))
d4731 1
a4731 1
      if (! aout_link_input_section_ext (finfo, input_bfd, input_section,
d4733 1
a4733 1
					 rel_size, finfo->contents))
d4738 1
a4738 1
  if (! bfd_set_section_contents (finfo->output_bfd,
d4740 1
a4740 1
				  (void *) finfo->contents,
d4747 1
a4747 1
  if (finfo->info->relocatable && rel_size > 0)
d4749 1
a4749 1
      if (bfd_seek (finfo->output_bfd, *reloff_ptr, SEEK_SET) != 0)
d4751 1
a4751 1
      if (bfd_bwrite (relocs, rel_size, finfo->output_bfd) != rel_size)
d4758 2
a4759 2
      BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (finfo->output_bfd)
		  && (reloff_ptr != &finfo->treloff
d4761 1
a4761 1
			  <= obj_datasec (finfo->output_bfd)->rel_filepos)));
d4771 1
a4771 1
aout_link_write_symbols (struct aout_final_link_info *finfo, bfd *input_bfd)
d4787 1
a4787 1
  output_bfd = finfo->output_bfd;
d4790 3
a4792 3
  strip = finfo->info->strip;
  discard = finfo->info->discard;
  outsym = finfo->output_syms;
d4798 1
a4798 1
	  || bfd_hash_lookup (finfo->info->keep_hash, input_bfd->filename,
d4805 1
a4805 1
      strtab_index = add_to_stringtab (output_bfd, finfo->strtab,
d4824 1
a4824 1
  symbol_map = finfo->symbol_map;
d4923 1
a4923 1
	      if (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d5151 2
a5152 2
	      copy = (bfd_boolean) (! finfo->info->keep_memory);
	      incl_entry = aout_link_includes_lookup (&finfo->includes,
d5164 1
a5164 1
                      bfd_hash_allocate (&finfo->includes.root,
d5213 1
a5213 1
      if (! finfo->info->keep_memory)
d5223 1
a5223 1
      strtab_index = add_to_stringtab (output_bfd, finfo->strtab,
d5235 1
a5235 1
  if (outsym > finfo->output_syms)
d5239 1
a5239 1
      if (bfd_seek (output_bfd, finfo->symoff, SEEK_SET) != 0)
d5241 1
a5241 1
      outsym_size = outsym - finfo->output_syms;
d5243 1
a5243 1
      if (bfd_bwrite ((void *) finfo->output_syms, outsym_size, output_bfd)
d5246 1
a5246 1
      finfo->symoff += outsym_size;
d5255 1
a5255 1
aout_link_input_bfd (struct aout_final_link_info *finfo, bfd *input_bfd)
d5263 1
a5263 1
	    (finfo->info, input_bfd));
d5266 1
a5266 1
     finfo->info->keep_memory is FALSE.  */
d5271 2
a5272 2
     is placed into finfo->symbol_map.  */
  if (! aout_link_write_symbols (finfo, input_bfd))
d5281 1
a5281 1
      if (! aout_link_input_section (finfo, input_bfd,
d5283 1
a5283 1
				     &finfo->treloff,
d5289 1
a5289 1
      if (! aout_link_input_section (finfo, input_bfd,
d5291 1
a5291 1
				     &finfo->dreloff,
d5299 1
a5299 1
  if (! finfo->info->keep_memory)
@


1.86
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* aoutx.h (aout_final_link): Use sizeof int not sizeof int*.
	(aout_link_write_other_symbol): Missing break statement.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d3554 1
a3554 1
aout_link_write_other_symbol (struct aout_link_hash_entry *h, void * data)
d3556 1
d3723 1
a3723 1
	  if (! aout_link_write_other_symbol (h, (void *) finfo))
d4081 2
a4082 2
			      if (! aout_link_write_other_symbol (h,
								  (void *) finfo))
d4423 2
a4424 2
			      if (! aout_link_write_other_symbol (h,
								  (void *) finfo))
d5472 1
a5472 1
      aout_link_write_other_symbol (h, &aout_info);
d5546 3
a5548 3
  aout_link_hash_traverse (aout_hash_table (info),
			   aout_link_write_other_symbol,
			   (void *) &aout_info);
@


1.85
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d3640 1
d5452 1
a5452 1
  aout_info.symbol_map = (int *) bfd_malloc (max_sym_count * sizeof (int *));
@


1.84
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d3308 2
a3309 2
	  if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d3336 2
a3337 2
		      if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d3346 2
a3347 2
                      bfd_hash_allocate (&info->hash->table,
                                         sizeof (struct bfd_link_hash_common_entry));
d3385 2
a3386 2
	      if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d3407 2
a3408 1
  bfd *subsbfd = NULL;
d3410 1
a3410 1
  if (! aout_get_external_symbols (abfd))
d3413 2
a3414 1
  if (! aout_link_check_ar_symbols (abfd, info, pneeded, &subsbfd))
d3417 2
a3418 1
  if (*pneeded)
d3422 9
a3430 3
      if (subsbfd && !aout_get_external_symbols (subsbfd))
	return FALSE;
      if (! aout_link_add_symbols (subsbfd ? subsbfd : abfd, info))
d3434 1
a3434 1
  if (! info->keep_memory || ! *pneeded)
d3436 1
a3436 1
      if (! aout_link_free_symbols (abfd))
@


1.84.2.1
log
@backport from mainline
@
text
@d3308 2
a3309 2
	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, name, subsbfd))
d3336 2
a3337 2
		      if (!(*info->callbacks
			    ->add_archive_element) (info, abfd, name, subsbfd))
d3346 2
a3347 2
		    bfd_hash_allocate (&info->hash->table,
				       sizeof (struct bfd_link_hash_common_entry));
d3385 2
a3386 2
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
d3407 1
a3407 2
  bfd *oldbfd;
  bfd_boolean needed;
d3409 1
a3409 1
  if (!aout_get_external_symbols (abfd))
d3412 1
a3412 2
  oldbfd = abfd;
  if (!aout_link_check_ar_symbols (abfd, info, pneeded, &abfd))
d3415 1
a3415 2
  needed = *pneeded;
  if (needed)
d3419 3
a3421 9
      if (abfd != oldbfd)
	{
	  if (!info->keep_memory
	      && !aout_link_free_symbols (oldbfd))
	    return FALSE;
	  if (!aout_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!aout_link_add_symbols (abfd, info))
d3425 1
a3425 1
  if (!info->keep_memory || !needed)
d3427 1
a3427 1
      if (!aout_link_free_symbols (abfd))
@


1.84.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a3639 1
      break;
d5451 1
a5451 1
  aout_info.symbol_map = (int *) bfd_malloc (max_sym_count * sizeof (int));
@


1.83
log
@	* aout-arm.c (MY(bfd_reloc_type_lookup)): Use bfd_arch_bits_per_address.
	* aout-ns32k.c (MY(bfd_reloc_type_lookup)): Likewise.
	* aoutx.h (NAME(aout,reloc_type_lookup)): Likewise.
	* coff-arm.c (coff_arm_reloc_type_lookup): Likewise.
	* elf-hppa.h (elf_hppa_reloc_final_type): Likewise.
	* reloc.c (bfd_default_reloc_type_lookup): Likewise.
	* riscix.c (riscix_reloc_type_lookup): Likewise.
@
text
@d3213 2
a3214 1
			    bfd_boolean *pneeded)
d3308 2
a3309 1
	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d3336 2
a3337 3
		      if (! (*info->callbacks->add_archive_element) (info,
								     abfd,
								     name))
d3385 2
a3386 1
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d3407 2
d3412 1
a3412 1
  if (! aout_link_check_ar_symbols (abfd, info, pneeded))
d3417 5
a3421 1
      if (! aout_link_add_symbols (abfd, info))
@


1.82
log
@	* aoutx.h (some_aout_object_p): Don't set EXEC_P for files with
	relocs.
@
text
@d272 1
a272 1
    switch (bfd_get_arch_info (abfd)->bits_per_address)
@


1.81
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d632 3
a634 1
			       + obj_textsec (abfd)->size)))
@


1.80
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a5235 2
  bfd_size_type sym_count;

a5248 2
  sym_count = obj_aout_external_sym_count (input_bfd);

@


1.79
log
@include/
	* bfdlink.h (enum bfd_link_common_skip_ar_symbols): Rename from
	bfd_link_common_skip_ar_aymbols.
	(struct bfd_link_info): Here too.
bfd/
	* aoutx.h (aout_link_check_ar_symbols): Typo fix.
ld/
	* emultempl/netbsd.em (gldnetbsd_before_parse): Typo fix.
@
text
@d1811 1
a1811 1
  bfd_size_type index;
d1823 1
a1823 1
  index = _bfd_stringtab_add (tab, str, hash, copy);
d1825 1
a1825 1
  if (index != (bfd_size_type) -1)
d1828 1
a1828 1
    index += BYTES_IN_WORD;
d1830 1
a1830 1
  return index;
@


1.78
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d3287 1
a3287 1
	      switch (info->common_skip_ar_aymbols)
@


1.77
log
@update copyright dates
@
text
@d467 1
a467 1
  rawptr = bfd_zalloc (abfd, amt);
d682 1
a682 1
  rawptr = bfd_zalloc (abfd, amt);
d1312 1
a1312 1
      syms = bfd_malloc (count * EXTERNAL_NLIST_SIZE);
d1352 1
a1352 1
      strings = bfd_malloc (stringsize + 1);
d1753 1
a1753 1
  cached = bfd_zmalloc (cached_size);
d2314 1
a2314 1
  reloc_cache = bfd_zmalloc (amt);
d2375 1
a2375 1
  native = bfd_zalloc (abfd, natsize);
d2789 1
a2789 1
      buf = bfd_malloc (filelen + funclen + 3);
d2883 2
a2884 1
    ret = bfd_hash_allocate (table, sizeof (* ret));
d2923 1
a2923 1
  ret = bfd_malloc (amt);
d2978 1
a2978 1
  sym_hash = bfd_alloc (abfd, amt);
d3342 3
a3344 2
		  h->u.c.p = bfd_hash_allocate (&info->hash->table,
						sizeof (struct bfd_link_hash_common_entry));
d3514 2
a3515 1
    ret = bfd_hash_allocate (table, sizeof (* ret));
d3792 1
a3792 1
	  buf = bfd_zmalloc (size);
d5142 2
a5143 1
		  t = bfd_hash_allocate (&finfo->includes.root,
d5434 1
a5434 1
  aout_info.contents = bfd_malloc (max_contents_size);
d5436 3
a5438 3
  aout_info.symbol_map = bfd_malloc (max_sym_count * sizeof (int *));
  aout_info.output_syms = bfd_malloc ((max_sym_count + 1)
				      * sizeof (struct external_nlist));
@


1.77.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d467 1
a467 1
  rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);
d682 1
a682 1
  rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);
d1312 1
a1312 1
      syms = (struct external_nlist *) bfd_malloc (count * EXTERNAL_NLIST_SIZE);
d1352 1
a1352 1
      strings = (char *) bfd_malloc (stringsize + 1);
d1753 1
a1753 1
  cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
d2314 1
a2314 1
  reloc_cache = (arelent *) bfd_zmalloc (amt);
d2375 1
a2375 1
  native = (unsigned char *) bfd_zalloc (abfd, natsize);
d2789 1
a2789 1
      buf = (char *) bfd_malloc (filelen + funclen + 3);
d2883 1
a2883 2
    ret = (struct aout_link_hash_entry *) bfd_hash_allocate (table,
                                                             sizeof (* ret));
d2922 1
a2922 1
  ret = (struct aout_link_hash_table *) bfd_malloc (amt);
d2977 1
a2977 1
  sym_hash = (struct aout_link_hash_entry **) bfd_alloc (abfd, amt);
d3341 2
a3342 3
		  h->u.c.p = (struct bfd_link_hash_common_entry *)
                      bfd_hash_allocate (&info->hash->table,
                                         sizeof (struct bfd_link_hash_common_entry));
d3512 1
a3512 2
    ret = (struct aout_link_includes_entry *)
        bfd_hash_allocate (table, sizeof (* ret));
d3789 1
a3789 1
	  buf = (bfd_byte *) bfd_zmalloc (size);
d5139 1
a5139 2
		  t = (struct aout_link_includes_totals *)
                      bfd_hash_allocate (&finfo->includes.root,
d5430 1
a5430 1
  aout_info.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d5432 3
a5434 3
  aout_info.symbol_map = (int *) bfd_malloc (max_sym_count * sizeof (int *));
  aout_info.output_syms = (struct external_nlist *)
      bfd_malloc ((max_sym_count + 1) * sizeof (struct external_nlist));
@


1.76
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
@


1.75
log
@	* aoutx.h (aout_get_external_symbols): Declare 'amt' locally.
	* bfdwin.c (bfd_free_window): Cast to unsigned long.
@
text
@d1671 2
a1672 2
  aout_symbol_type *new = bfd_zalloc (abfd, amt);
  if (!new)
d1674 1
a1674 1
  new->symbol.the_bfd = abfd;
d1676 1
a1676 1
  return &new->symbol;
@


1.74
log
@bfd:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
	* archures.c (bfd_mach_mips_xlr): Define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_xlr): Define.
	(arch_info_struct): Add XLR entry.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
	(mips_set_isa_flags): Handle bfd_mach_mips_xlr
	(mips_mach_extensions): Add XLR entry.

binutils:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.

gas:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* config/tc-mips.c (macro): Handle M_MSGSND, M_MSGLD, M_MSGLD_T,
	M_MSGWAIT and M_MSGWAIT_T.
	(mips_cpu_info_table): Add XLR entry.
	* doc/c-mips.texi (-march): Document xlr.

gas/testsuite:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* gas/mips/mips.exp (xlr): New architecture.
	(xlr-ext): Run test.
	* gas/mips/xlr-ext.d, gas/mips/xlr-ext.s: New.

include/elf:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (E_MIPS_MACH_XLR): Define.

include/opcode:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (INSN_XLR): Define.
	(INSN_CHIP_MASK): Update.
	(CPU_XLR): Define.
	(OPCODE_IS_MEMBER): Update.
	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define.

opcodes:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): Define.
	(mips_arch_choices): Add XLR entry.
	* mips-opc.c (XLR): Define.
	(mips_builtin_opcodes): Add XLR instructions.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
a1296 1
      bfd_size_type amt;
d1316 10
a1325 7
      amt = exec_hdr (abfd)->a_syms;
      if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0
	  || bfd_bread (syms, amt, abfd) != amt)
	{
	  free (syms);
	  return FALSE;
	}
@


1.73
log
@	* aoutx.h (NAME): Add case statements for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* archures.c (bfd_architecture): Add .#defines for bfd_mach_mips14000,
	bfd_mach_mips16000.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c: Add enums I_mips14000, I_mips16000.
	(arch_info_struct): Add refs to R14000, R16000.
	* elfxx-mips.c (mips_set_isa_flags): Handle bfd_mach_mips14000,
	bfd_mach_mips16000.
	(mips_mach_extensions): Map R14000, R16000 to R10000.

	* config/tc-mips.c (hilo_interlocks): Handle CPU_R14000, CPU_R16000.
	(mips_cpu_info_table): Add r14000, r16000.
	* doc/c-mips.texi: Add entries for 14000, 16000.

	* mips-dis.c (mips_arch_choices): Add r14000, r16000.

	* mips.h: Define CPU_R14000, CPU_R16000.
        (OPCODE_IS_MEMBER): Include R14000, R16000 in test.
@
text
@d798 1
@


1.72
log
@2007-08-09  Michael Snyder  <msnyder@@access-company.com>

	* aoutx.h (aout_get_external_symbols): Return if count is zero.
@
text
@d789 2
@


1.71
log
@2007-08-01  Michael Snyder  <msnyder@@access-company.com>

	* aoutx.h (aout_link_add_symbols): Return if count is zero.
@
text
@d1297 2
d1311 1
a1311 1
      if (syms == NULL && count != 0)
@


1.70
log
@	* aoutx.h (swap_ext_reloc_in): Set howto to NULL for unknown
	r_type.
	(swap_std_reloc_in): Likewise.
	(aout_link_input_section_std): Likewise.  Return with an error
	on unexpected relocation type.
	(aout_link_input_section_ext): Likewise.
@
text
@d2962 3
d2971 1
a2971 1
  if (sym_hash == NULL && sym_count != 0)
@


1.69
log
@	PR4694
	* aoutx.h (final_link): Write a zero in first word of
	stringtab if no symbols rather than corrupting last byte
	of text/data.
@
text
@d2165 4
a2168 1
  cache_ptr->howto =  howto_table_ext + r_type;
d2236 8
a2243 3
  BFD_ASSERT (howto_idx < TABLE_SIZE (howto_table_std));
  cache_ptr->howto =  howto_table_std + howto_idx;
  BFD_ASSERT (cache_ptr->howto->type != (unsigned int) -1);
d3974 4
a3977 2
	BFD_ASSERT (howto_idx < TABLE_SIZE (howto_table_std));
	howto = howto_table_std + howto_idx;
d3981 8
d4307 7
a4313 1
      BFD_ASSERT (r_type < TABLE_SIZE (howto_table_ext));
@


1.68
log
@2007-07-27  Michael Snyder  <msnyder@@access-company.com>

	* aoutx.h (slurp_symbol_table): Return if count == 0.
@
text
@d5560 2
d5564 1
a5564 2
      if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0
	  || ! emit_stringtab (abfd, aout_info.strtab))
d5567 1
a5567 2
  else if (obj_textsec (abfd)->reloc_count == 0
	   && obj_datasec (abfd)->reloc_count == 0)
d5569 1
a5569 2
      bfd_byte b;
      file_ptr pos;
d5571 2
a5572 4
      b = 0;
      pos = obj_datasec (abfd)->filepos + exec_hdr (abfd)->a_data - 1;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
@


1.67
log
@2007-07-26  Michael Snyder  <msnyder@@access-company.com>

	* aoutx.h (slurp_reloc_table): Return TRUE if reloc_size == zero
	or count == zero.
@
text
@d1742 3
d1747 1
a1747 1
  if (cached == NULL && cached_size != 0)
@


1.66
log
@Switch sources over to use the GPL version 3
@
text
@d2283 3
d2292 2
d2297 1
a2297 1
  if (reloc_cache == NULL && count != 0)
d2301 1
a2301 1
  if (relocs == NULL && reloc_size != 0)
@


1.65
log
@PR gas/3041
* gas/config/tc-m68k.c (relaxable_symbol): Do not relax weak symbols.
    (tc_gen_reloc): Adjust the addend of relocs against weak symbols.
     (md_apply_fix): Put zero values into the frags referencing weak symbols.
* bfd/aoutx.h (swap_std_reloc_out): Treat relocs against weak symbols in the same way as relocs against external symbols.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 2
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.64
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1955 4
a1958 1
      || bfd_is_und_section (output_section))
@


1.63
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d121 1
a122 1
#include "sysdep.h"
@


1.62
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@a131 2
reloc_howto_type * NAME (aout, reloc_type_lookup)  (bfd *, bfd_reloc_code_real_type);

d320 25
@


1.61
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d2783 2
a2784 1
NAME (aout, sizeof_headers) (bfd *abfd, bfd_boolean execable ATTRIBUTE_UNUSED)
@


1.60
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@a1195 1
	  return TRUE;
d1197 1
a1197 2

      if (obj_datasec (abfd) == NULL && !strcmp (newsect->name, ".data"))
a1200 1
	  return TRUE;
d1202 1
a1202 2

      if (obj_bsssec (abfd) == NULL && !strcmp (newsect->name, ".bss"))
a1205 1
	  return TRUE;
d1210 1
a1210 1
  return TRUE;
@


1.59
log
@2005-10-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1472
	* aoutx.h (NAME (aout, machine_type)): Handle
	bfd_mach_sparc_v8plus, bfd_mach_sparc_v8plusa,
	bfd_mach_sparc_v8plusb, bfd_mach_sparc_v9, bfd_mach_sparc_v9a
	and bfd_mach_sparc_v9b.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d2862 2
a2863 1
				    const char *))
d2865 1
a2865 1
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d2880 3
a2882 2
  if (! NAME (aout, link_hash_table_init) (ret, abfd,
					   NAME (aout, link_hash_newfunc)))
d5257 4
a5260 3
  if (! bfd_hash_table_init_n (&aout_info.includes.root,
			       aout_link_includes_newfunc,
			       251))
@


1.58
log
@Remove a29k support.
@
text
@d709 6
a714 1
	  || machine == bfd_mach_sparc_v9)
@


1.57
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@a732 5
    case bfd_arch_a29k:
      if (machine == 0)
	arch_flags = M_29K;
      break;

a845 1
    case bfd_arch_a29k:
@


1.56
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.55
log
@Update the FSF address in the copyright/GPL notice
@
text
@d5321 1
a5321 1
						 ->link_order_head)
d5325 1
a5325 1
						 ->link_order_head)
d5417 1
a5417 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d5425 1
a5425 1
      for (p = o->link_order_head;
d5470 1
a5470 1
	  for (p = o->link_order_head;
@


1.54
log
@Convert to ISO C90 formatting
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.53
log
@update copyright dates
@
text
@d132 1
a132 14
static bfd_boolean aout_get_external_symbols
  PARAMS ((bfd *));
static bfd_boolean translate_from_native_sym_flags
  PARAMS ((bfd *, aout_symbol_type *));
static bfd_boolean translate_to_native_sym_flags
  PARAMS ((bfd *, asymbol *, struct external_nlist *));
static void adjust_o_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_z_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_n_magic
  PARAMS ((bfd *, struct internal_exec *));
reloc_howto_type * NAME(aout,reloc_type_lookup)
  PARAMS ((bfd *, bfd_reloc_code_real_type));
d156 1
a156 1
#define MY_swap_std_reloc_in NAME(aout,swap_std_reloc_in)
d160 1
a160 1
#define MY_swap_ext_reloc_in NAME(aout,swap_ext_reloc_in)
d164 1
a164 1
#define MY_swap_std_reloc_out NAME(aout,swap_std_reloc_out)
d168 1
a168 1
#define MY_swap_ext_reloc_out NAME(aout,swap_ext_reloc_out)
d179 2
a180 2
#define howto_table_ext NAME(aout,ext_howto_table)
#define howto_table_std NAME(aout,std_howto_table)
d184 27
a210 27
  /* type           rs   size bsz  pcrel bitpos ovrf                  sf name          part_inpl readmask setmask pcdone.  */
  HOWTO(RELOC_8,      0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_16,     0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_32,     0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_DISP8,  0,  0, 	8,  TRUE,  0, complain_overflow_signed,0,"DISP8", 	FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_DISP16, 0,  1, 	16, TRUE,  0, complain_overflow_signed,0,"DISP16", 	FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_DISP32, 0,  2, 	32, TRUE,  0, complain_overflow_signed,0,"DISP32", 	FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_WDISP30,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"WDISP30", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_WDISP22,2,  2, 	22, TRUE,  0, complain_overflow_signed,0,"WDISP22", 	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_HI22,   10, 2, 	22, FALSE, 0, complain_overflow_bitfield,0,"HI22",	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_22,     0,  2, 	22, FALSE, 0, complain_overflow_bitfield,0,"22",       FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_13,     0,  2, 	13, FALSE, 0, complain_overflow_bitfield,0,"13",       FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_LO10,   0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"LO10",     FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_SFA_BASE,0, 2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_BASE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_SFA_OFF13,0,2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_OFF13",FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_BASE10, 0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"BASE10",   FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_BASE13, 0,  2,	13, FALSE, 0, complain_overflow_signed,0,"BASE13",   FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_BASE22, 10, 2,	22, FALSE, 0, complain_overflow_bitfield,0,"BASE22",   FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_PC10,   0,  2,	10, TRUE,  0, complain_overflow_dont,0,"PC10",	FALSE, 0,0x000003ff, TRUE),
  HOWTO(RELOC_PC22,   10,  2,	22, TRUE,  0, complain_overflow_signed,0,"PC22", FALSE, 0,0x003fffff, TRUE),
  HOWTO(RELOC_JMP_TBL,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"JMP_TBL", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_SEGOFF16,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"SEGOFF16",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_GLOB_DAT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"GLOB_DAT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_JMP_SLOT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"JMP_SLOT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_RELATIVE,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",	FALSE, 0,0x00000000, FALSE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
d212 1
a212 1
  HOWTO(RELOC_SPARC_REV32,    0,  2, 	32, FALSE, 0, complain_overflow_dont,0,"R_SPARC_REV32",       FALSE, 0,0xffffffff, FALSE),
d266 1
a266 3
NAME(aout,reloc_type_lookup) (abfd,code)
     bfd *abfd;
     bfd_reloc_code_real_type code;
d268 2
a269 2
#define EXT(i, j)	case i: return &howto_table_ext[j]
#define STD(i, j)	case i: return &howto_table_std[j]
d302 2
a303 1
      default: return (reloc_howto_type *) NULL;
d317 2
a318 1
      default: return (reloc_howto_type *) NULL;
a329 1

d339 1
a339 1
            struct external_exec *raw_bytes,
d350 3
a352 4
NAME(aout,swap_exec_header_in) (abfd, raw_bytes, execp)
     bfd *abfd;
     struct external_exec *raw_bytes;
     struct internal_exec *execp;
a353 2
  struct external_exec *bytes = (struct external_exec *)raw_bytes;

d358 1
a358 1
  memset ((PTR) execp, 0, sizeof (struct internal_exec));
d369 1
a369 1
#define NAME_swap_exec_header_in NAME(aout,swap_exec_header_in)
d387 3
a389 4
NAME(aout,swap_exec_header_out) (abfd, execp, raw_bytes)
     bfd *abfd;
     struct internal_exec *execp;
     struct external_exec *raw_bytes;
a390 2
  struct external_exec *bytes = (struct external_exec *)raw_bytes;

d405 1
a405 2
NAME(aout,make_sections) (abfd)
     bfd *abfd;
d407 1
a407 2
  if (obj_textsec (abfd) == (asection *) NULL
      && bfd_make_section (abfd, ".text") == (asection *) NULL)
d409 1
a409 2
  if (obj_datasec (abfd) == (asection *) NULL
      && bfd_make_section (abfd, ".data") == (asection *) NULL)
d411 1
a411 2
  if (obj_bsssec (abfd) == (asection *) NULL
      && bfd_make_section (abfd, ".bss") == (asection *) NULL)
d423 2
a424 1
	  const bfd_target *(*callback_to_real_object_p) ());
d435 3
a437 4
NAME(aout,some_aout_object_p) (abfd, execp, callback_to_real_object_p)
     bfd *abfd;
     struct internal_exec *execp;
     const bfd_target *(*callback_to_real_object_p) PARAMS ((bfd *));
d441 1
a441 1
  bfd_size_type amt = sizeof (struct aout_data_struct);
d443 1
a443 1
  rawptr = (struct aout_data_struct  *) bfd_zalloc (abfd, amt);
d445 1
a445 1
    return 0;
d492 3
a494 5
    {
      /* Should have been checked with N_BADMAG before this routine
	 was called.  */
      abort ();
    }
d498 1
a498 1
  obj_aout_symbols (abfd) = (aout_symbol_type *)NULL;
d515 1
a515 1
  if (! NAME(aout,make_sections) (abfd))
d651 1
a651 2
NAME(aout,mkobject) (abfd)
     bfd *abfd;
d654 1
a654 1
  bfd_size_type amt = sizeof (struct aout_data_struct);
d658 1
a658 1
  rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);
d665 3
a667 3
  obj_textsec (abfd) = (asection *) NULL;
  obj_datasec (abfd) = (asection *) NULL;
  obj_bsssec (abfd) = (asection *) NULL;
d679 2
a680 1
	  unsigned long machine));
d693 3
a695 4
NAME(aout,machine_type) (arch, machine, unknown)
     enum bfd_architecture arch;
     unsigned long machine;
     bfd_boolean *unknown;
d822 1
a822 1
	  unsigned long machine));
d831 3
a833 4
NAME(aout,set_arch_mach) (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d842 1
a842 1
      NAME(aout,machine_type) (arch, machine, &unknown);
d864 1
a864 3
adjust_o_magic (abfd, execp)
     bfd *abfd;
     struct internal_exec *execp;
d924 1
a924 3
adjust_z_magic (abfd, execp)
     bfd *abfd;
     struct internal_exec *execp;
d929 2
a930 1
  int ztih;			/* Nonzero if text includes exec header.  */
d1041 1
a1041 3
adjust_n_magic (abfd, execp)
     bfd *abfd;
     struct internal_exec *execp;
d1082 3
a1084 4
NAME(aout,adjust_sizes_and_vmas) (abfd, text_size, text_end)
     bfd *abfd;
     bfd_size_type *text_size;
     file_ptr *text_end ATTRIBUTE_UNUSED;
d1088 1
a1088 1
  if (! NAME(aout,make_sections) (abfd))
d1179 1
a1179 1
	    asection *newsect));
d1186 1
a1186 3
NAME(aout,new_section_hook) (abfd, newsect)
     bfd *abfd;
     asection *newsect;
d1220 5
a1224 6
NAME(aout,set_section_contents) (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d1231 1
a1231 1
      if (! NAME(aout,adjust_sizes_and_vmas) (abfd, &text_size, &text_end))
d1270 1
a1270 2
aout_get_external_symbols (abfd)
     bfd *abfd;
d1272 1
a1272 1
  if (obj_aout_external_syms (abfd) == (struct external_nlist *) NULL)
d1290 2
a1291 3
      syms = ((struct external_nlist *)
	      bfd_malloc (count * EXTERNAL_NLIST_SIZE));
      if (syms == (struct external_nlist *) NULL && count != 0)
d1317 1
a1317 1
	  || bfd_bread ((PTR) string_chars, amt, abfd) != amt)
d1327 1
a1327 1
      strings = (char *) bfd_malloc (stringsize + 1);
d1359 1
a1359 3
translate_from_native_sym_flags (abfd, cache_ptr)
     bfd *abfd;
     aout_symbol_type *cache_ptr;
d1530 3
a1532 4
translate_to_native_sym_flags (abfd, cache_ptr, sym_pointer)
     bfd *abfd;
     asymbol *cache_ptr;
     struct external_nlist *sym_pointer;
d1642 1
a1642 2
NAME(aout,make_empty_symbol) (abfd)
     bfd *abfd;
d1645 2
a1646 1
  aout_symbol_type *new = (aout_symbol_type *) bfd_zalloc (abfd, amt);
d1657 7
a1663 8
NAME(aout,translate_symbol_table) (abfd, in, ext, count, str, strsize, dynamic)
     bfd *abfd;
     aout_symbol_type *in;
     struct external_nlist *ext;
     bfd_size_type count;
     char *str;
     bfd_size_type strsize;
     bfd_boolean dynamic;
d1708 1
a1708 2
NAME(aout,slurp_symbol_table) (abfd)
     bfd *abfd;
d1715 1
a1715 1
  if (obj_aout_symbols (abfd) != (aout_symbol_type *) NULL)
d1725 1
a1725 1
  cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
d1730 1
a1730 1
  if (! (NAME(aout,translate_symbol_table)
d1750 2
a1751 2
  if (old_external_syms == (struct external_nlist *) NULL
      && obj_aout_external_syms (abfd) != (struct external_nlist *) NULL)
a1772 5
static bfd_size_type add_to_stringtab
  PARAMS ((bfd *, struct bfd_strtab_hash *, const char *, bfd_boolean));
static bfd_boolean emit_stringtab
  PARAMS ((bfd *, struct bfd_strtab_hash *));

d1776 5
a1780 6
static INLINE bfd_size_type
add_to_stringtab (abfd, tab, str, copy)
     bfd *abfd;
     struct bfd_strtab_hash *tab;
     const char *str;
     bfd_boolean copy;
d1798 3
a1800 5
    {
      /* Add BYTES_IN_WORD to the return value to account for the
	 space taken up by the string table size.  */
      index += BYTES_IN_WORD;
    }
d1809 1
a1809 3
emit_stringtab (abfd, tab)
     register bfd *abfd;
     struct bfd_strtab_hash *tab;
d1816 1
a1816 1
  if (bfd_bwrite ((PTR) buffer, amt, abfd) != amt)
d1823 1
a1823 2
NAME(aout,write_syms) (abfd)
     bfd *abfd;
d1862 1
a1862 1
      if (bfd_bwrite ((PTR) &nsp, amt, abfd) != amt)
d1883 1
a1883 3
NAME(aout,canonicalize_symtab) (abfd, location)
     bfd *abfd;
     asymbol **location;
d1885 2
a1886 2
    unsigned int counter = 0;
    aout_symbol_type *symbase;
d1888 2
a1889 2
    if (!NAME(aout,slurp_symbol_table) (abfd))
      return -1;
d1891 6
a1896 6
    for (symbase = obj_aout_symbols (abfd);
	 counter++ < bfd_get_symcount (abfd);
	 )
      *(location++) = (asymbol *) (symbase++);
    *location++ =0;
    return bfd_get_symcount (abfd);
d1902 2
a1903 2
extern void  NAME(aout,swap_std_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_std_external *));
d1906 3
a1908 4
NAME(aout,swap_std_reloc_out) (abfd, g, natptr)
     bfd *abfd;
     arelent *g;
     struct reloc_std_external *natptr;
d1991 2
a1992 2
extern void NAME(aout,swap_ext_reloc_out)
  PARAMS ((bfd *, arelent *, struct reloc_ext_external *));
d1995 3
a1997 4
NAME(aout,swap_ext_reloc_out) (abfd, g, natptr)
     bfd *abfd;
     arelent *g;
     register struct reloc_ext_external *natptr;
d2108 5
a2112 6
NAME(aout,swap_ext_reloc_in) (abfd, bytes, cache_ptr, symbols, symcount)
     bfd *abfd;
     struct reloc_ext_external *bytes;
     arelent *cache_ptr;
     asymbol **symbols;
     bfd_size_type symcount;
d2163 5
a2167 6
NAME(aout,swap_std_reloc_in) (abfd, bytes, cache_ptr, symbols, symcount)
     bfd *abfd;
     struct reloc_std_external *bytes;
     arelent *cache_ptr;
     asymbol **symbols;
     bfd_size_type symcount;
d2233 1
a2233 4
NAME(aout,slurp_reloc_table) (abfd, asect, symbols)
     bfd *abfd;
     sec_ptr asect;
     asymbol **symbols;
d2237 1
a2237 1
  PTR relocs;
d2270 1
a2270 1
  reloc_cache = (arelent *) bfd_zmalloc (amt);
d2317 1
a2317 3
NAME(aout,squirt_out_relocs) (abfd, section)
     bfd *abfd;
     asection *section;
d2331 1
a2331 1
  native = (unsigned char *) bfd_zalloc (abfd, natsize);
d2354 1
a2354 1
  if (bfd_bwrite ((PTR) native, natsize, abfd) != natsize)
d2367 4
a2370 5
NAME(aout,canonicalize_reloc) (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d2381 1
a2381 1
  if (!(tblptr || NAME(aout,slurp_reloc_table) (abfd, section, symbols)))
d2408 1
a2408 3
NAME(aout,get_reloc_upper_bound) (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
d2417 1
a2417 1
    return (sizeof (arelent *) * (asect->reloc_count+1));
d2420 3
a2422 3
    return (sizeof (arelent *)
	    * ((exec_hdr (abfd)->a_drsize / obj_reloc_entry_size (abfd))
	       + 1));
d2425 3
a2427 3
    return (sizeof (arelent *)
	    * ((exec_hdr (abfd)->a_trsize / obj_reloc_entry_size (abfd))
	       + 1));
d2440 1
a2440 2
NAME(aout,get_symtab_upper_bound) (abfd)
     bfd *abfd;
d2442 1
a2442 1
  if (!NAME(aout,slurp_symbol_table) (abfd))
d2449 2
a2450 3
NAME(aout,get_lineno) (ignore_abfd, ignore_symbol)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *ignore_symbol ATTRIBUTE_UNUSED;
d2452 1
a2452 1
  return (alent *)NULL;
d2456 3
a2458 4
NAME(aout,get_symbol_info) (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d2482 4
a2485 5
NAME(aout,print_symbol) (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
d2505 1
a2505 1
	bfd_print_symbol_vandf (abfd, (PTR)file, symbol);
d2529 4
a2532 5
NAME(aout,read_minisymbols) (abfd, dynamic, minisymsp, sizep)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR *minisymsp;
     unsigned int *sizep;
d2535 3
a2537 5
    {
      /* We could handle the dynamic symbols here as well, but it's
         easier to hand them off.  */
      return _bfd_generic_read_minisymbols (abfd, dynamic, minisymsp, sizep);
    }
d2545 1
a2545 1
  *minisymsp = (PTR) obj_aout_external_syms (abfd);
d2562 4
a2565 5
NAME(aout,minisymbol_to_symbol) (abfd, dynamic, minisym, sym)
     bfd *abfd;
     bfd_boolean dynamic;
     const PTR minisym;
     asymbol *sym;
d2574 1
a2574 1
  if (! (NAME(aout,translate_symbol_table)
d2592 7
a2598 9
NAME(aout,find_nearest_line)
     (abfd, section, symbols, offset, filename_ptr, functionname_ptr, line_ptr)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     const char **filename_ptr;
     const char **functionname_ptr;
     unsigned int *line_ptr;
d2605 1
a2605 1
  const char *line_file_name = NULL; /* Value of current_file_name at line number.  */
d2617 1
a2617 1
  if (symbols != (asymbol **)NULL)
d2745 1
a2745 1
      buf = (char *) bfd_malloc (filelen + funclen + 3);
d2789 1
a2789 3
NAME(aout,sizeof_headers) (abfd, execable)
     bfd *abfd;
     bfd_boolean execable ATTRIBUTE_UNUSED;
d2798 1
a2798 2
NAME(aout,bfd_free_cached_info) (abfd)
     bfd *abfd;
d2817 1
a2817 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
a2825 11
static bfd_boolean aout_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean aout_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean aout_link_free_symbols
  PARAMS ((bfd *));
static bfd_boolean aout_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean aout_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));

d2829 3
a2831 4
NAME(aout,link_hash_newfunc) (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d2837 4
a2840 5
  if (ret == (struct aout_link_hash_entry *) NULL)
    ret = ((struct aout_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct aout_link_hash_entry)));
  if (ret == (struct aout_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d2859 5
a2863 6
NAME(aout,link_hash_table_init) (table, abfd, newfunc)
     struct aout_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d2871 1
a2871 2
NAME(aout,link_hash_table_create) (abfd)
     bfd *abfd;
d2874 1
a2874 1
  bfd_size_type amt = sizeof (struct aout_link_hash_table);
d2876 1
a2876 1
  ret = (struct aout_link_hash_table *) bfd_malloc (amt);
d2878 1
a2878 1
    return (struct bfd_link_hash_table *) NULL;
d2880 2
a2881 2
  if (! NAME(aout,link_hash_table_init) (ret, abfd,
					 NAME(aout,link_hash_newfunc)))
d2884 1
a2884 1
      return (struct bfd_link_hash_table *) NULL;
d2889 1
a2889 2
/* Given an a.out BFD, add symbols to the global hash table as
   appropriate.  */
d2891 2
a2892 4
bfd_boolean
NAME(aout,link_add_symbols) (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2894 12
a2905 12
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return aout_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return _bfd_generic_link_add_archive_symbols
	(abfd, info, aout_link_check_archive_element);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}
d2907 7
a2913 1
/* Add symbols from an a.out object file.  */
d2915 1
a2915 10
static bfd_boolean
aout_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  if (! aout_get_external_symbols (abfd))
    return FALSE;
  if (! aout_link_add_symbols (abfd, info))
    return FALSE;
  if (! info->keep_memory)
d2917 2
a2918 1
      if (! aout_link_free_symbols (abfd))
a2920 2
  return TRUE;
}
d2922 7
a2928 12
/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called from
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
aout_link_check_archive_element (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  if (! aout_get_external_symbols (abfd))
d2930 1
d2932 3
a2934 2
  if (! aout_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;
d2936 3
a2938 1
  if (*pneeded)
d2940 6
a2945 3
      if (! aout_link_add_symbols (abfd, info))
	return FALSE;
    }
d2947 1
a2947 5
  if (! info->keep_memory || ! *pneeded)
    {
      if (! aout_link_free_symbols (abfd))
	return FALSE;
    }
d2949 1
a2949 2
  return TRUE;
}
d2951 3
a2953 1
/* Free up the internal symbols read from an a.out file.  */
d2955 8
a2962 24
static bfd_boolean
aout_link_free_symbols (abfd)
     bfd *abfd;
{
  if (obj_aout_external_syms (abfd) != (struct external_nlist *) NULL)
    {
#ifdef USE_MMAP
      bfd_free_window (&obj_aout_sym_window (abfd));
#else
      free ((PTR) obj_aout_external_syms (abfd));
#endif
      obj_aout_external_syms (abfd) = (struct external_nlist *) NULL;
    }
  if (obj_aout_external_strings (abfd) != (char *) NULL)
    {
#ifdef USE_MMAP
      bfd_free_window (&obj_aout_string_window (abfd));
#else
      free ((PTR) obj_aout_external_strings (abfd));
#endif
      obj_aout_external_strings (abfd) = (char *) NULL;
    }
  return TRUE;
}
d2964 10
a2973 43
/* Look through the internal symbols to see if this object file should
   be included in the link.  We should include this object file if it
   defines any symbols which are currently undefined.  If this object
   file defines a common symbol, then we may adjust the size of the
   known symbol but we do not include the object file in the link
   (unless there is some other reason to include it).  */

static bfd_boolean
aout_link_check_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  register struct external_nlist *p;
  struct external_nlist *pend;
  char *strings;

  *pneeded = FALSE;

  /* Look through all the symbols.  */
  p = obj_aout_external_syms (abfd);
  pend = p + obj_aout_external_sym_count (abfd);
  strings = obj_aout_external_strings (abfd);
  for (; p < pend; p++)
    {
      int type = H_GET_8 (abfd, p->e_type);
      const char *name;
      struct bfd_link_hash_entry *h;

      /* Ignore symbols that are not externally visible.  This is an
	 optimization only, as we check the type more thoroughly
	 below.  */
      if (((type & N_EXT) == 0
	   || (type & N_STAB) != 0
	   || type == N_FN)
	  && type != N_WEAKA
	  && type != N_WEAKT
	  && type != N_WEAKD
	  && type != N_WEAKB)
	{
	  if (type == N_WARNING
	      || type == N_INDR)
	    ++p;
d2975 4
a2978 13
	}

      name = strings + GET_WORD (abfd, p->e_strx);
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* We are only interested in symbols that are currently
	 undefined or common.  */
      if (h == (struct bfd_link_hash_entry *) NULL
	  || (h->type != bfd_link_hash_undefined
	      && h->type != bfd_link_hash_common))
	{
	  if (type == (N_INDR | N_EXT))
	    ++p;
a2979 1
	}
d2981 2
a2982 24
      if (type == (N_TEXT | N_EXT)
	  || type == (N_DATA | N_EXT)
	  || type == (N_BSS | N_EXT)
	  || type == (N_ABS | N_EXT)
	  || type == (N_INDR | N_EXT))
	{
	  /* This object file defines this symbol.  We must link it
	     in.  This is true regardless of whether the current
	     definition of the symbol is undefined or common.

             If the current definition is common, we have a case in
	     which we have already seen an object file including:
	         int a;
	     and this object file from the archive includes:
	         int a = 5;
	     In such a case, whether to include this object is target
             dependant for backward compatibility.

	     FIXME: The SunOS 4.1.3 linker will pull in the archive
	     element if the symbol is defined in the .data section,
	     but not if it is defined in the .text section.  That
	     seems a bit crazy to me, and it has not been implemented
	     yet.  However, it might be correct.  */
	  if (h->type == bfd_link_hash_common)
d2984 2
a2985 18
	      int skip = 0;

	      switch (info->common_skip_ar_aymbols)
		{
		case bfd_link_common_skip_text:
		  skip = (type == (N_TEXT | N_EXT));
		  break;
		case bfd_link_common_skip_data:
		  skip = (type == (N_DATA | N_EXT));
		  break;
		default:
		case bfd_link_common_skip_all:
		  skip = 1;
		  break;
		}

	      if (skip)
		continue;
d2987 2
a2988 192

	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}

      if (type == (N_UNDF | N_EXT))
	{
	  bfd_vma value;

	  value = GET_WORD (abfd, p->e_value);
	  if (value != 0)
	    {
	      /* This symbol is common in the object from the archive
		 file.  */
	      if (h->type == bfd_link_hash_undefined)
		{
		  bfd *symbfd;
		  unsigned int power;

		  symbfd = h->u.undef.abfd;
		  if (symbfd == (bfd *) NULL)
		    {
		      /* This symbol was created as undefined from
			 outside BFD.  We assume that we should link
			 in the object file.  This is done for the -u
			 option in the linker.  */
		      if (! (*info->callbacks->add_archive_element) (info,
								     abfd,
								     name))
			return FALSE;
		      *pneeded = TRUE;
		      return TRUE;
		    }
		  /* Turn the current link symbol into a common
		     symbol.  It is already on the undefs list.  */
		  h->type = bfd_link_hash_common;
		  h->u.c.p = ((struct bfd_link_hash_common_entry *)
			      bfd_hash_allocate (&info->hash->table,
				  sizeof (struct bfd_link_hash_common_entry)));
		  if (h->u.c.p == NULL)
		    return FALSE;

		  h->u.c.size = value;

		  /* FIXME: This isn't quite right.  The maximum
		     alignment of a common symbol should be set by the
		     architecture of the output file, not of the input
		     file.  */
		  power = bfd_log2 (value);
		  if (power > bfd_get_arch_info (abfd)->section_align_power)
		    power = bfd_get_arch_info (abfd)->section_align_power;
		  h->u.c.p->alignment_power = power;

		  h->u.c.p->section = bfd_make_section_old_way (symbfd,
								"COMMON");
		}
	      else
		{
		  /* Adjust the size of the common symbol if
		     necessary.  */
		  if (value > h->u.c.size)
		    h->u.c.size = value;
		}
	    }
	}

      if (type == N_WEAKA
	  || type == N_WEAKT
	  || type == N_WEAKD
	  || type == N_WEAKB)
	{
	  /* This symbol is weak but defined.  We must pull it in if
	     the current link symbol is undefined, but we don't want
	     it if the current link symbol is common.  */
	  if (h->type == bfd_link_hash_undefined)
	    {
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}
    }

  /* We do not need this object file.  */
  return TRUE;
}

/* Add all symbols from an object file to the hash table.  */

static bfd_boolean
aout_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	     bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
  struct external_nlist *syms;
  bfd_size_type sym_count;
  char *strings;
  bfd_boolean copy;
  struct aout_link_hash_entry **sym_hash;
  register struct external_nlist *p;
  struct external_nlist *pend;
  bfd_size_type amt;

  syms = obj_aout_external_syms (abfd);
  sym_count = obj_aout_external_sym_count (abfd);
  strings = obj_aout_external_strings (abfd);
  if (info->keep_memory)
    copy = FALSE;
  else
    copy = TRUE;

  if (aout_backend_info (abfd)->add_dynamic_symbols != NULL)
    {
      if (! ((*aout_backend_info (abfd)->add_dynamic_symbols)
	     (abfd, info, &syms, &sym_count, &strings)))
	return FALSE;
    }

  /* We keep a list of the linker hash table entries that correspond
     to particular symbols.  We could just look them up in the hash
     table, but keeping the list is more efficient.  Perhaps this
     should be conditional on info->keep_memory.  */
  amt = sym_count * sizeof (struct aout_link_hash_entry *);
  sym_hash = (struct aout_link_hash_entry **) bfd_alloc (abfd, amt);
  if (sym_hash == NULL && sym_count != 0)
    return FALSE;
  obj_aout_sym_hashes (abfd) = sym_hash;

  add_one_symbol = aout_backend_info (abfd)->add_one_symbol;
  if (add_one_symbol == NULL)
    add_one_symbol = _bfd_generic_link_add_one_symbol;

  p = syms;
  pend = p + sym_count;
  for (; p < pend; p++, sym_hash++)
    {
      int type;
      const char *name;
      bfd_vma value;
      asection *section;
      flagword flags;
      const char *string;

      *sym_hash = NULL;

      type = H_GET_8 (abfd, p->e_type);

      /* Ignore debugging symbols.  */
      if ((type & N_STAB) != 0)
	continue;

      name = strings + GET_WORD (abfd, p->e_strx);
      value = GET_WORD (abfd, p->e_value);
      flags = BSF_GLOBAL;
      string = NULL;
      switch (type)
	{
	default:
	  abort ();

	case N_UNDF:
	case N_ABS:
	case N_TEXT:
	case N_DATA:
	case N_BSS:
	case N_FN_SEQ:
	case N_COMM:
	case N_SETV:
	case N_FN:
	  /* Ignore symbols that are not externally visible.  */
	  continue;
	case N_INDR:
	  /* Ignore local indirect symbol.  */
	  ++p;
	  ++sym_hash;
	  continue;

	case N_UNDF | N_EXT:
	  if (value == 0)
	    {
	      section = bfd_und_section_ptr;
	      flags = 0;
	    }
	  else
	    section = bfd_com_section_ptr;
a3105 2

/* A hash table used for header files with N_BINCL entries.  */
d3107 4
a3110 1
struct aout_link_includes_table
d3112 20
a3131 2
  struct bfd_hash_table root;
};
d3133 1
a3133 2
/* A linked list of totals that we have found for a particular header
   file.  */
d3135 2
a3136 1
struct aout_link_includes_totals
d3138 11
a3148 3
  struct aout_link_includes_totals *next;
  bfd_vma total;
};
d3150 6
a3155 1
/* An entry in the header file hash table.  */
d3157 4
a3160 1
struct aout_link_includes_entry
d3162 3
a3164 4
  struct bfd_hash_entry root;
  /* List of totals we have found for this file.  */
  struct aout_link_includes_totals *totals;
};
d3166 1
a3166 1
/* Look up an entry in an the header file hash table.  */
d3168 253
a3420 3
#define aout_link_includes_lookup(table, string, create, copy)		\
  ((struct aout_link_includes_entry *)					\
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
d3442 1
a3442 1
  PTR relocs;
a3448 26
static struct bfd_hash_entry *aout_link_includes_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean aout_link_input_bfd
  PARAMS ((struct aout_final_link_info *, bfd *input_bfd));
static bfd_boolean aout_link_write_symbols
  PARAMS ((struct aout_final_link_info *, bfd *input_bfd));
static bfd_boolean aout_link_write_other_symbol
  PARAMS ((struct aout_link_hash_entry *, PTR));
static bfd_boolean aout_link_input_section
  PARAMS ((struct aout_final_link_info *, bfd *input_bfd,
	   asection *input_section, file_ptr *reloff_ptr,
	   bfd_size_type rel_size));
static bfd_boolean aout_link_input_section_std
  PARAMS ((struct aout_final_link_info *, bfd *input_bfd,
	   asection *input_section, struct reloc_std_external *,
	   bfd_size_type rel_size, bfd_byte *contents));
static bfd_boolean aout_link_input_section_ext
  PARAMS ((struct aout_final_link_info *, bfd *input_bfd,
	   asection *input_section, struct reloc_ext_external *,
	   bfd_size_type rel_size, bfd_byte *contents));
static INLINE asection *aout_reloc_index_to_section
  PARAMS ((bfd *, int));
static bfd_boolean aout_link_reloc_link_order
  PARAMS ((struct aout_final_link_info *, asection *,
	   struct bfd_link_order *));

d3452 3
a3454 4
aout_link_includes_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d3461 4
a3464 6
  if (ret == (struct aout_link_includes_entry *) NULL)
    ret = ((struct aout_link_includes_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct aout_link_includes_entry)));
  if (ret == (struct aout_link_includes_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d3478 2
a3479 6
/* Do the final link step.  This is called on the output BFD.  The
   INFO structure should point to a list of BFDs linked through the
   link_next field which can be used to find each BFD which takes part
   in the output.  Also, each section in ABFD should point to a list
   of bfd_link_order structures which list all the input sections for
   the output section.  */
d3481 2
a3482 5
bfd_boolean
NAME(aout,final_link) (abfd, info, callback)
     bfd *abfd;
     struct bfd_link_info *info;
     void (*callback) PARAMS ((bfd *, file_ptr *, file_ptr *, file_ptr *));
d3484 14
a3497 12
  struct aout_final_link_info aout_info;
  bfd_boolean includes_hash_initialized = FALSE;
  register bfd *sub;
  bfd_size_type trsize, drsize;
  bfd_size_type max_contents_size;
  bfd_size_type max_relocs_size;
  bfd_size_type max_sym_count;
  bfd_size_type text_size;
  file_ptr text_end;
  register struct bfd_link_order *p;
  asection *o;
  bfd_boolean have_link_order_relocs;
d3499 1
a3499 2
  if (info->shared)
    abfd->flags |= DYNAMIC;
d3501 1
a3501 21
  aout_info.info = info;
  aout_info.output_bfd = abfd;
  aout_info.contents = NULL;
  aout_info.relocs = NULL;
  aout_info.symbol_map = NULL;
  aout_info.output_syms = NULL;

  if (! bfd_hash_table_init_n (&aout_info.includes.root,
			       aout_link_includes_newfunc,
			       251))
    goto error_return;
  includes_hash_initialized = TRUE;

  /* Figure out the largest section size.  Also, if generating
     relocatable output, count the relocs.  */
  trsize = 0;
  drsize = 0;
  max_contents_size = 0;
  max_relocs_size = 0;
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
d3503 2
a3504 3
      bfd_size_type sz;

      if (info->relocatable)
d3506 2
a3507 18
	  if (bfd_get_flavour (sub) == bfd_target_aout_flavour)
	    {
	      trsize += exec_hdr (sub)->a_trsize;
	      drsize += exec_hdr (sub)->a_drsize;
	    }
	  else
	    {
	      /* FIXME: We need to identify the .text and .data sections
		 and call get_reloc_upper_bound and canonicalize_reloc to
		 work out the number of relocs needed, and then multiply
		 by the reloc size.  */
	      (*_bfd_error_handler)
		(_("%s: relocatable link from %s to %s not supported"),
		 bfd_get_filename (abfd),
		 sub->xvec->name, abfd->xvec->name);
	      bfd_set_error (bfd_error_invalid_operation);
	      goto error_return;
	    }
d3509 1
d3511 2
a3512 8
      if (bfd_get_flavour (sub) == bfd_target_aout_flavour)
	{
	  sz = obj_textsec (sub)->size;
	  if (sz > max_contents_size)
	    max_contents_size = sz;
	  sz = obj_datasec (sub)->size;
	  if (sz > max_contents_size)
	    max_contents_size = sz;
d3514 1
a3514 6
	  sz = exec_hdr (sub)->a_trsize;
	  if (sz > max_relocs_size)
	    max_relocs_size = sz;
	  sz = exec_hdr (sub)->a_drsize;
	  if (sz > max_relocs_size)
	    max_relocs_size = sz;
d3516 7
a3522 5
	  sz = obj_aout_external_sym_count (sub);
	  if (sz > max_sym_count)
	    max_sym_count = sz;
	}
    }
d3524 1
a3524 1
  if (info->relocatable)
d3526 46
a3571 8
      if (obj_textsec (abfd) != (asection *) NULL)
	trsize += (_bfd_count_link_order_relocs (obj_textsec (abfd)
						 ->link_order_head)
		   * obj_reloc_entry_size (abfd));
      if (obj_datasec (abfd) != (asection *) NULL)
	drsize += (_bfd_count_link_order_relocs (obj_datasec (abfd)
						 ->link_order_head)
		   * obj_reloc_entry_size (abfd));
d3574 8
a3581 2
  exec_hdr (abfd)->a_trsize = trsize;
  exec_hdr (abfd)->a_drsize = drsize;
d3583 2
a3584 1
  exec_hdr (abfd)->a_entry = bfd_get_start_address (abfd);
d3586 5
a3590 5
  /* Adjust the section sizes and vmas according to the magic number.
     This sets a_text, a_data and a_bss in the exec_hdr and sets the
     filepos for each section.  */
  if (! NAME(aout,adjust_sizes_and_vmas) (abfd, &text_size, &text_end))
    goto error_return;
d3592 3
a3594 13
  /* The relocation and symbol file positions differ among a.out
     targets.  We are passed a callback routine from the backend
     specific code to handle this.
     FIXME: At this point we do not know how much space the symbol
     table will require.  This will not work for any (nonstandard)
     a.out target that needs to know the symbol table size before it
     can compute the relocation file positions.  This may or may not
     be the case for the hp300hpux target, for example.  */
  (*callback) (abfd, &aout_info.treloff, &aout_info.dreloff,
	       &aout_info.symoff);
  obj_textsec (abfd)->rel_filepos = aout_info.treloff;
  obj_datasec (abfd)->rel_filepos = aout_info.dreloff;
  obj_sym_filepos (abfd) = aout_info.symoff;
d3596 2
a3597 2
  /* We keep a count of the symbols as we output them.  */
  obj_aout_external_sym_count (abfd) = 0;
d3599 1
a3599 4
  /* We accumulate the string table as we write out the symbols.  */
  aout_info.strtab = _bfd_stringtab_init ();
  if (aout_info.strtab == NULL)
    goto error_return;
d3601 14
a3614 12
  /* Allocate buffers to hold section contents and relocs.  */
  aout_info.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  aout_info.relocs = (PTR) bfd_malloc (max_relocs_size);
  aout_info.symbol_map = (int *) bfd_malloc (max_sym_count * sizeof (int *));
  aout_info.output_syms = ((struct external_nlist *)
			   bfd_malloc ((max_sym_count + 1)
				       * sizeof (struct external_nlist)));
  if ((aout_info.contents == NULL && max_contents_size != 0)
      || (aout_info.relocs == NULL && max_relocs_size != 0)
      || (aout_info.symbol_map == NULL && max_sym_count != 0)
      || aout_info.output_syms == NULL)
    goto error_return;
d3616 1
a3616 6
  /* If we have a symbol named __DYNAMIC, force it out now.  This is
     required by SunOS.  Doing this here rather than in sunos.c is a
     hack, but it's easier than exporting everything which would be
     needed.  */
  {
    struct aout_link_hash_entry *h;
d3618 14
a3631 5
    h = aout_link_hash_lookup (aout_hash_table (info), "__DYNAMIC",
			       FALSE, FALSE, FALSE);
    if (h != NULL)
      aout_link_write_other_symbol (h, &aout_info);
  }
d3633 28
a3660 10
  /* The most time efficient way to do the link would be to read all
     the input object files into memory and then sort out the
     information into the output file.  Unfortunately, that will
     probably use too much memory.  Another method would be to step
     through everything that composes the text section and write it
     out, and then everything that composes the data section and write
     it out, and then write out the relocs, and then write out the
     symbols.  Unfortunately, that requires reading stuff from each
     input file several times, and we will not be able to keep all the
     input files open simultaneously, and reopening them will be slow.
d3662 2
a3663 18
     What we do is basically process one input file at a time.  We do
     everything we need to do with an input file once--copy over the
     section contents, handle the relocation information, and write
     out the symbols--and then we throw away the information we read
     from it.  This approach requires a lot of lseeks of the output
     file, which is unfortunate but still faster than reopening a lot
     of files.

     We use the output_has_begun field of the input BFDs to see
     whether we have already handled it.  */
  for (sub = info->input_bfds; sub != (bfd *) NULL; sub = sub->link_next)
    sub->output_has_begun = FALSE;

  /* Mark all sections which are to be included in the link.  This
     will normally be every section.  We need to do this so that we
     can identify any sections which the linker has decided to not
     include.  */
  for (o = abfd->sections; o != NULL; o = o->next)
d3665 2
a3666 3
      for (p = o->link_order_head; p != NULL; p = p->next)
	if (p->type == bfd_indirect_link_order)
	  p->u.indirect.section->linker_mark = TRUE;
d3669 8
a3676 2
  have_link_order_relocs = FALSE;
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d3678 10
a3687 9
      for (p = o->link_order_head;
	   p != (struct bfd_link_order *) NULL;
	   p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_aout_flavour))
	    {
	      bfd *input_bfd;
d3689 5
a3693 21
	      input_bfd = p->u.indirect.section->owner;
	      if (! input_bfd->output_has_begun)
		{
		  if (! aout_link_input_bfd (&aout_info, input_bfd))
		    goto error_return;
		  input_bfd->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      /* These are handled below.  */
	      have_link_order_relocs = TRUE;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }
d3695 30
a3724 4
  /* Write out any symbols that we have not already written out.  */
  aout_link_hash_traverse (aout_hash_table (info),
			   aout_link_write_other_symbol,
			   (PTR) &aout_info);
d3726 6
a3731 7
  /* Now handle any relocs we were asked to create by the linker.
     These did not come from any input file.  We must do these after
     we have written out all the symbols, so that we know the symbol
     indices to use.  */
  if (have_link_order_relocs)
    {
      for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d3733 12
a3744 3
	  for (p = o->link_order_head;
	       p != (struct bfd_link_order *) NULL;
	       p = p->next)
d3746 13
a3758 2
	      if (p->type == bfd_section_reloc_link_order
		  || p->type == bfd_symbol_reloc_link_order)
d3760 2
a3761 2
		  if (! aout_link_reloc_link_order (&aout_info, o, p))
		    goto error_return;
d3763 1
d3765 5
d3772 1
a3772 2

  if (aout_info.contents != NULL)
d3774 5
a3778 23
      free (aout_info.contents);
      aout_info.contents = NULL;
    }
  if (aout_info.relocs != NULL)
    {
      free (aout_info.relocs);
      aout_info.relocs = NULL;
    }
  if (aout_info.symbol_map != NULL)
    {
      free (aout_info.symbol_map);
      aout_info.symbol_map = NULL;
    }
  if (aout_info.output_syms != NULL)
    {
      free (aout_info.output_syms);
      aout_info.output_syms = NULL;
    }
  if (includes_hash_initialized)
    {
      bfd_hash_table_free (&aout_info.includes.root);
      includes_hash_initialized = FALSE;
    }
d3780 18
a3797 6
  /* Finish up any dynamic linking we may be doing.  */
  if (aout_backend_info (abfd)->finish_dynamic_link != NULL)
    {
      if (! (*aout_backend_info (abfd)->finish_dynamic_link) (abfd, info))
	goto error_return;
    }
d3799 2
a3800 8
  /* Update the header information.  */
  abfd->symcount = obj_aout_external_sym_count (abfd);
  exec_hdr (abfd)->a_syms = abfd->symcount * EXTERNAL_NLIST_SIZE;
  obj_str_filepos (abfd) = obj_sym_filepos (abfd) + exec_hdr (abfd)->a_syms;
  obj_textsec (abfd)->reloc_count =
    exec_hdr (abfd)->a_trsize / obj_reloc_entry_size (abfd);
  obj_datasec (abfd)->reloc_count =
    exec_hdr (abfd)->a_drsize / obj_reloc_entry_size (abfd);
d3802 1
a3802 6
  /* Write out the string table, unless there are no symbols.  */
  if (abfd->symcount > 0)
    {
      if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0
	  || ! emit_stringtab (abfd, aout_info.strtab))
	goto error_return;
a3803 5
  else if (obj_textsec (abfd)->reloc_count == 0
	   && obj_datasec (abfd)->reloc_count == 0)
    {
      bfd_byte b;
      file_ptr pos;
d3805 13
a3817 6
      b = 0;
      pos = obj_datasec (abfd)->filepos + exec_hdr (abfd)->a_data - 1;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)
	goto error_return;
    }
a3819 13

 error_return:
  if (aout_info.contents != NULL)
    free (aout_info.contents);
  if (aout_info.relocs != NULL)
    free (aout_info.relocs);
  if (aout_info.symbol_map != NULL)
    free (aout_info.symbol_map);
  if (aout_info.output_syms != NULL)
    free (aout_info.output_syms);
  if (includes_hash_initialized)
    bfd_hash_table_free (&aout_info.includes.root);
  return FALSE;
d3822 1
a3822 1
/* Link an a.out input BFD into the output file.  */
d3824 2
a3825 4
static bfd_boolean
aout_link_input_bfd (finfo, input_bfd)
     struct aout_final_link_info *finfo;
     bfd *input_bfd;
d3827 1
a3827 7
  bfd_size_type sym_count;

  BFD_ASSERT (bfd_get_format (input_bfd) == bfd_object);

  /* If this is a dynamic object, it may need special handling.  */
  if ((input_bfd->flags & DYNAMIC) != 0
      && aout_backend_info (input_bfd)->link_dynamic_object != NULL)
d3829 6
a3834 2
      return ((*aout_backend_info (input_bfd)->link_dynamic_object)
	      (finfo->info, input_bfd));
d3836 1
a3836 44

  /* Get the symbols.  We probably have them already, unless
     finfo->info->keep_memory is FALSE.  */
  if (! aout_get_external_symbols (input_bfd))
    return FALSE;

  sym_count = obj_aout_external_sym_count (input_bfd);

  /* Write out the symbols and get a map of the new indices.  The map
     is placed into finfo->symbol_map.  */
  if (! aout_link_write_symbols (finfo, input_bfd))
    return FALSE;

  /* Relocate and write out the sections.  These functions use the
     symbol map created by aout_link_write_symbols.  The linker_mark
     field will be set if these sections are to be included in the
     link, which will normally be the case.  */
  if (obj_textsec (input_bfd)->linker_mark)
    {
      if (! aout_link_input_section (finfo, input_bfd,
				     obj_textsec (input_bfd),
				     &finfo->treloff,
				     exec_hdr (input_bfd)->a_trsize))
	return FALSE;
    }
  if (obj_datasec (input_bfd)->linker_mark)
    {
      if (! aout_link_input_section (finfo, input_bfd,
				     obj_datasec (input_bfd),
				     &finfo->dreloff,
				     exec_hdr (input_bfd)->a_drsize))
	return FALSE;
    }

  /* If we are not keeping memory, we don't need the symbols any
     longer.  We still need them if we are keeping memory, because the
     strings in the hash table point into them.  */
  if (! finfo->info->keep_memory)
    {
      if (! aout_link_free_symbols (input_bfd))
	return FALSE;
    }

  return TRUE;
d3839 1
a3839 2
/* Adjust and write out the symbols for an a.out file.  Set the new
   symbol indices into a symbol_map.  */
d3842 6
a3847 3
aout_link_write_symbols (finfo, input_bfd)
     struct aout_final_link_info *finfo;
     bfd *input_bfd;
d3849 4
d3854 2
a3855 1
  bfd_size_type sym_count;
d3857 1
a3857 7
  enum bfd_link_strip strip;
  enum bfd_link_discard discard;
  struct external_nlist *outsym;
  bfd_size_type strtab_index;
  register struct external_nlist *sym;
  struct external_nlist *sym_end;
  struct aout_link_hash_entry **sym_hash;
d3859 3
a3861 2
  bfd_boolean pass;
  bfd_boolean skip_next;
d3864 1
a3864 5
  sym_count = obj_aout_external_sym_count (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  strip = finfo->info->strip;
  discard = finfo->info->discard;
  outsym = finfo->output_syms;
d3866 3
a3868 24
  /* First write out a symbol for this object file, unless we are
     discarding such symbols.  */
  if (strip != strip_all
      && (strip != strip_some
	  || bfd_hash_lookup (finfo->info->keep_hash, input_bfd->filename,
			      FALSE, FALSE) != NULL)
      && discard != discard_all)
    {
      H_PUT_8 (output_bfd, N_TEXT, outsym->e_type);
      H_PUT_8 (output_bfd, 0, outsym->e_other);
      H_PUT_16 (output_bfd, 0, outsym->e_desc);
      strtab_index = add_to_stringtab (output_bfd, finfo->strtab,
				       input_bfd->filename, FALSE);
      if (strtab_index == (bfd_size_type) -1)
	return FALSE;
      PUT_WORD (output_bfd, strtab_index, outsym->e_strx);
      PUT_WORD (output_bfd,
		(bfd_get_section_vma (output_bfd,
				      obj_textsec (input_bfd)->output_section)
		 + obj_textsec (input_bfd)->output_offset),
		outsym->e_value);
      ++obj_aout_external_sym_count (output_bfd);
      ++outsym;
    }
d3870 4
a3873 5
  pass = FALSE;
  skip_next = FALSE;
  sym = obj_aout_external_syms (input_bfd);
  sym_end = sym + sym_count;
  sym_hash = obj_aout_sym_hashes (input_bfd);
d3875 5
a3879 2
  memset (symbol_map, 0, (size_t) sym_count * sizeof *symbol_map);
  for (; sym < sym_end; sym++, sym_hash++, symbol_map++)
d3881 9
a3889 7
      const char *name;
      int type;
      struct aout_link_hash_entry *h;
      bfd_boolean skip;
      asection *symsec;
      bfd_vma val = 0;
      bfd_boolean copy;
d3891 1
a3891 6
      /* We set *symbol_map to 0 above for all symbols.  If it has
         already been set to -1 for this symbol, it means that we are
         discarding it because it appears in a duplicate header file.
         See the N_BINCL code below.  */
      if (*symbol_map == -1)
	continue;
d3893 8
a3900 4
      /* Initialize *symbol_map to -1, which means that the symbol was
         not copied into the output file.  We will change it later if
         we do copy the symbol over.  */
      *symbol_map = -1;
d3902 29
a3930 2
      type = H_GET_8 (input_bfd, sym->e_type);
      name = strings + GET_WORD (input_bfd, sym->e_strx);
d3932 6
a3937 1
      h = NULL;
d3939 1
a3939 1
      if (pass)
d3941 19
a3959 16
	  /* Pass this symbol through.  It is the target of an
	     indirect or warning symbol.  */
	  val = GET_WORD (input_bfd, sym->e_value);
	  pass = FALSE;
	}
      else if (skip_next)
	{
	  /* Skip this symbol, which is the target of an indirect
	     symbol that we have changed to no longer be an indirect
	     symbol.  */
	  skip_next = FALSE;
	  continue;
	}
      else
	{
	  struct aout_link_hash_entry *hresolve;
d3961 55
a4015 5
	  /* We have saved the hash table entry for this symbol, if
	     there is one.  Note that we could just look it up again
	     in the hash table, provided we first check that it is an
	     external symbol.  */
	  h = *sym_hash;
d4017 2
a4018 5
	  /* Use the name from the hash table, in case the symbol was
             wrapped.  */
	  if (h != NULL
	      && h->root.type != bfd_link_hash_warning)
	    name = h->root.root.string;
d4020 15
a4034 8
	  /* If this is an indirect or warning symbol, then change
	     hresolve to the base symbol.  We also change *sym_hash so
	     that the relocation routines relocate against the real
	     symbol.  */
	  hresolve = h;
	  if (h != (struct aout_link_hash_entry *) NULL
	      && (h->root.type == bfd_link_hash_indirect
		  || h->root.type == bfd_link_hash_warning))
d4036 8
a4043 6
	      hresolve = (struct aout_link_hash_entry *) h->root.u.i.link;
	      while (hresolve->root.type == bfd_link_hash_indirect
		     || hresolve->root.type == bfd_link_hash_warning)
		hresolve = ((struct aout_link_hash_entry *)
			    hresolve->root.u.i.link);
	      *sym_hash = hresolve;
d4046 33
a4078 3
	  /* If the symbol has already been written out, skip it.  */
	  if (h != (struct aout_link_hash_entry *) NULL
	      && h->written)
d4080 1
a4080 6
	      if ((type & N_TYPE) == N_INDR
		  || type == N_WARNING)
		skip_next = TRUE;
	      *symbol_map = h->indx;
	      continue;
	    }
d4082 16
a4097 18
	  /* See if we are stripping this symbol.  */
	  skip = FALSE;
	  switch (strip)
	    {
	    case strip_none:
	      break;
	    case strip_debugger:
	      if ((type & N_STAB) != 0)
		skip = TRUE;
	      break;
	    case strip_some:
	      if (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
		  == NULL)
		skip = TRUE;
	      break;
	    case strip_all:
	      skip = TRUE;
	      break;
d4099 1
a4099 1
	  if (skip)
d4101 8
a4108 3
	      if (h != (struct aout_link_hash_entry *) NULL)
		h->written = TRUE;
	      continue;
d4111 1
a4111 19
	  /* Get the value of the symbol.  */
	  if ((type & N_TYPE) == N_TEXT
	      || type == N_WEAKT)
	    symsec = obj_textsec (input_bfd);
	  else if ((type & N_TYPE) == N_DATA
		   || type == N_WEAKD)
	    symsec = obj_datasec (input_bfd);
	  else if ((type & N_TYPE) == N_BSS
		   || type == N_WEAKB)
	    symsec = obj_bsssec (input_bfd);
	  else if ((type & N_TYPE) == N_ABS
		   || type == N_WEAKA)
	    symsec = bfd_abs_section_ptr;
	  else if (((type & N_TYPE) == N_INDR
		    && (hresolve == (struct aout_link_hash_entry *) NULL
			|| (hresolve->root.type != bfd_link_hash_defined
			    && hresolve->root.type != bfd_link_hash_defweak
			    && hresolve->root.type != bfd_link_hash_common)))
		   || type == N_WARNING)
d4113 8
a4120 8
	      /* Pass the next symbol through unchanged.  The
		 condition above for indirect symbols is so that if
		 the indirect symbol was defined, we output it with
		 the correct definition so the debugger will
		 understand it.  */
	      pass = TRUE;
	      val = GET_WORD (input_bfd, sym->e_value);
	      symsec = NULL;
d4122 5
a4126 1
	  else if ((type & N_STAB) != 0)
d4128 10
a4137 2
	      val = GET_WORD (input_bfd, sym->e_value);
	      symsec = NULL;
a4138 8
	  else
	    {
	      /* If we get here with an indirect symbol, it means that
		 we are outputting it with a real definition.  In such
		 a case we do not want to output the next symbol,
		 which is the target of the indirection.  */
	      if ((type & N_TYPE) == N_INDR)
		skip_next = TRUE;
d4140 5
a4144 1
	      symsec = NULL;
d4146 134
a4279 26
	      /* We need to get the value from the hash table.  We use
		 hresolve so that if we have defined an indirect
		 symbol we output the final definition.  */
	      if (h == (struct aout_link_hash_entry *) NULL)
		{
		  switch (type & N_TYPE)
		    {
		    case N_SETT:
		      symsec = obj_textsec (input_bfd);
		      break;
		    case N_SETD:
		      symsec = obj_datasec (input_bfd);
		      break;
		    case N_SETB:
		      symsec = obj_bsssec (input_bfd);
		      break;
		    case N_SETA:
		      symsec = bfd_abs_section_ptr;
		      break;
		    default:
		      val = 0;
		      break;
		    }
		}
	      else if (hresolve->root.type == bfd_link_hash_defined
		       || hresolve->root.type == bfd_link_hash_defweak)
a4280 1
		  asection *input_section;
d4283 5
a4287 20
		  /* This case usually means a common symbol which was
		     turned into a defined symbol.  */
		  input_section = hresolve->root.u.def.section;
		  output_section = input_section->output_section;
		  BFD_ASSERT (bfd_is_abs_section (output_section)
			      || output_section->owner == output_bfd);
		  val = (hresolve->root.u.def.value
			 + bfd_get_section_vma (output_bfd, output_section)
			 + input_section->output_offset);

		  /* Get the correct type based on the section.  If
		     this is a constructed set, force it to be
		     globally visible.  */
		  if (type == N_SETT
		      || type == N_SETD
		      || type == N_SETB
		      || type == N_SETA)
		    type |= N_EXT;

		  type &=~ N_TYPE;
d4289 2
d4292 1
a4292 3
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_TEXT
			     : N_WEAKT);
d4294 1
a4294 3
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_DATA
			     : N_WEAKD);
d4296 1
a4296 3
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_BSS
			     : N_WEAKB);
d4298 15
a4312 10
		    type |= (hresolve->root.type == bfd_link_hash_defined
			     ? N_ABS
			     : N_WEAKA);
		}
	      else if (hresolve->root.type == bfd_link_hash_common)
		val = hresolve->root.u.c.size;
	      else if (hresolve->root.type == bfd_link_hash_undefweak)
		{
		  val = 0;
		  type = N_WEAKU;
a4314 21
		val = 0;
	    }
	  if (symsec != (asection *) NULL)
	    val = (symsec->output_section->vma
		   + symsec->output_offset
		   + (GET_WORD (input_bfd, sym->e_value)
		      - symsec->vma));

	  /* If this is a global symbol set the written flag, and if
	     it is a local symbol see if we should discard it.  */
	  if (h != (struct aout_link_hash_entry *) NULL)
	    {
	      h->written = TRUE;
	      h->indx = obj_aout_external_sym_count (output_bfd);
	    }
	  else if ((type & N_TYPE) != N_SETT
		   && (type & N_TYPE) != N_SETD
		   && (type & N_TYPE) != N_SETB
		   && (type & N_TYPE) != N_SETA)
	    {
	      switch (discard)
d4316 3
a4318 18
		case discard_none:
		case discard_sec_merge:
		  break;
		case discard_l:
		  if ((type & N_STAB) == 0
		      && bfd_is_local_label_name (input_bfd, name))
		    skip = TRUE;
		  break;
		case discard_all:
		  skip = TRUE;
		  break;
		}
	      if (skip)
		{
		  pass = FALSE;
		  continue;
		}
	    }
d4320 1
a4320 21
	  /* An N_BINCL symbol indicates the start of the stabs
	     entries for a header file.  We need to scan ahead to the
	     next N_EINCL symbol, ignoring nesting, adding up all the
	     characters in the symbol names, not including the file
	     numbers in types (the first number after an open
	     parenthesis).  */
	  if (type == (int) N_BINCL)
	    {
	      struct external_nlist *incl_sym;
	      int nest;
	      struct aout_link_includes_entry *incl_entry;
	      struct aout_link_includes_totals *t;

	      val = 0;
	      nest = 0;
	      for (incl_sym = sym + 1; incl_sym < sym_end; incl_sym++)
		{
		  int incl_type;

		  incl_type = H_GET_8 (input_bfd, incl_sym->e_type);
		  if (incl_type == (int) N_EINCL)
d4322 8
a4329 15
		      if (nest == 0)
			break;
		      --nest;
		    }
		  else if (incl_type == (int) N_BINCL)
		    ++nest;
		  else if (nest == 0)
		    {
		      const char *s;

		      s = strings + GET_WORD (input_bfd, incl_sym->e_strx);
		      for (; *s != '\0'; s++)
			{
			  val += *s;
			  if (*s == '(')
d4331 5
a4335 5
			      /* Skip the file number.  */
			      ++s;
			      while (ISDIGIT (*s))
				++s;
			      --s;
d4337 13
d4352 7
d4361 2
a4362 12
	      /* If we have already included a header file with the
                 same value, then replace this one with an N_EXCL
                 symbol.  */
	      copy = (bfd_boolean) (! finfo->info->keep_memory);
	      incl_entry = aout_link_includes_lookup (&finfo->includes,
						      name, TRUE, copy);
	      if (incl_entry == NULL)
		return FALSE;
	      for (t = incl_entry->totals; t != NULL; t = t->next)
		if (t->total == val)
		  break;
	      if (t == NULL)
d4364 3
a4366 10
		  /* This is the first time we have seen this header
                     file with this set of stabs strings.  */
		  t = ((struct aout_link_includes_totals *)
		       bfd_hash_allocate (&finfo->includes.root,
					  sizeof *t));
		  if (t == NULL)
		    return FALSE;
		  t->total = val;
		  t->next = incl_entry->totals;
		  incl_entry->totals = t;
d4370 45
a4414 1
		  int *incl_map;
d4416 3
a4418 4
		  /* This is a duplicate header file.  We must change
                     it to be an N_EXCL entry, and mark all the
                     included symbols to prevent outputting them.  */
		  type = (int) N_EXCL;
d4420 3
a4422 6
		  nest = 0;
		  for (incl_sym = sym + 1, incl_map = symbol_map + 1;
		       incl_sym < sym_end;
		       incl_sym++, incl_map++)
		    {
		      int incl_type;
d4424 15
a4438 15
		      incl_type = H_GET_8 (input_bfd, incl_sym->e_type);
		      if (incl_type == (int) N_EINCL)
			{
			  if (nest == 0)
			    {
			      *incl_map = -1;
			      break;
			    }
			  --nest;
			}
		      else if (incl_type == (int) N_BINCL)
			++nest;
		      else if (nest == 0)
			*incl_map = -1;
		    }
d4441 6
a4446 1
	}
d4448 23
a4470 13
      /* Copy this symbol into the list of symbols we are going to
	 write out.  */
      H_PUT_8 (output_bfd, type, outsym->e_type);
      H_PUT_8 (output_bfd, H_GET_8 (input_bfd, sym->e_other), outsym->e_other);
      H_PUT_16 (output_bfd, H_GET_16 (input_bfd, sym->e_desc), outsym->e_desc);
      copy = FALSE;
      if (! finfo->info->keep_memory)
	{
	  /* name points into a string table which we are going to
	     free.  If there is a hash table entry, use that string.
	     Otherwise, copy name into memory.  */
	  if (h != (struct aout_link_hash_entry *) NULL)
	    name = h->root.root.string;
d4472 2
a4473 12
	    copy = TRUE;
	}
      strtab_index = add_to_stringtab (output_bfd, finfo->strtab,
				       name, copy);
      if (strtab_index == (bfd_size_type) -1)
	return FALSE;
      PUT_WORD (output_bfd, strtab_index, outsym->e_strx);
      PUT_WORD (output_bfd, val, outsym->e_value);
      *symbol_map = obj_aout_external_sym_count (output_bfd);
      ++obj_aout_external_sym_count (output_bfd);
      ++outsym;
    }
d4475 9
a4483 4
  /* Write out the output symbols we have just constructed.  */
  if (outsym > finfo->output_syms)
    {
      bfd_size_type outsym_size;
d4485 10
a4494 9
      if (bfd_seek (output_bfd, finfo->symoff, SEEK_SET) != 0)
	return FALSE;
      outsym_size = outsym - finfo->output_syms;
      outsym_size *= EXTERNAL_NLIST_SIZE;
      if (bfd_bwrite ((PTR) finfo->output_syms, outsym_size, output_bfd)
	  != outsym_size)
	return FALSE;
      finfo->symoff += outsym_size;
    }
d4496 11
a4506 18
  return TRUE;
}

/* Write out a symbol that was not associated with an a.out input
   object.  */

static bfd_boolean
aout_link_write_other_symbol (h, data)
     struct aout_link_hash_entry *h;
     PTR data;
{
  struct aout_final_link_info *finfo = (struct aout_final_link_info *) data;
  bfd *output_bfd;
  int type;
  bfd_vma val;
  struct external_nlist outsym;
  bfd_size_type indx;
  bfd_size_type amt;
d4508 3
a4510 6
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct aout_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }
d4512 7
a4518 1
  output_bfd = finfo->output_bfd;
d4520 10
a4529 9
  if (aout_backend_info (output_bfd)->write_dynamic_symbol != NULL)
    {
      if (! ((*aout_backend_info (output_bfd)->write_dynamic_symbol)
	     (output_bfd, finfo->info, h)))
	{
	  /* FIXME: No way to handle errors.  */
	  abort ();
	}
    }
d4531 9
a4539 2
  if (h->written)
    return TRUE;
d4541 8
a4548 1
  h->written = TRUE;
d4550 5
a4554 7
  /* An indx of -2 means the symbol must be written.  */
  if (h->indx != -2
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
    return TRUE;
d4556 10
a4565 19
  switch (h->root.type)
    {
    default:
    case bfd_link_hash_warning:
      abort ();
      /* Avoid variable not initialized warnings.  */
      return TRUE;
    case bfd_link_hash_new:
      /* This can happen for set symbols when sets are not being
         built.  */
      return TRUE;
    case bfd_link_hash_undefined:
      type = N_UNDF | N_EXT;
      val = 0;
      break;
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;
d4567 11
a4577 29
	sec = h->root.u.def.section->output_section;
	BFD_ASSERT (bfd_is_abs_section (sec)
		    || sec->owner == output_bfd);
	if (sec == obj_textsec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_TEXT : N_WEAKT;
	else if (sec == obj_datasec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_DATA : N_WEAKD;
	else if (sec == obj_bsssec (output_bfd))
	  type = h->root.type == bfd_link_hash_defined ? N_BSS : N_WEAKB;
	else
	  type = h->root.type == bfd_link_hash_defined ? N_ABS : N_WEAKA;
	type |= N_EXT;
	val = (h->root.u.def.value
	       + sec->vma
	       + h->root.u.def.section->output_offset);
      }
      break;
    case bfd_link_hash_common:
      type = N_UNDF | N_EXT;
      val = h->root.u.c.size;
      break;
    case bfd_link_hash_undefweak:
      type = N_WEAKU;
      val = 0;
    case bfd_link_hash_indirect:
      /* We ignore these symbols, since the indirected symbol is
	 already in the hash table.  */
      return TRUE;
    }
d4579 13
a4591 19
  H_PUT_8 (output_bfd, type, outsym.e_type);
  H_PUT_8 (output_bfd, 0, outsym.e_other);
  H_PUT_16 (output_bfd, 0, outsym.e_desc);
  indx = add_to_stringtab (output_bfd, finfo->strtab, h->root.root.string,
			   FALSE);
  if (indx == - (bfd_size_type) 1)
    {
      /* FIXME: No way to handle errors.  */
      abort ();
    }
  PUT_WORD (output_bfd, indx, outsym.e_strx);
  PUT_WORD (output_bfd, val, outsym.e_value);

  amt = EXTERNAL_NLIST_SIZE;
  if (bfd_seek (output_bfd, finfo->symoff, SEEK_SET) != 0
      || bfd_bwrite ((PTR) &outsym, amt, output_bfd) != amt)
    {
      /* FIXME: No way to handle errors.  */
      abort ();
a4593 4
  finfo->symoff += EXTERNAL_NLIST_SIZE;
  h->indx = obj_aout_external_sym_count (output_bfd);
  ++obj_aout_external_sym_count (output_bfd);

d4600 5
a4604 7
aout_link_input_section (finfo, input_bfd, input_section, reloff_ptr,
			 rel_size)
     struct aout_final_link_info *finfo;
     bfd *input_bfd;
     asection *input_section;
     file_ptr *reloff_ptr;
     bfd_size_type rel_size;
d4607 1
a4607 1
  PTR relocs;
d4612 1
a4612 1
				  (PTR) finfo->contents,
d4650 1
a4650 1
				  (PTR) finfo->contents,
d4661 84
a4744 3
      if (bfd_bwrite (relocs, rel_size, finfo->output_bfd) != rel_size)
	return FALSE;
      *reloff_ptr += rel_size;
d4746 6
a4751 8
      /* Assert that the relocs have not run into the symbols, and
	 that if these are the text relocs they have not run into the
	 data relocs.  */
      BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (finfo->output_bfd)
		  && (reloff_ptr != &finfo->treloff
		      || (*reloff_ptr
			  <= obj_datasec (finfo->output_bfd)->rel_filepos)));
    }
d4753 4
a4756 2
  return TRUE;
}
d4758 2
a4759 1
/* Get the section corresponding to a reloc index.  */
d4761 1
a4761 22
static INLINE asection *
aout_reloc_index_to_section (abfd, indx)
     bfd *abfd;
     int indx;
{
  switch (indx & N_TYPE)
    {
    case N_TEXT:
      return obj_textsec (abfd);
    case N_DATA:
      return obj_datasec (abfd);
    case N_BSS:
      return obj_bsssec (abfd);
    case N_ABS:
    case N_UNDF:
      return bfd_abs_section_ptr;
    default:
      abort ();
    }
  /*NOTREACHED*/
  return NULL;
}
d4763 18
a4780 1
/* Relocate an a.out section using standard a.out relocs.  */
d4782 5
a4786 23
static bfd_boolean
aout_link_input_section_std (finfo, input_bfd, input_section, relocs,
			     rel_size, contents)
     struct aout_final_link_info *finfo;
     bfd *input_bfd;
     asection *input_section;
     struct reloc_std_external *relocs;
     bfd_size_type rel_size;
     bfd_byte *contents;
{
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
  bfd *output_bfd;
  bfd_boolean relocatable;
  struct external_nlist *syms;
  char *strings;
  struct aout_link_hash_entry **sym_hashes;
  int *symbol_map;
  bfd_size_type reloc_count;
  register struct reloc_std_external *rel;
  struct reloc_std_external *rel_end;
d4788 5
a4792 2
  output_bfd = finfo->output_bfd;
  check_dynamic_reloc = aout_backend_info (output_bfd)->check_dynamic_reloc;
d4794 16
a4809 3
  BFD_ASSERT (obj_reloc_entry_size (input_bfd) == RELOC_STD_SIZE);
  BFD_ASSERT (input_bfd->xvec->header_byteorder
	      == output_bfd->xvec->header_byteorder);
d4811 10
a4820 5
  relocatable = finfo->info->relocatable;
  syms = obj_aout_external_syms (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  sym_hashes = obj_aout_sym_hashes (input_bfd);
  symbol_map = finfo->symbol_map;
d4822 25
a4846 14
  reloc_count = rel_size / RELOC_STD_SIZE;
  rel = relocs;
  rel_end = rel + reloc_count;
  for (; rel < rel_end; rel++)
    {
      bfd_vma r_addr;
      int r_index;
      int r_extern;
      int r_pcrel;
      int r_baserel = 0;
      reloc_howto_type *howto;
      struct aout_link_hash_entry *h = NULL;
      bfd_vma relocation;
      bfd_reloc_status_type r;
d4848 42
a4889 1
      r_addr = GET_SWORD (input_bfd, rel->r_address);
d4891 1
a4891 8
#ifdef MY_reloc_howto
      howto = MY_reloc_howto (input_bfd, rel, r_index, r_extern, r_pcrel);
#else
      {
	int r_jmptable;
	int r_relative;
	int r_length;
	unsigned int howto_idx;
d4893 29
a4921 29
	if (bfd_header_big_endian (input_bfd))
	  {
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
			  | rel->r_index[2]);
	    r_extern  = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
	    r_pcrel   = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
	    r_baserel = (0 != (rel->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
	    r_jmptable= (0 != (rel->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
	    r_relative= (0 != (rel->r_type[0] & RELOC_STD_BITS_RELATIVE_BIG));
	    r_length  = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
			 >> RELOC_STD_BITS_LENGTH_SH_BIG);
	  }
	else
	  {
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
			 | rel->r_index[0]);
	    r_extern  = (0 != (rel->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
	    r_pcrel   = (0 != (rel->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
	    r_baserel = (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_BASEREL_LITTLE));
	    r_jmptable= (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_JMPTABLE_LITTLE));
	    r_relative= (0 != (rel->r_type[0]
			       & RELOC_STD_BITS_RELATIVE_LITTLE));
	    r_length  = ((rel->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
			 >> RELOC_STD_BITS_LENGTH_SH_LITTLE);
	  }
d4923 9
a4931 6
	howto_idx = (r_length + 4 * r_pcrel + 8 * r_baserel
		     + 16 * r_jmptable + 32 * r_relative);
	BFD_ASSERT (howto_idx < TABLE_SIZE (howto_table_std));
	howto = howto_table_std + howto_idx;
      }
#endif
d4933 8
a4940 15
      if (relocatable)
	{
	  /* We are generating a relocatable output file, and must
	     modify the reloc accordingly.  */
	  if (r_extern)
	    {
	      /* If we know the symbol this relocation is against,
		 convert it into a relocation against a section.  This
		 is what the native linker does.  */
	      h = sym_hashes[r_index];
	      if (h != (struct aout_link_hash_entry *) NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  asection *output_section;
d4942 1
a4942 5
		  /* Change the r_extern value.  */
		  if (bfd_header_big_endian (output_bfd))
		    rel->r_type[0] &=~ RELOC_STD_BITS_EXTERN_BIG;
		  else
		    rel->r_type[0] &=~ RELOC_STD_BITS_EXTERN_LITTLE;
a4943 2
		  /* Compute a new r_index.  */
		  output_section = h->root.u.def.section->output_section;
d4945 3
a4947 1
		    r_index = N_TEXT;
d4949 3
a4951 1
		    r_index = N_DATA;
d4953 3
a4955 1
		    r_index = N_BSS;
d4957 3
a4959 7
		    r_index = N_ABS;

		  /* Add the symbol value and the section VMA to the
		     addend stored in the contents.  */
		  relocation = (h->root.u.def.value
				+ output_section->vma
				+ h->root.u.def.section->output_offset);
d4961 3
a4963 1
	      else
d4965 2
a4966 38
		  /* We must change r_index according to the symbol
		     map.  */
		  r_index = symbol_map[r_index];

		  if (r_index == -1)
		    {
		      if (h != NULL)
			{
			  /* We decided to strip this symbol, but it
                             turns out that we can't.  Note that we
                             lose the other and desc information here.
                             I don't think that will ever matter for a
                             global symbol.  */
			  if (h->indx < 0)
			    {
			      h->indx = -2;
			      h->written = FALSE;
			      if (! aout_link_write_other_symbol (h,
								  (PTR) finfo))
				return FALSE;
			    }
			  r_index = h->indx;
			}
		      else
			{
			  const char *name;

			  name = strings + GET_WORD (input_bfd,
						     syms[r_index].e_strx);
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, input_section,
				  r_addr)))
			    return FALSE;
			  r_index = 0;
			}
		    }

		  relocation = 0;
d4968 8
d4977 13
a4989 2
	      /* Write out the new r_index value.  */
	      if (bfd_header_big_endian (output_bfd))
d4991 11
a5001 3
		  rel->r_index[0] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[2] = r_index;
d5003 1
a5003 1
	      else
d5005 2
a5006 3
		  rel->r_index[2] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[0] = r_index;
d5009 8
a5016 1
	  else
d5018 4
a5021 1
	      asection *section;
d5023 5
a5027 7
	      /* This is a relocation against a section.  We must
		 adjust by the amount that the section moved.  */
	      section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (section->output_section->vma
			    + section->output_offset
			    - section->vma);
	    }
d5029 12
a5040 4
	  /* Change the address of the relocation.  */
	  PUT_WORD (output_bfd,
		    r_addr + input_section->output_offset,
		    rel->r_address);
d5042 15
a5056 7
	  /* Adjust a PC relative relocation by removing the reference
	     to the original address in the section and including the
	     reference to the new address.  */
	  if (r_pcrel)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   - input_section->vma);
d5058 12
a5069 26
#ifdef MY_relocatable_reloc
	  MY_relocatable_reloc (howto, output_bfd, rel, relocation, r_addr);
#endif

	  if (relocation == 0)
	    r = bfd_reloc_ok;
	  else
	    r = MY_relocate_contents (howto,
					input_bfd, relocation,
					contents + r_addr);
	}
      else
	{
	  bfd_boolean hundef;

	  /* We are generating an executable, and must do a full
	     relocation.  */
	  hundef = FALSE;

	  if (r_extern)
	    {
	      h = sym_hashes[r_index];

	      if (h != (struct aout_link_hash_entry *) NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
d5071 9
a5079 3
		  relocation = (h->root.u.def.value
				+ h->root.u.def.section->output_section->vma
				+ h->root.u.def.section->output_offset);
a5080 3
	      else if (h != (struct aout_link_hash_entry *) NULL
		       && h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
d5083 1
a5083 7
		  hundef = TRUE;
		  relocation = 0;
		}
	    }
	  else
	    {
	      asection *section;
d5085 4
a5088 7
	      section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (section->output_section->vma
			    + section->output_offset
			    - section->vma);
	      if (r_pcrel)
		relocation += input_section->vma;
	    }
d5090 6
a5095 3
	  if (check_dynamic_reloc != NULL)
	    {
	      bfd_boolean skip;
d5097 16
a5112 23
	      if (! ((*check_dynamic_reloc)
		     (finfo->info, input_bfd, input_section, h,
		      (PTR) rel, contents, &skip, &relocation)))
		return FALSE;
	      if (skip)
		continue;
	    }

	  /* Now warn if a global symbol is undefined.  We could not
             do this earlier, because check_dynamic_reloc might want
             to skip this reloc.  */
	  if (hundef && ! finfo->info->shared && ! r_baserel)
	    {
	      const char *name;

	      if (h != NULL)
		name = h->root.root.string;
	      else
		name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
	      if (! ((*finfo->info->callbacks->undefined_symbol)
		     (finfo->info, name, input_bfd, input_section,
		     r_addr, TRUE)))
		return FALSE;
a5113 5

	  r = MY_final_link_relocate (howto,
				      input_bfd, input_section,
				      contents, r_addr, relocation,
				      (bfd_vma) 0);
d5116 7
a5122 1
      if (r != bfd_reloc_ok)
d5124 7
a5130 29
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else if (r_extern)
		  name = strings + GET_WORD (input_bfd,
					     syms[r_index].e_strx);
		else
		  {
		    asection *s;

		    s = aout_reloc_index_to_section (input_bfd, r_index);
		    name = bfd_section_name (input_bfd, s);
		  }
		if (! ((*finfo->info->callbacks->reloc_overflow)
		       (finfo->info, (h ? &h->root : NULL), name,
			howto->name, (bfd_vma) 0, input_bfd,
			input_section, r_addr)))
		  return FALSE;
	      }
	      break;
	    }
d5132 9
d5143 2
a5144 46
  return TRUE;
}

/* Relocate an a.out section using extended a.out relocs.  */

static bfd_boolean
aout_link_input_section_ext (finfo, input_bfd, input_section, relocs,
			     rel_size, contents)
     struct aout_final_link_info *finfo;
     bfd *input_bfd;
     asection *input_section;
     struct reloc_ext_external *relocs;
     bfd_size_type rel_size;
     bfd_byte *contents;
{
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
  bfd *output_bfd;
  bfd_boolean relocatable;
  struct external_nlist *syms;
  char *strings;
  struct aout_link_hash_entry **sym_hashes;
  int *symbol_map;
  bfd_size_type reloc_count;
  register struct reloc_ext_external *rel;
  struct reloc_ext_external *rel_end;

  output_bfd = finfo->output_bfd;
  check_dynamic_reloc = aout_backend_info (output_bfd)->check_dynamic_reloc;

  BFD_ASSERT (obj_reloc_entry_size (input_bfd) == RELOC_EXT_SIZE);
  BFD_ASSERT (input_bfd->xvec->header_byteorder
	      == output_bfd->xvec->header_byteorder);

  relocatable = finfo->info->relocatable;
  syms = obj_aout_external_syms (input_bfd);
  strings = obj_aout_external_strings (input_bfd);
  sym_hashes = obj_aout_sym_hashes (input_bfd);
  symbol_map = finfo->symbol_map;

  reloc_count = rel_size / RELOC_EXT_SIZE;
  rel = relocs;
  rel_end = rel + reloc_count;
  for (; rel < rel_end; rel++)
d5146 1
a5146 94
      bfd_vma r_addr;
      int r_index;
      int r_extern;
      unsigned int r_type;
      bfd_vma r_addend;
      struct aout_link_hash_entry *h = NULL;
      asection *r_section = NULL;
      bfd_vma relocation;

      r_addr = GET_SWORD (input_bfd, rel->r_address);

      if (bfd_header_big_endian (input_bfd))
	{
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
		      | rel->r_index[2]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
	  r_type   = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
		      >> RELOC_EXT_BITS_TYPE_SH_BIG);
	}
      else
	{
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
		      | rel->r_index[0]);
	  r_extern = (0 != (rel->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
	  r_type   = ((rel->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
		      >> RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}

      r_addend = GET_SWORD (input_bfd, rel->r_addend);

      BFD_ASSERT (r_type < TABLE_SIZE (howto_table_ext));

      if (relocatable)
	{
	  /* We are generating a relocatable output file, and must
	     modify the reloc accordingly.  */
	  if (r_extern
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
	    {
	      /* If we know the symbol this relocation is against,
		 convert it into a relocation against a section.  This
		 is what the native linker does.  */
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
		h = NULL;
	      else
		h = sym_hashes[r_index];
	      if (h != (struct aout_link_hash_entry *) NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  asection *output_section;

		  /* Change the r_extern value.  */
		  if (bfd_header_big_endian (output_bfd))
		    rel->r_type[0] &=~ RELOC_EXT_BITS_EXTERN_BIG;
		  else
		    rel->r_type[0] &=~ RELOC_EXT_BITS_EXTERN_LITTLE;

		  /* Compute a new r_index.  */
		  output_section = h->root.u.def.section->output_section;
		  if (output_section == obj_textsec (output_bfd))
		    r_index = N_TEXT;
		  else if (output_section == obj_datasec (output_bfd))
		    r_index = N_DATA;
		  else if (output_section == obj_bsssec (output_bfd))
		    r_index = N_BSS;
		  else
		    r_index = N_ABS;

		  /* Add the symbol value and the section VMA to the
		     addend.  */
		  relocation = (h->root.u.def.value
				+ output_section->vma
				+ h->root.u.def.section->output_offset);

		  /* Now RELOCATION is the VMA of the final
		     destination.  If this is a PC relative reloc,
		     then ADDEND is the negative of the source VMA.
		     We want to set ADDEND to the difference between
		     the destination VMA and the source VMA, which
		     means we must adjust RELOCATION by the change in
		     the source VMA.  This is done below.  */
		}
	      else
		{
		  /* We must change r_index according to the symbol
		     map.  */
		  r_index = symbol_map[r_index];
d5148 9
a5156 22
		  if (r_index == -1)
		    {
		      if (h != NULL)
			{
			  /* We decided to strip this symbol, but it
                             turns out that we can't.  Note that we
                             lose the other and desc information here.
                             I don't think that will ever matter for a
                             global symbol.  */
			  if (h->indx < 0)
			    {
			      h->indx = -2;
			      h->written = FALSE;
			      if (! aout_link_write_other_symbol (h,
								  (PTR) finfo))
				return FALSE;
			    }
			  r_index = h->indx;
			}
		      else
			{
			  const char *name;
d5158 2
a5159 9
			  name = strings + GET_WORD (input_bfd,
						     syms[r_index].e_strx);
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, input_section,
				  r_addr)))
			    return FALSE;
			  r_index = 0;
			}
		    }
d5161 1
a5161 1
		  relocation = 0;
d5163 4
a5166 5
		  /* If this is a PC relative reloc, then the addend
		     is the negative of the source VMA.  We must
		     adjust it by the change in the source VMA.  This
		     is done below.  */
		}
d5168 1
a5168 22
	      /* Write out the new r_index value.  */
	      if (bfd_header_big_endian (output_bfd))
		{
		  rel->r_index[0] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[2] = r_index;
		}
	      else
		{
		  rel->r_index[2] = r_index >> 16;
		  rel->r_index[1] = r_index >> 8;
		  rel->r_index[0] = r_index;
		}
	    }
	  else
	    {
	      /* This is a relocation against a section.  We must
		 adjust by the amount that the section moved.  */
	      r_section = aout_reloc_index_to_section (input_bfd, r_index);
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    - r_section->vma);
d5170 5
a5174 6
	      /* If this is a PC relative reloc, then the addend is
		 the difference in VMA between the destination and the
		 source.  We have just adjusted for the change in VMA
		 of the destination, so we must also adjust by the
		 change in VMA of the source.  This is done below.  */
	    }
d5176 4
a5179 10
	  /* As described above, we must always adjust a PC relative
	     reloc by the change in VMA of the source.  However, if
	     pcrel_offset is set, then the addend does not include the
	     location within the section, in which case we don't need
	     to adjust anything.  */
	  if (howto_table_ext[r_type].pc_relative
	      && ! howto_table_ext[r_type].pcrel_offset)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   - input_section->vma);
d5181 1
a5181 3
	  /* Change the addend if necessary.  */
	  if (relocation != 0)
	    PUT_WORD (output_bfd, r_addend + relocation, rel->r_addend);
d5183 4
a5186 9
	  /* Change the address of the relocation.  */
	  PUT_WORD (output_bfd,
		    r_addr + input_section->output_offset,
		    rel->r_address);
	}
      else
	{
	  bfd_boolean hundef;
	  bfd_reloc_status_type r;
d5188 20
a5207 3
	  /* We are generating an executable, and must do a full
	     relocation.  */
	  hundef = FALSE;
d5209 8
a5216 3
	  if (r_extern)
	    {
	      h = sym_hashes[r_index];
d5218 2
a5219 23
	      if (h != (struct aout_link_hash_entry *) NULL
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak))
		{
		  relocation = (h->root.u.def.value
				+ h->root.u.def.section->output_section->vma
				+ h->root.u.def.section->output_offset);
		}
	      else if (h != (struct aout_link_hash_entry *) NULL
		       && h->root.type == bfd_link_hash_undefweak)
		relocation = 0;
	      else
		{
		  hundef = TRUE;
		  relocation = 0;
		}
	    }
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
	    {
	      struct external_nlist *sym;
	      int type;
d5221 6
a5226 26
	      /* For base relative relocs, r_index is always an index
                 into the symbol table, even if r_extern is 0.  */
	      sym = syms + r_index;
	      type = H_GET_8 (input_bfd, sym->e_type);
	      if ((type & N_TYPE) == N_TEXT
		  || type == N_WEAKT)
		r_section = obj_textsec (input_bfd);
	      else if ((type & N_TYPE) == N_DATA
		       || type == N_WEAKD)
		r_section = obj_datasec (input_bfd);
	      else if ((type & N_TYPE) == N_BSS
		       || type == N_WEAKB)
		r_section = obj_bsssec (input_bfd);
	      else if ((type & N_TYPE) == N_ABS
		       || type == N_WEAKA)
		r_section = bfd_abs_section_ptr;
	      else
		abort ();
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    + (GET_WORD (input_bfd, sym->e_value)
			       - r_section->vma));
	    }
	  else
	    {
	      r_section = aout_reloc_index_to_section (input_bfd, r_index);
d5228 17
a5244 9
	      /* If this is a PC relative reloc, then R_ADDEND is the
		 difference between the two vmas, or
		   old_dest_sec + old_dest_off - (old_src_sec + old_src_off)
		 where
		   old_dest_sec == section->vma
		 and
		   old_src_sec == input_section->vma
		 and
		   old_src_off == r_addr
d5246 2
a5247 10
		 _bfd_final_link_relocate expects RELOCATION +
		 R_ADDEND to be the VMA of the destination minus
		 r_addr (the minus r_addr is because this relocation
		 is not pcrel_offset, which is a bit confusing and
		 should, perhaps, be changed), or
		   new_dest_sec
		 where
		   new_dest_sec == output_section->vma + output_offset
		 We arrange for this to happen by setting RELOCATION to
		   new_dest_sec + old_src_sec - old_dest_sec
d5249 6
a5254 11
		 If this is not a PC relative reloc, then R_ADDEND is
		 simply the VMA of the destination, so we set
		 RELOCATION to the change in the destination VMA, or
		   new_dest_sec - old_dest_sec
		 */
	      relocation = (r_section->output_section->vma
			    + r_section->output_offset
			    - r_section->vma);
	      if (howto_table_ext[r_type].pc_relative)
		relocation += input_section->vma;
	    }
d5256 5
a5260 3
	  if (check_dynamic_reloc != NULL)
	    {
	      bfd_boolean skip;
d5262 10
a5271 7
	      if (! ((*check_dynamic_reloc)
		     (finfo->info, input_bfd, input_section, h,
		      (PTR) rel, contents, &skip, &relocation)))
		return FALSE;
	      if (skip)
		continue;
	    }
d5273 3
a5275 8
	  /* Now warn if a global symbol is undefined.  We could not
             do this earlier, because check_dynamic_reloc might want
             to skip this reloc.  */
	  if (hundef
	      && ! finfo->info->shared
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
d5277 2
a5278 10
	      const char *name;

	      if (h != NULL)
		name = h->root.root.string;
	      else
		name = strings + GET_WORD (input_bfd, syms[r_index].e_strx);
	      if (! ((*finfo->info->callbacks->undefined_symbol)
		     (finfo->info, name, input_bfd, input_section,
		     r_addr, TRUE)))
		return FALSE;
a5279 6

	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
	    r = MY_final_link_relocate (howto_table_ext + r_type,
					input_bfd, input_section,
					contents, r_addr, relocation,
					r_addend);
d5282 10
a5291 6
	      bfd_vma x;

	      x = bfd_get_32 (input_bfd, contents + r_addr);
	      x = x + relocation + r_addend;
	      bfd_putl32 (/*input_bfd,*/ x, contents + r_addr);
	      r = bfd_reloc_ok;
d5293 1
d5295 8
a5302 10
	  if (r != bfd_reloc_ok)
	    {
	      switch (r)
		{
		default:
		case bfd_reloc_outofrange:
		  abort ();
		case bfd_reloc_overflow:
		  {
		    const char *name;
d5304 6
a5309 11
		    if (h != NULL)
		      name = NULL;
		    else if (r_extern
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
		      name = strings + GET_WORD (input_bfd,
						 syms[r_index].e_strx);
		    else
		      {
			asection *s;
d5311 3
a5313 12
			s = aout_reloc_index_to_section (input_bfd, r_index);
			name = bfd_section_name (input_bfd, s);
		      }
		    if (! ((*finfo->info->callbacks->reloc_overflow)
			   (finfo->info, (h ? &h->root : NULL), name,
			    howto_table_ext[r_type].name,
			    r_addend, input_bfd, input_section, r_addr)))
		      return FALSE;
		  }
		  break;
		}
	    }
d5317 56
a5372 2
  return TRUE;
}
d5374 6
a5379 1
/* Handle a link order which is supposed to generate a reloc.  */
d5381 5
a5385 15
static bfd_boolean
aout_link_reloc_link_order (finfo, o, p)
     struct aout_final_link_info *finfo;
     asection *o;
     struct bfd_link_order *p;
{
  struct bfd_link_order_reloc *pr;
  int r_index;
  int r_extern;
  reloc_howto_type *howto;
  file_ptr *reloff_ptr = NULL;
  struct reloc_std_external srel;
  struct reloc_ext_external erel;
  PTR rel_ptr;
  bfd_size_type amt;
d5387 10
a5396 1
  pr = p->u.reloc.p;
d5398 7
a5404 14
  if (p->type == bfd_section_reloc_link_order)
    {
      r_extern = 0;
      if (bfd_is_abs_section (pr->u.section))
	r_index = N_ABS | N_EXT;
      else
	{
	  BFD_ASSERT (pr->u.section->owner == finfo->output_bfd);
	  r_index = pr->u.section->target_index;
	}
    }
  else
    {
      struct aout_link_hash_entry *h;
d5406 4
a5409 29
      BFD_ASSERT (p->type == bfd_symbol_reloc_link_order);
      r_extern = 1;
      h = ((struct aout_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (finfo->output_bfd, finfo->info,
					 pr->u.name, FALSE, FALSE, TRUE));
      if (h != (struct aout_link_hash_entry *) NULL
	  && h->indx >= 0)
	r_index = h->indx;
      else if (h != NULL)
	{
	  /* We decided to strip this symbol, but it turns out that we
	     can't.  Note that we lose the other and desc information
	     here.  I don't think that will ever matter for a global
	     symbol.  */
	  h->indx = -2;
	  h->written = FALSE;
	  if (! aout_link_write_other_symbol (h, (PTR) finfo))
	    return FALSE;
	  r_index = h->indx;
	}
      else
	{
	  if (! ((*finfo->info->callbacks->unattached_reloc)
		 (finfo->info, pr->u.name, (bfd *) NULL,
		  (asection *) NULL, (bfd_vma) 0)))
	    return FALSE;
	  r_index = 0;
	}
    }
d5411 5
a5415 2
  howto = bfd_reloc_type_lookup (finfo->output_bfd, pr->reloc);
  if (howto == 0)
d5417 3
a5419 2
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
d5422 2
a5423 8
  if (o == obj_textsec (finfo->output_bfd))
    reloff_ptr = &finfo->treloff;
  else if (o == obj_datasec (finfo->output_bfd))
    reloff_ptr = &finfo->dreloff;
  else
    abort ();

  if (obj_reloc_entry_size (finfo->output_bfd) == RELOC_STD_SIZE)
d5425 9
a5433 10
#ifdef MY_put_reloc
      MY_put_reloc (finfo->output_bfd, r_extern, r_index, p->offset, howto,
		    &srel);
#else
      {
	int r_pcrel;
	int r_baserel;
	int r_jmptable;
	int r_relative;
	int r_length;
d5435 21
a5455 5
	r_pcrel = (int) howto->pc_relative;
	r_baserel = (howto->type & 8) != 0;
	r_jmptable = (howto->type & 16) != 0;
	r_relative = (howto->type & 32) != 0;
	r_length = howto->size;
d5457 4
a5460 30
	PUT_WORD (finfo->output_bfd, p->offset, srel.r_address);
	if (bfd_header_big_endian (finfo->output_bfd))
	  {
	    srel.r_index[0] = r_index >> 16;
	    srel.r_index[1] = r_index >> 8;
	    srel.r_index[2] = r_index;
	    srel.r_type[0] =
	      ((r_extern ?     RELOC_STD_BITS_EXTERN_BIG : 0)
	       | (r_pcrel ?    RELOC_STD_BITS_PCREL_BIG : 0)
	       | (r_baserel ?  RELOC_STD_BITS_BASEREL_BIG : 0)
	       | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_BIG : 0)
	       | (r_relative ? RELOC_STD_BITS_RELATIVE_BIG : 0)
	       | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG));
	  }
	else
	  {
	    srel.r_index[2] = r_index >> 16;
	    srel.r_index[1] = r_index >> 8;
	    srel.r_index[0] = r_index;
	    srel.r_type[0] =
	      ((r_extern ?     RELOC_STD_BITS_EXTERN_LITTLE : 0)
	       | (r_pcrel ?    RELOC_STD_BITS_PCREL_LITTLE : 0)
	       | (r_baserel ?  RELOC_STD_BITS_BASEREL_LITTLE : 0)
	       | (r_jmptable ? RELOC_STD_BITS_JMPTABLE_LITTLE : 0)
	       | (r_relative ? RELOC_STD_BITS_RELATIVE_LITTLE : 0)
	       | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE));
	  }
      }
#endif
      rel_ptr = (PTR) &srel;
d5462 7
a5468 6
      /* We have to write the addend into the object file, since
	 standard a.out relocs are in place.  It would be more
	 reliable if we had the current contents of the file here,
	 rather than assuming zeroes, but we can't read the file since
	 it was opened using bfd_openw.  */
      if (pr->addend != 0)
d5470 3
a5472 12
	  bfd_size_type size;
	  bfd_reloc_status_type r;
	  bfd_byte *buf;
	  bfd_boolean ok;

	  size = bfd_get_reloc_size (howto);
	  buf = (bfd_byte *) bfd_zmalloc (size);
	  if (buf == (bfd_byte *) NULL)
	    return FALSE;
	  r = MY_relocate_contents (howto, finfo->output_bfd,
				    (bfd_vma) pr->addend, buf);
	  switch (r)
d5474 2
a5475 14
	    case bfd_reloc_ok:
	      break;
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      if (! ((*finfo->info->callbacks->reloc_overflow)
		     (finfo->info, NULL,
		      (p->type == bfd_section_reloc_link_order
		       ? bfd_section_name (finfo->output_bfd,
					   pr->u.section)
		       : pr->u.name),
		      howto->name, pr->addend, (bfd *) NULL,
		      (asection *) NULL, (bfd_vma) 0)))
d5477 2
a5478 2
		  free (buf);
		  return FALSE;
a5479 1
	      break;
a5480 5
	  ok = bfd_set_section_contents (finfo->output_bfd, o, (PTR) buf,
					 (file_ptr) p->offset, size);
	  free (buf);
	  if (! ok)
	    return FALSE;
d5483 22
a5504 1
  else
d5506 3
a5508 5
#ifdef MY_put_ext_reloc
      MY_put_ext_reloc (finfo->output_bfd, r_extern, r_index, p->offset,
			howto, &erel, pr->addend);
#else
      PUT_WORD (finfo->output_bfd, p->offset, erel.r_address);
d5510 6
a5515 18
      if (bfd_header_big_endian (finfo->output_bfd))
	{
	  erel.r_index[0] = r_index >> 16;
	  erel.r_index[1] = r_index >> 8;
	  erel.r_index[2] = r_index;
	  erel.r_type[0] =
	    ((r_extern ? RELOC_EXT_BITS_EXTERN_BIG : 0)
	     | (howto->type << RELOC_EXT_BITS_TYPE_SH_BIG));
	}
      else
	{
	  erel.r_index[2] = r_index >> 16;
	  erel.r_index[1] = r_index >> 8;
	  erel.r_index[0] = r_index;
	  erel.r_type[0] =
	    (r_extern ? RELOC_EXT_BITS_EXTERN_LITTLE : 0)
	      | (howto->type << RELOC_EXT_BITS_TYPE_SH_LITTLE);
	}
d5517 8
a5524 2
      PUT_WORD (finfo->output_bfd, (bfd_vma) pr->addend, erel.r_addend);
#endif /* MY_put_ext_reloc */
d5526 6
a5531 1
      rel_ptr = (PTR) &erel;
d5533 5
d5539 6
a5544 4
  amt = obj_reloc_entry_size (finfo->output_bfd);
  if (bfd_seek (finfo->output_bfd, *reloff_ptr, SEEK_SET) != 0
      || bfd_bwrite (rel_ptr, amt, finfo->output_bfd) != amt)
    return FALSE;
d5546 1
a5546 1
  *reloff_ptr += obj_reloc_entry_size (finfo->output_bfd);
d5548 12
a5559 8
  /* Assert that the relocs have not run into the symbols, and that n
     the text relocs have not run into the data relocs.  */
  BFD_ASSERT (*reloff_ptr <= obj_sym_filepos (finfo->output_bfd)
	      && (reloff_ptr != &finfo->treloff
		  || (*reloff_ptr
		      <= obj_datasec (finfo->output_bfd)->rel_filepos)));

  return TRUE;
@


1.52
log
@	* aoutx.h (aout_link_add_symbols): Just return TRUE if a warning
	symbol was last.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001, 2002, 2003, 2004
@


1.51
log
@	* aoutx.h (NAME(aout,find_nearest_line)): Correct case for N_SO
	being the last symbol.
@
text
@d3433 3
a3435 2
	     about.  */
	  BFD_ASSERT (p + 1 < pend);
@


1.50
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2751 1
a2751 1
		break;
@


1.49
log
@	* archures.c: Define bfd_mach_mips9000.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_9000.
	(mips_set_isa_flags): Handle bfd_mach_mips9000.
	* cpu-mips.c (I_mips9000): Define.
	(arch_info_struct): Add case for bfd_mach_mips9000.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mips9000.
	* bfd-in2.h: Regenerate.
@
text
@d657 1
a657 8
    {
#if 0 /* These should be set correctly anyways.  */
      abfd->sections = obj_textsec (abfd);
      obj_textsec (abfd)->next = obj_datasec (abfd);
      obj_datasec (abfd)->next = obj_bsssec (abfd);
#endif
      return result;
    }
a912 3
#if 0	    /* ?? Does alignment in the file image really matter?  */
      pad = align_power (vma, obj_datasec (abfd)->alignment_power) - vma;
#endif
a926 3
#if 0
      pad = align_power (vma, obj_bsssec (abfd)->alignment_power) - vma;
#endif
a1498 82
#if 0
	asection *section;
	arelent_chain *reloc;
	asection *into_section;
	bfd_size_type amt;

	/* This is a set symbol.  The name of the symbol is the name
	   of the set (e.g., __CTOR_LIST__).  The value of the symbol
	   is the value to add to the set.  We create a section with
	   the same name as the symbol, and add a reloc to insert the
	   appropriate value into the section.

	   This action is actually obsolete; it used to make the
	   linker do the right thing, but the linker no longer uses
	   this function.  */

	section = bfd_get_section_by_name (abfd, cache_ptr->symbol.name);
	if (section == NULL)
	  {
	    char *copy;

	    amt = strlen (cache_ptr->symbol.name) + 1;
	    copy = bfd_alloc (abfd, amt);
	    if (copy == NULL)
	      return FALSE;

	    strcpy (copy, cache_ptr->symbol.name);
	    section = bfd_make_section (abfd, copy);
	    if (section == NULL)
	      return FALSE;
	  }

	amt = sizeof (arelent_chain);
	reloc = (arelent_chain *) bfd_alloc (abfd, amt);
	if (reloc == NULL)
	  return FALSE;

	/* Build a relocation entry for the constructor.  */
	switch (cache_ptr->type & N_TYPE)
	  {
	  case N_SETA:
	    into_section = bfd_abs_section_ptr;
	    cache_ptr->type = N_ABS;
	    break;
	  case N_SETT:
	    into_section = obj_textsec (abfd);
	    cache_ptr->type = N_TEXT;
	    break;
	  case N_SETD:
	    into_section = obj_datasec (abfd);
	    cache_ptr->type = N_DATA;
	    break;
	  case N_SETB:
	    into_section = obj_bsssec (abfd);
	    cache_ptr->type = N_BSS;
	    break;
	  }

	/* Build a relocation pointing into the constructor section
	   pointing at the symbol in the set vector specified.  */
	reloc->relent.addend = cache_ptr->symbol.value;
	cache_ptr->symbol.section = into_section;
	reloc->relent.sym_ptr_ptr = into_section->symbol_ptr_ptr;

	/* We modify the symbol to belong to a section depending upon
	   the name of the symbol, and add to the size of the section
	   to contain a pointer to the symbol. Build a reloc entry to
	   relocate to this symbol attached to this section.  */
	section->flags = SEC_CONSTRUCTOR | SEC_RELOC;

	section->reloc_count++;
	section->alignment_power = 2;

	reloc->next = section->constructor_chain;
	section->constructor_chain = reloc;
	reloc->relent.address = section->size;
	section->size += BYTES_IN_WORD;

	reloc->relent.howto = CTOR_TABLE_RELOC_HOWTO (abfd);

#endif /* 0 */

a1984 5
#if 0
  /* For a standard reloc, the addend is in the object file.  */
  r_addend = g->addend + (*(g->sym_ptr_ptr))->section->output_section->vma;
#endif

@


1.48
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d796 1
@


1.47
log
@From Miod Vallat <miod@@online.fr>:
* aoutx.h (NAME(aout,machine_type)): Handle bfd_arch_m88k.
@
text
@d5161 1
a5161 1
		  name = h->root.root.string;
d5173 3
a5175 2
		       (finfo->info, name, howto->name,
			(bfd_vma) 0, input_bfd, input_section, r_addr)))
d5573 1
a5573 1
		      name = h->root.root.string;
d5588 2
a5589 1
			   (finfo->info, name, howto_table_ext[r_type].name,
d5758 1
a5758 1
		     (finfo->info,
@


1.46
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d833 4
@


1.45
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d544 2
a545 2
  obj_datasec (abfd)->_raw_size = execp->a_data;
  obj_bsssec (abfd)->_raw_size = execp->a_bss;
a570 1
  obj_textsec (abfd)->raw_size = N_TXTSIZE (*execp);
d634 1
a634 1
			       + obj_textsec (abfd)->_raw_size)))
d909 2
a910 2
  pos += obj_textsec (abfd)->_raw_size;
  vma += obj_textsec (abfd)->_raw_size;
d918 1
a918 1
      obj_textsec (abfd)->_raw_size += pad;
d926 2
a927 2
  pos += obj_datasec (abfd)->_raw_size;
  vma += obj_datasec (abfd)->_raw_size;
d935 1
a935 1
      obj_datasec (abfd)->_raw_size += pad;
d948 1
a948 1
	  obj_datasec (abfd)->_raw_size += pad;
d955 3
a957 3
  execp->a_text = obj_textsec (abfd)->_raw_size;
  execp->a_data = obj_datasec (abfd)->_raw_size;
  execp->a_bss = obj_bsssec (abfd)->_raw_size;
d1007 1
a1007 1
      text_end = obj_textsec (abfd)->filepos + obj_textsec (abfd)->_raw_size;
d1015 1
a1015 1
      text_end = obj_textsec (abfd)->_raw_size;
d1019 1
a1019 1
  obj_textsec (abfd)->_raw_size += text_pad;
d1026 1
a1026 1
      vma = obj_textsec (abfd)->vma + obj_textsec (abfd)->_raw_size;
d1034 1
a1034 1
      text_pad = data->vma - (text->vma + text->_raw_size);
d1038 1
a1038 1
	text->_raw_size += text_pad;
d1041 1
a1041 1
				 + obj_textsec (abfd)->_raw_size);
d1044 1
a1044 1
  execp->a_text = obj_textsec (abfd)->_raw_size;
d1053 2
a1054 2
  obj_datasec (abfd)->_raw_size
    = align_power (obj_datasec (abfd)->_raw_size,
d1056 1
a1056 1
  execp->a_data = BFD_ALIGN (obj_datasec (abfd)->_raw_size,
d1058 1
a1058 1
  data_pad = execp->a_data - obj_datasec (abfd)->_raw_size;
d1063 1
a1063 1
			      + obj_datasec (abfd)->_raw_size);
d1072 3
a1074 3
      == obj_datasec (abfd)->vma + obj_datasec (abfd)->_raw_size)
    execp->a_bss = (data_pad > obj_bsssec (abfd)->_raw_size
		    ? 0 : obj_bsssec (abfd)->_raw_size - data_pad);
d1076 1
a1076 1
    execp->a_bss = obj_bsssec (abfd)->_raw_size;
d1094 2
a1095 2
  pos += obj_textsec (abfd)->_raw_size;
  vma += obj_textsec (abfd)->_raw_size;
d1104 1
a1104 1
  vma += obj_datasec (abfd)->_raw_size;
d1106 2
a1107 2
  obj_datasec (abfd)->_raw_size += pad;
  pos += obj_datasec (abfd)->_raw_size;
d1116 3
a1118 3
  execp->a_text = obj_textsec (abfd)->_raw_size;
  execp->a_data = obj_datasec (abfd)->_raw_size;
  execp->a_bss = obj_bsssec (abfd)->_raw_size;
d1136 2
a1137 2
  obj_textsec (abfd)->_raw_size =
    align_power (obj_textsec (abfd)->_raw_size,
d1140 1
a1140 1
  *text_size = obj_textsec (abfd)->_raw_size;
d1178 1
a1178 1
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->_raw_size,
d1180 1
a1180 1
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->_raw_size,
d1182 1
a1182 1
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->_raw_size,
d1204 1
a1204 1
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->_raw_size,
d1206 1
a1206 1
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->_raw_size,
d1208 1
a1208 1
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->_raw_size);
d1582 2
a1583 2
	reloc->relent.address = section->_raw_size;
	section->_raw_size += BYTES_IN_WORD;
d3786 1
a3786 1
	  sz = bfd_section_size (sub, obj_textsec (sub));
d3789 1
a3789 1
	  sz = bfd_section_size (sub, obj_datasec (sub));
d4744 1
a4744 1
  input_size = bfd_section_size (input_bfd, input_section);
@


1.45.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d544 2
a545 2
  obj_datasec (abfd)->size = execp->a_data;
  obj_bsssec (abfd)->size = execp->a_bss;
d571 1
d635 1
a635 1
			       + obj_textsec (abfd)->size)))
a833 4
    case bfd_arch_m88k:
      *unknown = FALSE;
      break;

d910 2
a911 2
  pos += obj_textsec (abfd)->size;
  vma += obj_textsec (abfd)->size;
d919 1
a919 1
      obj_textsec (abfd)->size += pad;
d927 2
a928 2
  pos += obj_datasec (abfd)->size;
  vma += obj_datasec (abfd)->size;
d936 1
a936 1
      obj_datasec (abfd)->size += pad;
d949 1
a949 1
	  obj_datasec (abfd)->size += pad;
d956 3
a958 3
  execp->a_text = obj_textsec (abfd)->size;
  execp->a_data = obj_datasec (abfd)->size;
  execp->a_bss = obj_bsssec (abfd)->size;
d1008 1
a1008 1
      text_end = obj_textsec (abfd)->filepos + obj_textsec (abfd)->size;
d1016 1
a1016 1
      text_end = obj_textsec (abfd)->size;
d1020 1
a1020 1
  obj_textsec (abfd)->size += text_pad;
d1027 1
a1027 1
      vma = obj_textsec (abfd)->vma + obj_textsec (abfd)->size;
d1035 1
a1035 1
      text_pad = data->vma - (text->vma + text->size);
d1039 1
a1039 1
	text->size += text_pad;
d1042 1
a1042 1
				 + obj_textsec (abfd)->size);
d1045 1
a1045 1
  execp->a_text = obj_textsec (abfd)->size;
d1054 2
a1055 2
  obj_datasec (abfd)->size
    = align_power (obj_datasec (abfd)->size,
d1057 1
a1057 1
  execp->a_data = BFD_ALIGN (obj_datasec (abfd)->size,
d1059 1
a1059 1
  data_pad = execp->a_data - obj_datasec (abfd)->size;
d1064 1
a1064 1
			      + obj_datasec (abfd)->size);
d1073 3
a1075 3
      == obj_datasec (abfd)->vma + obj_datasec (abfd)->size)
    execp->a_bss = (data_pad > obj_bsssec (abfd)->size
		    ? 0 : obj_bsssec (abfd)->size - data_pad);
d1077 1
a1077 1
    execp->a_bss = obj_bsssec (abfd)->size;
d1095 2
a1096 2
  pos += obj_textsec (abfd)->size;
  vma += obj_textsec (abfd)->size;
d1105 1
a1105 1
  vma += obj_datasec (abfd)->size;
d1107 2
a1108 2
  obj_datasec (abfd)->size += pad;
  pos += obj_datasec (abfd)->size;
d1117 3
a1119 3
  execp->a_text = obj_textsec (abfd)->size;
  execp->a_data = obj_datasec (abfd)->size;
  execp->a_bss = obj_bsssec (abfd)->size;
d1137 2
a1138 2
  obj_textsec (abfd)->size =
    align_power (obj_textsec (abfd)->size,
d1141 1
a1141 1
  *text_size = obj_textsec (abfd)->size;
d1179 1
a1179 1
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,
d1181 1
a1181 1
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,
d1183 1
a1183 1
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size,
d1205 1
a1205 1
	   obj_textsec (abfd)->vma, obj_textsec (abfd)->size,
d1207 1
a1207 1
	   obj_datasec (abfd)->vma, obj_datasec (abfd)->size,
d1209 1
a1209 1
	   obj_bsssec (abfd)->vma, obj_bsssec (abfd)->size);
d1583 2
a1584 2
	reloc->relent.address = section->size;
	section->size += BYTES_IN_WORD;
d3787 1
a3787 1
	  sz = obj_textsec (sub)->size;
d3790 1
a3790 1
	  sz = obj_datasec (sub)->size;
d4745 1
a4745 1
  input_size = input_section->size;
@


1.44
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d3257 1
a3257 1
             dependant for backward compatability.
@


1.43
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d1268 1
a1268 1
     PTR location;
@


1.42
log
@[ bfd/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* archures.c (bfd_mach_mipsisa64r2): New define.
	* bfd-in2.h: Regenerate.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mipsisa64r2.
	* cpu-mips.c (I_mipsisa64r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa64r2.
	* elfxx-mips.c (_bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_64R2.
	(mips_set_isa_flags): Add bfd_mach_mipsisa64r2 case.
	(mips_mach_extensions): Add entry for bfd_mach_mipsisa64r2.

[ binutils/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_64R2.

[ gas/Changelog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mipsisa64r2, mipsisa64r2el, mipsisa64r2*): New CPUs.
	* configure: Regenerate.
	* config/tc-mips.c (imm2_expr): New variable.
	(md_assemble, mips16_ip): Initialize imm2_expr.
	(ISA_HAS_64BIT_REGS, ISA_HAS_DROR, ISA_HAS_ROR): Add ISA_MIPS64R2.
	(macro_build): Handle +A, +B, +C, +E, +F, +G, and +H format operands.
	(macro): Handle M_DEXT and M_DINS.
	(validate_mips_insn): Handle +E, +F, +G, +H, and +I format operands.
	(mips_ip): Likewise.
	(OPTION_MIPS64R2): New define.
	(md_longopts): New entry for -mips64r2 (OPTION_MIPS64R2).
	OPTION_ASE_BASE): Increase to compensate for OPTION_MIPS64R2.
	(md_parse_option): Handle OPTION_MIPS64R2.
	(s_mipsset): Handle setting "mips64r2" ISA.
	(mips_cpu_info_table): Add mips64r2.
	(md_show_usage): Document -mips64r2 option.
	* doc/as.texinfo: Docuemnt -mips64r2 option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips64r2.d: New file.
	* gas/mips/cp0sel-names-mips64r2.d: New file.
	* gas/mips/elf_arch_mips64r2.d: New file.
	* gas/mips/hwr-names-mips64r2.d: New file.
	* gas/mips/mips32r2-ill-fp64.l: New file.
	* gas/mips/mips32r2-ill-fp64.s: New file.
	* gas/mips/mips64r2-ill.l: New file.
	* gas/mips/mips64r2-ill.s: New file.
	* gas/mips/mips64r2.d: New file.
	* gas/mips/mips64r2.s: New file.
	* gas/mips/mips.exp: Define "mips64r2" arch, and run new tests.

[ include/elf/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_64R2): New define.

[ include/opcode/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document +E, +F, +G, +H, and +I operand types.
	Update documentation of I, +B and +C operand types.
	(INSN_ISA64R2, ISA_MIPS64R2, CPU_MIPS64R2): New defines.
	(M_DEXT, M_DINS): New enum values.

[ ld/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ldmain.c (get_emulation): Ignore "-mips64r2".

[ ld/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ld-mips-elf/mips-elf-flags.exp: Add tests for combinations
	with MIPS64r2.

[ opcodes/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_arch_choices): Add entry for "mips64r2"
	(print_insn_args): Add handing for +E, +F, +G, and +H.
	* mips-opc.c (I65): New define for MIPS64r2.
	(mips_builtin_opcodes): Add "dext", "dextm", "dextu", "dins",
	"dinsm", "dinsu", "drotl", "drotr", "drotr32", "drotrv", "dsbh",
	and "dshd" for MIPS64r2.  Adjust "dror", "dror32", and "drorv" to
	be supported on MIPS64r2.
@
text
@d2029 1
a2029 1
NAME(aout,get_symtab) (abfd, location)
@


1.41
log
@Correct spelling of "relocatable".
@
text
@d804 1
@


1.40
log
@Fix memory leaks
@
text
@d3752 1
a3752 1
     relocateable output, count the relocs.  */
d3762 1
a3762 1
      if (info->relocateable)
d3776 1
a3776 1
		(_("%s: relocateable link from %s to %s not supported"),
d3806 1
a3806 1
  if (info->relocateable)
d4789 1
a4789 1
  /* If we are producing relocateable output, the relocs were
d4791 1
a4791 1
  if (finfo->info->relocateable && rel_size > 0)
d4853 1
a4853 1
  bfd_boolean relocateable;
d4869 1
a4869 1
  relocateable = finfo->info->relocateable;
d4938 1
a4938 1
      if (relocateable)
d4940 1
a4940 1
	  /* We are generating a relocateable output file, and must
d5198 1
a5198 1
  bfd_boolean relocateable;
d5214 1
a5214 1
  relocateable = finfo->info->relocateable;
d5259 1
a5259 1
      if (relocateable)
d5261 1
a5261 1
	  /* We are generating a relocateable output file, and must
@


1.39
log
@[ bfd/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* aoutx.h (NAME(aout,machine_type)): Add bfd_mach_mipsisa32r2 case.
	* archures.c (bfd_mach_mipsisa32r2): New define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_mipsisa32r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa32r2.
	* elfxx-mips.c (elf_mips_isa, _bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_32R2.
	(_bfd_mips_elf_final_write_processing): Add
	bfd_mach_mipsisa32r2 case.
	(_bfd_mips_elf_merge_private_bfd_data): Handle merging of
	binaries marked as using MIPS32 Release 2.

[ binutils/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* doc/binutils.texi (objdump): Note MIPS HWR (Hardware Register)
	changes in MIPS -M options.

[ gas/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in: Recognize mipsisa32r2, mipsisa32r2el, and
	CPU variants.
	* configure: Regenerate.
	* config/tc-mips.c (ISA_HAS_DROR, ISA_HAS_ROR): New defines.
	(macro_build): Handle "K" operand.
	(macro2): Use ISA_HAS_DROR and ISA_HAS_ROR in the places where
	CPU_HAS_DROR and CPU_HAS_ROR are currently used.
	(mips_ip): New variable "lastpos", and implement "+A", "+B",
	and "+C" operands for MIPS32 Release 2 ins/ext instructions.
	Implement "K" operand for MIPS32 Release 2 rdhwr instruction.
	(validate_mips_insn): Implement "+" as a way to extend the
	allowed operands, and implement "K", "+A", "+B", and "+C"
	operands.
	(OPTION_MIPS32R2): New define.
	(md_longopts): Add entry for OPTION_MIPS32R2.
	(OPTION_ELF_BASE): Adjust to accomodate OPTIONS_MIPS32R2.
	(md_parse_option): Handle OPTION_MIPS32R2.
	(s_mipsset): Reimplement handling of ".set mipsN" options
	and add support for ".set mips32r2".
	(mips_cpu_info_table): Add entry for "mips32r2" (MIPS32 Release 2).
	(md_show_usage): Document "-mips32r2" option.
	* doc/as.texinfo: Document "-mips32r2" option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips32r2.d: New test.
	* gas/mips/hwr-names-mips32r2.d: New test.
	* gas/mips/hwr-names-numeric.d: New test.
	* gas/mips/hwr-names.s: New test source file.
	* gas/mips/mips32r2.d: New test.
	* gas/mips/mips32r2.s: New test source file.
	* gas/mips/mips32r2-ill.l: New test.
	* gas/mips/mips32r2-ill.s: New test source file.
	* gas/mips/mips.exp: Add mips32r2 architecture data array
	entry.  Run new tests mentioned above.

[ include/elf/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_32R2): New define.

[ include/opcode/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document "+" as the start of two-character operand
	type names, and add new "K", "+A", "+B", and "+C" operand types.
	(OP_MASK_INSMSB, OP_SH_INSMSB, OP_MASK_EXTMSB)
	(OP_SH_EXTMSB, INSN_ISA32R2, ISA_MIPS32R2, CPU_MIPS32R2): New
	defines.

[ opcodes/ChangeLog ]
2002-12-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_cp0_names_mips3264r2, mips_hwr_names_numeric)
	(mips_hwr_names_mips3264r2): New arrays.
	(mips_arch_choice): New "hwr_names" member.
	(mips_arch_choices): Adjust for structure change, and add a new
	entry for "mips32r2" ISA.
	(mips_hwr_names): New variable.
	(set_default_mips_dis_options): Set mips_hwr_names.
	(parse_mips_dis_option): New "hwr-names" option which sets
	mips_hwr_names, and adjust "reg-names=ARCH" to set mips_hwr_names.
	(print_insn_arg): Change return type to "int"
	and use that to indicate number of characters consumed.
	Add support for "+" operand extension character, "+A", "+B",
	"+C", and "K" operands.
	(print_insn_mips): Adjust for changes to print_insn_arg.
	(print_mips_disassembler_options): Adjust for "hwr-names"
	addition and "reg-names" change.
	* mips-opc (I33): New define (shorthand for INSN_ISA32R2).
	(mips_builtin_opcodes): Note that "nop" and "ssnop" are special
	forms of "sll".  Add new MIPS32 Release 2 instructions: ehb,
	di, ei, ext, ins, jr.hb, jalr.hb, mfhc1, mfhc2, mthc1, mthc2,
	rdhwr, rdpgpr, seb, seh, synci, wrpgpr, wsbh.
	Note that hardware rotate instructions (ror, rorv) can be
	used on MIPS32 Release 2, and add the official mnemonics
	for them (rotr, rotrv) and the similar "rotl" mnemonic for
	left-rotate.
@
text
@d3 1
a3 1
   2001, 2002
d108 1
a108 3
	configuration is selected.

*/
d158 1
a158 1
	addend.
a159 1
*/
d230 2
a231 1
reloc_howto_type howto_table_std[] = {
d3068 1
a3068 1
  ret = (struct aout_link_hash_table *) bfd_alloc (abfd, amt);
d3071 1
d3908 2
a3909 4
	{
	  if (p->type == bfd_indirect_link_order)
	    p->u.indirect.section->linker_mark = TRUE;
	}
@


1.38
log
@Allow an otherwise unrepresentable read-only section that lies after .text
and before .data to be written into the output file and included in a_text.
@
text
@d803 1
@


1.37
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1290 11
a1300 5
      (*_bfd_error_handler)
	(_("%s: can not represent section `%s' in a.out object file format"),
	 bfd_get_filename (abfd), bfd_get_section_name (abfd, section));
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
d1712 10
a1721 5
      (*_bfd_error_handler)
	(_("%s: can not represent section `%s' in a.out object file format"),
	 bfd_get_filename (abfd), bfd_get_section_name (abfd, sec));
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
@


1.36
log
@	* aoutx.h (NAME(aout,swap_ext_reloc_in)): Cast bytes->r_index to
	unsigned int.  Cast RELOC_BASE10, RELOC_BASE13 and RELOC_BASE22 to
	unsigned int.
	(NAME(aout,final_link)): Cast enum used in assignment.
	(aout_link_write_symbols): Cast enums in comparisons, int values to
	boolean, enums in assignments to int.
	(aout_link_input_section_std): Cast rel->r_index to unsigned int.
	(aout_link_input_section_ext): Likewise.  Cast enums used in comparisons
	with unsigned ints.
	(aout_link_reloc_link_order): Cast enum to int in assignment.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Cast result of memchr
	calls to char *.
	* bfd-in.h (bfd_set_section_vma): Cast enum true to unsigned int in
	assignment.
	* bfd-in2.h (bfd_set_section_vma): Likewise.
	* bfd.c (bfd_record_phdr): Cast enums in assignments.
	* binary.c (bfd_alloc): Cast enum to long.
	* coffgen.c (_bfd_coff_is_local_label_name): Cast return to boolean.
	* dwarf2.c (read_abbrevs): Add casts to enum types.
	(read_attribute_value): Likewise.
	(arange_add): Cast result of bfd_zalloc call.
	(comp_unit_contains_address): Return true and false.
	(comp_unit_find_nearest_line): Cast return to boolean.
	* format.c (bfd_check_format_matches, bfd_set_format): Likewise.
	* gen-aout.c: define macro '_' if not defined.
	* libbfd.c (bfd_realloc): Cast malloc and realloc to PTR.
	(bfd_bwrite): Cast bfd_realloc to bfd_byte *.
	(bfd_write_bigendian_4byte_int): Cast return to boolean.
	(bfd_seek): Cast bfd_realloc to bfd_byte *.
	(bfd_generic_is_local_label_name): Cast return to boolean.
	* libcoff.h (_bfd_coff_adjust_symndx): Remove extraneous '\'.
	* linker.c (_bfd_link_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(_bfd_generic_link_hash_newfunc): likewise.
	(_bfd_generic_final_link): Cast enum to unsigned int.
	* merge.c (sec_merge_emit): Cast return to boolean.
	(merge_strings): Add casts to const unsigned char *.
	* reloc.c (bfd_get_reloc_code_name): Cast enums in comparison to int.
	(bfd_generic_get_relocated_section_content): Cast enum to unsigned int.
	* section.c (bfd_section_hash_newfunc): Cast bfd_hash_allocate result to
	struct bfd_hash_entry *.
	(bfd_set_section_content): Add cast to PTR in comparison.
	* simple.c (simple_dummy_warning, simple_dummy_undefined_symbol,
	simple_dummy_reloc_overflow, simple_dummy_reloc_dangerous,
	simple_dummy_unattached_reloc,
	bfd_simple_get_relocated_section_contents): Add K&R declarations and
	function definitions.
	* srec.c (S3Forced): Initialize to false.
	(srec_get_symtab): Cast return value from bfd_alloc to asymbol *.
	* stabs.c (_bfd_link_section_stabs): Cast enum to int in comparisons.
	(_bfd_discard_section_stabs): Likewise.  Also cast return to boolean.
	* syms.c (bfd_is_undefined_symclass): Cast return to boolean.
	(_bfd_stab_section_find_nearest_line): Cast enum to bfd_byte in
	comparisons.
@
text
@d134 3
a136 2
static boolean aout_get_external_symbols PARAMS ((bfd *));
static boolean translate_from_native_sym_flags
d138 1
a138 1
static boolean translate_to_native_sym_flags
d140 6
a145 3
static void adjust_o_magic PARAMS ((bfd *, struct internal_exec *));
static void adjust_z_magic PARAMS ((bfd *, struct internal_exec *));
static void adjust_n_magic PARAMS ((bfd *, struct internal_exec *));
d201 26
a226 26
  HOWTO(RELOC_8,      0,  0,  	8,  false, 0, complain_overflow_bitfield,0,"8",        false, 0,0x000000ff, false),
  HOWTO(RELOC_16,     0,  1, 	16, false, 0, complain_overflow_bitfield,0,"16",       false, 0,0x0000ffff, false),
  HOWTO(RELOC_32,     0,  2, 	32, false, 0, complain_overflow_bitfield,0,"32",       false, 0,0xffffffff, false),
  HOWTO(RELOC_DISP8,  0,  0, 	8,  true,  0, complain_overflow_signed,0,"DISP8", 	false, 0,0x000000ff, false),
  HOWTO(RELOC_DISP16, 0,  1, 	16, true,  0, complain_overflow_signed,0,"DISP16", 	false, 0,0x0000ffff, false),
  HOWTO(RELOC_DISP32, 0,  2, 	32, true,  0, complain_overflow_signed,0,"DISP32", 	false, 0,0xffffffff, false),
  HOWTO(RELOC_WDISP30,2,  2, 	30, true,  0, complain_overflow_signed,0,"WDISP30", 	false, 0,0x3fffffff, false),
  HOWTO(RELOC_WDISP22,2,  2, 	22, true,  0, complain_overflow_signed,0,"WDISP22", 	false, 0,0x003fffff, false),
  HOWTO(RELOC_HI22,   10, 2, 	22, false, 0, complain_overflow_bitfield,0,"HI22",	false, 0,0x003fffff, false),
  HOWTO(RELOC_22,     0,  2, 	22, false, 0, complain_overflow_bitfield,0,"22",       false, 0,0x003fffff, false),
  HOWTO(RELOC_13,     0,  2, 	13, false, 0, complain_overflow_bitfield,0,"13",       false, 0,0x00001fff, false),
  HOWTO(RELOC_LO10,   0,  2, 	10, false, 0, complain_overflow_dont,0,"LO10",     false, 0,0x000003ff, false),
  HOWTO(RELOC_SFA_BASE,0, 2, 	32, false, 0, complain_overflow_bitfield,0,"SFA_BASE", false, 0,0xffffffff, false),
  HOWTO(RELOC_SFA_OFF13,0,2, 	32, false, 0, complain_overflow_bitfield,0,"SFA_OFF13",false, 0,0xffffffff, false),
  HOWTO(RELOC_BASE10, 0,  2, 	10, false, 0, complain_overflow_dont,0,"BASE10",   false, 0,0x000003ff, false),
  HOWTO(RELOC_BASE13, 0,  2,	13, false, 0, complain_overflow_signed,0,"BASE13",   false, 0,0x00001fff, false),
  HOWTO(RELOC_BASE22, 10, 2,	22, false, 0, complain_overflow_bitfield,0,"BASE22",   false, 0,0x003fffff, false),
  HOWTO(RELOC_PC10,   0,  2,	10, true,  0, complain_overflow_dont,0,"PC10",	false, 0,0x000003ff, true),
  HOWTO(RELOC_PC22,   10,  2,	22, true,  0, complain_overflow_signed,0,"PC22", false, 0,0x003fffff, true),
  HOWTO(RELOC_JMP_TBL,2,  2, 	30, true,  0, complain_overflow_signed,0,"JMP_TBL", 	false, 0,0x3fffffff, false),
  HOWTO(RELOC_SEGOFF16,0, 2,	0,  false, 0, complain_overflow_bitfield,0,"SEGOFF16",	false, 0,0x00000000, false),
  HOWTO(RELOC_GLOB_DAT,0, 2,	0,  false, 0, complain_overflow_bitfield,0,"GLOB_DAT",	false, 0,0x00000000, false),
  HOWTO(RELOC_JMP_SLOT,0, 2,	0,  false, 0, complain_overflow_bitfield,0,"JMP_SLOT",	false, 0,0x00000000, false),
  HOWTO(RELOC_RELATIVE,0, 2,	0,  false, 0, complain_overflow_bitfield,0,"RELATIVE",	false, 0,0x00000000, false),
  HOWTO(0,  0, 0,    0,  false, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    false,0,0x00000000,true),
  HOWTO(0,  0, 0,    0,  false, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    false,0,0x00000000,true),
d228 1
a228 1
  HOWTO(RELOC_SPARC_REV32,    0,  2, 	32, false, 0, complain_overflow_dont,0,"R_SPARC_REV32",       false, 0,0xffffffff, false),
d235 11
a245 11
HOWTO ( 0,	       0,  0,  	8,  false, 0, complain_overflow_bitfield,0,"8",		true, 0x000000ff,0x000000ff, false),
HOWTO ( 1,	       0,  1, 	16, false, 0, complain_overflow_bitfield,0,"16",	true, 0x0000ffff,0x0000ffff, false),
HOWTO ( 2,	       0,  2, 	32, false, 0, complain_overflow_bitfield,0,"32",	true, 0xffffffff,0xffffffff, false),
HOWTO ( 3,	       0,  4, 	64, false, 0, complain_overflow_bitfield,0,"64",	true, 0xdeaddead,0xdeaddead, false),
HOWTO ( 4,	       0,  0, 	8,  true,  0, complain_overflow_signed,  0,"DISP8",	true, 0x000000ff,0x000000ff, false),
HOWTO ( 5,	       0,  1, 	16, true,  0, complain_overflow_signed,  0,"DISP16",	true, 0x0000ffff,0x0000ffff, false),
HOWTO ( 6,	       0,  2, 	32, true,  0, complain_overflow_signed,  0,"DISP32",	true, 0xffffffff,0xffffffff, false),
HOWTO ( 7,	       0,  4, 	64, true,  0, complain_overflow_signed,  0,"DISP64",	true, 0xfeedface,0xfeedface, false),
HOWTO ( 8,	       0,  2,    0, false, 0, complain_overflow_bitfield,0,"GOT_REL",	false,         0,0x00000000, false),
HOWTO ( 9,	       0,  1,   16, false, 0, complain_overflow_bitfield,0,"BASE16",	false,0xffffffff,0xffffffff, false),
HOWTO (10,	       0,  2,   32, false, 0, complain_overflow_bitfield,0,"BASE32",	false,0xffffffff,0xffffffff, false),
d251 1
a251 1
  HOWTO (16,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"JMP_TABLE", false,         0,0x00000000, false),
d267 1
a267 1
  HOWTO (32,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"RELATIVE",  false,         0,0x00000000, false),
d275 1
a275 1
  HOWTO (40,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"BASEREL",   false,         0,0x00000000, false),
d426 1
a426 1
boolean
d432 1
a432 1
    return false;
d435 1
a435 1
    return false;
d438 2
a439 2
    return false;
  return true;
d680 1
a680 1
	boolean aout_@@var{size}_mkobject, (bfd *abfd);
d686 1
a686 1
boolean
d697 1
a697 1
    return false;
d706 1
a706 1
  return true;
d732 1
a732 1
     boolean *unknown;
d737 1
a737 1
  *unknown = true;
d756 1
a756 1
	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = false; break;
d826 1
a826 1
      *unknown = false;
d839 1
a839 1
    *unknown = false;
d849 1
a849 1
	boolean aout_@@var{size}_set_arch_mach,
d860 1
a860 1
boolean
d867 1
a867 1
    return false;
d871 1
a871 1
      boolean unknown;
d875 1
a875 1
	return false;
d1123 1
a1123 1
boolean
d1132 1
a1132 1
    return false;
d1135 1
a1135 1
    return true;
d1212 1
a1212 1
  return true;
d1220 1
a1220 1
        boolean aout_@@var{size}_new_section_hook,
d1228 1
a1228 1
boolean
d1242 1
a1242 1
	  return true;
d1249 1
a1249 1
	  return true;
d1256 1
a1256 1
	  return true;
d1261 1
a1261 1
  return true;
d1264 1
a1264 1
boolean
d1278 1
a1278 1
	return false;
d1284 1
a1284 1
      return false;
d1294 1
a1294 1
      return false;
d1301 1
a1301 1
	return false;
d1304 1
a1304 1
  return true;
d1309 1
a1309 1
static boolean
d1324 2
a1325 2
				 &obj_aout_sym_window (abfd), true))
	return false;
d1334 1
a1334 1
	return false;
d1341 1
a1341 1
	  return false;
d1360 1
a1360 1
	return false;
d1365 2
a1366 2
				 &obj_aout_string_window (abfd), true))
	return false;
d1371 1
a1371 1
	return false;
d1379 1
a1379 1
	  return false;
d1392 1
a1392 1
  return true;
d1400 1
a1400 1
static boolean
d1437 1
a1437 1
      return true;
d1526 1
a1526 1
	      return false;
d1531 1
a1531 1
	      return false;
d1537 1
a1537 1
	  return false;
d1650 1
a1650 1
  return true;
d1655 1
a1655 1
static boolean
d1681 1
a1681 1
      return false;
d1710 1
a1710 1
      return false;
d1758 1
a1758 1
  return true;
d1778 1
a1778 1
boolean
d1786 1
a1786 1
     boolean dynamic;
d1808 1
a1808 1
	return false;
d1817 1
a1817 1
	return false;
d1823 1
a1823 1
  return true;
d1830 1
a1830 1
boolean
d1840 1
a1840 1
    return true;
d1845 1
a1845 1
    return false;
d1851 1
a1851 1
    return false;
d1860 1
a1860 1
	  false)))
d1863 1
a1863 1
      return false;
d1885 1
a1885 1
  return true;
d1898 3
a1900 2
  PARAMS ((bfd *, struct bfd_strtab_hash *, const char *, boolean));
static boolean emit_stringtab PARAMS ((bfd *, struct bfd_strtab_hash *));
d1910 1
a1910 1
     boolean copy;
d1912 1
a1912 1
  boolean hash;
d1921 1
a1921 1
  hash = true;
d1923 1
a1923 1
    hash = false;
d1940 1
a1940 1
static boolean
d1951 1
a1951 1
    return false;
d1956 1
a1956 1
boolean
d1966 1
a1966 1
    return false;
d1975 1
a1975 1
      indx = add_to_stringtab (abfd, strtab, g->name, false);
d2010 1
a2010 1
  return true;
d2014 1
a2014 1
  return false;
d2378 1
a2378 1
boolean
d2394 1
a2394 1
    return true;
d2397 1
a2397 1
    return true;
d2408 1
a2408 1
      return false;
d2412 1
a2412 1
    return false;
d2421 1
a2421 1
    return false;
d2427 1
a2427 1
      return false;
d2434 1
a2434 1
      return false;
d2460 1
a2460 1
  return true;
d2465 1
a2465 1
boolean
d2478 1
a2478 1
    return true;
d2484 1
a2484 1
    return false;
d2508 1
a2508 1
      return false;
d2512 1
a2512 1
  return true;
d2689 1
a2689 1
     boolean dynamic;
d2725 1
a2725 1
     boolean dynamic;
d2743 1
a2743 1
	  false)))
d2753 1
a2753 1
boolean
d2912 1
a2912 1
	return false;
d2949 1
a2949 1
  return true;
d2955 1
a2955 1
     boolean execable ATTRIBUTE_UNUSED;
d2963 1
a2963 1
boolean
d2971 1
a2971 1
    return true;
d2988 1
a2988 1
  return true;
d2993 1
a2993 1
static boolean aout_link_add_object_symbols
d2995 7
a3001 6
static boolean aout_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean aout_link_free_symbols PARAMS ((bfd *));
static boolean aout_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *pneeded));
static boolean aout_link_add_symbols
d3029 1
a3029 1
      ret->written = false;
d3038 1
a3038 1
boolean
d3042 3
a3044 3
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d3073 1
a3073 1
boolean
d3087 1
a3087 1
      return false;
d3093 1
a3093 1
static boolean
d3099 1
a3099 1
    return false;
d3101 1
a3101 1
    return false;
d3105 1
a3105 1
	return false;
d3107 1
a3107 1
  return true;
d3115 1
a3115 1
static boolean
d3119 1
a3119 1
     boolean *pneeded;
d3122 1
a3122 1
    return false;
d3125 1
a3125 1
    return false;
d3130 1
a3130 1
	return false;
d3136 1
a3136 1
	return false;
d3139 1
a3139 1
  return true;
d3144 1
a3144 1
static boolean
d3166 1
a3166 1
  return true;
d3176 1
a3176 1
static boolean
d3180 1
a3180 1
     boolean *pneeded;
d3186 1
a3186 1
  *pneeded = false;
d3216 1
a3216 1
      h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d3275 3
a3277 3
	    return false;
	  *pneeded = true;
	  return true;
d3304 3
a3306 3
			return false;
		      *pneeded = true;
		      return true;
d3315 1
a3315 1
		    return false;
d3352 3
a3354 3
		return false;
	      *pneeded = true;
	      return true;
d3360 1
a3360 1
  return true;
d3365 1
a3365 1
static boolean
d3370 4
a3373 5
  boolean (*add_one_symbol) PARAMS ((struct bfd_link_info *, bfd *,
				     const char *, flagword, asection *,
				     bfd_vma, const char *, boolean,
				     boolean,
				     struct bfd_link_hash_entry **));
d3377 1
a3377 1
  boolean copy;
d3387 1
a3387 1
    copy = false;
d3389 1
a3389 1
    copy = true;
d3395 1
a3395 1
	return false;
d3405 1
a3405 1
    return false;
d3551 1
a3551 1
	     (info, abfd, name, flags, section, value, string, copy, false,
d3553 1
a3553 1
	return false;
d3579 1
a3579 1
  return true;
d3642 1
a3642 1
static boolean aout_link_input_bfd
d3644 1
a3644 1
static boolean aout_link_write_symbols
d3646 1
a3646 1
static boolean aout_link_write_other_symbol
d3648 1
a3648 1
static boolean aout_link_input_section
d3652 1
a3652 1
static boolean aout_link_input_section_std
d3656 1
a3656 1
static boolean aout_link_input_section_ext
d3662 1
a3662 1
static boolean aout_link_reloc_link_order
d3705 1
a3705 1
boolean
d3712 1
a3712 1
  boolean includes_hash_initialized = false;
d3722 1
a3722 1
  boolean have_link_order_relocs;
d3738 1
a3738 1
  includes_hash_initialized = true;
d3861 1
a3861 1
			       false, false, false);
d3888 1
a3888 1
    sub->output_has_begun = false;
d3899 1
a3899 1
	    p->u.indirect.section->linker_mark = (unsigned int) true;
d3903 1
a3903 1
  have_link_order_relocs = false;
d3921 1
a3921 1
		  input_bfd->output_has_begun = true;
d3928 1
a3928 1
	      have_link_order_relocs = true;
d3988 1
a3988 1
      includes_hash_initialized = false;
d4027 1
a4027 1
  return true;
d4040 1
a4040 1
  return false;
d4045 1
a4045 1
static boolean
d4063 1
a4063 1
     finfo->info->keep_memory is false.  */
d4065 1
a4065 1
    return false;
d4072 1
a4072 1
    return false;
d4084 1
a4084 1
	return false;
d4092 1
a4092 1
	return false;
d4101 1
a4101 1
	return false;
d4104 1
a4104 1
  return true;
d4110 1
a4110 1
static boolean
d4126 2
a4127 2
  boolean pass;
  boolean skip_next;
d4141 1
a4141 1
			      false, false) != NULL)
d4148 1
a4148 1
				       input_bfd->filename, false);
d4150 1
a4150 1
	return false;
d4161 2
a4162 2
  pass = false;
  skip_next = false;
d4173 1
a4173 1
      boolean skip;
d4176 1
a4176 1
      boolean copy;
d4200 1
a4200 1
	  pass = false;
d4207 1
a4207 1
	  skip_next = false;
d4249 1
a4249 1
		skip_next = true;
d4255 1
a4255 1
	  skip = false;
d4262 1
a4262 1
		skip = true;
d4265 1
a4265 1
	      if (bfd_hash_lookup (finfo->info->keep_hash, name, false, false)
d4267 1
a4267 1
		skip = true;
d4270 1
a4270 1
	      skip = true;
d4276 1
a4276 1
		h->written = true;
d4305 1
a4305 1
	      pass = true;
d4321 1
a4321 1
		skip_next = true;
d4413 1
a4413 1
	      h->written = true;
d4429 1
a4429 1
		    skip = true;
d4432 1
a4432 1
		  skip = true;
d4437 1
a4437 1
		  pass = false;
d4493 1
a4493 1
	      copy = (boolean) (! finfo->info->keep_memory);
d4495 1
a4495 1
						      name, true, copy);
d4497 1
a4497 1
		return false;
d4509 1
a4509 1
		    return false;
d4554 1
a4554 1
      copy = false;
d4563 1
a4563 1
	    copy = true;
d4568 1
a4568 1
	return false;
d4582 1
a4582 1
	return false;
d4587 1
a4587 1
	return false;
d4591 1
a4591 1
  return true;
d4597 1
a4597 1
static boolean
d4614 1
a4614 1
	return true;
d4630 1
a4630 1
    return true;
d4632 1
a4632 1
  h->written = true;
d4639 2
a4640 2
				  false, false) == NULL)))
    return true;
d4648 1
a4648 1
      return true;
d4652 1
a4652 1
      return true;
d4689 1
a4689 1
      return true;
d4696 1
a4696 1
			   false);
d4717 1
a4717 1
  return true;
d4722 1
a4722 1
static boolean
d4739 1
a4739 1
    return false;
d4752 1
a4752 1
	    return false;
d4762 1
a4762 1
	return false;
d4769 1
a4769 1
	return false;
d4778 1
a4778 1
    return false;
d4785 1
a4785 1
	return false;
d4787 1
a4787 1
	return false;
d4799 1
a4799 1
  return true;
d4829 1
a4829 1
static boolean
d4839 4
a4842 5
  boolean (*check_dynamic_reloc) PARAMS ((struct bfd_link_info *,
					  bfd *, asection *,
					  struct aout_link_hash_entry *,
					  PTR, bfd_byte *, boolean *,
					  bfd_vma *));
d4844 1
a4844 1
  boolean relocateable;
d4986 1
a4986 1
			      h->written = false;
d4989 1
a4989 1
				return false;
d5002 1
a5002 1
			    return false;
d5062 1
a5062 1
	  boolean hundef;
d5066 1
a5066 1
	  hundef = false;
d5085 1
a5085 1
		  hundef = true;
d5103 1
a5103 1
	      boolean skip;
d5108 1
a5108 1
		return false;
d5126 2
a5127 2
		     r_addr, true)))
		return false;
d5162 1
a5162 1
		  return false;
d5169 1
a5169 1
  return true;
d5174 1
a5174 1
static boolean
d5184 4
a5187 5
  boolean (*check_dynamic_reloc) PARAMS ((struct bfd_link_info *,
					  bfd *, asection *,
					  struct aout_link_hash_entry *,
					  PTR, bfd_byte *, boolean *,
					  bfd_vma *));
d5189 1
a5189 1
  boolean relocateable;
d5323 1
a5323 1
			      h->written = false;
d5326 1
a5326 1
				return false;
d5339 1
a5339 1
			    return false;
d5404 1
a5404 1
	  boolean hundef;
d5409 1
a5409 1
	  hundef = false;
d5428 1
a5428 1
		  hundef = true;
d5501 1
a5501 1
	      boolean skip;
d5506 1
a5506 1
		return false;
d5528 2
a5529 2
		     r_addr, true)))
		return false;
d5576 1
a5576 1
		      return false;
d5584 1
a5584 1
  return true;
d5589 1
a5589 1
static boolean
d5626 1
a5626 1
					 pr->u.name, false, false, true));
d5637 1
a5637 1
	  h->written = false;
d5639 1
a5639 1
	    return false;
d5647 1
a5647 1
	    return false;
d5656 1
a5656 1
      return false;
d5726 1
a5726 1
	  boolean ok;
d5731 1
a5731 1
	    return false;
d5752 1
a5752 1
		  return false;
d5760 1
a5760 1
	    return false;
d5799 1
a5799 1
    return false;
d5810 1
a5810 1
  return true;
@


1.35
log
@	* aoutx.h (NAME(aout,machine_type)): Recognize bfd_mach_i386_i386
	and bfd_mach_i386_i386_intel_syntax.
@
text
@d2264 2
a2265 2
      r_index = ((bytes->r_index[0] << 16)
		 | (bytes->r_index[1] << 8)
d2273 2
a2274 2
      r_index =  ((bytes->r_index[2] << 16)
		  | (bytes->r_index[1] << 8)
d2286 3
a2288 3
  if (r_type == RELOC_BASE10
      || r_type == RELOC_BASE13
      || r_type == RELOC_BASE22)
d2323 2
a2324 2
      r_index = ((bytes->r_index[0] << 16)
		 | (bytes->r_index[1] << 8)
d2336 2
a2337 2
      r_index = ((bytes->r_index[2] << 16)
		 | (bytes->r_index[1] << 8)
d3894 1
a3894 1
	    p->u.indirect.section->linker_mark = true;
d4443 1
a4443 1
	  if (type == N_BINCL)
d4457 1
a4457 1
		  if (incl_type == N_EINCL)
d4463 1
a4463 1
		  else if (incl_type == N_BINCL)
d4488 1
a4488 1
	      copy = ! finfo->info->keep_memory;
d4516 1
a4516 1
		  type = N_EXCL;
d4526 1
a4526 1
		      if (incl_type == N_EINCL)
d4535 1
a4535 1
		      else if (incl_type == N_BINCL)
d4890 2
a4891 2
	    r_index   =  ((rel->r_index[0] << 16)
			  | (rel->r_index[1] << 8)
d4903 2
a4904 2
	    r_index   = ((rel->r_index[2] << 16)
			 | (rel->r_index[1] << 8)
d5226 2
a5227 2
	  r_index  = ((rel->r_index[0] << 16)
		      | (rel->r_index[1] << 8)
d5235 2
a5236 2
	  r_index  = ((rel->r_index[2] << 16)
		      | (rel->r_index[1] << 8)
d5252 3
a5254 3
	      || r_type == RELOC_BASE10
	      || r_type == RELOC_BASE13
	      || r_type == RELOC_BASE22)
d5259 3
a5261 3
	      if (r_type == RELOC_BASE10
		  || r_type == RELOC_BASE13
		  || r_type == RELOC_BASE22)
d5429 3
a5431 3
	  else if (r_type == RELOC_BASE10
		   || r_type == RELOC_BASE13
		   || r_type == RELOC_BASE22)
d5513 3
a5515 3
	      && r_type != RELOC_BASE10
	      && r_type != RELOC_BASE13
	      && r_type != RELOC_BASE22)
d5529 1
a5529 1
	  if (r_type != RELOC_SPARC_REV32)
d5558 3
a5560 3
			     || r_type == RELOC_BASE10
			     || r_type == RELOC_BASE13
			     || r_type == RELOC_BASE22)
d5676 1
a5676 1
	r_pcrel = howto->pc_relative;
@


1.35.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2001, 2002, 2003
d108 3
a110 1
	configuration is selected.  */
d134 2
a135 3
static bfd_boolean aout_get_external_symbols
  PARAMS ((bfd *));
static bfd_boolean translate_from_native_sym_flags
d137 1
a137 1
static bfd_boolean translate_to_native_sym_flags
d139 3
a141 6
static void adjust_o_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_z_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_n_magic
  PARAMS ((bfd *, struct internal_exec *));
d156 1
a156 1
	addend.  */
d158 1
d197 26
a222 26
  HOWTO(RELOC_8,      0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_16,     0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_32,     0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_DISP8,  0,  0, 	8,  TRUE,  0, complain_overflow_signed,0,"DISP8", 	FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_DISP16, 0,  1, 	16, TRUE,  0, complain_overflow_signed,0,"DISP16", 	FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_DISP32, 0,  2, 	32, TRUE,  0, complain_overflow_signed,0,"DISP32", 	FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_WDISP30,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"WDISP30", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_WDISP22,2,  2, 	22, TRUE,  0, complain_overflow_signed,0,"WDISP22", 	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_HI22,   10, 2, 	22, FALSE, 0, complain_overflow_bitfield,0,"HI22",	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_22,     0,  2, 	22, FALSE, 0, complain_overflow_bitfield,0,"22",       FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_13,     0,  2, 	13, FALSE, 0, complain_overflow_bitfield,0,"13",       FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_LO10,   0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"LO10",     FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_SFA_BASE,0, 2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_BASE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_SFA_OFF13,0,2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_OFF13",FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_BASE10, 0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"BASE10",   FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_BASE13, 0,  2,	13, FALSE, 0, complain_overflow_signed,0,"BASE13",   FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_BASE22, 10, 2,	22, FALSE, 0, complain_overflow_bitfield,0,"BASE22",   FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_PC10,   0,  2,	10, TRUE,  0, complain_overflow_dont,0,"PC10",	FALSE, 0,0x000003ff, TRUE),
  HOWTO(RELOC_PC22,   10,  2,	22, TRUE,  0, complain_overflow_signed,0,"PC22", FALSE, 0,0x003fffff, TRUE),
  HOWTO(RELOC_JMP_TBL,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"JMP_TBL", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_SEGOFF16,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"SEGOFF16",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_GLOB_DAT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"GLOB_DAT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_JMP_SLOT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"JMP_SLOT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_RELATIVE,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",	FALSE, 0,0x00000000, FALSE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
d224 1
a224 1
  HOWTO(RELOC_SPARC_REV32,    0,  2, 	32, FALSE, 0, complain_overflow_dont,0,"R_SPARC_REV32",       FALSE, 0,0xffffffff, FALSE),
d229 1
a229 2
reloc_howto_type howto_table_std[] =
{
d231 11
a241 11
HOWTO ( 0,	       0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",		TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 1,	       0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 2,	       0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 3,	       0,  4, 	64, FALSE, 0, complain_overflow_bitfield,0,"64",	TRUE, 0xdeaddead,0xdeaddead, FALSE),
HOWTO ( 4,	       0,  0, 	8,  TRUE,  0, complain_overflow_signed,  0,"DISP8",	TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 5,	       0,  1, 	16, TRUE,  0, complain_overflow_signed,  0,"DISP16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 6,	       0,  2, 	32, TRUE,  0, complain_overflow_signed,  0,"DISP32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 7,	       0,  4, 	64, TRUE,  0, complain_overflow_signed,  0,"DISP64",	TRUE, 0xfeedface,0xfeedface, FALSE),
HOWTO ( 8,	       0,  2,    0, FALSE, 0, complain_overflow_bitfield,0,"GOT_REL",	FALSE,         0,0x00000000, FALSE),
HOWTO ( 9,	       0,  1,   16, FALSE, 0, complain_overflow_bitfield,0,"BASE16",	FALSE,0xffffffff,0xffffffff, FALSE),
HOWTO (10,	       0,  2,   32, FALSE, 0, complain_overflow_bitfield,0,"BASE32",	FALSE,0xffffffff,0xffffffff, FALSE),
d247 1
a247 1
  HOWTO (16,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"JMP_TABLE", FALSE,         0,0x00000000, FALSE),
d263 1
a263 1
  HOWTO (32,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",  FALSE,         0,0x00000000, FALSE),
d271 1
a271 1
  HOWTO (40,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"BASEREL",   FALSE,         0,0x00000000, FALSE),
d422 1
a422 1
bfd_boolean
d428 1
a428 1
    return FALSE;
d431 1
a431 1
    return FALSE;
d434 2
a435 2
    return FALSE;
  return TRUE;
d676 1
a676 1
	bfd_boolean aout_@@var{size}_mkobject, (bfd *abfd);
d682 1
a682 1
bfd_boolean
d693 1
a693 1
    return FALSE;
d702 1
a702 1
  return TRUE;
d728 1
a728 1
     bfd_boolean *unknown;
d733 1
a733 1
  *unknown = TRUE;
d752 1
a752 1
	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = FALSE; break;
a798 1
	case bfd_mach_mipsisa32r2:
a800 1
	case bfd_mach_mipsisa64r2:
d822 1
a822 1
      *unknown = FALSE;
d835 1
a835 1
    *unknown = FALSE;
d845 1
a845 1
	bfd_boolean aout_@@var{size}_set_arch_mach,
d856 1
a856 1
bfd_boolean
d863 1
a863 1
    return FALSE;
d867 1
a867 1
      bfd_boolean unknown;
d871 1
a871 1
	return FALSE;
d1119 1
a1119 1
bfd_boolean
d1128 1
a1128 1
    return FALSE;
d1131 1
a1131 1
    return TRUE;
d1208 1
a1208 1
  return TRUE;
d1216 1
a1216 1
        bfd_boolean aout_@@var{size}_new_section_hook,
d1224 1
a1224 1
bfd_boolean
d1238 1
a1238 1
	  return TRUE;
d1245 1
a1245 1
	  return TRUE;
d1252 1
a1252 1
	  return TRUE;
d1257 1
a1257 1
  return TRUE;
d1260 1
a1260 1
bfd_boolean
d1264 1
a1264 1
     const PTR location;
d1274 1
a1274 1
	return FALSE;
d1280 1
a1280 1
      return FALSE;
d1286 5
a1290 11
      if (aout_section_merge_with_text_p (abfd, section))
	section->filepos = obj_textsec (abfd)->filepos +
			   (section->vma - obj_textsec (abfd)->vma);
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, section));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
d1297 1
a1297 1
	return FALSE;
d1300 1
a1300 1
  return TRUE;
d1305 1
a1305 1
static bfd_boolean
d1320 2
a1321 2
				 &obj_aout_sym_window (abfd), TRUE))
	return FALSE;
d1330 1
a1330 1
	return FALSE;
d1337 1
a1337 1
	  return FALSE;
d1356 1
a1356 1
	return FALSE;
d1361 2
a1362 2
				 &obj_aout_string_window (abfd), TRUE))
	return FALSE;
d1367 1
a1367 1
	return FALSE;
d1375 1
a1375 1
	  return FALSE;
d1388 1
a1388 1
  return TRUE;
d1396 1
a1396 1
static bfd_boolean
d1433 1
a1433 1
      return TRUE;
d1522 1
a1522 1
	      return FALSE;
d1527 1
a1527 1
	      return FALSE;
d1533 1
a1533 1
	  return FALSE;
d1646 1
a1646 1
  return TRUE;
d1651 1
a1651 1
static bfd_boolean
d1677 1
a1677 1
      return FALSE;
d1702 5
a1706 10
      if (aout_section_merge_with_text_p (abfd, sec))
	sym_pointer->e_type[0] |= N_TEXT;
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, sec));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
d1754 1
a1754 1
  return TRUE;
d1774 1
a1774 1
bfd_boolean
d1782 1
a1782 1
     bfd_boolean dynamic;
d1804 1
a1804 1
	return FALSE;
d1813 1
a1813 1
	return FALSE;
d1819 1
a1819 1
  return TRUE;
d1826 1
a1826 1
bfd_boolean
d1836 1
a1836 1
    return TRUE;
d1841 1
a1841 1
    return FALSE;
d1847 1
a1847 1
    return FALSE;
d1856 1
a1856 1
	  FALSE)))
d1859 1
a1859 1
      return FALSE;
d1881 1
a1881 1
  return TRUE;
d1894 2
a1895 3
  PARAMS ((bfd *, struct bfd_strtab_hash *, const char *, bfd_boolean));
static bfd_boolean emit_stringtab
  PARAMS ((bfd *, struct bfd_strtab_hash *));
d1905 1
a1905 1
     bfd_boolean copy;
d1907 1
a1907 1
  bfd_boolean hash;
d1916 1
a1916 1
  hash = TRUE;
d1918 1
a1918 1
    hash = FALSE;
d1935 1
a1935 1
static bfd_boolean
d1946 1
a1946 1
    return FALSE;
d1951 1
a1951 1
bfd_boolean
d1961 1
a1961 1
    return FALSE;
d1970 1
a1970 1
      indx = add_to_stringtab (abfd, strtab, g->name, FALSE);
d2005 1
a2005 1
  return TRUE;
d2009 1
a2009 1
  return FALSE;
d2013 1
a2013 1
NAME(aout,canonicalize_symtab) (abfd, location)
d2264 2
a2265 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2273 2
a2274 2
      r_index =  (((unsigned int) bytes->r_index[2] << 16)
		  | ((unsigned int) bytes->r_index[1] << 8)
d2286 3
a2288 3
  if (r_type == (unsigned int) RELOC_BASE10
      || r_type == (unsigned int) RELOC_BASE13
      || r_type == (unsigned int) RELOC_BASE22)
d2323 2
a2324 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2336 2
a2337 2
      r_index = (((unsigned int) bytes->r_index[2] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2373 1
a2373 1
bfd_boolean
d2389 1
a2389 1
    return TRUE;
d2392 1
a2392 1
    return TRUE;
d2403 1
a2403 1
      return FALSE;
d2407 1
a2407 1
    return FALSE;
d2416 1
a2416 1
    return FALSE;
d2422 1
a2422 1
      return FALSE;
d2429 1
a2429 1
      return FALSE;
d2455 1
a2455 1
  return TRUE;
d2460 1
a2460 1
bfd_boolean
d2473 1
a2473 1
    return TRUE;
d2479 1
a2479 1
    return FALSE;
d2503 1
a2503 1
      return FALSE;
d2507 1
a2507 1
  return TRUE;
d2684 1
a2684 1
     bfd_boolean dynamic;
d2720 1
a2720 1
     bfd_boolean dynamic;
d2738 1
a2738 1
	  FALSE)))
d2748 1
a2748 1
bfd_boolean
d2907 1
a2907 1
	return FALSE;
d2944 1
a2944 1
  return TRUE;
d2950 1
a2950 1
     bfd_boolean execable ATTRIBUTE_UNUSED;
d2958 1
a2958 1
bfd_boolean
d2966 1
a2966 1
    return TRUE;
d2983 1
a2983 1
  return TRUE;
d2988 1
a2988 1
static bfd_boolean aout_link_add_object_symbols
d2990 6
a2995 7
static bfd_boolean aout_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean aout_link_free_symbols
  PARAMS ((bfd *));
static bfd_boolean aout_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean aout_link_add_symbols
d3023 1
a3023 1
      ret->written = FALSE;
d3032 1
a3032 1
bfd_boolean
d3036 3
a3038 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d3052 1
a3052 1
  ret = (struct aout_link_hash_table *) bfd_malloc (amt);
a3054 1

d3067 1
a3067 1
bfd_boolean
d3081 1
a3081 1
      return FALSE;
d3087 1
a3087 1
static bfd_boolean
d3093 1
a3093 1
    return FALSE;
d3095 1
a3095 1
    return FALSE;
d3099 1
a3099 1
	return FALSE;
d3101 1
a3101 1
  return TRUE;
d3109 1
a3109 1
static bfd_boolean
d3113 1
a3113 1
     bfd_boolean *pneeded;
d3116 1
a3116 1
    return FALSE;
d3119 1
a3119 1
    return FALSE;
d3124 1
a3124 1
	return FALSE;
d3130 1
a3130 1
	return FALSE;
d3133 1
a3133 1
  return TRUE;
d3138 1
a3138 1
static bfd_boolean
d3160 1
a3160 1
  return TRUE;
d3170 1
a3170 1
static bfd_boolean
d3174 1
a3174 1
     bfd_boolean *pneeded;
d3180 1
a3180 1
  *pneeded = FALSE;
d3210 1
a3210 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d3239 1
a3239 1
             dependant for backward compatibility.
d3269 3
a3271 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d3298 3
a3300 3
			return FALSE;
		      *pneeded = TRUE;
		      return TRUE;
d3309 1
a3309 1
		    return FALSE;
d3346 3
a3348 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d3354 1
a3354 1
  return TRUE;
d3359 1
a3359 1
static bfd_boolean
d3364 5
a3368 4
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	     bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
d3372 1
a3372 1
  bfd_boolean copy;
d3382 1
a3382 1
    copy = FALSE;
d3384 1
a3384 1
    copy = TRUE;
d3390 1
a3390 1
	return FALSE;
d3400 1
a3400 1
    return FALSE;
d3546 1
a3546 1
	     (info, abfd, name, flags, section, value, string, copy, FALSE,
d3548 1
a3548 1
	return FALSE;
d3574 1
a3574 1
  return TRUE;
d3637 1
a3637 1
static bfd_boolean aout_link_input_bfd
d3639 1
a3639 1
static bfd_boolean aout_link_write_symbols
d3641 1
a3641 1
static bfd_boolean aout_link_write_other_symbol
d3643 1
a3643 1
static bfd_boolean aout_link_input_section
d3647 1
a3647 1
static bfd_boolean aout_link_input_section_std
d3651 1
a3651 1
static bfd_boolean aout_link_input_section_ext
d3657 1
a3657 1
static bfd_boolean aout_link_reloc_link_order
d3700 1
a3700 1
bfd_boolean
d3707 1
a3707 1
  bfd_boolean includes_hash_initialized = FALSE;
d3717 1
a3717 1
  bfd_boolean have_link_order_relocs;
d3733 1
a3733 1
  includes_hash_initialized = TRUE;
d3736 1
a3736 1
     relocatable output, count the relocs.  */
d3746 1
a3746 1
      if (info->relocatable)
d3760 1
a3760 1
		(_("%s: relocatable link from %s to %s not supported"),
d3790 1
a3790 1
  if (info->relocatable)
d3856 1
a3856 1
			       FALSE, FALSE, FALSE);
d3883 1
a3883 1
    sub->output_has_begun = FALSE;
d3892 4
a3895 2
	if (p->type == bfd_indirect_link_order)
	  p->u.indirect.section->linker_mark = TRUE;
d3898 1
a3898 1
  have_link_order_relocs = FALSE;
d3916 1
a3916 1
		  input_bfd->output_has_begun = TRUE;
d3923 1
a3923 1
	      have_link_order_relocs = TRUE;
d3983 1
a3983 1
      includes_hash_initialized = FALSE;
d4022 1
a4022 1
  return TRUE;
d4035 1
a4035 1
  return FALSE;
d4040 1
a4040 1
static bfd_boolean
d4058 1
a4058 1
     finfo->info->keep_memory is FALSE.  */
d4060 1
a4060 1
    return FALSE;
d4067 1
a4067 1
    return FALSE;
d4079 1
a4079 1
	return FALSE;
d4087 1
a4087 1
	return FALSE;
d4096 1
a4096 1
	return FALSE;
d4099 1
a4099 1
  return TRUE;
d4105 1
a4105 1
static bfd_boolean
d4121 2
a4122 2
  bfd_boolean pass;
  bfd_boolean skip_next;
d4136 1
a4136 1
			      FALSE, FALSE) != NULL)
d4143 1
a4143 1
				       input_bfd->filename, FALSE);
d4145 1
a4145 1
	return FALSE;
d4156 2
a4157 2
  pass = FALSE;
  skip_next = FALSE;
d4168 1
a4168 1
      bfd_boolean skip;
d4171 1
a4171 1
      bfd_boolean copy;
d4195 1
a4195 1
	  pass = FALSE;
d4202 1
a4202 1
	  skip_next = FALSE;
d4244 1
a4244 1
		skip_next = TRUE;
d4250 1
a4250 1
	  skip = FALSE;
d4257 1
a4257 1
		skip = TRUE;
d4260 1
a4260 1
	      if (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d4262 1
a4262 1
		skip = TRUE;
d4265 1
a4265 1
	      skip = TRUE;
d4271 1
a4271 1
		h->written = TRUE;
d4300 1
a4300 1
	      pass = TRUE;
d4316 1
a4316 1
		skip_next = TRUE;
d4408 1
a4408 1
	      h->written = TRUE;
d4424 1
a4424 1
		    skip = TRUE;
d4427 1
a4427 1
		  skip = TRUE;
d4432 1
a4432 1
		  pass = FALSE;
d4443 1
a4443 1
	  if (type == (int) N_BINCL)
d4457 1
a4457 1
		  if (incl_type == (int) N_EINCL)
d4463 1
a4463 1
		  else if (incl_type == (int) N_BINCL)
d4488 1
a4488 1
	      copy = (bfd_boolean) (! finfo->info->keep_memory);
d4490 1
a4490 1
						      name, TRUE, copy);
d4492 1
a4492 1
		return FALSE;
d4504 1
a4504 1
		    return FALSE;
d4516 1
a4516 1
		  type = (int) N_EXCL;
d4526 1
a4526 1
		      if (incl_type == (int) N_EINCL)
d4535 1
a4535 1
		      else if (incl_type == (int) N_BINCL)
d4549 1
a4549 1
      copy = FALSE;
d4558 1
a4558 1
	    copy = TRUE;
d4563 1
a4563 1
	return FALSE;
d4577 1
a4577 1
	return FALSE;
d4582 1
a4582 1
	return FALSE;
d4586 1
a4586 1
  return TRUE;
d4592 1
a4592 1
static bfd_boolean
d4609 1
a4609 1
	return TRUE;
d4625 1
a4625 1
    return TRUE;
d4627 1
a4627 1
  h->written = TRUE;
d4634 2
a4635 2
				  FALSE, FALSE) == NULL)))
    return TRUE;
d4643 1
a4643 1
      return TRUE;
d4647 1
a4647 1
      return TRUE;
d4684 1
a4684 1
      return TRUE;
d4691 1
a4691 1
			   FALSE);
d4712 1
a4712 1
  return TRUE;
d4717 1
a4717 1
static bfd_boolean
d4734 1
a4734 1
    return FALSE;
d4747 1
a4747 1
	    return FALSE;
d4757 1
a4757 1
	return FALSE;
d4764 1
a4764 1
	return FALSE;
d4773 1
a4773 1
    return FALSE;
d4775 1
a4775 1
  /* If we are producing relocatable output, the relocs were
d4777 1
a4777 1
  if (finfo->info->relocatable && rel_size > 0)
d4780 1
a4780 1
	return FALSE;
d4782 1
a4782 1
	return FALSE;
d4794 1
a4794 1
  return TRUE;
d4824 1
a4824 1
static bfd_boolean
d4834 5
a4838 4
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
d4840 1
a4840 1
  bfd_boolean relocatable;
d4856 1
a4856 1
  relocatable = finfo->info->relocatable;
d4890 2
a4891 2
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
d4903 2
a4904 2
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
d4925 1
a4925 1
      if (relocatable)
d4927 1
a4927 1
	  /* We are generating a relocatable output file, and must
d4982 1
a4982 1
			      h->written = FALSE;
d4985 1
a4985 1
				return FALSE;
d4998 1
a4998 1
			    return FALSE;
d5058 1
a5058 1
	  bfd_boolean hundef;
d5062 1
a5062 1
	  hundef = FALSE;
d5081 1
a5081 1
		  hundef = TRUE;
d5099 1
a5099 1
	      bfd_boolean skip;
d5104 1
a5104 1
		return FALSE;
d5122 2
a5123 2
		     r_addr, TRUE)))
		return FALSE;
d5158 1
a5158 1
		  return FALSE;
d5165 1
a5165 1
  return TRUE;
d5170 1
a5170 1
static bfd_boolean
d5180 5
a5184 4
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
d5186 1
a5186 1
  bfd_boolean relocatable;
d5202 1
a5202 1
  relocatable = finfo->info->relocatable;
d5226 2
a5227 2
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5235 2
a5236 2
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5247 1
a5247 1
      if (relocatable)
d5249 1
a5249 1
	  /* We are generating a relocatable output file, and must
d5252 3
a5254 3
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
d5259 3
a5261 3
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
d5320 1
a5320 1
			      h->written = FALSE;
d5323 1
a5323 1
				return FALSE;
d5336 1
a5336 1
			    return FALSE;
d5401 1
a5401 1
	  bfd_boolean hundef;
d5406 1
a5406 1
	  hundef = FALSE;
d5425 1
a5425 1
		  hundef = TRUE;
d5429 3
a5431 3
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
d5498 1
a5498 1
	      bfd_boolean skip;
d5503 1
a5503 1
		return FALSE;
d5513 3
a5515 3
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
d5525 2
a5526 2
		     r_addr, TRUE)))
		return FALSE;
d5529 1
a5529 1
	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
d5558 3
a5560 3
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
d5573 1
a5573 1
		      return FALSE;
d5581 1
a5581 1
  return TRUE;
d5586 1
a5586 1
static bfd_boolean
d5623 1
a5623 1
					 pr->u.name, FALSE, FALSE, TRUE));
d5634 1
a5634 1
	  h->written = FALSE;
d5636 1
a5636 1
	    return FALSE;
d5644 1
a5644 1
	    return FALSE;
d5653 1
a5653 1
      return FALSE;
d5676 1
a5676 1
	r_pcrel = (int) howto->pc_relative;
d5723 1
a5723 1
	  bfd_boolean ok;
d5728 1
a5728 1
	    return FALSE;
d5749 1
a5749 1
		  return FALSE;
d5757 1
a5757 1
	    return FALSE;
d5796 1
a5796 1
    return FALSE;
d5807 1
a5807 1
  return TRUE;
@


1.35.6.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d2264 2
a2265 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2273 2
a2274 2
      r_index =  (((unsigned int) bytes->r_index[2] << 16)
		  | ((unsigned int) bytes->r_index[1] << 8)
d2286 3
a2288 3
  if (r_type == (unsigned int) RELOC_BASE10
      || r_type == (unsigned int) RELOC_BASE13
      || r_type == (unsigned int) RELOC_BASE22)
d2323 2
a2324 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2336 2
a2337 2
      r_index = (((unsigned int) bytes->r_index[2] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d3894 1
a3894 1
	    p->u.indirect.section->linker_mark = (unsigned int) true;
d4443 1
a4443 1
	  if (type == (int) N_BINCL)
d4457 1
a4457 1
		  if (incl_type == (int) N_EINCL)
d4463 1
a4463 1
		  else if (incl_type == (int) N_BINCL)
d4488 1
a4488 1
	      copy = (boolean) (! finfo->info->keep_memory);
d4516 1
a4516 1
		  type = (int) N_EXCL;
d4526 1
a4526 1
		      if (incl_type == (int) N_EINCL)
d4535 1
a4535 1
		      else if (incl_type == (int) N_BINCL)
d4890 2
a4891 2
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
d4903 2
a4904 2
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
d5226 2
a5227 2
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5235 2
a5236 2
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5252 3
a5254 3
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
d5259 3
a5261 3
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
d5429 3
a5431 3
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
d5513 3
a5515 3
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
d5529 1
a5529 1
	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
d5558 3
a5560 3
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
d5676 1
a5676 1
	r_pcrel = (int) howto->pc_relative;
@


1.35.6.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d134 2
a135 3
static bfd_boolean aout_get_external_symbols
  PARAMS ((bfd *));
static bfd_boolean translate_from_native_sym_flags
d137 1
a137 1
static bfd_boolean translate_to_native_sym_flags
d139 3
a141 6
static void adjust_o_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_z_magic
  PARAMS ((bfd *, struct internal_exec *));
static void adjust_n_magic
  PARAMS ((bfd *, struct internal_exec *));
d197 26
a222 26
  HOWTO(RELOC_8,      0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_16,     0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_32,     0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_DISP8,  0,  0, 	8,  TRUE,  0, complain_overflow_signed,0,"DISP8", 	FALSE, 0,0x000000ff, FALSE),
  HOWTO(RELOC_DISP16, 0,  1, 	16, TRUE,  0, complain_overflow_signed,0,"DISP16", 	FALSE, 0,0x0000ffff, FALSE),
  HOWTO(RELOC_DISP32, 0,  2, 	32, TRUE,  0, complain_overflow_signed,0,"DISP32", 	FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_WDISP30,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"WDISP30", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_WDISP22,2,  2, 	22, TRUE,  0, complain_overflow_signed,0,"WDISP22", 	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_HI22,   10, 2, 	22, FALSE, 0, complain_overflow_bitfield,0,"HI22",	FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_22,     0,  2, 	22, FALSE, 0, complain_overflow_bitfield,0,"22",       FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_13,     0,  2, 	13, FALSE, 0, complain_overflow_bitfield,0,"13",       FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_LO10,   0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"LO10",     FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_SFA_BASE,0, 2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_BASE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_SFA_OFF13,0,2, 	32, FALSE, 0, complain_overflow_bitfield,0,"SFA_OFF13",FALSE, 0,0xffffffff, FALSE),
  HOWTO(RELOC_BASE10, 0,  2, 	10, FALSE, 0, complain_overflow_dont,0,"BASE10",   FALSE, 0,0x000003ff, FALSE),
  HOWTO(RELOC_BASE13, 0,  2,	13, FALSE, 0, complain_overflow_signed,0,"BASE13",   FALSE, 0,0x00001fff, FALSE),
  HOWTO(RELOC_BASE22, 10, 2,	22, FALSE, 0, complain_overflow_bitfield,0,"BASE22",   FALSE, 0,0x003fffff, FALSE),
  HOWTO(RELOC_PC10,   0,  2,	10, TRUE,  0, complain_overflow_dont,0,"PC10",	FALSE, 0,0x000003ff, TRUE),
  HOWTO(RELOC_PC22,   10,  2,	22, TRUE,  0, complain_overflow_signed,0,"PC22", FALSE, 0,0x003fffff, TRUE),
  HOWTO(RELOC_JMP_TBL,2,  2, 	30, TRUE,  0, complain_overflow_signed,0,"JMP_TBL", 	FALSE, 0,0x3fffffff, FALSE),
  HOWTO(RELOC_SEGOFF16,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"SEGOFF16",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_GLOB_DAT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"GLOB_DAT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_JMP_SLOT,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"JMP_SLOT",	FALSE, 0,0x00000000, FALSE),
  HOWTO(RELOC_RELATIVE,0, 2,	0,  FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",	FALSE, 0,0x00000000, FALSE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
  HOWTO(0,  0, 0,    0,  FALSE, 0, complain_overflow_dont, 0, "R_SPARC_NONE",    FALSE,0,0x00000000,TRUE),
d224 1
a224 1
  HOWTO(RELOC_SPARC_REV32,    0,  2, 	32, FALSE, 0, complain_overflow_dont,0,"R_SPARC_REV32",       FALSE, 0,0xffffffff, FALSE),
d231 11
a241 11
HOWTO ( 0,	       0,  0,  	8,  FALSE, 0, complain_overflow_bitfield,0,"8",		TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 1,	       0,  1, 	16, FALSE, 0, complain_overflow_bitfield,0,"16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 2,	       0,  2, 	32, FALSE, 0, complain_overflow_bitfield,0,"32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 3,	       0,  4, 	64, FALSE, 0, complain_overflow_bitfield,0,"64",	TRUE, 0xdeaddead,0xdeaddead, FALSE),
HOWTO ( 4,	       0,  0, 	8,  TRUE,  0, complain_overflow_signed,  0,"DISP8",	TRUE, 0x000000ff,0x000000ff, FALSE),
HOWTO ( 5,	       0,  1, 	16, TRUE,  0, complain_overflow_signed,  0,"DISP16",	TRUE, 0x0000ffff,0x0000ffff, FALSE),
HOWTO ( 6,	       0,  2, 	32, TRUE,  0, complain_overflow_signed,  0,"DISP32",	TRUE, 0xffffffff,0xffffffff, FALSE),
HOWTO ( 7,	       0,  4, 	64, TRUE,  0, complain_overflow_signed,  0,"DISP64",	TRUE, 0xfeedface,0xfeedface, FALSE),
HOWTO ( 8,	       0,  2,    0, FALSE, 0, complain_overflow_bitfield,0,"GOT_REL",	FALSE,         0,0x00000000, FALSE),
HOWTO ( 9,	       0,  1,   16, FALSE, 0, complain_overflow_bitfield,0,"BASE16",	FALSE,0xffffffff,0xffffffff, FALSE),
HOWTO (10,	       0,  2,   32, FALSE, 0, complain_overflow_bitfield,0,"BASE32",	FALSE,0xffffffff,0xffffffff, FALSE),
d247 1
a247 1
  HOWTO (16,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"JMP_TABLE", FALSE,         0,0x00000000, FALSE),
d263 1
a263 1
  HOWTO (32,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"RELATIVE",  FALSE,         0,0x00000000, FALSE),
d271 1
a271 1
  HOWTO (40,	       0,  2,	 0, FALSE, 0, complain_overflow_bitfield,0,"BASEREL",   FALSE,         0,0x00000000, FALSE),
d422 1
a422 1
bfd_boolean
d428 1
a428 1
    return FALSE;
d431 1
a431 1
    return FALSE;
d434 2
a435 2
    return FALSE;
  return TRUE;
d676 1
a676 1
	bfd_boolean aout_@@var{size}_mkobject, (bfd *abfd);
d682 1
a682 1
bfd_boolean
d693 1
a693 1
    return FALSE;
d702 1
a702 1
  return TRUE;
d728 1
a728 1
     bfd_boolean *unknown;
d733 1
a733 1
  *unknown = TRUE;
d752 1
a752 1
	case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = FALSE; break;
d822 1
a822 1
      *unknown = FALSE;
d835 1
a835 1
    *unknown = FALSE;
d845 1
a845 1
	bfd_boolean aout_@@var{size}_set_arch_mach,
d856 1
a856 1
bfd_boolean
d863 1
a863 1
    return FALSE;
d867 1
a867 1
      bfd_boolean unknown;
d871 1
a871 1
	return FALSE;
d1119 1
a1119 1
bfd_boolean
d1128 1
a1128 1
    return FALSE;
d1131 1
a1131 1
    return TRUE;
d1208 1
a1208 1
  return TRUE;
d1216 1
a1216 1
        bfd_boolean aout_@@var{size}_new_section_hook,
d1224 1
a1224 1
bfd_boolean
d1238 1
a1238 1
	  return TRUE;
d1245 1
a1245 1
	  return TRUE;
d1252 1
a1252 1
	  return TRUE;
d1257 1
a1257 1
  return TRUE;
d1260 1
a1260 1
bfd_boolean
d1274 1
a1274 1
	return FALSE;
d1280 1
a1280 1
      return FALSE;
d1286 5
a1290 11
      if (aout_section_merge_with_text_p (abfd, section))
	section->filepos = obj_textsec (abfd)->filepos +
			   (section->vma - obj_textsec (abfd)->vma);
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, section));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
d1297 1
a1297 1
	return FALSE;
d1300 1
a1300 1
  return TRUE;
d1305 1
a1305 1
static bfd_boolean
d1320 2
a1321 2
				 &obj_aout_sym_window (abfd), TRUE))
	return FALSE;
d1330 1
a1330 1
	return FALSE;
d1337 1
a1337 1
	  return FALSE;
d1356 1
a1356 1
	return FALSE;
d1361 2
a1362 2
				 &obj_aout_string_window (abfd), TRUE))
	return FALSE;
d1367 1
a1367 1
	return FALSE;
d1375 1
a1375 1
	  return FALSE;
d1388 1
a1388 1
  return TRUE;
d1396 1
a1396 1
static bfd_boolean
d1433 1
a1433 1
      return TRUE;
d1522 1
a1522 1
	      return FALSE;
d1527 1
a1527 1
	      return FALSE;
d1533 1
a1533 1
	  return FALSE;
d1646 1
a1646 1
  return TRUE;
d1651 1
a1651 1
static bfd_boolean
d1677 1
a1677 1
      return FALSE;
d1702 5
a1706 10
      if (aout_section_merge_with_text_p (abfd, sec))
	sym_pointer->e_type[0] |= N_TEXT;
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, sec));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return FALSE;
	}
d1754 1
a1754 1
  return TRUE;
d1774 1
a1774 1
bfd_boolean
d1782 1
a1782 1
     bfd_boolean dynamic;
d1804 1
a1804 1
	return FALSE;
d1813 1
a1813 1
	return FALSE;
d1819 1
a1819 1
  return TRUE;
d1826 1
a1826 1
bfd_boolean
d1836 1
a1836 1
    return TRUE;
d1841 1
a1841 1
    return FALSE;
d1847 1
a1847 1
    return FALSE;
d1856 1
a1856 1
	  FALSE)))
d1859 1
a1859 1
      return FALSE;
d1881 1
a1881 1
  return TRUE;
d1894 2
a1895 3
  PARAMS ((bfd *, struct bfd_strtab_hash *, const char *, bfd_boolean));
static bfd_boolean emit_stringtab
  PARAMS ((bfd *, struct bfd_strtab_hash *));
d1905 1
a1905 1
     bfd_boolean copy;
d1907 1
a1907 1
  bfd_boolean hash;
d1916 1
a1916 1
  hash = TRUE;
d1918 1
a1918 1
    hash = FALSE;
d1935 1
a1935 1
static bfd_boolean
d1946 1
a1946 1
    return FALSE;
d1951 1
a1951 1
bfd_boolean
d1961 1
a1961 1
    return FALSE;
d1970 1
a1970 1
      indx = add_to_stringtab (abfd, strtab, g->name, FALSE);
d2005 1
a2005 1
  return TRUE;
d2009 1
a2009 1
  return FALSE;
d2373 1
a2373 1
bfd_boolean
d2389 1
a2389 1
    return TRUE;
d2392 1
a2392 1
    return TRUE;
d2403 1
a2403 1
      return FALSE;
d2407 1
a2407 1
    return FALSE;
d2416 1
a2416 1
    return FALSE;
d2422 1
a2422 1
      return FALSE;
d2429 1
a2429 1
      return FALSE;
d2455 1
a2455 1
  return TRUE;
d2460 1
a2460 1
bfd_boolean
d2473 1
a2473 1
    return TRUE;
d2479 1
a2479 1
    return FALSE;
d2503 1
a2503 1
      return FALSE;
d2507 1
a2507 1
  return TRUE;
d2684 1
a2684 1
     bfd_boolean dynamic;
d2720 1
a2720 1
     bfd_boolean dynamic;
d2738 1
a2738 1
	  FALSE)))
d2748 1
a2748 1
bfd_boolean
d2907 1
a2907 1
	return FALSE;
d2944 1
a2944 1
  return TRUE;
d2950 1
a2950 1
     bfd_boolean execable ATTRIBUTE_UNUSED;
d2958 1
a2958 1
bfd_boolean
d2966 1
a2966 1
    return TRUE;
d2983 1
a2983 1
  return TRUE;
d2988 1
a2988 1
static bfd_boolean aout_link_add_object_symbols
d2990 6
a2995 7
static bfd_boolean aout_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean aout_link_free_symbols
  PARAMS ((bfd *));
static bfd_boolean aout_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *pneeded));
static bfd_boolean aout_link_add_symbols
d3023 1
a3023 1
      ret->written = FALSE;
d3032 1
a3032 1
bfd_boolean
d3036 3
a3038 3
     struct bfd_hash_entry *(*newfunc)
       PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
		const char *));
d3067 1
a3067 1
bfd_boolean
d3081 1
a3081 1
      return FALSE;
d3087 1
a3087 1
static bfd_boolean
d3093 1
a3093 1
    return FALSE;
d3095 1
a3095 1
    return FALSE;
d3099 1
a3099 1
	return FALSE;
d3101 1
a3101 1
  return TRUE;
d3109 1
a3109 1
static bfd_boolean
d3113 1
a3113 1
     bfd_boolean *pneeded;
d3116 1
a3116 1
    return FALSE;
d3119 1
a3119 1
    return FALSE;
d3124 1
a3124 1
	return FALSE;
d3130 1
a3130 1
	return FALSE;
d3133 1
a3133 1
  return TRUE;
d3138 1
a3138 1
static bfd_boolean
d3160 1
a3160 1
  return TRUE;
d3170 1
a3170 1
static bfd_boolean
d3174 1
a3174 1
     bfd_boolean *pneeded;
d3180 1
a3180 1
  *pneeded = FALSE;
d3210 1
a3210 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d3269 3
a3271 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d3298 3
a3300 3
			return FALSE;
		      *pneeded = TRUE;
		      return TRUE;
d3309 1
a3309 1
		    return FALSE;
d3346 3
a3348 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d3354 1
a3354 1
  return TRUE;
d3359 1
a3359 1
static bfd_boolean
d3364 5
a3368 4
  bfd_boolean (*add_one_symbol)
    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, asection *,
	     bfd_vma, const char *, bfd_boolean, bfd_boolean,
	     struct bfd_link_hash_entry **));
d3372 1
a3372 1
  bfd_boolean copy;
d3382 1
a3382 1
    copy = FALSE;
d3384 1
a3384 1
    copy = TRUE;
d3390 1
a3390 1
	return FALSE;
d3400 1
a3400 1
    return FALSE;
d3546 1
a3546 1
	     (info, abfd, name, flags, section, value, string, copy, FALSE,
d3548 1
a3548 1
	return FALSE;
d3574 1
a3574 1
  return TRUE;
d3637 1
a3637 1
static bfd_boolean aout_link_input_bfd
d3639 1
a3639 1
static bfd_boolean aout_link_write_symbols
d3641 1
a3641 1
static bfd_boolean aout_link_write_other_symbol
d3643 1
a3643 1
static bfd_boolean aout_link_input_section
d3647 1
a3647 1
static bfd_boolean aout_link_input_section_std
d3651 1
a3651 1
static bfd_boolean aout_link_input_section_ext
d3657 1
a3657 1
static bfd_boolean aout_link_reloc_link_order
d3700 1
a3700 1
bfd_boolean
d3707 1
a3707 1
  bfd_boolean includes_hash_initialized = FALSE;
d3717 1
a3717 1
  bfd_boolean have_link_order_relocs;
d3733 1
a3733 1
  includes_hash_initialized = TRUE;
d3856 1
a3856 1
			       FALSE, FALSE, FALSE);
d3883 1
a3883 1
    sub->output_has_begun = FALSE;
d3894 1
a3894 1
	    p->u.indirect.section->linker_mark = TRUE;
d3898 1
a3898 1
  have_link_order_relocs = FALSE;
d3916 1
a3916 1
		  input_bfd->output_has_begun = TRUE;
d3923 1
a3923 1
	      have_link_order_relocs = TRUE;
d3983 1
a3983 1
      includes_hash_initialized = FALSE;
d4022 1
a4022 1
  return TRUE;
d4035 1
a4035 1
  return FALSE;
d4040 1
a4040 1
static bfd_boolean
d4058 1
a4058 1
     finfo->info->keep_memory is FALSE.  */
d4060 1
a4060 1
    return FALSE;
d4067 1
a4067 1
    return FALSE;
d4079 1
a4079 1
	return FALSE;
d4087 1
a4087 1
	return FALSE;
d4096 1
a4096 1
	return FALSE;
d4099 1
a4099 1
  return TRUE;
d4105 1
a4105 1
static bfd_boolean
d4121 2
a4122 2
  bfd_boolean pass;
  bfd_boolean skip_next;
d4136 1
a4136 1
			      FALSE, FALSE) != NULL)
d4143 1
a4143 1
				       input_bfd->filename, FALSE);
d4145 1
a4145 1
	return FALSE;
d4156 2
a4157 2
  pass = FALSE;
  skip_next = FALSE;
d4168 1
a4168 1
      bfd_boolean skip;
d4171 1
a4171 1
      bfd_boolean copy;
d4195 1
a4195 1
	  pass = FALSE;
d4202 1
a4202 1
	  skip_next = FALSE;
d4244 1
a4244 1
		skip_next = TRUE;
d4250 1
a4250 1
	  skip = FALSE;
d4257 1
a4257 1
		skip = TRUE;
d4260 1
a4260 1
	      if (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE, FALSE)
d4262 1
a4262 1
		skip = TRUE;
d4265 1
a4265 1
	      skip = TRUE;
d4271 1
a4271 1
		h->written = TRUE;
d4300 1
a4300 1
	      pass = TRUE;
d4316 1
a4316 1
		skip_next = TRUE;
d4408 1
a4408 1
	      h->written = TRUE;
d4424 1
a4424 1
		    skip = TRUE;
d4427 1
a4427 1
		  skip = TRUE;
d4432 1
a4432 1
		  pass = FALSE;
d4488 1
a4488 1
	      copy = (bfd_boolean) (! finfo->info->keep_memory);
d4490 1
a4490 1
						      name, TRUE, copy);
d4492 1
a4492 1
		return FALSE;
d4504 1
a4504 1
		    return FALSE;
d4549 1
a4549 1
      copy = FALSE;
d4558 1
a4558 1
	    copy = TRUE;
d4563 1
a4563 1
	return FALSE;
d4577 1
a4577 1
	return FALSE;
d4582 1
a4582 1
	return FALSE;
d4586 1
a4586 1
  return TRUE;
d4592 1
a4592 1
static bfd_boolean
d4609 1
a4609 1
	return TRUE;
d4625 1
a4625 1
    return TRUE;
d4627 1
a4627 1
  h->written = TRUE;
d4634 2
a4635 2
				  FALSE, FALSE) == NULL)))
    return TRUE;
d4643 1
a4643 1
      return TRUE;
d4647 1
a4647 1
      return TRUE;
d4684 1
a4684 1
      return TRUE;
d4691 1
a4691 1
			   FALSE);
d4712 1
a4712 1
  return TRUE;
d4717 1
a4717 1
static bfd_boolean
d4734 1
a4734 1
    return FALSE;
d4747 1
a4747 1
	    return FALSE;
d4757 1
a4757 1
	return FALSE;
d4764 1
a4764 1
	return FALSE;
d4773 1
a4773 1
    return FALSE;
d4780 1
a4780 1
	return FALSE;
d4782 1
a4782 1
	return FALSE;
d4794 1
a4794 1
  return TRUE;
d4824 1
a4824 1
static bfd_boolean
d4834 5
a4838 4
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
d4840 1
a4840 1
  bfd_boolean relocateable;
d4982 1
a4982 1
			      h->written = FALSE;
d4985 1
a4985 1
				return FALSE;
d4998 1
a4998 1
			    return FALSE;
d5058 1
a5058 1
	  bfd_boolean hundef;
d5062 1
a5062 1
	  hundef = FALSE;
d5081 1
a5081 1
		  hundef = TRUE;
d5099 1
a5099 1
	      bfd_boolean skip;
d5104 1
a5104 1
		return FALSE;
d5122 2
a5123 2
		     r_addr, TRUE)))
		return FALSE;
d5158 1
a5158 1
		  return FALSE;
d5165 1
a5165 1
  return TRUE;
d5170 1
a5170 1
static bfd_boolean
d5180 5
a5184 4
  bfd_boolean (*check_dynamic_reloc)
    PARAMS ((struct bfd_link_info *, bfd *, asection *,
	     struct aout_link_hash_entry *, PTR, bfd_byte *, bfd_boolean *,
	     bfd_vma *));
d5186 1
a5186 1
  bfd_boolean relocateable;
d5320 1
a5320 1
			      h->written = FALSE;
d5323 1
a5323 1
				return FALSE;
d5336 1
a5336 1
			    return FALSE;
d5401 1
a5401 1
	  bfd_boolean hundef;
d5406 1
a5406 1
	  hundef = FALSE;
d5425 1
a5425 1
		  hundef = TRUE;
d5498 1
a5498 1
	      bfd_boolean skip;
d5503 1
a5503 1
		return FALSE;
d5525 2
a5526 2
		     r_addr, TRUE)))
		return FALSE;
d5573 1
a5573 1
		      return FALSE;
d5581 1
a5581 1
  return TRUE;
d5586 1
a5586 1
static bfd_boolean
d5623 1
a5623 1
					 pr->u.name, FALSE, FALSE, TRUE));
d5634 1
a5634 1
	  h->written = FALSE;
d5636 1
a5636 1
	    return FALSE;
d5644 1
a5644 1
	    return FALSE;
d5653 1
a5653 1
      return FALSE;
d5723 1
a5723 1
	  bfd_boolean ok;
d5728 1
a5728 1
	    return FALSE;
d5749 1
a5749 1
		  return FALSE;
d5757 1
a5757 1
	    return FALSE;
d5796 1
a5796 1
    return FALSE;
d5807 1
a5807 1
  return TRUE;
@


1.35.6.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a802 1
	case bfd_mach_mipsisa32r2:
@


1.35.6.4
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d108 3
a110 1
	configuration is selected.  */
d160 1
a160 1
	addend.  */
d162 1
d233 1
a233 2
reloc_howto_type howto_table_std[] =
{
d3070 1
a3070 1
  ret = (struct aout_link_hash_table *) bfd_malloc (amt);
a3072 1

d3909 4
a3912 2
	if (p->type == bfd_indirect_link_order)
	  p->u.indirect.section->linker_mark = TRUE;
@


1.35.6.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3752 1
a3752 1
     relocatable output, count the relocs.  */
d3762 1
a3762 1
      if (info->relocatable)
d3776 1
a3776 1
		(_("%s: relocatable link from %s to %s not supported"),
d3806 1
a3806 1
  if (info->relocatable)
d4789 1
a4789 1
  /* If we are producing relocatable output, the relocs were
d4791 1
a4791 1
  if (finfo->info->relocatable && rel_size > 0)
d4853 1
a4853 1
  bfd_boolean relocatable;
d4869 1
a4869 1
  relocatable = finfo->info->relocatable;
d4938 1
a4938 1
      if (relocatable)
d4940 1
a4940 1
	  /* We are generating a relocatable output file, and must
d5198 1
a5198 1
  bfd_boolean relocatable;
d5214 1
a5214 1
  relocatable = finfo->info->relocatable;
d5259 1
a5259 1
      if (relocatable)
d5261 1
a5261 1
	  /* We are generating a relocatable output file, and must
@


1.35.6.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a803 1
	case bfd_mach_mipsisa64r2:
d1267 1
a1267 1
     const PTR location;
d2028 1
a2028 1
NAME(aout,canonicalize_symtab) (abfd, location)
@


1.35.6.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d3257 1
a3257 1
             dependant for backward compatibility.
@


1.34
log
@	* aoutx.h (NAME(aout,reloc_type_lookup)): Handle BFD_RELOC_8.
@
text
@d760 3
a762 1
      if (machine == 0)
@


1.33
log
@	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.
@
text
@d321 1
@


1.32
log
@Add new field to bfd_link structure and use it to control how common symbols
are extracted from archives.
@
text
@d4214 2
a4215 1
	  if (h != NULL)
a4236 1
	      && h->root.type != bfd_link_hash_warning
@


1.31
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d196 1
a196 1
  /* type           rs   size bsz  pcrel bitpos ovrf                  sf name          part_inpl readmask setmask pcdone */
d230 1
a230 1
  /* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
d284 1
d295 1
d318 1
a318 1
    /* std relocs */
d479 2
a480 1
  *(abfd->tdata.aout_data->a.hdr) = *execp;	/* Copy in the internal_exec struct */
d483 1
a483 1
  /* Set the file flags */
d487 1
a487 1
  /* Setting of EXEC_P has been deferred to the bottom of this function */
d569 1
a569 1
  /* data and bss are already filled in since they're so standard */
d571 1
a571 1
  /* The virtual memory addresses of the sections */
d576 1
a576 1
  /* The file offsets of the sections */
d580 1
a580 1
  /* The file offsets of the relocation info */
d871 1
a871 1
  /* Determine the size of a relocation entry */
d909 1
a909 1
#if 0	    /* ?? Does alignment in the file image really matter? */
d1226 1
a1226 1
  /* align to double at least */
d1230 7
a1236 7
  {
    if (obj_textsec (abfd) == NULL && !strcmp (newsect->name, ".text"))
      {
	obj_textsec (abfd)= newsect;
	newsect->target_index = N_TEXT;
	return true;
      }
d1238 6
a1243 6
    if (obj_datasec (abfd) == NULL && !strcmp (newsect->name, ".data"))
      {
	obj_datasec (abfd) = newsect;
	newsect->target_index = N_DATA;
	return true;
      }
d1245 7
a1251 6
    if (obj_bsssec (abfd) == NULL && !strcmp (newsect->name, ".bss"))
      {
	obj_bsssec (abfd) = newsect;
	newsect->target_index = N_BSS;
	return true;
      }
d1253 1
a1253 3
  }

  /* We allow more than three sections internally */
a1405 1

d1706 1
a1706 1
  /* Turn the symbol from section relative to absolute again */
d1722 1
d1831 1
a1831 1
  /* If there's no work to be done, don't do any */
d2028 1
a2028 1
/* Standard reloc stuff */
d2050 2
a2051 2
  r_length = g->howto->size ;	/* Size as a power of two */
  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC? */
d2062 1
a2062 1
  /* name was clobbered by aout_write_syms to be symbol index */
d2069 1
a2069 2
     check for that here
     */
d2076 6
a2081 6
      {
	/* Whoops, looked like an abs symbol, but is really an offset
	   from the abs section */
	r_index = N_ABS;
	r_extern = 0;
       }
d2083 5
a2087 6
      {
	/* Fill in symbol */
	r_extern = 1;
	r_index = (*(g->sym_ptr_ptr))->KEEPIT;

      }
d2091 1
a2091 1
      /* Just an ordinary section */
d2096 1
a2096 1
  /* now the fun stuff */
d2123 1
a2123 1
/* Extended stuff */
a2155 1

d2172 1
a2172 1
      /* Just an ordinary section */
d2177 1
a2177 1
  /* now the fun stuff */
d2258 1
a2258 1
  /* now the fun stuff */
d2317 1
a2317 1
  /* now the fun stuff */
d2507 2
a2508 1
/* This is stupid.  This function should be a boolean predicate */
d2561 1
d2563 1
a2563 3
    {
      return (sizeof (arelent *) * (asect->reloc_count+1));
    }
d2741 3
a2743 5
/*
 provided a BFD, a section and an offset into the section, calculate
 and return the name of the source file and the line nearest to the
 wanted location.
*/
d2756 1
a2756 1
  /* Run down the file looking for the filename, function and linenumber */
d2772 1
d2860 1
a2860 1
		/* We'll keep this if it is nearer than the one we have already */
d2862 5
a2866 4
		    q->symbol.value <= offset) {
		  low_func_vma = q->symbol.value;
		  func = (asymbol *)q;
		}
d2888 1
d2896 1
d2934 1
a2934 1
      /* Have to remove : stuff */
d3228 4
a3231 3
	     definition of the symbol is undefined or common.  If the
	     current definition is common, we have a case in which we
	     have already seen an object file including
d3233 1
a3233 1
	     and this object file from the archive includes
d3235 2
a3236 1
	     In such a case we must include this object file.
d3241 24
a3264 2
	     seems a bit crazy to me, and I haven't implemented it.
	     However, it might be correct.  */
@


1.30
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d536 1
a536 1
    return NULL;
d658 1
d660 5
a664 6
  else
    {
      free (rawptr);
      abfd->tdata.aout_data = oldrawptr;
    }
  return result;
@


1.30.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d536 1
a536 1
    goto error_ret;
a657 1
      return result;
d659 6
a664 5

 error_ret:
  bfd_release (abfd, rawptr);
  abfd->tdata.aout_data = oldrawptr;
  return NULL;
d4189 1
a4189 2
	  if (h != NULL
	      && h->root.type != bfd_link_hash_warning)
d4211 1
@


1.30.2.2
log
@Merge from mainline.
@
text
@d2262 2
a2263 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2271 2
a2272 2
      r_index =  (((unsigned int) bytes->r_index[2] << 16)
		  | ((unsigned int) bytes->r_index[1] << 8)
d2284 3
a2286 3
  if (r_type == (unsigned int) RELOC_BASE10
      || r_type == (unsigned int) RELOC_BASE13
      || r_type == (unsigned int) RELOC_BASE22)
d2321 2
a2322 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2334 2
a2335 2
      r_index = (((unsigned int) bytes->r_index[2] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d3866 1
a3866 1
	    p->u.indirect.section->linker_mark = (unsigned int) true;
d4415 1
a4415 1
	  if (type == (int) N_BINCL)
d4429 1
a4429 1
		  if (incl_type == (int) N_EINCL)
d4435 1
a4435 1
		  else if (incl_type == (int) N_BINCL)
d4460 1
a4460 1
	      copy = (boolean) (! finfo->info->keep_memory);
d4488 1
a4488 1
		  type = (int) N_EXCL;
d4498 1
a4498 1
		      if (incl_type == (int) N_EINCL)
d4507 1
a4507 1
		      else if (incl_type == (int) N_BINCL)
d4862 2
a4863 2
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
d4875 2
a4876 2
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
d5198 2
a5199 2
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5207 2
a5208 2
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5224 3
a5226 3
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
d5231 3
a5233 3
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
d5401 3
a5403 3
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
d5485 3
a5487 3
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
d5501 1
a5501 1
	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
d5530 3
a5532 3
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
d5648 1
a5648 1
	r_pcrel = (int) howto->pc_relative;
@


1.30.2.3
log
@Merge fixes from trunk.
@
text
@d1281 5
a1285 11
      if (aout_section_merge_with_text_p (abfd, section))
	section->filepos = obj_textsec (abfd)->filepos +
			   (section->vma - obj_textsec (abfd)->vma);
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, section));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return false;
	}
d1698 5
a1702 10
      if (aout_section_merge_with_text_p (abfd, sec))
	sym_pointer->e_type[0] |= N_TEXT;
      else
	{
          (*_bfd_error_handler)
	   (_("%s: can not represent section `%s' in a.out object file format"),
	     bfd_get_filename (abfd), bfd_get_section_name (abfd, sec));
          bfd_set_error (bfd_error_nonrepresentable_section);
          return false;
	}
@


1.29
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d1313 3
a1315 3
      if (bfd_get_file_window (abfd,
			       obj_sym_filepos (abfd), exec_hdr (abfd)->a_syms,
			       &obj_aout_sym_window (abfd), true) == false)
d1355 2
a1356 2
      if (bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
			       &obj_aout_string_window (abfd), true) == false)
@


1.28
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d1840 1
a1840 1
  cached = (aout_symbol_type *) bfd_malloc (cached_size);
a1842 2
  if (cached_size != 0)
    memset (cached, 0, (size_t) cached_size);
d2412 1
a2412 1
  reloc_cache = (arelent *) bfd_malloc (amt);
a2414 1
  memset (reloc_cache, 0, (size_t) amt);
@


1.28.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1840 1
a1840 1
  cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
d1843 2
d2414 1
a2414 1
  reloc_cache = (arelent *) bfd_zmalloc (amt);
d2417 1
@


1.28.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1313 3
a1315 3
      if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd),
				 exec_hdr (abfd)->a_syms,
				 &obj_aout_sym_window (abfd), true))
d1355 2
a1356 2
      if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,
				 &obj_aout_string_window (abfd), true))
@


1.28.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d7 1
a7 1
   This file is part of BFD, the Binary File Descriptor library.
d9 13
a21 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d196 1
a196 1
  /* type           rs   size bsz  pcrel bitpos ovrf                  sf name          part_inpl readmask setmask pcdone.  */
d230 1
a230 1
  /* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone.  */
a283 1

a293 1

d316 1
a316 1
    /* std relocs.  */
d477 1
a477 2
  /* Copy in the internal_exec struct.  */
  *(abfd->tdata.aout_data->a.hdr) = *execp;
d480 1
a480 1
  /* Set the file flags.  */
d484 1
a484 1
  /* Setting of EXEC_P has been deferred to the bottom of this function.  */
d536 1
a536 1
    goto error_ret;
d566 1
a566 1
  /* Data and bss are already filled in since they're so standard.  */
d568 1
a568 1
  /* The virtual memory addresses of the sections.  */
d573 1
a573 1
  /* The file offsets of the sections.  */
d577 1
a577 1
  /* The file offsets of the relocation info.  */
a657 1
      return result;
d659 6
a664 5

 error_ret:
  bfd_release (abfd, rawptr);
  abfd->tdata.aout_data = oldrawptr;
  return NULL;
d868 1
a868 1
  /* Determine the size of a relocation entry.  */
d906 1
a906 1
#if 0	    /* ?? Does alignment in the file image really matter?  */
d1223 1
a1223 1
  /* Align to double at least.  */
d1227 14
a1240 7
    {
      if (obj_textsec (abfd) == NULL && !strcmp (newsect->name, ".text"))
	{
	  obj_textsec (abfd)= newsect;
	  newsect->target_index = N_TEXT;
	  return true;
	}
d1242 6
a1247 6
      if (obj_datasec (abfd) == NULL && !strcmp (newsect->name, ".data"))
	{
	  obj_datasec (abfd) = newsect;
	  newsect->target_index = N_DATA;
	  return true;
	}
d1249 1
a1249 7
      if (obj_bsssec (abfd) == NULL && !strcmp (newsect->name, ".bss"))
	{
	  obj_bsssec (abfd) = newsect;
	  newsect->target_index = N_BSS;
	  return true;
	}
    }
d1251 1
a1251 1
  /* We allow more than three sections internally.  */
d1404 1
d1705 1
a1705 1
  /* Turn the symbol from section relative to absolute again.  */
a1720 1

d1829 1
a1829 1
  /* If there's no work to be done, don't do any.  */
d2026 1
a2026 1
/* Standard reloc stuff.  */
d2048 2
a2049 2
  r_length = g->howto->size ;	/* Size as a power of two.  */
  r_pcrel  = (int) g->howto->pc_relative; /* Relative to PC?  */
d2060 1
a2060 1
  /* Name was clobbered by aout_write_syms to be symbol index.  */
d2067 2
a2068 1
     check for that here.  */
d2075 6
a2080 6
	{
	  /* Whoops, looked like an abs symbol, but is
	     really an offset from the abs section.  */
	  r_index = N_ABS;
	  r_extern = 0;
	}
d2082 6
a2087 5
	{
	  /* Fill in symbol.  */
	  r_extern = 1;
	  r_index = (*(g->sym_ptr_ptr))->KEEPIT;
	}
d2091 1
a2091 1
      /* Just an ordinary section.  */
d2096 1
a2096 1
  /* Now the fun stuff.  */
d2123 1
a2123 1
/* Extended stuff.  */
d2156 1
d2173 1
a2173 1
      /* Just an ordinary section.  */
d2178 1
a2178 1
  /* Now the fun stuff.  */
d2259 1
a2259 1
  /* Now the fun stuff.  */
d2318 1
a2318 1
  /* Now the fun stuff.  */
d2508 1
a2508 2
/* This is stupid.  This function should be a boolean predicate.  */

a2560 1

d2562 3
a2564 1
    return (sizeof (arelent *) * (asect->reloc_count+1));
d2742 5
a2746 3
/* Provided a BFD, a section and an offset into the section, calculate
   and return the name of the source file and the line nearest to the
   wanted location.  */
d2759 1
a2759 1
  /* Run down the file looking for the filename, function and linenumber.  */
a2774 1

d2862 1
a2862 1
		/* We'll keep this if it is nearer than the one we have already.  */
d2864 4
a2867 5
		    q->symbol.value <= offset)
		  {
		    low_func_vma = q->symbol.value;
		    func = (asymbol *)q;
		  }
a2888 1

a2895 1

d2933 1
a2933 1
      /* Have to remove : stuff.  */
d3227 3
a3229 4
	     definition of the symbol is undefined or common.

             If the current definition is common, we have a case in
	     which we have already seen an object file including:
d3231 1
a3231 1
	     and this object file from the archive includes:
d3233 1
a3233 2
	     In such a case, whether to include this object is target
             dependant for backward compatability.
d3238 2
a3239 24
	     seems a bit crazy to me, and it has not been implemented
	     yet.  However, it might be correct.  */
	  if (h->type == bfd_link_hash_common)
	    {
	      int skip = 0;

	      switch (info->common_skip_ar_aymbols)
		{
		case bfd_link_common_skip_text:
		  skip = (type == (N_TEXT | N_EXT));
		  break;
		case bfd_link_common_skip_data:
		  skip = (type == (N_DATA | N_EXT));
		  break;
		default:
		case bfd_link_common_skip_all:
		  skip = 1;
		  break;
		}

	      if (skip)
		continue;
	    }

d4189 1
a4189 2
	  if (h != NULL
	      && h->root.type != bfd_link_hash_warning)
d4211 1
@


1.28.6.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a320 1
	STD (BFD_RELOC_8, 0);
@


1.28.6.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d760 1
a760 3
      if (machine == 0
	  || machine == bfd_mach_i386_i386
	  || machine == bfd_mach_i386_i386_intel_syntax)
@


1.28.6.6
log
@merge from mainline
@
text
@d2264 2
a2265 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2273 2
a2274 2
      r_index =  (((unsigned int) bytes->r_index[2] << 16)
		  | ((unsigned int) bytes->r_index[1] << 8)
d2286 3
a2288 3
  if (r_type == (unsigned int) RELOC_BASE10
      || r_type == (unsigned int) RELOC_BASE13
      || r_type == (unsigned int) RELOC_BASE22)
d2323 2
a2324 2
      r_index = (((unsigned int) bytes->r_index[0] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d2336 2
a2337 2
      r_index = (((unsigned int) bytes->r_index[2] << 16)
		 | ((unsigned int) bytes->r_index[1] << 8)
d3894 1
a3894 1
	    p->u.indirect.section->linker_mark = (unsigned int) true;
d4443 1
a4443 1
	  if (type == (int) N_BINCL)
d4457 1
a4457 1
		  if (incl_type == (int) N_EINCL)
d4463 1
a4463 1
		  else if (incl_type == (int) N_BINCL)
d4488 1
a4488 1
	      copy = (boolean) (! finfo->info->keep_memory);
d4516 1
a4516 1
		  type = (int) N_EXCL;
d4526 1
a4526 1
		      if (incl_type == (int) N_EINCL)
d4535 1
a4535 1
		      else if (incl_type == (int) N_BINCL)
d4890 2
a4891 2
	    r_index   =  (((unsigned int) rel->r_index[0] << 16)
			  | ((unsigned int) rel->r_index[1] << 8)
d4903 2
a4904 2
	    r_index   = (((unsigned int) rel->r_index[2] << 16)
			 | ((unsigned int) rel->r_index[1] << 8)
d5226 2
a5227 2
	  r_index  = (((unsigned int) rel->r_index[0] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5235 2
a5236 2
	  r_index  = (((unsigned int) rel->r_index[2] << 16)
		      | ((unsigned int) rel->r_index[1] << 8)
d5252 3
a5254 3
	      || r_type == (unsigned int) RELOC_BASE10
	      || r_type == (unsigned int) RELOC_BASE13
	      || r_type == (unsigned int) RELOC_BASE22)
d5259 3
a5261 3
	      if (r_type == (unsigned int) RELOC_BASE10
		  || r_type == (unsigned int) RELOC_BASE13
		  || r_type == (unsigned int) RELOC_BASE22)
d5429 3
a5431 3
	  else if (r_type == (unsigned int) RELOC_BASE10
		   || r_type == (unsigned int) RELOC_BASE13
		   || r_type == (unsigned int) RELOC_BASE22)
d5513 3
a5515 3
	      && r_type != (unsigned int) RELOC_BASE10
	      && r_type != (unsigned int) RELOC_BASE13
	      && r_type != (unsigned int) RELOC_BASE22)
d5529 1
a5529 1
	  if (r_type != (unsigned int) RELOC_SPARC_REV32)
d5558 3
a5560 3
			     || r_type == (unsigned int) RELOC_BASE10
			     || r_type == (unsigned int) RELOC_BASE13
			     || r_type == (unsigned int) RELOC_BASE22)
d5676 1
a5676 1
	r_pcrel = (int) howto->pc_relative;
@


1.28.4.1
log
@merge from trunk
@
text
@d1840 1
a1840 1
  cached = (aout_symbol_type *) bfd_zmalloc (cached_size);
d1843 2
d2414 1
a2414 1
  reloc_cache = (arelent *) bfd_zmalloc (amt);
d2417 1
@


1.27
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d3 1
a3 1
   2001
d4580 7
d4615 1
d4657 2
a4658 3
    case bfd_link_hash_warning:
      /* FIXME: Ignore these for now.  The circumstances under which
	 they should be written out are not clear to me.  */
@


1.27.2.1
log
@Merge from mainline.
@
text
@d3 1
a3 1
   2001, 2002
a4579 7
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct aout_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return true;
    }

a4607 1
    case bfd_link_hash_warning:
d4649 3
a4651 2
      /* We ignore these symbols, since the indirected symbol is
	 already in the hash table.  */
@


1.26
log
@	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	* aoutx.h: Formatting fixes.
	* merge.c (_bfd_merged_section_offset): Break line at 80 chars.

	* linker.c: Replace bfd_get_filename with bfd_archive_filename
	in error message.
@
text
@d933 1
a933 1
      /* The VMA of the .bss section is set by the the VMA of the
@


1.25
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d142 2
a143 1
reloc_howto_type * NAME(aout,reloc_type_lookup) PARAMS ((bfd *, bfd_reloc_code_real_type));
d161 4
a164 3
#define CTOR_TABLE_RELOC_HOWTO(BFD) ((obj_reloc_entry_size(BFD) == RELOC_EXT_SIZE \
	     ? howto_table_ext : howto_table_std) \
	    + CTOR_TABLE_RELOC_IDX)
d231 11
a241 11
HOWTO( 0,	       0,  0,  	8,  false, 0, complain_overflow_bitfield,0,"8",		true, 0x000000ff,0x000000ff, false),
HOWTO( 1,	       0,  1, 	16, false, 0, complain_overflow_bitfield,0,"16",	true, 0x0000ffff,0x0000ffff, false),
HOWTO( 2,	       0,  2, 	32, false, 0, complain_overflow_bitfield,0,"32",	true, 0xffffffff,0xffffffff, false),
HOWTO( 3,	       0,  4, 	64, false, 0, complain_overflow_bitfield,0,"64",	true, 0xdeaddead,0xdeaddead, false),
HOWTO( 4,	       0,  0, 	8,  true,  0, complain_overflow_signed,  0,"DISP8",	true, 0x000000ff,0x000000ff, false),
HOWTO( 5,	       0,  1, 	16, true,  0, complain_overflow_signed,  0,"DISP16",	true, 0x0000ffff,0x0000ffff, false),
HOWTO( 6,	       0,  2, 	32, true,  0, complain_overflow_signed,  0,"DISP32",	true, 0xffffffff,0xffffffff, false),
HOWTO( 7,	       0,  4, 	64, true,  0, complain_overflow_signed,  0,"DISP64",	true, 0xfeedface,0xfeedface, false),
HOWTO( 8,	       0,  2,    0, false, 0, complain_overflow_bitfield,0,"GOT_REL",	false,         0,0x00000000, false),
HOWTO( 9,	       0,  1,   16, false, 0, complain_overflow_bitfield,0,"BASE16",	false,0xffffffff,0xffffffff, false),
HOWTO(10,	       0,  2,   32, false, 0, complain_overflow_bitfield,0,"BASE32",	false,0xffffffff,0xffffffff, false),
d247 1
a247 1
  HOWTO(16,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"JMP_TABLE", false,         0,0x00000000, false),
d263 1
a263 1
  HOWTO(32,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"RELATIVE",  false,         0,0x00000000, false),
d271 1
a271 1
  HOWTO(40,	       0,  2,	 0, false, 0, complain_overflow_bitfield,0,"BASEREL",   false,         0,0x00000000, false),
d274 1
a274 1
#define TABLE_SIZE(TABLE)	(sizeof (TABLE)/sizeof (TABLE[0]))
d281 2
a282 2
#define EXT(i,j)	case i: return &howto_table_ext[j]
#define STD(i,j)	case i: return &howto_table_std[j]
d487 1
a487 1
  if (N_DYNAMIC(*execp))
d564 2
a565 2
  obj_textsec (abfd)->size = N_TXTSIZE(*execp);
  obj_textsec (abfd)->raw_size = N_TXTSIZE(*execp);
d569 3
a571 3
  obj_textsec (abfd)->vma = N_TXTADDR(*execp);
  obj_datasec (abfd)->vma = N_DATADDR(*execp);
  obj_bsssec  (abfd)->vma = N_BSSADDR(*execp);
d574 2
a575 2
  obj_textsec (abfd)->filepos = N_TXTOFF(*execp);
  obj_datasec (abfd)->filepos = N_DATOFF(*execp);
d578 2
a579 2
  obj_textsec (abfd)->rel_filepos = N_TRELOFF(*execp);
  obj_datasec (abfd)->rel_filepos = N_DRELOFF(*execp);
d586 6
a591 5
  switch (N_MACHTYPE (*exec_hdr (abfd))) {
  default:
    abfd->obj_arch = bfd_arch_obscure;
    break;
  }
d593 3
a595 3
  adata(abfd)->page_size = TARGET_PAGE_SIZE;
  adata(abfd)->segment_size = SEGMENT_SIZE;
  adata(abfd)->exec_bytes_size = EXEC_BYTES_SIZE;
d627 3
a629 2
      || (execp->a_entry >= obj_textsec(abfd)->vma
	  && execp->a_entry < obj_textsec(abfd)->vma + obj_textsec(abfd)->_raw_size))
d645 1
a645 1
	  && (fstat(fileno((FILE *) (abfd->iostream)), &stat_buf) == 0)
d731 27
a757 40
  switch (arch) {
  case bfd_arch_sparc:
    if (machine == 0
	|| machine == bfd_mach_sparc
	|| machine == bfd_mach_sparc_sparclite
	|| machine == bfd_mach_sparc_sparclite_le
	|| machine == bfd_mach_sparc_v9)
      arch_flags = M_SPARC;
    else if (machine == bfd_mach_sparc_sparclet)
      arch_flags = M_SPARCLET;
    break;

  case bfd_arch_m68k:
    switch (machine) {
    case 0:		  arch_flags = M_68010; break;
    case bfd_mach_m68000: arch_flags = M_UNKNOWN; *unknown = false; break;
    case bfd_mach_m68010: arch_flags = M_68010; break;
    case bfd_mach_m68020: arch_flags = M_68020; break;
    default:		  arch_flags = M_UNKNOWN; break;
    }
    break;

  case bfd_arch_i386:
    if (machine == 0)	arch_flags = M_386;
    break;

  case bfd_arch_a29k:
    if (machine == 0)	arch_flags = M_29K;
    break;

  case bfd_arch_arm:
    if (machine == 0)	arch_flags = M_ARM;
    break;

  case bfd_arch_mips:
    switch (machine) {
    case 0:
    case bfd_mach_mips3000:
    case bfd_mach_mips3900:
      arch_flags = M_MIPS1;
d759 4
a762 2
    case bfd_mach_mips6000:
      arch_flags = M_MIPS2;
d764 4
a767 17
    case bfd_mach_mips4000:
    case bfd_mach_mips4010:
    case bfd_mach_mips4100:
    case bfd_mach_mips4300:
    case bfd_mach_mips4400:
    case bfd_mach_mips4600:
    case bfd_mach_mips4650:
    case bfd_mach_mips8000:
    case bfd_mach_mips10000:
    case bfd_mach_mips12000:
    case bfd_mach_mips16:
    case bfd_mach_mipsisa32:
    case bfd_mach_mips5:
    case bfd_mach_mipsisa64:
    case bfd_mach_mips_sb1:
      /* FIXME: These should be MIPS3, MIPS4, MIPS16, MIPS32, etc.  */
      arch_flags = M_MIPS2;
d769 34
a802 2
    default:
      arch_flags = M_UNKNOWN;
a803 2
    }
    break;
d805 9
a813 8
  case bfd_arch_ns32k:
    switch (machine) {
    case 0:    		arch_flags = M_NS32532; break;
    case 32032:		arch_flags = M_NS32032; break;
    case 32532:		arch_flags = M_NS32532; break;
    default:		arch_flags = M_UNKNOWN; break;
    }
    break;
d815 3
a817 3
  case bfd_arch_vax:
    *unknown = false;
    break;
d819 4
a822 3
  case bfd_arch_cris:
    if (machine == 0 || machine == 255)	arch_flags = M_CRIS;
    break;
d824 3
a826 3
  default:
    arch_flags = M_UNKNOWN;
  }
d869 11
a879 10
  switch (arch) {
  case bfd_arch_sparc:
  case bfd_arch_a29k:
  case bfd_arch_mips:
    obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;
    break;
  default:
    obj_reloc_entry_size (abfd) = RELOC_STD_SIZE;
    break;
  }
d881 1
a881 1
  return (*aout_backend_info(abfd)->set_sizes) (abfd);
d894 3
a896 3
  obj_textsec(abfd)->filepos = pos;
  if (!obj_textsec(abfd)->user_set_vma)
    obj_textsec(abfd)->vma = vma;
d898 1
a898 1
    vma = obj_textsec(abfd)->vma;
d900 2
a901 2
  pos += obj_textsec(abfd)->_raw_size;
  vma += obj_textsec(abfd)->_raw_size;
d904 1
a904 1
  if (!obj_datasec(abfd)->user_set_vma)
d907 1
a907 1
      pad = align_power (vma, obj_datasec(abfd)->alignment_power) - vma;
d909 1
a909 1
      obj_textsec(abfd)->_raw_size += pad;
d912 1
a912 1
      obj_datasec(abfd)->vma = vma;
d915 4
a918 4
    vma = obj_datasec(abfd)->vma;
  obj_datasec(abfd)->filepos = pos;
  pos += obj_datasec(abfd)->_raw_size;
  vma += obj_datasec(abfd)->_raw_size;
d921 1
a921 1
  if (!obj_bsssec(abfd)->user_set_vma)
d924 1
a924 1
      pad = align_power (vma, obj_bsssec(abfd)->alignment_power) - vma;
d926 1
a926 1
      obj_datasec(abfd)->_raw_size += pad;
d929 1
a929 1
      obj_bsssec(abfd)->vma = vma;
d943 1
a943 1
  obj_bsssec(abfd)->filepos = pos;
d946 3
a948 3
  execp->a_text = obj_textsec(abfd)->_raw_size;
  execp->a_data = obj_datasec(abfd)->_raw_size;
  execp->a_bss = obj_bsssec(abfd)->_raw_size;
d968 4
a971 4
  obj_textsec(abfd)->filepos = (ztih
				? adata(abfd).exec_bytes_size
				: adata(abfd).zmagic_disk_block_size);
  if (! obj_textsec(abfd)->user_set_vma)
d974 6
a979 6
      obj_textsec(abfd)->vma = ((abfd->flags & HAS_RELOC)
				? 0
				: (ztih
				   ? (abdp->default_text_vma
				      + adata(abfd).exec_bytes_size)
				   : abdp->default_text_vma));
d1010 1
a1010 1
  obj_textsec(abfd)->_raw_size += text_pad;
d1014 1
a1014 1
  if (!obj_datasec(abfd)->user_set_vma)
d1017 2
a1018 2
      vma = obj_textsec(abfd)->vma + obj_textsec(abfd)->_raw_size;
      obj_datasec(abfd)->vma = BFD_ALIGN (vma, adata(abfd).segment_size);
d1031 2
a1032 2
  obj_datasec(abfd)->filepos = (obj_textsec(abfd)->filepos
				+ obj_textsec(abfd)->_raw_size);
d1035 1
a1035 1
  execp->a_text = obj_textsec(abfd)->_raw_size;
d1037 1
a1037 1
    execp->a_text += adata(abfd).exec_bytes_size;
d1044 6
a1049 6
  obj_datasec(abfd)->_raw_size
    = align_power (obj_datasec(abfd)->_raw_size,
		   obj_bsssec(abfd)->alignment_power);
  execp->a_data = BFD_ALIGN (obj_datasec(abfd)->_raw_size,
			     adata(abfd).page_size);
  data_pad = execp->a_data - obj_datasec(abfd)->_raw_size;
d1052 3
a1054 3
  if (!obj_bsssec(abfd)->user_set_vma)
    obj_bsssec(abfd)->vma = (obj_datasec(abfd)->vma
			     + obj_datasec(abfd)->_raw_size);
d1062 4
a1065 4
  if (align_power (obj_bsssec(abfd)->vma, obj_bsssec(abfd)->alignment_power)
      == obj_datasec(abfd)->vma + obj_datasec(abfd)->_raw_size)
    execp->a_bss = (data_pad > obj_bsssec(abfd)->_raw_size) ? 0 :
      obj_bsssec(abfd)->_raw_size - data_pad;
d1067 1
a1067 1
    execp->a_bss = obj_bsssec(abfd)->_raw_size;
d1075 1
a1075 1
  file_ptr pos = adata(abfd).exec_bytes_size;
d1080 3
a1082 3
  obj_textsec(abfd)->filepos = pos;
  if (!obj_textsec(abfd)->user_set_vma)
    obj_textsec(abfd)->vma = vma;
d1084 3
a1086 3
    vma = obj_textsec(abfd)->vma;
  pos += obj_textsec(abfd)->_raw_size;
  vma += obj_textsec(abfd)->_raw_size;
d1089 4
a1092 4
  obj_datasec(abfd)->filepos = pos;
  if (!obj_datasec(abfd)->user_set_vma)
    obj_datasec(abfd)->vma = BFD_ALIGN (vma, adata(abfd).segment_size);
  vma = obj_datasec(abfd)->vma;
d1095 4
a1098 4
  vma += obj_datasec(abfd)->_raw_size;
  pad = align_power (vma, obj_bsssec(abfd)->alignment_power) - vma;
  obj_datasec(abfd)->_raw_size += pad;
  pos += obj_datasec(abfd)->_raw_size;
d1101 2
a1102 2
  if (!obj_bsssec(abfd)->user_set_vma)
    obj_bsssec(abfd)->vma = vma;
d1104 1
a1104 1
    vma = obj_bsssec(abfd)->vma;
d1107 3
a1109 3
  execp->a_text = obj_textsec(abfd)->_raw_size;
  execp->a_data = obj_datasec(abfd)->_raw_size;
  execp->a_bss = obj_bsssec(abfd)->_raw_size;
d1124 1
a1124 1
  if (adata(abfd).magic != undecided_magic)
d1127 3
a1129 3
  obj_textsec(abfd)->_raw_size =
    align_power(obj_textsec(abfd)->_raw_size,
		obj_textsec(abfd)->alignment_power);
d1150 1
a1150 1
    adata(abfd).magic = z_magic;
d1152 1
a1152 1
    adata(abfd).magic = n_magic;
d1154 1
a1154 1
    adata(abfd).magic = o_magic;
d1160 7
a1166 6
	      switch (adata(abfd).magic) {
	      case n_magic: str = "NMAGIC"; break;
	      case o_magic: str = "OMAGIC"; break;
	      case z_magic: str = "ZMAGIC"; break;
	      default: abort ();
	      }
d1169 6
a1174 6
	   obj_textsec(abfd)->vma, obj_textsec(abfd)->_raw_size,
	   	obj_textsec(abfd)->alignment_power,
	   obj_datasec(abfd)->vma, obj_datasec(abfd)->_raw_size,
	   	obj_datasec(abfd)->alignment_power,
	   obj_bsssec(abfd)->vma, obj_bsssec(abfd)->_raw_size,
	   	obj_bsssec(abfd)->alignment_power);
d1178 1
a1178 1
  switch (adata(abfd).magic)
d1195 5
a1199 5
	   obj_textsec(abfd)->vma, obj_textsec(abfd)->_raw_size,
	   	obj_textsec(abfd)->filepos,
	   obj_datasec(abfd)->vma, obj_datasec(abfd)->_raw_size,
	   	obj_datasec(abfd)->filepos,
	   obj_bsssec(abfd)->vma, obj_bsssec(abfd)->_raw_size);
d1224 1
a1224 1
  newsect->alignment_power = bfd_get_arch_info(abfd)->section_align_power;
d1228 3
a1230 2
    if (obj_textsec(abfd) == NULL && !strcmp(newsect->name, ".text")) {
	obj_textsec(abfd)= newsect;
d1235 3
a1237 2
    if (obj_datasec(abfd) == NULL && !strcmp(newsect->name, ".data")) {
	obj_datasec(abfd) = newsect;
d1242 3
a1244 2
    if (obj_bsssec(abfd) == NULL && !strcmp(newsect->name, ".bss")) {
	obj_bsssec(abfd) = newsect;
d1572 1
a1572 1
	reloc->relent.howto = CTOR_TABLE_RELOC_HOWTO(abfd);
d1747 1
a1747 1
  PUT_WORD(abfd, value, sym_pointer->e_value);
d1972 1
a1972 1
      if (bfd_asymbol_flavour(g) == abfd->xvec->flavour)
d1974 3
a1976 3
	  H_PUT_16 (abfd, aout_symbol(g)->desc,  nsp.e_desc);
	  H_PUT_8  (abfd, aout_symbol(g)->other, nsp.e_other);
	  H_PUT_8  (abfd, aout_symbol(g)->type,  nsp.e_type);
d2020 4
a2023 2
    for (symbase = obj_aout_symbols(abfd); counter++ < bfd_get_symcount (abfd);)
      *(location++) = (asymbol *) ( symbase++);
d2048 1
a2048 1
  PUT_WORD(abfd, g->address, natptr->r_address);
d2099 2
a2100 1
  if (bfd_header_big_endian (abfd)) {
d2104 19
a2122 19
      natptr->r_type[0] =
       (r_extern?    RELOC_STD_BITS_EXTERN_BIG: 0)
	| (r_pcrel?     RELOC_STD_BITS_PCREL_BIG: 0)
	 | (r_baserel?   RELOC_STD_BITS_BASEREL_BIG: 0)
	  | (r_jmptable?  RELOC_STD_BITS_JMPTABLE_BIG: 0)
	   | (r_relative?  RELOC_STD_BITS_RELATIVE_BIG: 0)
	    | (r_length <<  RELOC_STD_BITS_LENGTH_SH_BIG);
    } else {
	natptr->r_index[2] = r_index >> 16;
	natptr->r_index[1] = r_index >> 8;
	natptr->r_index[0] = r_index;
	natptr->r_type[0] =
	 (r_extern?    RELOC_STD_BITS_EXTERN_LITTLE: 0)
	  | (r_pcrel?     RELOC_STD_BITS_PCREL_LITTLE: 0)
	   | (r_baserel?   RELOC_STD_BITS_BASEREL_LITTLE: 0)
	    | (r_jmptable?  RELOC_STD_BITS_JMPTABLE_LITTLE: 0)
	     | (r_relative?  RELOC_STD_BITS_RELATIVE_LITTLE: 0)
	      | (r_length <<  RELOC_STD_BITS_LENGTH_SH_LITTLE);
      }
d2181 16
a2196 15
  if (bfd_header_big_endian (abfd)) {
    natptr->r_index[0] = r_index >> 16;
    natptr->r_index[1] = r_index >> 8;
    natptr->r_index[2] = r_index;
    natptr->r_type[0] =
      ((r_extern? RELOC_EXT_BITS_EXTERN_BIG: 0)
       | (r_type << RELOC_EXT_BITS_TYPE_SH_BIG));
  } else {
    natptr->r_index[2] = r_index >> 16;
    natptr->r_index[1] = r_index >> 8;
    natptr->r_index[0] = r_index;
    natptr->r_type[0] =
     (r_extern? RELOC_EXT_BITS_EXTERN_LITTLE: 0)
      | (r_type << RELOC_EXT_BITS_TYPE_SH_LITTLE);
  }
d2207 1
a2207 1
   to give the true offset from the section */
d2209 5
a2213 28
#define MOVE_ADDRESS(ad)       						\
  if (r_extern) {							\
   /* undefined symbol */						\
     cache_ptr->sym_ptr_ptr = symbols + r_index;			\
     cache_ptr->addend = ad;						\
     } else {								\
    /* defined, section relative. replace symbol with pointer to    	\
       symbol which points to section  */				\
    switch (r_index) {							\
    case N_TEXT:							\
    case N_TEXT | N_EXT:						\
      cache_ptr->sym_ptr_ptr  = obj_textsec(abfd)->symbol_ptr_ptr;	\
      cache_ptr->addend = ad  - su->textsec->vma;			\
      break;								\
    case N_DATA:							\
    case N_DATA | N_EXT:						\
      cache_ptr->sym_ptr_ptr  = obj_datasec(abfd)->symbol_ptr_ptr;	\
      cache_ptr->addend = ad - su->datasec->vma;			\
      break;								\
    case N_BSS:								\
    case N_BSS | N_EXT:							\
      cache_ptr->sym_ptr_ptr  = obj_bsssec(abfd)->symbol_ptr_ptr;	\
      cache_ptr->addend = ad - su->bsssec->vma;				\
      break;								\
    default:								\
    case N_ABS:								\
    case N_ABS | N_EXT:							\
     cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;	\
a2214 1
      break;								\
d2216 29
a2244 1
  }     								\
d2262 18
a2279 15
  if (bfd_header_big_endian (abfd)) {
    r_index =  (bytes->r_index[0] << 16)
	     | (bytes->r_index[1] << 8)
	     |  bytes->r_index[2];
    r_extern = (0 != (bytes->r_type[0] & RELOC_EXT_BITS_EXTERN_BIG));
    r_type   =       (bytes->r_type[0] & RELOC_EXT_BITS_TYPE_BIG)
				      >> RELOC_EXT_BITS_TYPE_SH_BIG;
  } else {
    r_index =  (bytes->r_index[2] << 16)
	     | (bytes->r_index[1] << 8)
	     |  bytes->r_index[0];
    r_extern = (0 != (bytes->r_type[0] & RELOC_EXT_BITS_EXTERN_LITTLE));
    r_type   =       (bytes->r_type[0] & RELOC_EXT_BITS_TYPE_LITTLE)
				      >> RELOC_EXT_BITS_TYPE_SH_LITTLE;
  }
d2299 1
a2299 1
  MOVE_ADDRESS(GET_SWORD(abfd, bytes->r_addend));
d2321 26
a2346 23
  if (bfd_header_big_endian (abfd)) {
    r_index =  (bytes->r_index[0] << 16)
      | (bytes->r_index[1] << 8)
	|  bytes->r_index[2];
    r_extern  = (0 != (bytes->r_type[0] & RELOC_STD_BITS_EXTERN_BIG));
    r_pcrel   = (0 != (bytes->r_type[0] & RELOC_STD_BITS_PCREL_BIG));
    r_baserel = (0 != (bytes->r_type[0] & RELOC_STD_BITS_BASEREL_BIG));
    r_jmptable= (0 != (bytes->r_type[0] & RELOC_STD_BITS_JMPTABLE_BIG));
    r_relative= (0 != (bytes->r_type[0] & RELOC_STD_BITS_RELATIVE_BIG));
    r_length  =       (bytes->r_type[0] & RELOC_STD_BITS_LENGTH_BIG)
      			>> RELOC_STD_BITS_LENGTH_SH_BIG;
  } else {
    r_index =  (bytes->r_index[2] << 16)
      | (bytes->r_index[1] << 8)
	|  bytes->r_index[0];
    r_extern  = (0 != (bytes->r_type[0] & RELOC_STD_BITS_EXTERN_LITTLE));
    r_pcrel   = (0 != (bytes->r_type[0] & RELOC_STD_BITS_PCREL_LITTLE));
    r_baserel = (0 != (bytes->r_type[0] & RELOC_STD_BITS_BASEREL_LITTLE));
    r_jmptable= (0 != (bytes->r_type[0] & RELOC_STD_BITS_JMPTABLE_LITTLE));
    r_relative= (0 != (bytes->r_type[0] & RELOC_STD_BITS_RELATIVE_LITTLE));
    r_length  =       (bytes->r_type[0] & RELOC_STD_BITS_LENGTH_LITTLE)
      			>> RELOC_STD_BITS_LENGTH_SH_LITTLE;
  }
d2348 2
a2349 2
  howto_idx = r_length + 4 * r_pcrel + 8 * r_baserel
	      + 16 * r_jmptable + 32 * r_relative;
d2368 1
a2368 1
  MOVE_ADDRESS(0);
d2395 1
a2395 1
    reloc_size = exec_hdr(abfd)->a_drsize;
d2397 1
a2397 1
    reloc_size = exec_hdr(abfd)->a_trsize;
d2497 2
a2498 1
	MY_swap_std_reloc_out(abfd, *generic, (struct reloc_std_external *)natptr);
d2503 1
a2503 1
      bfd_release(abfd, native);
d2531 8
a2538 5
  if (section->flags & SEC_CONSTRUCTOR) {
    arelent_chain *chain = section->constructor_chain;
    for (count = 0; count < section->reloc_count; count ++) {
      *relptr ++ = &chain->relent;
      chain = chain->next;
d2540 3
a2542 3
  }
  else {
    tblptr = section->relocation;
d2544 5
a2548 5
    for (count = 0; count++ < section->reloc_count;)
      {
	*relptr++ = tblptr++;
      }
  }
d2559 9
a2567 7
  if (bfd_get_format (abfd) != bfd_object) {
    bfd_set_error (bfd_error_invalid_operation);
    return -1;
  }
  if (asect->flags & SEC_CONSTRUCTOR) {
    return (sizeof (arelent *) * (asect->reloc_count+1));
  }
d2571 1
a2571 1
	    * ((exec_hdr(abfd)->a_drsize / obj_reloc_entry_size (abfd))
d2576 1
a2576 1
	    * ((exec_hdr(abfd)->a_trsize / obj_reloc_entry_size (abfd))
d2617 1
a2617 1
      int type_code = aout_symbol(symbol)->type & 0xff;
d2628 2
a2629 2
      ret->stab_other = (unsigned) (aout_symbol(symbol)->other & 0xff);
      ret->stab_desc = (unsigned) (aout_symbol(symbol)->desc & 0xffff);
d2643 3
a2645 21
  switch (how) {
  case bfd_print_symbol_name:
    if (symbol->name)
      fprintf (file,"%s", symbol->name);
    break;
  case bfd_print_symbol_more:
    fprintf (file,"%4x %2x %2x",(unsigned) (aout_symbol(symbol)->desc & 0xffff),
	    (unsigned) (aout_symbol(symbol)->other & 0xff),
	    (unsigned) (aout_symbol(symbol)->type));
    break;
  case bfd_print_symbol_all:
    {
   const char *section_name = symbol->section->name;

      bfd_print_symbol_vandf (abfd, (PTR)file, symbol);

      fprintf (file," %-5s %04x %02x %02x",
	      section_name,
	      (unsigned) (aout_symbol(symbol)->desc & 0xffff),
	      (unsigned) (aout_symbol(symbol)->other & 0xff),
	      (unsigned) (aout_symbol(symbol)->type  & 0xff));
d2647 23
a2669 1
        fprintf (file," %s", symbol->name);
a2670 2
    break;
  }
d2778 21
a2798 18
  if (symbols != (asymbol **)NULL) {
    for (p = symbols; *p; p++) {
      aout_symbol_type  *q = (aout_symbol_type *) (*p);
    next:
      switch (q->type){
      case N_TEXT:
	/* If this looks like a file name symbol, and it comes after
           the line number we have found so far, but before the
           offset, then we have probably not found the right line
           number.  */
	if (q->symbol.value <= offset
	    && ((q->symbol.value > low_line_vma
		 && (line_file_name != NULL
		     || *line_ptr != 0))
		|| (q->symbol.value > low_func_vma
		    && func != NULL)))
	  {
	    const char *symname;
d2800 13
a2812 13
	    symname = q->symbol.name;
	    if (strcmp (symname + strlen (symname) - 2, ".o") == 0)
	      {
		if (q->symbol.value > low_line_vma)
		  {
		    *line_ptr = 0;
		    line_file_name = NULL;
		  }
		if (q->symbol.value > low_func_vma)
		  func = NULL;
	      }
	  }
	break;
d2814 14
a2827 14
      case N_SO:
	/* If this symbol is less than the offset, but greater than
           the line number we have found so far, then we have not
           found the right line number.  */
	if (q->symbol.value <= offset)
	  {
	    if (q->symbol.value > low_line_vma)
	      {
		*line_ptr = 0;
		line_file_name = NULL;
	      }
	    if (q->symbol.value > low_func_vma)
	      func = NULL;
	  }
d2829 18
a2846 18
	main_file_name = current_file_name = q->symbol.name;
	/* Look ahead to next symbol to check if that too is an N_SO.  */
	p++;
	if (*p == NULL)
	  break;
	q = (aout_symbol_type *) (*p);
	if (q->type != (int)N_SO)
	  goto next;

	/* Found a second N_SO  First is directory; second is filename.  */
	directory_name = current_file_name;
	main_file_name = current_file_name = q->symbol.name;
	if (obj_textsec(abfd) != section)
	  goto done;
	break;
      case N_SOL:
	current_file_name = q->symbol.name;
	break;
d2848 1
a2848 1
      case N_SLINE:
d2850 26
a2875 23
      case N_DSLINE:
      case N_BSLINE:
	/* We'll keep this if it resolves nearer than the one we have
           already.  */
	if (q->symbol.value >= low_line_vma
	    && q->symbol.value <= offset)
	  {
	    *line_ptr = q->desc;
	    low_line_vma = q->symbol.value;
	    line_file_name = current_file_name;
	    line_directory_name = directory_name;
	  }
	break;
      case N_FUN:
	{
	  /* We'll keep this if it is nearer than the one we have already */
	  if (q->symbol.value >= low_func_vma &&
	      q->symbol.value <= offset) {
	    low_func_vma = q->symbol.value;
	    func = (asymbol *)q;
	  }
	  else if (q->symbol.value > offset)
	    goto done;
a2876 2
	break;
      }
a2877 1
  }
d2951 1
a2951 1
  return adata(abfd).exec_bytes_size;
d3579 2
a3580 2
#define aout_link_includes_lookup(table, string, create, copy) \
  ((struct aout_link_includes_entry *) \
d4848 1
a4848 1
      howto = MY_reloc_howto(input_bfd, rel, r_index, r_extern, r_pcrel);
d5634 2
a5635 2
      MY_put_reloc(finfo->output_bfd, r_extern, r_index, p->offset, howto,
		   &srel);
@


1.24
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@a122 1
#include <ctype.h>
d125 1
d4410 1
a4410 1
			      while (isdigit ((unsigned char) *s))
@


1.23
log
@2001-08-31  Eric Christopher  <echristo@@redhat.com>
	    Jason Eckhardt  <jle@@redhat.com>

	* bfd/archures.c: Add mipsisa32 and mipsisa64. Remove mips32,
	mips32_4k and mips64.
	* bfd/aoutx.h: Remove bfd_mach_mips32, bfd_mach_mips32_4k,
	bfd_mach_mips64.  Add bfd_mach_mipsisa32, bfd_mach_mipsisa64.
	* bfd/cpu-mips.c: Ditto.
	* bfd/elf32-mips.c (_bfd_mips_elf_final_write_processing): Ditto.
	* bfd/bfd-in2.h: Regenerate.
@
text
@d370 1
a370 1
  execp->a_info   = bfd_h_get_32 (abfd, bytes->e_info);
d405 1
a405 1
  bfd_h_put_32 (abfd, execp->a_info  , bytes->e_info);
d458 1
d460 1
a460 1
  rawptr = (struct aout_data_struct  *) bfd_zalloc (abfd, sizeof (struct aout_data_struct ));
d678 2
a679 1
  struct aout_data_struct  *rawptr;
d683 1
a683 3
  /* Use an intermediate variable for clarity */
  rawptr = (struct aout_data_struct *)bfd_zalloc (abfd, sizeof (struct aout_data_struct ));

d690 3
a692 3
  obj_textsec (abfd) = (asection *)NULL;
  obj_datasec (abfd) = (asection *)NULL;
  obj_bsssec (abfd) = (asection *)NULL;
d946 1
a946 1
  CONST struct aout_backend_data *abdp;
d1274 1
a1274 1
	  || bfd_write (location, 1, count, abfd) != count)
d1291 1
d1306 1
a1306 1
	      bfd_malloc ((size_t) count * EXTERNAL_NLIST_SIZE));
d1310 1
d1312 1
a1312 2
	  || (bfd_read (syms, 1, exec_hdr (abfd)->a_syms, abfd)
	      != exec_hdr (abfd)->a_syms))
d1329 1
d1333 1
a1333 2
	  || (bfd_read ((PTR) string_chars, BYTES_IN_WORD, 1, abfd)
	      != BYTES_IN_WORD))
d1343 1
a1343 1
      strings = (char *) bfd_malloc ((size_t) stringsize + 1);
d1349 2
a1350 3
      if (bfd_read (strings + BYTES_IN_WORD, 1, stringsize - BYTES_IN_WORD,
		    abfd)
	  != stringsize - BYTES_IN_WORD)
d1481 1
d1498 2
a1499 1
	    copy = bfd_alloc (abfd, strlen (cache_ptr->symbol.name) + 1);
d1509 2
a1510 1
	reloc = (arelent_chain *) bfd_alloc (abfd, sizeof (arelent_chain));
d1741 2
a1742 2
  aout_symbol_type  *new =
    (aout_symbol_type *)bfd_zalloc (abfd, sizeof (aout_symbol_type));
d1785 3
a1787 3
      in->desc = bfd_h_get_16 (abfd, ext->e_desc);
      in->other = bfd_h_get_8 (abfd, ext->e_other);
      in->type = bfd_h_get_8 (abfd,  ext->e_type);
d1810 1
a1810 1
  size_t cached_size;
d1821 2
a1822 2
  cached_size = (obj_aout_external_sym_count (abfd)
		 * sizeof (aout_symbol_type));
d1827 1
a1827 1
    memset (cached, 0, cached_size);
d1921 1
d1925 1
a1925 1
  if (bfd_write ((PTR) buffer, 1, BYTES_IN_WORD, abfd) != BYTES_IN_WORD)
d1948 1
d1957 3
a1959 3
	  bfd_h_put_16(abfd, aout_symbol(g)->desc,  nsp.e_desc);
	  bfd_h_put_8(abfd, aout_symbol(g)->other,  nsp.e_other);
	  bfd_h_put_8(abfd, aout_symbol(g)->type,  nsp.e_type);
d1963 3
a1965 3
	  bfd_h_put_16(abfd,0, nsp.e_desc);
	  bfd_h_put_8(abfd, 0, nsp.e_other);
	  bfd_h_put_8(abfd, 0, nsp.e_type);
d1971 2
a1972 2
      if (bfd_write((PTR)&nsp,1,EXTERNAL_NLIST_SIZE, abfd)
	  != EXTERNAL_NLIST_SIZE)
d2120 1
a2120 1
  unsigned int r_addend;
d2290 1
a2290 1
  cache_ptr->address = bfd_h_get_32 (abfd, bytes->r_address);
d2348 1
a2348 1
  unsigned int count;
d2355 1
d2382 2
a2383 1
  reloc_cache = (arelent *) bfd_malloc ((size_t) (count * sizeof (arelent)));
d2386 1
a2386 1
  memset (reloc_cache, 0, count * sizeof (arelent));
d2388 1
a2388 1
  relocs = bfd_malloc ((size_t) reloc_size);
d2395 1
a2395 1
  if (bfd_read (relocs, 1, reloc_size, abfd) != reloc_size)
d2405 1
a2405 2
      register struct reloc_ext_external *rptr =
	(struct reloc_ext_external *) relocs;
d2409 1
a2409 1
			      bfd_get_symcount (abfd));
d2413 1
a2413 2
      register struct reloc_std_external *rptr =
	(struct reloc_std_external *) relocs;
d2417 1
a2417 1
			      bfd_get_symcount (abfd));
d2440 1
a2440 1
  size_t natsize;
d2446 1
a2446 1
  natsize = each_size * count;
d2469 5
a2473 4
  if ( bfd_write ((PTR) native, 1, natsize, abfd) != natsize) {
    bfd_release(abfd, native);
    return false;
  }
d2618 1
a2618 1
   CONST char *section_name = symbol->section->name;
d2719 2
a2720 2
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
d2725 5
a2729 5
  CONST char *directory_name = NULL;
  CONST char *main_file_name = NULL;
  CONST char *current_file_name = NULL;
  CONST char *line_file_name = NULL; /* Value of current_file_name at line number.  */
  CONST char *line_directory_name = NULL; /* Value of directory_name at line number.  */
d2733 1
a2733 1
  size_t filelen, funclen;
d2882 1
a2882 1
      char *p;
d2895 3
a2897 3
      p = strchr (buf, ':');
      if (p != NULL)
	*p = '\0';
d3007 1
d3009 1
a3009 2
  ret = ((struct aout_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct aout_link_hash_table)));
d3145 1
a3145 1
      int type = bfd_h_get_8 (abfd, p->e_type);
d3309 1
d3330 2
a3331 4
  sym_hash = ((struct aout_link_hash_entry **)
	      bfd_alloc (abfd,
			 ((size_t) sym_count
			  * sizeof (struct aout_link_hash_entry *))));
d3353 1
a3353 1
      type = bfd_h_get_8 (abfd, p->e_type);
d3643 3
a3645 3
  size_t max_contents_size;
  size_t max_relocs_size;
  size_t max_sym_count;
d3677 1
a3677 1
      size_t sz;
d3946 1
d3949 3
a3951 6
      if (bfd_seek (abfd,
		    (obj_datasec (abfd)->filepos
		     + exec_hdr (abfd)->a_data
		     - 1),
		    SEEK_SET) != 0
	  || bfd_write (&b, 1, 1, abfd) != 1)
d4072 3
a4074 3
      bfd_h_put_8 (output_bfd, N_TEXT, outsym->e_type);
      bfd_h_put_8 (output_bfd, 0, outsym->e_other);
      bfd_h_put_16 (output_bfd, (bfd_vma) 0, outsym->e_desc);
d4095 1
a4095 1
  memset (symbol_map, 0, sym_count * sizeof *symbol_map);
d4118 1
a4118 1
      type = bfd_h_get_8 (input_bfd, sym->e_type);
d4389 1
a4389 1
		  incl_type = bfd_h_get_8 (input_bfd, incl_sym->e_type);
d4458 1
a4458 1
		      incl_type = bfd_h_get_8 (input_bfd, incl_sym->e_type);
d4479 3
a4481 5
      bfd_h_put_8 (output_bfd, type, outsym->e_type);
      bfd_h_put_8 (output_bfd, bfd_h_get_8 (input_bfd, sym->e_other),
		   outsym->e_other);
      bfd_h_put_16 (output_bfd, bfd_h_get_16 (input_bfd, sym->e_desc),
		    outsym->e_desc);
d4507 1
a4507 1
      bfd_size_type outsym_count;
d4511 4
a4514 5
      outsym_count = outsym - finfo->output_syms;
      if (bfd_write ((PTR) finfo->output_syms,
		     (bfd_size_type) EXTERNAL_NLIST_SIZE,
		     (bfd_size_type) outsym_count, output_bfd)
	  != outsym_count * EXTERNAL_NLIST_SIZE)
d4516 1
a4516 1
      finfo->symoff += outsym_count * EXTERNAL_NLIST_SIZE;
d4536 1
d4613 3
a4615 3
  bfd_h_put_8 (output_bfd, type, outsym.e_type);
  bfd_h_put_8 (output_bfd, 0, outsym.e_other);
  bfd_h_put_16 (output_bfd, 0, outsym.e_desc);
d4618 1
a4618 1
  if (indx == (bfd_size_type) -1)
d4626 1
d4628 1
a4628 2
      || bfd_write ((PTR) &outsym, (bfd_size_type) EXTERNAL_NLIST_SIZE,
		    (bfd_size_type) 1, output_bfd) != EXTERNAL_NLIST_SIZE)
d4672 1
a4672 1
	      || bfd_read (relocs, 1, rel_size, input_bfd) != rel_size)
d4697 1
a4697 1
				  input_section->output_offset,
d4707 1
a4707 2
      if (bfd_write (relocs, (bfd_size_type) 1, rel_size, finfo->output_bfd)
	  != rel_size)
d5365 1
a5365 1
	      type = bfd_h_get_8 (input_bfd, sym->e_type);
d5526 1
d5656 1
a5656 1
				      pr->addend, buf);
d5679 2
a5680 4
	  ok = bfd_set_section_contents (finfo->output_bfd, o,
					 (PTR) buf,
					 (file_ptr) p->offset,
					 size);
d5713 1
a5713 1
      PUT_WORD (finfo->output_bfd, pr->addend, erel.r_addend);
d5719 1
d5721 1
a5721 4
      || (bfd_write (rel_ptr, (bfd_size_type) 1,
		     obj_reloc_entry_size (finfo->output_bfd),
		     finfo->output_bfd)
	  != obj_reloc_entry_size (finfo->output_bfd)))
@


1.22
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d782 1
a782 2
    case bfd_mach_mips32:
    case bfd_mach_mips32_4k:
d784 1
a784 1
    case bfd_mach_mips64:
@


1.21
log
@Add missing protypes
@
text
@d2593 2
a2594 2
NAME(aout,print_symbol) (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d2615 1
a2615 1
      bfd_print_symbol_vandf((PTR)file,symbol);
@


1.20
log
@Only pad the tesxt section if the data section is going to follow it.
@
text
@d142 1
d2557 1
a2557 1
 alent *
@


1.19
log
@Add MIPS r12k support
@
text
@d1009 8
a1016 4
      text_pad = (obj_datasec(abfd)->vma
		  - obj_textsec(abfd)->vma
		  - obj_textsec(abfd)->_raw_size);
      obj_textsec(abfd)->_raw_size += text_pad;
@


1.18
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d779 1
@


1.17
log
@Update copyright notices
@
text
@d4344 1
@


1.16
log
@2001-02-27  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (NAME(aout,bfd_free_cached_info)): Return true if
	abfd->tdata.aout_data == NULL.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.15
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd.c: Likewise.
	* bfd-in2.h: Likewise.
	* bfd-in.h: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* dwarf2.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* format.c: Likewise.
	* freebsd.h: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
@
text
@d2909 2
a2910 1
  if (bfd_get_format (abfd) != bfd_object)
@


1.15.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,
   2001
@


1.15.2.2
log
@Merge from mainline.
@
text
@a778 1
    case bfd_mach_mips12000:
d2910 1
a2910 2
  if (bfd_get_format (abfd) != bfd_object
      || abfd->tdata.aout_data == NULL)
@


1.14
log
@Add MIPS SB1 machine
@
text
@a1979 1

a1996 1

a2538 1

@


1.13
log
@Add MIPS V and MIPS 64 machine numbers
@
text
@d783 1
@


1.12
log
@Add MIPS32 as a seperate MIPS architecture
@
text
@d781 2
@


1.11
log
@2000-11-28  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffswap.h: Likewise.
	* corefile.c: Likewise.
@
text
@d779 3
a781 1
      /* FIXME: These should be MIPS3 or MIPS4.  */
@


1.10
log
@2000-11-20  Kazu Hirata  <kazu@@hxi.com>

	* aix386-core.c: Fix formatting.
	* aout-adobe.c: Likewise.
	* aout-arm.c: Likewise.
	* aout-encap.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aout-target.h: Likewise.
	* aout-tic30.c: Likewise.
	* aoutf1.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
@
text
@d2572 1
a2572 1
	  sprintf(buf, "(%d)", type_code);
d2595 1
a2595 1
      fprintf(file,"%s", symbol->name);
d2598 1
a2598 1
    fprintf(file,"%4x %2x %2x",(unsigned) (aout_symbol(symbol)->desc & 0xffff),
d2608 1
a2608 1
      fprintf(file," %-5s %04x %02x %02x",
d2614 1
a2614 1
        fprintf(file," %s", symbol->name);
@


1.9
log
@2000-11-07  Kazu Hirata  <kazu@@hxi.com>

	* aix386-core.c: Fix formatting.
	* aoutf1.h: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* armnetbsd.c: Likewise.
@
text
@d270 1
a270 1
#define TABLE_SIZE(TABLE)	(sizeof(TABLE)/sizeof(TABLE[0]))
d438 1
a438 1
	  const bfd_target *(*callback_to_real_object_p)());
d603 1
a603 1
  result = (*callback_to_real_object_p)(abfd);
d1985 1
a1985 1
    if (!NAME(aout,slurp_symbol_table)(abfd))
d1989 1
a1989 1
      *(location++) = (asymbol *)( symbase++);
d2481 1
a2481 1
  if (!(tblptr || NAME(aout,slurp_reloc_table)(abfd, section, symbols)))
d2542 1
a2542 1
  if (!NAME(aout,slurp_symbol_table)(abfd))
d2577 2
a2578 2
      ret->stab_other = (unsigned)(aout_symbol(symbol)->other & 0xff);
      ret->stab_desc = (unsigned)(aout_symbol(symbol)->desc & 0xffff);
d2598 3
a2600 3
    fprintf(file,"%4x %2x %2x",(unsigned)(aout_symbol(symbol)->desc & 0xffff),
	    (unsigned)(aout_symbol(symbol)->other & 0xff),
	    (unsigned)(aout_symbol(symbol)->type));
d2610 3
a2612 3
	      (unsigned)(aout_symbol(symbol)->desc & 0xffff),
	      (unsigned)(aout_symbol(symbol)->other & 0xff),
	      (unsigned)(aout_symbol(symbol)->type  & 0xff));
d2727 1
a2727 1
      aout_symbol_type  *q = (aout_symbol_type *)(*p);
d2778 1
a2778 1
	q = (aout_symbol_type *)(*p);
@


1.8
log
@	* Makefile.am (ALL_MACHINES): Add cpu-cris.lo.
	(ALL_MACHINES_CFILES): Add cpu-cris.c.
	(BFD32_BACKENDS): Add aout-cris.lo and elf32-cris.lo.
	(BFD32_BACKENDS_CFILES): Add aout-cris.c and elf32-cris.c.
	(cpu-cris.lo, aout-cris.lo, elf32-cris.lo): New rules.
	* Makefile.in: Rebuild.
	* aclocal.m4: Rebuild.
	* aoutx.h (NAME(aout,machine_type)): Add case for bfd_arch_cris.
	* archures.c (enum bfd_architecture): Add bfd_arch_cris.
	(bfd_cris_arch): Declare.
	(bfd_archures_list): Add bfd_cris_arch.
	* bfd-in2.h: Rebuild.
	* config.bfd: (cris-*-*): New target.
	* configure.in (bfd_elf32_cris_vec, cris_aout_vec): New vectors.
	* configure: Rebuild.
	* elf.c (prep_headers): Add bfd_arch_cris.
	* libbfd.h: Rebuild.
	* libaout.h (enum machine_type): Add M_CRIS.
	* reloc.c: Add CRIS relocations.
	* targets.c (bfd_target bfd_elf32_cris_vec, cris_aout_vec):
	Declare.
	(bfd_target_vect): Add bfd_elf32_cris_vec and cris_aout_vec.
	* cpu-cris.c, aout-cris.c, elf32-cris.c: New files.
	* po/POTFILES.in, po/bfd.pot: Regenerate.
@
text
@a25 1

d365 1
a365 1
     are memcmp'd, and thus the contents do matter. */
d402 1
a402 1
  /* Now fill in fields in the raw data, from the fields in the exec struct. */
d519 1
a519 1
  /* The default symbol entry size is that of traditional Unix. */
d618 1
a618 1
     sets the entry point, and that is likely to be non-zero for most systems. */
a694 1

d758 1
a758 1
    
a814 1

d941 1
a941 1
  
d1009 1
a1009 1
  
d1054 1
a1054 1
  
d1069 1
a1069 1
  
d1114 1
a1114 1
     the text. */
a1200 1

d1310 1
a1310 1
      
d1639 1
a1639 1
	 bfd_get_filename (abfd), 
d1721 1
a1721 1
/* Native-level interface to symbols. */
d1788 1
a1788 1
   hold them all plus all the cached symbol entries. */
d1996 1
a1996 1
/* Output standard relocation information to a file in target byte order. */
a2038 1

a2090 1

d2092 1
a2092 1
/* Output extended relocation information to a file in target byte order. */
a2173 1

a2547 1
/*ARGSUSED*/
a2555 1
/*ARGSUSED*/
a2582 1
/*ARGSUSED*/
a2605 1

d2714 2
a2715 2
  CONST char *line_file_name = NULL; /* Value of current_file_name at line number. */
  CONST char *line_directory_name = NULL; /* Value of directory_name at line number. */
d2774 1
a2774 1
	/* Look ahead to next symbol to check if that too is an N_SO. */
d2782 1
a2782 1
	/* Found a second N_SO  First is directory; second is filename. */
a2889 1
/*ARGSUSED*/
d4133 1
a4133 1
	     external symbol. */
d4797 1
a4797 1
#else      
@


1.7
log
@2000-07-15  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (translate_to_native_sym_flags): Handle BSF_LOCAL.
@
text
@d803 4
@


1.6
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d1684 2
@


1.5
log
@	* aoutx.h (NAME(aout,reloc_type_lookup)): Add BFD_RELOC_8 and
	BFD_RELOC_16 to switch for extended relocs.
	(MY_swap_ext_reloc_in): New.
	(MY_swap_ext_reloc_out): New.
	(NAME(aout,slurp_reloc_table)): Use MY_swap_ext_reloc_in rather
	than NAME(aout,swap_ext_reloc_in) for extended relocs.
	(NAME(aout,squirt_out_relocs)): Similarly use
	MY_swap_ext_reloc_out.
	(aout_link_reloc_link_order): Use MY_put_ext_reloc if defined.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d2836 1
a2836 1
      || main_file_name[0] == '/'
d2860 1
a2860 1
      if (main_file_name[0] == '/' || directory_name == NULL)
@


1.4
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d168 4
d176 4
d294 2
d2394 2
a2395 2
	NAME(aout,swap_ext_reloc_in) (abfd, rptr, cache_ptr, symbols,
				      bfd_get_symcount (abfd));
d2445 2
a2446 1
	NAME(aout,swap_ext_reloc_out) (abfd, *generic, (struct reloc_ext_external *)natptr);
d5685 4
d5711 1
@


1.4.2.1
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d2825 1
a2825 1
      || IS_ABSOLUTE_PATH (main_file_name)
d2849 1
a2849 1
      if (IS_ABSOLUTE_PATH (main_file_name) || directory_name == NULL)
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d5032 2
a5033 1
		     (finfo->info, name, input_bfd, input_section, r_addr)))
d5435 2
a5436 1
		     (finfo->info, name, input_bfd, input_section, r_addr)))
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf1.c (parse_line_table): Change eachLine to unsigned long.
	(dwarf1_unit_find_nearest_line): Change i to unsigned long.
@
text
@d231 5
a235 5
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
d237 15
a251 15
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
d253 7
a259 7
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
{ -1, 0, 0, 0, false, 0, complain_overflow_dont, NULL, NULL, false, 0, 0, false },
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d231 5
a235 5
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
d237 15
a251 8
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 }, { -1 }, { -1 }, { -1 }, { -1 }, { -1 }, { -1 }, { -1 },
d253 7
a259 7
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
{ -1 },
d1082 1
a1082 1
     file_ptr *text_end;
d2541 2
a2542 2
     bfd *ignore_abfd;
     asymbol *ignore_symbol;
d2544 1
a2544 1
return (alent *)NULL;
d2550 1
a2550 1
     bfd *ignore_abfd;
d2578 1
a2578 1
     bfd *ignore_abfd;
d2888 1
a2888 1
     boolean execable;
d4729 2
d5505 1
a5505 1
  file_ptr *reloff_ptr;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

